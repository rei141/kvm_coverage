<doctype html>
<html lang="ja">
<head>
<meta charset="utf-8">
<script src="https://cdn.rawgit.com/google/code-prettify/master/loader/run_prettify.js"></script>
<style>
    code{
        font-family:Monaco, Menlo, Consolas, 'Courier New', Courier, monospace, sans-serif;
        font-size: 14px;
        line-height: 18px;
        overflow: auto;
        resize: horizontal;
    }
    code_line{
        font-family: Monaco, Menlo, Consolas, 'Courier New', Courier, monospace, sans-serif;;
        font-size: 14px;
        line-height: 18px;
        overflow: auto;
        resize: horizontal;
        color:#303134;
    }
    blue{
        background-color:#BEEDE8;
    }
    yellow{
        background-color:#FFFF99;
    }
    red{
        background-color:#FF99AC;
    }
</style>

</head>
<body>
<table summary='blob content' class='blob' cellspacing="15">
<tr><td align="right"><pre><code_line>1.<br>2.<br>3.<br>4.<br>5.<br>6.<br>7.<br>8.<br>9.<br>10.<br>11.<br>12.<br>13.<br>14.<br>15.<br>16.<br>17.<br>18.<br>19.<br>20.<br>21.<br>22.<br>23.<br>24.<br>25.<br>26.<br>27.<br>28.<br>29.<br>30.<br>31.<br>32.<br>33.<br>34.<br>35.<br>36.<br>37.<br>38.<br>39.<br>40.<br>41.<br>42.<br>43.<br>44.<br>45.<br>46.<br>47.<br>48.<br>49.<br>50.<br>51.<br>52.<br>53.<br>54.<br>55.<br>56.<br>57.<br>58.<br>59.<br>60.<br>61.<br>62.<br>63.<br>64.<br>65.<br>66.<br>67.<br>68.<br>69.<br>70.<br>71.<br>72.<br>73.<br>74.<br>75.<br>76.<br>77.<br>78.<br>79.<br>80.<br>81.<br>82.<br>83.<br>84.<br>85.<br>86.<br>87.<br>88.<br>89.<br>90.<br>91.<br>92.<br>93.<br>94.<br>95.<br>96.<br>97.<br>98.<br>99.<br>100.<br>101.<br>102.<br>103.<br>104.<br>105.<br>106.<br>107.<br>108.<br>109.<br>110.<br>111.<br>112.<br>113.<br>114.<br>115.<br>116.<br>117.<br>118.<br>119.<br>120.<br>121.<br>122.<br>123.<br>124.<br>125.<br>126.<br>127.<br>128.<br>129.<br>130.<br>131.<br>132.<br>133.<br>134.<br>135.<br>136.<br>137.<br>138.<br>139.<br>140.<br>141.<br>142.<br>143.<br>144.<br>145.<br>146.<br>147.<br>148.<br>149.<br>150.<br>151.<br>152.<br>153.<br>154.<br>155.<br>156.<br>157.<br>158.<br>159.<br>160.<br>161.<br>162.<br>163.<br>164.<br>165.<br>166.<br>167.<br>168.<br>169.<br>170.<br>171.<br>172.<br>173.<br>174.<br>175.<br>176.<br>177.<br>178.<br>179.<br>180.<br>181.<br>182.<br>183.<br>184.<br>185.<br>186.<br>187.<br>188.<br>189.<br>190.<br>191.<br>192.<br>193.<br>194.<br>195.<br>196.<br>197.<br>198.<br>199.<br>200.<br>201.<br>202.<br>203.<br>204.<br>205.<br>206.<br>207.<br>208.<br>209.<br>210.<br>211.<br>212.<br>213.<br>214.<br>215.<br>216.<br>217.<br>218.<br>219.<br>220.<br>221.<br>222.<br>223.<br>224.<br>225.<br>226.<br>227.<br>228.<br>229.<br>230.<br>231.<br>232.<br>233.<br>234.<br>235.<br>236.<br>237.<br>238.<br>239.<br>240.<br>241.<br>242.<br>243.<br>244.<br>245.<br>246.<br>247.<br>248.<br>249.<br>250.<br>251.<br>252.<br>253.<br>254.<br>255.<br>256.<br>257.<br>258.<br>259.<br>260.<br>261.<br>262.<br>263.<br>264.<br>265.<br>266.<br>267.<br>268.<br>269.<br>270.<br>271.<br>272.<br>273.<br>274.<br>275.<br>276.<br>277.<br>278.<br>279.<br>280.<br>281.<br>282.<br>283.<br>284.<br>285.<br>286.<br>287.<br>288.<br>289.<br>290.<br>291.<br>292.<br>293.<br>294.<br>295.<br>296.<br>297.<br>298.<br>299.<br>300.<br>301.<br>302.<br>303.<br>304.<br>305.<br>306.<br>307.<br>308.<br>309.<br>310.<br>311.<br>312.<br>313.<br>314.<br>315.<br>316.<br>317.<br>318.<br>319.<br>320.<br>321.<br>322.<br>323.<br>324.<br>325.<br>326.<br>327.<br>328.<br>329.<br>330.<br>331.<br>332.<br>333.<br>334.<br>335.<br>336.<br>337.<br>338.<br>339.<br>340.<br>341.<br>342.<br>343.<br>344.<br>345.<br>346.<br>347.<br>348.<br>349.<br>350.<br>351.<br>352.<br>353.<br>354.<br>355.<br>356.<br>357.<br>358.<br>359.<br>360.<br>361.<br>362.<br>363.<br>364.<br>365.<br>366.<br>367.<br>368.<br>369.<br>370.<br>371.<br>372.<br>373.<br>374.<br>375.<br>376.<br>377.<br>378.<br>379.<br>380.<br>381.<br>382.<br>383.<br>384.<br>385.<br>386.<br>387.<br>388.<br>389.<br>390.<br>391.<br>392.<br>393.<br>394.<br>395.<br>396.<br>397.<br>398.<br>399.<br>400.<br>401.<br>402.<br>403.<br>404.<br>405.<br>406.<br>407.<br>408.<br>409.<br>410.<br>411.<br>412.<br>413.<br>414.<br>415.<br>416.<br>417.<br>418.<br>419.<br>420.<br>421.<br>422.<br>423.<br>424.<br>425.<br>426.<br>427.<br>428.<br>429.<br>430.<br>431.<br>432.<br>433.<br>434.<br>435.<br>436.<br>437.<br>438.<br>439.<br>440.<br>441.<br>442.<br>443.<br>444.<br>445.<br>446.<br>447.<br>448.<br>449.<br>450.<br>451.<br>452.<br></code_line></pre></td>
<td class='lines'><pre><code class="prettyprint">/* SPDX-License-Identifier: GPL-2.0 */
#ifndef _ASM_X86_DESC_H
#define _ASM_X86_DESC_H

#include &lt;asm/desc_defs.h&gt;
#include &lt;asm/ldt.h&gt;
#include &lt;asm/mmu.h&gt;
#include &lt;asm/fixmap.h&gt;
#include &lt;asm/irq_vectors.h&gt;
#include &lt;asm/cpu_entry_area.h&gt;

#include &lt;linux/debug_locks.h&gt;
#include &lt;linux/smp.h&gt;
#include &lt;linux/percpu.h&gt;

static inline void fill_ldt(struct desc_struct *desc, const struct user_desc *info)
{
	desc-&gt;limit0		= info-&gt;limit &amp; 0x0ffff;

	desc-&gt;base0		= (info-&gt;base_addr &amp; 0x0000ffff);
	desc-&gt;base1		= (info-&gt;base_addr &amp; 0x00ff0000) &gt;&gt; 16;

	desc-&gt;type		= (info-&gt;read_exec_only ^ 1) &lt;&lt; 1;
	desc-&gt;type	       |= info-&gt;contents &lt;&lt; 2;
	/* Set the ACCESS bit so it can be mapped RO */
	desc-&gt;type	       |= 1;

	desc-&gt;s			= 1;
	desc-&gt;dpl		= 0x3;
	desc-&gt;p			= info-&gt;seg_not_present ^ 1;
	desc-&gt;limit1		= (info-&gt;limit &amp; 0xf0000) &gt;&gt; 16;
	desc-&gt;avl		= info-&gt;useable;
	desc-&gt;d			= info-&gt;seg_32bit;
	desc-&gt;g			= info-&gt;limit_in_pages;

	desc-&gt;base2		= (info-&gt;base_addr &amp; 0xff000000) &gt;&gt; 24;
	/*
	 * Don&#x27;t allow setting of the lm bit. It would confuse
	 * user_64bit_mode and would get overridden by sysret anyway.
	 */
	desc-&gt;l			= 0;
}

struct gdt_page {
	struct desc_struct gdt[GDT_ENTRIES];
} __attribute__((aligned(PAGE_SIZE)));

DECLARE_PER_CPU_PAGE_ALIGNED(struct gdt_page, gdt_page);

/* Provide the original GDT */
static inline struct desc_struct *get_cpu_gdt_rw(unsigned int cpu)
{
	return per_cpu(gdt_page, cpu).gdt;
}

/* Provide the current original GDT */
static inline struct desc_struct *get_current_gdt_rw(void)
{
<yellow>	return this_cpu_ptr(&gdt_page)->gdt;</yellow>
}

/* Provide the fixmap address of the remapped GDT */
static inline struct desc_struct *get_cpu_gdt_ro(int cpu)
{
	return (struct desc_struct *)&amp;get_cpu_entry_area(cpu)-&gt;gdt;
}

/* Provide the current read-only GDT */
static inline struct desc_struct *get_current_gdt_ro(void)
{
<blue>	return get_cpu_gdt_ro(smp_processor_id());</blue>
}

/* Provide the physical address of the GDT page. */
static inline phys_addr_t get_cpu_gdt_paddr(unsigned int cpu)
{
	return per_cpu_ptr_to_phys(get_cpu_gdt_rw(cpu));
}

static inline void pack_gate(gate_desc *gate, unsigned type, unsigned long func,
			     unsigned dpl, unsigned ist, unsigned seg)
{
	gate-&gt;offset_low	= (u16) func;
	gate-&gt;bits.p		= 1;
	gate-&gt;bits.dpl		= dpl;
	gate-&gt;bits.zero		= 0;
	gate-&gt;bits.type		= type;
	gate-&gt;offset_middle	= (u16) (func &gt;&gt; 16);
#ifdef CONFIG_X86_64
	gate-&gt;segment		= __KERNEL_CS;
	gate-&gt;bits.ist		= ist;
	gate-&gt;reserved		= 0;
	gate-&gt;offset_high	= (u32) (func &gt;&gt; 32);
#else
	gate-&gt;segment		= seg;
	gate-&gt;bits.ist		= 0;
#endif
}

static inline int desc_empty(const void *ptr)
{
	const u32 *desc = ptr;

	return !(desc[0] | desc[1]);
}

#ifdef CONFIG_PARAVIRT_XXL
#include &lt;asm/paravirt.h&gt;
#else
#define load_TR_desc()				native_load_tr_desc()
#define load_gdt(dtr)				native_load_gdt(dtr)
#define load_idt(dtr)				native_load_idt(dtr)
#define load_tr(tr)				asm volatile(&quot;ltr %0&quot;::&quot;m&quot; (tr))
#define load_ldt(ldt)				asm volatile(&quot;lldt %0&quot;::&quot;m&quot; (ldt))

#define store_gdt(dtr)				native_store_gdt(dtr)
#define store_tr(tr)				(tr = native_store_tr())

#define load_TLS(t, cpu)			native_load_tls(t, cpu)
#define set_ldt					native_set_ldt

#define write_ldt_entry(dt, entry, desc)	native_write_ldt_entry(dt, entry, desc)
#define write_gdt_entry(dt, entry, desc, type)	native_write_gdt_entry(dt, entry, desc, type)
#define write_idt_entry(dt, entry, g)		native_write_idt_entry(dt, entry, g)

static inline void paravirt_alloc_ldt(struct desc_struct *ldt, unsigned entries)
{
}

static inline void paravirt_free_ldt(struct desc_struct *ldt, unsigned entries)
{
}
#endif	/* CONFIG_PARAVIRT_XXL */

#define store_ldt(ldt) asm(&quot;sldt %0&quot; : &quot;=m&quot;(ldt))

static inline void native_write_idt_entry(gate_desc *idt, int entry, const gate_desc *gate)
{
	memcpy(&amp;idt[entry], gate, sizeof(*gate));
}

static inline void native_write_ldt_entry(struct desc_struct *ldt, int entry, const void *desc)
{
	memcpy(&amp;ldt[entry], desc, 8);
}

static inline void
native_write_gdt_entry(struct desc_struct *gdt, int entry, const void *desc, int type)
{
	unsigned int size;

	switch (type) {
	case DESC_TSS:	size = sizeof(tss_desc);	break;
	case DESC_LDT:	size = sizeof(ldt_desc);	break;
	default:	size = sizeof(*gdt);		break;
	}

	memcpy(&amp;gdt[entry], desc, size);
}

static inline void set_tssldt_descriptor(void *d, unsigned long addr,
					 unsigned type, unsigned size)
{
	struct ldttss_desc *desc = d;

	memset(desc, 0, sizeof(*desc));

	desc-&gt;limit0		= (u16) size;
	desc-&gt;base0		= (u16) addr;
	desc-&gt;base1		= (addr &gt;&gt; 16) &amp; 0xFF;
	desc-&gt;type		= type;
	desc-&gt;p			= 1;
	desc-&gt;limit1		= (size &gt;&gt; 16) &amp; 0xF;
	desc-&gt;base2		= (addr &gt;&gt; 24) &amp; 0xFF;
#ifdef CONFIG_X86_64
	desc-&gt;base3		= (u32) (addr &gt;&gt; 32);
#endif
}

static inline void __set_tss_desc(unsigned cpu, unsigned int entry, struct x86_hw_tss *addr)
{
	struct desc_struct *d = get_cpu_gdt_rw(cpu);
	tss_desc tss;

	set_tssldt_descriptor(&amp;tss, (unsigned long)addr, DESC_TSS,
			      __KERNEL_TSS_LIMIT);
	write_gdt_entry(d, entry, &amp;tss, DESC_TSS);
}

#define set_tss_desc(cpu, addr) __set_tss_desc(cpu, GDT_ENTRY_TSS, addr)

static inline void native_set_ldt(const void *addr, unsigned int entries)
{
	if (likely(entries == 0))
		asm volatile(&quot;lldt %w0&quot;::&quot;q&quot; (0));
	else {
		unsigned cpu = smp_processor_id();
		ldt_desc ldt;

		set_tssldt_descriptor(&amp;ldt, (unsigned long)addr, DESC_LDT,
				      entries * LDT_ENTRY_SIZE - 1);
		write_gdt_entry(get_cpu_gdt_rw(cpu), GDT_ENTRY_LDT,
				&amp;ldt, DESC_LDT);
		asm volatile(&quot;lldt %w0&quot;::&quot;q&quot; (GDT_ENTRY_LDT*8));
	}
}

static inline void native_load_gdt(const struct desc_ptr *dtr)
{
	asm volatile(&quot;lgdt %0&quot;::&quot;m&quot; (*dtr));
}

static __always_inline void native_load_idt(const struct desc_ptr *dtr)
{
	asm volatile(&quot;lidt %0&quot;::&quot;m&quot; (*dtr));
}

static inline void native_store_gdt(struct desc_ptr *dtr)
{
	asm volatile(&quot;sgdt %0&quot;:&quot;=m&quot; (*dtr));
}

static inline void store_idt(struct desc_ptr *dtr)
{
	asm volatile(&quot;sidt %0&quot;:&quot;=m&quot; (*dtr));
}

static inline void native_gdt_invalidate(void)
{
	const struct desc_ptr invalid_gdt = {
		.address = 0,
		.size = 0
	};

	native_load_gdt(&amp;invalid_gdt);
}

static inline void native_idt_invalidate(void)
{
	const struct desc_ptr invalid_idt = {
		.address = 0,
		.size = 0
	};

	native_load_idt(&amp;invalid_idt);
}

/*
 * The LTR instruction marks the TSS GDT entry as busy. On 64-bit, the GDT is
 * a read-only remapping. To prevent a page fault, the GDT is switched to the
 * original writeable version when needed.
 */
#ifdef CONFIG_X86_64
static inline void native_load_tr_desc(void)
{
	struct desc_ptr gdt;
	int cpu = raw_smp_processor_id();
	bool restore = 0;
	struct desc_struct *fixmap_gdt;

	native_store_gdt(&amp;gdt);
	fixmap_gdt = get_cpu_gdt_ro(cpu);

	/*
	 * If the current GDT is the read-only fixmap, swap to the original
	 * writeable version. Swap back at the end.
	 */
	if (gdt.address == (unsigned long)fixmap_gdt) {
		load_direct_gdt(cpu);
		restore = 1;
	}
	asm volatile(&quot;ltr %w0&quot;::&quot;q&quot; (GDT_ENTRY_TSS*8));
	if (restore)
		load_fixmap_gdt(cpu);
}
#else
static inline void native_load_tr_desc(void)
{
	asm volatile(&quot;ltr %w0&quot;::&quot;q&quot; (GDT_ENTRY_TSS*8));
}
#endif

static inline unsigned long native_store_tr(void)
{
	unsigned long tr;

	asm volatile(&quot;str %0&quot;:&quot;=r&quot; (tr));

	return tr;
}

static inline void native_load_tls(struct thread_struct *t, unsigned int cpu)
{
	struct desc_struct *gdt = get_cpu_gdt_rw(cpu);
	unsigned int i;

	for (i = 0; i &lt; GDT_ENTRY_TLS_ENTRIES; i++)
		gdt[GDT_ENTRY_TLS_MIN + i] = t-&gt;tls_array[i];
}

DECLARE_PER_CPU(bool, __tss_limit_invalid);

static inline void force_reload_TR(void)
{
<yellow>	struct desc_struct *d = get_current_gdt_rw();</yellow>
	tss_desc tss;

<yellow>	memcpy(&tss, &d[GDT_ENTRY_TSS], sizeof(tss_desc));</yellow>

	/*
	 * LTR requires an available TSS, and the TSS is currently
	 * busy.  Make it be available so that LTR will work.
	 */
	tss.type = DESC_TSS;
<yellow>	write_gdt_entry(d, GDT_ENTRY_TSS, &tss, DESC_TSS);</yellow>

	load_TR_desc();
<yellow>	this_cpu_write(__tss_limit_invalid, false);</yellow>
}

/*
 * Call this if you need the TSS limit to be correct, which should be the case
 * if and only if you have TIF_IO_BITMAP set or you&#x27;re switching to a task
 * with TIF_IO_BITMAP set.
 */
static inline void refresh_tss_limit(void)
{
	DEBUG_LOCKS_WARN_ON(preemptible());

	if (unlikely(this_cpu_read(__tss_limit_invalid)))
		force_reload_TR();
}

/*
 * If you do something evil that corrupts the cached TSS limit (I&#x27;m looking
 * at you, VMX exits), call this function.
 *
 * The optimization here is that the TSS limit only matters for Linux if the
 * IO bitmap is in use.  If the TSS limit gets forced to its minimum value,
 * everything works except that IO bitmap will be ignored and all CPL 3 IO
 * instructions will #GP, which is exactly what we want for normal tasks.
 */
static inline void invalidate_tss_limit(void)
{
<blue>	DEBUG_LOCKS_WARN_ON(preemptible());</blue>

<blue>	if (unlikely(test_thread_flag(TIF_IO_BITMAP)))</blue>
<yellow>		force_reload_TR();</yellow>
	else
<blue>		this_cpu_write(__tss_limit_invalid, true);</blue>
}

/* This intentionally ignores lm, since 32-bit apps don&#x27;t have that field. */
#define LDT_empty(info)					\
	((info)-&gt;base_addr		== 0	&amp;&amp;	\
	 (info)-&gt;limit			== 0	&amp;&amp;	\
	 (info)-&gt;contents		== 0	&amp;&amp;	\
	 (info)-&gt;read_exec_only		== 1	&amp;&amp;	\
	 (info)-&gt;seg_32bit		== 0	&amp;&amp;	\
	 (info)-&gt;limit_in_pages		== 0	&amp;&amp;	\
	 (info)-&gt;seg_not_present	== 1	&amp;&amp;	\
	 (info)-&gt;useable		== 0)

/* Lots of programs expect an all-zero user_desc to mean &quot;no segment at all&quot;. */
static inline bool LDT_zero(const struct user_desc *info)
{
	return (info-&gt;base_addr		== 0 &amp;&amp;
		info-&gt;limit		== 0 &amp;&amp;
		info-&gt;contents		== 0 &amp;&amp;
		info-&gt;read_exec_only	== 0 &amp;&amp;
		info-&gt;seg_32bit		== 0 &amp;&amp;
		info-&gt;limit_in_pages	== 0 &amp;&amp;
		info-&gt;seg_not_present	== 0 &amp;&amp;
		info-&gt;useable		== 0);
}

static inline void clear_LDT(void)
{
	set_ldt(NULL, 0);
}

static inline unsigned long get_desc_base(const struct desc_struct *desc)
{
<yellow>	return (unsigned)(desc->base0 | ((desc->base1) << 16) | ((desc->base2) << 24));</yellow>
}

static inline void set_desc_base(struct desc_struct *desc, unsigned long base)
{
	desc-&gt;base0 = base &amp; 0xffff;
	desc-&gt;base1 = (base &gt;&gt; 16) &amp; 0xff;
	desc-&gt;base2 = (base &gt;&gt; 24) &amp; 0xff;
}

static inline unsigned long get_desc_limit(const struct desc_struct *desc)
{
<blue>	return desc->limit0 | (desc->limit1 << 16);</blue>
}

static inline void set_desc_limit(struct desc_struct *desc, unsigned long limit)
{
<blue>	desc->limit0 = limit & 0xffff;</blue>
	desc-&gt;limit1 = (limit &gt;&gt; 16) &amp; 0xf;
}

void alloc_intr_gate(unsigned int n, const void *addr);

static inline void init_idt_data(struct idt_data *data, unsigned int n,
				 const void *addr)
{
	BUG_ON(n &gt; 0xFF);

	memset(data, 0, sizeof(*data));
	data-&gt;vector	= n;
	data-&gt;addr	= addr;
	data-&gt;segment	= __KERNEL_CS;
	data-&gt;bits.type	= GATE_INTERRUPT;
	data-&gt;bits.p	= 1;
}

static inline void idt_init_desc(gate_desc *gate, const struct idt_data *d)
{
	unsigned long addr = (unsigned long) d-&gt;addr;

	gate-&gt;offset_low	= (u16) addr;
	gate-&gt;segment		= (u16) d-&gt;segment;
	gate-&gt;bits		= d-&gt;bits;
	gate-&gt;offset_middle	= (u16) (addr &gt;&gt; 16);
#ifdef CONFIG_X86_64
	gate-&gt;offset_high	= (u32) (addr &gt;&gt; 32);
	gate-&gt;reserved		= 0;
#endif
}

extern unsigned long system_vectors[];

extern void load_current_idt(void);
extern void idt_setup_early_handler(void);
extern void idt_setup_early_traps(void);
extern void idt_setup_traps(void);
extern void idt_setup_apic_and_irq_gates(void);
extern bool idt_is_f00f_address(unsigned long address);

#ifdef CONFIG_X86_64
extern void idt_setup_early_pf(void);
#else
static inline void idt_setup_early_pf(void) { }
#endif

extern void idt_invalidate(void);

#endif /* _ASM_X86_DESC_H */


</code></pre></td></tr></table>
</body>
</html>
