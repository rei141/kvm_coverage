<doctype html>
<html lang="ja">
<head><title>i8259.c</title><meta charset="utf-8">
<script src="https://cdn.rawgit.com/google/code-prettify/master/loader/run_prettify.js"></script>
<style>
    code{
        font-family:Monaco, Menlo, Consolas, 'Courier New', Courier, monospace, sans-serif;
        font-size: 14px;
        line-height: 18px;
        overflow: auto;
        resize: horizontal;
    }
    code_line{
        font-family: Monaco, Menlo, Consolas, 'Courier New', Courier, monospace, sans-serif;;
        font-size: 14px;
        line-height: 18px;
        overflow: auto;
        resize: horizontal;
        color:#303134;
    }
    blue{
        background-color:#BEEDE8;
    }
    yellow{
        background-color:#FFFF99;
    }
    red{
        background-color:#FF99AC;
    }
      .split {
         height: 100%;
         position: fixed;
         z-index: 1;
         top: 0;
         overflow-x: hidden;
      }

      .tree {
         left: 0;
         width: 20%;
      }

      .right {
         border-left: 2px solid #444;
         right: 0;
         width: 80%;
         /* font-family: 'Courier New', Courier, monospace;
				color: rgb(80, 80, 80); */
      }
</style>

</head>
<body>
   <div class="split tree">
      <ul id="file_list">
      </ul>
   </div>
   <div class="split right">
<table summary='blob content' class='blob' cellspacing="15">
<tr><td align="right"><pre><code_line><script>for (let i = 1; i <= 656; i++){
         document.write(i+".\n");
   }
         </script></code_line></pre></td>
<td class='lines'><pre><code class="prettyprint">/*
 * 8259 interrupt controller emulation
 *
 * Copyright (c) 2003-2004 Fabrice Bellard
 * Copyright (c) 2007 Intel Corporation
 * Copyright 2009 Red Hat, Inc. and/or its affiliates.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the &quot;Software&quot;), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 * Authors:
 *   Yaozu (Eddie) Dong &lt;Eddie.dong@intel.com&gt;
 *   Port from Qemu.
 */
#include &lt;linux/mm.h&gt;
#include &lt;linux/slab.h&gt;
#include &lt;linux/bitops.h&gt;
#include &quot;irq.h&quot;

#include &lt;linux/kvm_host.h&gt;
#include &quot;trace.h&quot;

#define pr_pic_unimpl(fmt, ...)	\
	pr_err_ratelimited(&quot;kvm: pic: &quot; fmt, ## __VA_ARGS__)

static void pic_irq_request(struct kvm *kvm, int level);

static void pic_lock(struct kvm_pic *s)
	__acquires(&amp;s-&gt;lock)
{
<blue>	spin_lock(&s->lock);</blue>
}

static void pic_unlock(struct kvm_pic *s)
	__releases(&amp;s-&gt;lock)
<blue>{</blue>
<blue>	bool wakeup = s->wakeup_needed;</blue>
	struct kvm_vcpu *vcpu;
	unsigned long i;

<blue>	s->wakeup_needed = false;</blue>

	spin_unlock(&amp;s-&gt;lock);

	if (wakeup) {
<blue>		kvm_for_each_vcpu(i, vcpu, s->kvm) {</blue>
<blue>			if (kvm_apic_accept_pic_intr(vcpu)) {</blue>
<blue>				kvm_make_request(KVM_REQ_EVENT, vcpu);</blue>
				kvm_vcpu_kick(vcpu);
				return;
			}
		}
	}
}

static void pic_clear_isr(struct kvm_kpic_state *s, int irq)
{
<blue>	s->isr &= ~(1 << irq);</blue>
	if (s != &amp;s-&gt;pics_state-&gt;pics[0])
<yellow>		irq += 8;</yellow>
	/*
	 * We are dropping lock while calling ack notifiers since ack
	 * notifier callbacks for assigned devices call into PIC recursively.
	 * Other interrupt may be delivered to PIC while lock is dropped but
	 * it should be safe since PIC state is already updated at this stage.
	 */
<blue>	pic_unlock(s->pics_state);</blue>
	kvm_notify_acked_irq(s-&gt;pics_state-&gt;kvm, SELECT_PIC(irq), irq);
	pic_lock(s-&gt;pics_state);
}

/*
 * set irq level. If an edge is detected, then the IRR is set to 1
 */
static inline int pic_set_irq1(struct kvm_kpic_state *s, int irq, int level)
{
	int mask, ret = 1;
	mask = 1 &lt;&lt; irq;
<yellow>	if (s->elcr & mask)	/* level triggered */</yellow>
		if (level) {
<yellow>			ret = !(s->irr & mask);</yellow>
			s-&gt;irr |= mask;
<blue>			s->last_irr |= mask;</blue>
		} else {
<yellow>			s->irr &= ~mask;</yellow>
			s-&gt;last_irr &amp;= ~mask;
		}
	else	/* edge triggered */
		if (level) {
<blue>			if ((s->last_irr & mask) == 0) {</blue>
<blue>				ret = !(s->irr & mask);</blue>
				s-&gt;irr |= mask;
			}
<blue>			s->last_irr |= mask;</blue>
		} else
<blue>			s->last_irr &= ~mask;</blue>

	return (s-&gt;imr &amp; mask) ? -1 : ret;
}

/*
 * return the highest priority found in mask (highest = smallest
 * number). Return 8 if no irq
 */
<yellow>static inline int get_priority(struct kvm_kpic_state *s, int mask)</yellow>
{
	int priority;
<blue>	if (mask == 0)</blue>
		return 8;
	priority = 0;
<yellow>	while ((mask & (1 << ((priority + s->priority_add) & 7))) == 0)</yellow>
		priority++;
	return priority;
}

/*
 * return the pic wanted interrupt. return -1 if none
 */
static int pic_get_irq(struct kvm_kpic_state *s)
{
	int mask, cur_priority, priority;

<blue>	mask = s->irr & ~s->imr;</blue>
<blue>	priority = get_priority(s, mask);</blue>
<yellow>	if (priority == 8)</yellow>
		return -1;
	/*
	 * compute current priority. If special fully nested mode on the
	 * master, the IRQ coming from the slave is not taken into account
	 * for the priority computation.
	 */
<blue>	mask = s->isr;</blue>
<yellow>	if (s->special_fully_nested_mode && s == &s->pics_state->pics[0])</yellow>
<yellow>		mask &= ~(1 << 2);</yellow>
<blue>	cur_priority = get_priority(s, mask);</blue>
<blue>	if (priority < cur_priority)</blue>
		/*
		 * higher priority found: an irq should be generated
		 */
		return (priority + s-&gt;priority_add) &amp; 7;
	else
		return -1;
<blue>}</blue>

/*
 * raise irq to CPU if necessary. must be called every time the active
 * irq may change
 */
static void pic_update_irq(struct kvm_pic *s)
{
	int irq2, irq;

<blue>	irq2 = pic_get_irq(&s->pics[1]);</blue>
	if (irq2 &gt;= 0) {
		/*
		 * if irq request by slave pic, signal master PIC
		 */
<yellow>		pic_set_irq1(&s->pics[0], 2, 1);</yellow>
<yellow>		pic_set_irq1(&s->pics[0], 2, 0);</yellow>
	}
<blue>	irq = pic_get_irq(&s->pics[0]);</blue>
<blue>	pic_irq_request(s->kvm, irq >= 0);</blue>
}

void kvm_pic_update_irq(struct kvm_pic *s)
{
<yellow>	pic_lock(s);</yellow>
	pic_update_irq(s);
	pic_unlock(s);
}

int kvm_pic_set_irq(struct kvm_pic *s, int irq, int irq_source_id, int level)
{
	int ret, irq_level;

<blue>	BUG_ON(irq < 0 || irq >= PIC_NUM_PINS);</blue>

<blue>	pic_lock(s);</blue>
<blue>	irq_level = __kvm_irq_line_state(&s->irq_states[irq],</blue>
					 irq_source_id, level);
<blue>	ret = pic_set_irq1(&s->pics[irq >> 3], irq & 7, irq_level);</blue>
<blue>	pic_update_irq(s);</blue>
<blue>	trace_kvm_pic_set_irq(irq >> 3, irq & 7, s->pics[irq >> 3].elcr,</blue>
			      s-&gt;pics[irq &gt;&gt; 3].imr, ret == 0);
<blue>	pic_unlock(s);</blue>

	return ret;
}

void kvm_pic_clear_all(struct kvm_pic *s, int irq_source_id)
{
	int i;

<yellow>	pic_lock(s);</yellow>
	for (i = 0; i &lt; PIC_NUM_PINS; i++)
<yellow>		__clear_bit(irq_source_id, &s->irq_states[i]);</yellow>
<yellow>	pic_unlock(s);</yellow>
}

/*
 * acknowledge interrupt &#x27;irq&#x27;
 */
<yellow>static inline void pic_intack(struct kvm_kpic_state *s, int irq)</yellow>
{
<blue>	s->isr |= 1 << irq;</blue>
	/*
	 * We don&#x27;t clear a level sensitive interrupt here
	 */
	if (!(s-&gt;elcr &amp; (1 &lt;&lt; irq)))
<blue>		s->irr &= ~(1 << irq);</blue>

<blue>	if (s->auto_eoi) {</blue>
<yellow>		if (s->rotate_on_auto_eoi)</yellow>
<yellow>			s->priority_add = (irq + 1) & 7;</yellow>
<yellow>		pic_clear_isr(s, irq);</yellow>
	}

}

int kvm_pic_read_irq(struct kvm *kvm)
{
	int irq, irq2, intno;
<blue>	struct kvm_pic *s = kvm->arch.vpic;</blue>

	s-&gt;output = 0;

	pic_lock(s);
	irq = pic_get_irq(&amp;s-&gt;pics[0]);
	if (irq &gt;= 0) {
<blue>		pic_intack(&s->pics[0], irq);</blue>
<blue>		if (irq == 2) {</blue>
<yellow>			irq2 = pic_get_irq(&s->pics[1]);</yellow>
			if (irq2 &gt;= 0)
<yellow>				pic_intack(&s->pics[1], irq2);</yellow>
			else
				/*
				 * spurious IRQ on slave controller
				 */
				irq2 = 7;
<yellow>			intno = s->pics[1].irq_base + irq2;</yellow>
		} else
<blue>			intno = s->pics[0].irq_base + irq;</blue>
	} else {
		/*
		 * spurious IRQ on host controller
		 */
		irq = 7;
<yellow>		intno = s->pics[0].irq_base + irq;</yellow>
	}
<blue>	pic_update_irq(s);</blue>
	pic_unlock(s);

	return intno;
}

static void kvm_pic_reset(struct kvm_kpic_state *s)
{
	int irq;
	unsigned long i;
	struct kvm_vcpu *vcpu;
<blue>	u8 edge_irr = s->irr & ~s->elcr;</blue>
	bool found = false;

	s-&gt;last_irr = 0;
	s-&gt;irr &amp;= s-&gt;elcr;
	s-&gt;imr = 0;
	s-&gt;priority_add = 0;
	s-&gt;special_mask = 0;
	s-&gt;read_reg_select = 0;
	if (!s-&gt;init4) {
<yellow>		s->special_fully_nested_mode = 0;</yellow>
		s-&gt;auto_eoi = 0;
	}
<blue>	s->init_state = 1;</blue>

<blue>	kvm_for_each_vcpu(i, vcpu, s->pics_state->kvm)</blue>
<blue>		if (kvm_apic_accept_pic_intr(vcpu)) {</blue>
			found = true;
			break;
		}


	if (!found)
		return;

<blue>	for (irq = 0; irq < PIC_NUM_PINS/2; irq++)</blue>
<blue>		if (edge_irr & (1 << irq))</blue>
<blue>			pic_clear_isr(s, irq);</blue>
}

static void pic_ioport_write(void *opaque, u32 addr, u32 val)
<blue>{</blue>
	struct kvm_kpic_state *s = opaque;
	int priority, cmd, irq;

	addr &amp;= 1;
<blue>	if (addr == 0) {</blue>
<blue>		if (val & 0x10) {</blue>
<blue>			s->init4 = val & 1;</blue>
			if (val &amp; 0x02)
<yellow>				pr_pic_unimpl("single mode not supported");</yellow>
<blue>			if (val & 0x08)</blue>
<yellow>				pr_pic_unimpl(</yellow>
						&quot;level sensitive irq not supported&quot;);
<blue>			kvm_pic_reset(s);</blue>
<blue>		} else if (val & 0x08) {</blue>
<yellow>			if (val & 0x04)</yellow>
<yellow>				s->poll = 1;</yellow>
<yellow>			if (val & 0x02)</yellow>
<yellow>				s->read_reg_select = val & 1;</yellow>
<yellow>			if (val & 0x40)</yellow>
<yellow>				s->special_mask = (val >> 5) & 1;</yellow>
		} else {
<blue>			cmd = val >> 5;</blue>
			switch (cmd) {
			case 0:
			case 4:
<yellow>				s->rotate_on_auto_eoi = cmd >> 2;</yellow>
				break;
			case 1:	/* end of interrupt */
			case 5:
<blue>				priority = get_priority(s, s->isr);</blue>
<yellow>				if (priority != 8) {</yellow>
					irq = (priority + s-&gt;priority_add) &amp; 7;
<blue>					if (cmd == 5)</blue>
<yellow>						s->priority_add = (irq + 1) & 7;</yellow>
<blue>					pic_clear_isr(s, irq);</blue>
					pic_update_irq(s-&gt;pics_state);
				}
				break;
			case 3:
<yellow>				irq = val & 7;</yellow>
				pic_clear_isr(s, irq);
				pic_update_irq(s-&gt;pics_state);
				break;
			case 6:
<yellow>				s->priority_add = (val + 1) & 7;</yellow>
				pic_update_irq(s-&gt;pics_state);
				break;
			case 7:
				irq = val &amp; 7;
<yellow>				s->priority_add = (irq + 1) & 7;</yellow>
				pic_clear_isr(s, irq);
				pic_update_irq(s-&gt;pics_state);
<blue>				break;</blue>
			default:
				break;	/* no operation */
			}
		}
	} else
<blue>		switch (s->init_state) {</blue>
		case 0: { /* normal mode */
<blue>			u8 imr_diff = s->imr ^ val,</blue>
				off = (s == &amp;s-&gt;pics_state-&gt;pics[0]) ? 0 : 8;
			s-&gt;imr = val;
<blue>			for (irq = 0; irq < PIC_NUM_PINS/2; irq++)</blue>
<blue>				if (imr_diff & (1 << irq))</blue>
					kvm_fire_mask_notifiers(
						s-&gt;pics_state-&gt;kvm,
						SELECT_PIC(irq + off),
						irq + off,
<blue>						!!(s->imr & (1 << irq)));</blue>
<blue>			pic_update_irq(s->pics_state);</blue>
			break;
		}
		case 1:
<blue>			s->irq_base = val & 0xf8;</blue>
			s-&gt;init_state = 2;
			break;
		case 2:
<blue>			if (s->init4)</blue>
<blue>				s->init_state = 3;</blue>
			else
<yellow>				s->init_state = 0;</yellow>
			break;
		case 3:
<blue>			s->special_fully_nested_mode = (val >> 4) & 1;</blue>
			s-&gt;auto_eoi = (val &gt;&gt; 1) &amp; 1;
			s-&gt;init_state = 0;
			break;
		}
}

static u32 pic_poll_read(struct kvm_kpic_state *s, u32 addr1)
{
	int ret;

	ret = pic_get_irq(s);
	if (ret &gt;= 0) {
		if (addr1 &gt;&gt; 7) {
<yellow>			s->pics_state->pics[0].isr &= ~(1 << 2);</yellow>
			s-&gt;pics_state-&gt;pics[0].irr &amp;= ~(1 &lt;&lt; 2);
		}
<yellow>		s->irr &= ~(1 << ret);</yellow>
		pic_clear_isr(s, ret);
		if (addr1 &gt;&gt; 7 || ret != 2)
<yellow>			pic_update_irq(s->pics_state);</yellow>
	} else {
		ret = 0x07;
<yellow>		pic_update_irq(s->pics_state);</yellow>
	}

	return ret;
}

static u32 pic_ioport_read(void *opaque, u32 addr)
{
	struct kvm_kpic_state *s = opaque;
	int ret;

	if (s-&gt;poll) {
<yellow>		ret = pic_poll_read(s, addr);</yellow>
<yellow>		s->poll = 0;</yellow>
	} else
<blue>		if ((addr & 1) == 0)</blue>
<yellow>			if (s->read_reg_select)</yellow>
<yellow>				ret = s->isr;</yellow>
			else
<yellow>				ret = s->irr;</yellow>
		else
<blue>			ret = s->imr;</blue>
	return ret;
}

static void elcr_ioport_write(void *opaque, u32 val)
{
	struct kvm_kpic_state *s = opaque;
	s-&gt;elcr = val &amp; s-&gt;elcr_mask;
}

static u32 elcr_ioport_read(void *opaque)
{
	struct kvm_kpic_state *s = opaque;
	return s-&gt;elcr;
}

static int picdev_write(struct kvm_pic *s,
			 gpa_t addr, int len, const void *val)
{
<blue>	unsigned char data = *(unsigned char *)val;</blue>

	if (len != 1) {
<yellow>		pr_pic_unimpl("non byte write\n");</yellow>
		return 0;
	}
<blue>	switch (addr) {</blue>
	case 0x20:
	case 0x21:
<blue>		pic_lock(s);</blue>
		pic_ioport_write(&amp;s-&gt;pics[0], addr, data);
		pic_unlock(s);
		break;
	case 0xa0:
	case 0xa1:
<blue>		pic_lock(s);</blue>
		pic_ioport_write(&amp;s-&gt;pics[1], addr, data);
		pic_unlock(s);
		break;
	case 0x4d0:
	case 0x4d1:
		pic_lock(s);
<blue>		elcr_ioport_write(&s->pics[addr & 1], data);</blue>
		pic_unlock(s);
		break;
	default:
		return -EOPNOTSUPP;
	}
	return 0;
<blue>}</blue>

static int picdev_read(struct kvm_pic *s,
		       gpa_t addr, int len, void *val)
{
	unsigned char *data = (unsigned char *)val;

<blue>	if (len != 1) {</blue>
<yellow>		memset(val, 0, len);</yellow>
		pr_pic_unimpl(&quot;non byte read\n&quot;);
		return 0;
	}
<blue>	switch (addr) {</blue>
	case 0x20:
	case 0x21:
	case 0xa0:
	case 0xa1:
		pic_lock(s);
<blue>		*data = pic_ioport_read(&s->pics[addr >> 7], addr);</blue>
		pic_unlock(s);
		break;
	case 0x4d0:
	case 0x4d1:
		pic_lock(s);
<yellow>		*data = elcr_ioport_read(&s->pics[addr & 1]);</yellow>
		pic_unlock(s);
		break;
	default:
		return -EOPNOTSUPP;
	}
	return 0;
<blue>}</blue>

static int picdev_master_write(struct kvm_vcpu *vcpu, struct kvm_io_device *dev,
			       gpa_t addr, int len, const void *val)
{
<blue>	return picdev_write(container_of(dev, struct kvm_pic, dev_master),</blue>
			    addr, len, val);
}

static int picdev_master_read(struct kvm_vcpu *vcpu, struct kvm_io_device *dev,
			      gpa_t addr, int len, void *val)
{
<blue>	return picdev_read(container_of(dev, struct kvm_pic, dev_master),</blue>
			    addr, len, val);
}

static int picdev_slave_write(struct kvm_vcpu *vcpu, struct kvm_io_device *dev,
			      gpa_t addr, int len, const void *val)
{
<blue>	return picdev_write(container_of(dev, struct kvm_pic, dev_slave),</blue>
			    addr, len, val);
}

static int picdev_slave_read(struct kvm_vcpu *vcpu, struct kvm_io_device *dev,
			     gpa_t addr, int len, void *val)
{
<blue>	return picdev_read(container_of(dev, struct kvm_pic, dev_slave),</blue>
			    addr, len, val);
}

static int picdev_elcr_write(struct kvm_vcpu *vcpu, struct kvm_io_device *dev,
			     gpa_t addr, int len, const void *val)
{
<blue>	return picdev_write(container_of(dev, struct kvm_pic, dev_elcr),</blue>
			    addr, len, val);
}

static int picdev_elcr_read(struct kvm_vcpu *vcpu, struct kvm_io_device *dev,
			    gpa_t addr, int len, void *val)
{
<yellow>	return picdev_read(container_of(dev, struct kvm_pic, dev_elcr),</yellow>
			    addr, len, val);
}

/*
 * callback when PIC0 irq status changed
 */
static void pic_irq_request(struct kvm *kvm, int level)
{
	struct kvm_pic *s = kvm-&gt;arch.vpic;

	if (!s-&gt;output)
<blue>		s->wakeup_needed = true;</blue>
<blue>	s->output = level;</blue>
}

static const struct kvm_io_device_ops picdev_master_ops = {
	.read     = picdev_master_read,
	.write    = picdev_master_write,
};

static const struct kvm_io_device_ops picdev_slave_ops = {
	.read     = picdev_slave_read,
	.write    = picdev_slave_write,
};

static const struct kvm_io_device_ops picdev_elcr_ops = {
	.read     = picdev_elcr_read,
	.write    = picdev_elcr_write,
};

int kvm_pic_init(struct kvm *kvm)
{
	struct kvm_pic *s;
	int ret;

<blue>	s = kzalloc(sizeof(struct kvm_pic), GFP_KERNEL_ACCOUNT);</blue>
	if (!s)
		return -ENOMEM;
<blue>	spin_lock_init(&s->lock);</blue>
	s-&gt;kvm = kvm;
	s-&gt;pics[0].elcr_mask = 0xf8;
	s-&gt;pics[1].elcr_mask = 0xde;
	s-&gt;pics[0].pics_state = s;
	s-&gt;pics[1].pics_state = s;

	/*
	 * Initialize PIO device
	 */
	kvm_iodevice_init(&amp;s-&gt;dev_master, &amp;picdev_master_ops);
	kvm_iodevice_init(&amp;s-&gt;dev_slave, &amp;picdev_slave_ops);
	kvm_iodevice_init(&amp;s-&gt;dev_elcr, &amp;picdev_elcr_ops);
	mutex_lock(&amp;kvm-&gt;slots_lock);
	ret = kvm_io_bus_register_dev(kvm, KVM_PIO_BUS, 0x20, 2,
				      &amp;s-&gt;dev_master);
	if (ret &lt; 0)
		goto fail_unlock;

<blue>	ret = kvm_io_bus_register_dev(kvm, KVM_PIO_BUS, 0xa0, 2, &s->dev_slave);</blue>
	if (ret &lt; 0)
		goto fail_unreg_2;

<blue>	ret = kvm_io_bus_register_dev(kvm, KVM_PIO_BUS, 0x4d0, 2, &s->dev_elcr);</blue>
	if (ret &lt; 0)
		goto fail_unreg_1;

<blue>	mutex_unlock(&kvm->slots_lock);</blue>

	kvm-&gt;arch.vpic = s;

	return 0;

fail_unreg_1:
<yellow>	kvm_io_bus_unregister_dev(kvm, KVM_PIO_BUS, &s->dev_slave);</yellow>

fail_unreg_2:
<yellow>	kvm_io_bus_unregister_dev(kvm, KVM_PIO_BUS, &s->dev_master);</yellow>

fail_unlock:
<yellow>	mutex_unlock(&kvm->slots_lock);</yellow>

	kfree(s);

	return ret;
<blue>}</blue>

void kvm_pic_destroy(struct kvm *kvm)
{
<yellow>	struct kvm_pic *vpic = kvm->arch.vpic;</yellow>

	if (!vpic)
		return;

<yellow>	mutex_lock(&kvm->slots_lock);</yellow>
	kvm_io_bus_unregister_dev(vpic-&gt;kvm, KVM_PIO_BUS, &amp;vpic-&gt;dev_master);
	kvm_io_bus_unregister_dev(vpic-&gt;kvm, KVM_PIO_BUS, &amp;vpic-&gt;dev_slave);
	kvm_io_bus_unregister_dev(vpic-&gt;kvm, KVM_PIO_BUS, &amp;vpic-&gt;dev_elcr);
	mutex_unlock(&amp;kvm-&gt;slots_lock);

	kvm-&gt;arch.vpic = NULL;
	kfree(vpic);
<yellow>}</yellow>


</code></pre></td></tr></table>
</div><script>const fileList = document.getElementById('file_list')
fileList.innerHTML+=`<li><a href="/kvm_coverage/coverage/linux/arch/x86/kvm/mmu/mmu.c.html">mmu.c 58.5%</li>`
fileList.innerHTML+=`<li><a href="/kvm_coverage/coverage/linux/arch/x86/kvm/vmx/nested.c.html">nested.c 84.9%</li>`
fileList.innerHTML+=`<li><a href="/kvm_coverage/coverage/linux/arch/x86/kvm/vmx/vmx.c.html">vmx.c 58.8%</li>`
fileList.innerHTML+=`<li><a href="/kvm_coverage/coverage/linux/arch/x86/kvm/x86.c.html">x86.c 51.7%</li>`
</script></body></html>