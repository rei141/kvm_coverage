<doctype html>
<html lang="ja">
<head><title>xen.c</title><meta charset="utf-8">
<script src="https://cdn.rawgit.com/google/code-prettify/master/loader/run_prettify.js"></script>
<style>
    code{
        font-family:Monaco, Menlo, Consolas, 'Courier New', Courier, monospace, sans-serif;
        font-size: 14px;
        line-height: 18px;
        overflow: auto;
        resize: horizontal;
    }
    code_line{
        font-family: Monaco, Menlo, Consolas, 'Courier New', Courier, monospace, sans-serif;;
        font-size: 14px;
        line-height: 18px;
        overflow: auto;
        resize: horizontal;
        color:#303134;
    }
    blue{
        background-color:#BEEDE8;
    }
    yellow{
        background-color:#FFFF99;
    }
    red{
        background-color:#FF99AC;
    }
      .split {
         height: 100%;
         position: fixed;
         z-index: 1;
         top: 0;
         overflow-x: hidden;
      }

      .tree {
         left: 0;
         width: 20%;
      }

      .right {
         border-left: 2px solid #444;
         right: 0;
         width: 80%;
         /* font-family: 'Courier New', Courier, monospace;
				color: rgb(80, 80, 80); */
      }
</style>

</head>
<body>
   <div class="split tree">
      <ul id="file_list">
      </ul>
   </div>
   <div class="split right">
<table summary='blob content' class='blob' cellspacing="15">
<tr><td align="right"><pre><code_line><script>for (let i = 1; i <= 1876; i++){
         document.write(i+".\n");
   }
         </script></code_line></pre></td>
<td class='lines'><pre><code class="prettyprint">// SPDX-License-Identifier: GPL-2.0
/*
 * Copyright © 2019 Oracle and/or its affiliates. All rights reserved.
 * Copyright © 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 *
 * KVM Xen emulation
 */

#include &quot;x86.h&quot;
#include &quot;xen.h&quot;
#include &quot;hyperv.h&quot;
#include &quot;lapic.h&quot;

#include &lt;linux/eventfd.h&gt;
#include &lt;linux/kvm_host.h&gt;
#include &lt;linux/sched/stat.h&gt;

#include &lt;trace/events/kvm.h&gt;
#include &lt;xen/interface/xen.h&gt;
#include &lt;xen/interface/vcpu.h&gt;
#include &lt;xen/interface/version.h&gt;
#include &lt;xen/interface/event_channel.h&gt;
#include &lt;xen/interface/sched.h&gt;

#include &quot;trace.h&quot;

static int kvm_xen_set_evtchn(struct kvm_xen_evtchn *xe, struct kvm *kvm);
static int kvm_xen_setattr_evtchn(struct kvm *kvm, struct kvm_xen_hvm_attr *data);
static bool kvm_xen_hcall_evtchn_send(struct kvm_vcpu *vcpu, u64 param, u64 *r);

DEFINE_STATIC_KEY_DEFERRED_FALSE(kvm_xen_enabled, HZ);

static int kvm_xen_shared_info_init(struct kvm *kvm, gfn_t gfn)
{
	struct gfn_to_pfn_cache *gpc = &amp;kvm-&gt;arch.xen.shinfo_cache;
	struct pvclock_wall_clock *wc;
	gpa_t gpa = gfn_to_gpa(gfn);
	u32 *wc_sec_hi;
	u32 wc_version;
	u64 wall_nsec;
	int ret = 0;
	int idx = srcu_read_lock(&amp;kvm-&gt;srcu);

	if (gfn == GPA_INVALID) {
<yellow>		kvm_gpc_deactivate(kvm, gpc);</yellow>
		goto out;
	}

	do {
<yellow>		ret = kvm_gpc_activate(kvm, gpc, NULL, KVM_HOST_USES_PFN, gpa,</yellow>
				       PAGE_SIZE);
		if (ret)
			goto out;

		/*
		 * This code mirrors kvm_write_wall_clock() except that it writes
		 * directly through the pfn cache and doesn&#x27;t mark the page dirty.
		 */
<yellow>		wall_nsec = ktime_get_real_ns() - get_kvmclock_ns(kvm);</yellow>

		/* It could be invalid again already, so we need to check */
		read_lock_irq(&amp;gpc-&gt;lock);

<yellow>		if (gpc->valid)</yellow>
			break;

<yellow>		read_unlock_irq(&gpc->lock);</yellow>
	} while (1);

	/* Paranoia checks on the 32-bit struct layout */
	BUILD_BUG_ON(offsetof(struct compat_shared_info, wc) != 0x900);
	BUILD_BUG_ON(offsetof(struct compat_shared_info, arch.wc_sec_hi) != 0x924);
	BUILD_BUG_ON(offsetof(struct pvclock_vcpu_time_info, version) != 0);

#ifdef CONFIG_X86_64
	/* Paranoia checks on the 64-bit struct layout */
	BUILD_BUG_ON(offsetof(struct shared_info, wc) != 0xc00);
	BUILD_BUG_ON(offsetof(struct shared_info, wc_sec_hi) != 0xc0c);

<yellow>	if (IS_ENABLED(CONFIG_64BIT) && kvm->arch.xen.long_mode) {</yellow>
<yellow>		struct shared_info *shinfo = gpc->khva;</yellow>

<yellow>		wc_sec_hi = &shinfo->wc_sec_hi;</yellow>
		wc = &amp;shinfo-&gt;wc;
	} else
#endif
	{
		struct compat_shared_info *shinfo = gpc-&gt;khva;

<yellow>		wc_sec_hi = &shinfo->arch.wc_sec_hi;</yellow>
		wc = &amp;shinfo-&gt;wc;
	}

	/* Increment and ensure an odd value */
<yellow>	wc_version = wc->version = (wc->version + 1) | 1;</yellow>
	smp_wmb();

	wc-&gt;nsec = do_div(wall_nsec,  1000000000);
	wc-&gt;sec = (u32)wall_nsec;
	*wc_sec_hi = wall_nsec &gt;&gt; 32;
	smp_wmb();

	wc-&gt;version = wc_version + 1;
	read_unlock_irq(&amp;gpc-&gt;lock);

	kvm_make_all_cpus_request(kvm, KVM_REQ_MASTERCLOCK_UPDATE);

out:
<yellow>	srcu_read_unlock(&kvm->srcu, idx);</yellow>
	return ret;
}

void kvm_xen_inject_timer_irqs(struct kvm_vcpu *vcpu)
<yellow>{</yellow>
<yellow>	if (atomic_read(&vcpu->arch.xen.timer_pending) > 0) {</yellow>
		struct kvm_xen_evtchn e;

<yellow>		e.vcpu_id = vcpu->vcpu_id;</yellow>
		e.vcpu_idx = vcpu-&gt;vcpu_idx;
		e.port = vcpu-&gt;arch.xen.timer_virq;
		e.priority = KVM_IRQ_ROUTING_XEN_EVTCHN_PRIO_2LEVEL;

<yellow>		kvm_xen_set_evtchn(&e, vcpu->kvm);</yellow>

<yellow>		vcpu->arch.xen.timer_expires = 0;</yellow>
		atomic_set(&amp;vcpu-&gt;arch.xen.timer_pending, 0);
	}
}

static enum hrtimer_restart xen_timer_callback(struct hrtimer *timer)
{
	struct kvm_vcpu *vcpu = container_of(timer, struct kvm_vcpu,
					     arch.xen.timer);
<yellow>	if (atomic_read(&vcpu->arch.xen.timer_pending))</yellow>
		return HRTIMER_NORESTART;

<yellow>	atomic_inc(&vcpu->arch.xen.timer_pending);</yellow>
	kvm_make_request(KVM_REQ_UNBLOCK, vcpu);
	kvm_vcpu_kick(vcpu);

	return HRTIMER_NORESTART;
<yellow>}</yellow>

static void kvm_xen_start_timer(struct kvm_vcpu *vcpu, u64 guest_abs, s64 delta_ns)
{
<yellow>	atomic_set(&vcpu->arch.xen.timer_pending, 0);</yellow>
<yellow>	vcpu->arch.xen.timer_expires = guest_abs;</yellow>

	if (delta_ns &lt;= 0) {
<yellow>		xen_timer_callback(&vcpu->arch.xen.timer);</yellow>
	} else {
		ktime_t ktime_now = ktime_get();
		hrtimer_start(&amp;vcpu-&gt;arch.xen.timer,
			      ktime_add_ns(ktime_now, delta_ns),
			      HRTIMER_MODE_ABS_HARD);
	}
}

static void kvm_xen_stop_timer(struct kvm_vcpu *vcpu)
{
<yellow>	hrtimer_cancel(&vcpu->arch.xen.timer);</yellow>
	vcpu-&gt;arch.xen.timer_expires = 0;
	atomic_set(&amp;vcpu-&gt;arch.xen.timer_pending, 0);
}

static void kvm_xen_init_timer(struct kvm_vcpu *vcpu)
{
<yellow>	hrtimer_init(&vcpu->arch.xen.timer, CLOCK_MONOTONIC,</yellow>
		     HRTIMER_MODE_ABS_HARD);
	vcpu-&gt;arch.xen.timer.function = xen_timer_callback;
}

static void kvm_xen_update_runstate(struct kvm_vcpu *v, int state)
{
	struct kvm_vcpu_xen *vx = &amp;v-&gt;arch.xen;
<yellow>	u64 now = get_kvmclock_ns(v->kvm);</yellow>
	u64 delta_ns = now - vx-&gt;runstate_entry_time;
	u64 run_delay = current-&gt;sched_info.run_delay;

	if (unlikely(!vx-&gt;runstate_entry_time))
<yellow>		vx->current_runstate = RUNSTATE_offline;</yellow>

	/*
	 * Time waiting for the scheduler isn&#x27;t &quot;stolen&quot; if the
	 * vCPU wasn&#x27;t running anyway.
	 */
<yellow>	if (vx->current_runstate == RUNSTATE_running) {</yellow>
<yellow>		u64 steal_ns = run_delay - vx->last_steal;</yellow>

		delta_ns -= steal_ns;

		vx-&gt;runstate_times[RUNSTATE_runnable] += steal_ns;
	}
<yellow>	vx->last_steal = run_delay;</yellow>

	vx-&gt;runstate_times[vx-&gt;current_runstate] += delta_ns;
	vx-&gt;current_runstate = state;
	vx-&gt;runstate_entry_time = now;
}

void kvm_xen_update_runstate_guest(struct kvm_vcpu *v, int state)
{
	struct kvm_vcpu_xen *vx = &amp;v-&gt;arch.xen;
	struct gfn_to_pfn_cache *gpc = &amp;vx-&gt;runstate_cache;
	uint64_t *user_times;
	unsigned long flags;
	size_t user_len;
	int *user_state;

<yellow>	kvm_xen_update_runstate(v, state);</yellow>

<yellow>	if (!vx->runstate_cache.active)</yellow>
		return;

<yellow>	if (IS_ENABLED(CONFIG_64BIT) && v->kvm->arch.xen.long_mode)</yellow>
		user_len = sizeof(struct vcpu_runstate_info);
	else
		user_len = sizeof(struct compat_vcpu_runstate_info);

<yellow>	read_lock_irqsave(&gpc->lock, flags);</yellow>
<yellow>	while (!kvm_gfn_to_pfn_cache_check(v->kvm, gpc, gpc->gpa,</yellow>
					   user_len)) {
<yellow>		read_unlock_irqrestore(&gpc->lock, flags);</yellow>

		/* When invoked from kvm_sched_out() we cannot sleep */
		if (state == RUNSTATE_runnable)
			return;

<yellow>		if (kvm_gfn_to_pfn_cache_refresh(v->kvm, gpc, gpc->gpa, user_len))</yellow>
			return;

<yellow>		read_lock_irqsave(&gpc->lock, flags);</yellow>
	}

	/*
	 * The only difference between 32-bit and 64-bit versions of the
	 * runstate struct us the alignment of uint64_t in 32-bit, which
	 * means that the 64-bit version has an additional 4 bytes of
	 * padding after the first field &#x27;state&#x27;.
	 *
	 * So we use &#x27;int __user *user_state&#x27; to point to the state field,
	 * and &#x27;uint64_t __user *user_times&#x27; for runstate_entry_time. So
	 * the actual array of time[] in each state starts at user_times[1].
	 */
	BUILD_BUG_ON(offsetof(struct vcpu_runstate_info, state) != 0);
	BUILD_BUG_ON(offsetof(struct compat_vcpu_runstate_info, state) != 0);
	BUILD_BUG_ON(sizeof(struct compat_vcpu_runstate_info) != 0x2c);
#ifdef CONFIG_X86_64
	BUILD_BUG_ON(offsetof(struct vcpu_runstate_info, state_entry_time) !=
		     offsetof(struct compat_vcpu_runstate_info, state_entry_time) + 4);
	BUILD_BUG_ON(offsetof(struct vcpu_runstate_info, time) !=
		     offsetof(struct compat_vcpu_runstate_info, time) + 4);
#endif

<yellow>	user_state = gpc->khva;</yellow>

<yellow>	if (IS_ENABLED(CONFIG_64BIT) && v->kvm->arch.xen.long_mode)</yellow>
<yellow>		user_times = gpc->khva + offsetof(struct vcpu_runstate_info,</yellow>
						  state_entry_time);
	else
<yellow>		user_times = gpc->khva + offsetof(struct compat_vcpu_runstate_info,</yellow>
						  state_entry_time);

	/*
	 * First write the updated state_entry_time at the appropriate
	 * location determined by &#x27;offset&#x27;.
	 */
	BUILD_BUG_ON(sizeof_field(struct vcpu_runstate_info, state_entry_time) !=
		     sizeof(user_times[0]));
	BUILD_BUG_ON(sizeof_field(struct compat_vcpu_runstate_info, state_entry_time) !=
		     sizeof(user_times[0]));

<yellow>	user_times[0] = vx->runstate_entry_time | XEN_RUNSTATE_UPDATE;</yellow>
	smp_wmb();

	/*
	 * Next, write the new runstate. This is in the *same* place
	 * for 32-bit and 64-bit guests, asserted here for paranoia.
	 */
	BUILD_BUG_ON(offsetof(struct vcpu_runstate_info, state) !=
		     offsetof(struct compat_vcpu_runstate_info, state));
	BUILD_BUG_ON(sizeof_field(struct vcpu_runstate_info, state) !=
		     sizeof(vx-&gt;current_runstate));
	BUILD_BUG_ON(sizeof_field(struct compat_vcpu_runstate_info, state) !=
		     sizeof(vx-&gt;current_runstate));

	*user_state = vx-&gt;current_runstate;

	/*
	 * Write the actual runstate times immediately after the
	 * runstate_entry_time.
	 */
	BUILD_BUG_ON(offsetof(struct vcpu_runstate_info, state_entry_time) !=
		     offsetof(struct vcpu_runstate_info, time) - sizeof(u64));
	BUILD_BUG_ON(offsetof(struct compat_vcpu_runstate_info, state_entry_time) !=
		     offsetof(struct compat_vcpu_runstate_info, time) - sizeof(u64));
	BUILD_BUG_ON(sizeof_field(struct vcpu_runstate_info, time) !=
		     sizeof_field(struct compat_vcpu_runstate_info, time));
	BUILD_BUG_ON(sizeof_field(struct vcpu_runstate_info, time) !=
		     sizeof(vx-&gt;runstate_times));

	memcpy(user_times + 1, vx-&gt;runstate_times, sizeof(vx-&gt;runstate_times));
	smp_wmb();

	/*
	 * Finally, clear the XEN_RUNSTATE_UPDATE bit in the guest&#x27;s
	 * runstate_entry_time field.
	 */
	user_times[0] &amp;= ~XEN_RUNSTATE_UPDATE;
	smp_wmb();

	read_unlock_irqrestore(&amp;gpc-&gt;lock, flags);

	mark_page_dirty_in_slot(v-&gt;kvm, gpc-&gt;memslot, gpc-&gt;gpa &gt;&gt; PAGE_SHIFT);
<yellow>}</yellow>

<yellow>static void kvm_xen_inject_vcpu_vector(struct kvm_vcpu *v)</yellow>
{
	struct kvm_lapic_irq irq = { };
	int r;

	irq.dest_id = v-&gt;vcpu_id;
	irq.vector = v-&gt;arch.xen.upcall_vector;
	irq.dest_mode = APIC_DEST_PHYSICAL;
	irq.shorthand = APIC_DEST_NOSHORT;
	irq.delivery_mode = APIC_DM_FIXED;
	irq.level = 1;

	/* The fast version will always work for physical unicast */
<yellow>	WARN_ON_ONCE(!kvm_irq_delivery_to_apic_fast(v->kvm, NULL, &irq, &r, NULL));</yellow>
}

/*
 * On event channel delivery, the vcpu_info may not have been accessible.
 * In that case, there are bits in vcpu-&gt;arch.xen.evtchn_pending_sel which
 * need to be marked into the vcpu_info (and evtchn_upcall_pending set).
 * Do so now that we can sleep in the context of the vCPU to bring the
 * page in, and refresh the pfn cache for it.
 */
void kvm_xen_inject_pending_events(struct kvm_vcpu *v)
{
<yellow>	unsigned long evtchn_pending_sel = READ_ONCE(v->arch.xen.evtchn_pending_sel);</yellow>
	struct gfn_to_pfn_cache *gpc = &amp;v-&gt;arch.xen.vcpu_info_cache;
	unsigned long flags;

	if (!evtchn_pending_sel)
		return;

	/*
	 * Yes, this is an open-coded loop. But that&#x27;s just what put_user()
	 * does anyway. Page it in and retry the instruction. We&#x27;re just a
	 * little more honest about it.
	 */
<yellow>	read_lock_irqsave(&gpc->lock, flags);</yellow>
<yellow>	while (!kvm_gfn_to_pfn_cache_check(v->kvm, gpc, gpc->gpa,</yellow>
					   sizeof(struct vcpu_info))) {
<yellow>		read_unlock_irqrestore(&gpc->lock, flags);</yellow>

		if (kvm_gfn_to_pfn_cache_refresh(v-&gt;kvm, gpc, gpc-&gt;gpa,
						 sizeof(struct vcpu_info)))
			return;

<yellow>		read_lock_irqsave(&gpc->lock, flags);</yellow>
	}

	/* Now gpc-&gt;khva is a valid kernel address for the vcpu_info */
<yellow>	if (IS_ENABLED(CONFIG_64BIT) && v->kvm->arch.xen.long_mode) {</yellow>
<yellow>		struct vcpu_info *vi = gpc->khva;</yellow>

<yellow>		asm volatile(LOCK_PREFIX "orq %0, %1\n"</yellow>
			     &quot;notq %0\n&quot;
			     LOCK_PREFIX &quot;andq %0, %2\n&quot;
			     : &quot;=r&quot; (evtchn_pending_sel),
			       &quot;+m&quot; (vi-&gt;evtchn_pending_sel),
			       &quot;+m&quot; (v-&gt;arch.xen.evtchn_pending_sel)
			     : &quot;0&quot; (evtchn_pending_sel));
		WRITE_ONCE(vi-&gt;evtchn_upcall_pending, 1);
	} else {
		u32 evtchn_pending_sel32 = evtchn_pending_sel;
		struct compat_vcpu_info *vi = gpc-&gt;khva;

<yellow>		asm volatile(LOCK_PREFIX "orl %0, %1\n"</yellow>
			     &quot;notl %0\n&quot;
			     LOCK_PREFIX &quot;andl %0, %2\n&quot;
			     : &quot;=r&quot; (evtchn_pending_sel32),
			       &quot;+m&quot; (vi-&gt;evtchn_pending_sel),
			       &quot;+m&quot; (v-&gt;arch.xen.evtchn_pending_sel)
			     : &quot;0&quot; (evtchn_pending_sel32));
		WRITE_ONCE(vi-&gt;evtchn_upcall_pending, 1);
	}
<yellow>	read_unlock_irqrestore(&gpc->lock, flags);</yellow>

	/* For the per-vCPU lapic vector, deliver it as MSI. */
	if (v-&gt;arch.xen.upcall_vector)
<yellow>		kvm_xen_inject_vcpu_vector(v);</yellow>

<yellow>	mark_page_dirty_in_slot(v->kvm, gpc->memslot, gpc->gpa >> PAGE_SHIFT);</yellow>
<yellow>}</yellow>

int __kvm_xen_has_interrupt(struct kvm_vcpu *v)
{
	struct gfn_to_pfn_cache *gpc = &amp;v-&gt;arch.xen.vcpu_info_cache;
	unsigned long flags;
	u8 rc = 0;

	/*
	 * If the global upcall vector (HVMIRQ_callback_vector) is set and
	 * the vCPU&#x27;s evtchn_upcall_pending flag is set, the IRQ is pending.
	 */

	/* No need for compat handling here */
	BUILD_BUG_ON(offsetof(struct vcpu_info, evtchn_upcall_pending) !=
		     offsetof(struct compat_vcpu_info, evtchn_upcall_pending));
	BUILD_BUG_ON(sizeof(rc) !=
		     sizeof_field(struct vcpu_info, evtchn_upcall_pending));
	BUILD_BUG_ON(sizeof(rc) !=
		     sizeof_field(struct compat_vcpu_info, evtchn_upcall_pending));

<yellow>	read_lock_irqsave(&gpc->lock, flags);</yellow>
<yellow>	while (!kvm_gfn_to_pfn_cache_check(v->kvm, gpc, gpc->gpa,</yellow>
					   sizeof(struct vcpu_info))) {
<yellow>		read_unlock_irqrestore(&gpc->lock, flags);</yellow>

		/*
		 * This function gets called from kvm_vcpu_block() after setting the
		 * task to TASK_INTERRUPTIBLE, to see if it needs to wake immediately
		 * from a HLT. So we really mustn&#x27;t sleep. If the page ended up absent
		 * at that point, just return 1 in order to trigger an immediate wake,
		 * and we&#x27;ll end up getting called again from a context where we *can*
		 * fault in the page and wait for it.
		 */
<yellow>		if (in_atomic() || !task_is_running(current))</yellow>
			return 1;

<yellow>		if (kvm_gfn_to_pfn_cache_refresh(v->kvm, gpc, gpc->gpa,</yellow>
						 sizeof(struct vcpu_info))) {
			/*
			 * If this failed, userspace has screwed up the
			 * vcpu_info mapping. No interrupts for you.
			 */
			return 0;
		}
<yellow>		read_lock_irqsave(&gpc->lock, flags);</yellow>
	}

<yellow>	rc = ((struct vcpu_info *)gpc->khva)->evtchn_upcall_pending;</yellow>
	read_unlock_irqrestore(&amp;gpc-&gt;lock, flags);
	return rc;
<yellow>}</yellow>

int kvm_xen_hvm_set_attr(struct kvm *kvm, struct kvm_xen_hvm_attr *data)
<yellow>{</yellow>
	int r = -ENOENT;


<yellow>	switch (data->type) {</yellow>
	case KVM_XEN_ATTR_TYPE_LONG_MODE:
		if (!IS_ENABLED(CONFIG_64BIT) &amp;&amp; data-&gt;u.long_mode) {
			r = -EINVAL;
		} else {
<yellow>			mutex_lock(&kvm->lock);</yellow>
			kvm-&gt;arch.xen.long_mode = !!data-&gt;u.long_mode;
			mutex_unlock(&amp;kvm-&gt;lock);
			r = 0;
		}
		break;

	case KVM_XEN_ATTR_TYPE_SHARED_INFO:
<yellow>		mutex_lock(&kvm->lock);</yellow>
<yellow>		r = kvm_xen_shared_info_init(kvm, data->u.shared_info.gfn);</yellow>
		mutex_unlock(&amp;kvm-&gt;lock);
		break;

	case KVM_XEN_ATTR_TYPE_UPCALL_VECTOR:
<yellow>		if (data->u.vector && data->u.vector < 0x10)</yellow>
			r = -EINVAL;
		else {
<yellow>			mutex_lock(&kvm->lock);</yellow>
			kvm-&gt;arch.xen.upcall_vector = data-&gt;u.vector;
			mutex_unlock(&amp;kvm-&gt;lock);
			r = 0;
		}
		break;

	case KVM_XEN_ATTR_TYPE_EVTCHN:
<yellow>		r = kvm_xen_setattr_evtchn(kvm, data);</yellow>
		break;

	case KVM_XEN_ATTR_TYPE_XEN_VERSION:
<yellow>		mutex_lock(&kvm->lock);</yellow>
		kvm-&gt;arch.xen.xen_version = data-&gt;u.xen_version;
		mutex_unlock(&amp;kvm-&gt;lock);
		r = 0;
		break;

	default:
		break;
	}

	return r;
}

int kvm_xen_hvm_get_attr(struct kvm *kvm, struct kvm_xen_hvm_attr *data)
{
	int r = -ENOENT;

<yellow>	mutex_lock(&kvm->lock);</yellow>

	switch (data-&gt;type) {
	case KVM_XEN_ATTR_TYPE_LONG_MODE:
<yellow>		data->u.long_mode = kvm->arch.xen.long_mode;</yellow>
		r = 0;
		break;

	case KVM_XEN_ATTR_TYPE_SHARED_INFO:
<yellow>		if (kvm->arch.xen.shinfo_cache.active)</yellow>
<yellow>			data->u.shared_info.gfn = gpa_to_gfn(kvm->arch.xen.shinfo_cache.gpa);</yellow>
		else
<yellow>			data->u.shared_info.gfn = GPA_INVALID;</yellow>
		r = 0;
		break;

	case KVM_XEN_ATTR_TYPE_UPCALL_VECTOR:
<yellow>		data->u.vector = kvm->arch.xen.upcall_vector;</yellow>
		r = 0;
		break;

	case KVM_XEN_ATTR_TYPE_XEN_VERSION:
<yellow>		data->u.xen_version = kvm->arch.xen.xen_version;</yellow>
		r = 0;
		break;

	default:
		break;
	}

<yellow>	mutex_unlock(&kvm->lock);</yellow>
	return r;
}

int kvm_xen_vcpu_set_attr(struct kvm_vcpu *vcpu, struct kvm_xen_vcpu_attr *data)
{
	int idx, r = -ENOENT;

<yellow>	mutex_lock(&vcpu->kvm->lock);</yellow>
	idx = srcu_read_lock(&amp;vcpu-&gt;kvm-&gt;srcu);

	switch (data-&gt;type) {
	case KVM_XEN_VCPU_ATTR_TYPE_VCPU_INFO:
		/* No compat necessary here. */
		BUILD_BUG_ON(sizeof(struct vcpu_info) !=
			     sizeof(struct compat_vcpu_info));
		BUILD_BUG_ON(offsetof(struct vcpu_info, time) !=
			     offsetof(struct compat_vcpu_info, time));

<yellow>		if (data->u.gpa == GPA_INVALID) {</yellow>
			kvm_gpc_deactivate(vcpu-&gt;kvm, &amp;vcpu-&gt;arch.xen.vcpu_info_cache);
			r = 0;
			break;
		}

<yellow>		r = kvm_gpc_activate(vcpu->kvm,</yellow>
				     &amp;vcpu-&gt;arch.xen.vcpu_info_cache, NULL,
				     KVM_HOST_USES_PFN, data-&gt;u.gpa,
				     sizeof(struct vcpu_info));
		if (!r)
			kvm_make_request(KVM_REQ_CLOCK_UPDATE, vcpu);

		break;

	case KVM_XEN_VCPU_ATTR_TYPE_VCPU_TIME_INFO:
<yellow>		if (data->u.gpa == GPA_INVALID) {</yellow>
			kvm_gpc_deactivate(vcpu-&gt;kvm,
					   &amp;vcpu-&gt;arch.xen.vcpu_time_info_cache);
			r = 0;
			break;
		}

<yellow>		r = kvm_gpc_activate(vcpu->kvm,</yellow>
				     &amp;vcpu-&gt;arch.xen.vcpu_time_info_cache,
				     NULL, KVM_HOST_USES_PFN, data-&gt;u.gpa,
				     sizeof(struct pvclock_vcpu_time_info));
		if (!r)
<yellow>			kvm_make_request(KVM_REQ_CLOCK_UPDATE, vcpu);</yellow>
		break;

	case KVM_XEN_VCPU_ATTR_TYPE_RUNSTATE_ADDR:
		if (!sched_info_on()) {
			r = -EOPNOTSUPP;
			break;
		}
<yellow>		if (data->u.gpa == GPA_INVALID) {</yellow>
<yellow>			kvm_gpc_deactivate(vcpu->kvm,</yellow>
					   &amp;vcpu-&gt;arch.xen.runstate_cache);
			r = 0;
			break;
		}

<yellow>		r = kvm_gpc_activate(vcpu->kvm, &vcpu->arch.xen.runstate_cache,</yellow>
				     NULL, KVM_HOST_USES_PFN, data-&gt;u.gpa,
				     sizeof(struct vcpu_runstate_info));
		break;

	case KVM_XEN_VCPU_ATTR_TYPE_RUNSTATE_CURRENT:
		if (!sched_info_on()) {
			r = -EOPNOTSUPP;
			break;
		}
<yellow>		if (data->u.runstate.state > RUNSTATE_offline) {</yellow>
			r = -EINVAL;
			break;
		}

		kvm_xen_update_runstate(vcpu, data-&gt;u.runstate.state);
		r = 0;
		break;

	case KVM_XEN_VCPU_ATTR_TYPE_RUNSTATE_DATA:
		if (!sched_info_on()) {
			r = -EOPNOTSUPP;
			break;
		}
<yellow>		if (data->u.runstate.state > RUNSTATE_offline) {</yellow>
			r = -EINVAL;
			break;
		}
<yellow>		if (data->u.runstate.state_entry_time !=</yellow>
		    (data-&gt;u.runstate.time_running +
		     data-&gt;u.runstate.time_runnable +
		     data-&gt;u.runstate.time_blocked +
		     data-&gt;u.runstate.time_offline)) {
			r = -EINVAL;
			break;
		}
<yellow>		if (get_kvmclock_ns(vcpu->kvm) <</yellow>
		    data-&gt;u.runstate.state_entry_time) {
			r = -EINVAL;
			break;
		}

<yellow>		vcpu->arch.xen.current_runstate = data->u.runstate.state;</yellow>
		vcpu-&gt;arch.xen.runstate_entry_time =
			data-&gt;u.runstate.state_entry_time;
		vcpu-&gt;arch.xen.runstate_times[RUNSTATE_running] =
			data-&gt;u.runstate.time_running;
		vcpu-&gt;arch.xen.runstate_times[RUNSTATE_runnable] =
			data-&gt;u.runstate.time_runnable;
		vcpu-&gt;arch.xen.runstate_times[RUNSTATE_blocked] =
			data-&gt;u.runstate.time_blocked;
		vcpu-&gt;arch.xen.runstate_times[RUNSTATE_offline] =
			data-&gt;u.runstate.time_offline;
		vcpu-&gt;arch.xen.last_steal = current-&gt;sched_info.run_delay;
		r = 0;
		break;

	case KVM_XEN_VCPU_ATTR_TYPE_RUNSTATE_ADJUST:
		if (!sched_info_on()) {
			r = -EOPNOTSUPP;
			break;
		}
<yellow>		if (data->u.runstate.state > RUNSTATE_offline &&</yellow>
		    data-&gt;u.runstate.state != (u64)-1) {
			r = -EINVAL;
			break;
		}
		/* The adjustment must add up */
<yellow>		if (data->u.runstate.state_entry_time !=</yellow>
		    (data-&gt;u.runstate.time_running +
		     data-&gt;u.runstate.time_runnable +
		     data-&gt;u.runstate.time_blocked +
		     data-&gt;u.runstate.time_offline)) {
			r = -EINVAL;
			break;
		}

<yellow>		if (get_kvmclock_ns(vcpu->kvm) <</yellow>
		    (vcpu-&gt;arch.xen.runstate_entry_time +
		     data-&gt;u.runstate.state_entry_time)) {
			r = -EINVAL;
			break;
		}

		vcpu-&gt;arch.xen.runstate_entry_time +=
			data-&gt;u.runstate.state_entry_time;
<yellow>		vcpu->arch.xen.runstate_times[RUNSTATE_running] +=</yellow>
			data-&gt;u.runstate.time_running;
		vcpu-&gt;arch.xen.runstate_times[RUNSTATE_runnable] +=
			data-&gt;u.runstate.time_runnable;
		vcpu-&gt;arch.xen.runstate_times[RUNSTATE_blocked] +=
			data-&gt;u.runstate.time_blocked;
		vcpu-&gt;arch.xen.runstate_times[RUNSTATE_offline] +=
			data-&gt;u.runstate.time_offline;

		if (data-&gt;u.runstate.state &lt;= RUNSTATE_offline)
<yellow>			kvm_xen_update_runstate(vcpu, data->u.runstate.state);</yellow>
		r = 0;
		break;

	case KVM_XEN_VCPU_ATTR_TYPE_VCPU_ID:
<yellow>		if (data->u.vcpu_id >= KVM_MAX_VCPUS)</yellow>
			r = -EINVAL;
		else {
<yellow>			vcpu->arch.xen.vcpu_id = data->u.vcpu_id;</yellow>
			r = 0;
		}
		break;

	case KVM_XEN_VCPU_ATTR_TYPE_TIMER:
<yellow>		if (data->u.timer.port &&</yellow>
<yellow>		    data->u.timer.priority != KVM_IRQ_ROUTING_XEN_EVTCHN_PRIO_2LEVEL) {</yellow>
			r = -EINVAL;
			break;
		}

<yellow>		if (!vcpu->arch.xen.timer.function)</yellow>
<yellow>			kvm_xen_init_timer(vcpu);</yellow>

		/* Stop the timer (if it&#x27;s running) before changing the vector */
<yellow>		kvm_xen_stop_timer(vcpu);</yellow>
		vcpu-&gt;arch.xen.timer_virq = data-&gt;u.timer.port;

		/* Start the timer if the new value has a valid vector+expiry. */
<yellow>		if (data->u.timer.port && data->u.timer.expires_ns)</yellow>
<yellow>			kvm_xen_start_timer(vcpu, data->u.timer.expires_ns,</yellow>
					    data-&gt;u.timer.expires_ns -
<yellow>					    get_kvmclock_ns(vcpu->kvm));</yellow>

<yellow>		r = 0;</yellow>
		break;

	case KVM_XEN_VCPU_ATTR_TYPE_UPCALL_VECTOR:
<yellow>		if (data->u.vector && data->u.vector < 0x10)</yellow>
			r = -EINVAL;
		else {
<yellow>			vcpu->arch.xen.upcall_vector = data->u.vector;</yellow>
			r = 0;
		}
		break;

	default:
		break;
	}

<yellow>	srcu_read_unlock(&vcpu->kvm->srcu, idx);</yellow>
	mutex_unlock(&amp;vcpu-&gt;kvm-&gt;lock);
	return r;
}

int kvm_xen_vcpu_get_attr(struct kvm_vcpu *vcpu, struct kvm_xen_vcpu_attr *data)
{
	int r = -ENOENT;

<yellow>	mutex_lock(&vcpu->kvm->lock);</yellow>

	switch (data-&gt;type) {
	case KVM_XEN_VCPU_ATTR_TYPE_VCPU_INFO:
<yellow>		if (vcpu->arch.xen.vcpu_info_cache.active)</yellow>
<yellow>			data->u.gpa = vcpu->arch.xen.vcpu_info_cache.gpa;</yellow>
		else
<yellow>			data->u.gpa = GPA_INVALID;</yellow>
		r = 0;
		break;

	case KVM_XEN_VCPU_ATTR_TYPE_VCPU_TIME_INFO:
<yellow>		if (vcpu->arch.xen.vcpu_time_info_cache.active)</yellow>
<yellow>			data->u.gpa = vcpu->arch.xen.vcpu_time_info_cache.gpa;</yellow>
		else
			data-&gt;u.gpa = GPA_INVALID;
		r = 0;
		break;

	case KVM_XEN_VCPU_ATTR_TYPE_RUNSTATE_ADDR:
		if (!sched_info_on()) {
			r = -EOPNOTSUPP;
			break;
		}
<yellow>		if (vcpu->arch.xen.runstate_cache.active) {</yellow>
<yellow>			data->u.gpa = vcpu->arch.xen.runstate_cache.gpa;</yellow>
			r = 0;
		}
		break;

	case KVM_XEN_VCPU_ATTR_TYPE_RUNSTATE_CURRENT:
		if (!sched_info_on()) {
			r = -EOPNOTSUPP;
			break;
		}
<yellow>		data->u.runstate.state = vcpu->arch.xen.current_runstate;</yellow>
		r = 0;
		break;

	case KVM_XEN_VCPU_ATTR_TYPE_RUNSTATE_DATA:
		if (!sched_info_on()) {
			r = -EOPNOTSUPP;
			break;
		}
<yellow>		data->u.runstate.state = vcpu->arch.xen.current_runstate;</yellow>
		data-&gt;u.runstate.state_entry_time =
			vcpu-&gt;arch.xen.runstate_entry_time;
		data-&gt;u.runstate.time_running =
			vcpu-&gt;arch.xen.runstate_times[RUNSTATE_running];
		data-&gt;u.runstate.time_runnable =
			vcpu-&gt;arch.xen.runstate_times[RUNSTATE_runnable];
		data-&gt;u.runstate.time_blocked =
			vcpu-&gt;arch.xen.runstate_times[RUNSTATE_blocked];
		data-&gt;u.runstate.time_offline =
			vcpu-&gt;arch.xen.runstate_times[RUNSTATE_offline];
		r = 0;
		break;

	case KVM_XEN_VCPU_ATTR_TYPE_RUNSTATE_ADJUST:
		r = -EINVAL;
		break;

	case KVM_XEN_VCPU_ATTR_TYPE_VCPU_ID:
<yellow>		data->u.vcpu_id = vcpu->arch.xen.vcpu_id;</yellow>
		r = 0;
		break;

	case KVM_XEN_VCPU_ATTR_TYPE_TIMER:
<yellow>		data->u.timer.port = vcpu->arch.xen.timer_virq;</yellow>
		data-&gt;u.timer.priority = KVM_IRQ_ROUTING_XEN_EVTCHN_PRIO_2LEVEL;
		data-&gt;u.timer.expires_ns = vcpu-&gt;arch.xen.timer_expires;
		r = 0;
		break;

	case KVM_XEN_VCPU_ATTR_TYPE_UPCALL_VECTOR:
<yellow>		data->u.vector = vcpu->arch.xen.upcall_vector;</yellow>
		r = 0;
		break;

	default:
		break;
	}

<yellow>	mutex_unlock(&vcpu->kvm->lock);</yellow>
	return r;
}

int kvm_xen_write_hypercall_page(struct kvm_vcpu *vcpu, u64 data)
<yellow>{</yellow>
<yellow>	struct kvm *kvm = vcpu->kvm;</yellow>
	u32 page_num = data &amp; ~PAGE_MASK;
	u64 page_addr = data &amp; PAGE_MASK;
	bool lm = is_long_mode(vcpu);

	/* Latch long_mode for shared_info pages etc. */
	vcpu-&gt;kvm-&gt;arch.xen.long_mode = lm;

	/*
	 * If Xen hypercall intercept is enabled, fill the hypercall
	 * page with VMCALL/VMMCALL instructions since that&#x27;s what
	 * we catch. Else the VMM has provided the hypercall pages
	 * with instructions of its own choosing, so use those.
	 */
<yellow>	if (kvm_xen_hypercall_enabled(kvm)) {</yellow>
		u8 instructions[32];
		int i;

<yellow>		if (page_num)</yellow>
<yellow>			return 1;</yellow>

		/* mov imm32, %eax */
		instructions[0] = 0xb8;

		/* vmcall / vmmcall */
<yellow>		static_call(kvm_x86_patch_hypercall)(vcpu, instructions + 5);</yellow>

		/* ret */
		instructions[8] = 0xc3;

		/* int3 to pad */
		memset(instructions + 9, 0xcc, sizeof(instructions) - 9);

<yellow>		for (i = 0; i < PAGE_SIZE / sizeof(instructions); i++) {</yellow>
			*(u32 *)&amp;instructions[1] = i;
<yellow>			if (kvm_vcpu_write_guest(vcpu,</yellow>
						 page_addr + (i * sizeof(instructions)),
						 instructions, sizeof(instructions)))
				return 1;
		}
	} else {
		/*
		 * Note, truncation is a non-issue as &#x27;lm&#x27; is guaranteed to be
		 * false for a 32-bit kernel, i.e. when hva_t is only 4 bytes.
		 */
		hva_t blob_addr = lm ? kvm-&gt;arch.xen_hvm_config.blob_addr_64
				     : kvm-&gt;arch.xen_hvm_config.blob_addr_32;
<yellow>		u8 blob_size = lm ? kvm->arch.xen_hvm_config.blob_size_64</yellow>
				  : kvm-&gt;arch.xen_hvm_config.blob_size_32;
		u8 *page;

<yellow>		if (page_num >= blob_size)</yellow>
			return 1;

<yellow>		blob_addr += page_num * PAGE_SIZE;</yellow>

		page = memdup_user((u8 __user *)blob_addr, PAGE_SIZE);
		if (IS_ERR(page))
<yellow>			return PTR_ERR(page);</yellow>

<yellow>		if (kvm_vcpu_write_guest(vcpu, page_addr, page, PAGE_SIZE)) {</yellow>
<yellow>			kfree(page);</yellow>
			return 1;
		}
	}
	return 0;
}

int kvm_xen_hvm_config(struct kvm *kvm, struct kvm_xen_hvm_config *xhc)
{
	/* Only some feature flags need to be *enabled* by userspace */
	u32 permitted_flags = KVM_XEN_HVM_CONFIG_INTERCEPT_HCALL |
		KVM_XEN_HVM_CONFIG_EVTCHN_SEND;

<yellow>	if (xhc->flags & ~permitted_flags)</yellow>
		return -EINVAL;

	/*
	 * With hypercall interception the kernel generates its own
	 * hypercall page so it must not be provided.
	 */
<yellow>	if ((xhc->flags & KVM_XEN_HVM_CONFIG_INTERCEPT_HCALL) &&</yellow>
<yellow>	    (xhc->blob_addr_32 || xhc->blob_addr_64 ||</yellow>
<yellow>	     xhc->blob_size_32 || xhc->blob_size_64))</yellow>
		return -EINVAL;

<yellow>	mutex_lock(&kvm->lock);</yellow>

<yellow>	if (xhc->msr && !kvm->arch.xen_hvm_config.msr)</yellow>
<yellow>		static_branch_inc(&kvm_xen_enabled.key);</yellow>
<yellow>	else if (!xhc->msr && kvm->arch.xen_hvm_config.msr)</yellow>
<yellow>		static_branch_slow_dec_deferred(&kvm_xen_enabled);</yellow>

<yellow>	memcpy(&kvm->arch.xen_hvm_config, xhc, sizeof(*xhc));</yellow>

	mutex_unlock(&amp;kvm-&gt;lock);
	return 0;
<yellow>}</yellow>

static int kvm_xen_hypercall_set_result(struct kvm_vcpu *vcpu, u64 result)
{
<yellow>	kvm_rax_write(vcpu, result);</yellow>
	return kvm_skip_emulated_instruction(vcpu);
}

static int kvm_xen_hypercall_complete_userspace(struct kvm_vcpu *vcpu)
{
<yellow>	struct kvm_run *run = vcpu->run;</yellow>

	if (unlikely(!kvm_is_linear_rip(vcpu, vcpu-&gt;arch.xen.hypercall_rip)))
<yellow>		return 1;</yellow>

<yellow>	return kvm_xen_hypercall_set_result(vcpu, run->xen.u.hcall.result);</yellow>
<yellow>}</yellow>

static inline int max_evtchn_port(struct kvm *kvm)
{
<yellow>	if (IS_ENABLED(CONFIG_64BIT) && kvm->arch.xen.long_mode)</yellow>
		return EVTCHN_2L_NR_CHANNELS;
	else
		return COMPAT_EVTCHN_2L_NR_CHANNELS;
}

static bool wait_pending_event(struct kvm_vcpu *vcpu, int nr_ports,
			       evtchn_port_t *ports)
{
	struct kvm *kvm = vcpu-&gt;kvm;
	struct gfn_to_pfn_cache *gpc = &amp;kvm-&gt;arch.xen.shinfo_cache;
	unsigned long *pending_bits;
	unsigned long flags;
	bool ret = true;
	int idx, i;

	read_lock_irqsave(&amp;gpc-&gt;lock, flags);
	idx = srcu_read_lock(&amp;kvm-&gt;srcu);
	if (!kvm_gfn_to_pfn_cache_check(kvm, gpc, gpc-&gt;gpa, PAGE_SIZE))
		goto out_rcu;

	ret = false;
<yellow>	if (IS_ENABLED(CONFIG_64BIT) && kvm->arch.xen.long_mode) {</yellow>
<yellow>		struct shared_info *shinfo = gpc->khva;</yellow>
		pending_bits = (unsigned long *)&amp;shinfo-&gt;evtchn_pending;
	} else {
		struct compat_shared_info *shinfo = gpc-&gt;khva;
		pending_bits = (unsigned long *)&amp;shinfo-&gt;evtchn_pending;
	}

<yellow>	for (i = 0; i < nr_ports; i++) {</yellow>
<yellow>		if (test_bit(ports[i], pending_bits)) {</yellow>
			ret = true;
			break;
		}
	}

 out_rcu:
<yellow>	srcu_read_unlock(&kvm->srcu, idx);</yellow>
	read_unlock_irqrestore(&amp;gpc-&gt;lock, flags);

	return ret;
}

static bool kvm_xen_schedop_poll(struct kvm_vcpu *vcpu, bool longmode,
				 u64 param, u64 *r)
{
	int idx, i;
	struct sched_poll sched_poll;
	evtchn_port_t port, *ports;
	gpa_t gpa;

<yellow>	if (!longmode || !lapic_in_kernel(vcpu) ||</yellow>
<yellow>	    !(vcpu->kvm->arch.xen_hvm_config.flags & KVM_XEN_HVM_CONFIG_EVTCHN_SEND))</yellow>
		return false;

<yellow>	idx = srcu_read_lock(&vcpu->kvm->srcu);</yellow>
	gpa = kvm_mmu_gva_to_gpa_system(vcpu, param, NULL);
<yellow>	srcu_read_unlock(&vcpu->kvm->srcu, idx);</yellow>

<yellow>	if (!gpa || kvm_vcpu_read_guest(vcpu, gpa, &sched_poll,</yellow>
					sizeof(sched_poll))) {
		*r = -EFAULT;
		return true;
	}

<yellow>	if (unlikely(sched_poll.nr_ports > 1)) {</yellow>
		/* Xen (unofficially) limits number of pollers to 128 */
<yellow>		if (sched_poll.nr_ports > 128) {</yellow>
			*r = -EINVAL;
			return true;
		}

<yellow>		ports = kmalloc_array(sched_poll.nr_ports,</yellow>
				      sizeof(*ports), GFP_KERNEL);
		if (!ports) {
			*r = -ENOMEM;
			return true;
		}
	} else
		ports = &amp;port;

<yellow>	for (i = 0; i < sched_poll.nr_ports; i++) {</yellow>
<yellow>		idx = srcu_read_lock(&vcpu->kvm->srcu);</yellow>
		gpa = kvm_mmu_gva_to_gpa_system(vcpu,
						(gva_t)(sched_poll.ports + i),
						NULL);
<yellow>		srcu_read_unlock(&vcpu->kvm->srcu, idx);</yellow>

<yellow>		if (!gpa || kvm_vcpu_read_guest(vcpu, gpa,</yellow>
						&amp;ports[i], sizeof(port))) {
			*r = -EFAULT;
			goto out;
		}
<yellow>		if (ports[i] >= max_evtchn_port(vcpu->kvm)) {</yellow>
			*r = -EINVAL;
			goto out;
		}
	}

<yellow>	if (sched_poll.nr_ports == 1)</yellow>
<yellow>		vcpu->arch.xen.poll_evtchn = port;</yellow>
	else
		vcpu-&gt;arch.xen.poll_evtchn = -1;

<yellow>	set_bit(vcpu->vcpu_idx, vcpu->kvm->arch.xen.poll_mask);</yellow>

<yellow>	if (!wait_pending_event(vcpu, sched_poll.nr_ports, ports)) {</yellow>
<yellow>		vcpu->arch.mp_state = KVM_MP_STATE_HALTED;</yellow>

		if (sched_poll.timeout)
			mod_timer(&amp;vcpu-&gt;arch.xen.poll_timer,
<yellow>				  jiffies + nsecs_to_jiffies(sched_poll.timeout));</yellow>

<yellow>		kvm_vcpu_halt(vcpu);</yellow>

		if (sched_poll.timeout)
<yellow>			del_timer(&vcpu->arch.xen.poll_timer);</yellow>

<yellow>		vcpu->arch.mp_state = KVM_MP_STATE_RUNNABLE;</yellow>
	}

<yellow>	vcpu->arch.xen.poll_evtchn = 0;</yellow>
	*r = 0;
out:
	/* Really, this is only needed in case of timeout */
<yellow>	clear_bit(vcpu->vcpu_idx, vcpu->kvm->arch.xen.poll_mask);</yellow>

	if (unlikely(sched_poll.nr_ports &gt; 1))
<yellow>		kfree(ports);</yellow>
	return true;
}

static void cancel_evtchn_poll(struct timer_list *t)
{
	struct kvm_vcpu *vcpu = from_timer(vcpu, t, arch.xen.poll_timer);

<yellow>	kvm_make_request(KVM_REQ_UNBLOCK, vcpu);</yellow>
	kvm_vcpu_kick(vcpu);
}

static bool kvm_xen_hcall_sched_op(struct kvm_vcpu *vcpu, bool longmode,
				   int cmd, u64 param, u64 *r)
{
<yellow>	switch (cmd) {</yellow>
	case SCHEDOP_poll:
<yellow>		if (kvm_xen_schedop_poll(vcpu, longmode, param, r))</yellow>
			return true;
		fallthrough;
	case SCHEDOP_yield:
<yellow>		kvm_vcpu_on_spin(vcpu, true);</yellow>
		*r = 0;
		return true;
	default:
		break;
	}

	return false;
}

struct compat_vcpu_set_singleshot_timer {
    uint64_t timeout_abs_ns;
    uint32_t flags;
} __attribute__((packed));

static bool kvm_xen_hcall_vcpu_op(struct kvm_vcpu *vcpu, bool longmode, int cmd,
				  int vcpu_id, u64 param, u64 *r)
{
	struct vcpu_set_singleshot_timer oneshot;
	s64 delta;
	gpa_t gpa;
	int idx;

<yellow>	if (!kvm_xen_timer_enabled(vcpu))</yellow>
		return false;

<yellow>	switch (cmd) {</yellow>
	case VCPUOP_set_singleshot_timer:
<yellow>		if (vcpu->arch.xen.vcpu_id != vcpu_id) {</yellow>
			*r = -EINVAL;
			return true;
		}
<yellow>		idx = srcu_read_lock(&vcpu->kvm->srcu);</yellow>
		gpa = kvm_mmu_gva_to_gpa_system(vcpu, param, NULL);
<yellow>		srcu_read_unlock(&vcpu->kvm->srcu, idx);</yellow>

		/*
		 * The only difference for 32-bit compat is the 4 bytes of
		 * padding after the interesting part of the structure. So
		 * for a faithful emulation of Xen we have to *try* to copy
		 * the padding and return -EFAULT if we can&#x27;t. Otherwise we
		 * might as well just have copied the 12-byte 32-bit struct.
		 */
		BUILD_BUG_ON(offsetof(struct compat_vcpu_set_singleshot_timer, timeout_abs_ns) !=
			     offsetof(struct vcpu_set_singleshot_timer, timeout_abs_ns));
		BUILD_BUG_ON(sizeof_field(struct compat_vcpu_set_singleshot_timer, timeout_abs_ns) !=
			     sizeof_field(struct vcpu_set_singleshot_timer, timeout_abs_ns));
		BUILD_BUG_ON(offsetof(struct compat_vcpu_set_singleshot_timer, flags) !=
			     offsetof(struct vcpu_set_singleshot_timer, flags));
		BUILD_BUG_ON(sizeof_field(struct compat_vcpu_set_singleshot_timer, flags) !=
			     sizeof_field(struct vcpu_set_singleshot_timer, flags));

		if (!gpa ||
<yellow>		    kvm_vcpu_read_guest(vcpu, gpa, &oneshot, longmode ? sizeof(oneshot) :</yellow>
					sizeof(struct compat_vcpu_set_singleshot_timer))) {
<yellow>			*r = -EFAULT;</yellow>
			return true;
		}

<yellow>		delta = oneshot.timeout_abs_ns - get_kvmclock_ns(vcpu->kvm);</yellow>
<yellow>		if ((oneshot.flags & VCPU_SSHOTTMR_future) && delta < 0) {</yellow>
<yellow>			*r = -ETIME;</yellow>
			return true;
		}

<yellow>		kvm_xen_start_timer(vcpu, oneshot.timeout_abs_ns, delta);</yellow>
<yellow>		*r = 0;</yellow>
		return true;

	case VCPUOP_stop_singleshot_timer:
<yellow>		if (vcpu->arch.xen.vcpu_id != vcpu_id) {</yellow>
<yellow>			*r = -EINVAL;</yellow>
			return true;
		}
<yellow>		kvm_xen_stop_timer(vcpu);</yellow>
		*r = 0;
		return true;
	}

	return false;
}

static bool kvm_xen_hcall_set_timer_op(struct kvm_vcpu *vcpu, uint64_t timeout,
				       u64 *r)
{
<yellow>	if (!kvm_xen_timer_enabled(vcpu))</yellow>
		return false;

<yellow>	if (timeout) {</yellow>
<yellow>		uint64_t guest_now = get_kvmclock_ns(vcpu->kvm);</yellow>
		int64_t delta = timeout - guest_now;

		/* Xen has a &#x27;Linux workaround&#x27; in do_set_timer_op() which
		 * checks for negative absolute timeout values (caused by
		 * integer overflow), and for values about 13 days in the
		 * future (2^50ns) which would be caused by jiffies
		 * overflow. For those cases, it sets the timeout 100ms in
		 * the future (not *too* soon, since if a guest really did
		 * set a long timeout on purpose we don&#x27;t want to keep
		 * churning CPU time by waking it up).
		 */
<yellow>		if (unlikely((int64_t)timeout < 0 ||</yellow>
			     (delta &gt; 0 &amp;&amp; (uint32_t) (delta &gt;&gt; 50) != 0))) {
			delta = 100 * NSEC_PER_MSEC;
			timeout = guest_now + delta;
		}

<yellow>		kvm_xen_start_timer(vcpu, timeout, delta);</yellow>
	} else {
<yellow>		kvm_xen_stop_timer(vcpu);</yellow>
	}

	*r = 0;
	return true;
}

int kvm_xen_hypercall(struct kvm_vcpu *vcpu)
<yellow>{</yellow>
	bool longmode;
	u64 input, params[6], r = -ENOSYS;
	bool handled = false;
	u8 cpl;

<yellow>	input = (u64)kvm_register_read(vcpu, VCPU_REGS_RAX);</yellow>

	/* Hyper-V hypercalls get bit 31 set in EAX */
<yellow>	if ((input & 0x80000000) &&</yellow>
<yellow>	    kvm_hv_hypercall_enabled(vcpu))</yellow>
<yellow>		return kvm_hv_hypercall(vcpu);</yellow>

<yellow>	longmode = is_64_bit_hypercall(vcpu);</yellow>
	if (!longmode) {
<yellow>		params[0] = (u32)kvm_rbx_read(vcpu);</yellow>
		params[1] = (u32)kvm_rcx_read(vcpu);
		params[2] = (u32)kvm_rdx_read(vcpu);
		params[3] = (u32)kvm_rsi_read(vcpu);
		params[4] = (u32)kvm_rdi_read(vcpu);
		params[5] = (u32)kvm_rbp_read(vcpu);
	}
#ifdef CONFIG_X86_64
	else {
<yellow>		params[0] = (u64)kvm_rdi_read(vcpu);</yellow>
		params[1] = (u64)kvm_rsi_read(vcpu);
		params[2] = (u64)kvm_rdx_read(vcpu);
		params[3] = (u64)kvm_r10_read(vcpu);
		params[4] = (u64)kvm_r8_read(vcpu);
		params[5] = (u64)kvm_r9_read(vcpu);
	}
#endif
<yellow>	cpl = static_call(kvm_x86_get_cpl)(vcpu);</yellow>
<yellow>	trace_kvm_xen_hypercall(input, params[0], params[1], params[2],</yellow>
				params[3], params[4], params[5]);

	/*
	 * Only allow hypercall acceleration for CPL0. The rare hypercalls that
	 * are permitted in guest userspace can be handled by the VMM.
	 */
<yellow>	if (unlikely(cpl > 0))</yellow>
		goto handle_in_userspace;

<yellow>	switch (input) {</yellow>
	case __HYPERVISOR_xen_version:
<yellow>		if (params[0] == XENVER_version && vcpu->kvm->arch.xen.xen_version) {</yellow>
			r = vcpu-&gt;kvm-&gt;arch.xen.xen_version;
			handled = true;
		}
		break;
	case __HYPERVISOR_event_channel_op:
<yellow>		if (params[0] == EVTCHNOP_send)</yellow>
<yellow>			handled = kvm_xen_hcall_evtchn_send(vcpu, params[1], &r);</yellow>
		break;
	case __HYPERVISOR_sched_op:
<yellow>		handled = kvm_xen_hcall_sched_op(vcpu, longmode, params[0],</yellow>
						 params[1], &amp;r);
		break;
	case __HYPERVISOR_vcpu_op:
<yellow>		handled = kvm_xen_hcall_vcpu_op(vcpu, longmode, params[0], params[1],</yellow>
						params[2], &amp;r);
		break;
	case __HYPERVISOR_set_timer_op: {
		u64 timeout = params[0];
		/* In 32-bit mode, the 64-bit timeout is in two 32-bit params. */
<yellow>		if (!longmode)</yellow>
<yellow>			timeout |= params[1] << 32;</yellow>
<yellow>		handled = kvm_xen_hcall_set_timer_op(vcpu, timeout, &r);</yellow>
		break;
	}
	default:
		break;
	}

<yellow>	if (handled)</yellow>
<yellow>		return kvm_xen_hypercall_set_result(vcpu, r);</yellow>

handle_in_userspace:
<yellow>	vcpu->run->exit_reason = KVM_EXIT_XEN;</yellow>
	vcpu-&gt;run-&gt;xen.type = KVM_EXIT_XEN_HCALL;
	vcpu-&gt;run-&gt;xen.u.hcall.longmode = longmode;
	vcpu-&gt;run-&gt;xen.u.hcall.cpl = cpl;
	vcpu-&gt;run-&gt;xen.u.hcall.input = input;
	vcpu-&gt;run-&gt;xen.u.hcall.params[0] = params[0];
	vcpu-&gt;run-&gt;xen.u.hcall.params[1] = params[1];
	vcpu-&gt;run-&gt;xen.u.hcall.params[2] = params[2];
	vcpu-&gt;run-&gt;xen.u.hcall.params[3] = params[3];
	vcpu-&gt;run-&gt;xen.u.hcall.params[4] = params[4];
	vcpu-&gt;run-&gt;xen.u.hcall.params[5] = params[5];
	vcpu-&gt;arch.xen.hypercall_rip = kvm_get_linear_rip(vcpu);
	vcpu-&gt;arch.complete_userspace_io =
		kvm_xen_hypercall_complete_userspace;

	return 0;
}

static void kvm_xen_check_poller(struct kvm_vcpu *vcpu, int port)
{
	int poll_evtchn = vcpu-&gt;arch.xen.poll_evtchn;

<yellow>	if ((poll_evtchn == port || poll_evtchn == -1) &&</yellow>
<yellow>	    test_and_clear_bit(vcpu->vcpu_idx, vcpu->kvm->arch.xen.poll_mask)) {</yellow>
<yellow>		kvm_make_request(KVM_REQ_UNBLOCK, vcpu);</yellow>
		kvm_vcpu_kick(vcpu);
	}
}

/*
 * The return value from this function is propagated to kvm_set_irq() API,
 * so it returns:
 *  &lt; 0   Interrupt was ignored (masked or not delivered for other reasons)
 *  = 0   Interrupt was coalesced (previous irq is still pending)
 *  &gt; 0   Number of CPUs interrupt was delivered to
 *
 * It is also called directly from kvm_arch_set_irq_inatomic(), where the
 * only check on its return value is a comparison with -EWOULDBLOCK&#x27;.
 */
int kvm_xen_set_evtchn_fast(struct kvm_xen_evtchn *xe, struct kvm *kvm)
<yellow>{</yellow>
<yellow>	struct gfn_to_pfn_cache *gpc = &kvm->arch.xen.shinfo_cache;</yellow>
	struct kvm_vcpu *vcpu;
	unsigned long *pending_bits, *mask_bits;
	unsigned long flags;
	int port_word_bit;
	bool kick_vcpu = false;
	int vcpu_idx, idx, rc;

	vcpu_idx = READ_ONCE(xe-&gt;vcpu_idx);
	if (vcpu_idx &gt;= 0)
<yellow>		vcpu = kvm_get_vcpu(kvm, vcpu_idx);</yellow>
	else {
<yellow>		vcpu = kvm_get_vcpu_by_id(kvm, xe->vcpu_id);</yellow>
		if (!vcpu)
<yellow>			return -EINVAL;</yellow>
<yellow>		WRITE_ONCE(xe->vcpu_idx, vcpu->vcpu_idx);</yellow>
	}

<yellow>	if (!vcpu->arch.xen.vcpu_info_cache.active)</yellow>
		return -EINVAL;

<yellow>	if (xe->port >= max_evtchn_port(kvm))</yellow>
		return -EINVAL;

	rc = -EWOULDBLOCK;

<yellow>	idx = srcu_read_lock(&kvm->srcu);</yellow>

	read_lock_irqsave(&amp;gpc-&gt;lock, flags);
	if (!kvm_gfn_to_pfn_cache_check(kvm, gpc, gpc-&gt;gpa, PAGE_SIZE))
		goto out_rcu;

<yellow>	if (IS_ENABLED(CONFIG_64BIT) && kvm->arch.xen.long_mode) {</yellow>
<yellow>		struct shared_info *shinfo = gpc->khva;</yellow>
		pending_bits = (unsigned long *)&amp;shinfo-&gt;evtchn_pending;
<yellow>		mask_bits = (unsigned long *)&shinfo->evtchn_mask;</yellow>
		port_word_bit = xe-&gt;port / 64;
	} else {
		struct compat_shared_info *shinfo = gpc-&gt;khva;
		pending_bits = (unsigned long *)&amp;shinfo-&gt;evtchn_pending;
<yellow>		mask_bits = (unsigned long *)&shinfo->evtchn_mask;</yellow>
		port_word_bit = xe-&gt;port / 32;
	}

	/*
	 * If this port wasn&#x27;t already set, and if it isn&#x27;t masked, then
	 * we try to set the corresponding bit in the in-kernel shadow of
	 * evtchn_pending_sel for the target vCPU. And if *that* wasn&#x27;t
	 * already set, then we kick the vCPU in question to write to the
	 * *real* evtchn_pending_sel in its own guest vcpu_info struct.
	 */
<yellow>	if (test_and_set_bit(xe->port, pending_bits)) {</yellow>
		rc = 0; /* It was already raised */
<yellow>	} else if (test_bit(xe->port, mask_bits)) {</yellow>
		rc = -ENOTCONN; /* Masked */
<yellow>		kvm_xen_check_poller(vcpu, xe->port);</yellow>
	} else {
		rc = 1; /* Delivered to the bitmap in shared_info. */
		/* Now switch to the vCPU&#x27;s vcpu_info to set the index and pending_sel */
		read_unlock_irqrestore(&amp;gpc-&gt;lock, flags);
		gpc = &amp;vcpu-&gt;arch.xen.vcpu_info_cache;

		read_lock_irqsave(&amp;gpc-&gt;lock, flags);
		if (!kvm_gfn_to_pfn_cache_check(kvm, gpc, gpc-&gt;gpa, sizeof(struct vcpu_info))) {
			/*
			 * Could not access the vcpu_info. Set the bit in-kernel
			 * and prod the vCPU to deliver it for itself.
			 */
<yellow>			if (!test_and_set_bit(port_word_bit, &vcpu->arch.xen.evtchn_pending_sel))</yellow>
				kick_vcpu = true;
			goto out_rcu;
		}

<yellow>		if (IS_ENABLED(CONFIG_64BIT) && kvm->arch.xen.long_mode) {</yellow>
<yellow>			struct vcpu_info *vcpu_info = gpc->khva;</yellow>
<yellow>			if (!test_and_set_bit(port_word_bit, &vcpu_info->evtchn_pending_sel)) {</yellow>
<yellow>				WRITE_ONCE(vcpu_info->evtchn_upcall_pending, 1);</yellow>
				kick_vcpu = true;
			}
		} else {
			struct compat_vcpu_info *vcpu_info = gpc-&gt;khva;
<yellow>			if (!test_and_set_bit(port_word_bit,</yellow>
					      (unsigned long *)&amp;vcpu_info-&gt;evtchn_pending_sel)) {
<yellow>				WRITE_ONCE(vcpu_info->evtchn_upcall_pending, 1);</yellow>
				kick_vcpu = true;
			}
		}

		/* For the per-vCPU lapic vector, deliver it as MSI. */
<yellow>		if (kick_vcpu && vcpu->arch.xen.upcall_vector) {</yellow>
<yellow>			kvm_xen_inject_vcpu_vector(vcpu);</yellow>
			kick_vcpu = false;
		}
	}

 out_rcu:
<yellow>	read_unlock_irqrestore(&gpc->lock, flags);</yellow>
<yellow>	srcu_read_unlock(&kvm->srcu, idx);</yellow>

	if (kick_vcpu) {
<yellow>		kvm_make_request(KVM_REQ_UNBLOCK, vcpu);</yellow>
		kvm_vcpu_kick(vcpu);
	}

	return rc;
}

static int kvm_xen_set_evtchn(struct kvm_xen_evtchn *xe, struct kvm *kvm)
{
	bool mm_borrowed = false;
	int rc;

	rc = kvm_xen_set_evtchn_fast(xe, kvm);
<yellow>	if (rc != -EWOULDBLOCK)</yellow>
		return rc;

<yellow>	if (current->mm != kvm->mm) {</yellow>
		/*
		 * If not on a thread which already belongs to this KVM,
		 * we&#x27;d better be in the irqfd workqueue.
		 */
<yellow>		if (WARN_ON_ONCE(current->mm))</yellow>
			return -EINVAL;

<yellow>		kthread_use_mm(kvm->mm);</yellow>
		mm_borrowed = true;
	}

	/*
	 * For the irqfd workqueue, using the main kvm-&gt;lock mutex is
	 * fine since this function is invoked from kvm_set_irq() with
	 * no other lock held, no srcu. In future if it will be called
	 * directly from a vCPU thread (e.g. on hypercall for an IPI)
	 * then it may need to switch to using a leaf-node mutex for
	 * serializing the shared_info mapping.
	 */
<yellow>	mutex_lock(&kvm->lock);</yellow>

	/*
	 * It is theoretically possible for the page to be unmapped
	 * and the MMU notifier to invalidate the shared_info before
	 * we even get to use it. In that case, this looks like an
	 * infinite loop. It was tempting to do it via the userspace
	 * HVA instead... but that just *hides* the fact that it&#x27;s
	 * an infinite loop, because if a fault occurs and it waits
	 * for the page to come back, it can *still* immediately
	 * fault and have to wait again, repeatedly.
	 *
	 * Conversely, the page could also have been reinstated by
	 * another thread before we even obtain the mutex above, so
	 * check again *first* before remapping it.
	 */
	do {
		struct gfn_to_pfn_cache *gpc = &amp;kvm-&gt;arch.xen.shinfo_cache;
		int idx;

<yellow>		rc = kvm_xen_set_evtchn_fast(xe, kvm);</yellow>
		if (rc != -EWOULDBLOCK)
			break;

<yellow>		idx = srcu_read_lock(&kvm->srcu);</yellow>
		rc = kvm_gfn_to_pfn_cache_refresh(kvm, gpc, gpc-&gt;gpa, PAGE_SIZE);
<yellow>		srcu_read_unlock(&kvm->srcu, idx);</yellow>
	} while(!rc);

<yellow>	mutex_unlock(&kvm->lock);</yellow>

	if (mm_borrowed)
<yellow>		kthread_unuse_mm(kvm->mm);</yellow>

	return rc;
<yellow>}</yellow>

/* This is the version called from kvm_set_irq() as the .set function */
static int evtchn_set_fn(struct kvm_kernel_irq_routing_entry *e, struct kvm *kvm,
			 int irq_source_id, int level, bool line_status)
{
<yellow>	if (!level)</yellow>
		return -EINVAL;

<yellow>	return kvm_xen_set_evtchn(&e->xen_evtchn, kvm);</yellow>
<yellow>}</yellow>

/*
 * Set up an event channel interrupt from the KVM IRQ routing table.
 * Used for e.g. PIRQ from passed through physical devices.
 */
int kvm_xen_setup_evtchn(struct kvm *kvm,
			 struct kvm_kernel_irq_routing_entry *e,
			 const struct kvm_irq_routing_entry *ue)

<yellow>{</yellow>
	struct kvm_vcpu *vcpu;

<yellow>	if (ue->u.xen_evtchn.port >= max_evtchn_port(kvm))</yellow>
		return -EINVAL;

	/* We only support 2 level event channels for now */
<yellow>	if (ue->u.xen_evtchn.priority != KVM_IRQ_ROUTING_XEN_EVTCHN_PRIO_2LEVEL)</yellow>
		return -EINVAL;

	/*
	 * Xen gives us interesting mappings from vCPU index to APIC ID,
	 * which means kvm_get_vcpu_by_id() has to iterate over all vCPUs
	 * to find it. Do that once at setup time, instead of every time.
	 * But beware that on live update / live migration, the routing
	 * table might be reinstated before the vCPU threads have finished
	 * recreating their vCPUs.
	 */
<yellow>	vcpu = kvm_get_vcpu_by_id(kvm, ue->u.xen_evtchn.vcpu);</yellow>
	if (vcpu)
<yellow>		e->xen_evtchn.vcpu_idx = vcpu->vcpu_idx;</yellow>
	else
<yellow>		e->xen_evtchn.vcpu_idx = -1;</yellow>

	e-&gt;xen_evtchn.port = ue-&gt;u.xen_evtchn.port;
	e-&gt;xen_evtchn.vcpu_id = ue-&gt;u.xen_evtchn.vcpu;
	e-&gt;xen_evtchn.priority = ue-&gt;u.xen_evtchn.priority;
	e-&gt;set = evtchn_set_fn;

	return 0;
}

/*
 * Explicit event sending from userspace with KVM_XEN_HVM_EVTCHN_SEND ioctl.
 */
int kvm_xen_hvm_evtchn_send(struct kvm *kvm, struct kvm_irq_routing_xen_evtchn *uxe)
<yellow>{</yellow>
	struct kvm_xen_evtchn e;
	int ret;

<yellow>	if (!uxe->port || uxe->port >= max_evtchn_port(kvm))</yellow>
		return -EINVAL;

	/* We only support 2 level event channels for now */
<yellow>	if (uxe->priority != KVM_IRQ_ROUTING_XEN_EVTCHN_PRIO_2LEVEL)</yellow>
		return -EINVAL;

<yellow>	e.port = uxe->port;</yellow>
	e.vcpu_id = uxe-&gt;vcpu;
	e.vcpu_idx = -1;
	e.priority = uxe-&gt;priority;

<yellow>	ret = kvm_xen_set_evtchn(&e, kvm);</yellow>

	/*
	 * None of that &#x27;return 1 if it actually got delivered&#x27; nonsense.
	 * We don&#x27;t care if it was masked (-ENOTCONN) either.
	 */
<yellow>	if (ret > 0 || ret == -ENOTCONN)</yellow>
		ret = 0;

	return ret;
<yellow>}</yellow>

/*
 * Support for *outbound* event channel events via the EVTCHNOP_send hypercall.
 */
struct evtchnfd {
	u32 send_port;
	u32 type;
	union {
		struct kvm_xen_evtchn port;
		struct {
			u32 port; /* zero */
			struct eventfd_ctx *ctx;
		} eventfd;
	} deliver;
};

/*
 * Update target vCPU or priority for a registered sending channel.
 */
static int kvm_xen_eventfd_update(struct kvm *kvm,
				  struct kvm_xen_hvm_attr *data)
{
<yellow>	u32 port = data->u.evtchn.send_port;</yellow>
	struct evtchnfd *evtchnfd;

<yellow>	if (!port || port >= max_evtchn_port(kvm))</yellow>
		return -EINVAL;

<yellow>	mutex_lock(&kvm->lock);</yellow>
	evtchnfd = idr_find(&amp;kvm-&gt;arch.xen.evtchn_ports, port);
	mutex_unlock(&amp;kvm-&gt;lock);

	if (!evtchnfd)
		return -ENOENT;

	/* For an UPDATE, nothing may change except the priority/vcpu */
<yellow>	if (evtchnfd->type != data->u.evtchn.type)</yellow>
		return -EINVAL;

	/*
	 * Port cannot change, and if it&#x27;s zero that was an eventfd
	 * which can&#x27;t be changed either.
	 */
<yellow>	if (!evtchnfd->deliver.port.port ||</yellow>
<yellow>	    evtchnfd->deliver.port.port != data->u.evtchn.deliver.port.port)</yellow>
		return -EINVAL;

	/* We only support 2 level event channels for now */
<yellow>	if (data->u.evtchn.deliver.port.priority != KVM_IRQ_ROUTING_XEN_EVTCHN_PRIO_2LEVEL)</yellow>
		return -EINVAL;

<yellow>	mutex_lock(&kvm->lock);</yellow>
	evtchnfd-&gt;deliver.port.priority = data-&gt;u.evtchn.deliver.port.priority;
	if (evtchnfd-&gt;deliver.port.vcpu_id != data-&gt;u.evtchn.deliver.port.vcpu) {
		evtchnfd-&gt;deliver.port.vcpu_id = data-&gt;u.evtchn.deliver.port.vcpu;
<yellow>		evtchnfd->deliver.port.vcpu_idx = -1;</yellow>
	}
<yellow>	mutex_unlock(&kvm->lock);</yellow>
	return 0;
}

/*
 * Configure the target (eventfd or local port delivery) for sending on
 * a given event channel.
 */
static int kvm_xen_eventfd_assign(struct kvm *kvm,
				  struct kvm_xen_hvm_attr *data)
{
<yellow>	u32 port = data->u.evtchn.send_port;</yellow>
	struct eventfd_ctx *eventfd = NULL;
	struct evtchnfd *evtchnfd = NULL;
	int ret = -EINVAL;

<yellow>	if (!port || port >= max_evtchn_port(kvm))</yellow>
		return -EINVAL;

<yellow>	evtchnfd = kzalloc(sizeof(struct evtchnfd), GFP_KERNEL);</yellow>
	if (!evtchnfd)
		return -ENOMEM;

<yellow>	switch(data->u.evtchn.type) {</yellow>
	case EVTCHNSTAT_ipi:
		/* IPI  must map back to the same port# */
<yellow>		if (data->u.evtchn.deliver.port.port != data->u.evtchn.send_port)</yellow>
			goto out_noeventfd; /* -EINVAL */
		break;

	case EVTCHNSTAT_interdomain:
<yellow>		if (data->u.evtchn.deliver.port.port) {</yellow>
<yellow>			if (data->u.evtchn.deliver.port.port >= max_evtchn_port(kvm))</yellow>
				goto out_noeventfd; /* -EINVAL */
		} else {
<yellow>			eventfd = eventfd_ctx_fdget(data->u.evtchn.deliver.eventfd.fd);</yellow>
			if (IS_ERR(eventfd)) {
<yellow>				ret = PTR_ERR(eventfd);</yellow>
				goto out_noeventfd;
			}
		}
		break;

	case EVTCHNSTAT_virq:
	case EVTCHNSTAT_closed:
	case EVTCHNSTAT_unbound:
	case EVTCHNSTAT_pirq:
	default: /* Unknown event channel type */
		goto out; /* -EINVAL */
	}

<yellow>	evtchnfd->send_port = data->u.evtchn.send_port;</yellow>
	evtchnfd-&gt;type = data-&gt;u.evtchn.type;
	if (eventfd) {
<yellow>		evtchnfd->deliver.eventfd.ctx = eventfd;</yellow>
	} else {
		/* We only support 2 level event channels for now */
<yellow>		if (data->u.evtchn.deliver.port.priority != KVM_IRQ_ROUTING_XEN_EVTCHN_PRIO_2LEVEL)</yellow>
			goto out; /* -EINVAL; */

<yellow>		evtchnfd->deliver.port.port = data->u.evtchn.deliver.port.port;</yellow>
		evtchnfd-&gt;deliver.port.vcpu_id = data-&gt;u.evtchn.deliver.port.vcpu;
		evtchnfd-&gt;deliver.port.vcpu_idx = -1;
		evtchnfd-&gt;deliver.port.priority = data-&gt;u.evtchn.deliver.port.priority;
	}

<yellow>	mutex_lock(&kvm->lock);</yellow>
	ret = idr_alloc(&amp;kvm-&gt;arch.xen.evtchn_ports, evtchnfd, port, port + 1,
			GFP_KERNEL);
	mutex_unlock(&amp;kvm-&gt;lock);
	if (ret &gt;= 0)
		return 0;

<yellow>	if (ret == -ENOSPC)</yellow>
		ret = -EEXIST;
out:
<yellow>	if (eventfd)</yellow>
<yellow>		eventfd_ctx_put(eventfd);</yellow>
out_noeventfd:
<yellow>	kfree(evtchnfd);</yellow>
	return ret;
}

static int kvm_xen_eventfd_deassign(struct kvm *kvm, u32 port)
{
	struct evtchnfd *evtchnfd;

<yellow>	mutex_lock(&kvm->lock);</yellow>
	evtchnfd = idr_remove(&amp;kvm-&gt;arch.xen.evtchn_ports, port);
	mutex_unlock(&amp;kvm-&gt;lock);

	if (!evtchnfd)
		return -ENOENT;

<yellow>	if (kvm)</yellow>
<yellow>		synchronize_srcu(&kvm->srcu);</yellow>
<yellow>	if (!evtchnfd->deliver.port.port)</yellow>
<yellow>		eventfd_ctx_put(evtchnfd->deliver.eventfd.ctx);</yellow>
<yellow>	kfree(evtchnfd);</yellow>
	return 0;
}

static int kvm_xen_eventfd_reset(struct kvm *kvm)
{
	struct evtchnfd *evtchnfd;
	int i;

	mutex_lock(&amp;kvm-&gt;lock);
<yellow>	idr_for_each_entry(&kvm->arch.xen.evtchn_ports, evtchnfd, i) {</yellow>
<yellow>		idr_remove(&kvm->arch.xen.evtchn_ports, evtchnfd->send_port);</yellow>
		synchronize_srcu(&amp;kvm-&gt;srcu);
		if (!evtchnfd-&gt;deliver.port.port)
<yellow>			eventfd_ctx_put(evtchnfd->deliver.eventfd.ctx);</yellow>
<yellow>		kfree(evtchnfd);</yellow>
	}
<yellow>	mutex_unlock(&kvm->lock);</yellow>

	return 0;
}

static int kvm_xen_setattr_evtchn(struct kvm *kvm, struct kvm_xen_hvm_attr *data)
{
<yellow>	u32 port = data->u.evtchn.send_port;</yellow>

	if (data-&gt;u.evtchn.flags == KVM_XEN_EVTCHN_RESET)
<yellow>		return kvm_xen_eventfd_reset(kvm);</yellow>

<yellow>	if (!port || port >= max_evtchn_port(kvm))</yellow>
		return -EINVAL;

<yellow>	if (data->u.evtchn.flags == KVM_XEN_EVTCHN_DEASSIGN)</yellow>
<yellow>		return kvm_xen_eventfd_deassign(kvm, port);</yellow>
<yellow>	if (data->u.evtchn.flags == KVM_XEN_EVTCHN_UPDATE)</yellow>
<yellow>		return kvm_xen_eventfd_update(kvm, data);</yellow>
<yellow>	if (data->u.evtchn.flags)</yellow>
		return -EINVAL;

<yellow>	return kvm_xen_eventfd_assign(kvm, data);</yellow>
}

static bool kvm_xen_hcall_evtchn_send(struct kvm_vcpu *vcpu, u64 param, u64 *r)
{
	struct evtchnfd *evtchnfd;
	struct evtchn_send send;
	gpa_t gpa;
	int idx;

<yellow>	idx = srcu_read_lock(&vcpu->kvm->srcu);</yellow>
	gpa = kvm_mmu_gva_to_gpa_system(vcpu, param, NULL);
<yellow>	srcu_read_unlock(&vcpu->kvm->srcu, idx);</yellow>

<yellow>	if (!gpa || kvm_vcpu_read_guest(vcpu, gpa, &send, sizeof(send))) {</yellow>
		*r = -EFAULT;
		return true;
	}

	/* The evtchn_ports idr is protected by vcpu-&gt;kvm-&gt;srcu */
<yellow>	evtchnfd = idr_find(&vcpu->kvm->arch.xen.evtchn_ports, send.port);</yellow>
	if (!evtchnfd)
		return false;

<yellow>	if (evtchnfd->deliver.port.port) {</yellow>
<yellow>		int ret = kvm_xen_set_evtchn(&evtchnfd->deliver.port, vcpu->kvm);</yellow>
<yellow>		if (ret < 0 && ret != -ENOTCONN)</yellow>
			return false;
	} else {
<yellow>		eventfd_signal(evtchnfd->deliver.eventfd.ctx, 1);</yellow>
	}

<yellow>	*r = 0;</yellow>
	return true;
}

void kvm_xen_init_vcpu(struct kvm_vcpu *vcpu)
{
<yellow>	vcpu->arch.xen.vcpu_id = vcpu->vcpu_idx;</yellow>
	vcpu-&gt;arch.xen.poll_evtchn = 0;

	timer_setup(&amp;vcpu-&gt;arch.xen.poll_timer, cancel_evtchn_poll, 0);

	kvm_gpc_init(&amp;vcpu-&gt;arch.xen.runstate_cache);
	kvm_gpc_init(&amp;vcpu-&gt;arch.xen.vcpu_info_cache);
	kvm_gpc_init(&amp;vcpu-&gt;arch.xen.vcpu_time_info_cache);
}

void kvm_xen_destroy_vcpu(struct kvm_vcpu *vcpu)
{
<yellow>	if (kvm_xen_timer_enabled(vcpu))</yellow>
<yellow>		kvm_xen_stop_timer(vcpu);</yellow>

<yellow>	kvm_gpc_deactivate(vcpu->kvm, &vcpu->arch.xen.runstate_cache);</yellow>
	kvm_gpc_deactivate(vcpu-&gt;kvm, &amp;vcpu-&gt;arch.xen.vcpu_info_cache);
	kvm_gpc_deactivate(vcpu-&gt;kvm, &amp;vcpu-&gt;arch.xen.vcpu_time_info_cache);

	del_timer_sync(&amp;vcpu-&gt;arch.xen.poll_timer);
}

void kvm_xen_init_vm(struct kvm *kvm)
{
<yellow>	idr_init(&kvm->arch.xen.evtchn_ports);</yellow>
	kvm_gpc_init(&amp;kvm-&gt;arch.xen.shinfo_cache);
}

void kvm_xen_destroy_vm(struct kvm *kvm)
<yellow>{</yellow>
	struct evtchnfd *evtchnfd;
	int i;

<yellow>	kvm_gpc_deactivate(kvm, &kvm->arch.xen.shinfo_cache);</yellow>

<yellow>	idr_for_each_entry(&kvm->arch.xen.evtchn_ports, evtchnfd, i) {</yellow>
<yellow>		if (!evtchnfd->deliver.port.port)</yellow>
<yellow>			eventfd_ctx_put(evtchnfd->deliver.eventfd.ctx);</yellow>
<yellow>		kfree(evtchnfd);</yellow>
	}
<yellow>	idr_destroy(&kvm->arch.xen.evtchn_ports);</yellow>

	if (kvm-&gt;arch.xen_hvm_config.msr)
<yellow>		static_branch_slow_dec_deferred(&kvm_xen_enabled);</yellow>
}


</code></pre></td></tr></table>
</div><script>const fileList = document.getElementById('file_list')
fileList.innerHTML+=`<li><a href="/coverage/linux/arch/x86/kvm/mmu/mmu.c.html">mmu.c 50.9%</li>`
fileList.innerHTML+=`<li><a href="/coverage/linux/arch/x86/kvm/vmx/nested.c.html">nested.c 82.6%</li>`
fileList.innerHTML+=`<li><a href="/coverage/linux/arch/x86/kvm/vmx/vmx.c.html">vmx.c 52.3%</li>`
fileList.innerHTML+=`<li><a href="/coverage/linux/arch/x86/kvm/x86.c.html">x86.c 52.8%</li>`
</script></body></html>