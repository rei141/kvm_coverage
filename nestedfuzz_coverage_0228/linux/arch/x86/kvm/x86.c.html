<doctype html>
<html lang="ja">
<head><title>x86.c</title><meta charset="utf-8">
<script src="https://cdn.rawgit.com/google/code-prettify/master/loader/run_prettify.js"></script>
<style>
    code{
        font-family:Monaco, Menlo, Consolas, 'Courier New', Courier, monospace, sans-serif;
        font-size: 14px;
        line-height: 18px;
        overflow: auto;
        resize: horizontal;
    }
    code_line{
        font-family: Monaco, Menlo, Consolas, 'Courier New', Courier, monospace, sans-serif;;
        font-size: 14px;
        line-height: 18px;
        overflow: auto;
        resize: horizontal;
        color:#303134;
    }
    blue{
        background-color:#BEEDE8;
    }
    yellow{
        background-color:#FFFF99;
    }
    red{
        background-color:#FF99AC;
    }
      .split {
         height: 100%;
         position: fixed;
         z-index: 1;
         top: 0;
         overflow-x: hidden;
      }

      .tree {
         left: 0;
         width: 20%;
      }

      .right {
         border-left: 2px solid #444;
         right: 0;
         width: 80%;
         /* font-family: 'Courier New', Courier, monospace;
				color: rgb(80, 80, 80); */
      }
</style>

</head>
<body>
   <div class="split tree">
      <ul id="file_list">
      </ul>
   </div>
   <div class="split right">
<table summary='blob content' class='blob' cellspacing="15">
<tr><td align="right"><pre><code_line><script>for (let i = 1; i <= 13491; i++){
         document.write(i+".\n");
   }
         </script></code_line></pre></td>
<td class='lines'><pre><code class="prettyprint">// SPDX-License-Identifier: GPL-2.0-only
/*
 * Kernel-based Virtual Machine driver for Linux
 *
 * derived from drivers/kvm/kvm_main.c
 *
 * Copyright (C) 2006 Qumranet, Inc.
 * Copyright (C) 2008 Qumranet, Inc.
 * Copyright IBM Corporation, 2008
 * Copyright 2010 Red Hat, Inc. and/or its affiliates.
 *
 * Authors:
 *   Avi Kivity   &lt;avi@qumranet.com&gt;
 *   Yaniv Kamay  &lt;yaniv@qumranet.com&gt;
 *   Amit Shah    &lt;amit.shah@qumranet.com&gt;
 *   Ben-Ami Yassour &lt;benami@il.ibm.com&gt;
 */

#include &lt;linux/kvm_host.h&gt;
#include &quot;irq.h&quot;
#include &quot;ioapic.h&quot;
#include &quot;mmu.h&quot;
#include &quot;i8254.h&quot;
#include &quot;tss.h&quot;
#include &quot;kvm_cache_regs.h&quot;
#include &quot;kvm_emulate.h&quot;
#include &quot;x86.h&quot;
#include &quot;cpuid.h&quot;
#include &quot;pmu.h&quot;
#include &quot;hyperv.h&quot;
#include &quot;lapic.h&quot;
#include &quot;xen.h&quot;
#include &quot;smm.h&quot;

#include &lt;linux/clocksource.h&gt;
#include &lt;linux/interrupt.h&gt;
#include &lt;linux/kvm.h&gt;
#include &lt;linux/fs.h&gt;
#include &lt;linux/vmalloc.h&gt;
#include &lt;linux/export.h&gt;
#include &lt;linux/moduleparam.h&gt;
#include &lt;linux/mman.h&gt;
#include &lt;linux/highmem.h&gt;
#include &lt;linux/iommu.h&gt;
#include &lt;linux/cpufreq.h&gt;
#include &lt;linux/user-return-notifier.h&gt;
#include &lt;linux/srcu.h&gt;
#include &lt;linux/slab.h&gt;
#include &lt;linux/perf_event.h&gt;
#include &lt;linux/uaccess.h&gt;
#include &lt;linux/hash.h&gt;
#include &lt;linux/pci.h&gt;
#include &lt;linux/timekeeper_internal.h&gt;
#include &lt;linux/pvclock_gtod.h&gt;
#include &lt;linux/kvm_irqfd.h&gt;
#include &lt;linux/irqbypass.h&gt;
#include &lt;linux/sched/stat.h&gt;
#include &lt;linux/sched/isolation.h&gt;
#include &lt;linux/mem_encrypt.h&gt;
#include &lt;linux/entry-kvm.h&gt;
#include &lt;linux/suspend.h&gt;

#include &lt;trace/events/kvm.h&gt;

#include &lt;asm/debugreg.h&gt;
#include &lt;asm/msr.h&gt;
#include &lt;asm/desc.h&gt;
#include &lt;asm/mce.h&gt;
#include &lt;asm/pkru.h&gt;
#include &lt;linux/kernel_stat.h&gt;
#include &lt;asm/fpu/api.h&gt;
#include &lt;asm/fpu/xcr.h&gt;
#include &lt;asm/fpu/xstate.h&gt;
#include &lt;asm/pvclock.h&gt;
#include &lt;asm/div64.h&gt;
#include &lt;asm/irq_remapping.h&gt;
#include &lt;asm/mshyperv.h&gt;
#include &lt;asm/hypervisor.h&gt;
#include &lt;asm/tlbflush.h&gt;
#include &lt;asm/intel_pt.h&gt;
#include &lt;asm/emulate_prefix.h&gt;
#include &lt;asm/sgx.h&gt;
#include &lt;clocksource/hyperv_timer.h&gt;

#define CREATE_TRACE_POINTS
#include &quot;trace.h&quot;

#define MAX_IO_MSRS 256
#define KVM_MAX_MCE_BANKS 32

struct kvm_caps kvm_caps __read_mostly = {
	.supported_mce_cap = MCG_CTL_P | MCG_SER_P,
};
EXPORT_SYMBOL_GPL(kvm_caps);

#define  ERR_PTR_USR(e)  ((void __user *)ERR_PTR(e))

#define emul_to_vcpu(ctxt) \
	((struct kvm_vcpu *)(ctxt)-&gt;vcpu)

/* EFER defaults:
 * - enable syscall per default because its emulated by KVM
 * - enable LME and LMA per default on 64 bit KVM
 */
#ifdef CONFIG_X86_64
static
u64 __read_mostly efer_reserved_bits = ~((u64)(EFER_SCE | EFER_LME | EFER_LMA));
#else
static u64 __read_mostly efer_reserved_bits = ~((u64)EFER_SCE);
#endif

static u64 __read_mostly cr4_reserved_bits = CR4_RESERVED_BITS;

#define KVM_EXIT_HYPERCALL_VALID_MASK (1 &lt;&lt; KVM_HC_MAP_GPA_RANGE)

#define KVM_CAP_PMU_VALID_MASK KVM_PMU_CAP_DISABLE

#define KVM_X2APIC_API_VALID_FLAGS (KVM_X2APIC_API_USE_32BIT_IDS | \
                                    KVM_X2APIC_API_DISABLE_BROADCAST_QUIRK)

static void update_cr8_intercept(struct kvm_vcpu *vcpu);
static void process_nmi(struct kvm_vcpu *vcpu);
static void __kvm_set_rflags(struct kvm_vcpu *vcpu, unsigned long rflags);
static void store_regs(struct kvm_vcpu *vcpu);
static int sync_regs(struct kvm_vcpu *vcpu);
static int kvm_vcpu_do_singlestep(struct kvm_vcpu *vcpu);

static int __set_sregs2(struct kvm_vcpu *vcpu, struct kvm_sregs2 *sregs2);
static void __get_sregs2(struct kvm_vcpu *vcpu, struct kvm_sregs2 *sregs2);

struct kvm_x86_ops kvm_x86_ops __read_mostly;

#define KVM_X86_OP(func)					     \
	DEFINE_STATIC_CALL_NULL(kvm_x86_##func,			     \
				*(((struct kvm_x86_ops *)0)-&gt;func));
#define KVM_X86_OP_OPTIONAL KVM_X86_OP
#define KVM_X86_OP_OPTIONAL_RET0 KVM_X86_OP
#include &lt;asm/kvm-x86-ops.h&gt;
EXPORT_STATIC_CALL_GPL(kvm_x86_get_cs_db_l_bits);
EXPORT_STATIC_CALL_GPL(kvm_x86_cache_reg);

static bool __read_mostly ignore_msrs = 0;
module_param(ignore_msrs, bool, S_IRUGO | S_IWUSR);

bool __read_mostly report_ignored_msrs = true;
module_param(report_ignored_msrs, bool, S_IRUGO | S_IWUSR);
EXPORT_SYMBOL_GPL(report_ignored_msrs);

unsigned int min_timer_period_us = 200;
module_param(min_timer_period_us, uint, S_IRUGO | S_IWUSR);

static bool __read_mostly kvmclock_periodic_sync = true;
module_param(kvmclock_periodic_sync, bool, S_IRUGO);

/* tsc tolerance in parts per million - default to 1/2 of the NTP threshold */
static u32 __read_mostly tsc_tolerance_ppm = 250;
module_param(tsc_tolerance_ppm, uint, S_IRUGO | S_IWUSR);

/*
 * lapic timer advance (tscdeadline mode only) in nanoseconds.  &#x27;-1&#x27; enables
 * adaptive tuning starting from default advancement of 1000ns.  &#x27;0&#x27; disables
 * advancement entirely.  Any other value is used as-is and disables adaptive
 * tuning, i.e. allows privileged userspace to set an exact advancement time.
 */
static int __read_mostly lapic_timer_advance_ns = -1;
module_param(lapic_timer_advance_ns, int, S_IRUGO | S_IWUSR);

static bool __read_mostly vector_hashing = true;
module_param(vector_hashing, bool, S_IRUGO);

bool __read_mostly enable_vmware_backdoor = false;
module_param(enable_vmware_backdoor, bool, S_IRUGO);
EXPORT_SYMBOL_GPL(enable_vmware_backdoor);

/*
 * Flags to manipulate forced emulation behavior (any non-zero value will
 * enable forced emulation).
 */
#define KVM_FEP_CLEAR_RFLAGS_RF	BIT(1)
static int __read_mostly force_emulation_prefix;
module_param(force_emulation_prefix, int, 0644);

int __read_mostly pi_inject_timer = -1;
module_param(pi_inject_timer, bint, S_IRUGO | S_IWUSR);

/* Enable/disable PMU virtualization */
bool __read_mostly enable_pmu = true;
EXPORT_SYMBOL_GPL(enable_pmu);
module_param(enable_pmu, bool, 0444);

bool __read_mostly eager_page_split = true;
module_param(eager_page_split, bool, 0644);

/* Enable/disable SMT_RSB bug mitigation */
bool __read_mostly mitigate_smt_rsb;
module_param(mitigate_smt_rsb, bool, 0444);

/*
 * Restoring the host value for MSRs that are only consumed when running in
 * usermode, e.g. SYSCALL MSRs and TSC_AUX, can be deferred until the CPU
 * returns to userspace, i.e. the kernel can run with the guest&#x27;s value.
 */
#define KVM_MAX_NR_USER_RETURN_MSRS 16

struct kvm_user_return_msrs {
	struct user_return_notifier urn;
	bool registered;
	struct kvm_user_return_msr_values {
		u64 host;
		u64 curr;
	} values[KVM_MAX_NR_USER_RETURN_MSRS];
};

u32 __read_mostly kvm_nr_uret_msrs;
EXPORT_SYMBOL_GPL(kvm_nr_uret_msrs);
static u32 __read_mostly kvm_uret_msrs_list[KVM_MAX_NR_USER_RETURN_MSRS];
static struct kvm_user_return_msrs __percpu *user_return_msrs;

#define KVM_SUPPORTED_XCR0     (XFEATURE_MASK_FP | XFEATURE_MASK_SSE \
				| XFEATURE_MASK_YMM | XFEATURE_MASK_BNDREGS \
				| XFEATURE_MASK_BNDCSR | XFEATURE_MASK_AVX512 \
				| XFEATURE_MASK_PKRU | XFEATURE_MASK_XTILE)

u64 __read_mostly host_efer;
EXPORT_SYMBOL_GPL(host_efer);

bool __read_mostly allow_smaller_maxphyaddr = 0;
EXPORT_SYMBOL_GPL(allow_smaller_maxphyaddr);

bool __read_mostly enable_apicv = true;
EXPORT_SYMBOL_GPL(enable_apicv);

u64 __read_mostly host_xss;
EXPORT_SYMBOL_GPL(host_xss);

const struct _kvm_stats_desc kvm_vm_stats_desc[] = {
	KVM_GENERIC_VM_STATS(),
	STATS_DESC_COUNTER(VM, mmu_shadow_zapped),
	STATS_DESC_COUNTER(VM, mmu_pte_write),
	STATS_DESC_COUNTER(VM, mmu_pde_zapped),
	STATS_DESC_COUNTER(VM, mmu_flooded),
	STATS_DESC_COUNTER(VM, mmu_recycled),
	STATS_DESC_COUNTER(VM, mmu_cache_miss),
	STATS_DESC_ICOUNTER(VM, mmu_unsync),
	STATS_DESC_ICOUNTER(VM, pages_4k),
	STATS_DESC_ICOUNTER(VM, pages_2m),
	STATS_DESC_ICOUNTER(VM, pages_1g),
	STATS_DESC_ICOUNTER(VM, nx_lpage_splits),
	STATS_DESC_PCOUNTER(VM, max_mmu_rmap_size),
	STATS_DESC_PCOUNTER(VM, max_mmu_page_hash_collisions)
};

const struct kvm_stats_header kvm_vm_stats_header = {
	.name_size = KVM_STATS_NAME_SIZE,
	.num_desc = ARRAY_SIZE(kvm_vm_stats_desc),
	.id_offset = sizeof(struct kvm_stats_header),
	.desc_offset = sizeof(struct kvm_stats_header) + KVM_STATS_NAME_SIZE,
	.data_offset = sizeof(struct kvm_stats_header) + KVM_STATS_NAME_SIZE +
		       sizeof(kvm_vm_stats_desc),
};

const struct _kvm_stats_desc kvm_vcpu_stats_desc[] = {
	KVM_GENERIC_VCPU_STATS(),
	STATS_DESC_COUNTER(VCPU, pf_taken),
	STATS_DESC_COUNTER(VCPU, pf_fixed),
	STATS_DESC_COUNTER(VCPU, pf_emulate),
	STATS_DESC_COUNTER(VCPU, pf_spurious),
	STATS_DESC_COUNTER(VCPU, pf_fast),
	STATS_DESC_COUNTER(VCPU, pf_mmio_spte_created),
	STATS_DESC_COUNTER(VCPU, pf_guest),
	STATS_DESC_COUNTER(VCPU, tlb_flush),
	STATS_DESC_COUNTER(VCPU, invlpg),
	STATS_DESC_COUNTER(VCPU, exits),
	STATS_DESC_COUNTER(VCPU, io_exits),
	STATS_DESC_COUNTER(VCPU, mmio_exits),
	STATS_DESC_COUNTER(VCPU, signal_exits),
	STATS_DESC_COUNTER(VCPU, irq_window_exits),
	STATS_DESC_COUNTER(VCPU, nmi_window_exits),
	STATS_DESC_COUNTER(VCPU, l1d_flush),
	STATS_DESC_COUNTER(VCPU, halt_exits),
	STATS_DESC_COUNTER(VCPU, request_irq_exits),
	STATS_DESC_COUNTER(VCPU, irq_exits),
	STATS_DESC_COUNTER(VCPU, host_state_reload),
	STATS_DESC_COUNTER(VCPU, fpu_reload),
	STATS_DESC_COUNTER(VCPU, insn_emulation),
	STATS_DESC_COUNTER(VCPU, insn_emulation_fail),
	STATS_DESC_COUNTER(VCPU, hypercalls),
	STATS_DESC_COUNTER(VCPU, irq_injections),
	STATS_DESC_COUNTER(VCPU, nmi_injections),
	STATS_DESC_COUNTER(VCPU, req_event),
	STATS_DESC_COUNTER(VCPU, nested_run),
	STATS_DESC_COUNTER(VCPU, directed_yield_attempted),
	STATS_DESC_COUNTER(VCPU, directed_yield_successful),
	STATS_DESC_COUNTER(VCPU, preemption_reported),
	STATS_DESC_COUNTER(VCPU, preemption_other),
	STATS_DESC_IBOOLEAN(VCPU, guest_mode),
	STATS_DESC_COUNTER(VCPU, notify_window_exits),
};

const struct kvm_stats_header kvm_vcpu_stats_header = {
	.name_size = KVM_STATS_NAME_SIZE,
	.num_desc = ARRAY_SIZE(kvm_vcpu_stats_desc),
	.id_offset = sizeof(struct kvm_stats_header),
	.desc_offset = sizeof(struct kvm_stats_header) + KVM_STATS_NAME_SIZE,
	.data_offset = sizeof(struct kvm_stats_header) + KVM_STATS_NAME_SIZE +
		       sizeof(kvm_vcpu_stats_desc),
};

u64 __read_mostly host_xcr0;

static struct kmem_cache *x86_emulator_cache;

/*
 * When called, it means the previous get/set msr reached an invalid msr.
 * Return true if we want to ignore/silent this failed msr access.
 */
static bool kvm_msr_ignored_check(u32 msr, u64 data, bool write)
{
<blue>	const char *op = write ? "wrmsr" : "rdmsr";</blue>

<blue>	if (ignore_msrs) {</blue>
<yellow>		if (report_ignored_msrs)</yellow>
<yellow>			kvm_pr_unimpl("ignored %s: 0x%x data 0x%llx\n",</yellow>
				      op, msr, data);
		/* Mask the error */
		return true;
	} else {
<blue>		kvm_debug_ratelimited("unhandled %s: 0x%x data 0x%llx\n",</blue>
				      op, msr, data);
		return false;
	}
<blue>}</blue>

static struct kmem_cache *kvm_alloc_emulator_cache(void)
{
	unsigned int useroffset = offsetof(struct x86_emulate_ctxt, src);
	unsigned int size = sizeof(struct x86_emulate_ctxt);

<yellow>	return kmem_cache_create_usercopy("x86_emulator", size,</yellow>
					  __alignof__(struct x86_emulate_ctxt),
					  SLAB_ACCOUNT, useroffset,
					  size - useroffset, NULL);
}

static int emulator_fix_hypercall(struct x86_emulate_ctxt *ctxt);

static inline void kvm_async_pf_hash_reset(struct kvm_vcpu *vcpu)
{
	int i;
	for (i = 0; i &lt; ASYNC_PF_PER_VCPU; i++)
<blue>		vcpu->arch.apf.gfns[i] = ~0;</blue>
}

static void kvm_on_user_return(struct user_return_notifier *urn)
{
	unsigned slot;
	struct kvm_user_return_msrs *msrs
		= container_of(urn, struct kvm_user_return_msrs, urn);
	struct kvm_user_return_msr_values *values;
	unsigned long flags;

	/*
	 * Disabling irqs at this point since the following code could be
	 * interrupted and executed through kvm_arch_hardware_disable()
	 */
<blue>	local_irq_save(flags);</blue>
<blue>	if (msrs->registered) {</blue>
<blue>		msrs->registered = false;</blue>
		user_return_notifier_unregister(urn);
	}
<blue>	local_irq_restore(flags);</blue>
<blue>	for (slot = 0; slot < kvm_nr_uret_msrs; ++slot) {</blue>
		values = &amp;msrs-&gt;values[slot];
<blue>		if (values->host != values->curr) {</blue>
<blue>			wrmsrl(kvm_uret_msrs_list[slot], values->host);</blue>
			values-&gt;curr = values-&gt;host;
		}
	}
<blue>}</blue>

static int kvm_probe_user_return_msr(u32 msr)
{
	u64 val;
	int ret;

<yellow>	preempt_disable();</yellow>
	ret = rdmsrl_safe(msr, &amp;val);
	if (ret)
		goto out;
<yellow>	ret = wrmsrl_safe(msr, val);</yellow>
out:
<yellow>	preempt_enable();</yellow>
	return ret;
}

int kvm_add_user_return_msr(u32 msr)
<yellow>{</yellow>
<yellow>	BUG_ON(kvm_nr_uret_msrs >= KVM_MAX_NR_USER_RETURN_MSRS);</yellow>

<yellow>	if (kvm_probe_user_return_msr(msr))</yellow>
		return -1;

<yellow>	kvm_uret_msrs_list[kvm_nr_uret_msrs] = msr;</yellow>
	return kvm_nr_uret_msrs++;
}
EXPORT_SYMBOL_GPL(kvm_add_user_return_msr);

int kvm_find_user_return_msr(u32 msr)
{
	int i;

<blue>	for (i = 0; i < kvm_nr_uret_msrs; ++i) {</blue>
<blue>		if (kvm_uret_msrs_list[i] == msr)</blue>
			return i;
	}
	return -1;
<blue>}</blue>
EXPORT_SYMBOL_GPL(kvm_find_user_return_msr);

static void kvm_user_return_msr_cpu_online(void)
{
<blue>	unsigned int cpu = smp_processor_id();</blue>
	struct kvm_user_return_msrs *msrs = per_cpu_ptr(user_return_msrs, cpu);
	u64 value;
	int i;

	for (i = 0; i &lt; kvm_nr_uret_msrs; ++i) {
<blue>		rdmsrl_safe(kvm_uret_msrs_list[i], &value);</blue>
		msrs-&gt;values[i].host = value;
		msrs-&gt;values[i].curr = value;
	}
}

int kvm_set_user_return_msr(unsigned slot, u64 value, u64 mask)
{
<blue>	unsigned int cpu = smp_processor_id();</blue>
	struct kvm_user_return_msrs *msrs = per_cpu_ptr(user_return_msrs, cpu);
	int err;

	value = (value &amp; mask) | (msrs-&gt;values[slot].host &amp; ~mask);
	if (value == msrs-&gt;values[slot].curr)
		return 0;
<blue>	err = wrmsrl_safe(kvm_uret_msrs_list[slot], value);</blue>
	if (err)
		return 1;

<blue>	msrs->values[slot].curr = value;</blue>
<blue>	if (!msrs->registered) {</blue>
<blue>		msrs->urn.on_user_return = kvm_on_user_return;</blue>
		user_return_notifier_register(&amp;msrs-&gt;urn);
		msrs-&gt;registered = true;
	}
	return 0;
<blue>}</blue>
EXPORT_SYMBOL_GPL(kvm_set_user_return_msr);

static void drop_user_return_notifiers(void)
{
	unsigned int cpu = smp_processor_id();
	struct kvm_user_return_msrs *msrs = per_cpu_ptr(user_return_msrs, cpu);

<yellow>	if (msrs->registered)</yellow>
<yellow>		kvm_on_user_return(&msrs->urn);</yellow>
}

u64 kvm_get_apic_base(struct kvm_vcpu *vcpu)
{
<blue>	return vcpu->arch.apic_base;</blue>
}

enum lapic_mode kvm_get_apic_mode(struct kvm_vcpu *vcpu)
{
<blue>	return kvm_apic_mode(kvm_get_apic_base(vcpu));</blue>
}
EXPORT_SYMBOL_GPL(kvm_get_apic_mode);

int kvm_set_apic_base(struct kvm_vcpu *vcpu, struct msr_data *msr_info)
{
<blue>	enum lapic_mode old_mode = kvm_get_apic_mode(vcpu);</blue>
<blue>	enum lapic_mode new_mode = kvm_apic_mode(msr_info->data);</blue>
	u64 reserved_bits = kvm_vcpu_reserved_gpa_bits_raw(vcpu) | 0x2ff |
<blue>		(guest_cpuid_has(vcpu, X86_FEATURE_X2APIC) ? 0 : X2APIC_ENABLE);</blue>

<blue>	if ((msr_info->data & reserved_bits) != 0 || new_mode == LAPIC_MODE_INVALID)</blue>
		return 1;
<blue>	if (!msr_info->host_initiated) {</blue>
<yellow>		if (old_mode == LAPIC_MODE_X2APIC && new_mode == LAPIC_MODE_XAPIC)</yellow>
			return 1;
<blue>		if (old_mode == LAPIC_MODE_DISABLED && new_mode == LAPIC_MODE_X2APIC)</blue>
			return 1;
	}

<blue>	kvm_lapic_set_base(vcpu, msr_info->data);</blue>
	kvm_recalculate_apic_map(vcpu-&gt;kvm);
	return 0;
<blue>}</blue>

/*
 * Handle a fault on a hardware virtualization (VMX or SVM) instruction.
 *
 * Hardware virtualization extension instructions may fault if a reboot turns
 * off virtualization while processes are running.  Usually after catching the
 * fault we just panic; during reboot instead the instruction is ignored.
 */
noinstr void kvm_spurious_fault(void)
{
	/* Fault while not rebooting.  We want the trace. */
	BUG_ON(!kvm_rebooting);
}
EXPORT_SYMBOL_GPL(kvm_spurious_fault);

#define EXCPT_BENIGN		0
#define EXCPT_CONTRIBUTORY	1
#define EXCPT_PF		2

static int exception_class(int vector)
{
<blue>	switch (vector) {</blue>
	case PF_VECTOR:
		return EXCPT_PF;
	case DE_VECTOR:
	case TS_VECTOR:
	case NP_VECTOR:
	case SS_VECTOR:
	case GP_VECTOR:
		return EXCPT_CONTRIBUTORY;
	default:
		break;
	}
	return EXCPT_BENIGN;
}

#define EXCPT_FAULT		0
#define EXCPT_TRAP		1
#define EXCPT_ABORT		2
#define EXCPT_INTERRUPT		3
#define EXCPT_DB		4

static int exception_type(int vector)
{
	unsigned int mask;

<blue>	if (WARN_ON(vector > 31 || vector == NMI_VECTOR))</blue>
<yellow>		return EXCPT_INTERRUPT;</yellow>

<blue>	mask = 1 << vector;</blue>

	/*
	 * #DBs can be trap-like or fault-like, the caller must check other CPU
	 * state, e.g. DR6, to determine whether a #DB is a trap or fault.
	 */
	if (mask &amp; (1 &lt;&lt; DB_VECTOR))
		return EXCPT_DB;

<blue>	if (mask & ((1 << BP_VECTOR) | (1 << OF_VECTOR)))</blue>
		return EXCPT_TRAP;

<blue>	if (mask & ((1 << DF_VECTOR) | (1 << MC_VECTOR)))</blue>
		return EXCPT_ABORT;

	/* Reserved exceptions will result in fault */
	return EXCPT_FAULT;
<blue>}</blue>

<blue>void kvm_deliver_exception_payload(struct kvm_vcpu *vcpu,</blue>
				   struct kvm_queued_exception *ex)
{
<blue>	if (!ex->has_payload)</blue>
		return;

<blue>	switch (ex->vector) {</blue>
	case DB_VECTOR:
		/*
		 * &quot;Certain debug exceptions may clear bit 0-3.  The
		 * remaining contents of the DR6 register are never
		 * cleared by the processor&quot;.
		 */
<blue>		vcpu->arch.dr6 &= ~DR_TRAP_BITS;</blue>
		/*
		 * In order to reflect the #DB exception payload in guest
		 * dr6, three components need to be considered: active low
		 * bit, FIXED_1 bits and active high bits (e.g. DR6_BD,
		 * DR6_BS and DR6_BT)
		 * DR6_ACTIVE_LOW contains the FIXED_1 and active low bits.
		 * In the target guest dr6:
		 * FIXED_1 bits should always be set.
		 * Active low bits should be cleared if 1-setting in payload.
		 * Active high bits should be set if 1-setting in payload.
		 *
		 * Note, the payload is compatible with the pending debug
		 * exceptions/exit qualification under VMX, that active_low bits
		 * are active high in payload.
		 * So they need to be flipped for DR6.
		 */
		vcpu-&gt;arch.dr6 |= DR6_ACTIVE_LOW;
		vcpu-&gt;arch.dr6 |= ex-&gt;payload;
		vcpu-&gt;arch.dr6 ^= ex-&gt;payload &amp; DR6_ACTIVE_LOW;

		/*
		 * The #DB payload is defined as compatible with the &#x27;pending
		 * debug exceptions&#x27; field under VMX, not DR6. While bit 12 is
		 * defined in the &#x27;pending debug exceptions&#x27; field (enabled
		 * breakpoint), it is reserved and must be zero in DR6.
		 */
		vcpu-&gt;arch.dr6 &amp;= ~BIT(12);
		break;
	case PF_VECTOR:
<blue>		vcpu->arch.cr2 = ex->payload;</blue>
		break;
	}

<blue>	ex->has_payload = false;</blue>
	ex-&gt;payload = 0;
<blue>}</blue>
EXPORT_SYMBOL_GPL(kvm_deliver_exception_payload);

static void kvm_queue_exception_vmexit(struct kvm_vcpu *vcpu, unsigned int vector,
				       bool has_error_code, u32 error_code,
				       bool has_payload, unsigned long payload)
{
	struct kvm_queued_exception *ex = &amp;vcpu-&gt;arch.exception_vmexit;

<blue>	ex->vector = vector;</blue>
	ex-&gt;injected = false;
	ex-&gt;pending = true;
	ex-&gt;has_error_code = has_error_code;
	ex-&gt;error_code = error_code;
	ex-&gt;has_payload = has_payload;
	ex-&gt;payload = payload;
}

/* Forcibly leave the nested mode in cases like a vCPU reset */
static void kvm_leave_nested(struct kvm_vcpu *vcpu)
{
<yellow>	kvm_x86_ops.nested_ops->leave_nested(vcpu);</yellow>
}

static void kvm_multiple_exception(struct kvm_vcpu *vcpu,
		unsigned nr, bool has_error, u32 error_code,
	        bool has_payload, unsigned long payload, bool reinject)
{
	u32 prev_nr;
	int class1, class2;

<blue>	kvm_make_request(KVM_REQ_EVENT, vcpu);</blue>

	/*
	 * If the exception is destined for L2 and isn&#x27;t being reinjected,
	 * morph it to a VM-Exit if L1 wants to intercept the exception.  A
	 * previously injected exception is not checked because it was checked
	 * when it was original queued, and re-checking is incorrect if _L1_
	 * injected the exception, in which case it&#x27;s exempt from interception.
	 */
<blue>	if (!reinject && is_guest_mode(vcpu) &&</blue>
<blue>	    kvm_x86_ops.nested_ops->is_exception_vmexit(vcpu, nr, error_code)) {</blue>
<blue>		kvm_queue_exception_vmexit(vcpu, nr, has_error, error_code,</blue>
					   has_payload, payload);
		return;
	}

<blue>	if (!vcpu->arch.exception.pending && !vcpu->arch.exception.injected) {</blue>
	queue:
<blue>		if (reinject) {</blue>
			/*
			 * On VM-Entry, an exception can be pending if and only
			 * if event injection was blocked by nested_run_pending.
			 * In that case, however, vcpu_enter_guest() requests an
			 * immediate exit, and the guest shouldn&#x27;t proceed far
			 * enough to need reinjection.
			 */
<blue>			WARN_ON_ONCE(kvm_is_exception_pending(vcpu));</blue>
<blue>			vcpu->arch.exception.injected = true;</blue>
<blue>			if (WARN_ON_ONCE(has_payload)) {</blue>
				/*
				 * A reinjected event has already
				 * delivered its payload.
				 */
				has_payload = false;
				payload = 0;
			}
		} else {
<blue>			vcpu->arch.exception.pending = true;</blue>
			vcpu-&gt;arch.exception.injected = false;
		}
		vcpu-&gt;arch.exception.has_error_code = has_error;
		vcpu-&gt;arch.exception.vector = nr;
		vcpu-&gt;arch.exception.error_code = error_code;
		vcpu-&gt;arch.exception.has_payload = has_payload;
		vcpu-&gt;arch.exception.payload = payload;
		if (!is_guest_mode(vcpu))
<blue>			kvm_deliver_exception_payload(vcpu,</blue>
						      &amp;vcpu-&gt;arch.exception);
		return;
	}

	/* to check exception */
<blue>	prev_nr = vcpu->arch.exception.vector;</blue>
	if (prev_nr == DF_VECTOR) {
		/* triple fault -&gt; shutdown */
<blue>		kvm_make_request(KVM_REQ_TRIPLE_FAULT, vcpu);</blue>
		return;
	}
<blue>	class1 = exception_class(prev_nr);</blue>
<blue>	class2 = exception_class(nr);</blue>
<blue>	if ((class1 == EXCPT_CONTRIBUTORY && class2 == EXCPT_CONTRIBUTORY) ||</blue>
	    (class1 == EXCPT_PF &amp;&amp; class2 != EXCPT_BENIGN)) {
		/*
		 * Synthesize #DF.  Clear the previously injected or pending
		 * exception so as not to incorrectly trigger shutdown.
		 */
<blue>		vcpu->arch.exception.injected = false;</blue>
		vcpu-&gt;arch.exception.pending = false;

		kvm_queue_exception_e(vcpu, DF_VECTOR, 0);
	} else {
		/* replace previous exception with a new one in a hope
		   that instruction re-execution will regenerate lost
		   exception */
		goto queue;
	}
<blue>}</blue>

void kvm_queue_exception(struct kvm_vcpu *vcpu, unsigned nr)
{
<blue>	kvm_multiple_exception(vcpu, nr, false, 0, false, 0, false);</blue>
}
EXPORT_SYMBOL_GPL(kvm_queue_exception);

void kvm_requeue_exception(struct kvm_vcpu *vcpu, unsigned nr)
{
<blue>	kvm_multiple_exception(vcpu, nr, false, 0, false, 0, true);</blue>
}
EXPORT_SYMBOL_GPL(kvm_requeue_exception);

void kvm_queue_exception_p(struct kvm_vcpu *vcpu, unsigned nr,
			   unsigned long payload)
{
<blue>	kvm_multiple_exception(vcpu, nr, false, 0, true, payload, false);</blue>
}
EXPORT_SYMBOL_GPL(kvm_queue_exception_p);

static void kvm_queue_exception_e_p(struct kvm_vcpu *vcpu, unsigned nr,
				    u32 error_code, unsigned long payload)
{
	kvm_multiple_exception(vcpu, nr, true, error_code,
			       true, payload, false);
}

<blue>int kvm_complete_insn_gp(struct kvm_vcpu *vcpu, int err)</blue>
{
<blue>	if (err)</blue>
<blue>		kvm_inject_gp(vcpu, 0);</blue>
	else
<blue>		return kvm_skip_emulated_instruction(vcpu);</blue>

	return 1;
<blue>}</blue>
EXPORT_SYMBOL_GPL(kvm_complete_insn_gp);

static int complete_emulated_insn_gp(struct kvm_vcpu *vcpu, int err)
{
	if (err) {
<yellow>		kvm_inject_gp(vcpu, 0);</yellow>
		return 1;
	}

<yellow>	return kvm_emulate_instruction(vcpu, EMULTYPE_NO_DECODE | EMULTYPE_SKIP |</yellow>
				       EMULTYPE_COMPLETE_USER_EXIT);
}

void kvm_inject_page_fault(struct kvm_vcpu *vcpu, struct x86_exception *fault)
{
<blue>	++vcpu->stat.pf_guest;</blue>

	/*
	 * Async #PF in L2 is always forwarded to L1 as a VM-Exit regardless of
	 * whether or not L1 wants to intercept &quot;regular&quot; #PF.
	 */
<blue>	if (is_guest_mode(vcpu) && fault->async_page_fault)</blue>
		kvm_queue_exception_vmexit(vcpu, PF_VECTOR,
<yellow>					   true, fault->error_code,</yellow>
					   true, fault-&gt;address);
	else
		kvm_queue_exception_e_p(vcpu, PF_VECTOR, fault-&gt;error_code,
					fault-&gt;address);
<blue>}</blue>

void kvm_inject_emulated_page_fault(struct kvm_vcpu *vcpu,
				    struct x86_exception *fault)
{
	struct kvm_mmu *fault_mmu;
<blue>	WARN_ON_ONCE(fault->vector != PF_VECTOR);</blue>

<blue>	fault_mmu = fault->nested_page_fault ? vcpu->arch.mmu :</blue>
					       vcpu-&gt;arch.walk_mmu;

	/*
	 * Invalidate the TLB entry for the faulting address, if it exists,
	 * else the access will fault indefinitely (and to emulate hardware).
	 */
<blue>	if ((fault->error_code & PFERR_PRESENT_MASK) &&</blue>
	    !(fault-&gt;error_code &amp; PFERR_RSVD_MASK))
<yellow>		kvm_mmu_invalidate_gva(vcpu, fault_mmu, fault->address,</yellow>
				       fault_mmu-&gt;root.hpa);

<blue>	fault_mmu->inject_page_fault(vcpu, fault);</blue>
}
EXPORT_SYMBOL_GPL(kvm_inject_emulated_page_fault);

void kvm_inject_nmi(struct kvm_vcpu *vcpu)
{
<yellow>	atomic_inc(&vcpu->arch.nmi_queued);</yellow>
	kvm_make_request(KVM_REQ_NMI, vcpu);
}

void kvm_queue_exception_e(struct kvm_vcpu *vcpu, unsigned nr, u32 error_code)
{
<blue>	kvm_multiple_exception(vcpu, nr, true, error_code, false, 0, false);</blue>
}
EXPORT_SYMBOL_GPL(kvm_queue_exception_e);

void kvm_requeue_exception_e(struct kvm_vcpu *vcpu, unsigned nr, u32 error_code)
{
<blue>	kvm_multiple_exception(vcpu, nr, true, error_code, false, 0, true);</blue>
}
EXPORT_SYMBOL_GPL(kvm_requeue_exception_e);

/*
 * Checks if cpl &lt;= required_cpl; if true, return true.  Otherwise queue
 * a #GP and return false.
 */
bool kvm_require_cpl(struct kvm_vcpu *vcpu, int required_cpl)
{
<yellow>	if (static_call(kvm_x86_get_cpl)(vcpu) <= required_cpl)</yellow>
		return true;
<yellow>	kvm_queue_exception_e(vcpu, GP_VECTOR, 0);</yellow>
	return false;
<yellow>}</yellow>

bool kvm_require_dr(struct kvm_vcpu *vcpu, int dr)
{
<blue>	if ((dr != 4 && dr != 5) || !kvm_read_cr4_bits(vcpu, X86_CR4_DE))</blue>
		return true;

<blue>	kvm_queue_exception(vcpu, UD_VECTOR);</blue>
	return false;
<blue>}</blue>
EXPORT_SYMBOL_GPL(kvm_require_dr);

static inline u64 pdptr_rsvd_bits(struct kvm_vcpu *vcpu)
{
	return vcpu-&gt;arch.reserved_gpa_bits | rsvd_bits(5, 8) | rsvd_bits(1, 2);
}

/*
 * Load the pae pdptrs.  Return 1 if they are all valid, 0 otherwise.
 */
int load_pdptrs(struct kvm_vcpu *vcpu, unsigned long cr3)
<blue>{</blue>
<blue>	struct kvm_mmu *mmu = vcpu->arch.walk_mmu;</blue>
	gfn_t pdpt_gfn = cr3 &gt;&gt; PAGE_SHIFT;
	gpa_t real_gpa;
	int i;
	int ret;
	u64 pdpte[ARRAY_SIZE(mmu-&gt;pdptrs)];

	/*
	 * If the MMU is nested, CR3 holds an L2 GPA and needs to be translated
	 * to an L1 GPA.
	 */
<yellow>	real_gpa = kvm_translate_gpa(vcpu, mmu, gfn_to_gpa(pdpt_gfn),</yellow>
				     PFERR_USER_MASK | PFERR_WRITE_MASK, NULL);
	if (real_gpa == INVALID_GPA)
		return 0;

	/* Note the offset, PDPTRs are 32 byte aligned when using PAE paging. */
<blue>	ret = kvm_vcpu_read_guest_page(vcpu, gpa_to_gfn(real_gpa), pdpte,</blue>
				       cr3 &amp; GENMASK(11, 5), sizeof(pdpte));
	if (ret &lt; 0)
		return 0;

<yellow>	for (i = 0; i < ARRAY_SIZE(pdpte); ++i) {</yellow>
<blue>		if ((pdpte[i] & PT_PRESENT_MASK) &&</blue>
<blue>		    (pdpte[i] & pdptr_rsvd_bits(vcpu))) {</blue>
			return 0;
		}
	}

	/*
	 * Marking VCPU_EXREG_PDPTR dirty doesn&#x27;t work for !tdp_enabled.
	 * Shadow page roots need to be reconstructed instead.
	 */
<yellow>	if (!tdp_enabled && memcmp(mmu->pdptrs, pdpte, sizeof(mmu->pdptrs)))</yellow>
<yellow>		kvm_mmu_free_roots(vcpu->kvm, mmu, KVM_MMU_ROOT_CURRENT);</yellow>

<yellow>	memcpy(mmu->pdptrs, pdpte, sizeof(mmu->pdptrs));</yellow>
	kvm_register_mark_dirty(vcpu, VCPU_EXREG_PDPTR);
	kvm_make_request(KVM_REQ_LOAD_MMU_PGD, vcpu);
	vcpu-&gt;arch.pdptrs_from_userspace = false;

	return 1;
}
EXPORT_SYMBOL_GPL(load_pdptrs);

void kvm_post_set_cr0(struct kvm_vcpu *vcpu, unsigned long old_cr0, unsigned long cr0)
{
<blue>	if ((cr0 ^ old_cr0) & X86_CR0_PG) {</blue>
<blue>		kvm_clear_async_pf_completion_queue(vcpu);</blue>
<blue>		kvm_async_pf_hash_reset(vcpu);</blue>

		/*
		 * Clearing CR0.PG is defined to flush the TLB from the guest&#x27;s
		 * perspective.
		 */
<blue>		if (!(cr0 & X86_CR0_PG))</blue>
<yellow>			kvm_make_request(KVM_REQ_TLB_FLUSH_GUEST, vcpu);</yellow>
	}

<blue>	if ((cr0 ^ old_cr0) & KVM_MMU_CR0_ROLE_BITS)</blue>
<blue>		kvm_mmu_reset_context(vcpu);</blue>

<blue>	if (((cr0 ^ old_cr0) & X86_CR0_CD) &&</blue>
<blue>	    kvm_arch_has_noncoherent_dma(vcpu->kvm) &&</blue>
<yellow>	    !kvm_check_has_quirk(vcpu->kvm, KVM_X86_QUIRK_CD_NW_CLEARED))</yellow>
<yellow>		kvm_zap_gfn_range(vcpu->kvm, 0, ~0ULL);</yellow>
<blue>}</blue>
EXPORT_SYMBOL_GPL(kvm_post_set_cr0);

int kvm_set_cr0(struct kvm_vcpu *vcpu, unsigned long cr0)
<blue>{</blue>
<blue>	unsigned long old_cr0 = kvm_read_cr0(vcpu);</blue>

	cr0 |= X86_CR0_ET;

#ifdef CONFIG_X86_64
	if (cr0 &amp; 0xffffffff00000000UL)
		return 1;
#endif

	cr0 &amp;= ~CR0_RESERVED_BITS;

<blue>	if ((cr0 & X86_CR0_NW) && !(cr0 & X86_CR0_CD))</blue>
		return 1;

<blue>	if ((cr0 & X86_CR0_PG) && !(cr0 & X86_CR0_PE))</blue>
		return 1;

#ifdef CONFIG_X86_64
<blue>	if ((vcpu->arch.efer & EFER_LME) && !is_paging(vcpu) &&</blue>
	    (cr0 &amp; X86_CR0_PG)) {
		int cs_db, cs_l;

<blue>		if (!is_pae(vcpu))</blue>
<yellow>			return 1;</yellow>
<blue>		static_call(kvm_x86_get_cs_db_l_bits)(vcpu, &cs_db, &cs_l);</blue>
		if (cs_l)
			return 1;
	}
#endif
<blue>	if (!(vcpu->arch.efer & EFER_LME) && (cr0 & X86_CR0_PG) &&</blue>
<yellow>	    is_pae(vcpu) && ((cr0 ^ old_cr0) & X86_CR0_PDPTR_BITS) &&</yellow>
<yellow>	    !load_pdptrs(vcpu, kvm_read_cr3(vcpu)))</yellow>
		return 1;

<blue>	if (!(cr0 & X86_CR0_PG) &&</blue>
<blue>	    (is_64_bit_mode(vcpu) || kvm_read_cr4_bits(vcpu, X86_CR4_PCIDE)))</blue>
		return 1;

<blue>	static_call(kvm_x86_set_cr0)(vcpu, cr0);</blue>

	kvm_post_set_cr0(vcpu, old_cr0, cr0);

	return 0;
}
EXPORT_SYMBOL_GPL(kvm_set_cr0);

void kvm_lmsw(struct kvm_vcpu *vcpu, unsigned long msw)
{
<blue>	(void)kvm_set_cr0(vcpu, kvm_read_cr0_bits(vcpu, ~0x0eul) | (msw & 0x0f));</blue>
}
EXPORT_SYMBOL_GPL(kvm_lmsw);

<blue>void kvm_load_guest_xsave_state(struct kvm_vcpu *vcpu)</blue>
{
<blue>	if (vcpu->arch.guest_state_protected)</blue>
		return;

<blue>	if (kvm_read_cr4_bits(vcpu, X86_CR4_OSXSAVE)) {</blue>

<blue>		if (vcpu->arch.xcr0 != host_xcr0)</blue>
<blue>			xsetbv(XCR_XFEATURE_ENABLED_MASK, vcpu->arch.xcr0);</blue>

<blue>		if (vcpu->arch.xsaves_enabled &&</blue>
<blue>		    vcpu->arch.ia32_xss != host_xss)</blue>
<blue>			wrmsrl(MSR_IA32_XSS, vcpu->arch.ia32_xss);</blue>
	}

#ifdef CONFIG_X86_INTEL_MEMORY_PROTECTION_KEYS
<blue>	if (static_cpu_has(X86_FEATURE_PKU) &&</blue>
<blue>	    vcpu->arch.pkru != vcpu->arch.host_pkru &&</blue>
<blue>	    ((vcpu->arch.xcr0 & XFEATURE_MASK_PKRU) ||</blue>
<blue>	     kvm_read_cr4_bits(vcpu, X86_CR4_PKE)))</blue>
<blue>		write_pkru(vcpu->arch.pkru);</blue>
#endif /* CONFIG_X86_INTEL_MEMORY_PROTECTION_KEYS */
<blue>}</blue>
EXPORT_SYMBOL_GPL(kvm_load_guest_xsave_state);

<blue>void kvm_load_host_xsave_state(struct kvm_vcpu *vcpu)</blue>
{
<blue>	if (vcpu->arch.guest_state_protected)</blue>
		return;

#ifdef CONFIG_X86_INTEL_MEMORY_PROTECTION_KEYS
<blue>	if (static_cpu_has(X86_FEATURE_PKU) &&</blue>
<blue>	    ((vcpu->arch.xcr0 & XFEATURE_MASK_PKRU) ||</blue>
<blue>	     kvm_read_cr4_bits(vcpu, X86_CR4_PKE))) {</blue>
<blue>		vcpu->arch.pkru = rdpkru();</blue>
		if (vcpu-&gt;arch.pkru != vcpu-&gt;arch.host_pkru)
<blue>			write_pkru(vcpu->arch.host_pkru);</blue>
	}
#endif /* CONFIG_X86_INTEL_MEMORY_PROTECTION_KEYS */

<blue>	if (kvm_read_cr4_bits(vcpu, X86_CR4_OSXSAVE)) {</blue>

<blue>		if (vcpu->arch.xcr0 != host_xcr0)</blue>
<blue>			xsetbv(XCR_XFEATURE_ENABLED_MASK, host_xcr0);</blue>

<blue>		if (vcpu->arch.xsaves_enabled &&</blue>
<blue>		    vcpu->arch.ia32_xss != host_xss)</blue>
<blue>			wrmsrl(MSR_IA32_XSS, host_xss);</blue>
	}

<blue>}</blue>
EXPORT_SYMBOL_GPL(kvm_load_host_xsave_state);

#ifdef CONFIG_X86_64
static inline u64 kvm_guest_supported_xfd(struct kvm_vcpu *vcpu)
{
<yellow>	return vcpu->arch.guest_supported_xcr0 & XFEATURE_MASK_USER_DYNAMIC;</yellow>
}
#endif

static int __kvm_set_xcr(struct kvm_vcpu *vcpu, u32 index, u64 xcr)
{
	u64 xcr0 = xcr;
<blue>	u64 old_xcr0 = vcpu->arch.xcr0;</blue>
	u64 valid_bits;

	/* Only support XCR_XFEATURE_ENABLED_MASK(xcr0) now  */
<blue>	if (index != XCR_XFEATURE_ENABLED_MASK)</blue>
		return 1;
<blue>	if (!(xcr0 & XFEATURE_MASK_FP))</blue>
		return 1;
<blue>	if ((xcr0 & XFEATURE_MASK_YMM) && !(xcr0 & XFEATURE_MASK_SSE))</blue>
		return 1;

	/*
	 * Do not allow the guest to set bits that we do not support
	 * saving.  However, xcr0 bit 0 is always set, even if the
	 * emulated CPU does not support XSAVE (see kvm_vcpu_reset()).
	 */
<blue>	valid_bits = vcpu->arch.guest_supported_xcr0 | XFEATURE_MASK_FP;</blue>
	if (xcr0 &amp; ~valid_bits)
		return 1;

<blue>	if ((!(xcr0 & XFEATURE_MASK_BNDREGS)) !=</blue>
	    (!(xcr0 &amp; XFEATURE_MASK_BNDCSR)))
		return 1;

<blue>	if (xcr0 & XFEATURE_MASK_AVX512) {</blue>
<yellow>		if (!(xcr0 & XFEATURE_MASK_YMM))</yellow>
			return 1;
<yellow>		if ((xcr0 & XFEATURE_MASK_AVX512) != XFEATURE_MASK_AVX512)</yellow>
			return 1;
	}

<blue>	if ((xcr0 & XFEATURE_MASK_XTILE) &&</blue>
	    ((xcr0 &amp; XFEATURE_MASK_XTILE) != XFEATURE_MASK_XTILE))
		return 1;

	vcpu-&gt;arch.xcr0 = xcr0;

	if ((xcr0 ^ old_xcr0) &amp; XFEATURE_MASK_EXTEND)
<yellow>		kvm_update_cpuid_runtime(vcpu);</yellow>
	return 0;
<blue>}</blue>

int kvm_emulate_xsetbv(struct kvm_vcpu *vcpu)
{
	/* Note, #UD due to CR4.OSXSAVE=0 has priority over the intercept. */
<yellow>	if (static_call(kvm_x86_get_cpl)(vcpu) != 0 ||</yellow>
<yellow>	    __kvm_set_xcr(vcpu, kvm_rcx_read(vcpu), kvm_read_edx_eax(vcpu))) {</yellow>
<yellow>		kvm_inject_gp(vcpu, 0);</yellow>
		return 1;
	}

<yellow>	return kvm_skip_emulated_instruction(vcpu);</yellow>
<yellow>}</yellow>
EXPORT_SYMBOL_GPL(kvm_emulate_xsetbv);

bool __kvm_is_valid_cr4(struct kvm_vcpu *vcpu, unsigned long cr4)
{
<blue>	if (cr4 & cr4_reserved_bits)</blue>
		return false;

<blue>	if (cr4 & vcpu->arch.cr4_guest_rsvd_bits)</blue>
		return false;

	return true;
<blue>}</blue>
EXPORT_SYMBOL_GPL(__kvm_is_valid_cr4);

static bool kvm_is_valid_cr4(struct kvm_vcpu *vcpu, unsigned long cr4)
{
<blue>	return __kvm_is_valid_cr4(vcpu, cr4) &&</blue>
<blue>	       static_call(kvm_x86_is_valid_cr4)(vcpu, cr4);</blue>
}

void kvm_post_set_cr4(struct kvm_vcpu *vcpu, unsigned long old_cr4, unsigned long cr4)
{
<blue>	if ((cr4 ^ old_cr4) & KVM_MMU_CR4_ROLE_BITS)</blue>
<blue>		kvm_mmu_reset_context(vcpu);</blue>

	/*
	 * If CR4.PCIDE is changed 0 -&gt; 1, there is no need to flush the TLB
	 * according to the SDM; however, stale prev_roots could be reused
	 * incorrectly in the future after a MOV to CR3 with NOFLUSH=1, so we
	 * free them all.  This is *not* a superset of KVM_REQ_TLB_FLUSH_GUEST
	 * or KVM_REQ_TLB_FLUSH_CURRENT, because the hardware TLB is not flushed,
	 * so fall through.
	 */
<blue>	if (!tdp_enabled &&</blue>
<blue>	    (cr4 & X86_CR4_PCIDE) && !(old_cr4 & X86_CR4_PCIDE))</blue>
<yellow>		kvm_mmu_unload(vcpu);</yellow>

	/*
	 * The TLB has to be flushed for all PCIDs if any of the following
	 * (architecturally required) changes happen:
	 * - CR4.PCIDE is changed from 1 to 0
	 * - CR4.PGE is toggled
	 *
	 * This is a superset of KVM_REQ_TLB_FLUSH_CURRENT.
	 */
<blue>	if (((cr4 ^ old_cr4) & X86_CR4_PGE) ||</blue>
<blue>	    (!(cr4 & X86_CR4_PCIDE) && (old_cr4 & X86_CR4_PCIDE)))</blue>
<yellow>		kvm_make_request(KVM_REQ_TLB_FLUSH_GUEST, vcpu);</yellow>

	/*
	 * The TLB has to be flushed for the current PCID if any of the
	 * following (architecturally required) changes happen:
	 * - CR4.SMEP is changed from 0 to 1
	 * - CR4.PAE is toggled
	 */
<blue>	else if (((cr4 ^ old_cr4) & X86_CR4_PAE) ||</blue>
<blue>		 ((cr4 & X86_CR4_SMEP) && !(old_cr4 & X86_CR4_SMEP)))</blue>
<blue>		kvm_make_request(KVM_REQ_TLB_FLUSH_CURRENT, vcpu);</blue>

<blue>}</blue>
EXPORT_SYMBOL_GPL(kvm_post_set_cr4);

int kvm_set_cr4(struct kvm_vcpu *vcpu, unsigned long cr4)
{
<blue>	unsigned long old_cr4 = kvm_read_cr4(vcpu);</blue>

<blue>	if (!kvm_is_valid_cr4(vcpu, cr4))</blue>
		return 1;

<blue>	if (is_long_mode(vcpu)) {</blue>
<blue>		if (!(cr4 & X86_CR4_PAE))</blue>
			return 1;
<blue>		if ((cr4 ^ old_cr4) & X86_CR4_LA57)</blue>
			return 1;
<blue>	} else if (is_paging(vcpu) && (cr4 & X86_CR4_PAE)</blue>
<yellow>		   && ((cr4 ^ old_cr4) & X86_CR4_PDPTR_BITS)</yellow>
<yellow>		   && !load_pdptrs(vcpu, kvm_read_cr3(vcpu)))</yellow>
		return 1;

<blue>	if ((cr4 & X86_CR4_PCIDE) && !(old_cr4 & X86_CR4_PCIDE)) {</blue>
<yellow>		if (!guest_cpuid_has(vcpu, X86_FEATURE_PCID))</yellow>
			return 1;

		/* PCID can not be enabled when cr3[11:0]!=000H or EFER.LMA=0 */
<yellow>		if ((kvm_read_cr3(vcpu) & X86_CR3_PCID_MASK) || !is_long_mode(vcpu))</yellow>
			return 1;
	}

<blue>	static_call(kvm_x86_set_cr4)(vcpu, cr4);</blue>

	kvm_post_set_cr4(vcpu, old_cr4, cr4);

	return 0;
<blue>}</blue>
EXPORT_SYMBOL_GPL(kvm_set_cr4);

static void kvm_invalidate_pcid(struct kvm_vcpu *vcpu, unsigned long pcid)
{
<blue>	struct kvm_mmu *mmu = vcpu->arch.mmu;</blue>
	unsigned long roots_to_free = 0;
	int i;

	/*
	 * MOV CR3 and INVPCID are usually not intercepted when using TDP, but
	 * this is reachable when running EPT=1 and unrestricted_guest=0,  and
	 * also via the emulator.  KVM&#x27;s TDP page tables are not in the scope of
	 * the invalidation, but the guest&#x27;s TLB entries need to be flushed as
	 * the CPU may have cached entries in its TLB for the target PCID.
	 */
<blue>	if (unlikely(tdp_enabled)) {</blue>
<blue>		kvm_make_request(KVM_REQ_TLB_FLUSH_GUEST, vcpu);</blue>
		return;
	}

	/*
	 * If neither the current CR3 nor any of the prev_roots use the given
	 * PCID, then nothing needs to be done here because a resync will
	 * happen anyway before switching to any other CR3.
	 */
<blue>	if (kvm_get_active_pcid(vcpu) == pcid) {</blue>
<blue>		kvm_make_request(KVM_REQ_MMU_SYNC, vcpu);</blue>
		kvm_make_request(KVM_REQ_TLB_FLUSH_CURRENT, vcpu);
	}

	/*
	 * If PCID is disabled, there is no need to free prev_roots even if the
	 * PCIDs for them are also 0, because MOV to CR3 always flushes the TLB
	 * with PCIDE=0.
	 */
<blue>	if (!kvm_read_cr4_bits(vcpu, X86_CR4_PCIDE))</blue>
		return;

<yellow>	for (i = 0; i < KVM_MMU_NUM_PREV_ROOTS; i++)</yellow>
<yellow>		if (kvm_get_pcid(vcpu, mmu->prev_roots[i].pgd) == pcid)</yellow>
<yellow>			roots_to_free |= KVM_MMU_ROOT_PREVIOUS(i);</yellow>

<yellow>	kvm_mmu_free_roots(vcpu->kvm, mmu, roots_to_free);</yellow>
<blue>}</blue>

int kvm_set_cr3(struct kvm_vcpu *vcpu, unsigned long cr3)
{
	bool skip_tlb_flush = false;
	unsigned long pcid = 0;
#ifdef CONFIG_X86_64
<blue>	bool pcid_enabled = kvm_read_cr4_bits(vcpu, X86_CR4_PCIDE);</blue>

	if (pcid_enabled) {
<blue>		skip_tlb_flush = cr3 & X86_CR3_PCID_NOFLUSH;</blue>
		cr3 &amp;= ~X86_CR3_PCID_NOFLUSH;
		pcid = cr3 &amp; X86_CR3_PCID_MASK;
	}
#endif

	/* PDPTRs are always reloaded for PAE paging. */
<blue>	if (cr3 == kvm_read_cr3(vcpu) && !is_pae_paging(vcpu))</blue>
		goto handle_tlb_flush;

	/*
	 * Do not condition the GPA check on long mode, this helper is used to
	 * stuff CR3, e.g. for RSM emulation, and there is no guarantee that
	 * the current vCPU mode is accurate.
	 */
<blue>	if (kvm_vcpu_is_illegal_gpa(vcpu, cr3))</blue>
		return 1;

<blue>	if (is_pae_paging(vcpu) && !load_pdptrs(vcpu, cr3))</blue>
		return 1;

<blue>	if (cr3 != kvm_read_cr3(vcpu))</blue>
<blue>		kvm_mmu_new_pgd(vcpu, cr3);</blue>

<blue>	vcpu->arch.cr3 = cr3;</blue>
	kvm_register_mark_dirty(vcpu, VCPU_EXREG_CR3);
	/* Do not call post_set_cr3, we do not get here for confidential guests.  */

handle_tlb_flush:
	/*
	 * A load of CR3 that flushes the TLB flushes only the current PCID,
	 * even if PCID is disabled, in which case PCID=0 is flushed.  It&#x27;s a
	 * moot point in the end because _disabling_ PCID will flush all PCIDs,
	 * and it&#x27;s impossible to use a non-zero PCID when PCID is disabled,
	 * i.e. only PCID=0 can be relevant.
	 */
<blue>	if (!skip_tlb_flush)</blue>
<blue>		kvm_invalidate_pcid(vcpu, pcid);</blue>

	return 0;
<blue>}</blue>
EXPORT_SYMBOL_GPL(kvm_set_cr3);

<blue>int kvm_set_cr8(struct kvm_vcpu *vcpu, unsigned long cr8)</blue>
{
<blue>	if (cr8 & CR8_RESERVED_BITS)</blue>
		return 1;
<blue>	if (lapic_in_kernel(vcpu))</blue>
<blue>		kvm_lapic_set_tpr(vcpu, cr8);</blue>
	else
<yellow>		vcpu->arch.cr8 = cr8;</yellow>
	return 0;
<blue>}</blue>
EXPORT_SYMBOL_GPL(kvm_set_cr8);

unsigned long kvm_get_cr8(struct kvm_vcpu *vcpu)
{
<blue>	if (lapic_in_kernel(vcpu))</blue>
<blue>		return kvm_lapic_get_cr8(vcpu);</blue>
	else
<yellow>		return vcpu->arch.cr8;</yellow>
<blue>}</blue>
EXPORT_SYMBOL_GPL(kvm_get_cr8);

<blue>static void kvm_update_dr0123(struct kvm_vcpu *vcpu)</blue>
{
	int i;

	if (!(vcpu-&gt;guest_debug &amp; KVM_GUESTDBG_USE_HW_BP)) {
		for (i = 0; i &lt; KVM_NR_DB_REGS; i++)
<blue>			vcpu->arch.eff_db[i] = vcpu->arch.db[i];</blue>
	}
}

void kvm_update_dr7(struct kvm_vcpu *vcpu)
{
	unsigned long dr7;

<blue>	if (vcpu->guest_debug & KVM_GUESTDBG_USE_HW_BP)</blue>
<yellow>		dr7 = vcpu->arch.guest_debug_dr7;</yellow>
	else
<yellow>		dr7 = vcpu->arch.dr7;</yellow>
<blue>	static_call(kvm_x86_set_dr7)(vcpu, dr7);</blue>
<blue>	vcpu->arch.switch_db_regs &= ~KVM_DEBUGREG_BP_ENABLED;</blue>
	if (dr7 &amp; DR7_BP_EN_MASK)
<blue>		vcpu->arch.switch_db_regs |= KVM_DEBUGREG_BP_ENABLED;</blue>
<yellow>}</yellow>
EXPORT_SYMBOL_GPL(kvm_update_dr7);

static u64 kvm_dr6_fixed(struct kvm_vcpu *vcpu)
{
	u64 fixed = DR6_FIXED_1;

<yellow>	if (!guest_cpuid_has(vcpu, X86_FEATURE_RTM))</yellow>
		fixed |= DR6_RTM;

<yellow>	if (!guest_cpuid_has(vcpu, X86_FEATURE_BUS_LOCK_DETECT))</yellow>
<yellow>		fixed |= DR6_BUS_LOCK;</yellow>
	return fixed;
}

int kvm_set_dr(struct kvm_vcpu *vcpu, int dr, unsigned long val)
{
	size_t size = ARRAY_SIZE(vcpu-&gt;arch.db);

<blue>	switch (dr) {</blue>
	case 0 ... 3:
<yellow>		vcpu->arch.db[array_index_nospec(dr, size)] = val;</yellow>
		if (!(vcpu-&gt;guest_debug &amp; KVM_GUESTDBG_USE_HW_BP))
<yellow>			vcpu->arch.eff_db[dr] = val;</yellow>
		break;
	case 4:
	case 6:
<yellow>		if (!kvm_dr6_valid(val))</yellow>
			return 1; /* #GP */
<yellow>		vcpu->arch.dr6 = (val & DR6_VOLATILE) | kvm_dr6_fixed(vcpu);</yellow>
		break;
	case 5:
	default: /* 7 */
<blue>		if (!kvm_dr7_valid(val))</blue>
			return 1; /* #GP */
<blue>		vcpu->arch.dr7 = (val & DR7_VOLATILE) | DR7_FIXED_1;</blue>
<blue>		kvm_update_dr7(vcpu);</blue>
		break;
	}

	return 0;
<blue>}</blue>
EXPORT_SYMBOL_GPL(kvm_set_dr);

<blue>void kvm_get_dr(struct kvm_vcpu *vcpu, int dr, unsigned long *val)</blue>
{
	size_t size = ARRAY_SIZE(vcpu-&gt;arch.db);

<blue>	switch (dr) {</blue>
	case 0 ... 3:
<blue>		*val = vcpu->arch.db[array_index_nospec(dr, size)];</blue>
		break;
	case 4:
	case 6:
<yellow>		*val = vcpu->arch.dr6;</yellow>
		break;
	case 5:
	default: /* 7 */
<blue>		*val = vcpu->arch.dr7;</blue>
		break;
	}
}
EXPORT_SYMBOL_GPL(kvm_get_dr);

<blue>int kvm_emulate_rdpmc(struct kvm_vcpu *vcpu)</blue>
<blue>{</blue>
<blue>	u32 ecx = kvm_rcx_read(vcpu);</blue>
	u64 data;

	if (kvm_pmu_rdpmc(vcpu, ecx, &amp;data)) {
<blue>		kvm_inject_gp(vcpu, 0);</blue>
		return 1;
	}

<yellow>	kvm_rax_write(vcpu, (u32)data);</yellow>
	kvm_rdx_write(vcpu, data &gt;&gt; 32);
<yellow>	return kvm_skip_emulated_instruction(vcpu);</yellow>
}
EXPORT_SYMBOL_GPL(kvm_emulate_rdpmc);

/*
 * List of msr numbers which we expose to userspace through KVM_GET_MSRS
 * and KVM_SET_MSRS, and KVM_GET_MSR_INDEX_LIST.
 *
 * The three MSR lists(msrs_to_save, emulated_msrs, msr_based_features)
 * extract the supported MSRs from the related const lists.
 * msrs_to_save is selected from the msrs_to_save_all to reflect the
 * capabilities of the host cpu. This capabilities test skips MSRs that are
 * kvm-specific. Those are put in emulated_msrs_all; filtering of emulated_msrs
 * may depend on host virtualization features rather than host cpu features.
 */

static const u32 msrs_to_save_all[] = {
	MSR_IA32_SYSENTER_CS, MSR_IA32_SYSENTER_ESP, MSR_IA32_SYSENTER_EIP,
	MSR_STAR,
#ifdef CONFIG_X86_64
	MSR_CSTAR, MSR_KERNEL_GS_BASE, MSR_SYSCALL_MASK, MSR_LSTAR,
#endif
	MSR_IA32_TSC, MSR_IA32_CR_PAT, MSR_VM_HSAVE_PA,
	MSR_IA32_FEAT_CTL, MSR_IA32_BNDCFGS, MSR_TSC_AUX,
	MSR_IA32_SPEC_CTRL,
	MSR_IA32_RTIT_CTL, MSR_IA32_RTIT_STATUS, MSR_IA32_RTIT_CR3_MATCH,
	MSR_IA32_RTIT_OUTPUT_BASE, MSR_IA32_RTIT_OUTPUT_MASK,
	MSR_IA32_RTIT_ADDR0_A, MSR_IA32_RTIT_ADDR0_B,
	MSR_IA32_RTIT_ADDR1_A, MSR_IA32_RTIT_ADDR1_B,
	MSR_IA32_RTIT_ADDR2_A, MSR_IA32_RTIT_ADDR2_B,
	MSR_IA32_RTIT_ADDR3_A, MSR_IA32_RTIT_ADDR3_B,
	MSR_IA32_UMWAIT_CONTROL,

	MSR_ARCH_PERFMON_FIXED_CTR0, MSR_ARCH_PERFMON_FIXED_CTR1,
	MSR_ARCH_PERFMON_FIXED_CTR0 + 2,
	MSR_CORE_PERF_FIXED_CTR_CTRL, MSR_CORE_PERF_GLOBAL_STATUS,
	MSR_CORE_PERF_GLOBAL_CTRL, MSR_CORE_PERF_GLOBAL_OVF_CTRL,
	MSR_IA32_PEBS_ENABLE, MSR_IA32_DS_AREA, MSR_PEBS_DATA_CFG,

	/* This part of MSRs should match KVM_INTEL_PMC_MAX_GENERIC. */
	MSR_ARCH_PERFMON_PERFCTR0, MSR_ARCH_PERFMON_PERFCTR1,
	MSR_ARCH_PERFMON_PERFCTR0 + 2, MSR_ARCH_PERFMON_PERFCTR0 + 3,
	MSR_ARCH_PERFMON_PERFCTR0 + 4, MSR_ARCH_PERFMON_PERFCTR0 + 5,
	MSR_ARCH_PERFMON_PERFCTR0 + 6, MSR_ARCH_PERFMON_PERFCTR0 + 7,
	MSR_ARCH_PERFMON_EVENTSEL0, MSR_ARCH_PERFMON_EVENTSEL1,
	MSR_ARCH_PERFMON_EVENTSEL0 + 2, MSR_ARCH_PERFMON_EVENTSEL0 + 3,
	MSR_ARCH_PERFMON_EVENTSEL0 + 4, MSR_ARCH_PERFMON_EVENTSEL0 + 5,
	MSR_ARCH_PERFMON_EVENTSEL0 + 6, MSR_ARCH_PERFMON_EVENTSEL0 + 7,

	MSR_K7_EVNTSEL0, MSR_K7_EVNTSEL1, MSR_K7_EVNTSEL2, MSR_K7_EVNTSEL3,
	MSR_K7_PERFCTR0, MSR_K7_PERFCTR1, MSR_K7_PERFCTR2, MSR_K7_PERFCTR3,

	/* This part of MSRs should match KVM_AMD_PMC_MAX_GENERIC. */
	MSR_F15H_PERF_CTL0, MSR_F15H_PERF_CTL1, MSR_F15H_PERF_CTL2,
	MSR_F15H_PERF_CTL3, MSR_F15H_PERF_CTL4, MSR_F15H_PERF_CTL5,
	MSR_F15H_PERF_CTR0, MSR_F15H_PERF_CTR1, MSR_F15H_PERF_CTR2,
	MSR_F15H_PERF_CTR3, MSR_F15H_PERF_CTR4, MSR_F15H_PERF_CTR5,

	MSR_IA32_XFD, MSR_IA32_XFD_ERR,
};

static u32 msrs_to_save[ARRAY_SIZE(msrs_to_save_all)];
static unsigned num_msrs_to_save;

static const u32 emulated_msrs_all[] = {
	MSR_KVM_SYSTEM_TIME, MSR_KVM_WALL_CLOCK,
	MSR_KVM_SYSTEM_TIME_NEW, MSR_KVM_WALL_CLOCK_NEW,
	HV_X64_MSR_GUEST_OS_ID, HV_X64_MSR_HYPERCALL,
	HV_X64_MSR_TIME_REF_COUNT, HV_X64_MSR_REFERENCE_TSC,
	HV_X64_MSR_TSC_FREQUENCY, HV_X64_MSR_APIC_FREQUENCY,
	HV_X64_MSR_CRASH_P0, HV_X64_MSR_CRASH_P1, HV_X64_MSR_CRASH_P2,
	HV_X64_MSR_CRASH_P3, HV_X64_MSR_CRASH_P4, HV_X64_MSR_CRASH_CTL,
	HV_X64_MSR_RESET,
	HV_X64_MSR_VP_INDEX,
	HV_X64_MSR_VP_RUNTIME,
	HV_X64_MSR_SCONTROL,
	HV_X64_MSR_STIMER0_CONFIG,
	HV_X64_MSR_VP_ASSIST_PAGE,
	HV_X64_MSR_REENLIGHTENMENT_CONTROL, HV_X64_MSR_TSC_EMULATION_CONTROL,
	HV_X64_MSR_TSC_EMULATION_STATUS,
	HV_X64_MSR_SYNDBG_OPTIONS,
	HV_X64_MSR_SYNDBG_CONTROL, HV_X64_MSR_SYNDBG_STATUS,
	HV_X64_MSR_SYNDBG_SEND_BUFFER, HV_X64_MSR_SYNDBG_RECV_BUFFER,
	HV_X64_MSR_SYNDBG_PENDING_BUFFER,

	MSR_KVM_ASYNC_PF_EN, MSR_KVM_STEAL_TIME,
	MSR_KVM_PV_EOI_EN, MSR_KVM_ASYNC_PF_INT, MSR_KVM_ASYNC_PF_ACK,

	MSR_IA32_TSC_ADJUST,
	MSR_IA32_TSC_DEADLINE,
	MSR_IA32_ARCH_CAPABILITIES,
	MSR_IA32_PERF_CAPABILITIES,
	MSR_IA32_MISC_ENABLE,
	MSR_IA32_MCG_STATUS,
	MSR_IA32_MCG_CTL,
	MSR_IA32_MCG_EXT_CTL,
	MSR_IA32_SMBASE,
	MSR_SMI_COUNT,
	MSR_PLATFORM_INFO,
	MSR_MISC_FEATURES_ENABLES,
	MSR_AMD64_VIRT_SPEC_CTRL,
	MSR_AMD64_TSC_RATIO,
	MSR_IA32_POWER_CTL,
	MSR_IA32_UCODE_REV,

	/*
	 * The following list leaves out MSRs whose values are determined
	 * by arch/x86/kvm/vmx/nested.c based on CPUID or other MSRs.
	 * We always support the &quot;true&quot; VMX control MSRs, even if the host
	 * processor does not, so I am putting these registers here rather
	 * than in msrs_to_save_all.
	 */
	MSR_IA32_VMX_BASIC,
	MSR_IA32_VMX_TRUE_PINBASED_CTLS,
	MSR_IA32_VMX_TRUE_PROCBASED_CTLS,
	MSR_IA32_VMX_TRUE_EXIT_CTLS,
	MSR_IA32_VMX_TRUE_ENTRY_CTLS,
	MSR_IA32_VMX_MISC,
	MSR_IA32_VMX_CR0_FIXED0,
	MSR_IA32_VMX_CR4_FIXED0,
	MSR_IA32_VMX_VMCS_ENUM,
	MSR_IA32_VMX_PROCBASED_CTLS2,
	MSR_IA32_VMX_EPT_VPID_CAP,
	MSR_IA32_VMX_VMFUNC,

	MSR_K7_HWCR,
	MSR_KVM_POLL_CONTROL,
};

static u32 emulated_msrs[ARRAY_SIZE(emulated_msrs_all)];
static unsigned num_emulated_msrs;

/*
 * List of msr numbers which are used to expose MSR-based features that
 * can be used by a hypervisor to validate requested CPU features.
 */
static const u32 msr_based_features_all[] = {
	MSR_IA32_VMX_BASIC,
	MSR_IA32_VMX_TRUE_PINBASED_CTLS,
	MSR_IA32_VMX_PINBASED_CTLS,
	MSR_IA32_VMX_TRUE_PROCBASED_CTLS,
	MSR_IA32_VMX_PROCBASED_CTLS,
	MSR_IA32_VMX_TRUE_EXIT_CTLS,
	MSR_IA32_VMX_EXIT_CTLS,
	MSR_IA32_VMX_TRUE_ENTRY_CTLS,
	MSR_IA32_VMX_ENTRY_CTLS,
	MSR_IA32_VMX_MISC,
	MSR_IA32_VMX_CR0_FIXED0,
	MSR_IA32_VMX_CR0_FIXED1,
	MSR_IA32_VMX_CR4_FIXED0,
	MSR_IA32_VMX_CR4_FIXED1,
	MSR_IA32_VMX_VMCS_ENUM,
	MSR_IA32_VMX_PROCBASED_CTLS2,
	MSR_IA32_VMX_EPT_VPID_CAP,
	MSR_IA32_VMX_VMFUNC,

	MSR_AMD64_DE_CFG,
	MSR_IA32_UCODE_REV,
	MSR_IA32_ARCH_CAPABILITIES,
	MSR_IA32_PERF_CAPABILITIES,
};

static u32 msr_based_features[ARRAY_SIZE(msr_based_features_all)];
static unsigned int num_msr_based_features;

/*
 * Some IA32_ARCH_CAPABILITIES bits have dependencies on MSRs that KVM
 * does not yet virtualize. These include:
 *   10 - MISC_PACKAGE_CTRLS
 *   11 - ENERGY_FILTERING_CTL
 *   12 - DOITM
 *   18 - FB_CLEAR_CTRL
 *   21 - XAPIC_DISABLE_STATUS
 *   23 - OVERCLOCKING_STATUS
 */

#define KVM_SUPPORTED_ARCH_CAP \
	(ARCH_CAP_RDCL_NO | ARCH_CAP_IBRS_ALL | ARCH_CAP_RSBA | \
	 ARCH_CAP_SKIP_VMENTRY_L1DFLUSH | ARCH_CAP_SSB_NO | ARCH_CAP_MDS_NO | \
	 ARCH_CAP_PSCHANGE_MC_NO | ARCH_CAP_TSX_CTRL_MSR | ARCH_CAP_TAA_NO | \
	 ARCH_CAP_SBDR_SSDP_NO | ARCH_CAP_FBSDP_NO | ARCH_CAP_PSDP_NO | \
	 ARCH_CAP_FB_CLEAR | ARCH_CAP_RRSBA | ARCH_CAP_PBRSB_NO)

static u64 kvm_get_arch_capabilities(void)
{
	u64 data = 0;

<blue>	if (boot_cpu_has(X86_FEATURE_ARCH_CAPABILITIES)) {</blue>
<blue>		rdmsrl(MSR_IA32_ARCH_CAPABILITIES, data);</blue>
		data &amp;= KVM_SUPPORTED_ARCH_CAP;
	}

	/*
	 * If nx_huge_pages is enabled, KVM&#x27;s shadow paging will ensure that
	 * the nested hypervisor runs with NX huge pages.  If it is not,
	 * L1 is anyway vulnerable to ITLB_MULTIHIT exploits from other
	 * L1 guests, so it need not worry about its own (L2) guests.
	 */
	data |= ARCH_CAP_PSCHANGE_MC_NO;

	/*
	 * If we&#x27;re doing cache flushes (either &quot;always&quot; or &quot;cond&quot;)
	 * we will do one whenever the guest does a vmlaunch/vmresume.
	 * If an outer hypervisor is doing the cache flush for us
	 * (VMENTER_L1D_FLUSH_NESTED_VM), we can safely pass that
	 * capability to the guest too, and if EPT is disabled we&#x27;re not
	 * vulnerable.  Overall, only VMENTER_L1D_FLUSH_NEVER will
	 * require a nested hypervisor to do a flush of its own.
	 */
<blue>	if (l1tf_vmx_mitigation != VMENTER_L1D_FLUSH_NEVER)</blue>
<blue>		data |= ARCH_CAP_SKIP_VMENTRY_L1DFLUSH;</blue>

<blue>	if (!boot_cpu_has_bug(X86_BUG_CPU_MELTDOWN))</blue>
<blue>		data |= ARCH_CAP_RDCL_NO;</blue>
<blue>	if (!boot_cpu_has_bug(X86_BUG_SPEC_STORE_BYPASS))</blue>
<yellow>		data |= ARCH_CAP_SSB_NO;</yellow>
<blue>	if (!boot_cpu_has_bug(X86_BUG_MDS))</blue>
<blue>		data |= ARCH_CAP_MDS_NO;</blue>

<blue>	if (!boot_cpu_has(X86_FEATURE_RTM)) {</blue>
		/*
		 * If RTM=0 because the kernel has disabled TSX, the host might
		 * have TAA_NO or TSX_CTRL.  Clear TAA_NO (the guest sees RTM=0
		 * and therefore knows that there cannot be TAA) but keep
		 * TSX_CTRL: some buggy userspaces leave it set on tsx=on hosts,
		 * and we want to allow migrating those guests to tsx=off hosts.
		 */
<blue>		data &= ~ARCH_CAP_TAA_NO;</blue>
<yellow>	} else if (!boot_cpu_has_bug(X86_BUG_TAA)) {</yellow>
<yellow>		data |= ARCH_CAP_TAA_NO;</yellow>
	} else {
		/*
		 * Nothing to do here; we emulate TSX_CTRL if present on the
		 * host so the guest can choose between disabling TSX or
		 * using VERW to clear CPU buffers.
		 */
	}

	return data;
<blue>}</blue>

<blue>static int kvm_get_msr_feature(struct kvm_msr_entry *msr)</blue>
{
<blue>	switch (msr->index) {</blue>
	case MSR_IA32_ARCH_CAPABILITIES:
<blue>		msr->data = kvm_get_arch_capabilities();</blue>
		break;
	case MSR_IA32_PERF_CAPABILITIES:
<blue>		msr->data = kvm_caps.supported_perf_cap;</blue>
		break;
	case MSR_IA32_UCODE_REV:
<blue>		rdmsrl_safe(msr->index, &msr->data);</blue>
		break;
	default:
<blue>		return static_call(kvm_x86_get_msr_feature)(msr);</blue>
	}
	return 0;
}

static int do_get_msr_feature(struct kvm_vcpu *vcpu, unsigned index, u64 *data)
<blue>{</blue>
	struct kvm_msr_entry msr;
	int r;

	msr.index = index;
<blue>	r = kvm_get_msr_feature(&msr);</blue>

	if (r == KVM_MSR_RET_INVALID) {
		/* Unconditionally clear the output for simplicity */
<yellow>		*data = 0;</yellow>
		if (kvm_msr_ignored_check(index, 0, false))
			r = 0;
	}

<blue>	if (r)</blue>
		return r;

<blue>	*data = msr.data;</blue>

	return 0;
}

static bool __kvm_valid_efer(struct kvm_vcpu *vcpu, u64 efer)
{
<blue>	if (efer & EFER_FFXSR && !guest_cpuid_has(vcpu, X86_FEATURE_FXSR_OPT))</blue>
		return false;

<blue>	if (efer & EFER_SVME && !guest_cpuid_has(vcpu, X86_FEATURE_SVM))</blue>
		return false;

<blue>	if (efer & (EFER_LME | EFER_LMA) &&</blue>
<blue>	    !guest_cpuid_has(vcpu, X86_FEATURE_LM))</blue>
		return false;

<blue>	if (efer & EFER_NX && !guest_cpuid_has(vcpu, X86_FEATURE_NX))</blue>
		return false;

	return true;

<blue>}</blue>
bool kvm_valid_efer(struct kvm_vcpu *vcpu, u64 efer)
{
<blue>	if (efer & efer_reserved_bits)</blue>
		return false;

<blue>	return __kvm_valid_efer(vcpu, efer);</blue>
<blue>}</blue>
EXPORT_SYMBOL_GPL(kvm_valid_efer);

static int set_efer(struct kvm_vcpu *vcpu, struct msr_data *msr_info)
{
<blue>	u64 old_efer = vcpu->arch.efer;</blue>
	u64 efer = msr_info-&gt;data;
	int r;

	if (efer &amp; efer_reserved_bits)
		return 1;

<blue>	if (!msr_info->host_initiated) {</blue>
<blue>		if (!__kvm_valid_efer(vcpu, efer))</blue>
			return 1;

<blue>		if (is_paging(vcpu) &&</blue>
<yellow>		    (vcpu->arch.efer & EFER_LME) != (efer & EFER_LME))</yellow>
			return 1;
	}

<blue>	efer &= ~EFER_LMA;</blue>
<yellow>	efer |= vcpu->arch.efer & EFER_LMA;</yellow>

	r = static_call(kvm_x86_set_efer)(vcpu, efer);
	if (r) {
<yellow>		WARN_ON(r > 0);</yellow>
		return r;
	}

<blue>	if ((efer ^ old_efer) & KVM_MMU_EFER_ROLE_BITS)</blue>
<blue>		kvm_mmu_reset_context(vcpu);</blue>

	return 0;
}

void kvm_enable_efer_bits(u64 mask)
{
<yellow>       efer_reserved_bits &= ~mask;</yellow>
}
EXPORT_SYMBOL_GPL(kvm_enable_efer_bits);

bool kvm_msr_allowed(struct kvm_vcpu *vcpu, u32 index, u32 type)
{
	struct kvm_x86_msr_filter *msr_filter;
	struct msr_bitmap_range *ranges;
<blue>	struct kvm *kvm = vcpu->kvm;</blue>
	bool allowed;
	int idx;
	u32 i;

	/* x2APIC MSRs do not support filtering. */
<blue>	if (index >= 0x800 && index <= 0x8ff)</blue>
		return true;

<blue>	idx = srcu_read_lock(&kvm->srcu);</blue>

<blue>	msr_filter = srcu_dereference(kvm->arch.msr_filter, &kvm->srcu);</blue>
<blue>	if (!msr_filter) {</blue>
		allowed = true;
		goto out;
	}

<blue>	allowed = msr_filter->default_allow;</blue>
	ranges = msr_filter-&gt;ranges;

<blue>	for (i = 0; i < msr_filter->count; i++) {</blue>
<blue>		u32 start = ranges[i].base;</blue>
<blue>		u32 end = start + ranges[i].nmsrs;</blue>
<yellow>		u32 flags = ranges[i].flags;</yellow>
<yellow>		unsigned long *bitmap = ranges[i].bitmap;</yellow>

		if ((index &gt;= start) &amp;&amp; (index &lt; end) &amp;&amp; (flags &amp; type)) {
			allowed = !!test_bit(index - start, bitmap);
			break;
		}
	}

out:
<blue>	srcu_read_unlock(&kvm->srcu, idx);</blue>

	return allowed;
<blue>}</blue>
EXPORT_SYMBOL_GPL(kvm_msr_allowed);

/*
 * Write @data into the MSR specified by @index.  Select MSR specific fault
 * checks are bypassed if @host_initiated is %true.
 * Returns 0 on success, non-0 otherwise.
 * Assumes vcpu_load() was already called.
 */
static int __kvm_set_msr(struct kvm_vcpu *vcpu, u32 index, u64 data,
			 bool host_initiated)
<blue>{</blue>
	struct msr_data msr;

<blue>	switch (index) {</blue>
	case MSR_FS_BASE:
	case MSR_GS_BASE:
	case MSR_KERNEL_GS_BASE:
	case MSR_CSTAR:
	case MSR_LSTAR:
<blue>		if (is_noncanonical_address(data, vcpu))</blue>
			return 1;
		break;
	case MSR_IA32_SYSENTER_EIP:
	case MSR_IA32_SYSENTER_ESP:
		/*
		 * IA32_SYSENTER_ESP and IA32_SYSENTER_EIP cause #GP if
		 * non-canonical address is written on Intel but not on
		 * AMD (which ignores the top 32-bits, because it does
		 * not implement 64-bit SYSENTER).
		 *
		 * 64-bit code should hence be able to write a non-canonical
		 * value on AMD.  Making the address canonical ensures that
		 * vmentry does not fail on Intel after writing a non-canonical
		 * value, and that something deterministic happens if the guest
		 * invokes 64-bit SYSENTER.
		 */
<blue>		data = __canonical_address(data, vcpu_virt_addr_bits(vcpu));</blue>
		break;
	case MSR_TSC_AUX:
<blue>		if (!kvm_is_supported_user_return_msr(MSR_TSC_AUX))</blue>
			return 1;

<blue>		if (!host_initiated &&</blue>
<blue>		    !guest_cpuid_has(vcpu, X86_FEATURE_RDTSCP) &&</blue>
<yellow>		    !guest_cpuid_has(vcpu, X86_FEATURE_RDPID))</yellow>
			return 1;

		/*
		 * Per Intel&#x27;s SDM, bits 63:32 are reserved, but AMD&#x27;s APM has
		 * incomplete and conflicting architectural behavior.  Current
		 * AMD CPUs completely ignore bits 63:32, i.e. they aren&#x27;t
		 * reserved and always read as zeros.  Enforce Intel&#x27;s reserved
		 * bits check if and only if the guest CPU is Intel, and clear
		 * the bits in all other cases.  This ensures cross-vendor
		 * migration will provide consistent behavior for the guest.
		 */
<blue>		if (guest_cpuid_is_intel(vcpu) && (data >> 32) != 0)</blue>
			return 1;

<blue>		data = (u32)data;</blue>
		break;
	}

<blue>	msr.data = data;</blue>
	msr.index = index;
	msr.host_initiated = host_initiated;

<blue>	return static_call(kvm_x86_set_msr)(vcpu, &msr);</blue>
}

<blue>static int kvm_set_msr_ignored_check(struct kvm_vcpu *vcpu,</blue>
				     u32 index, u64 data, bool host_initiated)
{
<blue>	int ret = __kvm_set_msr(vcpu, index, data, host_initiated);</blue>

	if (ret == KVM_MSR_RET_INVALID)
<blue>		if (kvm_msr_ignored_check(index, data, true))</blue>
			ret = 0;

	return ret;
}

/*
 * Read the MSR specified by @index into @data.  Select MSR specific fault
 * checks are bypassed if @host_initiated is %true.
 * Returns 0 on success, non-0 otherwise.
 * Assumes vcpu_load() was already called.
 */
int __kvm_get_msr(struct kvm_vcpu *vcpu, u32 index, u64 *data,
		  bool host_initiated)
<blue>{</blue>
	struct msr_data msr;
	int ret;

<blue>	switch (index) {</blue>
	case MSR_TSC_AUX:
<blue>		if (!kvm_is_supported_user_return_msr(MSR_TSC_AUX))</blue>
			return 1;

<blue>		if (!host_initiated &&</blue>
<yellow>		    !guest_cpuid_has(vcpu, X86_FEATURE_RDTSCP) &&</yellow>
<yellow>		    !guest_cpuid_has(vcpu, X86_FEATURE_RDPID))</yellow>
			return 1;
		break;
	}

<blue>	msr.index = index;</blue>
	msr.host_initiated = host_initiated;

	ret = static_call(kvm_x86_get_msr)(vcpu, &amp;msr);
	if (!ret)
<blue>		*data = msr.data;</blue>
	return ret;
}

<blue>static int kvm_get_msr_ignored_check(struct kvm_vcpu *vcpu,</blue>
				     u32 index, u64 *data, bool host_initiated)
{
<blue>	int ret = __kvm_get_msr(vcpu, index, data, host_initiated);</blue>

	if (ret == KVM_MSR_RET_INVALID) {
		/* Unconditionally clear *data for simplicity */
<blue>		*data = 0;</blue>
<blue>		if (kvm_msr_ignored_check(index, 0, false))</blue>
			ret = 0;
	}

	return ret;
}

<blue>static int kvm_get_msr_with_filter(struct kvm_vcpu *vcpu, u32 index, u64 *data)</blue>
{
	if (!kvm_msr_allowed(vcpu, index, KVM_MSR_FILTER_READ))
		return KVM_MSR_RET_FILTERED;
<blue>	return kvm_get_msr_ignored_check(vcpu, index, data, false);</blue>
}

<blue>static int kvm_set_msr_with_filter(struct kvm_vcpu *vcpu, u32 index, u64 data)</blue>
{
	if (!kvm_msr_allowed(vcpu, index, KVM_MSR_FILTER_WRITE))
		return KVM_MSR_RET_FILTERED;
<blue>	return kvm_set_msr_ignored_check(vcpu, index, data, false);</blue>
}

int kvm_get_msr(struct kvm_vcpu *vcpu, u32 index, u64 *data)
{
<blue>	return kvm_get_msr_ignored_check(vcpu, index, data, false);</blue>
<blue>}</blue>
EXPORT_SYMBOL_GPL(kvm_get_msr);

int kvm_set_msr(struct kvm_vcpu *vcpu, u32 index, u64 data)
{
<blue>	return kvm_set_msr_ignored_check(vcpu, index, data, false);</blue>
<blue>}</blue>
EXPORT_SYMBOL_GPL(kvm_set_msr);

static void complete_userspace_rdmsr(struct kvm_vcpu *vcpu)
{
<yellow>	if (!vcpu->run->msr.error) {</yellow>
<yellow>		kvm_rax_write(vcpu, (u32)vcpu->run->msr.data);</yellow>
		kvm_rdx_write(vcpu, vcpu-&gt;run-&gt;msr.data &gt;&gt; 32);
	}
}

static int complete_emulated_msr_access(struct kvm_vcpu *vcpu)
{
<yellow>	return complete_emulated_insn_gp(vcpu, vcpu->run->msr.error);</yellow>
<yellow>}</yellow>

static int complete_emulated_rdmsr(struct kvm_vcpu *vcpu)
{
<yellow>	complete_userspace_rdmsr(vcpu);</yellow>
<yellow>	return complete_emulated_msr_access(vcpu);</yellow>
<yellow>}</yellow>

static int complete_fast_msr_access(struct kvm_vcpu *vcpu)
{
<yellow>	return static_call(kvm_x86_complete_emulated_msr)(vcpu, vcpu->run->msr.error);</yellow>
}

static int complete_fast_rdmsr(struct kvm_vcpu *vcpu)
{
<yellow>	complete_userspace_rdmsr(vcpu);</yellow>
<yellow>	return complete_fast_msr_access(vcpu);</yellow>
}

static u64 kvm_msr_reason(int r)
{
<blue>	switch (r) {</blue>
	case KVM_MSR_RET_INVALID:
		return KVM_MSR_EXIT_REASON_UNKNOWN;
	case KVM_MSR_RET_FILTERED:
		return KVM_MSR_EXIT_REASON_FILTER;
	default:
		return KVM_MSR_EXIT_REASON_INVAL;
	}
}

static int kvm_msr_user_space(struct kvm_vcpu *vcpu, u32 index,
			      u32 exit_reason, u64 data,
			      int (*completion)(struct kvm_vcpu *vcpu),
			      int r)
{
<blue>	u64 msr_reason = kvm_msr_reason(r);</blue>

	/* Check if the user wanted to know about this MSR fault */
<blue>	if (!(vcpu->kvm->arch.user_space_msr_mask & msr_reason))</blue>
		return 0;

<yellow>	vcpu->run->exit_reason = exit_reason;</yellow>
	vcpu-&gt;run-&gt;msr.error = 0;
	memset(vcpu-&gt;run-&gt;msr.pad, 0, sizeof(vcpu-&gt;run-&gt;msr.pad));
	vcpu-&gt;run-&gt;msr.reason = msr_reason;
	vcpu-&gt;run-&gt;msr.index = index;
	vcpu-&gt;run-&gt;msr.data = data;
	vcpu-&gt;arch.complete_userspace_io = completion;

	return 1;
<blue>}</blue>

int kvm_emulate_rdmsr(struct kvm_vcpu *vcpu)
<blue>{</blue>
<blue>	u32 ecx = kvm_rcx_read(vcpu);</blue>
	u64 data;
	int r;

<blue>	r = kvm_get_msr_with_filter(vcpu, ecx, &data);</blue>

<blue>	if (!r) {</blue>
<blue>		trace_kvm_msr_read(ecx, data);</blue>

		kvm_rax_write(vcpu, data &amp; -1u);
		kvm_rdx_write(vcpu, (data &gt;&gt; 32) &amp; -1u);
	} else {
		/* MSR read failed? See if we should ask user space */
<blue>		if (kvm_msr_user_space(vcpu, ecx, KVM_EXIT_X86_RDMSR, 0,</blue>
				       complete_fast_rdmsr, r))
			return 0;
<blue>		trace_kvm_msr_read_ex(ecx);</blue>
	}

<blue>	return static_call(kvm_x86_complete_emulated_msr)(vcpu, r);</blue>
}
EXPORT_SYMBOL_GPL(kvm_emulate_rdmsr);

int kvm_emulate_wrmsr(struct kvm_vcpu *vcpu)
{
<blue>	u32 ecx = kvm_rcx_read(vcpu);</blue>
	u64 data = kvm_read_edx_eax(vcpu);
	int r;

<blue>	r = kvm_set_msr_with_filter(vcpu, ecx, data);</blue>

<blue>	if (!r) {</blue>
<blue>		trace_kvm_msr_write(ecx, data);</blue>
	} else {
		/* MSR write failed? See if we should ask user space */
<blue>		if (kvm_msr_user_space(vcpu, ecx, KVM_EXIT_X86_WRMSR, data,</blue>
				       complete_fast_msr_access, r))
			return 0;
		/* Signal all other negative errors to userspace */
<blue>		if (r < 0)</blue>
			return r;
<blue>		trace_kvm_msr_write_ex(ecx, data);</blue>
	}

<blue>	return static_call(kvm_x86_complete_emulated_msr)(vcpu, r);</blue>
<blue>}</blue>
EXPORT_SYMBOL_GPL(kvm_emulate_wrmsr);

int kvm_emulate_as_nop(struct kvm_vcpu *vcpu)
{
<blue>	return kvm_skip_emulated_instruction(vcpu);</blue>
<yellow>}</yellow>

int kvm_emulate_invd(struct kvm_vcpu *vcpu)
{
	/* Treat an INVD instruction as a NOP and just skip it. */
	return kvm_emulate_as_nop(vcpu);
}
EXPORT_SYMBOL_GPL(kvm_emulate_invd);

int kvm_handle_invalid_op(struct kvm_vcpu *vcpu)
{
<yellow>	kvm_queue_exception(vcpu, UD_VECTOR);</yellow>
	return 1;
}
EXPORT_SYMBOL_GPL(kvm_handle_invalid_op);


static int kvm_emulate_monitor_mwait(struct kvm_vcpu *vcpu, const char *insn)
{
<blue>	if (!kvm_check_has_quirk(vcpu->kvm, KVM_X86_QUIRK_MWAIT_NEVER_UD_FAULTS) &&</blue>
<yellow>	    !guest_cpuid_has(vcpu, X86_FEATURE_MWAIT))</yellow>
<yellow>		return kvm_handle_invalid_op(vcpu);</yellow>

<blue>	pr_warn_once("kvm: %s instruction emulated as NOP!\n", insn);</blue>
<blue>	return kvm_emulate_as_nop(vcpu);</blue>
<blue>}</blue>
int kvm_emulate_mwait(struct kvm_vcpu *vcpu)
{
<blue>	return kvm_emulate_monitor_mwait(vcpu, "MWAIT");</blue>
}
EXPORT_SYMBOL_GPL(kvm_emulate_mwait);

int kvm_emulate_monitor(struct kvm_vcpu *vcpu)
{
<blue>	return kvm_emulate_monitor_mwait(vcpu, "MONITOR");</blue>
}
EXPORT_SYMBOL_GPL(kvm_emulate_monitor);

static inline bool kvm_vcpu_exit_request(struct kvm_vcpu *vcpu)
{
<blue>	xfer_to_guest_mode_prepare();</blue>
<blue>	return vcpu->mode == EXITING_GUEST_MODE || kvm_request_pending(vcpu) ||</blue>
<blue>		xfer_to_guest_mode_work_pending();</blue>
}

/*
 * The fast path for frequent and performance sensitive wrmsr emulation,
 * i.e. the sending of IPI, sending IPI early in the VM-Exit flow reduces
 * the latency of virtual IPI by avoiding the expensive bits of transitioning
 * from guest to host, e.g. reacquiring KVM&#x27;s SRCU lock. In contrast to the
 * other cases which must be called after interrupts are enabled on the host.
 */
static int handle_fastpath_set_x2apic_icr_irqoff(struct kvm_vcpu *vcpu, u64 data)
{
<blue>	if (!lapic_in_kernel(vcpu) || !apic_x2apic_mode(vcpu->arch.apic))</blue>
		return 1;

	if (((data &amp; APIC_SHORT_MASK) == APIC_DEST_NOSHORT) &amp;&amp;
	    ((data &amp; APIC_DEST_MASK) == APIC_DEST_PHYSICAL) &amp;&amp;
	    ((data &amp; APIC_MODE_MASK) == APIC_DM_FIXED) &amp;&amp;
<yellow>	    ((u32)(data >> 32) != X2APIC_BROADCAST))</yellow>
<yellow>		return kvm_x2apic_icr_write(vcpu->arch.apic, data);</yellow>

	return 1;
}

static int handle_fastpath_set_tscdeadline(struct kvm_vcpu *vcpu, u64 data)
{
	if (!kvm_can_use_hv_timer(vcpu))
		return 1;

	kvm_set_lapic_tscdeadline_msr(vcpu, data);
	return 0;
}

fastpath_t handle_fastpath_set_msr_irqoff(struct kvm_vcpu *vcpu)
{
<blue>	u32 msr = kvm_rcx_read(vcpu);</blue>
	u64 data;
	fastpath_t ret = EXIT_FASTPATH_NONE;

	switch (msr) {
	case APIC_BASE_MSR + (APIC_ICR &gt;&gt; 4):
<yellow>		data = kvm_read_edx_eax(vcpu);</yellow>
<yellow>		if (!handle_fastpath_set_x2apic_icr_irqoff(vcpu, data)) {</yellow>
<yellow>			kvm_skip_emulated_instruction(vcpu);</yellow>
			ret = EXIT_FASTPATH_EXIT_HANDLED;
		}
		break;
	case MSR_IA32_TSC_DEADLINE:
<yellow>		data = kvm_read_edx_eax(vcpu);</yellow>
		if (!handle_fastpath_set_tscdeadline(vcpu, data)) {
			kvm_skip_emulated_instruction(vcpu);
			ret = EXIT_FASTPATH_REENTER_GUEST;
		}
		break;
	default:
		break;
	}

	if (ret != EXIT_FASTPATH_NONE)
<yellow>		trace_kvm_msr_write(msr, data);</yellow>

	return ret;
<blue>}</blue>
EXPORT_SYMBOL_GPL(handle_fastpath_set_msr_irqoff);

/*
 * Adapt set_msr() to msr_io()&#x27;s calling convention
 */
static int do_get_msr(struct kvm_vcpu *vcpu, unsigned index, u64 *data)
{
<blue>	return kvm_get_msr_ignored_check(vcpu, index, data, true);</blue>
<blue>}</blue>

static int do_set_msr(struct kvm_vcpu *vcpu, unsigned index, u64 *data)
{
<yellow>	return kvm_set_msr_ignored_check(vcpu, index, *data, true);</yellow>
}

#ifdef CONFIG_X86_64
struct pvclock_clock {
	int vclock_mode;
	u64 cycle_last;
	u64 mask;
	u32 mult;
	u32 shift;
	u64 base_cycles;
	u64 offset;
};

struct pvclock_gtod_data {
	seqcount_t	seq;

	struct pvclock_clock clock; /* extract of a clocksource struct */
	struct pvclock_clock raw_clock; /* extract of a clocksource struct */

	ktime_t		offs_boot;
	u64		wall_time_sec;
};

static struct pvclock_gtod_data pvclock_gtod_data;

static void update_pvclock_gtod(struct timekeeper *tk)
{
	struct pvclock_gtod_data *vdata = &amp;pvclock_gtod_data;

<yellow>	write_seqcount_begin(&vdata->seq);</yellow>

	/* copy pvclock gtod data */
	vdata-&gt;clock.vclock_mode	= tk-&gt;tkr_mono.clock-&gt;vdso_clock_mode;
	vdata-&gt;clock.cycle_last		= tk-&gt;tkr_mono.cycle_last;
	vdata-&gt;clock.mask		= tk-&gt;tkr_mono.mask;
	vdata-&gt;clock.mult		= tk-&gt;tkr_mono.mult;
	vdata-&gt;clock.shift		= tk-&gt;tkr_mono.shift;
	vdata-&gt;clock.base_cycles	= tk-&gt;tkr_mono.xtime_nsec;
	vdata-&gt;clock.offset		= tk-&gt;tkr_mono.base;

	vdata-&gt;raw_clock.vclock_mode	= tk-&gt;tkr_raw.clock-&gt;vdso_clock_mode;
	vdata-&gt;raw_clock.cycle_last	= tk-&gt;tkr_raw.cycle_last;
	vdata-&gt;raw_clock.mask		= tk-&gt;tkr_raw.mask;
	vdata-&gt;raw_clock.mult		= tk-&gt;tkr_raw.mult;
	vdata-&gt;raw_clock.shift		= tk-&gt;tkr_raw.shift;
	vdata-&gt;raw_clock.base_cycles	= tk-&gt;tkr_raw.xtime_nsec;
	vdata-&gt;raw_clock.offset		= tk-&gt;tkr_raw.base;

	vdata-&gt;wall_time_sec            = tk-&gt;xtime_sec;

	vdata-&gt;offs_boot		= tk-&gt;offs_boot;

	write_seqcount_end(&amp;vdata-&gt;seq);
}

static s64 get_kvmclock_base_ns(void)
{
	/* Count up from boot time, but with the frequency of the raw clock.  */
<yellow>	return ktime_to_ns(ktime_add(ktime_get_raw(), pvclock_gtod_data.offs_boot));</yellow>
}
#else
static s64 get_kvmclock_base_ns(void)
{
	/* Master clock not used, so we can just use CLOCK_BOOTTIME.  */
	return ktime_get_boottime_ns();
}
#endif

<blue>static void kvm_write_wall_clock(struct kvm *kvm, gpa_t wall_clock, int sec_hi_ofs)</blue>
{
	int version;
	int r;
	struct pvclock_wall_clock wc;
	u32 wc_sec_hi;
	u64 wall_nsec;

<blue>	if (!wall_clock)</blue>
		return;

<yellow>	r = kvm_read_guest(kvm, wall_clock, &version, sizeof(version));</yellow>
	if (r)
		return;

<yellow>	if (version & 1)</yellow>
<yellow>		++version;  /* first time write, random junk */</yellow>

<yellow>	++version;</yellow>

	if (kvm_write_guest(kvm, wall_clock, &amp;version, sizeof(version)))
		return;

	/*
	 * The guest calculates current wall clock time by adding
	 * system time (updated by kvm_guest_time_update below) to the
	 * wall clock specified here.  We do the reverse here.
	 */
<yellow>	wall_nsec = ktime_get_real_ns() - get_kvmclock_ns(kvm);</yellow>

	wc.nsec = do_div(wall_nsec, 1000000000);
	wc.sec = (u32)wall_nsec; /* overflow in 2106 guest time */
	wc.version = version;

	kvm_write_guest(kvm, wall_clock, &amp;wc, sizeof(wc));

	if (sec_hi_ofs) {
		wc_sec_hi = wall_nsec &gt;&gt; 32;
		kvm_write_guest(kvm, wall_clock + sec_hi_ofs,
				&amp;wc_sec_hi, sizeof(wc_sec_hi));
	}

	version++;
	kvm_write_guest(kvm, wall_clock, &amp;version, sizeof(version));
}

static void kvm_write_system_time(struct kvm_vcpu *vcpu, gpa_t system_time,
				  bool old_msr, bool host_initiated)
{
<yellow>	struct kvm_arch *ka = &vcpu->kvm->arch;</yellow>

<blue>	if (vcpu->vcpu_id == 0 && !host_initiated) {</blue>
<yellow>		if (ka->boot_vcpu_runs_old_kvmclock != old_msr)</yellow>
<yellow>			kvm_make_request(KVM_REQ_MASTERCLOCK_UPDATE, vcpu);</yellow>

<yellow>		ka->boot_vcpu_runs_old_kvmclock = old_msr;</yellow>
	}

<blue>	vcpu->arch.time = system_time;</blue>
	kvm_make_request(KVM_REQ_GLOBAL_CLOCK_UPDATE, vcpu);

	/* we verify if the enable bit is set... */
	if (system_time &amp; 1)
<yellow>		kvm_gpc_activate(&vcpu->arch.pv_time, system_time & ~1ULL,</yellow>
				 sizeof(struct pvclock_vcpu_time_info));
	else
<blue>		kvm_gpc_deactivate(&vcpu->arch.pv_time);</blue>

	return;
<blue>}</blue>

static uint32_t div_frac(uint32_t dividend, uint32_t divisor)
{
<yellow>	do_shl32_div32(dividend, divisor);</yellow>
	return dividend;
}

static void kvm_get_time_scale(uint64_t scaled_hz, uint64_t base_hz,
			       s8 *pshift, u32 *pmultiplier)
{
	uint64_t scaled64;
	int32_t  shift = 0;
	uint64_t tps64;
	uint32_t tps32;

	tps64 = base_hz;
	scaled64 = scaled_hz;
	while (tps64 &gt; scaled64*2 || tps64 &amp; 0xffffffff00000000ULL) {
<blue>		tps64 >>= 1;</blue>
		shift--;
	}

<yellow>	tps32 = (uint32_t)tps64;</yellow>
<blue>	while (tps32 <= scaled64 || scaled64 & 0xffffffff00000000ULL) {</blue>
<blue>		if (scaled64 & 0xffffffff00000000ULL || tps32 & 0x80000000)</blue>
<yellow>			scaled64 >>= 1;</yellow>
		else
<blue>			tps32 <<= 1;</blue>
		shift++;
	}

<blue>	*pshift = shift;</blue>
<yellow>	*pmultiplier = div_frac(scaled64, tps32);</yellow>
}

#ifdef CONFIG_X86_64
static atomic_t kvm_guest_has_master_clock = ATOMIC_INIT(0);
#endif

static DEFINE_PER_CPU(unsigned long, cpu_tsc_khz);
static unsigned long max_tsc_khz;

static u32 adjust_tsc_khz(u32 khz, s32 ppm)
{
	u64 v = (u64)khz * (1000000 + ppm);
	do_div(v, 1000000);
	return v;
}

static void kvm_vcpu_write_tsc_multiplier(struct kvm_vcpu *vcpu, u64 l1_multiplier);

static int set_tsc_khz(struct kvm_vcpu *vcpu, u32 user_tsc_khz, bool scale)
{
	u64 ratio;

	/* Guest TSC same frequency as host TSC? */
	if (!scale) {
<blue>		kvm_vcpu_write_tsc_multiplier(vcpu, kvm_caps.default_tsc_scaling_ratio);</blue>
		return 0;
	}

	/* TSC scaling supported? */
<yellow>	if (!kvm_caps.has_tsc_control) {</yellow>
<yellow>		if (user_tsc_khz > tsc_khz) {</yellow>
<yellow>			vcpu->arch.tsc_catchup = 1;</yellow>
			vcpu-&gt;arch.tsc_always_catchup = 1;
			return 0;
		} else {
<yellow>			pr_warn_ratelimited("user requested TSC rate below hardware speed\n");</yellow>
			return -1;
		}
	}

	/* TSC scaling required  - calculate ratio */
<yellow>	ratio = mul_u64_u32_div(1ULL << kvm_caps.tsc_scaling_ratio_frac_bits,</yellow>
				user_tsc_khz, tsc_khz);

<yellow>	if (ratio == 0 || ratio >= kvm_caps.max_tsc_scaling_ratio) {</yellow>
<yellow>		pr_warn_ratelimited("Invalid TSC scaling ratio - virtual-tsc-khz=%u\n",</yellow>
			            user_tsc_khz);
		return -1;
	}

<yellow>	kvm_vcpu_write_tsc_multiplier(vcpu, ratio);</yellow>
	return 0;
}

static int kvm_set_tsc_khz(struct kvm_vcpu *vcpu, u32 user_tsc_khz)
{
	u32 thresh_lo, thresh_hi;
	int use_scaling = 0;

	/* tsc_khz can be zero if TSC calibration fails */
<blue>	if (user_tsc_khz == 0) {</blue>
		/* set tsc_scaling_ratio to a safe value */
<yellow>		kvm_vcpu_write_tsc_multiplier(vcpu, kvm_caps.default_tsc_scaling_ratio);</yellow>
		return -1;
	}

	/* Compute a scale to convert nanoseconds in TSC cycles */
<blue>	kvm_get_time_scale(user_tsc_khz * 1000LL, NSEC_PER_SEC,</blue>
			   &amp;vcpu-&gt;arch.virtual_tsc_shift,
			   &amp;vcpu-&gt;arch.virtual_tsc_mult);
	vcpu-&gt;arch.virtual_tsc_khz = user_tsc_khz;

	/*
	 * Compute the variation in TSC rate which is acceptable
	 * within the range of tolerance and decide if the
	 * rate being applied is within that bounds of the hardware
	 * rate.  If so, no scaling or compensation need be done.
	 */
	thresh_lo = adjust_tsc_khz(tsc_khz, -tsc_tolerance_ppm);
	thresh_hi = adjust_tsc_khz(tsc_khz, tsc_tolerance_ppm);
<blue>	if (user_tsc_khz < thresh_lo || user_tsc_khz > thresh_hi) {</blue>
<yellow>		pr_debug("kvm: requested TSC rate %u falls outside tolerance [%u,%u]\n", user_tsc_khz, thresh_lo, thresh_hi);</yellow>
		use_scaling = 1;
	}
<blue>	return set_tsc_khz(vcpu, user_tsc_khz, use_scaling);</blue>
<blue>}</blue>

static u64 compute_guest_tsc(struct kvm_vcpu *vcpu, s64 kernel_ns)
{
<yellow>	u64 tsc = pvclock_scale_delta(kernel_ns-vcpu->arch.this_tsc_nsec,</yellow>
				      vcpu-&gt;arch.virtual_tsc_mult,
<yellow>				      vcpu->arch.virtual_tsc_shift);</yellow>
<yellow>	tsc += vcpu->arch.this_tsc_write;</yellow>
	return tsc;
}

#ifdef CONFIG_X86_64
static inline int gtod_is_based_on_tsc(int mode)
{
<yellow>	return mode == VDSO_CLOCKMODE_TSC || mode == VDSO_CLOCKMODE_HVCLOCK;</yellow>
}
#endif

static void kvm_track_tsc_matching(struct kvm_vcpu *vcpu)
{
#ifdef CONFIG_X86_64
	bool vcpus_matched;
	struct kvm_arch *ka = &amp;vcpu-&gt;kvm-&gt;arch;
	struct pvclock_gtod_data *gtod = &amp;pvclock_gtod_data;

<blue>	vcpus_matched = (ka->nr_vcpus_matched_tsc + 1 ==</blue>
			 atomic_read(&amp;vcpu-&gt;kvm-&gt;online_vcpus));

	/*
	 * Once the masterclock is enabled, always perform request in
	 * order to update it.
	 *
	 * In order to enable masterclock, the host clocksource must be TSC
	 * and the vcpus need to have matched TSCs.  When that happens,
	 * perform request to enable masterclock.
	 */
<blue>	if (ka->use_master_clock ||</blue>
<blue>	    (gtod_is_based_on_tsc(gtod->clock.vclock_mode) && vcpus_matched))</blue>
<blue>		kvm_make_request(KVM_REQ_MASTERCLOCK_UPDATE, vcpu);</blue>

<blue>	trace_kvm_track_tsc(vcpu->vcpu_id, ka->nr_vcpus_matched_tsc,</blue>
<blue>			    atomic_read(&vcpu->kvm->online_vcpus),</blue>
<blue>		            ka->use_master_clock, gtod->clock.vclock_mode);</blue>
#endif
}

/*
 * Multiply tsc by a fixed point number represented by ratio.
 *
 * The most significant 64-N bits (mult) of ratio represent the
 * integral part of the fixed point number; the remaining N bits
 * (frac) represent the fractional part, ie. ratio represents a fixed
 * point number (mult + frac * 2^(-N)).
 *
 * N equals to kvm_caps.tsc_scaling_ratio_frac_bits.
 */
static inline u64 __scale_tsc(u64 ratio, u64 tsc)
{
<yellow>	return mul_u64_u64_shr(tsc, ratio, kvm_caps.tsc_scaling_ratio_frac_bits);</yellow>
}

<yellow>u64 kvm_scale_tsc(u64 tsc, u64 ratio)</yellow>
{
	u64 _tsc = tsc;

<yellow>	if (ratio != kvm_caps.default_tsc_scaling_ratio)</yellow>
<yellow>		_tsc = __scale_tsc(ratio, tsc);</yellow>

	return _tsc;
<yellow>}</yellow>

static u64 kvm_compute_l1_tsc_offset(struct kvm_vcpu *vcpu, u64 target_tsc)
{
	u64 tsc;

<blue>	tsc = kvm_scale_tsc(rdtsc(), vcpu->arch.l1_tsc_scaling_ratio);</blue>

<blue>	return target_tsc - tsc;</blue>
}

u64 kvm_read_l1_tsc(struct kvm_vcpu *vcpu, u64 host_tsc)
{
<blue>	return vcpu->arch.l1_tsc_offset +</blue>
<yellow>		kvm_scale_tsc(host_tsc, vcpu->arch.l1_tsc_scaling_ratio);</yellow>
}
EXPORT_SYMBOL_GPL(kvm_read_l1_tsc);

u64 kvm_calc_nested_tsc_offset(u64 l1_offset, u64 l2_offset, u64 l2_multiplier)
{
	u64 nested_offset;

<blue>	if (l2_multiplier == kvm_caps.default_tsc_scaling_ratio)</blue>
		nested_offset = l1_offset;
	else
<blue>		nested_offset = mul_s64_u64_shr((s64) l1_offset, l2_multiplier,</blue>
						kvm_caps.tsc_scaling_ratio_frac_bits);

<blue>	nested_offset += l2_offset;</blue>
	return nested_offset;
}
EXPORT_SYMBOL_GPL(kvm_calc_nested_tsc_offset);

<blue>u64 kvm_calc_nested_tsc_multiplier(u64 l1_multiplier, u64 l2_multiplier)</blue>
{
<blue>	if (l2_multiplier != kvm_caps.default_tsc_scaling_ratio)</blue>
<blue>		return mul_u64_u64_shr(l1_multiplier, l2_multiplier,</blue>
				       kvm_caps.tsc_scaling_ratio_frac_bits);

	return l1_multiplier;
<blue>}</blue>
EXPORT_SYMBOL_GPL(kvm_calc_nested_tsc_multiplier);

static void kvm_vcpu_write_tsc_offset(struct kvm_vcpu *vcpu, u64 l1_offset)
{
<blue>	trace_kvm_write_tsc_offset(vcpu->vcpu_id,</blue>
				   vcpu-&gt;arch.l1_tsc_offset,
				   l1_offset);

<blue>	vcpu->arch.l1_tsc_offset = l1_offset;</blue>

	/*
	 * If we are here because L1 chose not to trap WRMSR to TSC then
	 * according to the spec this should set L1&#x27;s TSC (as opposed to
	 * setting L1&#x27;s offset for L2).
	 */
	if (is_guest_mode(vcpu))
<blue>		vcpu->arch.tsc_offset = kvm_calc_nested_tsc_offset(</blue>
			l1_offset,
			static_call(kvm_x86_get_l2_tsc_offset)(vcpu),
			static_call(kvm_x86_get_l2_tsc_multiplier)(vcpu));
	else
		vcpu-&gt;arch.tsc_offset = l1_offset;

	static_call(kvm_x86_write_tsc_offset)(vcpu, vcpu-&gt;arch.tsc_offset);
}

static void kvm_vcpu_write_tsc_multiplier(struct kvm_vcpu *vcpu, u64 l1_multiplier)
{
<blue>	vcpu->arch.l1_tsc_scaling_ratio = l1_multiplier;</blue>

	/* Userspace is changing the multiplier while L2 is active */
	if (is_guest_mode(vcpu))
<blue>		vcpu->arch.tsc_scaling_ratio = kvm_calc_nested_tsc_multiplier(</blue>
			l1_multiplier,
			static_call(kvm_x86_get_l2_tsc_multiplier)(vcpu));
	else
		vcpu-&gt;arch.tsc_scaling_ratio = l1_multiplier;

<blue>	if (kvm_caps.has_tsc_control)</blue>
<blue>		static_call(kvm_x86_write_tsc_multiplier)(</blue>
			vcpu, vcpu-&gt;arch.tsc_scaling_ratio);
<blue>}</blue>

<blue>static inline bool kvm_check_tsc_unstable(void)</blue>
{
#ifdef CONFIG_X86_64
	/*
	 * TSC is marked unstable when we&#x27;re running on Hyper-V,
	 * &#x27;TSC page&#x27; clocksource is good.
	 */
<blue>	if (pvclock_gtod_data.clock.vclock_mode == VDSO_CLOCKMODE_HVCLOCK)</blue>
		return false;
#endif
<blue>	return check_tsc_unstable();</blue>
}

/*
 * Infers attempts to synchronize the guest&#x27;s tsc from host writes. Sets the
 * offset for the vcpu and tracks the TSC matching generation that the vcpu
 * participates in.
 */
static void __kvm_synchronize_tsc(struct kvm_vcpu *vcpu, u64 offset, u64 tsc,
				  u64 ns, bool matched)
{
<blue>	struct kvm *kvm = vcpu->kvm;</blue>

<blue>	lockdep_assert_held(&kvm->arch.tsc_write_lock);</blue>

	/*
	 * We also track th most recent recorded KHZ, write and time to
	 * allow the matching interval to be extended at each write.
	 */
<blue>	kvm->arch.last_tsc_nsec = ns;</blue>
	kvm-&gt;arch.last_tsc_write = tsc;
	kvm-&gt;arch.last_tsc_khz = vcpu-&gt;arch.virtual_tsc_khz;
	kvm-&gt;arch.last_tsc_offset = offset;

	vcpu-&gt;arch.last_guest_tsc = tsc;

	kvm_vcpu_write_tsc_offset(vcpu, offset);

	if (!matched) {
		/*
		 * We split periods of matched TSC writes into generations.
		 * For each generation, we track the original measured
		 * nanosecond time, offset, and write, so if TSCs are in
		 * sync, we can match exact offset, and if not, we can match
		 * exact software computation in compute_guest_tsc()
		 *
		 * These values are tracked in kvm-&gt;arch.cur_xxx variables.
		 */
<blue>		kvm->arch.cur_tsc_generation++;</blue>
		kvm-&gt;arch.cur_tsc_nsec = ns;
		kvm-&gt;arch.cur_tsc_write = tsc;
		kvm-&gt;arch.cur_tsc_offset = offset;
		kvm-&gt;arch.nr_vcpus_matched_tsc = 0;
<blue>	} else if (vcpu->arch.this_tsc_generation != kvm->arch.cur_tsc_generation) {</blue>
<yellow>		kvm->arch.nr_vcpus_matched_tsc++;</yellow>
	}

	/* Keep track of which generation this VCPU has synchronized to */
<blue>	vcpu->arch.this_tsc_generation = kvm->arch.cur_tsc_generation;</blue>
	vcpu-&gt;arch.this_tsc_nsec = kvm-&gt;arch.cur_tsc_nsec;
	vcpu-&gt;arch.this_tsc_write = kvm-&gt;arch.cur_tsc_write;

<blue>	kvm_track_tsc_matching(vcpu);</blue>
<blue>}</blue>

static void kvm_synchronize_tsc(struct kvm_vcpu *vcpu, u64 data)
{
<blue>	struct kvm *kvm = vcpu->kvm;</blue>
	u64 offset, ns, elapsed;
	unsigned long flags;
	bool matched = false;
	bool synchronizing = false;

	raw_spin_lock_irqsave(&amp;kvm-&gt;arch.tsc_write_lock, flags);
	offset = kvm_compute_l1_tsc_offset(vcpu, data);
	ns = get_kvmclock_base_ns();
<blue>	elapsed = ns - kvm->arch.last_tsc_nsec;</blue>

	if (vcpu-&gt;arch.virtual_tsc_khz) {
		if (data == 0) {
			/*
			 * detection of vcpu initialization -- need to sync
			 * with other vCPUs. This particularly helps to keep
			 * kvm_clock stable after CPU hotplug
			 */
			synchronizing = true;
		} else {
<blue>			u64 tsc_exp = kvm->arch.last_tsc_write +</blue>
<blue>						nsec_to_cycles(vcpu, elapsed);</blue>
			u64 tsc_hz = vcpu-&gt;arch.virtual_tsc_khz * 1000LL;
			/*
			 * Special case: TSC write with a small delta (1 second)
			 * of virtual cycle time against real time is
			 * interpreted as an attempt to synchronize the CPU.
			 */
			synchronizing = data &lt; tsc_exp + tsc_hz &amp;&amp;
<blue>					data + tsc_hz > tsc_exp;</blue>
		}
	}

	/*
	 * For a reliable TSC, we can match TSC offsets, and for an unstable
	 * TSC, we add elapsed time in this computation.  We could let the
	 * compensation code attempt to catch up if we fall behind, but
	 * it&#x27;s better to try to match offsets from the beginning.
         */
	if (synchronizing &amp;&amp;
<blue>	    vcpu->arch.virtual_tsc_khz == kvm->arch.last_tsc_khz) {</blue>
<blue>		if (!kvm_check_tsc_unstable()) {</blue>
<blue>			offset = kvm->arch.cur_tsc_offset;</blue>
		} else {
<yellow>			u64 delta = nsec_to_cycles(vcpu, elapsed);</yellow>
			data += delta;
			offset = kvm_compute_l1_tsc_offset(vcpu, data);
		}
		matched = true;
	}

<blue>	__kvm_synchronize_tsc(vcpu, offset, data, ns, matched);</blue>
	raw_spin_unlock_irqrestore(&amp;kvm-&gt;arch.tsc_write_lock, flags);
}

static inline void adjust_tsc_offset_guest(struct kvm_vcpu *vcpu,
					   s64 adjustment)
{
<yellow>	u64 tsc_offset = vcpu->arch.l1_tsc_offset;</yellow>
	kvm_vcpu_write_tsc_offset(vcpu, tsc_offset + adjustment);
}

static inline void adjust_tsc_offset_host(struct kvm_vcpu *vcpu, s64 adjustment)
{
<yellow>	if (vcpu->arch.l1_tsc_scaling_ratio != kvm_caps.default_tsc_scaling_ratio)</yellow>
<yellow>		WARN_ON(adjustment < 0);</yellow>
<yellow>	adjustment = kvm_scale_tsc((u64) adjustment,</yellow>
				   vcpu-&gt;arch.l1_tsc_scaling_ratio);
<yellow>	adjust_tsc_offset_guest(vcpu, adjustment);</yellow>
}

#ifdef CONFIG_X86_64

static u64 read_tsc(void)
{
	u64 ret = (u64)rdtsc_ordered();
	u64 last = pvclock_gtod_data.clock.cycle_last;

	if (likely(ret &gt;= last))
		return ret;

	/*
	 * GCC likes to generate cmov here, but this branch is extremely
	 * predictable (it&#x27;s just a function of time and the likely is
	 * very likely) and there&#x27;s a data dependence, so force GCC
	 * to generate a branch instead.  I don&#x27;t barrier() because
	 * we don&#x27;t actually need a barrier, and if this function
	 * ever gets inlined it will generate worse code.
	 */
	asm volatile (&quot;&quot;);
<yellow>	return last;</yellow>
}

static inline u64 vgettsc(struct pvclock_clock *clock, u64 *tsc_timestamp,
			  int *mode)
{
	long v;
	u64 tsc_pg_val;

<blue>	switch (clock->vclock_mode) {</blue>
	case VDSO_CLOCKMODE_HVCLOCK:
<yellow>		tsc_pg_val = hv_read_tsc_page_tsc(hv_get_tsc_page(),</yellow>
						  tsc_timestamp);
		if (tsc_pg_val != U64_MAX) {
			/* TSC page valid */
<yellow>			*mode = VDSO_CLOCKMODE_HVCLOCK;</yellow>
			v = (tsc_pg_val - clock-&gt;cycle_last) &amp;
				clock-&gt;mask;
		} else {
			/* TSC page invalid */
<yellow>			*mode = VDSO_CLOCKMODE_NONE;</yellow>
		}
		break;
	case VDSO_CLOCKMODE_TSC:
<blue>		*mode = VDSO_CLOCKMODE_TSC;</blue>
<blue>		*tsc_timestamp = read_tsc();</blue>
		v = (*tsc_timestamp - clock-&gt;cycle_last) &amp;
			clock-&gt;mask;
		break;
	default:
<yellow>		*mode = VDSO_CLOCKMODE_NONE;</yellow>
	}

	if (*mode == VDSO_CLOCKMODE_NONE)
<yellow>		*tsc_timestamp = v = 0;</yellow>

<blue>	return v * clock->mult;</blue>
}

static int do_monotonic_raw(s64 *t, u64 *tsc_timestamp)
{
	struct pvclock_gtod_data *gtod = &amp;pvclock_gtod_data;
	unsigned long seq;
	int mode;
	u64 ns;

	do {
<blue>		seq = read_seqcount_begin(&gtod->seq);</blue>
		ns = gtod-&gt;raw_clock.base_cycles;
<blue>		ns += vgettsc(&gtod->raw_clock, tsc_timestamp, &mode);</blue>
<blue>		ns >>= gtod->raw_clock.shift;</blue>
<blue>		ns += ktime_to_ns(ktime_add(gtod->raw_clock.offset, gtod->offs_boot));</blue>
	} while (unlikely(read_seqcount_retry(&amp;gtod-&gt;seq, seq)));
	*t = ns;

	return mode;
}

static int do_realtime(struct timespec64 *ts, u64 *tsc_timestamp)
{
	struct pvclock_gtod_data *gtod = &amp;pvclock_gtod_data;
	unsigned long seq;
	int mode;
	u64 ns;

	do {
<yellow>		seq = read_seqcount_begin(&gtod->seq);</yellow>
<yellow>		ts->tv_sec = gtod->wall_time_sec;</yellow>
		ns = gtod-&gt;clock.base_cycles;
		ns += vgettsc(&amp;gtod-&gt;clock, tsc_timestamp, &amp;mode);
<yellow>		ns >>= gtod->clock.shift;</yellow>
<yellow>	} while (unlikely(read_seqcount_retry(&gtod->seq, seq)));</yellow>

<yellow>	ts->tv_sec += __iter_div_u64_rem(ns, NSEC_PER_SEC, &ns);</yellow>
	ts-&gt;tv_nsec = ns;

	return mode;
}

/* returns true if host is using TSC based clocksource */
static bool kvm_get_time_and_clockread(s64 *kernel_ns, u64 *tsc_timestamp)
{
	/* checked again under seqlock below */
	if (!gtod_is_based_on_tsc(pvclock_gtod_data.clock.vclock_mode))
		return false;

<blue>	return gtod_is_based_on_tsc(do_monotonic_raw(kernel_ns,</blue>
						      tsc_timestamp));
}

/* returns true if host is using TSC based clocksource */
<yellow>static bool kvm_get_walltime_and_clockread(struct timespec64 *ts,</yellow>
					   u64 *tsc_timestamp)
{
	/* checked again under seqlock below */
<yellow>	if (!gtod_is_based_on_tsc(pvclock_gtod_data.clock.vclock_mode))</yellow>
		return false;

<yellow>	return gtod_is_based_on_tsc(do_realtime(ts, tsc_timestamp));</yellow>
}
#endif

/*
 *
 * Assuming a stable TSC across physical CPUS, and a stable TSC
 * across virtual CPUs, the following condition is possible.
 * Each numbered line represents an event visible to both
 * CPUs at the next numbered event.
 *
 * &quot;timespecX&quot; represents host monotonic time. &quot;tscX&quot; represents
 * RDTSC value.
 *
 * 		VCPU0 on CPU0		|	VCPU1 on CPU1
 *
 * 1.  read timespec0,tsc0
 * 2.					| timespec1 = timespec0 + N
 * 					| tsc1 = tsc0 + M
 * 3. transition to guest		| transition to guest
 * 4. ret0 = timespec0 + (rdtsc - tsc0) |
 * 5.				        | ret1 = timespec1 + (rdtsc - tsc1)
 * 				        | ret1 = timespec0 + N + (rdtsc - (tsc0 + M))
 *
 * Since ret0 update is visible to VCPU1 at time 5, to obey monotonicity:
 *
 * 	- ret0 &lt; ret1
 *	- timespec0 + (rdtsc - tsc0) &lt; timespec0 + N + (rdtsc - (tsc0 + M))
 *		...
 *	- 0 &lt; N - M =&gt; M &lt; N
 *
 * That is, when timespec0 != timespec1, M &lt; N. Unfortunately that is not
 * always the case (the difference between two distinct xtime instances
 * might be smaller then the difference between corresponding TSC reads,
 * when updating guest vcpus pvclock areas).
 *
 * To avoid that problem, do not allow visibility of distinct
 * system_timestamp/tsc_timestamp values simultaneously: use a master
 * copy of host monotonic time values. Update that master copy
 * in lockstep.
 *
 * Rely on synchronization of host TSCs and guest TSCs for monotonicity.
 *
 */

static void pvclock_update_vm_gtod_copy(struct kvm *kvm)
<blue>{</blue>
#ifdef CONFIG_X86_64
	struct kvm_arch *ka = &amp;kvm-&gt;arch;
	int vclock_mode;
	bool host_tsc_clocksource, vcpus_matched;

<blue>	lockdep_assert_held(&kvm->arch.tsc_write_lock);</blue>
<blue>	vcpus_matched = (ka->nr_vcpus_matched_tsc + 1 ==</blue>
			atomic_read(&amp;kvm-&gt;online_vcpus));

	/*
	 * If the host uses TSC clock, then passthrough TSC as stable
	 * to the guest.
	 */
<blue>	host_tsc_clocksource = kvm_get_time_and_clockread(</blue>
					&amp;ka-&gt;master_kernel_ns,
					&amp;ka-&gt;master_cycle_now);

<blue>	ka->use_master_clock = host_tsc_clocksource && vcpus_matched</blue>
<blue>				&& !ka->backwards_tsc_observed</blue>
<blue>				&& !ka->boot_vcpu_runs_old_kvmclock;</blue>

	if (ka-&gt;use_master_clock)
<blue>		atomic_set(&kvm_guest_has_master_clock, 1);</blue>

<blue>	vclock_mode = pvclock_gtod_data.clock.vclock_mode;</blue>
<blue>	trace_kvm_update_master_clock(ka->use_master_clock, vclock_mode,</blue>
					vcpus_matched);
#endif
}

static void kvm_make_mclock_inprogress_request(struct kvm *kvm)
{
<yellow>	kvm_make_all_cpus_request(kvm, KVM_REQ_MCLOCK_INPROGRESS);</yellow>
}

static void __kvm_start_pvclock_update(struct kvm *kvm)
{
<blue>	raw_spin_lock_irq(&kvm->arch.tsc_write_lock);</blue>
<blue>	write_seqcount_begin(&kvm->arch.pvclock_sc);</blue>
}

static void kvm_start_pvclock_update(struct kvm *kvm)
{
	kvm_make_mclock_inprogress_request(kvm);

	/* no guest entries from this point */
	__kvm_start_pvclock_update(kvm);
}

static void kvm_end_pvclock_update(struct kvm *kvm)
<blue>{</blue>
	struct kvm_arch *ka = &amp;kvm-&gt;arch;
	struct kvm_vcpu *vcpu;
	unsigned long i;

<blue>	write_seqcount_end(&ka->pvclock_sc);</blue>
	raw_spin_unlock_irq(&amp;ka-&gt;tsc_write_lock);
	kvm_for_each_vcpu(i, vcpu, kvm)
<blue>		kvm_make_request(KVM_REQ_CLOCK_UPDATE, vcpu);</blue>

	/* guest entries allowed */
<blue>	kvm_for_each_vcpu(i, vcpu, kvm)</blue>
<blue>		kvm_clear_request(KVM_REQ_MCLOCK_INPROGRESS, vcpu);</blue>
}

static void kvm_update_masterclock(struct kvm *kvm)
{
	kvm_hv_request_tsc_page_update(kvm);
	kvm_start_pvclock_update(kvm);
	pvclock_update_vm_gtod_copy(kvm);
	kvm_end_pvclock_update(kvm);
}

/*
 * Use the kernel&#x27;s tsc_khz directly if the TSC is constant, otherwise use KVM&#x27;s
 * per-CPU value (which may be zero if a CPU is going offline).  Note, tsc_khz
 * can change during boot even if the TSC is constant, as it&#x27;s possible for KVM
 * to be loaded before TSC calibration completes.  Ideally, KVM would get a
 * notification when calibration completes, but practically speaking calibration
 * will complete before userspace is alive enough to create VMs.
 */
static unsigned long get_cpu_tsc_khz(void)
{
<blue>	if (static_cpu_has(X86_FEATURE_CONSTANT_TSC))</blue>
<blue>		return tsc_khz;</blue>
	else
<yellow>		return __this_cpu_read(cpu_tsc_khz);</yellow>
<blue>}</blue>

/* Called within read_seqcount_begin/retry for kvm-&gt;pvclock_sc.  */
static void __get_kvmclock(struct kvm *kvm, struct kvm_clock_data *data)
<yellow>{</yellow>
	struct kvm_arch *ka = &amp;kvm-&gt;arch;
	struct pvclock_vcpu_time_info hv_clock;

	/* both __this_cpu_read() and rdtsc() should be on the same cpu */
<yellow>	get_cpu();</yellow>

	data-&gt;flags = 0;
<yellow>	if (ka->use_master_clock &&</yellow>
<yellow>	    (static_cpu_has(X86_FEATURE_CONSTANT_TSC) || __this_cpu_read(cpu_tsc_khz))) {</yellow>
#ifdef CONFIG_X86_64
		struct timespec64 ts;

<yellow>		if (kvm_get_walltime_and_clockread(&ts, &data->host_tsc)) {</yellow>
<yellow>			data->realtime = ts.tv_nsec + NSEC_PER_SEC * ts.tv_sec;</yellow>
			data-&gt;flags |= KVM_CLOCK_REALTIME | KVM_CLOCK_HOST_TSC;
		} else
#endif
<yellow>		data->host_tsc = rdtsc();</yellow>

<yellow>		data->flags |= KVM_CLOCK_TSC_STABLE;</yellow>
		hv_clock.tsc_timestamp = ka-&gt;master_cycle_now;
		hv_clock.system_time = ka-&gt;master_kernel_ns + ka-&gt;kvmclock_offset;
<yellow>		kvm_get_time_scale(NSEC_PER_SEC, get_cpu_tsc_khz() * 1000LL,</yellow>
				   &amp;hv_clock.tsc_shift,
				   &amp;hv_clock.tsc_to_system_mul);
<yellow>		data->clock = __pvclock_read_cycles(&hv_clock, data->host_tsc);</yellow>
	} else {
<yellow>		data->clock = get_kvmclock_base_ns() + ka->kvmclock_offset;</yellow>
	}

<yellow>	put_cpu();</yellow>
}

static void get_kvmclock(struct kvm *kvm, struct kvm_clock_data *data)
{
	struct kvm_arch *ka = &amp;kvm-&gt;arch;
	unsigned seq;

	do {
<yellow>		seq = read_seqcount_begin(&ka->pvclock_sc);</yellow>
<yellow>		__get_kvmclock(kvm, data);</yellow>
	} while (read_seqcount_retry(&amp;ka-&gt;pvclock_sc, seq));
}

u64 get_kvmclock_ns(struct kvm *kvm)
{
	struct kvm_clock_data data;

<yellow>	get_kvmclock(kvm, &data);</yellow>
<yellow>	return data.clock;</yellow>
}

static void kvm_setup_guest_pvclock(struct kvm_vcpu *v,
				    struct gfn_to_pfn_cache *gpc,
				    unsigned int offset)
{
	struct kvm_vcpu_arch *vcpu = &amp;v-&gt;arch;
	struct pvclock_vcpu_time_info *guest_hv_clock;
	unsigned long flags;

<yellow>	read_lock_irqsave(&gpc->lock, flags);</yellow>
<yellow>	while (!kvm_gpc_check(gpc, offset + sizeof(*guest_hv_clock))) {</yellow>
<yellow>		read_unlock_irqrestore(&gpc->lock, flags);</yellow>

		if (kvm_gpc_refresh(gpc, offset + sizeof(*guest_hv_clock)))
			return;

<yellow>		read_lock_irqsave(&gpc->lock, flags);</yellow>
	}

<yellow>	guest_hv_clock = (void *)(gpc->khva + offset);</yellow>

	/*
	 * This VCPU is paused, but it&#x27;s legal for a guest to read another
	 * VCPU&#x27;s kvmclock, so we really have to follow the specification where
	 * it says that version is odd if data is being modified, and even after
	 * it is consistent.
	 */

	guest_hv_clock-&gt;version = vcpu-&gt;hv_clock.version = (guest_hv_clock-&gt;version + 1) | 1;
	smp_wmb();

	/* retain PVCLOCK_GUEST_STOPPED if set in guest copy */
	vcpu-&gt;hv_clock.flags |= (guest_hv_clock-&gt;flags &amp; PVCLOCK_GUEST_STOPPED);

<yellow>	if (vcpu->pvclock_set_guest_stopped_request) {</yellow>
<yellow>		vcpu->hv_clock.flags |= PVCLOCK_GUEST_STOPPED;</yellow>
		vcpu-&gt;pvclock_set_guest_stopped_request = false;
	}

<yellow>	memcpy(guest_hv_clock, &vcpu->hv_clock, sizeof(*guest_hv_clock));</yellow>
	smp_wmb();

	guest_hv_clock-&gt;version = ++vcpu-&gt;hv_clock.version;

	mark_page_dirty_in_slot(v-&gt;kvm, gpc-&gt;memslot, gpc-&gt;gpa &gt;&gt; PAGE_SHIFT);
	read_unlock_irqrestore(&amp;gpc-&gt;lock, flags);

<yellow>	trace_kvm_pvclock_update(v->vcpu_id, &vcpu->hv_clock);</yellow>
<yellow>}</yellow>

static int kvm_guest_time_update(struct kvm_vcpu *v)
{
	unsigned long flags, tgt_tsc_khz;
	unsigned seq;
	struct kvm_vcpu_arch *vcpu = &amp;v-&gt;arch;
<blue>	struct kvm_arch *ka = &v->kvm->arch;</blue>
	s64 kernel_ns;
	u64 tsc_timestamp, host_tsc;
	u8 pvclock_flags;
	bool use_master_clock;

	kernel_ns = 0;
	host_tsc = 0;

	/*
	 * If the host uses TSC clock, then passthrough TSC as stable
	 * to the guest.
	 */
	do {
<blue>		seq = read_seqcount_begin(&ka->pvclock_sc);</blue>
<blue>		use_master_clock = ka->use_master_clock;</blue>
		if (use_master_clock) {
<blue>			host_tsc = ka->master_cycle_now;</blue>
			kernel_ns = ka-&gt;master_kernel_ns;
		}
<blue>	} while (read_seqcount_retry(&ka->pvclock_sc, seq));</blue>

	/* Keep irq disabled to prevent changes to the clock */
<blue>	local_irq_save(flags);</blue>
<yellow>	tgt_tsc_khz = get_cpu_tsc_khz();</yellow>
	if (unlikely(tgt_tsc_khz == 0)) {
<yellow>		local_irq_restore(flags);</yellow>
<yellow>		kvm_make_request(KVM_REQ_CLOCK_UPDATE, v);</yellow>
		return 1;
	}
<blue>	if (!use_master_clock) {</blue>
<yellow>		host_tsc = rdtsc();</yellow>
		kernel_ns = get_kvmclock_base_ns();
	}

<blue>	tsc_timestamp = kvm_read_l1_tsc(v, host_tsc);</blue>

	/*
	 * We may have to catch up the TSC to match elapsed wall clock
	 * time for two reasons, even if kvmclock is used.
	 *   1) CPU could have been running below the maximum TSC rate
	 *   2) Broken TSC compensation resets the base at each VCPU
	 *      entry to avoid unknown leaps of TSC even when running
	 *      again on the same CPU.  This may cause apparent elapsed
	 *      time to disappear, and the guest to stand still or run
	 *	very slowly.
	 */
<blue>	if (vcpu->tsc_catchup) {</blue>
<yellow>		u64 tsc = compute_guest_tsc(v, kernel_ns);</yellow>
		if (tsc &gt; tsc_timestamp) {
<yellow>			adjust_tsc_offset_guest(v, tsc - tsc_timestamp);</yellow>
			tsc_timestamp = tsc;
		}
	}

<blue>	local_irq_restore(flags);</blue>

	/* With all the info we got, fill in the values */

<blue>	if (kvm_caps.has_tsc_control)</blue>
<blue>		tgt_tsc_khz = kvm_scale_tsc(tgt_tsc_khz,</blue>
					    v-&gt;arch.l1_tsc_scaling_ratio);

<blue>	if (unlikely(vcpu->hw_tsc_khz != tgt_tsc_khz)) {</blue>
<blue>		kvm_get_time_scale(NSEC_PER_SEC, tgt_tsc_khz * 1000LL,</blue>
				   &amp;vcpu-&gt;hv_clock.tsc_shift,
				   &amp;vcpu-&gt;hv_clock.tsc_to_system_mul);
		vcpu-&gt;hw_tsc_khz = tgt_tsc_khz;
	}

<blue>	vcpu->hv_clock.tsc_timestamp = tsc_timestamp;</blue>
	vcpu-&gt;hv_clock.system_time = kernel_ns + v-&gt;kvm-&gt;arch.kvmclock_offset;
	vcpu-&gt;last_guest_tsc = tsc_timestamp;

	/* If the host uses TSC clocksource, then it is stable */
	pvclock_flags = 0;
	if (use_master_clock)
		pvclock_flags |= PVCLOCK_TSC_STABLE_BIT;

	vcpu-&gt;hv_clock.flags = pvclock_flags;

<blue>	if (vcpu->pv_time.active)</blue>
<yellow>		kvm_setup_guest_pvclock(v, &vcpu->pv_time, 0);</yellow>
<blue>	if (vcpu->xen.vcpu_info_cache.active)</blue>
<yellow>		kvm_setup_guest_pvclock(v, &vcpu->xen.vcpu_info_cache,</yellow>
					offsetof(struct compat_vcpu_info, time));
<blue>	if (vcpu->xen.vcpu_time_info_cache.active)</blue>
<yellow>		kvm_setup_guest_pvclock(v, &vcpu->xen.vcpu_time_info_cache, 0);</yellow>
<blue>	kvm_hv_setup_tsc_page(v->kvm, &vcpu->hv_clock);</blue>
	return 0;
<blue>}</blue>

/*
 * kvmclock updates which are isolated to a given vcpu, such as
 * vcpu-&gt;cpu migration, should not allow system_timestamp from
 * the rest of the vcpus to remain static. Otherwise ntp frequency
 * correction applies to one vcpu&#x27;s system_timestamp but not
 * the others.
 *
 * So in those cases, request a kvmclock update for all vcpus.
 * We need to rate-limit these requests though, as they can
 * considerably slow guests that have a large number of vcpus.
 * The time for a remote vcpu to update its kvmclock is bound
 * by the delay we use to rate-limit the updates.
 */

#define KVMCLOCK_UPDATE_DELAY msecs_to_jiffies(100)

static void kvmclock_update_fn(struct work_struct *work)
<yellow>{</yellow>
	unsigned long i;
	struct delayed_work *dwork = to_delayed_work(work);
	struct kvm_arch *ka = container_of(dwork, struct kvm_arch,
					   kvmclock_update_work);
	struct kvm *kvm = container_of(ka, struct kvm, arch);
	struct kvm_vcpu *vcpu;

<yellow>	kvm_for_each_vcpu(i, vcpu, kvm) {</yellow>
<yellow>		kvm_make_request(KVM_REQ_CLOCK_UPDATE, vcpu);</yellow>
		kvm_vcpu_kick(vcpu);
	}
}

static void kvm_gen_kvmclock_update(struct kvm_vcpu *v)
{
	struct kvm *kvm = v-&gt;kvm;

	kvm_make_request(KVM_REQ_CLOCK_UPDATE, v);
	schedule_delayed_work(&amp;kvm-&gt;arch.kvmclock_update_work,
					KVMCLOCK_UPDATE_DELAY);
}

#define KVMCLOCK_SYNC_PERIOD (300 * HZ)

<yellow>static void kvmclock_sync_fn(struct work_struct *work)</yellow>
{
	struct delayed_work *dwork = to_delayed_work(work);
	struct kvm_arch *ka = container_of(dwork, struct kvm_arch,
					   kvmclock_sync_work);
	struct kvm *kvm = container_of(ka, struct kvm, arch);

<yellow>	if (!kvmclock_periodic_sync)</yellow>
		return;

<yellow>	schedule_delayed_work(&kvm->arch.kvmclock_update_work, 0);</yellow>
	schedule_delayed_work(&amp;kvm-&gt;arch.kvmclock_sync_work,
					KVMCLOCK_SYNC_PERIOD);
<yellow>}</yellow>

/* These helpers are safe iff @msr is known to be an MCx bank MSR. */
static bool is_mci_control_msr(u32 msr)
{
<blue>	return (msr & 3) == 0;</blue>
}
static bool is_mci_status_msr(u32 msr)
{
	return (msr &amp; 3) == 1;
}

/*
 * On AMD, HWCR[McStatusWrEn] controls whether setting MCi_STATUS results in #GP.
 */
static bool can_set_mci_status(struct kvm_vcpu *vcpu)
{
	/* McStatusWrEn enabled? */
<yellow>	if (guest_cpuid_is_amd_or_hygon(vcpu))</yellow>
<yellow>		return !!(vcpu->arch.msr_hwcr & BIT_ULL(18));</yellow>

	return false;
}

static int set_msr_mce(struct kvm_vcpu *vcpu, struct msr_data *msr_info)
{
<blue>	u64 mcg_cap = vcpu->arch.mcg_cap;</blue>
	unsigned bank_num = mcg_cap &amp; 0xff;
	u32 msr = msr_info-&gt;index;
	u64 data = msr_info-&gt;data;
	u32 offset, last_msr;

	switch (msr) {
	case MSR_IA32_MCG_STATUS:
<blue>		vcpu->arch.mcg_status = data;</blue>
		break;
	case MSR_IA32_MCG_CTL:
<blue>		if (!(mcg_cap & MCG_CTL_P) &&</blue>
<yellow>		    (data || !msr_info->host_initiated))</yellow>
			return 1;
<blue>		if (data != 0 && data != ~(u64)0)</blue>
			return 1;
<blue>		vcpu->arch.mcg_ctl = data;</blue>
		break;
	case MSR_IA32_MC0_CTL2 ... MSR_IA32_MCx_CTL2(KVM_MAX_MCE_BANKS) - 1:
<yellow>		last_msr = MSR_IA32_MCx_CTL2(bank_num) - 1;</yellow>
		if (msr &gt; last_msr)
			return 1;

<yellow>		if (!(mcg_cap & MCG_CMCI_P) && (data || !msr_info->host_initiated))</yellow>
			return 1;
		/* An attempt to write a 1 to a reserved bit raises #GP */
<yellow>		if (data & ~(MCI_CTL2_CMCI_EN | MCI_CTL2_CMCI_THRESHOLD_MASK))</yellow>
			return 1;
<yellow>		offset = array_index_nospec(msr - MSR_IA32_MC0_CTL2,</yellow>
					    last_msr + 1 - MSR_IA32_MC0_CTL2);
		vcpu-&gt;arch.mci_ctl2_banks[offset] = data;
		break;
	case MSR_IA32_MC0_CTL ... MSR_IA32_MCx_CTL(KVM_MAX_MCE_BANKS) - 1:
<blue>		last_msr = MSR_IA32_MCx_CTL(bank_num) - 1;</blue>
		if (msr &gt; last_msr)
			return 1;

		/*
		 * Only 0 or all 1s can be written to IA32_MCi_CTL, all other
		 * values are architecturally undefined.  But, some Linux
		 * kernels clear bit 10 in bank 4 to workaround a BIOS/GART TLB
		 * issue on AMD K8s, allow bit 10 to be clear when setting all
		 * other bits in order to avoid an uncaught #GP in the guest.
		 *
		 * UNIXWARE clears bit 0 of MC1_CTL to ignore correctable,
		 * single-bit ECC data errors.
		 */
<blue>		if (is_mci_control_msr(msr) &&</blue>
<blue>		    data != 0 && (data | (1 << 10) | 1) != ~(u64)0)</blue>
			return 1;

		/*
		 * All CPUs allow writing 0 to MCi_STATUS MSRs to clear the MSR.
		 * AMD-based CPUs allow non-zero values, but if and only if
		 * HWCR[McStatusWrEn] is set.
		 */
<blue>		if (!msr_info->host_initiated && is_mci_status_msr(msr) &&</blue>
<yellow>		    data != 0 && !can_set_mci_status(vcpu))</yellow>
			return 1;

<blue>		offset = array_index_nospec(msr - MSR_IA32_MC0_CTL,</blue>
					    last_msr + 1 - MSR_IA32_MC0_CTL);
		vcpu-&gt;arch.mce_banks[offset] = data;
		break;
	default:
		return 1;
	}
	return 0;
}

static inline bool kvm_pv_async_pf_enabled(struct kvm_vcpu *vcpu)
{
	u64 mask = KVM_ASYNC_PF_ENABLED | KVM_ASYNC_PF_DELIVERY_AS_INT;

<yellow>	return (vcpu->arch.apf.msr_en_val & mask) == mask;</yellow>
}

static int kvm_pv_enable_async_pf(struct kvm_vcpu *vcpu, u64 data)
{
	gpa_t gpa = data &amp; ~0x3f;

	/* Bits 4:5 are reserved, Should be zero */
<blue>	if (data & 0x30)</blue>
		return 1;

<blue>	if (!guest_pv_has(vcpu, KVM_FEATURE_ASYNC_PF_VMEXIT) &&</blue>
<yellow>	    (data & KVM_ASYNC_PF_DELIVERY_AS_PF_VMEXIT))</yellow>
		return 1;

<blue>	if (!guest_pv_has(vcpu, KVM_FEATURE_ASYNC_PF_INT) &&</blue>
<yellow>	    (data & KVM_ASYNC_PF_DELIVERY_AS_INT))</yellow>
		return 1;

<blue>	if (!lapic_in_kernel(vcpu))</blue>
		return data ? 1 : 0;

<blue>	vcpu->arch.apf.msr_en_val = data;</blue>

	if (!kvm_pv_async_pf_enabled(vcpu)) {
<blue>		kvm_clear_async_pf_completion_queue(vcpu);</blue>
<blue>		kvm_async_pf_hash_reset(vcpu);</blue>
		return 0;
	}

<yellow>	if (kvm_gfn_to_hva_cache_init(vcpu->kvm, &vcpu->arch.apf.data, gpa,</yellow>
					sizeof(u64)))
		return 1;

<yellow>	vcpu->arch.apf.send_user_only = !(data & KVM_ASYNC_PF_SEND_ALWAYS);</yellow>
	vcpu-&gt;arch.apf.delivery_as_pf_vmexit = data &amp; KVM_ASYNC_PF_DELIVERY_AS_PF_VMEXIT;

	kvm_async_pf_wakeup_all(vcpu);

	return 0;
}

static int kvm_pv_enable_async_pf_int(struct kvm_vcpu *vcpu, u64 data)
{
	/* Bits 8-63 are reserved */
<blue>	if (data >> 8)</blue>
		return 1;

<blue>	if (!lapic_in_kernel(vcpu))</blue>
		return 1;

<blue>	vcpu->arch.apf.msr_int_val = data;</blue>

	vcpu-&gt;arch.apf.vec = data &amp; KVM_ASYNC_PF_VEC_MASK;

	return 0;
}

static void kvmclock_reset(struct kvm_vcpu *vcpu)
{
<yellow>	kvm_gpc_deactivate(&vcpu->arch.pv_time);</yellow>
	vcpu-&gt;arch.time = 0;
}

static void kvm_vcpu_flush_tlb_all(struct kvm_vcpu *vcpu)
{
	++vcpu-&gt;stat.tlb_flush;
	static_call(kvm_x86_flush_tlb_all)(vcpu);

	/* Flushing all ASIDs flushes the current ASID... */
	kvm_clear_request(KVM_REQ_TLB_FLUSH_CURRENT, vcpu);
}

static void kvm_vcpu_flush_tlb_guest(struct kvm_vcpu *vcpu)
{
<blue>	++vcpu->stat.tlb_flush;</blue>

<blue>	if (!tdp_enabled) {</blue>
		/*
		 * A TLB flush on behalf of the guest is equivalent to
		 * INVPCID(all), toggling CR4.PGE, etc., which requires
		 * a forced sync of the shadow page tables.  Ensure all the
		 * roots are synced and the guest TLB in hardware is clean.
		 */
<blue>		kvm_mmu_sync_roots(vcpu);</blue>
		kvm_mmu_sync_prev_roots(vcpu);
	}

	static_call(kvm_x86_flush_tlb_guest)(vcpu);

	/*
	 * Flushing all &quot;guest&quot; TLB is always a superset of Hyper-V&#x27;s fine
	 * grained flushing.
	 */
<blue>	kvm_hv_vcpu_purge_flush_tlb(vcpu);</blue>
<blue>}</blue>


static inline void kvm_vcpu_flush_tlb_current(struct kvm_vcpu *vcpu)
{
	++vcpu-&gt;stat.tlb_flush;
	static_call(kvm_x86_flush_tlb_current)(vcpu);
}

/*
 * Service &quot;local&quot; TLB flush requests, which are specific to the current MMU
 * context.  In addition to the generic event handling in vcpu_enter_guest(),
 * TLB flushes that are targeted at an MMU context also need to be serviced
 * prior before nested VM-Enter/VM-Exit.
 */
void kvm_service_local_tlb_flush_requests(struct kvm_vcpu *vcpu)
{
<blue>	if (kvm_check_request(KVM_REQ_TLB_FLUSH_CURRENT, vcpu))</blue>
		kvm_vcpu_flush_tlb_current(vcpu);

<blue>	if (kvm_check_request(KVM_REQ_TLB_FLUSH_GUEST, vcpu))</blue>
		kvm_vcpu_flush_tlb_guest(vcpu);
<blue>}</blue>
EXPORT_SYMBOL_GPL(kvm_service_local_tlb_flush_requests);

static void record_steal_time(struct kvm_vcpu *vcpu)
{
	struct gfn_to_hva_cache *ghc = &amp;vcpu-&gt;arch.st.cache;
	struct kvm_steal_time __user *st;
	struct kvm_memslots *slots;
<blue>	gpa_t gpa = vcpu->arch.st.msr_val & KVM_STEAL_VALID_BITS;</blue>
	u64 steal;
	u32 version;

<yellow>	if (kvm_xen_msr_enabled(vcpu->kvm)) {</yellow>
<yellow>		kvm_xen_runstate_set_running(vcpu);</yellow>
		return;
	}

<blue>	if (!(vcpu->arch.st.msr_val & KVM_MSR_ENABLED))</blue>
		return;

<yellow>	if (WARN_ON_ONCE(current->mm != vcpu->kvm->mm))</yellow>
		return;

<yellow>	slots = kvm_memslots(vcpu->kvm);</yellow>

<yellow>	if (unlikely(slots->generation != ghc->generation ||</yellow>
		     gpa != ghc-&gt;gpa ||
		     kvm_is_error_hva(ghc-&gt;hva) || !ghc-&gt;memslot)) {
		/* We rely on the fact that it fits in a single page. */
		BUILD_BUG_ON((sizeof(*st) - 1) &amp; KVM_STEAL_VALID_BITS);

<yellow>		if (kvm_gfn_to_hva_cache_init(vcpu->kvm, ghc, gpa, sizeof(*st)) ||</yellow>
<yellow>		    kvm_is_error_hva(ghc->hva) || !ghc->memslot)</yellow>
			return;
	}

	st = (struct kvm_steal_time __user *)ghc-&gt;hva;
	/*
	 * Doing a TLB flush here, on the guest&#x27;s behalf, can avoid
	 * expensive IPIs.
	 */
<yellow>	if (guest_pv_has(vcpu, KVM_FEATURE_PV_TLB_FLUSH)) {</yellow>
		u8 st_preempted = 0;
		int err = -EFAULT;

<yellow>		if (!user_access_begin(st, sizeof(*st)))</yellow>
			return;

		asm volatile(&quot;1: xchgb %0, %2\n&quot;
			     &quot;xor %1, %1\n&quot;
			     &quot;2:\n&quot;
			     _ASM_EXTABLE_UA(1b, 2b)
			     : &quot;+q&quot; (st_preempted),
			       &quot;+&amp;r&quot; (err),
			       &quot;+m&quot; (st-&gt;preempted));
		if (err)
			goto out;

<yellow>		user_access_end();</yellow>

		vcpu-&gt;arch.st.preempted = 0;

<yellow>		trace_kvm_pv_tlb_flush(vcpu->vcpu_id,</yellow>
				       st_preempted &amp; KVM_VCPU_FLUSH_TLB);
<yellow>		if (st_preempted & KVM_VCPU_FLUSH_TLB)</yellow>
<yellow>			kvm_vcpu_flush_tlb_guest(vcpu);</yellow>

<yellow>		if (!user_access_begin(st, sizeof(*st)))</yellow>
			goto dirty;
	} else {
<yellow>		if (!user_access_begin(st, sizeof(*st)))</yellow>
			return;

		unsafe_put_user(0, &amp;st-&gt;preempted, out);
<yellow>		vcpu->arch.st.preempted = 0;</yellow>
	}

<yellow>	unsafe_get_user(version, &st->version, out);</yellow>
<yellow>	if (version & 1)</yellow>
<yellow>		version += 1;  /* first time write, random junk */</yellow>

<yellow>	version += 1;</yellow>
	unsafe_put_user(version, &amp;st-&gt;version, out);

	smp_wmb();

<yellow>	unsafe_get_user(steal, &st->steal, out);</yellow>
<yellow>	steal += current->sched_info.run_delay -</yellow>
		vcpu-&gt;arch.st.last_steal;
	vcpu-&gt;arch.st.last_steal = current-&gt;sched_info.run_delay;
	unsafe_put_user(steal, &amp;st-&gt;steal, out);

<yellow>	version += 1;</yellow>
	unsafe_put_user(version, &amp;st-&gt;version, out);

 out:
<yellow>	user_access_end();</yellow>
 dirty:
<yellow>	mark_page_dirty_in_slot(vcpu->kvm, ghc->memslot, gpa_to_gfn(ghc->gpa));</yellow>
<blue>}</blue>

int kvm_set_msr_common(struct kvm_vcpu *vcpu, struct msr_data *msr_info)
{
	bool pr = false;
<blue>	u32 msr = msr_info->index;</blue>
	u64 data = msr_info-&gt;data;

<blue>	if (msr && msr == vcpu->kvm->arch.xen_hvm_config.msr)</blue>
<yellow>		return kvm_xen_write_hypercall_page(vcpu, data);</yellow>

<blue>	switch (msr) {</blue>
	case MSR_AMD64_NB_CFG:
	case MSR_IA32_UCODE_WRITE:
	case MSR_VM_HSAVE_PA:
	case MSR_AMD64_PATCH_LOADER:
	case MSR_AMD64_BU_CFG2:
	case MSR_AMD64_DC_CFG:
	case MSR_F15H_EX_CFG:
		break;

	case MSR_IA32_UCODE_REV:
<blue>		if (msr_info->host_initiated)</blue>
<blue>			vcpu->arch.microcode_version = data;</blue>
		break;
	case MSR_IA32_ARCH_CAPABILITIES:
<blue>		if (!msr_info->host_initiated)</blue>
			return 1;
<blue>		vcpu->arch.arch_capabilities = data;</blue>
		break;
	case MSR_IA32_PERF_CAPABILITIES:
<yellow>		if (!msr_info->host_initiated)</yellow>
			return 1;
<yellow>		if (data & ~kvm_caps.supported_perf_cap)</yellow>
			return 1;

<yellow>		vcpu->arch.perf_capabilities = data;</yellow>
		kvm_pmu_refresh(vcpu);
		return 0;
	case MSR_EFER:
<blue>		return set_efer(vcpu, msr_info);</blue>
	case MSR_K7_HWCR:
		data &amp;= ~(u64)0x40;	/* ignore flush filter disable */
		data &amp;= ~(u64)0x100;	/* ignore ignne emulation enable */
<yellow>		data &= ~(u64)0x8;	/* ignore TLB cache disable */</yellow>

		/* Handle McStatusWrEn */
		if (data == BIT_ULL(18)) {
<yellow>			vcpu->arch.msr_hwcr = data;</yellow>
<yellow>		} else if (data != 0) {</yellow>
<yellow>			vcpu_unimpl(vcpu, "unimplemented HWCR wrmsr: 0x%llx\n",</yellow>
				    data);
			return 1;
		}
		break;
	case MSR_FAM10H_MMIO_CONF_BASE:
<yellow>		if (data != 0) {</yellow>
<yellow>			vcpu_unimpl(vcpu, "unimplemented MMIO_CONF_BASE wrmsr: "</yellow>
				    &quot;0x%llx\n&quot;, data);
			return 1;
		}
		break;
	case 0x200 ... MSR_IA32_MC0_CTL2 - 1:
	case MSR_IA32_MCx_CTL2(KVM_MAX_MCE_BANKS) ... 0x2ff:
<blue>		return kvm_mtrr_set_msr(vcpu, msr, data);</blue>
	case MSR_IA32_APICBASE:
<blue>		return kvm_set_apic_base(vcpu, msr_info);</blue>
	case APIC_BASE_MSR ... APIC_BASE_MSR + 0xff:
<yellow>		return kvm_x2apic_msr_write(vcpu, msr, data);</yellow>
	case MSR_IA32_TSC_DEADLINE:
<blue>		kvm_set_lapic_tscdeadline_msr(vcpu, data);</blue>
		break;
	case MSR_IA32_TSC_ADJUST:
<blue>		if (guest_cpuid_has(vcpu, X86_FEATURE_TSC_ADJUST)) {</blue>
<blue>			if (!msr_info->host_initiated) {</blue>
<yellow>				s64 adj = data - vcpu->arch.ia32_tsc_adjust_msr;</yellow>
				adjust_tsc_offset_guest(vcpu, adj);
				/* Before back to guest, tsc_timestamp must be adjusted
				 * as well, otherwise guest&#x27;s percpu pvclock time could jump.
				 */
				kvm_make_request(KVM_REQ_CLOCK_UPDATE, vcpu);
			}
<blue>			vcpu->arch.ia32_tsc_adjust_msr = data;</blue>
		}
		break;
	case MSR_IA32_MISC_ENABLE: {
<blue>		u64 old_val = vcpu->arch.ia32_misc_enable_msr;</blue>

<blue>		if (!msr_info->host_initiated) {</blue>
			/* RO bits */
<yellow>			if ((old_val ^ data) & MSR_IA32_MISC_ENABLE_PMU_RO_MASK)</yellow>
				return 1;

			/* R bits, i.e. writes are ignored, but don&#x27;t fault. */
			data = data &amp; ~MSR_IA32_MISC_ENABLE_EMON;
<yellow>			data |= old_val & MSR_IA32_MISC_ENABLE_EMON;</yellow>
		}

<blue>		if (!kvm_check_has_quirk(vcpu->kvm, KVM_X86_QUIRK_MISC_ENABLE_NO_MWAIT) &&</blue>
<yellow>		    ((old_val ^ data)  & MSR_IA32_MISC_ENABLE_MWAIT)) {</yellow>
<yellow>			if (!guest_cpuid_has(vcpu, X86_FEATURE_XMM3))</yellow>
				return 1;
<yellow>			vcpu->arch.ia32_misc_enable_msr = data;</yellow>
			kvm_update_cpuid_runtime(vcpu);
		} else {
<blue>			vcpu->arch.ia32_misc_enable_msr = data;</blue>
		}
		break;
	}
	case MSR_IA32_SMBASE:
<blue>		if (!IS_ENABLED(CONFIG_KVM_SMM) || !msr_info->host_initiated)</blue>
			return 1;
<blue>		vcpu->arch.smbase = data;</blue>
		break;
	case MSR_IA32_POWER_CTL:
<yellow>		vcpu->arch.msr_ia32_power_ctl = data;</yellow>
		break;
	case MSR_IA32_TSC:
<blue>		if (msr_info->host_initiated) {</blue>
<blue>			kvm_synchronize_tsc(vcpu, data);</blue>
		} else {
<blue>			u64 adj = kvm_compute_l1_tsc_offset(vcpu, data) - vcpu->arch.l1_tsc_offset;</blue>
			adjust_tsc_offset_guest(vcpu, adj);
			vcpu-&gt;arch.ia32_tsc_adjust_msr += adj;
		}
		break;
	case MSR_IA32_XSS:
<blue>		if (!msr_info->host_initiated &&</blue>
<yellow>		    !guest_cpuid_has(vcpu, X86_FEATURE_XSAVES))</yellow>
			return 1;
		/*
		 * KVM supports exposing PT to the guest, but does not support
		 * IA32_XSS[bit 8]. Guests have to use RDMSR/WRMSR rather than
		 * XSAVES/XRSTORS to save/restore PT MSRs.
		 */
<blue>		if (data & ~kvm_caps.supported_xss)</blue>
			return 1;
<blue>		vcpu->arch.ia32_xss = data;</blue>
		kvm_update_cpuid_runtime(vcpu);
		break;
	case MSR_SMI_COUNT:
<blue>		if (!msr_info->host_initiated)</blue>
			return 1;
<blue>		vcpu->arch.smi_count = data;</blue>
		break;
	case MSR_KVM_WALL_CLOCK_NEW:
<yellow>		if (!guest_pv_has(vcpu, KVM_FEATURE_CLOCKSOURCE2))</yellow>
			return 1;

<yellow>		vcpu->kvm->arch.wall_clock = data;</yellow>
		kvm_write_wall_clock(vcpu-&gt;kvm, data, 0);
		break;
	case MSR_KVM_WALL_CLOCK:
<blue>		if (!guest_pv_has(vcpu, KVM_FEATURE_CLOCKSOURCE))</blue>
			return 1;

<blue>		vcpu->kvm->arch.wall_clock = data;</blue>
		kvm_write_wall_clock(vcpu-&gt;kvm, data, 0);
		break;
	case MSR_KVM_SYSTEM_TIME_NEW:
<yellow>		if (!guest_pv_has(vcpu, KVM_FEATURE_CLOCKSOURCE2))</yellow>
			return 1;

<yellow>		kvm_write_system_time(vcpu, data, false, msr_info->host_initiated);</yellow>
		break;
	case MSR_KVM_SYSTEM_TIME:
<blue>		if (!guest_pv_has(vcpu, KVM_FEATURE_CLOCKSOURCE))</blue>
			return 1;

<blue>		kvm_write_system_time(vcpu, data, true,  msr_info->host_initiated);</blue>
		break;
	case MSR_KVM_ASYNC_PF_EN:
<blue>		if (!guest_pv_has(vcpu, KVM_FEATURE_ASYNC_PF))</blue>
			return 1;

<blue>		if (kvm_pv_enable_async_pf(vcpu, data))</blue>
			return 1;
		break;
	case MSR_KVM_ASYNC_PF_INT:
<blue>		if (!guest_pv_has(vcpu, KVM_FEATURE_ASYNC_PF_INT))</blue>
			return 1;

<blue>		if (kvm_pv_enable_async_pf_int(vcpu, data))</blue>
			return 1;
		break;
	case MSR_KVM_ASYNC_PF_ACK:
<yellow>		if (!guest_pv_has(vcpu, KVM_FEATURE_ASYNC_PF_INT))</yellow>
			return 1;
<yellow>		if (data & 0x1) {</yellow>
<yellow>			vcpu->arch.apf.pageready_pending = false;</yellow>
			kvm_check_async_pf_completion(vcpu);
		}
		break;
	case MSR_KVM_STEAL_TIME:
<blue>		if (!guest_pv_has(vcpu, KVM_FEATURE_STEAL_TIME))</blue>
			return 1;

		if (unlikely(!sched_info_on()))
			return 1;

<blue>		if (data & KVM_STEAL_RESERVED_MASK)</blue>
			return 1;

<blue>		vcpu->arch.st.msr_val = data;</blue>

		if (!(data &amp; KVM_MSR_ENABLED))
			break;

<yellow>		kvm_make_request(KVM_REQ_STEAL_UPDATE, vcpu);</yellow>

		break;
	case MSR_KVM_PV_EOI_EN:
<blue>		if (!guest_pv_has(vcpu, KVM_FEATURE_PV_EOI))</blue>
			return 1;

<blue>		if (kvm_lapic_set_pv_eoi(vcpu, data, sizeof(u8)))</blue>
			return 1;
		break;

	case MSR_KVM_POLL_CONTROL:
<blue>		if (!guest_pv_has(vcpu, KVM_FEATURE_POLL_CONTROL))</blue>
			return 1;

		/* only enable bit supported */
<blue>		if (data & (-1ULL << 1))</blue>
			return 1;

<blue>		vcpu->arch.msr_kvm_poll_control = data;</blue>
		break;

	case MSR_IA32_MCG_CTL:
	case MSR_IA32_MCG_STATUS:
	case MSR_IA32_MC0_CTL ... MSR_IA32_MCx_CTL(KVM_MAX_MCE_BANKS) - 1:
	case MSR_IA32_MC0_CTL2 ... MSR_IA32_MCx_CTL2(KVM_MAX_MCE_BANKS) - 1:
<blue>		return set_msr_mce(vcpu, msr_info);</blue>

	case MSR_K7_PERFCTR0 ... MSR_K7_PERFCTR3:
	case MSR_P6_PERFCTR0 ... MSR_P6_PERFCTR1:
		pr = true;
		fallthrough;
	case MSR_K7_EVNTSEL0 ... MSR_K7_EVNTSEL3:
	case MSR_P6_EVNTSEL0 ... MSR_P6_EVNTSEL1:
<yellow>		if (kvm_pmu_is_valid_msr(vcpu, msr))</yellow>
			return kvm_pmu_set_msr(vcpu, msr_info);

<yellow>		if (pr || data != 0)</yellow>
<yellow>			vcpu_unimpl(vcpu, "disabled perfctr wrmsr: "</yellow>
				    &quot;0x%x data 0x%llx\n&quot;, msr, data);
		break;
	case MSR_K7_CLK_CTL:
		/*
		 * Ignore all writes to this no longer documented MSR.
		 * Writes are only relevant for old K7 processors,
		 * all pre-dating SVM, but a recommended workaround from
		 * AMD for these chips. It is possible to specify the
		 * affected processor models on the command line, hence
		 * the need to ignore the workaround.
		 */
		break;
	case HV_X64_MSR_GUEST_OS_ID ... HV_X64_MSR_SINT15:
	case HV_X64_MSR_SYNDBG_CONTROL ... HV_X64_MSR_SYNDBG_PENDING_BUFFER:
	case HV_X64_MSR_SYNDBG_OPTIONS:
	case HV_X64_MSR_CRASH_P0 ... HV_X64_MSR_CRASH_P4:
	case HV_X64_MSR_CRASH_CTL:
	case HV_X64_MSR_STIMER0_CONFIG ... HV_X64_MSR_STIMER3_COUNT:
	case HV_X64_MSR_REENLIGHTENMENT_CONTROL:
	case HV_X64_MSR_TSC_EMULATION_CONTROL:
	case HV_X64_MSR_TSC_EMULATION_STATUS:
<blue>		return kvm_hv_set_msr_common(vcpu, msr, data,</blue>
<blue>					     msr_info->host_initiated);</blue>
	case MSR_IA32_BBL_CR_CTL3:
		/* Drop writes to this legacy MSR -- see rdmsr
		 * counterpart for further detail.
		 */
<yellow>		if (report_ignored_msrs)</yellow>
<yellow>			vcpu_unimpl(vcpu, "ignored wrmsr: 0x%x data 0x%llx\n",</yellow>
				msr, data);
		break;
	case MSR_AMD64_OSVW_ID_LENGTH:
<yellow>		if (!guest_cpuid_has(vcpu, X86_FEATURE_OSVW))</yellow>
			return 1;
<yellow>		vcpu->arch.osvw.length = data;</yellow>
		break;
	case MSR_AMD64_OSVW_STATUS:
<yellow>		if (!guest_cpuid_has(vcpu, X86_FEATURE_OSVW))</yellow>
			return 1;
<yellow>		vcpu->arch.osvw.status = data;</yellow>
		break;
	case MSR_PLATFORM_INFO:
<yellow>		if (!msr_info->host_initiated ||</yellow>
<yellow>		    (!(data & MSR_PLATFORM_INFO_CPUID_FAULT) &&</yellow>
<yellow>		     cpuid_fault_enabled(vcpu)))</yellow>
			return 1;
<yellow>		vcpu->arch.msr_platform_info = data;</yellow>
		break;
	case MSR_MISC_FEATURES_ENABLES:
<yellow>		if (data & ~MSR_MISC_FEATURES_ENABLES_CPUID_FAULT ||</yellow>
		    (data &amp; MSR_MISC_FEATURES_ENABLES_CPUID_FAULT &amp;&amp;
<yellow>		     !supports_cpuid_fault(vcpu)))</yellow>
			return 1;
<yellow>		vcpu->arch.msr_misc_features_enables = data;</yellow>
		break;
#ifdef CONFIG_X86_64
	case MSR_IA32_XFD:
<yellow>		if (!msr_info->host_initiated &&</yellow>
<yellow>		    !guest_cpuid_has(vcpu, X86_FEATURE_XFD))</yellow>
			return 1;

<yellow>		if (data & ~kvm_guest_supported_xfd(vcpu))</yellow>
			return 1;

<yellow>		fpu_update_guest_xfd(&vcpu->arch.guest_fpu, data);</yellow>
		break;
	case MSR_IA32_XFD_ERR:
<yellow>		if (!msr_info->host_initiated &&</yellow>
<yellow>		    !guest_cpuid_has(vcpu, X86_FEATURE_XFD))</yellow>
			return 1;

<yellow>		if (data & ~kvm_guest_supported_xfd(vcpu))</yellow>
			return 1;

<yellow>		vcpu->arch.guest_fpu.xfd_err = data;</yellow>
		break;
#endif
	case MSR_IA32_PEBS_ENABLE:
	case MSR_IA32_DS_AREA:
	case MSR_PEBS_DATA_CFG:
	case MSR_F15H_PERF_CTL0 ... MSR_F15H_PERF_CTR5:
<yellow>		if (kvm_pmu_is_valid_msr(vcpu, msr))</yellow>
			return kvm_pmu_set_msr(vcpu, msr_info);
		/*
		 * Userspace is allowed to write &#x27;0&#x27; to MSRs that KVM reports
		 * as to-be-saved, even if an MSRs isn&#x27;t fully supported.
		 */
<yellow>		return !msr_info->host_initiated || data;</yellow>
	default:
<blue>		if (kvm_pmu_is_valid_msr(vcpu, msr))</blue>
<yellow>			return kvm_pmu_set_msr(vcpu, msr_info);</yellow>
		return KVM_MSR_RET_INVALID;
	}
	return 0;
<blue>}</blue>
EXPORT_SYMBOL_GPL(kvm_set_msr_common);

static int get_msr_mce(struct kvm_vcpu *vcpu, u32 msr, u64 *pdata, bool host)
{
	u64 data;
<blue>	u64 mcg_cap = vcpu->arch.mcg_cap;</blue>
	unsigned bank_num = mcg_cap &amp; 0xff;
	u32 offset, last_msr;

	switch (msr) {
	case MSR_IA32_P5_MC_ADDR:
	case MSR_IA32_P5_MC_TYPE:
		data = 0;
		break;
	case MSR_IA32_MCG_CAP:
		data = vcpu-&gt;arch.mcg_cap;
		break;
	case MSR_IA32_MCG_CTL:
<blue>		if (!(mcg_cap & MCG_CTL_P) && !host)</blue>
			return 1;
<blue>		data = vcpu->arch.mcg_ctl;</blue>
		break;
	case MSR_IA32_MCG_STATUS:
<blue>		data = vcpu->arch.mcg_status;</blue>
		break;
	case MSR_IA32_MC0_CTL2 ... MSR_IA32_MCx_CTL2(KVM_MAX_MCE_BANKS) - 1:
<yellow>		last_msr = MSR_IA32_MCx_CTL2(bank_num) - 1;</yellow>
		if (msr &gt; last_msr)
			return 1;

<yellow>		if (!(mcg_cap & MCG_CMCI_P) && !host)</yellow>
			return 1;
<yellow>		offset = array_index_nospec(msr - MSR_IA32_MC0_CTL2,</yellow>
					    last_msr + 1 - MSR_IA32_MC0_CTL2);
		data = vcpu-&gt;arch.mci_ctl2_banks[offset];
		break;
	case MSR_IA32_MC0_CTL ... MSR_IA32_MCx_CTL(KVM_MAX_MCE_BANKS) - 1:
<blue>		last_msr = MSR_IA32_MCx_CTL(bank_num) - 1;</blue>
		if (msr &gt; last_msr)
			return 1;

<blue>		offset = array_index_nospec(msr - MSR_IA32_MC0_CTL,</blue>
					    last_msr + 1 - MSR_IA32_MC0_CTL);
		data = vcpu-&gt;arch.mce_banks[offset];
		break;
	default:
		return 1;
	}
<blue>	*pdata = data;</blue>
	return 0;
}

int kvm_get_msr_common(struct kvm_vcpu *vcpu, struct msr_data *msr_info)
{
<blue>	switch (msr_info->index) {</blue>
	case MSR_IA32_PLATFORM_ID:
	case MSR_IA32_EBL_CR_POWERON:
	case MSR_IA32_LASTBRANCHFROMIP:
	case MSR_IA32_LASTBRANCHTOIP:
	case MSR_IA32_LASTINTFROMIP:
	case MSR_IA32_LASTINTTOIP:
	case MSR_AMD64_SYSCFG:
	case MSR_K8_TSEG_ADDR:
	case MSR_K8_TSEG_MASK:
	case MSR_VM_HSAVE_PA:
	case MSR_K8_INT_PENDING_MSG:
	case MSR_AMD64_NB_CFG:
	case MSR_FAM10H_MMIO_CONF_BASE:
	case MSR_AMD64_BU_CFG2:
	case MSR_IA32_PERF_CTL:
	case MSR_AMD64_DC_CFG:
	case MSR_F15H_EX_CFG:
	/*
	 * Intel Sandy Bridge CPUs must support the RAPL (running average power
	 * limit) MSRs. Just return 0, as we do not want to expose the host
	 * data here. Do not conditionalize this on CPUID, as KVM does not do
	 * so for existing CPU-specific MSRs.
	 */
	case MSR_RAPL_POWER_UNIT:
	case MSR_PP0_ENERGY_STATUS:	/* Power plane 0 (core) */
	case MSR_PP1_ENERGY_STATUS:	/* Power plane 1 (graphics uncore) */
	case MSR_PKG_ENERGY_STATUS:	/* Total package */
	case MSR_DRAM_ENERGY_STATUS:	/* DRAM controller */
<yellow>		msr_info->data = 0;</yellow>
		break;
	case MSR_IA32_PEBS_ENABLE:
	case MSR_IA32_DS_AREA:
	case MSR_PEBS_DATA_CFG:
	case MSR_F15H_PERF_CTL0 ... MSR_F15H_PERF_CTR5:
<yellow>		if (kvm_pmu_is_valid_msr(vcpu, msr_info->index))</yellow>
			return kvm_pmu_get_msr(vcpu, msr_info);
		/*
		 * Userspace is allowed to read MSRs that KVM reports as
		 * to-be-saved, even if an MSR isn&#x27;t fully supported.
		 */
<yellow>		if (!msr_info->host_initiated)</yellow>
			return 1;
<yellow>		msr_info->data = 0;</yellow>
		break;
	case MSR_K7_EVNTSEL0 ... MSR_K7_EVNTSEL3:
	case MSR_K7_PERFCTR0 ... MSR_K7_PERFCTR3:
	case MSR_P6_PERFCTR0 ... MSR_P6_PERFCTR1:
	case MSR_P6_EVNTSEL0 ... MSR_P6_EVNTSEL1:
<yellow>		if (kvm_pmu_is_valid_msr(vcpu, msr_info->index))</yellow>
			return kvm_pmu_get_msr(vcpu, msr_info);
		msr_info-&gt;data = 0;
		break;
	case MSR_IA32_UCODE_REV:
<yellow>		msr_info->data = vcpu->arch.microcode_version;</yellow>
		break;
	case MSR_IA32_ARCH_CAPABILITIES:
<yellow>		if (!msr_info->host_initiated &&</yellow>
<yellow>		    !guest_cpuid_has(vcpu, X86_FEATURE_ARCH_CAPABILITIES))</yellow>
			return 1;
<yellow>		msr_info->data = vcpu->arch.arch_capabilities;</yellow>
		break;
	case MSR_IA32_PERF_CAPABILITIES:
<yellow>		if (!msr_info->host_initiated &&</yellow>
<yellow>		    !guest_cpuid_has(vcpu, X86_FEATURE_PDCM))</yellow>
			return 1;
<yellow>		msr_info->data = vcpu->arch.perf_capabilities;</yellow>
		break;
	case MSR_IA32_POWER_CTL:
<yellow>		msr_info->data = vcpu->arch.msr_ia32_power_ctl;</yellow>
		break;
	case MSR_IA32_TSC: {
		/*
		 * Intel SDM states that MSR_IA32_TSC read adds the TSC offset
		 * even when not intercepted. AMD manual doesn&#x27;t explicitly
		 * state this but appears to behave the same.
		 *
		 * On userspace reads and writes, however, we unconditionally
		 * return L1&#x27;s TSC value to ensure backwards-compatible
		 * behavior for migration.
		 */
		u64 offset, ratio;

<blue>		if (msr_info->host_initiated) {</blue>
<blue>			offset = vcpu->arch.l1_tsc_offset;</blue>
			ratio = vcpu-&gt;arch.l1_tsc_scaling_ratio;
		} else {
			offset = vcpu-&gt;arch.tsc_offset;
			ratio = vcpu-&gt;arch.tsc_scaling_ratio;
		}

<blue>		msr_info->data = kvm_scale_tsc(rdtsc(), ratio) + offset;</blue>
		break;
	}
	case MSR_MTRRcap:
	case 0x200 ... MSR_IA32_MC0_CTL2 - 1:
	case MSR_IA32_MCx_CTL2(KVM_MAX_MCE_BANKS) ... 0x2ff:
<blue>		return kvm_mtrr_get_msr(vcpu, msr_info->index, &msr_info->data);</blue>
	case 0xcd: /* fsb frequency */
<yellow>		msr_info->data = 3;</yellow>
		break;
		/*
		 * MSR_EBC_FREQUENCY_ID
		 * Conservative value valid for even the basic CPU models.
		 * Models 0,1: 000 in bits 23:21 indicating a bus speed of
		 * 100MHz, model 2 000 in bits 18:16 indicating 100MHz,
		 * and 266MHz for model 3, or 4. Set Core Clock
		 * Frequency to System Bus Frequency Ratio to 1 (bits
		 * 31:24) even though these are only valid for CPU
		 * models &gt; 2, however guests may end up dividing or
		 * multiplying by zero otherwise.
		 */
	case MSR_EBC_FREQUENCY_ID:
<yellow>		msr_info->data = 1 << 24;</yellow>
		break;
	case MSR_IA32_APICBASE:
<blue>		msr_info->data = kvm_get_apic_base(vcpu);</blue>
		break;
	case APIC_BASE_MSR ... APIC_BASE_MSR + 0xff:
<yellow>		return kvm_x2apic_msr_read(vcpu, msr_info->index, &msr_info->data);</yellow>
	case MSR_IA32_TSC_DEADLINE:
<blue>		msr_info->data = kvm_get_lapic_tscdeadline_msr(vcpu);</blue>
		break;
	case MSR_IA32_TSC_ADJUST:
<blue>		msr_info->data = (u64)vcpu->arch.ia32_tsc_adjust_msr;</blue>
		break;
	case MSR_IA32_MISC_ENABLE:
<blue>		msr_info->data = vcpu->arch.ia32_misc_enable_msr;</blue>
		break;
	case MSR_IA32_SMBASE:
<blue>		if (!IS_ENABLED(CONFIG_KVM_SMM) || !msr_info->host_initiated)</blue>
			return 1;
<blue>		msr_info->data = vcpu->arch.smbase;</blue>
		break;
	case MSR_SMI_COUNT:
<blue>		msr_info->data = vcpu->arch.smi_count;</blue>
		break;
	case MSR_IA32_PERF_STATUS:
		/* TSC increment by tick */
		msr_info-&gt;data = 1000ULL;
		/* CPU multiplier */
<yellow>		msr_info->data |= (((uint64_t)4ULL) << 40);</yellow>
		break;
	case MSR_EFER:
<blue>		msr_info->data = vcpu->arch.efer;</blue>
		break;
	case MSR_KVM_WALL_CLOCK:
<blue>		if (!guest_pv_has(vcpu, KVM_FEATURE_CLOCKSOURCE))</blue>
			return 1;

<blue>		msr_info->data = vcpu->kvm->arch.wall_clock;</blue>
		break;
	case MSR_KVM_WALL_CLOCK_NEW:
<yellow>		if (!guest_pv_has(vcpu, KVM_FEATURE_CLOCKSOURCE2))</yellow>
			return 1;

<yellow>		msr_info->data = vcpu->kvm->arch.wall_clock;</yellow>
		break;
	case MSR_KVM_SYSTEM_TIME:
<blue>		if (!guest_pv_has(vcpu, KVM_FEATURE_CLOCKSOURCE))</blue>
			return 1;

<blue>		msr_info->data = vcpu->arch.time;</blue>
		break;
	case MSR_KVM_SYSTEM_TIME_NEW:
<yellow>		if (!guest_pv_has(vcpu, KVM_FEATURE_CLOCKSOURCE2))</yellow>
			return 1;

<yellow>		msr_info->data = vcpu->arch.time;</yellow>
		break;
	case MSR_KVM_ASYNC_PF_EN:
<blue>		if (!guest_pv_has(vcpu, KVM_FEATURE_ASYNC_PF))</blue>
			return 1;

<blue>		msr_info->data = vcpu->arch.apf.msr_en_val;</blue>
		break;
	case MSR_KVM_ASYNC_PF_INT:
<blue>		if (!guest_pv_has(vcpu, KVM_FEATURE_ASYNC_PF_INT))</blue>
			return 1;

<blue>		msr_info->data = vcpu->arch.apf.msr_int_val;</blue>
		break;
	case MSR_KVM_ASYNC_PF_ACK:
<yellow>		if (!guest_pv_has(vcpu, KVM_FEATURE_ASYNC_PF_INT))</yellow>
			return 1;

		msr_info-&gt;data = 0;
		break;
	case MSR_KVM_STEAL_TIME:
<blue>		if (!guest_pv_has(vcpu, KVM_FEATURE_STEAL_TIME))</blue>
			return 1;

<blue>		msr_info->data = vcpu->arch.st.msr_val;</blue>
		break;
	case MSR_KVM_PV_EOI_EN:
<blue>		if (!guest_pv_has(vcpu, KVM_FEATURE_PV_EOI))</blue>
			return 1;

<blue>		msr_info->data = vcpu->arch.pv_eoi.msr_val;</blue>
		break;
	case MSR_KVM_POLL_CONTROL:
<blue>		if (!guest_pv_has(vcpu, KVM_FEATURE_POLL_CONTROL))</blue>
			return 1;

<blue>		msr_info->data = vcpu->arch.msr_kvm_poll_control;</blue>
		break;
	case MSR_IA32_P5_MC_ADDR:
	case MSR_IA32_P5_MC_TYPE:
	case MSR_IA32_MCG_CAP:
	case MSR_IA32_MCG_CTL:
	case MSR_IA32_MCG_STATUS:
	case MSR_IA32_MC0_CTL ... MSR_IA32_MCx_CTL(KVM_MAX_MCE_BANKS) - 1:
	case MSR_IA32_MC0_CTL2 ... MSR_IA32_MCx_CTL2(KVM_MAX_MCE_BANKS) - 1:
<blue>		return get_msr_mce(vcpu, msr_info->index, &msr_info->data,</blue>
<blue>				   msr_info->host_initiated);</blue>
	case MSR_IA32_XSS:
<yellow>		if (!msr_info->host_initiated &&</yellow>
<yellow>		    !guest_cpuid_has(vcpu, X86_FEATURE_XSAVES))</yellow>
			return 1;
<yellow>		msr_info->data = vcpu->arch.ia32_xss;</yellow>
		break;
	case MSR_K7_CLK_CTL:
		/*
		 * Provide expected ramp-up count for K7. All other
		 * are set to zero, indicating minimum divisors for
		 * every field.
		 *
		 * This prevents guest kernels on AMD host with CPU
		 * type 6, model 8 and higher from exploding due to
		 * the rdmsr failing.
		 */
<yellow>		msr_info->data = 0x20000000;</yellow>
		break;
	case HV_X64_MSR_GUEST_OS_ID ... HV_X64_MSR_SINT15:
	case HV_X64_MSR_SYNDBG_CONTROL ... HV_X64_MSR_SYNDBG_PENDING_BUFFER:
	case HV_X64_MSR_SYNDBG_OPTIONS:
	case HV_X64_MSR_CRASH_P0 ... HV_X64_MSR_CRASH_P4:
	case HV_X64_MSR_CRASH_CTL:
	case HV_X64_MSR_STIMER0_CONFIG ... HV_X64_MSR_STIMER3_COUNT:
	case HV_X64_MSR_REENLIGHTENMENT_CONTROL:
	case HV_X64_MSR_TSC_EMULATION_CONTROL:
	case HV_X64_MSR_TSC_EMULATION_STATUS:
<blue>		return kvm_hv_get_msr_common(vcpu,</blue>
					     msr_info-&gt;index, &amp;msr_info-&gt;data,
<blue>					     msr_info->host_initiated);</blue>
	case MSR_IA32_BBL_CR_CTL3:
		/* This legacy MSR exists but isn&#x27;t fully documented in current
		 * silicon.  It is however accessed by winxp in very narrow
		 * scenarios where it sets bit #19, itself documented as
		 * a &quot;reserved&quot; bit.  Best effort attempt to source coherent
		 * read data here should the balance of the register be
		 * interpreted by the guest:
		 *
		 * L2 cache control register 3: 64GB range, 256KB size,
		 * enabled, latency 0x1, configured
		 */
<yellow>		msr_info->data = 0xbe702111;</yellow>
		break;
	case MSR_AMD64_OSVW_ID_LENGTH:
<yellow>		if (!guest_cpuid_has(vcpu, X86_FEATURE_OSVW))</yellow>
			return 1;
<yellow>		msr_info->data = vcpu->arch.osvw.length;</yellow>
		break;
	case MSR_AMD64_OSVW_STATUS:
<yellow>		if (!guest_cpuid_has(vcpu, X86_FEATURE_OSVW))</yellow>
			return 1;
<yellow>		msr_info->data = vcpu->arch.osvw.status;</yellow>
		break;
	case MSR_PLATFORM_INFO:
<yellow>		if (!msr_info->host_initiated &&</yellow>
<yellow>		    !vcpu->kvm->arch.guest_can_read_msr_platform_info)</yellow>
			return 1;
<yellow>		msr_info->data = vcpu->arch.msr_platform_info;</yellow>
		break;
	case MSR_MISC_FEATURES_ENABLES:
<yellow>		msr_info->data = vcpu->arch.msr_misc_features_enables;</yellow>
		break;
	case MSR_K7_HWCR:
<yellow>		msr_info->data = vcpu->arch.msr_hwcr;</yellow>
		break;
#ifdef CONFIG_X86_64
	case MSR_IA32_XFD:
<yellow>		if (!msr_info->host_initiated &&</yellow>
<yellow>		    !guest_cpuid_has(vcpu, X86_FEATURE_XFD))</yellow>
			return 1;

<yellow>		msr_info->data = vcpu->arch.guest_fpu.fpstate->xfd;</yellow>
		break;
	case MSR_IA32_XFD_ERR:
<yellow>		if (!msr_info->host_initiated &&</yellow>
<yellow>		    !guest_cpuid_has(vcpu, X86_FEATURE_XFD))</yellow>
			return 1;

<yellow>		msr_info->data = vcpu->arch.guest_fpu.xfd_err;</yellow>
		break;
#endif
	default:
<blue>		if (kvm_pmu_is_valid_msr(vcpu, msr_info->index))</blue>
<yellow>			return kvm_pmu_get_msr(vcpu, msr_info);</yellow>
		return KVM_MSR_RET_INVALID;
	}
	return 0;
<blue>}</blue>
EXPORT_SYMBOL_GPL(kvm_get_msr_common);

/*
 * Read or write a bunch of msrs. All parameters are kernel addresses.
 *
 * @return number of msrs set successfully.
 */
static int __msr_io(struct kvm_vcpu *vcpu, struct kvm_msrs *msrs,
		    struct kvm_msr_entry *entries,
		    int (*do_msr)(struct kvm_vcpu *vcpu,
				  unsigned index, u64 *data))
{
	int i;

<blue>	for (i = 0; i < msrs->nmsrs; ++i)</blue>
<blue>		if (do_msr(vcpu, entries[i].index, &entries[i].data))</blue>
			break;

	return i;
}

/*
 * Read or write a bunch of msrs. Parameters are user addresses.
 *
 * @return number of msrs set successfully.
 */
static int msr_io(struct kvm_vcpu *vcpu, struct kvm_msrs __user *user_msrs,
		  int (*do_msr)(struct kvm_vcpu *vcpu,
				unsigned index, u64 *data),
		  int writeback)
<blue>{</blue>
	struct kvm_msrs msrs;
	struct kvm_msr_entry *entries;
	int r, n;
	unsigned size;

	r = -EFAULT;
<blue>	if (copy_from_user(&msrs, user_msrs, sizeof(msrs)))</blue>
		goto out;

	r = -E2BIG;
<blue>	if (msrs.nmsrs >= MAX_IO_MSRS)</blue>
		goto out;

<blue>	size = sizeof(struct kvm_msr_entry) * msrs.nmsrs;</blue>
	entries = memdup_user(user_msrs-&gt;entries, size);
	if (IS_ERR(entries)) {
<yellow>		r = PTR_ERR(entries);</yellow>
		goto out;
	}

<blue>	r = n = __msr_io(vcpu, &msrs, entries, do_msr);</blue>
<blue>	if (r < 0)</blue>
		goto out_free;

	r = -EFAULT;
<blue>	if (writeback && copy_to_user(user_msrs->entries, entries, size))</blue>
		goto out_free;

	r = n;

out_free:
<blue>	kfree(entries);</blue>
out:
	return r;
}

static inline bool kvm_can_mwait_in_guest(void)
{
<yellow>	return boot_cpu_has(X86_FEATURE_MWAIT) &&</yellow>
<yellow>		!boot_cpu_has_bug(X86_BUG_MONITOR) &&</yellow>
<yellow>		boot_cpu_has(X86_FEATURE_ARAT);</yellow>
}

static int kvm_ioctl_get_supported_hv_cpuid(struct kvm_vcpu *vcpu,
					    struct kvm_cpuid2 __user *cpuid_arg)
<blue>{</blue>
	struct kvm_cpuid2 cpuid;
	int r;

	r = -EFAULT;
<blue>	if (copy_from_user(&cpuid, cpuid_arg, sizeof(cpuid)))</blue>
		return r;

<blue>	r = kvm_get_hv_cpuid(vcpu, &cpuid, cpuid_arg->entries);</blue>
	if (r)
		return r;

	r = -EFAULT;
<blue>	if (copy_to_user(cpuid_arg, &cpuid, sizeof(cpuid)))</blue>
		return r;

	return 0;
}

int kvm_vm_ioctl_check_extension(struct kvm *kvm, long ext)
{
<yellow>	int r = 0;</yellow>

<blue>	switch (ext) {</blue>
	case KVM_CAP_IRQCHIP:
	case KVM_CAP_HLT:
	case KVM_CAP_MMU_SHADOW_CACHE_CONTROL:
	case KVM_CAP_SET_TSS_ADDR:
	case KVM_CAP_EXT_CPUID:
	case KVM_CAP_EXT_EMUL_CPUID:
	case KVM_CAP_CLOCKSOURCE:
	case KVM_CAP_PIT:
	case KVM_CAP_NOP_IO_DELAY:
	case KVM_CAP_MP_STATE:
	case KVM_CAP_SYNC_MMU:
	case KVM_CAP_USER_NMI:
	case KVM_CAP_REINJECT_CONTROL:
	case KVM_CAP_IRQ_INJECT_STATUS:
	case KVM_CAP_IOEVENTFD:
	case KVM_CAP_IOEVENTFD_NO_LENGTH:
	case KVM_CAP_PIT2:
	case KVM_CAP_PIT_STATE2:
	case KVM_CAP_SET_IDENTITY_MAP_ADDR:
	case KVM_CAP_VCPU_EVENTS:
	case KVM_CAP_HYPERV:
	case KVM_CAP_HYPERV_VAPIC:
	case KVM_CAP_HYPERV_SPIN:
	case KVM_CAP_HYPERV_SYNIC:
	case KVM_CAP_HYPERV_SYNIC2:
	case KVM_CAP_HYPERV_VP_INDEX:
	case KVM_CAP_HYPERV_EVENTFD:
	case KVM_CAP_HYPERV_TLBFLUSH:
	case KVM_CAP_HYPERV_SEND_IPI:
	case KVM_CAP_HYPERV_CPUID:
	case KVM_CAP_HYPERV_ENFORCE_CPUID:
	case KVM_CAP_SYS_HYPERV_CPUID:
	case KVM_CAP_PCI_SEGMENT:
	case KVM_CAP_DEBUGREGS:
	case KVM_CAP_X86_ROBUST_SINGLESTEP:
	case KVM_CAP_XSAVE:
	case KVM_CAP_ASYNC_PF:
	case KVM_CAP_ASYNC_PF_INT:
	case KVM_CAP_GET_TSC_KHZ:
	case KVM_CAP_KVMCLOCK_CTRL:
	case KVM_CAP_READONLY_MEM:
	case KVM_CAP_HYPERV_TIME:
	case KVM_CAP_IOAPIC_POLARITY_IGNORED:
	case KVM_CAP_TSC_DEADLINE_TIMER:
	case KVM_CAP_DISABLE_QUIRKS:
	case KVM_CAP_SET_BOOT_CPU_ID:
 	case KVM_CAP_SPLIT_IRQCHIP:
	case KVM_CAP_IMMEDIATE_EXIT:
	case KVM_CAP_PMU_EVENT_FILTER:
	case KVM_CAP_GET_MSR_FEATURES:
	case KVM_CAP_MSR_PLATFORM_INFO:
	case KVM_CAP_EXCEPTION_PAYLOAD:
	case KVM_CAP_X86_TRIPLE_FAULT_EVENT:
	case KVM_CAP_SET_GUEST_DEBUG:
	case KVM_CAP_LAST_CPU:
	case KVM_CAP_X86_USER_SPACE_MSR:
	case KVM_CAP_X86_MSR_FILTER:
	case KVM_CAP_ENFORCE_PV_FEATURE_CPUID:
#ifdef CONFIG_X86_SGX_KVM
	case KVM_CAP_SGX_ATTRIBUTE:
#endif
	case KVM_CAP_VM_COPY_ENC_CONTEXT_FROM:
	case KVM_CAP_VM_MOVE_ENC_CONTEXT_FROM:
	case KVM_CAP_SREGS2:
	case KVM_CAP_EXIT_ON_EMULATION_FAILURE:
	case KVM_CAP_VCPU_ATTRIBUTES:
	case KVM_CAP_SYS_ATTRIBUTES:
	case KVM_CAP_VAPIC:
	case KVM_CAP_ENABLE_CAP:
	case KVM_CAP_VM_DISABLE_NX_HUGE_PAGES:
		r = 1;
		break;
	case KVM_CAP_EXIT_HYPERCALL:
		r = KVM_EXIT_HYPERCALL_VALID_MASK;
		break;
	case KVM_CAP_SET_GUEST_DEBUG2:
		return KVM_GUESTDBG_VALID_MASK;
#ifdef CONFIG_KVM_XEN
	case KVM_CAP_XEN_HVM:
		r = KVM_XEN_HVM_CONFIG_HYPERCALL_MSR |
		    KVM_XEN_HVM_CONFIG_INTERCEPT_HCALL |
		    KVM_XEN_HVM_CONFIG_SHARED_INFO |
		    KVM_XEN_HVM_CONFIG_EVTCHN_2LEVEL |
		    KVM_XEN_HVM_CONFIG_EVTCHN_SEND;
		if (sched_info_on())
			r |= KVM_XEN_HVM_CONFIG_RUNSTATE |
			     KVM_XEN_HVM_CONFIG_RUNSTATE_UPDATE_FLAG;
		break;
#endif
	case KVM_CAP_SYNC_REGS:
		r = KVM_SYNC_X86_VALID_FIELDS;
		break;
	case KVM_CAP_ADJUST_CLOCK:
		r = KVM_CLOCK_VALID_FLAGS;
		break;
	case KVM_CAP_X86_DISABLE_EXITS:
		r = KVM_X86_DISABLE_EXITS_PAUSE;

<yellow>		if (!mitigate_smt_rsb) {</yellow>
			r |= KVM_X86_DISABLE_EXITS_HLT |
			     KVM_X86_DISABLE_EXITS_CSTATE;

<yellow>			if (kvm_can_mwait_in_guest())</yellow>
				r |= KVM_X86_DISABLE_EXITS_MWAIT;
		}
		break;
	case KVM_CAP_X86_SMM:
		if (!IS_ENABLED(CONFIG_KVM_SMM))
			break;

		/* SMBASE is usually relocated above 1M on modern chipsets,
		 * and SMM handlers might indeed rely on 4G segment limits,
		 * so do not report SMM to be available if real mode is
		 * emulated via vm86 mode.  Still, do not go to great lengths
		 * to avoid userspace&#x27;s usage of the feature, because it is a
		 * fringe case that is not enabled except via specific settings
		 * of the module parameters.
		 */
<blue>		r = static_call(kvm_x86_has_emulated_msr)(kvm, MSR_IA32_SMBASE);</blue>
		break;
	case KVM_CAP_NR_VCPUS:
<blue>		r = min_t(unsigned int, num_online_cpus(), KVM_MAX_VCPUS);</blue>
		break;
	case KVM_CAP_MAX_VCPUS:
		r = KVM_MAX_VCPUS;
		break;
	case KVM_CAP_MAX_VCPU_ID:
		r = KVM_MAX_VCPU_IDS;
		break;
	case KVM_CAP_PV_MMU:	/* obsolete */
		r = 0;
		break;
	case KVM_CAP_MCE:
		r = KVM_MAX_MCE_BANKS;
		break;
	case KVM_CAP_XCRS:
<blue>		r = boot_cpu_has(X86_FEATURE_XSAVE);</blue>
		break;
	case KVM_CAP_TSC_CONTROL:
	case KVM_CAP_VM_TSC_CONTROL:
<blue>		r = kvm_caps.has_tsc_control;</blue>
		break;
	case KVM_CAP_X2APIC_API:
		r = KVM_X2APIC_API_VALID_FLAGS;
		break;
	case KVM_CAP_NESTED_STATE:
<blue>		r = kvm_x86_ops.nested_ops->get_state ?</blue>
<blue>			kvm_x86_ops.nested_ops->get_state(NULL, NULL, 0) : 0;</blue>
		break;
	case KVM_CAP_HYPERV_DIRECT_TLBFLUSH:
<yellow>		r = kvm_x86_ops.enable_l2_tlb_flush != NULL;</yellow>
		break;
	case KVM_CAP_HYPERV_ENLIGHTENED_VMCS:
<yellow>		r = kvm_x86_ops.nested_ops->enable_evmcs != NULL;</yellow>
		break;
	case KVM_CAP_SMALLER_MAXPHYADDR:
<yellow>		r = (int) allow_smaller_maxphyaddr;</yellow>
		break;
	case KVM_CAP_STEAL_TIME:
		r = sched_info_on();
		break;
	case KVM_CAP_X86_BUS_LOCK_EXIT:
<yellow>		if (kvm_caps.has_bus_lock_exit)</yellow>
			r = KVM_BUS_LOCK_DETECTION_OFF |
			    KVM_BUS_LOCK_DETECTION_EXIT;
		else
			r = 0;
		break;
	case KVM_CAP_XSAVE2: {
		u64 guest_perm = xstate_get_guest_group_perm();

<yellow>		r = xstate_required_size(kvm_caps.supported_xcr0 & guest_perm, false);</yellow>
		if (r &lt; sizeof(struct kvm_xsave))
<blue>			r = sizeof(struct kvm_xsave);</blue>
		break;
	}
	case KVM_CAP_PMU_CAPABILITY:
<yellow>		r = enable_pmu ? KVM_CAP_PMU_VALID_MASK : 0;</yellow>
		break;
	case KVM_CAP_DISABLE_QUIRKS2:
		r = KVM_X86_VALID_QUIRKS;
		break;
	case KVM_CAP_X86_NOTIFY_VMEXIT:
<blue>		r = kvm_caps.has_notify_vmexit;</blue>
		break;
	default:
		break;
	}
	return r;
<blue>}</blue>

static inline void __user *kvm_get_attr_addr(struct kvm_device_attr *attr)
{
	void __user *uaddr = (void __user*)(unsigned long)attr-&gt;addr;

	if ((u64)(unsigned long)uaddr != attr-&gt;addr)
		return ERR_PTR_USR(-EFAULT);
	return uaddr;
}

static int kvm_x86_dev_get_attr(struct kvm_device_attr *attr)
{
	u64 __user *uaddr = kvm_get_attr_addr(attr);

<blue>	if (attr->group)</blue>
		return -ENXIO;

<blue>	if (IS_ERR(uaddr))</blue>
<yellow>		return PTR_ERR(uaddr);</yellow>

<blue>	switch (attr->attr) {</blue>
	case KVM_X86_XCOMP_GUEST_SUPP:
<blue>		if (put_user(kvm_caps.supported_xcr0, uaddr))</blue>
			return -EFAULT;
		return 0;
	default:
		return -ENXIO;
		break;
	}
}

static int kvm_x86_dev_has_attr(struct kvm_device_attr *attr)
{
<yellow>	if (attr->group)</yellow>
		return -ENXIO;

<yellow>	switch (attr->attr) {</yellow>
	case KVM_X86_XCOMP_GUEST_SUPP:
		return 0;
	default:
		return -ENXIO;
	}
}

long kvm_arch_dev_ioctl(struct file *filp,
			unsigned int ioctl, unsigned long arg)
<blue>{</blue>
	void __user *argp = (void __user *)arg;
	long r;

<blue>	switch (ioctl) {</blue>
	case KVM_GET_MSR_INDEX_LIST: {
		struct kvm_msr_list __user *user_msr_list = argp;
		struct kvm_msr_list msr_list;
		unsigned n;

		r = -EFAULT;
<blue>		if (copy_from_user(&msr_list, user_msr_list, sizeof(msr_list)))</blue>
			goto out;
		n = msr_list.nmsrs;
		msr_list.nmsrs = num_msrs_to_save + num_emulated_msrs;
<blue>		if (copy_to_user(user_msr_list, &msr_list, sizeof(msr_list)))</blue>
			goto out;
		r = -E2BIG;
<blue>		if (n < msr_list.nmsrs)</blue>
			goto out;
		r = -EFAULT;
<blue>		if (copy_to_user(user_msr_list->indices, &msrs_to_save,</blue>
				 num_msrs_to_save * sizeof(u32)))
			goto out;
<blue>		if (copy_to_user(user_msr_list->indices + num_msrs_to_save,</blue>
				 &amp;emulated_msrs,
				 num_emulated_msrs * sizeof(u32)))
			goto out;
		r = 0;
		break;
	}
	case KVM_GET_SUPPORTED_CPUID:
	case KVM_GET_EMULATED_CPUID: {
		struct kvm_cpuid2 __user *cpuid_arg = argp;
		struct kvm_cpuid2 cpuid;

		r = -EFAULT;
<blue>		if (copy_from_user(&cpuid, cpuid_arg, sizeof(cpuid)))</blue>
			goto out;

<blue>		r = kvm_dev_ioctl_get_cpuid(&cpuid, cpuid_arg->entries,</blue>
					    ioctl);
		if (r)
			goto out;

		r = -EFAULT;
<blue>		if (copy_to_user(cpuid_arg, &cpuid, sizeof(cpuid)))</blue>
			goto out;
		r = 0;
		break;
	}
	case KVM_X86_GET_MCE_CAP_SUPPORTED:
		r = -EFAULT;
<blue>		if (copy_to_user(argp, &kvm_caps.supported_mce_cap,</blue>
				 sizeof(kvm_caps.supported_mce_cap)))
			goto out;
		r = 0;
		break;
	case KVM_GET_MSR_FEATURE_INDEX_LIST: {
		struct kvm_msr_list __user *user_msr_list = argp;
		struct kvm_msr_list msr_list;
		unsigned int n;

		r = -EFAULT;
<blue>		if (copy_from_user(&msr_list, user_msr_list, sizeof(msr_list)))</blue>
			goto out;
		n = msr_list.nmsrs;
		msr_list.nmsrs = num_msr_based_features;
<blue>		if (copy_to_user(user_msr_list, &msr_list, sizeof(msr_list)))</blue>
			goto out;
		r = -E2BIG;
<blue>		if (n < msr_list.nmsrs)</blue>
			goto out;
		r = -EFAULT;
<blue>		if (copy_to_user(user_msr_list->indices, &msr_based_features,</blue>
				 num_msr_based_features * sizeof(u32)))
			goto out;
<blue>		r = 0;</blue>
		break;
	}
	case KVM_GET_MSRS:
<blue>		r = msr_io(NULL, argp, do_get_msr_feature, 1);</blue>
		break;
	case KVM_GET_SUPPORTED_HV_CPUID:
<blue>		r = kvm_ioctl_get_supported_hv_cpuid(NULL, argp);</blue>
		break;
	case KVM_GET_DEVICE_ATTR: {
		struct kvm_device_attr attr;
		r = -EFAULT;
<blue>		if (copy_from_user(&attr, (void __user *)arg, sizeof(attr)))</blue>
			break;
<blue>		r = kvm_x86_dev_get_attr(&attr);</blue>
		break;
	}
	case KVM_HAS_DEVICE_ATTR: {
		struct kvm_device_attr attr;
		r = -EFAULT;
<yellow>		if (copy_from_user(&attr, (void __user *)arg, sizeof(attr)))</yellow>
			break;
<yellow>		r = kvm_x86_dev_has_attr(&attr);</yellow>
		break;
	}
	default:
		r = -EINVAL;
		break;
	}
out:
<blue>	return r;</blue>
}

static void wbinvd_ipi(void *garbage)
{
<yellow>	wbinvd();</yellow>
}

static bool need_emulate_wbinvd(struct kvm_vcpu *vcpu)
{
<blue>	return kvm_arch_has_noncoherent_dma(vcpu->kvm);</blue>
}

void kvm_arch_vcpu_load(struct kvm_vcpu *vcpu, int cpu)
{
	/* Address WBINVD may be executed by guest */
<blue>	if (need_emulate_wbinvd(vcpu)) {</blue>
<yellow>		if (static_call(kvm_x86_has_wbinvd_exit)())</yellow>
<yellow>			cpumask_set_cpu(cpu, vcpu->arch.wbinvd_dirty_mask);</yellow>
<yellow>		else if (vcpu->cpu != -1 && vcpu->cpu != cpu)</yellow>
<yellow>			smp_call_function_single(vcpu->cpu,</yellow>
					wbinvd_ipi, NULL, 1);
	}

<blue>	static_call(kvm_x86_vcpu_load)(vcpu, cpu);</blue>

	/* Save host pkru register if supported */
<blue>	vcpu->arch.host_pkru = read_pkru();</blue>

	/* Apply any externally detected TSC adjustments (due to suspend) */
	if (unlikely(vcpu-&gt;arch.tsc_offset_adjustment)) {
<yellow>		adjust_tsc_offset_host(vcpu, vcpu->arch.tsc_offset_adjustment);</yellow>
		vcpu-&gt;arch.tsc_offset_adjustment = 0;
		kvm_make_request(KVM_REQ_CLOCK_UPDATE, vcpu);
	}

<blue>	if (unlikely(vcpu->cpu != cpu) || kvm_check_tsc_unstable()) {</blue>
<blue>		s64 tsc_delta = !vcpu->arch.last_host_tsc ? 0 :</blue>
<blue>				rdtsc() - vcpu->arch.last_host_tsc;</blue>
		if (tsc_delta &lt; 0)
<yellow>			mark_tsc_unstable("KVM discovered backwards TSC");</yellow>

<blue>		if (kvm_check_tsc_unstable()) {</blue>
<yellow>			u64 offset = kvm_compute_l1_tsc_offset(vcpu,</yellow>
						vcpu-&gt;arch.last_guest_tsc);
			kvm_vcpu_write_tsc_offset(vcpu, offset);
			vcpu-&gt;arch.tsc_catchup = 1;
		}

<blue>		if (kvm_lapic_hv_timer_in_use(vcpu))</blue>
<yellow>			kvm_lapic_restart_hv_timer(vcpu);</yellow>

		/*
		 * On a host with synchronized TSC, there is no need to update
		 * kvmclock on vcpu-&gt;cpu migration
		 */
<blue>		if (!vcpu->kvm->arch.use_master_clock || vcpu->cpu == -1)</blue>
<blue>			kvm_make_request(KVM_REQ_GLOBAL_CLOCK_UPDATE, vcpu);</blue>
<blue>		if (vcpu->cpu != cpu)</blue>
<blue>			kvm_make_request(KVM_REQ_MIGRATE_TIMER, vcpu);</blue>
<blue>		vcpu->cpu = cpu;</blue>
	}

<blue>	kvm_make_request(KVM_REQ_STEAL_UPDATE, vcpu);</blue>
}

static void kvm_steal_time_set_preempted(struct kvm_vcpu *vcpu)
{
	struct gfn_to_hva_cache *ghc = &amp;vcpu-&gt;arch.st.cache;
	struct kvm_steal_time __user *st;
	struct kvm_memslots *slots;
	static const u8 preempted = KVM_VCPU_PREEMPTED;
<yellow>	gpa_t gpa = vcpu->arch.st.msr_val & KVM_STEAL_VALID_BITS;</yellow>

	/*
	 * The vCPU can be marked preempted if and only if the VM-Exit was on
	 * an instruction boundary and will not trigger guest emulation of any
	 * kind (see vcpu_run).  Vendor specific code controls (conservatively)
	 * when this is true, for example allowing the vCPU to be marked
	 * preempted if and only if the VM-Exit was due to a host interrupt.
	 */
<yellow>	if (!vcpu->arch.at_instruction_boundary) {</yellow>
<yellow>		vcpu->stat.preemption_other++;</yellow>
		return;
	}

<yellow>	vcpu->stat.preemption_reported++;</yellow>
	if (!(vcpu-&gt;arch.st.msr_val &amp; KVM_MSR_ENABLED))
		return;

<yellow>	if (vcpu->arch.st.preempted)</yellow>
		return;

	/* This happens on process exit */
<yellow>	if (unlikely(current->mm != vcpu->kvm->mm))</yellow>
		return;

<yellow>	slots = kvm_memslots(vcpu->kvm);</yellow>

<yellow>	if (unlikely(slots->generation != ghc->generation ||</yellow>
		     gpa != ghc-&gt;gpa ||
		     kvm_is_error_hva(ghc-&gt;hva) || !ghc-&gt;memslot))
		return;

	st = (struct kvm_steal_time __user *)ghc-&gt;hva;
	BUILD_BUG_ON(sizeof(st-&gt;preempted) != sizeof(preempted));

<yellow>	if (!copy_to_user_nofault(&st->preempted, &preempted, sizeof(preempted)))</yellow>
<yellow>		vcpu->arch.st.preempted = KVM_VCPU_PREEMPTED;</yellow>

<yellow>	mark_page_dirty_in_slot(vcpu->kvm, ghc->memslot, gpa_to_gfn(ghc->gpa));</yellow>
}

void kvm_arch_vcpu_put(struct kvm_vcpu *vcpu)
{
	int idx;

<blue>	if (vcpu->preempted) {</blue>
<yellow>		if (!vcpu->arch.guest_state_protected)</yellow>
<yellow>			vcpu->arch.preempted_in_kernel = !static_call(kvm_x86_get_cpl)(vcpu);</yellow>

		/*
		 * Take the srcu lock as memslots will be accessed to check the gfn
		 * cache generation against the memslots generation.
		 */
<yellow>		idx = srcu_read_lock(&vcpu->kvm->srcu);</yellow>
<yellow>		if (kvm_xen_msr_enabled(vcpu->kvm))</yellow>
<yellow>			kvm_xen_runstate_set_preempted(vcpu);</yellow>
		else
<yellow>			kvm_steal_time_set_preempted(vcpu);</yellow>
<yellow>		srcu_read_unlock(&vcpu->kvm->srcu, idx);</yellow>
	}

<blue>	static_call(kvm_x86_vcpu_put)(vcpu);</blue>
	vcpu-&gt;arch.last_host_tsc = rdtsc();
}

static int kvm_vcpu_ioctl_get_lapic(struct kvm_vcpu *vcpu,
				    struct kvm_lapic_state *s)
{
<blue>	static_call_cond(kvm_x86_sync_pir_to_irr)(vcpu);</blue>

	return kvm_apic_get_state(vcpu, s);
}

static int kvm_vcpu_ioctl_set_lapic(struct kvm_vcpu *vcpu,
				    struct kvm_lapic_state *s)
{
	int r;

<blue>	r = kvm_apic_set_state(vcpu, s);</blue>
	if (r)
		return r;
<blue>	update_cr8_intercept(vcpu);</blue>

	return 0;
}

<yellow>static int kvm_cpu_accept_dm_intr(struct kvm_vcpu *vcpu)</yellow>
{
	/*
	 * We can accept userspace&#x27;s request for interrupt injection
	 * as long as we have a place to store the interrupt number.
	 * The actual injection will happen when the CPU is able to
	 * deliver the interrupt.
	 */
<yellow>	if (kvm_cpu_has_extint(vcpu))</yellow>
		return false;

	/* Acknowledging ExtINT does not happen if LINT0 is masked.  */
<yellow>	return (!lapic_in_kernel(vcpu) ||</yellow>
<yellow>		kvm_apic_accept_pic_intr(vcpu));</yellow>
}

<yellow>static int kvm_vcpu_ready_for_interrupt_injection(struct kvm_vcpu *vcpu)</yellow>
{
	/*
	 * Do not cause an interrupt window exit if an exception
	 * is pending or an event needs reinjection; userspace
	 * might want to inject the interrupt manually using KVM_SET_REGS
	 * or KVM_SET_SREGS.  For that to work, we must be at an
	 * instruction boundary and with no events half-injected.
	 */
<yellow>	return (kvm_arch_interrupt_allowed(vcpu) &&</yellow>
<yellow>		kvm_cpu_accept_dm_intr(vcpu) &&</yellow>
<yellow>		!kvm_event_needs_reinjection(vcpu) &&</yellow>
<yellow>		!kvm_is_exception_pending(vcpu));</yellow>
<yellow>}</yellow>

static int kvm_vcpu_ioctl_interrupt(struct kvm_vcpu *vcpu,
				    struct kvm_interrupt *irq)
{
<yellow>	if (irq->irq >= KVM_NR_INTERRUPTS)</yellow>
		return -EINVAL;

<yellow>	if (!irqchip_in_kernel(vcpu->kvm)) {</yellow>
<yellow>		kvm_queue_interrupt(vcpu, irq->irq, false);</yellow>
		kvm_make_request(KVM_REQ_EVENT, vcpu);
		return 0;
	}

	/*
	 * With in-kernel LAPIC, we only use this to inject EXTINT, so
	 * fail for in-kernel 8259.
	 */
<yellow>	if (pic_in_kernel(vcpu->kvm))</yellow>
		return -ENXIO;

<yellow>	if (vcpu->arch.pending_external_vector != -1)</yellow>
		return -EEXIST;

<yellow>	vcpu->arch.pending_external_vector = irq->irq;</yellow>
	kvm_make_request(KVM_REQ_EVENT, vcpu);
	return 0;
}

static int kvm_vcpu_ioctl_nmi(struct kvm_vcpu *vcpu)
{
<yellow>	kvm_inject_nmi(vcpu);</yellow>

	return 0;
}

static int vcpu_ioctl_tpr_access_reporting(struct kvm_vcpu *vcpu,
					   struct kvm_tpr_access_ctl *tac)
{
<blue>	if (tac->flags)</blue>
		return -EINVAL;
<blue>	vcpu->arch.tpr_access_reporting = !!tac->enabled;</blue>
	return 0;
}

static int kvm_vcpu_ioctl_x86_setup_mce(struct kvm_vcpu *vcpu,
					u64 mcg_cap)
{
	int r;
	unsigned bank_num = mcg_cap &amp; 0xff, bank;

	r = -EINVAL;
	if (!bank_num || bank_num &gt; KVM_MAX_MCE_BANKS)
		goto out;
<blue>	if (mcg_cap & ~(kvm_caps.supported_mce_cap | 0xff | 0xff0000))</blue>
		goto out;
	r = 0;
<blue>	vcpu->arch.mcg_cap = mcg_cap;</blue>
	/* Init IA32_MCG_CTL to all 1s */
	if (mcg_cap &amp; MCG_CTL_P)
<blue>		vcpu->arch.mcg_ctl = ~(u64)0;</blue>
	/* Init IA32_MCi_CTL to all 1s, IA32_MCi_CTL2 to all 0s */
<blue>	for (bank = 0; bank < bank_num; bank++) {</blue>
<blue>		vcpu->arch.mce_banks[bank*4] = ~(u64)0;</blue>
<blue>		if (mcg_cap & MCG_CMCI_P)</blue>
<yellow>			vcpu->arch.mci_ctl2_banks[bank] = 0;</yellow>
	}

<blue>	kvm_apic_after_set_mcg_cap(vcpu);</blue>

	static_call(kvm_x86_setup_mce)(vcpu);
out:
	return r;
}

/*
 * Validate this is an UCNA (uncorrectable no action) error by checking the
 * MCG_STATUS and MCi_STATUS registers:
 * - none of the bits for Machine Check Exceptions are set
 * - both the VAL (valid) and UC (uncorrectable) bits are set
 * MCI_STATUS_PCC - Processor Context Corrupted
 * MCI_STATUS_S - Signaled as a Machine Check Exception
 * MCI_STATUS_AR - Software recoverable Action Required
 */
static bool is_ucna(struct kvm_x86_mce *mce)
{
	return	!mce-&gt;mcg_status &amp;&amp;
		!(mce-&gt;status &amp; (MCI_STATUS_PCC | MCI_STATUS_S | MCI_STATUS_AR)) &amp;&amp;
<yellow>		(mce->status & MCI_STATUS_VAL) &&</yellow>
		(mce-&gt;status &amp; MCI_STATUS_UC);
}

static int kvm_vcpu_x86_set_ucna(struct kvm_vcpu *vcpu, struct kvm_x86_mce *mce, u64* banks)
{
	u64 mcg_cap = vcpu-&gt;arch.mcg_cap;

<yellow>	banks[1] = mce->status;</yellow>
	banks[2] = mce-&gt;addr;
	banks[3] = mce-&gt;misc;
	vcpu-&gt;arch.mcg_status = mce-&gt;mcg_status;

	if (!(mcg_cap &amp; MCG_CMCI_P) ||
<yellow>	    !(vcpu->arch.mci_ctl2_banks[mce->bank] & MCI_CTL2_CMCI_EN))</yellow>
		return 0;

<yellow>	if (lapic_in_kernel(vcpu))</yellow>
<yellow>		kvm_apic_local_deliver(vcpu->arch.apic, APIC_LVTCMCI);</yellow>

	return 0;
}

static int kvm_vcpu_ioctl_x86_set_mce(struct kvm_vcpu *vcpu,
				      struct kvm_x86_mce *mce)
{
<yellow>	u64 mcg_cap = vcpu->arch.mcg_cap;</yellow>
	unsigned bank_num = mcg_cap &amp; 0xff;
	u64 *banks = vcpu-&gt;arch.mce_banks;

<yellow>	if (mce->bank >= bank_num || !(mce->status & MCI_STATUS_VAL))</yellow>
		return -EINVAL;

<yellow>	banks += array_index_nospec(4 * mce->bank, 4 * bank_num);</yellow>

<yellow>	if (is_ucna(mce))</yellow>
<yellow>		return kvm_vcpu_x86_set_ucna(vcpu, mce, banks);</yellow>

	/*
	 * if IA32_MCG_CTL is not all 1s, the uncorrected error
	 * reporting is disabled
	 */
<yellow>	if ((mce->status & MCI_STATUS_UC) && (mcg_cap & MCG_CTL_P) &&</yellow>
<yellow>	    vcpu->arch.mcg_ctl != ~(u64)0)</yellow>
		return 0;
	/*
	 * if IA32_MCi_CTL is not all 1s, the uncorrected error
	 * reporting is disabled for the bank
	 */
<yellow>	if ((mce->status & MCI_STATUS_UC) && banks[0] != ~(u64)0)</yellow>
		return 0;
	if (mce-&gt;status &amp; MCI_STATUS_UC) {
<yellow>		if ((vcpu->arch.mcg_status & MCG_STATUS_MCIP) ||</yellow>
<yellow>		    !kvm_read_cr4_bits(vcpu, X86_CR4_MCE)) {</yellow>
<yellow>			kvm_make_request(KVM_REQ_TRIPLE_FAULT, vcpu);</yellow>
			return 0;
		}
<yellow>		if (banks[1] & MCI_STATUS_VAL)</yellow>
<yellow>			mce->status |= MCI_STATUS_OVER;</yellow>
<yellow>		banks[2] = mce->addr;</yellow>
		banks[3] = mce-&gt;misc;
		vcpu-&gt;arch.mcg_status = mce-&gt;mcg_status;
		banks[1] = mce-&gt;status;
		kvm_queue_exception(vcpu, MC_VECTOR);
<yellow>	} else if (!(banks[1] & MCI_STATUS_VAL)</yellow>
<yellow>		   || !(banks[1] & MCI_STATUS_UC)) {</yellow>
		if (banks[1] &amp; MCI_STATUS_VAL)
<yellow>			mce->status |= MCI_STATUS_OVER;</yellow>
<yellow>		banks[2] = mce->addr;</yellow>
		banks[3] = mce-&gt;misc;
		banks[1] = mce-&gt;status;
	} else
<yellow>		banks[1] |= MCI_STATUS_OVER;</yellow>
	return 0;
}

static void kvm_vcpu_ioctl_x86_get_vcpu_events(struct kvm_vcpu *vcpu,
					       struct kvm_vcpu_events *events)
{
	struct kvm_queued_exception *ex;

<blue>	process_nmi(vcpu);</blue>

#ifdef CONFIG_KVM_SMM
<yellow>	if (kvm_check_request(KVM_REQ_SMI, vcpu))</yellow>
		process_smi(vcpu);
#endif

	/*
	 * KVM&#x27;s ABI only allows for one exception to be migrated.  Luckily,
	 * the only time there can be two queued exceptions is if there&#x27;s a
	 * non-exiting _injected_ exception, and a pending exiting exception.
	 * In that case, ignore the VM-Exiting exception as it&#x27;s an extension
	 * of the injected exception.
	 */
<blue>	if (vcpu->arch.exception_vmexit.pending &&</blue>
<yellow>	    !vcpu->arch.exception.pending &&</yellow>
<yellow>	    !vcpu->arch.exception.injected)</yellow>
<yellow>		ex = &vcpu->arch.exception_vmexit;</yellow>
	else
<blue>		ex = &vcpu->arch.exception;</blue>

	/*
	 * In guest mode, payload delivery should be deferred if the exception
	 * will be intercepted by L1, e.g. KVM should not modifying CR2 if L1
	 * intercepts #PF, ditto for DR6 and #DBs.  If the per-VM capability,
	 * KVM_CAP_EXCEPTION_PAYLOAD, is not set, userspace may or may not
	 * propagate the payload and so it cannot be safely deferred.  Deliver
	 * the payload if the capability hasn&#x27;t been requested.
	 */
<blue>	if (!vcpu->kvm->arch.exception_payload_enabled &&</blue>
<yellow>	    ex->pending && ex->has_payload)</yellow>
<yellow>		kvm_deliver_exception_payload(vcpu, ex);</yellow>

	memset(events, 0, sizeof(*events));

	/*
	 * The API doesn&#x27;t provide the instruction length for software
	 * exceptions, so don&#x27;t report them. As long as the guest RIP
	 * isn&#x27;t advanced, we should expect to encounter the exception
	 * again.
	 */
<blue>	if (!kvm_exception_is_soft(ex->vector)) {</blue>
<blue>		events->exception.injected = ex->injected;</blue>
<blue>		events->exception.pending = ex->pending;</blue>
		/*
		 * For ABI compatibility, deliberately conflate
		 * pending and injected exceptions when
		 * KVM_CAP_EXCEPTION_PAYLOAD isn&#x27;t enabled.
		 */
<blue>		if (!vcpu->kvm->arch.exception_payload_enabled)</blue>
<yellow>			events->exception.injected |= ex->pending;</yellow>
	}
<blue>	events->exception.nr = ex->vector;</blue>
<blue>	events->exception.has_error_code = ex->has_error_code;</blue>
	events-&gt;exception.error_code = ex-&gt;error_code;
<blue>	events->exception_has_payload = ex->has_payload;</blue>
	events-&gt;exception_payload = ex-&gt;payload;

<blue>	events->interrupt.injected =</blue>
<blue>		vcpu->arch.interrupt.injected && !vcpu->arch.interrupt.soft;</blue>
	events-&gt;interrupt.nr = vcpu-&gt;arch.interrupt.nr;
	events-&gt;interrupt.shadow = static_call(kvm_x86_get_interrupt_shadow)(vcpu);

<blue>	events->nmi.injected = vcpu->arch.nmi_injected;</blue>
	events-&gt;nmi.pending = vcpu-&gt;arch.nmi_pending != 0;
	events-&gt;nmi.masked = static_call(kvm_x86_get_nmi_mask)(vcpu);

	/* events-&gt;sipi_vector is never valid when reporting to user space */

#ifdef CONFIG_KVM_SMM
	events-&gt;smi.smm = is_smm(vcpu);
<blue>	events->smi.pending = vcpu->arch.smi_pending;</blue>
	events-&gt;smi.smm_inside_nmi =
		!!(vcpu-&gt;arch.hflags &amp; HF_SMM_INSIDE_NMI_MASK);
#endif
<blue>	events->smi.latched_init = kvm_lapic_latched_init(vcpu);</blue>

	events-&gt;flags = (KVM_VCPUEVENT_VALID_NMI_PENDING
			 | KVM_VCPUEVENT_VALID_SHADOW
			 | KVM_VCPUEVENT_VALID_SMM);
<blue>	if (vcpu->kvm->arch.exception_payload_enabled)</blue>
<blue>		events->flags |= KVM_VCPUEVENT_VALID_PAYLOAD;</blue>
<blue>	if (vcpu->kvm->arch.triple_fault_event) {</blue>
<blue>		events->triple_fault.pending = kvm_test_request(KVM_REQ_TRIPLE_FAULT, vcpu);</blue>
		events-&gt;flags |= KVM_VCPUEVENT_VALID_TRIPLE_FAULT;
	}
<blue>}</blue>

static int kvm_vcpu_ioctl_x86_set_vcpu_events(struct kvm_vcpu *vcpu,
					      struct kvm_vcpu_events *events)
{
<blue>	if (events->flags & ~(KVM_VCPUEVENT_VALID_NMI_PENDING</blue>
			      | KVM_VCPUEVENT_VALID_SIPI_VECTOR
			      | KVM_VCPUEVENT_VALID_SHADOW
			      | KVM_VCPUEVENT_VALID_SMM
			      | KVM_VCPUEVENT_VALID_PAYLOAD
			      | KVM_VCPUEVENT_VALID_TRIPLE_FAULT))
		return -EINVAL;

<blue>	if (events->flags & KVM_VCPUEVENT_VALID_PAYLOAD) {</blue>
<blue>		if (!vcpu->kvm->arch.exception_payload_enabled)</blue>
			return -EINVAL;
<blue>		if (events->exception.pending)</blue>
<yellow>			events->exception.injected = 0;</yellow>
		else
<blue>			events->exception_has_payload = 0;</blue>
	} else {
<yellow>		events->exception.pending = 0;</yellow>
		events-&gt;exception_has_payload = 0;
	}

<blue>	if ((events->exception.injected || events->exception.pending) &&</blue>
<yellow>	    (events->exception.nr > 31 || events->exception.nr == NMI_VECTOR))</yellow>
		return -EINVAL;

	/* INITs are latched while in SMM */
<blue>	if (events->flags & KVM_VCPUEVENT_VALID_SMM &&</blue>
<blue>	    (events->smi.smm || events->smi.pending) &&</blue>
<yellow>	    vcpu->arch.mp_state == KVM_MP_STATE_INIT_RECEIVED)</yellow>
		return -EINVAL;

<blue>	process_nmi(vcpu);</blue>

	/*
	 * Flag that userspace is stuffing an exception, the next KVM_RUN will
	 * morph the exception to a VM-Exit if appropriate.  Do this only for
	 * pending exceptions, already-injected exceptions are not subject to
	 * intercpetion.  Note, userspace that conflates pending and injected
	 * is hosed, and will incorrectly convert an injected exception into a
	 * pending exception, which in turn may cause a spurious VM-Exit.
	 */
	vcpu-&gt;arch.exception_from_userspace = events-&gt;exception.pending;

	vcpu-&gt;arch.exception_vmexit.pending = false;

	vcpu-&gt;arch.exception.injected = events-&gt;exception.injected;
	vcpu-&gt;arch.exception.pending = events-&gt;exception.pending;
	vcpu-&gt;arch.exception.vector = events-&gt;exception.nr;
	vcpu-&gt;arch.exception.has_error_code = events-&gt;exception.has_error_code;
	vcpu-&gt;arch.exception.error_code = events-&gt;exception.error_code;
	vcpu-&gt;arch.exception.has_payload = events-&gt;exception_has_payload;
	vcpu-&gt;arch.exception.payload = events-&gt;exception_payload;

	vcpu-&gt;arch.interrupt.injected = events-&gt;interrupt.injected;
	vcpu-&gt;arch.interrupt.nr = events-&gt;interrupt.nr;
	vcpu-&gt;arch.interrupt.soft = events-&gt;interrupt.soft;
	if (events-&gt;flags &amp; KVM_VCPUEVENT_VALID_SHADOW)
		static_call(kvm_x86_set_interrupt_shadow)(vcpu,
<yellow>						events->interrupt.shadow);</yellow>

<blue>	vcpu->arch.nmi_injected = events->nmi.injected;</blue>
	if (events-&gt;flags &amp; KVM_VCPUEVENT_VALID_NMI_PENDING)
<blue>		vcpu->arch.nmi_pending = events->nmi.pending;</blue>
<blue>	static_call(kvm_x86_set_nmi_mask)(vcpu, events->nmi.masked);</blue>

	if (events-&gt;flags &amp; KVM_VCPUEVENT_VALID_SIPI_VECTOR &amp;&amp;
<yellow>	    lapic_in_kernel(vcpu))</yellow>
<yellow>		vcpu->arch.apic->sipi_vector = events->sipi_vector;</yellow>

<blue>	if (events->flags & KVM_VCPUEVENT_VALID_SMM) {</blue>
#ifdef CONFIG_KVM_SMM
<blue>		if (!!(vcpu->arch.hflags & HF_SMM_MASK) != events->smi.smm) {</blue>
<yellow>			kvm_leave_nested(vcpu);</yellow>
			kvm_smm_changed(vcpu, events-&gt;smi.smm);
		}

<blue>		vcpu->arch.smi_pending = events->smi.pending;</blue>

		if (events-&gt;smi.smm) {
<yellow>			if (events->smi.smm_inside_nmi)</yellow>
<yellow>				vcpu->arch.hflags |= HF_SMM_INSIDE_NMI_MASK;</yellow>
			else
<yellow>				vcpu->arch.hflags &= ~HF_SMM_INSIDE_NMI_MASK;</yellow>
		}

#else
		if (events-&gt;smi.smm || events-&gt;smi.pending ||
		    events-&gt;smi.smm_inside_nmi)
			return -EINVAL;
#endif

<blue>		if (lapic_in_kernel(vcpu)) {</blue>
<blue>			if (events->smi.latched_init)</blue>
<yellow>				set_bit(KVM_APIC_INIT, &vcpu->arch.apic->pending_events);</yellow>
			else
<blue>				clear_bit(KVM_APIC_INIT, &vcpu->arch.apic->pending_events);</blue>
		}
	}

<blue>	if (events->flags & KVM_VCPUEVENT_VALID_TRIPLE_FAULT) {</blue>
<blue>		if (!vcpu->kvm->arch.triple_fault_event)</blue>
			return -EINVAL;
<blue>		if (events->triple_fault.pending)</blue>
<yellow>			kvm_make_request(KVM_REQ_TRIPLE_FAULT, vcpu);</yellow>
		else
<blue>			kvm_clear_request(KVM_REQ_TRIPLE_FAULT, vcpu);</blue>
	}

<blue>	kvm_make_request(KVM_REQ_EVENT, vcpu);</blue>

	return 0;
<blue>}</blue>

static void kvm_vcpu_ioctl_x86_get_debugregs(struct kvm_vcpu *vcpu,
					     struct kvm_debugregs *dbgregs)
{
	unsigned long val;

<blue>	memset(dbgregs, 0, sizeof(*dbgregs));</blue>
	memcpy(dbgregs-&gt;db, vcpu-&gt;arch.db, sizeof(vcpu-&gt;arch.db));
	kvm_get_dr(vcpu, 6, &amp;val);
	dbgregs-&gt;dr6 = val;
	dbgregs-&gt;dr7 = vcpu-&gt;arch.dr7;
}

static int kvm_vcpu_ioctl_x86_set_debugregs(struct kvm_vcpu *vcpu,
					    struct kvm_debugregs *dbgregs)
{
	if (dbgregs-&gt;flags)
		return -EINVAL;

<blue>	if (!kvm_dr6_valid(dbgregs->dr6))</blue>
		return -EINVAL;
	if (!kvm_dr7_valid(dbgregs-&gt;dr7))
		return -EINVAL;

<blue>	memcpy(vcpu->arch.db, dbgregs->db, sizeof(vcpu->arch.db));</blue>
<blue>	kvm_update_dr0123(vcpu);</blue>
<yellow>	vcpu->arch.dr6 = dbgregs->dr6;</yellow>
	vcpu-&gt;arch.dr7 = dbgregs-&gt;dr7;
<blue>	kvm_update_dr7(vcpu);</blue>

	return 0;
}

static void kvm_vcpu_ioctl_x86_get_xsave(struct kvm_vcpu *vcpu,
					 struct kvm_xsave *guest_xsave)
{
<yellow>	if (fpstate_is_confidential(&vcpu->arch.guest_fpu))</yellow>
		return;

<yellow>	fpu_copy_guest_fpstate_to_uabi(&vcpu->arch.guest_fpu,</yellow>
				       guest_xsave-&gt;region,
				       sizeof(guest_xsave-&gt;region),
				       vcpu-&gt;arch.pkru);
}

static void kvm_vcpu_ioctl_x86_get_xsave2(struct kvm_vcpu *vcpu,
					  u8 *state, unsigned int size)
{
<blue>	if (fpstate_is_confidential(&vcpu->arch.guest_fpu))</blue>
		return;

<blue>	fpu_copy_guest_fpstate_to_uabi(&vcpu->arch.guest_fpu,</blue>
				       state, size, vcpu-&gt;arch.pkru);
}

static int kvm_vcpu_ioctl_x86_set_xsave(struct kvm_vcpu *vcpu,
					struct kvm_xsave *guest_xsave)
{
<blue>	if (fpstate_is_confidential(&vcpu->arch.guest_fpu))</blue>
		return 0;

<blue>	return fpu_copy_uabi_to_guest_fpstate(&vcpu->arch.guest_fpu,</blue>
					      guest_xsave-&gt;region,
					      kvm_caps.supported_xcr0,
					      &amp;vcpu-&gt;arch.pkru);
}

static void kvm_vcpu_ioctl_x86_get_xcrs(struct kvm_vcpu *vcpu,
					struct kvm_xcrs *guest_xcrs)
{
<blue>	if (!boot_cpu_has(X86_FEATURE_XSAVE)) {</blue>
<yellow>		guest_xcrs->nr_xcrs = 0;</yellow>
		return;
	}

<blue>	guest_xcrs->nr_xcrs = 1;</blue>
	guest_xcrs-&gt;flags = 0;
	guest_xcrs-&gt;xcrs[0].xcr = XCR_XFEATURE_ENABLED_MASK;
	guest_xcrs-&gt;xcrs[0].value = vcpu-&gt;arch.xcr0;
}

static int kvm_vcpu_ioctl_x86_set_xcrs(struct kvm_vcpu *vcpu,
				       struct kvm_xcrs *guest_xcrs)
{
	int i, r = 0;

<blue>	if (!boot_cpu_has(X86_FEATURE_XSAVE))</blue>
		return -EINVAL;

<blue>	if (guest_xcrs->nr_xcrs > KVM_MAX_XCRS || guest_xcrs->flags)</blue>
		return -EINVAL;

<blue>	for (i = 0; i < guest_xcrs->nr_xcrs; i++)</blue>
		/* Only support XCR0 currently */
<blue>		if (guest_xcrs->xcrs[i].xcr == XCR_XFEATURE_ENABLED_MASK) {</blue>
			r = __kvm_set_xcr(vcpu, XCR_XFEATURE_ENABLED_MASK,
<blue>				guest_xcrs->xcrs[i].value);</blue>
			break;
		}
	if (r)
		r = -EINVAL;
	return r;
}

/*
 * kvm_set_guest_paused() indicates to the guest kernel that it has been
 * stopped by the hypervisor.  This function will be called from the host only.
 * EINVAL is returned when the host attempts to set the flag for a guest that
 * does not support pv clocks.
 */
static int kvm_set_guest_paused(struct kvm_vcpu *vcpu)
{
<blue>	if (!vcpu->arch.pv_time.active)</blue>
		return -EINVAL;
<yellow>	vcpu->arch.pvclock_set_guest_stopped_request = true;</yellow>
	kvm_make_request(KVM_REQ_CLOCK_UPDATE, vcpu);
	return 0;
}

static int kvm_arch_tsc_has_attr(struct kvm_vcpu *vcpu,
				 struct kvm_device_attr *attr)
{
	int r;

<yellow>	switch (attr->attr) {</yellow>
	case KVM_VCPU_TSC_OFFSET:
		r = 0;
		break;
	default:
		r = -ENXIO;
	}

	return r;
}

static int kvm_arch_tsc_get_attr(struct kvm_vcpu *vcpu,
				 struct kvm_device_attr *attr)
{
	u64 __user *uaddr = kvm_get_attr_addr(attr);
	int r;

	if (IS_ERR(uaddr))
		return PTR_ERR(uaddr);

<yellow>	switch (attr->attr) {</yellow>
	case KVM_VCPU_TSC_OFFSET:
		r = -EFAULT;
<yellow>		if (put_user(vcpu->arch.l1_tsc_offset, uaddr))</yellow>
			break;
		r = 0;
		break;
	default:
		r = -ENXIO;
	}

	return r;
}

static int kvm_arch_tsc_set_attr(struct kvm_vcpu *vcpu,
				 struct kvm_device_attr *attr)
{
	u64 __user *uaddr = kvm_get_attr_addr(attr);
<yellow>	struct kvm *kvm = vcpu->kvm;</yellow>
	int r;

	if (IS_ERR(uaddr))
		return PTR_ERR(uaddr);

<yellow>	switch (attr->attr) {</yellow>
	case KVM_VCPU_TSC_OFFSET: {
		u64 offset, tsc, ns;
		unsigned long flags;
		bool matched;

		r = -EFAULT;
<yellow>		if (get_user(offset, uaddr))</yellow>
			break;

<yellow>		raw_spin_lock_irqsave(&kvm->arch.tsc_write_lock, flags);</yellow>

		matched = (vcpu-&gt;arch.virtual_tsc_khz &amp;&amp;
<yellow>			   kvm->arch.last_tsc_khz == vcpu->arch.virtual_tsc_khz &&</yellow>
<yellow>			   kvm->arch.last_tsc_offset == offset);</yellow>

<yellow>		tsc = kvm_scale_tsc(rdtsc(), vcpu->arch.l1_tsc_scaling_ratio) + offset;</yellow>
		ns = get_kvmclock_base_ns();

		__kvm_synchronize_tsc(vcpu, offset, tsc, ns, matched);
		raw_spin_unlock_irqrestore(&amp;kvm-&gt;arch.tsc_write_lock, flags);

		r = 0;
		break;
	}
	default:
		r = -ENXIO;
	}

	return r;
}

static int kvm_vcpu_ioctl_device_attr(struct kvm_vcpu *vcpu,
				      unsigned int ioctl,
				      void __user *argp)
{
	struct kvm_device_attr attr;
	int r;

<yellow>	if (copy_from_user(&attr, argp, sizeof(attr)))</yellow>
		return -EFAULT;

<yellow>	if (attr.group != KVM_VCPU_TSC_CTRL)</yellow>
		return -ENXIO;

<yellow>	switch (ioctl) {</yellow>
	case KVM_HAS_DEVICE_ATTR:
<yellow>		r = kvm_arch_tsc_has_attr(vcpu, &attr);</yellow>
		break;
	case KVM_GET_DEVICE_ATTR:
<yellow>		r = kvm_arch_tsc_get_attr(vcpu, &attr);</yellow>
		break;
	case KVM_SET_DEVICE_ATTR:
<yellow>		r = kvm_arch_tsc_set_attr(vcpu, &attr);</yellow>
		break;
	}

	return r;
}

static int kvm_vcpu_ioctl_enable_cap(struct kvm_vcpu *vcpu,
				     struct kvm_enable_cap *cap)
{
	int r;
	uint16_t vmcs_version;
	void __user *user_ptr;

<blue>	if (cap->flags)</blue>
		return -EINVAL;

<blue>	switch (cap->cap) {</blue>
	case KVM_CAP_HYPERV_SYNIC2:
<blue>		if (cap->args[0])</blue>
			return -EINVAL;
		fallthrough;

	case KVM_CAP_HYPERV_SYNIC:
<blue>		if (!irqchip_in_kernel(vcpu->kvm))</blue>
			return -EINVAL;
<blue>		return kvm_hv_activate_synic(vcpu, cap->cap ==</blue>
					     KVM_CAP_HYPERV_SYNIC2);
	case KVM_CAP_HYPERV_ENLIGHTENED_VMCS:
<blue>		if (!kvm_x86_ops.nested_ops->enable_evmcs)</blue>
			return -ENOTTY;
<blue>		r = kvm_x86_ops.nested_ops->enable_evmcs(vcpu, &vmcs_version);</blue>
		if (!r) {
			user_ptr = (void __user *)(uintptr_t)cap-&gt;args[0];
<blue>			if (copy_to_user(user_ptr, &vmcs_version,</blue>
					 sizeof(vmcs_version)))
				r = -EFAULT;
		}
		return r;
	case KVM_CAP_HYPERV_DIRECT_TLBFLUSH:
<yellow>		if (!kvm_x86_ops.enable_l2_tlb_flush)</yellow>
			return -ENOTTY;

<yellow>		return static_call(kvm_x86_enable_l2_tlb_flush)(vcpu);</yellow>

	case KVM_CAP_HYPERV_ENFORCE_CPUID:
<yellow>		return kvm_hv_set_enforce_cpuid(vcpu, cap->args[0]);</yellow>

	case KVM_CAP_ENFORCE_PV_FEATURE_CPUID:
<yellow>		vcpu->arch.pv_cpuid.enforce = cap->args[0];</yellow>
<yellow>		if (vcpu->arch.pv_cpuid.enforce)</yellow>
<yellow>			kvm_update_pv_runtime(vcpu);</yellow>

		return 0;
	default:
		return -EINVAL;
	}
}

long kvm_arch_vcpu_ioctl(struct file *filp,
			 unsigned int ioctl, unsigned long arg)
{
<blue>	struct kvm_vcpu *vcpu = filp->private_data;</blue>
	void __user *argp = (void __user *)arg;
	int r;
	union {
		struct kvm_sregs2 *sregs2;
		struct kvm_lapic_state *lapic;
		struct kvm_xsave *xsave;
		struct kvm_xcrs *xcrs;
		void *buffer;
	} u;

	vcpu_load(vcpu);

<blue>	u.buffer = NULL;</blue>
	switch (ioctl) {
	case KVM_GET_LAPIC: {
		r = -EINVAL;
<blue>		if (!lapic_in_kernel(vcpu))</blue>
			goto out;
<blue>		u.lapic = kzalloc(sizeof(struct kvm_lapic_state),</blue>
				GFP_KERNEL_ACCOUNT);

		r = -ENOMEM;
		if (!u.lapic)
			goto out;
<blue>		r = kvm_vcpu_ioctl_get_lapic(vcpu, u.lapic);</blue>
		if (r)
			goto out;
		r = -EFAULT;
<blue>		if (copy_to_user(argp, u.lapic, sizeof(struct kvm_lapic_state)))</blue>
			goto out;
		r = 0;
		break;
	}
	case KVM_SET_LAPIC: {
		r = -EINVAL;
<blue>		if (!lapic_in_kernel(vcpu))</blue>
			goto out;
<blue>		u.lapic = memdup_user(argp, sizeof(*u.lapic));</blue>
		if (IS_ERR(u.lapic)) {
			r = PTR_ERR(u.lapic);
			goto out_nofree;
		}

<blue>		r = kvm_vcpu_ioctl_set_lapic(vcpu, u.lapic);</blue>
		break;
	}
	case KVM_INTERRUPT: {
		struct kvm_interrupt irq;

		r = -EFAULT;
<yellow>		if (copy_from_user(&irq, argp, sizeof(irq)))</yellow>
			goto out;
<yellow>		r = kvm_vcpu_ioctl_interrupt(vcpu, &irq);</yellow>
		break;
	}
	case KVM_NMI: {
<yellow>		r = kvm_vcpu_ioctl_nmi(vcpu);</yellow>
		break;
	}
	case KVM_SMI: {
<yellow>		r = kvm_inject_smi(vcpu);</yellow>
		break;
	}
	case KVM_SET_CPUID: {
		struct kvm_cpuid __user *cpuid_arg = argp;
		struct kvm_cpuid cpuid;

		r = -EFAULT;
<yellow>		if (copy_from_user(&cpuid, cpuid_arg, sizeof(cpuid)))</yellow>
			goto out;
<yellow>		r = kvm_vcpu_ioctl_set_cpuid(vcpu, &cpuid, cpuid_arg->entries);</yellow>
		break;
	}
	case KVM_SET_CPUID2: {
		struct kvm_cpuid2 __user *cpuid_arg = argp;
		struct kvm_cpuid2 cpuid;

		r = -EFAULT;
<blue>		if (copy_from_user(&cpuid, cpuid_arg, sizeof(cpuid)))</blue>
			goto out;
<blue>		r = kvm_vcpu_ioctl_set_cpuid2(vcpu, &cpuid,</blue>
					      cpuid_arg-&gt;entries);
		break;
	}
	case KVM_GET_CPUID2: {
		struct kvm_cpuid2 __user *cpuid_arg = argp;
		struct kvm_cpuid2 cpuid;

		r = -EFAULT;
<yellow>		if (copy_from_user(&cpuid, cpuid_arg, sizeof(cpuid)))</yellow>
			goto out;
<yellow>		r = kvm_vcpu_ioctl_get_cpuid2(vcpu, &cpuid,</yellow>
					      cpuid_arg-&gt;entries);
		if (r)
			goto out;
		r = -EFAULT;
<yellow>		if (copy_to_user(cpuid_arg, &cpuid, sizeof(cpuid)))</yellow>
			goto out;
		r = 0;
		break;
	}
	case KVM_GET_MSRS: {
<blue>		int idx = srcu_read_lock(&vcpu->kvm->srcu);</blue>
		r = msr_io(vcpu, argp, do_get_msr, 1);
<blue>		srcu_read_unlock(&vcpu->kvm->srcu, idx);</blue>
		break;
	}
	case KVM_SET_MSRS: {
<blue>		int idx = srcu_read_lock(&vcpu->kvm->srcu);</blue>
<blue>		r = msr_io(vcpu, argp, do_set_msr, 0);</blue>
<blue>		srcu_read_unlock(&vcpu->kvm->srcu, idx);</blue>
		break;
	}
	case KVM_TPR_ACCESS_REPORTING: {
		struct kvm_tpr_access_ctl tac;

		r = -EFAULT;
<blue>		if (copy_from_user(&tac, argp, sizeof(tac)))</blue>
			goto out;
<blue>		r = vcpu_ioctl_tpr_access_reporting(vcpu, &tac);</blue>
		if (r)
			goto out;
		r = -EFAULT;
		if (copy_to_user(argp, &amp;tac, sizeof(tac)))
			goto out;
		r = 0;
<blue>		break;</blue>
	};
	case KVM_SET_VAPIC_ADDR: {
		struct kvm_vapic_addr va;
		int idx;

		r = -EINVAL;
<blue>		if (!lapic_in_kernel(vcpu))</blue>
			goto out;
		r = -EFAULT;
<blue>		if (copy_from_user(&va, argp, sizeof(va)))</blue>
			goto out;
<blue>		idx = srcu_read_lock(&vcpu->kvm->srcu);</blue>
		r = kvm_lapic_set_vapic_addr(vcpu, va.vapic_addr);
<blue>		srcu_read_unlock(&vcpu->kvm->srcu, idx);</blue>
		break;
	}
	case KVM_X86_SETUP_MCE: {
		u64 mcg_cap;

		r = -EFAULT;
<blue>		if (copy_from_user(&mcg_cap, argp, sizeof(mcg_cap)))</blue>
			goto out;
<blue>		r = kvm_vcpu_ioctl_x86_setup_mce(vcpu, mcg_cap);</blue>
		break;
	}
	case KVM_X86_SET_MCE: {
		struct kvm_x86_mce mce;

		r = -EFAULT;
<yellow>		if (copy_from_user(&mce, argp, sizeof(mce)))</yellow>
			goto out;
<yellow>		r = kvm_vcpu_ioctl_x86_set_mce(vcpu, &mce);</yellow>
		break;
	}
	case KVM_GET_VCPU_EVENTS: {
		struct kvm_vcpu_events events;

<blue>		kvm_vcpu_ioctl_x86_get_vcpu_events(vcpu, &events);</blue>

		r = -EFAULT;
		if (copy_to_user(argp, &amp;events, sizeof(struct kvm_vcpu_events)))
			break;
		r = 0;
		break;
	}
	case KVM_SET_VCPU_EVENTS: {
		struct kvm_vcpu_events events;

		r = -EFAULT;
<blue>		if (copy_from_user(&events, argp, sizeof(struct kvm_vcpu_events)))</blue>
			break;

<blue>		r = kvm_vcpu_ioctl_x86_set_vcpu_events(vcpu, &events);</blue>
		break;
	}
	case KVM_GET_DEBUGREGS: {
		struct kvm_debugregs dbgregs;

<blue>		kvm_vcpu_ioctl_x86_get_debugregs(vcpu, &dbgregs);</blue>

		r = -EFAULT;
		if (copy_to_user(argp, &amp;dbgregs,
				 sizeof(struct kvm_debugregs)))
			break;
		r = 0;
		break;
	}
	case KVM_SET_DEBUGREGS: {
		struct kvm_debugregs dbgregs;

		r = -EFAULT;
<blue>		if (copy_from_user(&dbgregs, argp,</blue>
				   sizeof(struct kvm_debugregs)))
			break;

<blue>		r = kvm_vcpu_ioctl_x86_set_debugregs(vcpu, &dbgregs);</blue>
		break;
	}
	case KVM_GET_XSAVE: {
		r = -EINVAL;
<yellow>		if (vcpu->arch.guest_fpu.uabi_size > sizeof(struct kvm_xsave))</yellow>
			break;

<yellow>		u.xsave = kzalloc(sizeof(struct kvm_xsave), GFP_KERNEL_ACCOUNT);</yellow>
		r = -ENOMEM;
		if (!u.xsave)
			break;

<yellow>		kvm_vcpu_ioctl_x86_get_xsave(vcpu, u.xsave);</yellow>

		r = -EFAULT;
<yellow>		if (copy_to_user(argp, u.xsave, sizeof(struct kvm_xsave)))</yellow>
			break;
		r = 0;
		break;
	}
	case KVM_SET_XSAVE: {
<blue>		int size = vcpu->arch.guest_fpu.uabi_size;</blue>

		u.xsave = memdup_user(argp, size);
		if (IS_ERR(u.xsave)) {
			r = PTR_ERR(u.xsave);
			goto out_nofree;
		}

<blue>		r = kvm_vcpu_ioctl_x86_set_xsave(vcpu, u.xsave);</blue>
		break;
	}

	case KVM_GET_XSAVE2: {
<blue>		int size = vcpu->arch.guest_fpu.uabi_size;</blue>

		u.xsave = kzalloc(size, GFP_KERNEL_ACCOUNT);
		r = -ENOMEM;
		if (!u.xsave)
			break;

<blue>		kvm_vcpu_ioctl_x86_get_xsave2(vcpu, u.buffer, size);</blue>

		r = -EFAULT;
<blue>		if (copy_to_user(argp, u.xsave, size))</blue>
			break;

		r = 0;
		break;
	}

	case KVM_GET_XCRS: {
<blue>		u.xcrs = kzalloc(sizeof(struct kvm_xcrs), GFP_KERNEL_ACCOUNT);</blue>
		r = -ENOMEM;
		if (!u.xcrs)
			break;

<blue>		kvm_vcpu_ioctl_x86_get_xcrs(vcpu, u.xcrs);</blue>

		r = -EFAULT;
<blue>		if (copy_to_user(argp, u.xcrs,</blue>
				 sizeof(struct kvm_xcrs)))
			break;
		r = 0;
		break;
	}
	case KVM_SET_XCRS: {
<blue>		u.xcrs = memdup_user(argp, sizeof(*u.xcrs));</blue>
		if (IS_ERR(u.xcrs)) {
			r = PTR_ERR(u.xcrs);
			goto out_nofree;
		}

<blue>		r = kvm_vcpu_ioctl_x86_set_xcrs(vcpu, u.xcrs);</blue>
		break;
	}
	case KVM_SET_TSC_KHZ: {
		u32 user_tsc_khz;

		r = -EINVAL;
		user_tsc_khz = (u32)arg;

<blue>		if (kvm_caps.has_tsc_control &&</blue>
<blue>		    user_tsc_khz >= kvm_caps.max_guest_tsc_khz)</blue>
			goto out;

<blue>		if (user_tsc_khz == 0)</blue>
<yellow>			user_tsc_khz = tsc_khz;</yellow>

<blue>		if (!kvm_set_tsc_khz(vcpu, user_tsc_khz))</blue>
			r = 0;

		goto out;
	}
	case KVM_GET_TSC_KHZ: {
<blue>		r = vcpu->arch.virtual_tsc_khz;</blue>
		goto out;
	}
	case KVM_KVMCLOCK_CTRL: {
<blue>		r = kvm_set_guest_paused(vcpu);</blue>
		goto out;
	}
	case KVM_ENABLE_CAP: {
		struct kvm_enable_cap cap;

		r = -EFAULT;
<blue>		if (copy_from_user(&cap, argp, sizeof(cap)))</blue>
			goto out;
<blue>		r = kvm_vcpu_ioctl_enable_cap(vcpu, &cap);</blue>
		break;
	}
	case KVM_GET_NESTED_STATE: {
		struct kvm_nested_state __user *user_kvm_nested_state = argp;
		u32 user_data_size;

		r = -EINVAL;
<blue>		if (!kvm_x86_ops.nested_ops->get_state)</blue>
			break;

		BUILD_BUG_ON(sizeof(user_data_size) != sizeof(user_kvm_nested_state-&gt;size));
		r = -EFAULT;
<blue>		if (get_user(user_data_size, &user_kvm_nested_state->size))</blue>
			break;

<blue>		r = kvm_x86_ops.nested_ops->get_state(vcpu, user_kvm_nested_state,</blue>
						     user_data_size);
		if (r &lt; 0)
			break;

<blue>		if (r > user_data_size) {</blue>
<yellow>			if (put_user(r, &user_kvm_nested_state->size))</yellow>
				r = -EFAULT;
			else
				r = -E2BIG;
			break;
		}

		r = 0;
		break;
	}
	case KVM_SET_NESTED_STATE: {
		struct kvm_nested_state __user *user_kvm_nested_state = argp;
		struct kvm_nested_state kvm_state;
		int idx;

		r = -EINVAL;
<blue>		if (!kvm_x86_ops.nested_ops->set_state)</blue>
			break;

		r = -EFAULT;
<blue>		if (copy_from_user(&kvm_state, user_kvm_nested_state, sizeof(kvm_state)))</blue>
			break;

		r = -EINVAL;
<blue>		if (kvm_state.size < sizeof(kvm_state))</blue>
			break;

<blue>		if (kvm_state.flags &</blue>
		    ~(KVM_STATE_NESTED_RUN_PENDING | KVM_STATE_NESTED_GUEST_MODE
		      | KVM_STATE_NESTED_EVMCS | KVM_STATE_NESTED_MTF_PENDING
		      | KVM_STATE_NESTED_GIF_SET))
			break;

		/* nested_run_pending implies guest_mode.  */
<blue>		if ((kvm_state.flags & KVM_STATE_NESTED_RUN_PENDING)</blue>
		    &amp;&amp; !(kvm_state.flags &amp; KVM_STATE_NESTED_GUEST_MODE))
			break;

<blue>		idx = srcu_read_lock(&vcpu->kvm->srcu);</blue>
		r = kvm_x86_ops.nested_ops-&gt;set_state(vcpu, user_kvm_nested_state, &amp;kvm_state);
<blue>		srcu_read_unlock(&vcpu->kvm->srcu, idx);</blue>
		break;
	}
	case KVM_GET_SUPPORTED_HV_CPUID:
<yellow>		r = kvm_ioctl_get_supported_hv_cpuid(vcpu, argp);</yellow>
		break;
#ifdef CONFIG_KVM_XEN
	case KVM_XEN_VCPU_GET_ATTR: {
		struct kvm_xen_vcpu_attr xva;

		r = -EFAULT;
<yellow>		if (copy_from_user(&xva, argp, sizeof(xva)))</yellow>
			goto out;
<yellow>		r = kvm_xen_vcpu_get_attr(vcpu, &xva);</yellow>
<yellow>		if (!r && copy_to_user(argp, &xva, sizeof(xva)))</yellow>
			r = -EFAULT;
		break;
	}
	case KVM_XEN_VCPU_SET_ATTR: {
		struct kvm_xen_vcpu_attr xva;

		r = -EFAULT;
<yellow>		if (copy_from_user(&xva, argp, sizeof(xva)))</yellow>
<yellow>			goto out;</yellow>
<yellow>		r = kvm_xen_vcpu_set_attr(vcpu, &xva);</yellow>
		break;
	}
#endif
	case KVM_GET_SREGS2: {
<blue>		u.sregs2 = kzalloc(sizeof(struct kvm_sregs2), GFP_KERNEL);</blue>
		r = -ENOMEM;
		if (!u.sregs2)
			goto out;
<blue>		__get_sregs2(vcpu, u.sregs2);</blue>
		r = -EFAULT;
<blue>		if (copy_to_user(argp, u.sregs2, sizeof(struct kvm_sregs2)))</blue>
			goto out;
		r = 0;
		break;
	}
	case KVM_SET_SREGS2: {
<blue>		u.sregs2 = memdup_user(argp, sizeof(struct kvm_sregs2));</blue>
		if (IS_ERR(u.sregs2)) {
			r = PTR_ERR(u.sregs2);
			u.sregs2 = NULL;
			goto out;
		}
<blue>		r = __set_sregs2(vcpu, u.sregs2);</blue>
<blue>		break;</blue>
	}
	case KVM_HAS_DEVICE_ATTR:
	case KVM_GET_DEVICE_ATTR:
	case KVM_SET_DEVICE_ATTR:
<yellow>		r = kvm_vcpu_ioctl_device_attr(vcpu, ioctl, argp);</yellow>
		break;
	default:
		r = -EINVAL;
	}
out:
<blue>	kfree(u.buffer);</blue>
out_nofree:
<blue>	vcpu_put(vcpu);</blue>
<blue>	return r;</blue>
}

vm_fault_t kvm_arch_vcpu_fault(struct kvm_vcpu *vcpu, struct vm_fault *vmf)
{
	return VM_FAULT_SIGBUS;
<yellow>}</yellow>

static int kvm_vm_ioctl_set_tss_addr(struct kvm *kvm, unsigned long addr)
{
	int ret;

<yellow>	if (addr > (unsigned int)(-3 * PAGE_SIZE))</yellow>
		return -EINVAL;
<yellow>	ret = static_call(kvm_x86_set_tss_addr)(kvm, addr);</yellow>
	return ret;
}

static int kvm_vm_ioctl_set_identity_map_addr(struct kvm *kvm,
					      u64 ident_addr)
{
<yellow>	return static_call(kvm_x86_set_identity_map_addr)(kvm, ident_addr);</yellow>
}

static int kvm_vm_ioctl_set_nr_mmu_pages(struct kvm *kvm,
					 unsigned long kvm_nr_mmu_pages)
{
<yellow>	if (kvm_nr_mmu_pages < KVM_MIN_ALLOC_MMU_PAGES)</yellow>
		return -EINVAL;

<yellow>	mutex_lock(&kvm->slots_lock);</yellow>

	kvm_mmu_change_mmu_pages(kvm, kvm_nr_mmu_pages);
	kvm-&gt;arch.n_requested_mmu_pages = kvm_nr_mmu_pages;

	mutex_unlock(&amp;kvm-&gt;slots_lock);
	return 0;
}

static unsigned long kvm_vm_ioctl_get_nr_mmu_pages(struct kvm *kvm)
{
<yellow>	return kvm->arch.n_max_mmu_pages;</yellow>
}

static int kvm_vm_ioctl_get_irqchip(struct kvm *kvm, struct kvm_irqchip *chip)
{
<yellow>	struct kvm_pic *pic = kvm->arch.vpic;</yellow>
	int r;

	r = 0;
	switch (chip-&gt;chip_id) {
	case KVM_IRQCHIP_PIC_MASTER:
<yellow>		memcpy(&chip->chip.pic, &pic->pics[0],</yellow>
			sizeof(struct kvm_pic_state));
		break;
	case KVM_IRQCHIP_PIC_SLAVE:
<yellow>		memcpy(&chip->chip.pic, &pic->pics[1],</yellow>
			sizeof(struct kvm_pic_state));
		break;
	case KVM_IRQCHIP_IOAPIC:
<yellow>		kvm_get_ioapic(kvm, &chip->chip.ioapic);</yellow>
		break;
	default:
		r = -EINVAL;
		break;
	}
	return r;
}

static int kvm_vm_ioctl_set_irqchip(struct kvm *kvm, struct kvm_irqchip *chip)
{
<yellow>	struct kvm_pic *pic = kvm->arch.vpic;</yellow>
	int r;

	r = 0;
	switch (chip-&gt;chip_id) {
	case KVM_IRQCHIP_PIC_MASTER:
<yellow>		spin_lock(&pic->lock);</yellow>
		memcpy(&amp;pic-&gt;pics[0], &amp;chip-&gt;chip.pic,
			sizeof(struct kvm_pic_state));
		spin_unlock(&amp;pic-&gt;lock);
		break;
	case KVM_IRQCHIP_PIC_SLAVE:
<yellow>		spin_lock(&pic->lock);</yellow>
		memcpy(&amp;pic-&gt;pics[1], &amp;chip-&gt;chip.pic,
			sizeof(struct kvm_pic_state));
		spin_unlock(&amp;pic-&gt;lock);
		break;
	case KVM_IRQCHIP_IOAPIC:
<yellow>		kvm_set_ioapic(kvm, &chip->chip.ioapic);</yellow>
		break;
	default:
		r = -EINVAL;
		break;
	}
<yellow>	kvm_pic_update_irq(pic);</yellow>
	return r;
}

static int kvm_vm_ioctl_get_pit(struct kvm *kvm, struct kvm_pit_state *ps)
{
	struct kvm_kpit_state *kps = &amp;kvm-&gt;arch.vpit-&gt;pit_state;

	BUILD_BUG_ON(sizeof(*ps) != sizeof(kps-&gt;channels));

<yellow>	mutex_lock(&kps->lock);</yellow>
	memcpy(ps, &amp;kps-&gt;channels, sizeof(*ps));
	mutex_unlock(&amp;kps-&gt;lock);
	return 0;
}

static int kvm_vm_ioctl_set_pit(struct kvm *kvm, struct kvm_pit_state *ps)
{
	int i;
	struct kvm_pit *pit = kvm-&gt;arch.vpit;

<yellow>	mutex_lock(&pit->pit_state.lock);</yellow>
	memcpy(&amp;pit-&gt;pit_state.channels, ps, sizeof(*ps));
	for (i = 0; i &lt; 3; i++)
<yellow>		kvm_pit_load_count(pit, i, ps->channels[i].count, 0);</yellow>
<yellow>	mutex_unlock(&pit->pit_state.lock);</yellow>
	return 0;
}

static int kvm_vm_ioctl_get_pit2(struct kvm *kvm, struct kvm_pit_state2 *ps)
{
<yellow>	mutex_lock(&kvm->arch.vpit->pit_state.lock);</yellow>
	memcpy(ps-&gt;channels, &amp;kvm-&gt;arch.vpit-&gt;pit_state.channels,
		sizeof(ps-&gt;channels));
	ps-&gt;flags = kvm-&gt;arch.vpit-&gt;pit_state.flags;
	mutex_unlock(&amp;kvm-&gt;arch.vpit-&gt;pit_state.lock);
	memset(&amp;ps-&gt;reserved, 0, sizeof(ps-&gt;reserved));
	return 0;
}

static int kvm_vm_ioctl_set_pit2(struct kvm *kvm, struct kvm_pit_state2 *ps)
{
	int start = 0;
	int i;
	u32 prev_legacy, cur_legacy;
	struct kvm_pit *pit = kvm-&gt;arch.vpit;

<yellow>	mutex_lock(&pit->pit_state.lock);</yellow>
	prev_legacy = pit-&gt;pit_state.flags &amp; KVM_PIT_FLAGS_HPET_LEGACY;
<yellow>	cur_legacy = ps->flags & KVM_PIT_FLAGS_HPET_LEGACY;</yellow>
	if (!prev_legacy &amp;&amp; cur_legacy)
		start = 1;
<yellow>	memcpy(&pit->pit_state.channels, &ps->channels,</yellow>
	       sizeof(pit-&gt;pit_state.channels));
	pit-&gt;pit_state.flags = ps-&gt;flags;
	for (i = 0; i &lt; 3; i++)
<yellow>		kvm_pit_load_count(pit, i, pit->pit_state.channels[i].count,</yellow>
				   start &amp;&amp; i == 0);
<yellow>	mutex_unlock(&pit->pit_state.lock);</yellow>
	return 0;
}

static int kvm_vm_ioctl_reinject(struct kvm *kvm,
				 struct kvm_reinject_control *control)
{
	struct kvm_pit *pit = kvm-&gt;arch.vpit;

	/* pit-&gt;pit_state.lock was overloaded to prevent userspace from getting
	 * an inconsistent state after running multiple KVM_REINJECT_CONTROL
	 * ioctls in parallel.  Use a separate lock if that ioctl isn&#x27;t rare.
	 */
<yellow>	mutex_lock(&pit->pit_state.lock);</yellow>
	kvm_pit_set_reinject(pit, control-&gt;pit_reinject);
	mutex_unlock(&amp;pit-&gt;pit_state.lock);

	return 0;
}

void kvm_arch_sync_dirty_log(struct kvm *kvm, struct kvm_memory_slot *memslot)
<yellow>{</yellow>

	/*
	 * Flush all CPUs&#x27; dirty log buffers to the  dirty_bitmap.  Called
	 * before reporting dirty_bitmap to userspace.  KVM flushes the buffers
	 * on all VM-Exits, thus we only need to kick running vCPUs to force a
	 * VM-Exit.
	 */
	struct kvm_vcpu *vcpu;
	unsigned long i;

<yellow>	kvm_for_each_vcpu(i, vcpu, kvm)</yellow>
<yellow>		kvm_vcpu_kick(vcpu);</yellow>
}

int kvm_vm_ioctl_irq_line(struct kvm *kvm, struct kvm_irq_level *irq_event,
			bool line_status)
{
<blue>	if (!irqchip_in_kernel(kvm))</blue>
		return -ENXIO;

	irq_event-&gt;status = kvm_set_irq(kvm, KVM_USERSPACE_IRQ_SOURCE_ID,
<blue>					irq_event->irq, irq_event->level,</blue>
					line_status);
	return 0;
<blue>}</blue>

int kvm_vm_ioctl_enable_cap(struct kvm *kvm,
			    struct kvm_enable_cap *cap)
<yellow>{</yellow>
	int r;

<yellow>	if (cap->flags)</yellow>
		return -EINVAL;

<yellow>	switch (cap->cap) {</yellow>
	case KVM_CAP_DISABLE_QUIRKS2:
		r = -EINVAL;
<yellow>		if (cap->args[0] & ~KVM_X86_VALID_QUIRKS)</yellow>
			break;
		fallthrough;
	case KVM_CAP_DISABLE_QUIRKS:
<yellow>		kvm->arch.disabled_quirks = cap->args[0];</yellow>
		r = 0;
		break;
	case KVM_CAP_SPLIT_IRQCHIP: {
<yellow>		mutex_lock(&kvm->lock);</yellow>
		r = -EINVAL;
		if (cap-&gt;args[0] &gt; MAX_NR_RESERVED_IOAPIC_PINS)
			goto split_irqchip_unlock;
		r = -EEXIST;
<yellow>		if (irqchip_in_kernel(kvm))</yellow>
			goto split_irqchip_unlock;
<yellow>		if (kvm->created_vcpus)</yellow>
			goto split_irqchip_unlock;
<yellow>		r = kvm_setup_empty_irq_routing(kvm);</yellow>
		if (r)
			goto split_irqchip_unlock;
		/* Pairs with irqchip_in_kernel. */
		smp_wmb();
<yellow>		kvm->arch.irqchip_mode = KVM_IRQCHIP_SPLIT;</yellow>
		kvm-&gt;arch.nr_reserved_ioapic_pins = cap-&gt;args[0];
<yellow>		kvm_clear_apicv_inhibit(kvm, APICV_INHIBIT_REASON_ABSENT);</yellow>
		r = 0;
split_irqchip_unlock:
		mutex_unlock(&amp;kvm-&gt;lock);
		break;
	}
	case KVM_CAP_X2APIC_API:
		r = -EINVAL;
<yellow>		if (cap->args[0] & ~KVM_X2APIC_API_VALID_FLAGS)</yellow>
			break;

<yellow>		if (cap->args[0] & KVM_X2APIC_API_USE_32BIT_IDS)</yellow>
<yellow>			kvm->arch.x2apic_format = true;</yellow>
<yellow>		if (cap->args[0] & KVM_X2APIC_API_DISABLE_BROADCAST_QUIRK)</yellow>
<yellow>			kvm->arch.x2apic_broadcast_quirk_disabled = true;</yellow>

		r = 0;
		break;
	case KVM_CAP_X86_DISABLE_EXITS:
		r = -EINVAL;
<yellow>		if (cap->args[0] & ~KVM_X86_DISABLE_VALID_EXITS)</yellow>
			break;

<yellow>		if (cap->args[0] & KVM_X86_DISABLE_EXITS_PAUSE)</yellow>
<yellow>			kvm->arch.pause_in_guest = true;</yellow>

#define SMT_RSB_MSG &quot;This processor is affected by the Cross-Thread Return Predictions vulnerability. &quot; \
		    &quot;KVM_CAP_X86_DISABLE_EXITS should only be used with SMT disabled or trusted guests.&quot;

<yellow>		if (!mitigate_smt_rsb) {</yellow>
<yellow>			if (boot_cpu_has_bug(X86_BUG_SMT_RSB) && cpu_smt_possible() &&</yellow>
<yellow>			    (cap->args[0] & ~KVM_X86_DISABLE_EXITS_PAUSE))</yellow>
<yellow>				pr_warn_once(SMT_RSB_MSG);</yellow>

<yellow>			if ((cap->args[0] & KVM_X86_DISABLE_EXITS_MWAIT) &&</yellow>
<yellow>			    kvm_can_mwait_in_guest())</yellow>
<yellow>				kvm->arch.mwait_in_guest = true;</yellow>
<yellow>			if (cap->args[0] & KVM_X86_DISABLE_EXITS_HLT)</yellow>
<yellow>				kvm->arch.hlt_in_guest = true;</yellow>
<yellow>			if (cap->args[0] & KVM_X86_DISABLE_EXITS_CSTATE)</yellow>
<yellow>				kvm->arch.cstate_in_guest = true;</yellow>
		}

		r = 0;
		break;
	case KVM_CAP_MSR_PLATFORM_INFO:
<yellow>		kvm->arch.guest_can_read_msr_platform_info = cap->args[0];</yellow>
		r = 0;
		break;
	case KVM_CAP_EXCEPTION_PAYLOAD:
<yellow>		kvm->arch.exception_payload_enabled = cap->args[0];</yellow>
		r = 0;
		break;
	case KVM_CAP_X86_TRIPLE_FAULT_EVENT:
<yellow>		kvm->arch.triple_fault_event = cap->args[0];</yellow>
		r = 0;
		break;
	case KVM_CAP_X86_USER_SPACE_MSR:
		r = -EINVAL;
<yellow>		if (cap->args[0] & ~KVM_MSR_EXIT_REASON_VALID_MASK)</yellow>
			break;
<yellow>		kvm->arch.user_space_msr_mask = cap->args[0];</yellow>
		r = 0;
		break;
	case KVM_CAP_X86_BUS_LOCK_EXIT:
		r = -EINVAL;
<yellow>		if (cap->args[0] & ~KVM_BUS_LOCK_DETECTION_VALID_MODE)</yellow>
			break;

<yellow>		if ((cap->args[0] & KVM_BUS_LOCK_DETECTION_OFF) &&</yellow>
		    (cap-&gt;args[0] &amp; KVM_BUS_LOCK_DETECTION_EXIT))
			break;

<yellow>		if (kvm_caps.has_bus_lock_exit &&</yellow>
<yellow>		    cap->args[0] & KVM_BUS_LOCK_DETECTION_EXIT)</yellow>
<yellow>			kvm->arch.bus_lock_detection_enabled = true;</yellow>
		r = 0;
		break;
#ifdef CONFIG_X86_SGX_KVM
	case KVM_CAP_SGX_ATTRIBUTE: {
		unsigned long allowed_attributes = 0;

<yellow>		r = sgx_set_attribute(&allowed_attributes, cap->args[0]);</yellow>
		if (r)
			break;

		/* KVM only supports the PROVISIONKEY privileged attribute. */
<yellow>		if ((allowed_attributes & SGX_ATTR_PROVISIONKEY) &&</yellow>
		    !(allowed_attributes &amp; ~SGX_ATTR_PROVISIONKEY))
<yellow>			kvm->arch.sgx_provisioning_allowed = true;</yellow>
		else
<yellow>			r = -EINVAL;</yellow>
		break;
	}
#endif
	case KVM_CAP_VM_COPY_ENC_CONTEXT_FROM:
		r = -EINVAL;
<yellow>		if (!kvm_x86_ops.vm_copy_enc_context_from)</yellow>
			break;

<yellow>		r = static_call(kvm_x86_vm_copy_enc_context_from)(kvm, cap->args[0]);</yellow>
		break;
	case KVM_CAP_VM_MOVE_ENC_CONTEXT_FROM:
		r = -EINVAL;
<yellow>		if (!kvm_x86_ops.vm_move_enc_context_from)</yellow>
			break;

<yellow>		r = static_call(kvm_x86_vm_move_enc_context_from)(kvm, cap->args[0]);</yellow>
		break;
	case KVM_CAP_EXIT_HYPERCALL:
<yellow>		if (cap->args[0] & ~KVM_EXIT_HYPERCALL_VALID_MASK) {</yellow>
			r = -EINVAL;
			break;
		}
<yellow>		kvm->arch.hypercall_exit_enabled = cap->args[0];</yellow>
		r = 0;
		break;
	case KVM_CAP_EXIT_ON_EMULATION_FAILURE:
		r = -EINVAL;
<yellow>		if (cap->args[0] & ~1)</yellow>
			break;
<yellow>		kvm->arch.exit_on_emulation_error = cap->args[0];</yellow>
		r = 0;
		break;
	case KVM_CAP_PMU_CAPABILITY:
		r = -EINVAL;
<yellow>		if (!enable_pmu || (cap->args[0] & ~KVM_CAP_PMU_VALID_MASK))</yellow>
			break;

<yellow>		mutex_lock(&kvm->lock);</yellow>
		if (!kvm-&gt;created_vcpus) {
<yellow>			kvm->arch.enable_pmu = !(cap->args[0] & KVM_PMU_CAP_DISABLE);</yellow>
			r = 0;
		}
		mutex_unlock(&amp;kvm-&gt;lock);
		break;
	case KVM_CAP_MAX_VCPU_ID:
		r = -EINVAL;
<yellow>		if (cap->args[0] > KVM_MAX_VCPU_IDS)</yellow>
			break;

<yellow>		mutex_lock(&kvm->lock);</yellow>
		if (kvm-&gt;arch.max_vcpu_ids == cap-&gt;args[0]) {
			r = 0;
<yellow>		} else if (!kvm->arch.max_vcpu_ids) {</yellow>
			kvm-&gt;arch.max_vcpu_ids = cap-&gt;args[0];
<yellow>			r = 0;</yellow>
		}
		mutex_unlock(&amp;kvm-&gt;lock);
		break;
	case KVM_CAP_X86_NOTIFY_VMEXIT:
		r = -EINVAL;
<yellow>		if ((u32)cap->args[0] & ~KVM_X86_NOTIFY_VMEXIT_VALID_BITS)</yellow>
			break;
<yellow>		if (!kvm_caps.has_notify_vmexit)</yellow>
			break;
<yellow>		if (!((u32)cap->args[0] & KVM_X86_NOTIFY_VMEXIT_ENABLED))</yellow>
			break;
<yellow>		mutex_lock(&kvm->lock);</yellow>
		if (!kvm-&gt;created_vcpus) {
<yellow>			kvm->arch.notify_window = cap->args[0] >> 32;</yellow>
			kvm-&gt;arch.notify_vmexit_flags = (u32)cap-&gt;args[0];
			r = 0;
		}
		mutex_unlock(&amp;kvm-&gt;lock);
		break;
	case KVM_CAP_VM_DISABLE_NX_HUGE_PAGES:
		r = -EINVAL;

		/*
		 * Since the risk of disabling NX hugepages is a guest crashing
		 * the system, ensure the userspace process has permission to
		 * reboot the system.
		 *
		 * Note that unlike the reboot() syscall, the process must have
		 * this capability in the root namespace because exposing
		 * /dev/kvm into a container does not limit the scope of the
		 * iTLB multihit bug to that container. In other words,
		 * this must use capable(), not ns_capable().
		 */
<yellow>		if (!capable(CAP_SYS_BOOT)) {</yellow>
			r = -EPERM;
			break;
		}

<yellow>		if (cap->args[0])</yellow>
			break;

<yellow>		mutex_lock(&kvm->lock);</yellow>
		if (!kvm-&gt;created_vcpus) {
<yellow>			kvm->arch.disable_nx_huge_pages = true;</yellow>
			r = 0;
		}
<yellow>		mutex_unlock(&kvm->lock);</yellow>
		break;
	default:
		r = -EINVAL;
		break;
	}
	return r;
}

static struct kvm_x86_msr_filter *kvm_alloc_msr_filter(bool default_allow)
{
	struct kvm_x86_msr_filter *msr_filter;

<yellow>	msr_filter = kzalloc(sizeof(*msr_filter), GFP_KERNEL_ACCOUNT);</yellow>
	if (!msr_filter)
		return NULL;

<yellow>	msr_filter->default_allow = default_allow;</yellow>
	return msr_filter;
}

<yellow>static void kvm_free_msr_filter(struct kvm_x86_msr_filter *msr_filter)</yellow>
{
	u32 i;

	if (!msr_filter)
		return;

<yellow>	for (i = 0; i < msr_filter->count; i++)</yellow>
<yellow>		kfree(msr_filter->ranges[i].bitmap);</yellow>

<yellow>	kfree(msr_filter);</yellow>
}

static int kvm_add_msr_filter(struct kvm_x86_msr_filter *msr_filter,
			      struct kvm_msr_filter_range *user_range)
{
	unsigned long *bitmap = NULL;
	size_t bitmap_size;

<yellow>	if (!user_range->nmsrs)</yellow>
		return 0;

<yellow>	if (user_range->flags & ~KVM_MSR_FILTER_RANGE_VALID_MASK)</yellow>
		return -EINVAL;

<yellow>	if (!user_range->flags)</yellow>
		return -EINVAL;

<yellow>	bitmap_size = BITS_TO_LONGS(user_range->nmsrs) * sizeof(long);</yellow>
	if (!bitmap_size || bitmap_size &gt; KVM_MSR_FILTER_MAX_BITMAP_SIZE)
		return -EINVAL;

<yellow>	bitmap = memdup_user((__user u8*)user_range->bitmap, bitmap_size);</yellow>
	if (IS_ERR(bitmap))
		return PTR_ERR(bitmap);

<yellow>	msr_filter->ranges[msr_filter->count] = (struct msr_bitmap_range) {</yellow>
		.flags = user_range-&gt;flags,
		.base = user_range-&gt;base,
		.nmsrs = user_range-&gt;nmsrs,
		.bitmap = bitmap,
	};

	msr_filter-&gt;count++;
	return 0;
}

static int kvm_vm_ioctl_set_msr_filter(struct kvm *kvm,
				       struct kvm_msr_filter *filter)
{
	struct kvm_x86_msr_filter *new_filter, *old_filter;
	bool default_allow;
	bool empty = true;
	int r = 0;
	u32 i;

<yellow>	if (filter->flags & ~KVM_MSR_FILTER_VALID_MASK)</yellow>
		return -EINVAL;

	for (i = 0; i &lt; ARRAY_SIZE(filter-&gt;ranges); i++)
<yellow>		empty &= !filter->ranges[i].nmsrs;</yellow>

<yellow>	default_allow = !(filter->flags & KVM_MSR_FILTER_DEFAULT_DENY);</yellow>
<yellow>	if (empty && !default_allow)</yellow>
		return -EINVAL;

<yellow>	new_filter = kvm_alloc_msr_filter(default_allow);</yellow>
	if (!new_filter)
		return -ENOMEM;

<yellow>	for (i = 0; i < ARRAY_SIZE(filter->ranges); i++) {</yellow>
<yellow>		r = kvm_add_msr_filter(new_filter, &filter->ranges[i]);</yellow>
<yellow>		if (r) {</yellow>
<yellow>			kvm_free_msr_filter(new_filter);</yellow>
			return r;
		}
	}

<yellow>	mutex_lock(&kvm->lock);</yellow>

	/* The per-VM filter is protected by kvm-&gt;lock... */
	old_filter = srcu_dereference_check(kvm-&gt;arch.msr_filter, &amp;kvm-&gt;srcu, 1);

	rcu_assign_pointer(kvm-&gt;arch.msr_filter, new_filter);
	synchronize_srcu(&amp;kvm-&gt;srcu);

<yellow>	kvm_free_msr_filter(old_filter);</yellow>

<yellow>	kvm_make_all_cpus_request(kvm, KVM_REQ_MSR_FILTER_CHANGED);</yellow>
	mutex_unlock(&amp;kvm-&gt;lock);

	return 0;
<yellow>}</yellow>

#ifdef CONFIG_KVM_COMPAT
/* for KVM_X86_SET_MSR_FILTER */
struct kvm_msr_filter_range_compat {
	__u32 flags;
	__u32 nmsrs;
	__u32 base;
	__u32 bitmap;
};

struct kvm_msr_filter_compat {
	__u32 flags;
	struct kvm_msr_filter_range_compat ranges[KVM_MSR_FILTER_MAX_RANGES];
};

#define KVM_X86_SET_MSR_FILTER_COMPAT _IOW(KVMIO, 0xc6, struct kvm_msr_filter_compat)

long kvm_arch_vm_compat_ioctl(struct file *filp, unsigned int ioctl,
			      unsigned long arg)
<yellow>{</yellow>
	void __user *argp = (void __user *)arg;
<yellow>	struct kvm *kvm = filp->private_data;</yellow>
	long r = -ENOTTY;

	switch (ioctl) {
	case KVM_X86_SET_MSR_FILTER_COMPAT: {
		struct kvm_msr_filter __user *user_msr_filter = argp;
		struct kvm_msr_filter_compat filter_compat;
		struct kvm_msr_filter filter;
		int i;

<yellow>		if (copy_from_user(&filter_compat, user_msr_filter,</yellow>
				   sizeof(filter_compat)))
<yellow>			return -EFAULT;</yellow>

<yellow>		filter.flags = filter_compat.flags;</yellow>
		for (i = 0; i &lt; ARRAY_SIZE(filter.ranges); i++) {
			struct kvm_msr_filter_range_compat *cr;

<yellow>			cr = &filter_compat.ranges[i];</yellow>
			filter.ranges[i] = (struct kvm_msr_filter_range) {
				.flags = cr-&gt;flags,
				.nmsrs = cr-&gt;nmsrs,
				.base = cr-&gt;base,
				.bitmap = (__u8 *)(ulong)cr-&gt;bitmap,
			};
		}

<yellow>		r = kvm_vm_ioctl_set_msr_filter(kvm, &filter);</yellow>
		break;
	}
	}

	return r;
}
#endif

#ifdef CONFIG_HAVE_KVM_PM_NOTIFIER
static int kvm_arch_suspend_notifier(struct kvm *kvm)
{
	struct kvm_vcpu *vcpu;
	unsigned long i;
	int ret = 0;

<yellow>	mutex_lock(&kvm->lock);</yellow>
<yellow>	kvm_for_each_vcpu(i, vcpu, kvm) {</yellow>
<yellow>		if (!vcpu->arch.pv_time.active)</yellow>
			continue;

<yellow>		ret = kvm_set_guest_paused(vcpu);</yellow>
		if (ret) {
			kvm_err(&quot;Failed to pause guest VCPU%d: %d\n&quot;,
				vcpu-&gt;vcpu_id, ret);
			break;
		}
	}
<yellow>	mutex_unlock(&kvm->lock);</yellow>

	return ret ? NOTIFY_BAD : NOTIFY_DONE;
}

int kvm_arch_pm_notifier(struct kvm *kvm, unsigned long state)
<yellow>{</yellow>
<yellow>	switch (state) {</yellow>
	case PM_HIBERNATION_PREPARE:
	case PM_SUSPEND_PREPARE:
<yellow>		return kvm_arch_suspend_notifier(kvm);</yellow>
	}

	return NOTIFY_DONE;
}
#endif /* CONFIG_HAVE_KVM_PM_NOTIFIER */

static int kvm_vm_ioctl_get_clock(struct kvm *kvm, void __user *argp)
{
<yellow>	struct kvm_clock_data data = { 0 };</yellow>

<yellow>	get_kvmclock(kvm, &data);</yellow>
<yellow>	if (copy_to_user(argp, &data, sizeof(data)))</yellow>
		return -EFAULT;

	return 0;
}

static int kvm_vm_ioctl_set_clock(struct kvm *kvm, void __user *argp)
{
	struct kvm_arch *ka = &amp;kvm-&gt;arch;
	struct kvm_clock_data data;
	u64 now_raw_ns;

<yellow>	if (copy_from_user(&data, argp, sizeof(data)))</yellow>
		return -EFAULT;

	/*
	 * Only KVM_CLOCK_REALTIME is used, but allow passing the
	 * result of KVM_GET_CLOCK back to KVM_SET_CLOCK.
	 */
<yellow>	if (data.flags & ~KVM_CLOCK_VALID_FLAGS)</yellow>
		return -EINVAL;

<yellow>	kvm_hv_request_tsc_page_update(kvm);</yellow>
	kvm_start_pvclock_update(kvm);
	pvclock_update_vm_gtod_copy(kvm);

	/*
	 * This pairs with kvm_guest_time_update(): when masterclock is
	 * in use, we use master_kernel_ns + kvmclock_offset to set
	 * unsigned &#x27;system_time&#x27; so if we use get_kvmclock_ns() (which
	 * is slightly ahead) here we risk going negative on unsigned
	 * &#x27;system_time&#x27; when &#x27;data.clock&#x27; is very small.
	 */
	if (data.flags &amp; KVM_CLOCK_REALTIME) {
<yellow>		u64 now_real_ns = ktime_get_real_ns();</yellow>

		/*
		 * Avoid stepping the kvmclock backwards.
		 */
		if (now_real_ns &gt; data.realtime)
<yellow>			data.clock += now_real_ns - data.realtime;</yellow>
	}

<yellow>	if (ka->use_master_clock)</yellow>
<yellow>		now_raw_ns = ka->master_kernel_ns;</yellow>
	else
<yellow>		now_raw_ns = get_kvmclock_base_ns();</yellow>
<yellow>	ka->kvmclock_offset = data.clock - now_raw_ns;</yellow>
	kvm_end_pvclock_update(kvm);
	return 0;
}

long kvm_arch_vm_ioctl(struct file *filp,
		       unsigned int ioctl, unsigned long arg)
<blue>{</blue>
<blue>	struct kvm *kvm = filp->private_data;</blue>
	void __user *argp = (void __user *)arg;
	int r = -ENOTTY;
	/*
	 * This union makes it completely explicit to gcc-3.x
	 * that these two variables&#x27; stack usage should be
	 * combined, not added together.
	 */
	union {
		struct kvm_pit_state ps;
		struct kvm_pit_state2 ps2;
		struct kvm_pit_config pit_config;
	} u;

	switch (ioctl) {
	case KVM_SET_TSS_ADDR:
<yellow>		r = kvm_vm_ioctl_set_tss_addr(kvm, arg);</yellow>
		break;
	case KVM_SET_IDENTITY_MAP_ADDR: {
		u64 ident_addr;

<yellow>		mutex_lock(&kvm->lock);</yellow>
		r = -EINVAL;
		if (kvm-&gt;created_vcpus)
			goto set_identity_unlock;
		r = -EFAULT;
<yellow>		if (copy_from_user(&ident_addr, argp, sizeof(ident_addr)))</yellow>
			goto set_identity_unlock;
<yellow>		r = kvm_vm_ioctl_set_identity_map_addr(kvm, ident_addr);</yellow>
set_identity_unlock:
<yellow>		mutex_unlock(&kvm->lock);</yellow>
		break;
	}
	case KVM_SET_NR_MMU_PAGES:
<yellow>		r = kvm_vm_ioctl_set_nr_mmu_pages(kvm, arg);</yellow>
		break;
	case KVM_GET_NR_MMU_PAGES:
<yellow>		r = kvm_vm_ioctl_get_nr_mmu_pages(kvm);</yellow>
		break;
	case KVM_CREATE_IRQCHIP: {
<blue>		mutex_lock(&kvm->lock);</blue>

		r = -EEXIST;
		if (irqchip_in_kernel(kvm))
			goto create_irqchip_unlock;

		r = -EINVAL;
<blue>		if (kvm->created_vcpus)</blue>
			goto create_irqchip_unlock;

<blue>		r = kvm_pic_init(kvm);</blue>
		if (r)
			goto create_irqchip_unlock;

<blue>		r = kvm_ioapic_init(kvm);</blue>
		if (r) {
<yellow>			kvm_pic_destroy(kvm);</yellow>
			goto create_irqchip_unlock;
		}

<blue>		r = kvm_setup_default_irq_routing(kvm);</blue>
		if (r) {
<yellow>			kvm_ioapic_destroy(kvm);</yellow>
			kvm_pic_destroy(kvm);
			goto create_irqchip_unlock;
		}
		/* Write kvm-&gt;irq_routing before enabling irqchip_in_kernel. */
		smp_wmb();
<blue>		kvm->arch.irqchip_mode = KVM_IRQCHIP_KERNEL;</blue>
<blue>		kvm_clear_apicv_inhibit(kvm, APICV_INHIBIT_REASON_ABSENT);</blue>
	create_irqchip_unlock:
		mutex_unlock(&amp;kvm-&gt;lock);
		break;
	}
	case KVM_CREATE_PIT:
<yellow>		u.pit_config.flags = KVM_PIT_SPEAKER_DUMMY;</yellow>
		goto create_pit;
	case KVM_CREATE_PIT2:
		r = -EFAULT;
<yellow>		if (copy_from_user(&u.pit_config, argp,</yellow>
				   sizeof(struct kvm_pit_config)))
			goto out;
	create_pit:
<yellow>		mutex_lock(&kvm->lock);</yellow>
		r = -EEXIST;
		if (kvm-&gt;arch.vpit)
			goto create_pit_unlock;
		r = -ENOMEM;
<yellow>		kvm->arch.vpit = kvm_create_pit(kvm, u.pit_config.flags);</yellow>
		if (kvm-&gt;arch.vpit)
			r = 0;
	create_pit_unlock:
<yellow>		mutex_unlock(&kvm->lock);</yellow>
		break;
	case KVM_GET_IRQCHIP: {
		/* 0: PIC master, 1: PIC slave, 2: IOAPIC */
		struct kvm_irqchip *chip;

<yellow>		chip = memdup_user(argp, sizeof(*chip));</yellow>
		if (IS_ERR(chip)) {
			r = PTR_ERR(chip);
			goto out;
		}

		r = -ENXIO;
<yellow>		if (!irqchip_kernel(kvm))</yellow>
			goto get_irqchip_out;
<yellow>		r = kvm_vm_ioctl_get_irqchip(kvm, chip);</yellow>
		if (r)
			goto get_irqchip_out;
		r = -EFAULT;
<yellow>		if (copy_to_user(argp, chip, sizeof(*chip)))</yellow>
			goto get_irqchip_out;
		r = 0;
	get_irqchip_out:
<yellow>		kfree(chip);</yellow>
		break;
	}
	case KVM_SET_IRQCHIP: {
		/* 0: PIC master, 1: PIC slave, 2: IOAPIC */
		struct kvm_irqchip *chip;

<yellow>		chip = memdup_user(argp, sizeof(*chip));</yellow>
		if (IS_ERR(chip)) {
			r = PTR_ERR(chip);
			goto out;
		}

		r = -ENXIO;
<yellow>		if (!irqchip_kernel(kvm))</yellow>
			goto set_irqchip_out;
<yellow>		r = kvm_vm_ioctl_set_irqchip(kvm, chip);</yellow>
	set_irqchip_out:
<yellow>		kfree(chip);</yellow>
		break;
	}
	case KVM_GET_PIT: {
		r = -EFAULT;
<yellow>		if (copy_from_user(&u.ps, argp, sizeof(struct kvm_pit_state)))</yellow>
			goto out;
		r = -ENXIO;
<yellow>		if (!kvm->arch.vpit)</yellow>
			goto out;
<yellow>		r = kvm_vm_ioctl_get_pit(kvm, &u.ps);</yellow>
		if (r)
			goto out;
		r = -EFAULT;
		if (copy_to_user(argp, &amp;u.ps, sizeof(struct kvm_pit_state)))
			goto out;
		r = 0;
		break;
	}
	case KVM_SET_PIT: {
		r = -EFAULT;
<yellow>		if (copy_from_user(&u.ps, argp, sizeof(u.ps)))</yellow>
			goto out;
<yellow>		mutex_lock(&kvm->lock);</yellow>
		r = -ENXIO;
		if (!kvm-&gt;arch.vpit)
			goto set_pit_out;
<yellow>		r = kvm_vm_ioctl_set_pit(kvm, &u.ps);</yellow>
set_pit_out:
		mutex_unlock(&amp;kvm-&gt;lock);
		break;
	}
	case KVM_GET_PIT2: {
		r = -ENXIO;
<yellow>		if (!kvm->arch.vpit)</yellow>
			goto out;
<yellow>		r = kvm_vm_ioctl_get_pit2(kvm, &u.ps2);</yellow>
		if (r)
			goto out;
		r = -EFAULT;
		if (copy_to_user(argp, &amp;u.ps2, sizeof(u.ps2)))
			goto out;
		r = 0;
		break;
	}
	case KVM_SET_PIT2: {
		r = -EFAULT;
<yellow>		if (copy_from_user(&u.ps2, argp, sizeof(u.ps2)))</yellow>
			goto out;
<yellow>		mutex_lock(&kvm->lock);</yellow>
		r = -ENXIO;
		if (!kvm-&gt;arch.vpit)
			goto set_pit2_out;
<yellow>		r = kvm_vm_ioctl_set_pit2(kvm, &u.ps2);</yellow>
set_pit2_out:
<yellow>		mutex_unlock(&kvm->lock);</yellow>
		break;
	}
	case KVM_REINJECT_CONTROL: {
		struct kvm_reinject_control control;
		r =  -EFAULT;
<yellow>		if (copy_from_user(&control, argp, sizeof(control)))</yellow>
			goto out;
		r = -ENXIO;
<yellow>		if (!kvm->arch.vpit)</yellow>
			goto out;
<yellow>		r = kvm_vm_ioctl_reinject(kvm, &control);</yellow>
		break;
	}
	case KVM_SET_BOOT_CPU_ID:
		r = 0;
<yellow>		mutex_lock(&kvm->lock);</yellow>
		if (kvm-&gt;created_vcpus)
			r = -EBUSY;
		else
<yellow>			kvm->arch.bsp_vcpu_id = arg;</yellow>
<blue>		mutex_unlock(&kvm->lock);</blue>
		break;
#ifdef CONFIG_KVM_XEN
	case KVM_XEN_HVM_CONFIG: {
		struct kvm_xen_hvm_config xhc;
		r = -EFAULT;
<yellow>		if (copy_from_user(&xhc, argp, sizeof(xhc)))</yellow>
			goto out;
<yellow>		r = kvm_xen_hvm_config(kvm, &xhc);</yellow>
		break;
	}
	case KVM_XEN_HVM_GET_ATTR: {
		struct kvm_xen_hvm_attr xha;

		r = -EFAULT;
<yellow>		if (copy_from_user(&xha, argp, sizeof(xha)))</yellow>
			goto out;
<yellow>		r = kvm_xen_hvm_get_attr(kvm, &xha);</yellow>
<yellow>		if (!r && copy_to_user(argp, &xha, sizeof(xha)))</yellow>
			r = -EFAULT;
		break;
	}
	case KVM_XEN_HVM_SET_ATTR: {
		struct kvm_xen_hvm_attr xha;

		r = -EFAULT;
<yellow>		if (copy_from_user(&xha, argp, sizeof(xha)))</yellow>
			goto out;
<yellow>		r = kvm_xen_hvm_set_attr(kvm, &xha);</yellow>
		break;
	}
	case KVM_XEN_HVM_EVTCHN_SEND: {
		struct kvm_irq_routing_xen_evtchn uxe;

		r = -EFAULT;
<yellow>		if (copy_from_user(&uxe, argp, sizeof(uxe)))</yellow>
			goto out;
<yellow>		r = kvm_xen_hvm_evtchn_send(kvm, &uxe);</yellow>
		break;
	}
#endif
	case KVM_SET_CLOCK:
<yellow>		r = kvm_vm_ioctl_set_clock(kvm, argp);</yellow>
		break;
	case KVM_GET_CLOCK:
<yellow>		r = kvm_vm_ioctl_get_clock(kvm, argp);</yellow>
<yellow>		break;</yellow>
	case KVM_SET_TSC_KHZ: {
		u32 user_tsc_khz;

		r = -EINVAL;
		user_tsc_khz = (u32)arg;

<yellow>		if (kvm_caps.has_tsc_control &&</yellow>
<yellow>		    user_tsc_khz >= kvm_caps.max_guest_tsc_khz)</yellow>
			goto out;

<yellow>		if (user_tsc_khz == 0)</yellow>
<yellow>			user_tsc_khz = tsc_khz;</yellow>

<yellow>		WRITE_ONCE(kvm->arch.default_tsc_khz, user_tsc_khz);</yellow>
		r = 0;

		goto out;
	}
	case KVM_GET_TSC_KHZ: {
<yellow>		r = READ_ONCE(kvm->arch.default_tsc_khz);</yellow>
		goto out;
	}
	case KVM_MEMORY_ENCRYPT_OP: {
		r = -ENOTTY;
<yellow>		if (!kvm_x86_ops.mem_enc_ioctl)</yellow>
			goto out;

<yellow>		r = static_call(kvm_x86_mem_enc_ioctl)(kvm, argp);</yellow>
		break;
	}
	case KVM_MEMORY_ENCRYPT_REG_REGION: {
		struct kvm_enc_region region;

		r = -EFAULT;
<yellow>		if (copy_from_user(&region, argp, sizeof(region)))</yellow>
			goto out;

		r = -ENOTTY;
<yellow>		if (!kvm_x86_ops.mem_enc_register_region)</yellow>
			goto out;

<yellow>		r = static_call(kvm_x86_mem_enc_register_region)(kvm, &region);</yellow>
		break;
	}
	case KVM_MEMORY_ENCRYPT_UNREG_REGION: {
		struct kvm_enc_region region;

		r = -EFAULT;
<yellow>		if (copy_from_user(&region, argp, sizeof(region)))</yellow>
<yellow>			goto out;</yellow>

		r = -ENOTTY;
<yellow>		if (!kvm_x86_ops.mem_enc_unregister_region)</yellow>
			goto out;

<yellow>		r = static_call(kvm_x86_mem_enc_unregister_region)(kvm, &region);</yellow>
		break;
	}
	case KVM_HYPERV_EVENTFD: {
		struct kvm_hyperv_eventfd hvevfd;

		r = -EFAULT;
<yellow>		if (copy_from_user(&hvevfd, argp, sizeof(hvevfd)))</yellow>
			goto out;
<yellow>		r = kvm_vm_ioctl_hv_eventfd(kvm, &hvevfd);</yellow>
		break;
	}
	case KVM_SET_PMU_EVENT_FILTER:
<yellow>		r = kvm_vm_ioctl_set_pmu_event_filter(kvm, argp);</yellow>
		break;
	case KVM_X86_SET_MSR_FILTER: {
		struct kvm_msr_filter __user *user_msr_filter = argp;
		struct kvm_msr_filter filter;

<yellow>		if (copy_from_user(&filter, user_msr_filter, sizeof(filter)))</yellow>
<yellow>			return -EFAULT;</yellow>

<yellow>		r = kvm_vm_ioctl_set_msr_filter(kvm, &filter);</yellow>
		break;
	}
	default:
		r = -ENOTTY;
	}
out:
<yellow>	return r;</yellow>
}

static void kvm_init_msr_list(void)
{
	u32 dummy[2];
	unsigned i;

	BUILD_BUG_ON_MSG(KVM_PMC_MAX_FIXED != 3,
			 &quot;Please update the fixed PMCs in msrs_to_saved_all[]&quot;);

	num_msrs_to_save = 0;
	num_emulated_msrs = 0;
	num_msr_based_features = 0;

<yellow>	for (i = 0; i < ARRAY_SIZE(msrs_to_save_all); i++) {</yellow>
<yellow>		if (rdmsr_safe(msrs_to_save_all[i], &dummy[0], &dummy[1]) < 0)</yellow>
			continue;

		/*
		 * Even MSRs that are valid in the host may not be exposed
		 * to the guests in some cases.
		 */
<yellow>		switch (msrs_to_save_all[i]) {</yellow>
		case MSR_IA32_BNDCFGS:
<yellow>			if (!kvm_mpx_supported())</yellow>
				continue;
			break;
		case MSR_TSC_AUX:
<yellow>			if (!kvm_cpu_cap_has(X86_FEATURE_RDTSCP) &&</yellow>
			    !kvm_cpu_cap_has(X86_FEATURE_RDPID))
				continue;
			break;
		case MSR_IA32_UMWAIT_CONTROL:
<yellow>			if (!kvm_cpu_cap_has(X86_FEATURE_WAITPKG))</yellow>
				continue;
			break;
		case MSR_IA32_RTIT_CTL:
		case MSR_IA32_RTIT_STATUS:
<yellow>			if (!kvm_cpu_cap_has(X86_FEATURE_INTEL_PT))</yellow>
				continue;
			break;
		case MSR_IA32_RTIT_CR3_MATCH:
<yellow>			if (!kvm_cpu_cap_has(X86_FEATURE_INTEL_PT) ||</yellow>
<yellow>			    !intel_pt_validate_hw_cap(PT_CAP_cr3_filtering))</yellow>
				continue;
			break;
		case MSR_IA32_RTIT_OUTPUT_BASE:
		case MSR_IA32_RTIT_OUTPUT_MASK:
<yellow>			if (!kvm_cpu_cap_has(X86_FEATURE_INTEL_PT) ||</yellow>
<yellow>				(!intel_pt_validate_hw_cap(PT_CAP_topa_output) &&</yellow>
<yellow>				 !intel_pt_validate_hw_cap(PT_CAP_single_range_output)))</yellow>
				continue;
			break;
		case MSR_IA32_RTIT_ADDR0_A ... MSR_IA32_RTIT_ADDR3_B:
<yellow>			if (!kvm_cpu_cap_has(X86_FEATURE_INTEL_PT) ||</yellow>
<yellow>				msrs_to_save_all[i] - MSR_IA32_RTIT_ADDR0_A >=</yellow>
				intel_pt_validate_hw_cap(PT_CAP_num_address_ranges) * 2)
				continue;
			break;
		case MSR_ARCH_PERFMON_PERFCTR0 ... MSR_ARCH_PERFMON_PERFCTR_MAX:
<yellow>			if (msrs_to_save_all[i] - MSR_ARCH_PERFMON_PERFCTR0 >=</yellow>
			    min(KVM_INTEL_PMC_MAX_GENERIC, kvm_pmu_cap.num_counters_gp))
				continue;
			break;
		case MSR_ARCH_PERFMON_EVENTSEL0 ... MSR_ARCH_PERFMON_EVENTSEL_MAX:
<yellow>			if (msrs_to_save_all[i] - MSR_ARCH_PERFMON_EVENTSEL0 >=</yellow>
			    min(KVM_INTEL_PMC_MAX_GENERIC, kvm_pmu_cap.num_counters_gp))
				continue;
			break;
		case MSR_IA32_XFD:
		case MSR_IA32_XFD_ERR:
<yellow>			if (!kvm_cpu_cap_has(X86_FEATURE_XFD))</yellow>
				continue;
			break;
		default:
			break;
		}

<yellow>		msrs_to_save[num_msrs_to_save++] = msrs_to_save_all[i];</yellow>
	}

<yellow>	for (i = 0; i < ARRAY_SIZE(emulated_msrs_all); i++) {</yellow>
<yellow>		if (!static_call(kvm_x86_has_emulated_msr)(NULL, emulated_msrs_all[i]))</yellow>
			continue;

<yellow>		emulated_msrs[num_emulated_msrs++] = emulated_msrs_all[i];</yellow>
	}

<yellow>	for (i = 0; i < ARRAY_SIZE(msr_based_features_all); i++) {</yellow>
		struct kvm_msr_entry msr;

<yellow>		msr.index = msr_based_features_all[i];</yellow>
<yellow>		if (kvm_get_msr_feature(&msr))</yellow>
			continue;

<yellow>		msr_based_features[num_msr_based_features++] = msr_based_features_all[i];</yellow>
	}
}

static int vcpu_mmio_write(struct kvm_vcpu *vcpu, gpa_t addr, int len,
			   const void *v)
{
	int handled = 0;
	int n;

	do {
<blue>		n = min(len, 8);</blue>
<yellow>		if (!(lapic_in_kernel(vcpu) &&</yellow>
<blue>		      !kvm_iodevice_write(vcpu, &vcpu->arch.apic->dev, addr, n, v))</blue>
<blue>		    && kvm_io_bus_write(vcpu, KVM_MMIO_BUS, addr, n, v))</blue>
			break;
		handled += n;
		addr += n;
<blue>		len -= n;</blue>
		v += n;
	} while (len);

	return handled;
}

static int vcpu_mmio_read(struct kvm_vcpu *vcpu, gpa_t addr, int len, void *v)
{
	int handled = 0;
	int n;

	do {
<blue>		n = min(len, 8);</blue>
<yellow>		if (!(lapic_in_kernel(vcpu) &&</yellow>
<blue>		      !kvm_iodevice_read(vcpu, &vcpu->arch.apic->dev,</blue>
					 addr, n, v))
<blue>		    && kvm_io_bus_read(vcpu, KVM_MMIO_BUS, addr, n, v))</blue>
			break;
<blue>		trace_kvm_mmio(KVM_TRACE_MMIO_READ, n, addr, v);</blue>
		handled += n;
		addr += n;
<blue>		len -= n;</blue>
		v += n;
	} while (len);

	return handled;
<blue>}</blue>

void kvm_set_segment(struct kvm_vcpu *vcpu,
		     struct kvm_segment *var, int seg)
{
<blue>	static_call(kvm_x86_set_segment)(vcpu, var, seg);</blue>
}

void kvm_get_segment(struct kvm_vcpu *vcpu,
		     struct kvm_segment *var, int seg)
{
<blue>	static_call(kvm_x86_get_segment)(vcpu, var, seg);</blue>
}

gpa_t translate_nested_gpa(struct kvm_vcpu *vcpu, gpa_t gpa, u64 access,
			   struct x86_exception *exception)
{
<blue>	struct kvm_mmu *mmu = vcpu->arch.mmu;</blue>
	gpa_t t_gpa;

<yellow>	BUG_ON(!mmu_is_nested(vcpu));</yellow>

	/* NPT walks are always user-walks */
	access |= PFERR_USER_MASK;
<blue>	t_gpa  = mmu->gva_to_gpa(vcpu, mmu, gpa, access, exception);</blue>

	return t_gpa;
}

gpa_t kvm_mmu_gva_to_gpa_read(struct kvm_vcpu *vcpu, gva_t gva,
			      struct x86_exception *exception)
{
<blue>	struct kvm_mmu *mmu = vcpu->arch.walk_mmu;</blue>

	u64 access = (static_call(kvm_x86_get_cpl)(vcpu) == 3) ? PFERR_USER_MASK : 0;
	return mmu-&gt;gva_to_gpa(vcpu, mmu, gva, access, exception);
}
EXPORT_SYMBOL_GPL(kvm_mmu_gva_to_gpa_read);

gpa_t kvm_mmu_gva_to_gpa_write(struct kvm_vcpu *vcpu, gva_t gva,
			       struct x86_exception *exception)
{
<blue>	struct kvm_mmu *mmu = vcpu->arch.walk_mmu;</blue>

	u64 access = (static_call(kvm_x86_get_cpl)(vcpu) == 3) ? PFERR_USER_MASK : 0;
	access |= PFERR_WRITE_MASK;
	return mmu-&gt;gva_to_gpa(vcpu, mmu, gva, access, exception);
}
EXPORT_SYMBOL_GPL(kvm_mmu_gva_to_gpa_write);

/* uses this to access any guest&#x27;s mapped memory without checking CPL */
gpa_t kvm_mmu_gva_to_gpa_system(struct kvm_vcpu *vcpu, gva_t gva,
				struct x86_exception *exception)
{
<yellow>	struct kvm_mmu *mmu = vcpu->arch.walk_mmu;</yellow>

	return mmu-&gt;gva_to_gpa(vcpu, mmu, gva, 0, exception);
}

static int kvm_read_guest_virt_helper(gva_t addr, void *val, unsigned int bytes,
				      struct kvm_vcpu *vcpu, u64 access,
				      struct x86_exception *exception)
{
<blue>	struct kvm_mmu *mmu = vcpu->arch.walk_mmu;</blue>
	void *data = val;
	int r = X86EMUL_CONTINUE;

	while (bytes) {
<blue>		gpa_t gpa = mmu->gva_to_gpa(vcpu, mmu, addr, access, exception);</blue>
		unsigned offset = addr &amp; (PAGE_SIZE-1);
		unsigned toread = min(bytes, (unsigned)PAGE_SIZE - offset);
		int ret;

		if (gpa == INVALID_GPA)
			return X86EMUL_PROPAGATE_FAULT;
<blue>		ret = kvm_vcpu_read_guest_page(vcpu, gpa >> PAGE_SHIFT, data,</blue>
					       offset, toread);
		if (ret &lt; 0) {
			r = X86EMUL_IO_NEEDED;
			goto out;
		}

<blue>		bytes -= toread;</blue>
		data += toread;
		addr += toread;
	}
out:
	return r;
<blue>}</blue>

/* used for instruction fetching */
static int kvm_fetch_guest_virt(struct x86_emulate_ctxt *ctxt,
				gva_t addr, void *val, unsigned int bytes,
				struct x86_exception *exception)
{
<blue>	struct kvm_vcpu *vcpu = emul_to_vcpu(ctxt);</blue>
	struct kvm_mmu *mmu = vcpu-&gt;arch.walk_mmu;
	u64 access = (static_call(kvm_x86_get_cpl)(vcpu) == 3) ? PFERR_USER_MASK : 0;
	unsigned offset;
	int ret;

	/* Inline kvm_read_guest_virt_helper for speed.  */
	gpa_t gpa = mmu-&gt;gva_to_gpa(vcpu, mmu, addr, access|PFERR_FETCH_MASK,
				    exception);
	if (unlikely(gpa == INVALID_GPA))
		return X86EMUL_PROPAGATE_FAULT;

<blue>	offset = addr & (PAGE_SIZE-1);</blue>
<yellow>	if (WARN_ON(offset + bytes > PAGE_SIZE))</yellow>
		bytes = (unsigned)PAGE_SIZE - offset;
<blue>	ret = kvm_vcpu_read_guest_page(vcpu, gpa >> PAGE_SHIFT, val,</blue>
				       offset, bytes);
	if (unlikely(ret &lt; 0))
		return X86EMUL_IO_NEEDED;

	return X86EMUL_CONTINUE;
<blue>}</blue>

int kvm_read_guest_virt(struct kvm_vcpu *vcpu,
			       gva_t addr, void *val, unsigned int bytes,
			       struct x86_exception *exception)
{
<blue>	u64 access = (static_call(kvm_x86_get_cpl)(vcpu) == 3) ? PFERR_USER_MASK : 0;</blue>

	/*
	 * FIXME: this should call handle_emulation_failure if X86EMUL_IO_NEEDED
	 * is returned, but our callers are not ready for that and they blindly
	 * call kvm_inject_page_fault.  Ensure that they at least do not leak
	 * uninitialized kernel stack memory into cr2 and error code.
	 */
	memset(exception, 0, sizeof(*exception));
	return kvm_read_guest_virt_helper(addr, val, bytes, vcpu, access,
					  exception);
}
EXPORT_SYMBOL_GPL(kvm_read_guest_virt);

static int emulator_read_std(struct x86_emulate_ctxt *ctxt,
			     gva_t addr, void *val, unsigned int bytes,
			     struct x86_exception *exception, bool system)
{
<blue>	struct kvm_vcpu *vcpu = emul_to_vcpu(ctxt);</blue>
	u64 access = 0;

	if (system)
		access |= PFERR_IMPLICIT_ACCESS;
<blue>	else if (static_call(kvm_x86_get_cpl)(vcpu) == 3)</blue>
		access |= PFERR_USER_MASK;

<blue>	return kvm_read_guest_virt_helper(addr, val, bytes, vcpu, access, exception);</blue>
}

static int kvm_write_guest_virt_helper(gva_t addr, void *val, unsigned int bytes,
				      struct kvm_vcpu *vcpu, u64 access,
				      struct x86_exception *exception)
{
<blue>	struct kvm_mmu *mmu = vcpu->arch.walk_mmu;</blue>
	void *data = val;
	int r = X86EMUL_CONTINUE;

	while (bytes) {
<blue>		gpa_t gpa = mmu->gva_to_gpa(vcpu, mmu, addr, access, exception);</blue>
		unsigned offset = addr &amp; (PAGE_SIZE-1);
		unsigned towrite = min(bytes, (unsigned)PAGE_SIZE - offset);
		int ret;

		if (gpa == INVALID_GPA)
			return X86EMUL_PROPAGATE_FAULT;
<blue>		ret = kvm_vcpu_write_guest(vcpu, gpa, data, towrite);</blue>
		if (ret &lt; 0) {
			r = X86EMUL_IO_NEEDED;
			goto out;
		}

<blue>		bytes -= towrite;</blue>
		data += towrite;
		addr += towrite;
	}
out:
	return r;
<blue>}</blue>

static int emulator_write_std(struct x86_emulate_ctxt *ctxt, gva_t addr, void *val,
			      unsigned int bytes, struct x86_exception *exception,
			      bool system)
{
<yellow>	struct kvm_vcpu *vcpu = emul_to_vcpu(ctxt);</yellow>
	u64 access = PFERR_WRITE_MASK;

	if (system)
		access |= PFERR_IMPLICIT_ACCESS;
<yellow>	else if (static_call(kvm_x86_get_cpl)(vcpu) == 3)</yellow>
		access |= PFERR_USER_MASK;

<yellow>	return kvm_write_guest_virt_helper(addr, val, bytes, vcpu,</yellow>
					   access, exception);
}

int kvm_write_guest_virt_system(struct kvm_vcpu *vcpu, gva_t addr, void *val,
				unsigned int bytes, struct x86_exception *exception)
{
	/* kvm_write_guest_virt_system can pull in tons of pages. */
<blue>	vcpu->arch.l1tf_flush_l1d = true;</blue>

	return kvm_write_guest_virt_helper(addr, val, bytes, vcpu,
					   PFERR_WRITE_MASK, exception);
}
EXPORT_SYMBOL_GPL(kvm_write_guest_virt_system);

static int kvm_can_emulate_insn(struct kvm_vcpu *vcpu, int emul_type,
				void *insn, int insn_len)
{
<blue>	return static_call(kvm_x86_can_emulate_instruction)(vcpu, emul_type,</blue>
							    insn, insn_len);
}

int handle_ud(struct kvm_vcpu *vcpu)
<blue>{</blue>
	static const char kvm_emulate_prefix[] = { __KVM_EMULATE_PREFIX };
	int fep_flags = READ_ONCE(force_emulation_prefix);
	int emul_type = EMULTYPE_TRAP_UD;
	char sig[5]; /* ud2; .ascii &quot;kvm&quot; */
	struct x86_exception e;

<blue>	if (unlikely(!kvm_can_emulate_insn(vcpu, emul_type, NULL, 0)))</blue>
		return 1;

<blue>	if (fep_flags &&</blue>
<yellow>	    kvm_read_guest_virt(vcpu, kvm_get_linear_rip(vcpu),</yellow>
				sig, sizeof(sig), &amp;e) == 0 &amp;&amp;
<yellow>	    memcmp(sig, kvm_emulate_prefix, sizeof(sig)) == 0) {</yellow>
<yellow>		if (fep_flags & KVM_FEP_CLEAR_RFLAGS_RF)</yellow>
<yellow>			kvm_set_rflags(vcpu, kvm_get_rflags(vcpu) & ~X86_EFLAGS_RF);</yellow>
<yellow>		kvm_rip_write(vcpu, kvm_rip_read(vcpu) + sizeof(sig));</yellow>
		emul_type = EMULTYPE_TRAP_UD_FORCED;
	}

<blue>	return kvm_emulate_instruction(vcpu, emul_type);</blue>
}
EXPORT_SYMBOL_GPL(handle_ud);

static int vcpu_is_mmio_gpa(struct kvm_vcpu *vcpu, unsigned long gva,
			    gpa_t gpa, bool write)
{
	/* For APIC access vmexit */
<blue>	if ((gpa & PAGE_MASK) == APIC_DEFAULT_PHYS_BASE)</blue>
		return 1;

<blue>	if (vcpu_match_mmio_gpa(vcpu, gpa)) {</blue>
<blue>		trace_vcpu_match_mmio(gva, gpa, write, true);</blue>
		return 1;
	}

	return 0;
<blue>}</blue>

static int vcpu_mmio_gva_to_gpa(struct kvm_vcpu *vcpu, unsigned long gva,
				gpa_t *gpa, struct x86_exception *exception,
				bool write)
{
<blue>	struct kvm_mmu *mmu = vcpu->arch.walk_mmu;</blue>
	u64 access = ((static_call(kvm_x86_get_cpl)(vcpu) == 3) ? PFERR_USER_MASK : 0)
		| (write ? PFERR_WRITE_MASK : 0);

	/*
	 * currently PKRU is only applied to ept enabled guest so
	 * there is no pkey in EPT page table for L1 guest or EPT
	 * shadow page table for L2 guest.
	 */
<blue>	if (vcpu_match_mmio_gva(vcpu, gva) && (!is_paging(vcpu) ||</blue>
<blue>	    !permission_fault(vcpu, vcpu->arch.walk_mmu,</blue>
			      vcpu-&gt;arch.mmio_access, 0, access))) {
<blue>		*gpa = vcpu->arch.mmio_gfn << PAGE_SHIFT |</blue>
					(gva &amp; (PAGE_SIZE - 1));
		trace_vcpu_match_mmio(gva, *gpa, write, false);
		return 1;
	}

<blue>	*gpa = mmu->gva_to_gpa(vcpu, mmu, gva, access, exception);</blue>

	if (*gpa == INVALID_GPA)
		return -1;

<blue>	return vcpu_is_mmio_gpa(vcpu, gva, *gpa, write);</blue>
}

int emulator_write_phys(struct kvm_vcpu *vcpu, gpa_t gpa,
			const void *val, int bytes)
{
	int ret;

<blue>	ret = kvm_vcpu_write_guest(vcpu, gpa, val, bytes);</blue>
	if (ret &lt; 0)
		return 0;
<blue>	kvm_page_track_write(vcpu, gpa, val, bytes);</blue>
	return 1;
<yellow>}</yellow>

struct read_write_emulator_ops {
	int (*read_write_prepare)(struct kvm_vcpu *vcpu, void *val,
				  int bytes);
	int (*read_write_emulate)(struct kvm_vcpu *vcpu, gpa_t gpa,
				  void *val, int bytes);
	int (*read_write_mmio)(struct kvm_vcpu *vcpu, gpa_t gpa,
			       int bytes, void *val);
	int (*read_write_exit_mmio)(struct kvm_vcpu *vcpu, gpa_t gpa,
				    void *val, int bytes);
	bool write;
};

<blue>static int read_prepare(struct kvm_vcpu *vcpu, void *val, int bytes)</blue>
{
<blue>	if (vcpu->mmio_read_completed) {</blue>
<blue>		trace_kvm_mmio(KVM_TRACE_MMIO_READ, bytes,</blue>
			       vcpu-&gt;mmio_fragments[0].gpa, val);
		vcpu-&gt;mmio_read_completed = 0;
		return 1;
	}

	return 0;
<blue>}</blue>

static int read_emulate(struct kvm_vcpu *vcpu, gpa_t gpa,
			void *val, int bytes)
{
<blue>	return !kvm_vcpu_read_guest(vcpu, gpa, val, bytes);</blue>
}

static int write_emulate(struct kvm_vcpu *vcpu, gpa_t gpa,
			 void *val, int bytes)
{
<blue>	return emulator_write_phys(vcpu, gpa, val, bytes);</blue>
<blue>}</blue>

static int write_mmio(struct kvm_vcpu *vcpu, gpa_t gpa, int bytes, void *val)
{
<blue>	trace_kvm_mmio(KVM_TRACE_MMIO_WRITE, bytes, gpa, val);</blue>
<blue>	return vcpu_mmio_write(vcpu, gpa, bytes, val);</blue>
<blue>}</blue>

static int read_exit_mmio(struct kvm_vcpu *vcpu, gpa_t gpa,
			  void *val, int bytes)
{
<blue>	trace_kvm_mmio(KVM_TRACE_MMIO_READ_UNSATISFIED, bytes, gpa, NULL);</blue>
	return X86EMUL_IO_NEEDED;
}

static int write_exit_mmio(struct kvm_vcpu *vcpu, gpa_t gpa,
			   void *val, int bytes)
{
	struct kvm_mmio_fragment *frag = &amp;vcpu-&gt;mmio_fragments[0];

<blue>	memcpy(vcpu->run->mmio.data, frag->data, min(8u, frag->len));</blue>
	return X86EMUL_CONTINUE;
}

static const struct read_write_emulator_ops read_emultor = {
	.read_write_prepare = read_prepare,
	.read_write_emulate = read_emulate,
	.read_write_mmio = vcpu_mmio_read,
	.read_write_exit_mmio = read_exit_mmio,
};

static const struct read_write_emulator_ops write_emultor = {
	.read_write_emulate = write_emulate,
	.read_write_mmio = write_mmio,
	.read_write_exit_mmio = write_exit_mmio,
	.write = true,
};

static int emulator_read_write_onepage(unsigned long addr, void *val,
				       unsigned int bytes,
				       struct x86_exception *exception,
				       struct kvm_vcpu *vcpu,
				       const struct read_write_emulator_ops *ops)
{
	gpa_t gpa;
	int handled, ret;
<blue>	bool write = ops->write;</blue>
	struct kvm_mmio_fragment *frag;
<blue>	struct x86_emulate_ctxt *ctxt = vcpu->arch.emulate_ctxt;</blue>

	/*
	 * If the exit was due to a NPF we may already have a GPA.
	 * If the GPA is present, use it to avoid the GVA to GPA table walk.
	 * Note, this cannot be used on string operations since string
	 * operation using rep will only have the initial GPA from the NPF
	 * occurred.
	 */
<blue>	if (ctxt->gpa_available && emulator_can_use_gpa(ctxt) &&</blue>
<blue>	    (addr & ~PAGE_MASK) == (ctxt->gpa_val & ~PAGE_MASK)) {</blue>
		gpa = ctxt-&gt;gpa_val;
<blue>		ret = vcpu_is_mmio_gpa(vcpu, addr, gpa, write);</blue>
	} else {
<blue>		ret = vcpu_mmio_gva_to_gpa(vcpu, addr, &gpa, exception, write);</blue>
		if (ret &lt; 0)
			return X86EMUL_PROPAGATE_FAULT;
	}

<blue>	if (!ret && ops->read_write_emulate(vcpu, gpa, val, bytes))</blue>
		return X86EMUL_CONTINUE;

	/*
	 * Is this MMIO handled locally?
	 */
<blue>	handled = ops->read_write_mmio(vcpu, gpa, bytes, val);</blue>
	if (handled == bytes)
		return X86EMUL_CONTINUE;

<blue>	gpa += handled;</blue>
	bytes -= handled;
	val += handled;

<yellow>	WARN_ON(vcpu->mmio_nr_fragments >= KVM_MAX_MMIO_FRAGMENTS);</yellow>
<blue>	frag = &vcpu->mmio_fragments[vcpu->mmio_nr_fragments++];</blue>
	frag-&gt;gpa = gpa;
	frag-&gt;data = val;
	frag-&gt;len = bytes;
	return X86EMUL_CONTINUE;
<blue>}</blue>

static int emulator_read_write(struct x86_emulate_ctxt *ctxt,
			unsigned long addr,
			void *val, unsigned int bytes,
			struct x86_exception *exception,
			const struct read_write_emulator_ops *ops)
{
<blue>	struct kvm_vcpu *vcpu = emul_to_vcpu(ctxt);</blue>
	gpa_t gpa;
	int rc;

	if (ops-&gt;read_write_prepare &amp;&amp;
<blue>		  ops->read_write_prepare(vcpu, val, bytes))</blue>
		return X86EMUL_CONTINUE;

<blue>	vcpu->mmio_nr_fragments = 0;</blue>

	/* Crossing a page boundary? */
	if (((addr + bytes - 1) ^ addr) &amp; PAGE_MASK) {
		int now;

<yellow>		now = -addr & ~PAGE_MASK;</yellow>
		rc = emulator_read_write_onepage(addr, val, now, exception,
						 vcpu, ops);

		if (rc != X86EMUL_CONTINUE)
			return rc;
<yellow>		addr += now;</yellow>
		if (ctxt-&gt;mode != X86EMUL_MODE_PROT64)
<yellow>			addr = (u32)addr;</yellow>
<yellow>		val += now;</yellow>
		bytes -= now;
	}

<blue>	rc = emulator_read_write_onepage(addr, val, bytes, exception,</blue>
					 vcpu, ops);
	if (rc != X86EMUL_CONTINUE)
		return rc;

<blue>	if (!vcpu->mmio_nr_fragments)</blue>
		return rc;

<blue>	gpa = vcpu->mmio_fragments[0].gpa;</blue>

	vcpu-&gt;mmio_needed = 1;
	vcpu-&gt;mmio_cur_fragment = 0;

	vcpu-&gt;run-&gt;mmio.len = min(8u, vcpu-&gt;mmio_fragments[0].len);
<blue>	vcpu->run->mmio.is_write = vcpu->mmio_is_write = ops->write;</blue>
	vcpu-&gt;run-&gt;exit_reason = KVM_EXIT_MMIO;
	vcpu-&gt;run-&gt;mmio.phys_addr = gpa;

	return ops-&gt;read_write_exit_mmio(vcpu, gpa, val, bytes);
<blue>}</blue>

static int emulator_read_emulated(struct x86_emulate_ctxt *ctxt,
				  unsigned long addr,
				  void *val,
				  unsigned int bytes,
				  struct x86_exception *exception)
{
<blue>	return emulator_read_write(ctxt, addr, val, bytes,</blue>
				   exception, &amp;read_emultor);
}

static int emulator_write_emulated(struct x86_emulate_ctxt *ctxt,
			    unsigned long addr,
			    const void *val,
			    unsigned int bytes,
			    struct x86_exception *exception)
{
<blue>	return emulator_read_write(ctxt, addr, (void *)val, bytes,</blue>
				   exception, &amp;write_emultor);
}

#define emulator_try_cmpxchg_user(t, ptr, old, new) \
	(__try_cmpxchg_user((t __user *)(ptr), (t *)(old), *(t *)(new), efault ## t))

static int emulator_cmpxchg_emulated(struct x86_emulate_ctxt *ctxt,
				     unsigned long addr,
				     const void *old,
				     const void *new,
				     unsigned int bytes,
				     struct x86_exception *exception)
{
<yellow>	struct kvm_vcpu *vcpu = emul_to_vcpu(ctxt);</yellow>
	u64 page_line_mask;
	unsigned long hva;
	gpa_t gpa;
	int r;

	/* guests cmpxchg8b have to be emulated atomically */
<yellow>	if (bytes > 8 || (bytes & (bytes - 1)))</yellow>
		goto emul_write;

<yellow>	gpa = kvm_mmu_gva_to_gpa_write(vcpu, addr, NULL);</yellow>

	if (gpa == INVALID_GPA ||
<yellow>	    (gpa & PAGE_MASK) == APIC_DEFAULT_PHYS_BASE)</yellow>
		goto emul_write;

	/*
	 * Emulate the atomic as a straight write to avoid #AC if SLD is
	 * enabled in the host and the access splits a cache line.
	 */
<yellow>	if (boot_cpu_has(X86_FEATURE_SPLIT_LOCK_DETECT))</yellow>
<yellow>		page_line_mask = ~(cache_line_size() - 1);</yellow>
	else
		page_line_mask = PAGE_MASK;

<yellow>	if (((gpa + bytes - 1) & page_line_mask) != (gpa & page_line_mask))</yellow>
		goto emul_write;

<yellow>	hva = kvm_vcpu_gfn_to_hva(vcpu, gpa_to_gfn(gpa));</yellow>
	if (kvm_is_error_hva(hva))
		goto emul_write;

<yellow>	hva += offset_in_page(gpa);</yellow>

	switch (bytes) {
	case 1:
<yellow>		r = emulator_try_cmpxchg_user(u8, hva, old, new);</yellow>
		break;
	case 2:
<yellow>		r = emulator_try_cmpxchg_user(u16, hva, old, new);</yellow>
		break;
	case 4:
<yellow>		r = emulator_try_cmpxchg_user(u32, hva, old, new);</yellow>
		break;
	case 8:
<yellow>		r = emulator_try_cmpxchg_user(u64, hva, old, new);</yellow>
		break;
	default:
<yellow>		BUG();</yellow>
	}

	if (r &lt; 0)
		return X86EMUL_UNHANDLEABLE;
<yellow>	if (r)</yellow>
		return X86EMUL_CMPXCHG_FAILED;

<yellow>	kvm_page_track_write(vcpu, gpa, new, bytes);</yellow>

	return X86EMUL_CONTINUE;

emul_write:
<yellow>	printk_once(KERN_WARNING "kvm: emulating exchange as write\n");</yellow>

<yellow>	return emulator_write_emulated(ctxt, addr, new, bytes, exception);</yellow>
<yellow>}</yellow>

static int emulator_pio_in_out(struct kvm_vcpu *vcpu, int size,
			       unsigned short port, void *data,
			       unsigned int count, bool in)
{
	unsigned i;
	int r;

<blue>	WARN_ON_ONCE(vcpu->arch.pio.count);</blue>
<blue>	for (i = 0; i < count; i++) {</blue>
<blue>		if (in)</blue>
<blue>			r = kvm_io_bus_read(vcpu, KVM_PIO_BUS, port, size, data);</blue>
		else
<blue>			r = kvm_io_bus_write(vcpu, KVM_PIO_BUS, port, size, data);</blue>

<blue>		if (r) {</blue>
<blue>			if (i == 0)</blue>
				goto userspace_io;

			/*
			 * Userspace must have unregistered the device while PIO
			 * was running.  Drop writes / read as 0.
			 */
<yellow>			if (in)</yellow>
<yellow>				memset(data, 0, size * (count - i));</yellow>
			break;
		}

		data += size;
	}
	return 1;

userspace_io:
<blue>	vcpu->arch.pio.port = port;</blue>
	vcpu-&gt;arch.pio.in = in;
	vcpu-&gt;arch.pio.count = count;
	vcpu-&gt;arch.pio.size = size;

	if (in)
<blue>		memset(vcpu->arch.pio_data, 0, size * count);</blue>
	else
<blue>		memcpy(vcpu->arch.pio_data, data, size * count);</blue>

<blue>	vcpu->run->exit_reason = KVM_EXIT_IO;</blue>
	vcpu-&gt;run-&gt;io.direction = in ? KVM_EXIT_IO_IN : KVM_EXIT_IO_OUT;
	vcpu-&gt;run-&gt;io.size = size;
	vcpu-&gt;run-&gt;io.data_offset = KVM_PIO_PAGE_OFFSET * PAGE_SIZE;
	vcpu-&gt;run-&gt;io.count = count;
	vcpu-&gt;run-&gt;io.port = port;
	return 0;
<blue>}</blue>

static int emulator_pio_in(struct kvm_vcpu *vcpu, int size,
      			   unsigned short port, void *val, unsigned int count)
{
	int r = emulator_pio_in_out(vcpu, size, port, val, count, true);
	if (r)
<blue>		trace_kvm_pio(KVM_PIO_IN, port, size, count, val);</blue>

	return r;
}

static void complete_emulator_pio_in(struct kvm_vcpu *vcpu, void *val)
{
<blue>	int size = vcpu->arch.pio.size;</blue>
	unsigned int count = vcpu-&gt;arch.pio.count;
	memcpy(val, vcpu-&gt;arch.pio_data, size * count);
	trace_kvm_pio(KVM_PIO_IN, vcpu-&gt;arch.pio.port, size, count, vcpu-&gt;arch.pio_data);
	vcpu-&gt;arch.pio.count = 0;
}

static int emulator_pio_in_emulated(struct x86_emulate_ctxt *ctxt,
				    int size, unsigned short port, void *val,
				    unsigned int count)
{
<blue>	struct kvm_vcpu *vcpu = emul_to_vcpu(ctxt);</blue>
	if (vcpu-&gt;arch.pio.count) {
		/*
		 * Complete a previous iteration that required userspace I/O.
		 * Note, @count isn&#x27;t guaranteed to match pio.count as userspace
		 * can modify ECX before rerunning the vCPU.  Ignore any such
		 * shenanigans as KVM doesn&#x27;t support modifying the rep count,
		 * and the emulator ensures @count doesn&#x27;t overflow the buffer.
		 */
<blue>		complete_emulator_pio_in(vcpu, val);</blue>
		return 1;
	}

<blue>	return emulator_pio_in(vcpu, size, port, val, count);</blue>
<blue>}</blue>

static int emulator_pio_out(struct kvm_vcpu *vcpu, int size,
			    unsigned short port, const void *val,
			    unsigned int count)
{
<yellow>	trace_kvm_pio(KVM_PIO_OUT, port, size, count, val);</yellow>
<yellow>	return emulator_pio_in_out(vcpu, size, port, (void *)val, count, false);</yellow>
}

static int emulator_pio_out_emulated(struct x86_emulate_ctxt *ctxt,
				     int size, unsigned short port,
				     const void *val, unsigned int count)
{
<blue>	return emulator_pio_out(emul_to_vcpu(ctxt), size, port, val, count);</blue>
}

static unsigned long get_segment_base(struct kvm_vcpu *vcpu, int seg)
{
<yellow>	return static_call(kvm_x86_get_segment_base)(vcpu, seg);</yellow>
}

static void emulator_invlpg(struct x86_emulate_ctxt *ctxt, ulong address)
{
<yellow>	kvm_mmu_invlpg(emul_to_vcpu(ctxt), address);</yellow>
}

<yellow>static int kvm_emulate_wbinvd_noskip(struct kvm_vcpu *vcpu)</yellow>
{
<blue>	if (!need_emulate_wbinvd(vcpu))</blue>
		return X86EMUL_CONTINUE;

<yellow>	if (static_call(kvm_x86_has_wbinvd_exit)()) {</yellow>
<yellow>		int cpu = get_cpu();</yellow>

<yellow>		cpumask_set_cpu(cpu, vcpu->arch.wbinvd_dirty_mask);</yellow>
		on_each_cpu_mask(vcpu-&gt;arch.wbinvd_dirty_mask,
				wbinvd_ipi, NULL, 1);
<yellow>		put_cpu();</yellow>
<yellow>		cpumask_clear(vcpu->arch.wbinvd_dirty_mask);</yellow>
	} else
<yellow>		wbinvd();</yellow>
	return X86EMUL_CONTINUE;
<blue>}</blue>

int kvm_emulate_wbinvd(struct kvm_vcpu *vcpu)
{
<blue>	kvm_emulate_wbinvd_noskip(vcpu);</blue>
<blue>	return kvm_skip_emulated_instruction(vcpu);</blue>
<blue>}</blue>
EXPORT_SYMBOL_GPL(kvm_emulate_wbinvd);



static void emulator_wbinvd(struct x86_emulate_ctxt *ctxt)
{
<yellow>	kvm_emulate_wbinvd_noskip(emul_to_vcpu(ctxt));</yellow>
}

static void emulator_get_dr(struct x86_emulate_ctxt *ctxt, int dr,
			    unsigned long *dest)
{
<yellow>	kvm_get_dr(emul_to_vcpu(ctxt), dr, dest);</yellow>
}

static int emulator_set_dr(struct x86_emulate_ctxt *ctxt, int dr,
			   unsigned long value)
{

<yellow>	return kvm_set_dr(emul_to_vcpu(ctxt), dr, value);</yellow>
}

static u64 mk_cr_64(u64 curr_cr, u32 new_val)
{
	return (curr_cr &amp; ~((1ULL &lt;&lt; 32) - 1)) | new_val;
}

static unsigned long emulator_get_cr(struct x86_emulate_ctxt *ctxt, int cr)
{
<blue>	struct kvm_vcpu *vcpu = emul_to_vcpu(ctxt);</blue>
	unsigned long value;

	switch (cr) {
	case 0:
<blue>		value = kvm_read_cr0(vcpu);</blue>
		break;
	case 2:
<yellow>		value = vcpu->arch.cr2;</yellow>
		break;
	case 3:
<yellow>		value = kvm_read_cr3(vcpu);</yellow>
		break;
	case 4:
<blue>		value = kvm_read_cr4(vcpu);</blue>
		break;
	case 8:
<yellow>		value = kvm_get_cr8(vcpu);</yellow>
		break;
	default:
		kvm_err(&quot;%s: unexpected cr %u\n&quot;, __func__, cr);
		return 0;
	}

	return value;
<blue>}</blue>

static int emulator_set_cr(struct x86_emulate_ctxt *ctxt, int cr, ulong val)
{
<blue>	struct kvm_vcpu *vcpu = emul_to_vcpu(ctxt);</blue>
	int res = 0;

	switch (cr) {
	case 0:
<blue>		res = kvm_set_cr0(vcpu, mk_cr_64(kvm_read_cr0(vcpu), val));</blue>
		break;
	case 2:
<yellow>		vcpu->arch.cr2 = val;</yellow>
		break;
	case 3:
<yellow>		res = kvm_set_cr3(vcpu, val);</yellow>
		break;
	case 4:
<yellow>		res = kvm_set_cr4(vcpu, mk_cr_64(kvm_read_cr4(vcpu), val));</yellow>
		break;
	case 8:
<yellow>		res = kvm_set_cr8(vcpu, val);</yellow>
		break;
	default:
		kvm_err(&quot;%s: unexpected cr %u\n&quot;, __func__, cr);
		res = -1;
	}

	return res;
<blue>}</blue>

static int emulator_get_cpl(struct x86_emulate_ctxt *ctxt)
{
<blue>	return static_call(kvm_x86_get_cpl)(emul_to_vcpu(ctxt));</blue>
}

static void emulator_get_gdt(struct x86_emulate_ctxt *ctxt, struct desc_ptr *dt)
{
<yellow>	static_call(kvm_x86_get_gdt)(emul_to_vcpu(ctxt), dt);</yellow>
}

static void emulator_get_idt(struct x86_emulate_ctxt *ctxt, struct desc_ptr *dt)
{
<yellow>	static_call(kvm_x86_get_idt)(emul_to_vcpu(ctxt), dt);</yellow>
}

static void emulator_set_gdt(struct x86_emulate_ctxt *ctxt, struct desc_ptr *dt)
{
<blue>	static_call(kvm_x86_set_gdt)(emul_to_vcpu(ctxt), dt);</blue>
}

static void emulator_set_idt(struct x86_emulate_ctxt *ctxt, struct desc_ptr *dt)
{
<yellow>	static_call(kvm_x86_set_idt)(emul_to_vcpu(ctxt), dt);</yellow>
}

static unsigned long emulator_get_cached_segment_base(
	struct x86_emulate_ctxt *ctxt, int seg)
{
<blue>	return get_segment_base(emul_to_vcpu(ctxt), seg);</blue>
}

static bool emulator_get_segment(struct x86_emulate_ctxt *ctxt, u16 *selector,
				 struct desc_struct *desc, u32 *base3,
				 int seg)
<blue>{</blue>
	struct kvm_segment var;

<blue>	kvm_get_segment(emul_to_vcpu(ctxt), &var, seg);</blue>
	*selector = var.selector;

	if (var.unusable) {
<yellow>		memset(desc, 0, sizeof(*desc));</yellow>
		if (base3)
<yellow>			*base3 = 0;</yellow>
		return false;
	}

<blue>	if (var.g)</blue>
<yellow>		var.limit >>= 12;</yellow>
<blue>	set_desc_limit(desc, var.limit);</blue>
	set_desc_base(desc, (unsigned long)var.base);
#ifdef CONFIG_X86_64
	if (base3)
<blue>		*base3 = var.base >> 32;</blue>
#endif
<blue>	desc->type = var.type;</blue>
	desc-&gt;s = var.s;
	desc-&gt;dpl = var.dpl;
	desc-&gt;p = var.present;
	desc-&gt;avl = var.avl;
	desc-&gt;l = var.l;
	desc-&gt;d = var.db;
	desc-&gt;g = var.g;

	return true;
}

static void emulator_set_segment(struct x86_emulate_ctxt *ctxt, u16 selector,
				 struct desc_struct *desc, u32 base3,
				 int seg)
{
<blue>	struct kvm_vcpu *vcpu = emul_to_vcpu(ctxt);</blue>
	struct kvm_segment var;

	var.selector = selector;
	var.base = get_desc_base(desc);
#ifdef CONFIG_X86_64
	var.base |= ((u64)base3) &lt;&lt; 32;
#endif
	var.limit = get_desc_limit(desc);
	if (desc-&gt;g)
<yellow>		var.limit = (var.limit << 12) | 0xfff;</yellow>
<blue>	var.type = desc->type;</blue>
	var.dpl = desc-&gt;dpl;
	var.db = desc-&gt;d;
	var.s = desc-&gt;s;
	var.l = desc-&gt;l;
	var.g = desc-&gt;g;
	var.avl = desc-&gt;avl;
	var.present = desc-&gt;p;
	var.unusable = !var.present;
	var.padding = 0;

	kvm_set_segment(vcpu, &amp;var, seg);
	return;
}

static int emulator_get_msr_with_filter(struct x86_emulate_ctxt *ctxt,
					u32 msr_index, u64 *pdata)
{
<yellow>	struct kvm_vcpu *vcpu = emul_to_vcpu(ctxt);</yellow>
	int r;

<yellow>	r = kvm_get_msr_with_filter(vcpu, msr_index, pdata);</yellow>
<yellow>	if (r < 0)</yellow>
		return X86EMUL_UNHANDLEABLE;

<yellow>	if (r) {</yellow>
<yellow>		if (kvm_msr_user_space(vcpu, msr_index, KVM_EXIT_X86_RDMSR, 0,</yellow>
				       complete_emulated_rdmsr, r))
			return X86EMUL_IO_NEEDED;

<yellow>		trace_kvm_msr_read_ex(msr_index);</yellow>
		return X86EMUL_PROPAGATE_FAULT;
	}

<yellow>	trace_kvm_msr_read(msr_index, *pdata);</yellow>
	return X86EMUL_CONTINUE;
<yellow>}</yellow>

static int emulator_set_msr_with_filter(struct x86_emulate_ctxt *ctxt,
					u32 msr_index, u64 data)
{
<yellow>	struct kvm_vcpu *vcpu = emul_to_vcpu(ctxt);</yellow>
	int r;

<yellow>	r = kvm_set_msr_with_filter(vcpu, msr_index, data);</yellow>
<yellow>	if (r < 0)</yellow>
		return X86EMUL_UNHANDLEABLE;

<yellow>	if (r) {</yellow>
<yellow>		if (kvm_msr_user_space(vcpu, msr_index, KVM_EXIT_X86_WRMSR, data,</yellow>
				       complete_emulated_msr_access, r))
			return X86EMUL_IO_NEEDED;

<yellow>		trace_kvm_msr_write_ex(msr_index, data);</yellow>
		return X86EMUL_PROPAGATE_FAULT;
	}

<yellow>	trace_kvm_msr_write(msr_index, data);</yellow>
	return X86EMUL_CONTINUE;
<yellow>}</yellow>

static int emulator_get_msr(struct x86_emulate_ctxt *ctxt,
			    u32 msr_index, u64 *pdata)
{
<blue>	return kvm_get_msr(emul_to_vcpu(ctxt), msr_index, pdata);</blue>
<blue>}</blue>

static int emulator_check_pmc(struct x86_emulate_ctxt *ctxt,
			      u32 pmc)
{
<yellow>	if (kvm_pmu_is_valid_rdpmc_ecx(emul_to_vcpu(ctxt), pmc))</yellow>
<yellow>		return 0;</yellow>
	return -EINVAL;
}

static int emulator_read_pmc(struct x86_emulate_ctxt *ctxt,
			     u32 pmc, u64 *pdata)
{
<yellow>	return kvm_pmu_rdpmc(emul_to_vcpu(ctxt), pmc, pdata);</yellow>
}

static void emulator_halt(struct x86_emulate_ctxt *ctxt)
{
<yellow>	emul_to_vcpu(ctxt)->arch.halt_request = 1;</yellow>
}

static int emulator_intercept(struct x86_emulate_ctxt *ctxt,
			      struct x86_instruction_info *info,
			      enum x86_intercept_stage stage)
{
<blue>	return static_call(kvm_x86_check_intercept)(emul_to_vcpu(ctxt), info, stage,</blue>
					    &amp;ctxt-&gt;exception);
}

static bool emulator_get_cpuid(struct x86_emulate_ctxt *ctxt,
			      u32 *eax, u32 *ebx, u32 *ecx, u32 *edx,
			      bool exact_only)
{
<yellow>	return kvm_cpuid(emul_to_vcpu(ctxt), eax, ebx, ecx, edx, exact_only);</yellow>
}

static bool emulator_guest_has_long_mode(struct x86_emulate_ctxt *ctxt)
{
<yellow>	return guest_cpuid_has(emul_to_vcpu(ctxt), X86_FEATURE_LM);</yellow>
<yellow>}</yellow>

static bool emulator_guest_has_movbe(struct x86_emulate_ctxt *ctxt)
{
<yellow>	return guest_cpuid_has(emul_to_vcpu(ctxt), X86_FEATURE_MOVBE);</yellow>
<yellow>}</yellow>

static bool emulator_guest_has_fxsr(struct x86_emulate_ctxt *ctxt)
{
<yellow>	return guest_cpuid_has(emul_to_vcpu(ctxt), X86_FEATURE_FXSR);</yellow>
<yellow>}</yellow>

static bool emulator_guest_has_rdpid(struct x86_emulate_ctxt *ctxt)
{
<yellow>	return guest_cpuid_has(emul_to_vcpu(ctxt), X86_FEATURE_RDPID);</yellow>
<yellow>}</yellow>

static ulong emulator_read_gpr(struct x86_emulate_ctxt *ctxt, unsigned reg)
{
<blue>	return kvm_register_read_raw(emul_to_vcpu(ctxt), reg);</blue>
<blue>}</blue>

static void emulator_write_gpr(struct x86_emulate_ctxt *ctxt, unsigned reg, ulong val)
{
<blue>	kvm_register_write_raw(emul_to_vcpu(ctxt), reg, val);</blue>
<blue>}</blue>

static void emulator_set_nmi_mask(struct x86_emulate_ctxt *ctxt, bool masked)
{
<yellow>	static_call(kvm_x86_set_nmi_mask)(emul_to_vcpu(ctxt), masked);</yellow>
}

static unsigned emulator_get_hflags(struct x86_emulate_ctxt *ctxt)
{
<blue>	return emul_to_vcpu(ctxt)->arch.hflags;</blue>
}

#ifndef CONFIG_KVM_SMM
static int emulator_leave_smm(struct x86_emulate_ctxt *ctxt)
{
	WARN_ON_ONCE(1);
	return X86EMUL_UNHANDLEABLE;
}
#endif

static void emulator_triple_fault(struct x86_emulate_ctxt *ctxt)
{
<yellow>	kvm_make_request(KVM_REQ_TRIPLE_FAULT, emul_to_vcpu(ctxt));</yellow>
}

static int emulator_set_xcr(struct x86_emulate_ctxt *ctxt, u32 index, u64 xcr)
{
<yellow>	return __kvm_set_xcr(emul_to_vcpu(ctxt), index, xcr);</yellow>
}

static void emulator_vm_bugged(struct x86_emulate_ctxt *ctxt)
{
<yellow>	struct kvm *kvm = emul_to_vcpu(ctxt)->kvm;</yellow>

<yellow>	if (!kvm->vm_bugged)</yellow>
<yellow>		kvm_vm_bugged(kvm);</yellow>
<yellow>}</yellow>

static const struct x86_emulate_ops emulate_ops = {
	.vm_bugged           = emulator_vm_bugged,
	.read_gpr            = emulator_read_gpr,
	.write_gpr           = emulator_write_gpr,
	.read_std            = emulator_read_std,
	.write_std           = emulator_write_std,
	.fetch               = kvm_fetch_guest_virt,
	.read_emulated       = emulator_read_emulated,
	.write_emulated      = emulator_write_emulated,
	.cmpxchg_emulated    = emulator_cmpxchg_emulated,
	.invlpg              = emulator_invlpg,
	.pio_in_emulated     = emulator_pio_in_emulated,
	.pio_out_emulated    = emulator_pio_out_emulated,
	.get_segment         = emulator_get_segment,
	.set_segment         = emulator_set_segment,
	.get_cached_segment_base = emulator_get_cached_segment_base,
	.get_gdt             = emulator_get_gdt,
	.get_idt	     = emulator_get_idt,
	.set_gdt             = emulator_set_gdt,
	.set_idt	     = emulator_set_idt,
	.get_cr              = emulator_get_cr,
	.set_cr              = emulator_set_cr,
	.cpl                 = emulator_get_cpl,
	.get_dr              = emulator_get_dr,
	.set_dr              = emulator_set_dr,
	.set_msr_with_filter = emulator_set_msr_with_filter,
	.get_msr_with_filter = emulator_get_msr_with_filter,
	.get_msr             = emulator_get_msr,
	.check_pmc	     = emulator_check_pmc,
	.read_pmc            = emulator_read_pmc,
	.halt                = emulator_halt,
	.wbinvd              = emulator_wbinvd,
	.fix_hypercall       = emulator_fix_hypercall,
	.intercept           = emulator_intercept,
	.get_cpuid           = emulator_get_cpuid,
	.guest_has_long_mode = emulator_guest_has_long_mode,
	.guest_has_movbe     = emulator_guest_has_movbe,
	.guest_has_fxsr      = emulator_guest_has_fxsr,
	.guest_has_rdpid     = emulator_guest_has_rdpid,
	.set_nmi_mask        = emulator_set_nmi_mask,
	.get_hflags          = emulator_get_hflags,
	.leave_smm           = emulator_leave_smm,
	.triple_fault        = emulator_triple_fault,
	.set_xcr             = emulator_set_xcr,
};

static void toggle_interruptibility(struct kvm_vcpu *vcpu, u32 mask)
{
	u32 int_shadow = static_call(kvm_x86_get_interrupt_shadow)(vcpu);
	/*
	 * an sti; sti; sequence only disable interrupts for the first
	 * instruction. So, if the last instruction, be it emulated or
	 * not, left the system with the INT_STI flag enabled, it
	 * means that the last instruction is an sti. We should not
	 * leave the flag on in this case. The same goes for mov ss
	 */
	if (int_shadow &amp; mask)
		mask = 0;
<blue>	if (unlikely(int_shadow || mask)) {</blue>
<yellow>		static_call(kvm_x86_set_interrupt_shadow)(vcpu, mask);</yellow>
		if (!mask)
<yellow>			kvm_make_request(KVM_REQ_EVENT, vcpu);</yellow>
	}
}

static void inject_emulated_exception(struct kvm_vcpu *vcpu)
{
<blue>	struct x86_emulate_ctxt *ctxt = vcpu->arch.emulate_ctxt;</blue>

	if (ctxt-&gt;exception.vector == PF_VECTOR)
<yellow>		kvm_inject_emulated_page_fault(vcpu, &ctxt->exception);</yellow>
<blue>	else if (ctxt->exception.error_code_valid)</blue>
		kvm_queue_exception_e(vcpu, ctxt-&gt;exception.vector,
<yellow>				      ctxt->exception.error_code);</yellow>
	else
<blue>		kvm_queue_exception(vcpu, ctxt->exception.vector);</blue>
<blue>}</blue>

static struct x86_emulate_ctxt *alloc_emulate_ctxt(struct kvm_vcpu *vcpu)
{
	struct x86_emulate_ctxt *ctxt;

<blue>	ctxt = kmem_cache_zalloc(x86_emulator_cache, GFP_KERNEL_ACCOUNT);</blue>
	if (!ctxt) {
		pr_err(&quot;kvm: failed to allocate vcpu&#x27;s emulator\n&quot;);
		return NULL;
	}

<blue>	ctxt->vcpu = vcpu;</blue>
	ctxt-&gt;ops = &amp;emulate_ops;
	vcpu-&gt;arch.emulate_ctxt = ctxt;

	return ctxt;
}

static void init_emulate_ctxt(struct kvm_vcpu *vcpu)
{
<blue>	struct x86_emulate_ctxt *ctxt = vcpu->arch.emulate_ctxt;</blue>
	int cs_db, cs_l;

	static_call(kvm_x86_get_cs_db_l_bits)(vcpu, &amp;cs_db, &amp;cs_l);

	ctxt-&gt;gpa_available = false;
<blue>	ctxt->eflags = kvm_get_rflags(vcpu);</blue>
<blue>	ctxt->tf = (ctxt->eflags & X86_EFLAGS_TF) != 0;</blue>

<blue>	ctxt->eip = kvm_rip_read(vcpu);</blue>
<blue>	ctxt->mode = (!is_protmode(vcpu))		? X86EMUL_MODE_REAL :</blue>
<blue>		     (ctxt->eflags & X86_EFLAGS_VM)	? X86EMUL_MODE_VM86 :</blue>
<blue>		     (cs_l && is_long_mode(vcpu))	? X86EMUL_MODE_PROT64 :</blue>
<yellow>		     cs_db				? X86EMUL_MODE_PROT32 :</yellow>
							  X86EMUL_MODE_PROT16;
	BUILD_BUG_ON(HF_GUEST_MASK != X86EMUL_GUEST_MASK);

	ctxt-&gt;interruptibility = 0;
	ctxt-&gt;have_exception = false;
	ctxt-&gt;exception.vector = -1;
	ctxt-&gt;perm_ok = false;

	init_decode_cache(ctxt);
	vcpu-&gt;arch.emulate_regs_need_sync_from_vcpu = false;
}

void kvm_inject_realmode_interrupt(struct kvm_vcpu *vcpu, int irq, int inc_eip)
{
<yellow>	struct x86_emulate_ctxt *ctxt = vcpu->arch.emulate_ctxt;</yellow>
	int ret;

	init_emulate_ctxt(vcpu);

	ctxt-&gt;op_bytes = 2;
	ctxt-&gt;ad_bytes = 2;
	ctxt-&gt;_eip = ctxt-&gt;eip + inc_eip;
	ret = emulate_int_real(ctxt, irq);

	if (ret != X86EMUL_CONTINUE) {
<yellow>		kvm_make_request(KVM_REQ_TRIPLE_FAULT, vcpu);</yellow>
	} else {
<yellow>		ctxt->eip = ctxt->_eip;</yellow>
		kvm_rip_write(vcpu, ctxt-&gt;eip);
		kvm_set_rflags(vcpu, ctxt-&gt;eflags);
	}
<yellow>}</yellow>
EXPORT_SYMBOL_GPL(kvm_inject_realmode_interrupt);

static void prepare_emulation_failure_exit(struct kvm_vcpu *vcpu, u64 *data,
					   u8 ndata, u8 *insn_bytes, u8 insn_size)
{
<yellow>	struct kvm_run *run = vcpu->run;</yellow>
	u64 info[5];
	u8 info_start;

	/*
	 * Zero the whole array used to retrieve the exit info, as casting to
	 * u32 for select entries will leave some chunks uninitialized.
	 */
	memset(&amp;info, 0, sizeof(info));

	static_call(kvm_x86_get_exit_info)(vcpu, (u32 *)&amp;info[0], &amp;info[1],
					   &amp;info[2], (u32 *)&amp;info[3],
					   (u32 *)&amp;info[4]);

	run-&gt;exit_reason = KVM_EXIT_INTERNAL_ERROR;
	run-&gt;emulation_failure.suberror = KVM_INTERNAL_ERROR_EMULATION;

	/*
	 * There&#x27;s currently space for 13 entries, but 5 are used for the exit
	 * reason and info.  Restrict to 4 to reduce the maintenance burden
	 * when expanding kvm_run.emulation_failure in the future.
	 */
<yellow>	if (WARN_ON_ONCE(ndata > 4))</yellow>
		ndata = 4;

	/* Always include the flags as a &#x27;data&#x27; entry. */
	info_start = 1;
<yellow>	run->emulation_failure.flags = 0;</yellow>

<yellow>	if (insn_size) {</yellow>
		BUILD_BUG_ON((sizeof(run-&gt;emulation_failure.insn_size) +
			      sizeof(run-&gt;emulation_failure.insn_bytes) != 16));
		info_start += 2;
<yellow>		run->emulation_failure.flags |=</yellow>
			KVM_INTERNAL_ERROR_EMULATION_FLAG_INSTRUCTION_BYTES;
		run-&gt;emulation_failure.insn_size = insn_size;
		memset(run-&gt;emulation_failure.insn_bytes, 0x90,
		       sizeof(run-&gt;emulation_failure.insn_bytes));
<yellow>		memcpy(run->emulation_failure.insn_bytes, insn_bytes, insn_size);</yellow>
	}

<yellow>	memcpy(&run->internal.data[info_start], info, sizeof(info));</yellow>
	memcpy(&amp;run-&gt;internal.data[info_start + ARRAY_SIZE(info)], data,
	       ndata * sizeof(data[0]));

	run-&gt;emulation_failure.ndata = info_start + ARRAY_SIZE(info) + ndata;
}

static void prepare_emulation_ctxt_failure_exit(struct kvm_vcpu *vcpu)
{
<yellow>	struct x86_emulate_ctxt *ctxt = vcpu->arch.emulate_ctxt;</yellow>

	prepare_emulation_failure_exit(vcpu, NULL, 0, ctxt-&gt;fetch.data,
				       ctxt-&gt;fetch.end - ctxt-&gt;fetch.data);
}

void __kvm_prepare_emulation_failure_exit(struct kvm_vcpu *vcpu, u64 *data,
					  u8 ndata)
{
<yellow>	prepare_emulation_failure_exit(vcpu, data, ndata, NULL, 0);</yellow>
}
EXPORT_SYMBOL_GPL(__kvm_prepare_emulation_failure_exit);

void kvm_prepare_emulation_failure_exit(struct kvm_vcpu *vcpu)
{
<yellow>	__kvm_prepare_emulation_failure_exit(vcpu, NULL, 0);</yellow>
}
EXPORT_SYMBOL_GPL(kvm_prepare_emulation_failure_exit);

static int handle_emulation_failure(struct kvm_vcpu *vcpu, int emulation_type)
{
<blue>	struct kvm *kvm = vcpu->kvm;</blue>

	++vcpu-&gt;stat.insn_emulation_fail;
<blue>	trace_kvm_emulate_insn_failed(vcpu);</blue>

<blue>	if (emulation_type & EMULTYPE_VMWARE_GP) {</blue>
<yellow>		kvm_queue_exception_e(vcpu, GP_VECTOR, 0);</yellow>
		return 1;
	}

<blue>	if (kvm->arch.exit_on_emulation_error ||</blue>
<blue>	    (emulation_type & EMULTYPE_SKIP)) {</blue>
<yellow>		prepare_emulation_ctxt_failure_exit(vcpu);</yellow>
		return 0;
	}

<blue>	kvm_queue_exception(vcpu, UD_VECTOR);</blue>

<yellow>	if (!is_guest_mode(vcpu) && static_call(kvm_x86_get_cpl)(vcpu) == 0) {</yellow>
<yellow>		prepare_emulation_ctxt_failure_exit(vcpu);</yellow>
		return 0;
	}

	return 1;
<blue>}</blue>

<yellow>static bool reexecute_instruction(struct kvm_vcpu *vcpu, gpa_t cr2_or_gpa,</yellow>
				  bool write_fault_to_shadow_pgtable,
				  int emulation_type)
{
	gpa_t gpa = cr2_or_gpa;
	kvm_pfn_t pfn;

<blue>	if (!(emulation_type & EMULTYPE_ALLOW_RETRY_PF))</blue>
		return false;

<yellow>	if (WARN_ON_ONCE(is_guest_mode(vcpu)) ||</yellow>
<yellow>	    WARN_ON_ONCE(!(emulation_type & EMULTYPE_PF)))</yellow>
		return false;

<yellow>	if (!vcpu->arch.mmu->root_role.direct) {</yellow>
		/*
		 * Write permission should be allowed since only
		 * write access need to be emulated.
		 */
<yellow>		gpa = kvm_mmu_gva_to_gpa_write(vcpu, cr2_or_gpa, NULL);</yellow>

		/*
		 * If the mapping is invalid in guest, let cpu retry
		 * it to generate fault.
		 */
		if (gpa == INVALID_GPA)
			return true;
	}

	/*
	 * Do not retry the unhandleable instruction if it faults on the
	 * readonly host memory, otherwise it will goto a infinite loop:
	 * retry instruction -&gt; write #PF -&gt; emulation fail -&gt; retry
	 * instruction -&gt; ...
	 */
<yellow>	pfn = gfn_to_pfn(vcpu->kvm, gpa_to_gfn(gpa));</yellow>

	/*
	 * If the instruction failed on the error pfn, it can not be fixed,
	 * report the error to userspace.
	 */
	if (is_error_noslot_pfn(pfn))
		return false;

<yellow>	kvm_release_pfn_clean(pfn);</yellow>

	/* The instructions are well-emulated on direct mmu. */
	if (vcpu-&gt;arch.mmu-&gt;root_role.direct) {
		unsigned int indirect_shadow_pages;

<yellow>		write_lock(&vcpu->kvm->mmu_lock);</yellow>
		indirect_shadow_pages = vcpu-&gt;kvm-&gt;arch.indirect_shadow_pages;
		write_unlock(&amp;vcpu-&gt;kvm-&gt;mmu_lock);

		if (indirect_shadow_pages)
<yellow>			kvm_mmu_unprotect_page(vcpu->kvm, gpa_to_gfn(gpa));</yellow>

		return true;
	}

	/*
	 * if emulation was due to access to shadowed page table
	 * and it failed try to unshadow page and re-enter the
	 * guest to let CPU execute the instruction.
	 */
<yellow>	kvm_mmu_unprotect_page(vcpu->kvm, gpa_to_gfn(gpa));</yellow>

	/*
	 * If the access faults on its page table, it can not
	 * be fixed by unprotecting shadow page and it should
	 * be reported to userspace.
	 */
	return !write_fault_to_shadow_pgtable;
<blue>}</blue>

static bool retry_instruction(struct x86_emulate_ctxt *ctxt,
			      gpa_t cr2_or_gpa,  int emulation_type)
{
<blue>	struct kvm_vcpu *vcpu = emul_to_vcpu(ctxt);</blue>
	unsigned long last_retry_eip, last_retry_addr, gpa = cr2_or_gpa;

	last_retry_eip = vcpu-&gt;arch.last_retry_eip;
	last_retry_addr = vcpu-&gt;arch.last_retry_addr;

	/*
	 * If the emulation is caused by #PF and it is non-page_table
	 * writing instruction, it means the VM-EXIT is caused by shadow
	 * page protected, we can zap the shadow page and retry this
	 * instruction directly.
	 *
	 * Note: if the guest uses a non-page-table modifying instruction
	 * on the PDE that points to the instruction, then we will unmap
	 * the instruction and go to an infinite loop. So, we cache the
	 * last retried eip and the last fault address, if we meet the eip
	 * and the address again, we can break out of the potential infinite
	 * loop.
	 */
	vcpu-&gt;arch.last_retry_eip = vcpu-&gt;arch.last_retry_addr = 0;

	if (!(emulation_type &amp; EMULTYPE_ALLOW_RETRY_PF))
		return false;

<blue>	if (WARN_ON_ONCE(is_guest_mode(vcpu)) ||</blue>
<blue>	    WARN_ON_ONCE(!(emulation_type & EMULTYPE_PF)))</blue>
		return false;

<blue>	if (x86_page_table_writing_insn(ctxt))</blue>
		return false;

<blue>	if (ctxt->eip == last_retry_eip && last_retry_addr == cr2_or_gpa)</blue>
		return false;

<blue>	vcpu->arch.last_retry_eip = ctxt->eip;</blue>
	vcpu-&gt;arch.last_retry_addr = cr2_or_gpa;

	if (!vcpu-&gt;arch.mmu-&gt;root_role.direct)
<blue>		gpa = kvm_mmu_gva_to_gpa_write(vcpu, cr2_or_gpa, NULL);</blue>

<blue>	kvm_mmu_unprotect_page(vcpu->kvm, gpa_to_gfn(gpa));</blue>

	return true;
}

static int complete_emulated_mmio(struct kvm_vcpu *vcpu);
static int complete_emulated_pio(struct kvm_vcpu *vcpu);

static int kvm_vcpu_check_hw_bp(unsigned long addr, u32 type, u32 dr7,
				unsigned long *db)
{
	u32 dr6 = 0;
	int i;
	u32 enable, rwlen;

	enable = dr7;
	rwlen = dr7 &gt;&gt; 16;
<blue>	for (i = 0; i < 4; i++, enable >>= 2, rwlen >>= 4)</blue>
<blue>		if ((enable & 3) && (rwlen & 15) == type && db[i] == addr)</blue>
<yellow>			dr6 |= (1 << i);</yellow>
	return dr6;
}

<yellow>static int kvm_vcpu_do_singlestep(struct kvm_vcpu *vcpu)</yellow>
{
<yellow>	struct kvm_run *kvm_run = vcpu->run;</yellow>

	if (vcpu-&gt;guest_debug &amp; KVM_GUESTDBG_SINGLESTEP) {
<yellow>		kvm_run->debug.arch.dr6 = DR6_BS | DR6_ACTIVE_LOW;</yellow>
		kvm_run-&gt;debug.arch.pc = kvm_get_linear_rip(vcpu);
		kvm_run-&gt;debug.arch.exception = DB_VECTOR;
		kvm_run-&gt;exit_reason = KVM_EXIT_DEBUG;
		return 0;
	}
<yellow>	kvm_queue_exception_p(vcpu, DB_VECTOR, DR6_BS);</yellow>
	return 1;
<yellow>}</yellow>

int kvm_skip_emulated_instruction(struct kvm_vcpu *vcpu)
{
<blue>	unsigned long rflags = static_call(kvm_x86_get_rflags)(vcpu);</blue>
	int r;

	r = static_call(kvm_x86_skip_emulated_instruction)(vcpu);
	if (unlikely(!r))
		return 0;

	kvm_pmu_trigger_event(vcpu, PERF_COUNT_HW_INSTRUCTIONS);

	/*
	 * rflags is the old, &quot;raw&quot; value of the flags.  The new value has
	 * not been saved yet.
	 *
	 * This is correct even for TF set by the guest, because &quot;the
	 * processor will not generate this exception after the instruction
	 * that sets the TF flag&quot;.
	 */
<blue>	if (unlikely(rflags & X86_EFLAGS_TF))</blue>
<yellow>		r = kvm_vcpu_do_singlestep(vcpu);</yellow>
	return r;
<blue>}</blue>
EXPORT_SYMBOL_GPL(kvm_skip_emulated_instruction);

static bool kvm_is_code_breakpoint_inhibited(struct kvm_vcpu *vcpu)
{
	u32 shadow;

<blue>	if (kvm_get_rflags(vcpu) & X86_EFLAGS_RF)</blue>
		return true;

	/*
	 * Intel CPUs inhibit code #DBs when MOV/POP SS blocking is active,
	 * but AMD CPUs do not.  MOV/POP SS blocking is rare, check that first
	 * to avoid the relatively expensive CPUID lookup.
	 */
<blue>	shadow = static_call(kvm_x86_get_interrupt_shadow)(vcpu);</blue>
	return (shadow &amp; KVM_X86_SHADOW_INT_MOV_SS) &amp;&amp;
<yellow>	       guest_cpuid_is_intel(vcpu);</yellow>
}

static bool kvm_vcpu_check_code_breakpoint(struct kvm_vcpu *vcpu,
					   int emulation_type, int *r)
{
<yellow>	WARN_ON_ONCE(emulation_type & EMULTYPE_NO_DECODE);</yellow>

	/*
	 * Do not check for code breakpoints if hardware has already done the
	 * checks, as inferred from the emulation type.  On NO_DECODE and SKIP,
	 * the instruction has passed all exception checks, and all intercepted
	 * exceptions that trigger emulation have lower priority than code
	 * breakpoints, i.e. the fact that the intercepted exception occurred
	 * means any code breakpoints have already been serviced.
	 *
	 * Note, KVM needs to check for code #DBs on EMULTYPE_TRAP_UD_FORCED as
	 * hardware has checked the RIP of the magic prefix, but not the RIP of
	 * the instruction being emulated.  The intent of forced emulation is
	 * to behave as if KVM intercepted the instruction without an exception
	 * and without a prefix.
	 */
<blue>	if (emulation_type & (EMULTYPE_NO_DECODE | EMULTYPE_SKIP |</blue>
			      EMULTYPE_TRAP_UD | EMULTYPE_VMWARE_GP | EMULTYPE_PF))
		return false;

<blue>	if (unlikely(vcpu->guest_debug & KVM_GUESTDBG_USE_HW_BP) &&</blue>
<yellow>	    (vcpu->arch.guest_debug_dr7 & DR7_BP_EN_MASK)) {</yellow>
<yellow>		struct kvm_run *kvm_run = vcpu->run;</yellow>
		unsigned long eip = kvm_get_linear_rip(vcpu);
<yellow>		u32 dr6 = kvm_vcpu_check_hw_bp(eip, 0,</yellow>
					   vcpu-&gt;arch.guest_debug_dr7,
					   vcpu-&gt;arch.eff_db);

<yellow>		if (dr6 != 0) {</yellow>
<yellow>			kvm_run->debug.arch.dr6 = dr6 | DR6_ACTIVE_LOW;</yellow>
			kvm_run-&gt;debug.arch.pc = eip;
			kvm_run-&gt;debug.arch.exception = DB_VECTOR;
			kvm_run-&gt;exit_reason = KVM_EXIT_DEBUG;
			*r = 0;
			return true;
		}
	}

<blue>	if (unlikely(vcpu->arch.dr7 & DR7_BP_EN_MASK) &&</blue>
<blue>	    !kvm_is_code_breakpoint_inhibited(vcpu)) {</blue>
<blue>		unsigned long eip = kvm_get_linear_rip(vcpu);</blue>
<blue>		u32 dr6 = kvm_vcpu_check_hw_bp(eip, 0,</blue>
					   vcpu-&gt;arch.dr7,
					   vcpu-&gt;arch.db);

<blue>		if (dr6 != 0) {</blue>
<yellow>			kvm_queue_exception_p(vcpu, DB_VECTOR, dr6);</yellow>
			*r = 1;
			return true;
		}
	}

	return false;
}

static bool is_vmware_backdoor_opcode(struct x86_emulate_ctxt *ctxt)
{
<yellow>	switch (ctxt->opcode_len) {</yellow>
	case 1:
<yellow>		switch (ctxt->b) {</yellow>
		case 0xe4:	/* IN */
		case 0xe5:
		case 0xec:
		case 0xed:
		case 0xe6:	/* OUT */
		case 0xe7:
		case 0xee:
		case 0xef:
		case 0x6c:	/* INS */
		case 0x6d:
		case 0x6e:	/* OUTS */
		case 0x6f:
			return true;
		}
		break;
	case 2:
<yellow>		switch (ctxt->b) {</yellow>
		case 0x33:	/* RDPMC */
			return true;
		}
		break;
	}

	return false;
}

/*
 * Decode an instruction for emulation.  The caller is responsible for handling
 * code breakpoints.  Note, manually detecting code breakpoints is unnecessary
 * (and wrong) when emulating on an intercepted fault-like exception[*], as
 * code breakpoints have higher priority and thus have already been done by
 * hardware.
 *
 * [*] Except #MC, which is higher priority, but KVM should never emulate in
 *     response to a machine check.
 */
int x86_decode_emulated_instruction(struct kvm_vcpu *vcpu, int emulation_type,
				    void *insn, int insn_len)
{
<blue>	struct x86_emulate_ctxt *ctxt = vcpu->arch.emulate_ctxt;</blue>
	int r;

	init_emulate_ctxt(vcpu);

	r = x86_decode_insn(ctxt, insn, insn_len, emulation_type);

<blue>	trace_kvm_emulate_insn_start(vcpu);</blue>
<blue>	++vcpu->stat.insn_emulation;</blue>

	return r;
}
EXPORT_SYMBOL_GPL(x86_decode_emulated_instruction);

int x86_emulate_instruction(struct kvm_vcpu *vcpu, gpa_t cr2_or_gpa,
			    int emulation_type, void *insn, int insn_len)
{
	int r;
<blue>	struct x86_emulate_ctxt *ctxt = vcpu->arch.emulate_ctxt;</blue>
	bool writeback = true;
	bool write_fault_to_spt;

	if (unlikely(!kvm_can_emulate_insn(vcpu, emulation_type, insn, insn_len)))
		return 1;

<blue>	vcpu->arch.l1tf_flush_l1d = true;</blue>

	/*
	 * Clear write_fault_to_shadow_pgtable here to ensure it is
	 * never reused.
	 */
	write_fault_to_spt = vcpu-&gt;arch.write_fault_to_shadow_pgtable;
<blue>	vcpu->arch.write_fault_to_shadow_pgtable = false;</blue>

	if (!(emulation_type &amp; EMULTYPE_NO_DECODE)) {
<blue>		kvm_clear_exception_queue(vcpu);</blue>

		/*
		 * Return immediately if RIP hits a code breakpoint, such #DBs
		 * are fault-like and are higher priority than any faults on
		 * the code fetch itself.
		 */
<blue>		if (kvm_vcpu_check_code_breakpoint(vcpu, emulation_type, &r))</blue>
			return r;

<blue>		r = x86_decode_emulated_instruction(vcpu, emulation_type,</blue>
						    insn, insn_len);
		if (r != EMULATION_OK)  {
<blue>			if ((emulation_type & EMULTYPE_TRAP_UD) ||</blue>
			    (emulation_type &amp; EMULTYPE_TRAP_UD_FORCED)) {
<blue>				kvm_queue_exception(vcpu, UD_VECTOR);</blue>
				return 1;
			}
<blue>			if (reexecute_instruction(vcpu, cr2_or_gpa,</blue>
						  write_fault_to_spt,
						  emulation_type))
				return 1;

<blue>			if (ctxt->have_exception &&</blue>
<yellow>			    !(emulation_type & EMULTYPE_SKIP)) {</yellow>
				/*
				 * #UD should result in just EMULATION_FAILED, and trap-like
				 * exception should not be encountered during decode.
				 */
<yellow>				WARN_ON_ONCE(ctxt->exception.vector == UD_VECTOR ||</yellow>
					     exception_type(ctxt-&gt;exception.vector) == EXCPT_TRAP);
<yellow>				inject_emulated_exception(vcpu);</yellow>
				return 1;
			}
			return handle_emulation_failure(vcpu, emulation_type);
		}
	}

<blue>	if ((emulation_type & EMULTYPE_VMWARE_GP) &&</blue>
<yellow>	    !is_vmware_backdoor_opcode(ctxt)) {</yellow>
<yellow>		kvm_queue_exception_e(vcpu, GP_VECTOR, 0);</yellow>
		return 1;
	}

	/*
	 * EMULTYPE_SKIP without EMULTYPE_COMPLETE_USER_EXIT is intended for
	 * use *only* by vendor callbacks for kvm_skip_emulated_instruction().
	 * The caller is responsible for updating interruptibility state and
	 * injecting single-step #DBs.
	 */
<blue>	if (emulation_type & EMULTYPE_SKIP) {</blue>
<yellow>		if (ctxt->mode != X86EMUL_MODE_PROT64)</yellow>
<yellow>			ctxt->eip = (u32)ctxt->_eip;</yellow>
		else
			ctxt-&gt;eip = ctxt-&gt;_eip;

		if (emulation_type &amp; EMULTYPE_COMPLETE_USER_EXIT) {
			r = 1;
			goto writeback;
		}

<yellow>		kvm_rip_write(vcpu, ctxt->eip);</yellow>
		if (ctxt-&gt;eflags &amp; X86_EFLAGS_RF)
<yellow>			kvm_set_rflags(vcpu, ctxt->eflags & ~X86_EFLAGS_RF);</yellow>
		return 1;
	}

<blue>	if (retry_instruction(ctxt, cr2_or_gpa, emulation_type))</blue>
		return 1;

	/* this is needed for vmware backdoor interface to work since it
	   changes registers values  during IO operation */
<blue>	if (vcpu->arch.emulate_regs_need_sync_from_vcpu) {</blue>
<yellow>		vcpu->arch.emulate_regs_need_sync_from_vcpu = false;</yellow>
		emulator_invalidate_register_cache(ctxt);
	}

restart:
<blue>	if (emulation_type & EMULTYPE_PF) {</blue>
		/* Save the faulting GPA (cr2) in the address field */
<blue>		ctxt->exception.address = cr2_or_gpa;</blue>

		/* With shadow page tables, cr2 contains a GVA or nGPA. */
		if (vcpu-&gt;arch.mmu-&gt;root_role.direct) {
<blue>			ctxt->gpa_available = true;</blue>
			ctxt-&gt;gpa_val = cr2_or_gpa;
		}
	} else {
		/* Sanitize the address out of an abundance of paranoia. */
<blue>		ctxt->exception.address = 0;</blue>
	}

<blue>	r = x86_emulate_insn(ctxt);</blue>

	if (r == EMULATION_INTERCEPTED)
		return 1;

<blue>	if (r == EMULATION_FAILED) {</blue>
<blue>		if (reexecute_instruction(vcpu, cr2_or_gpa, write_fault_to_spt,</blue>
					emulation_type))
			return 1;

<blue>		return handle_emulation_failure(vcpu, emulation_type);</blue>
	}

<blue>	if (ctxt->have_exception) {</blue>
		r = 1;
<blue>		inject_emulated_exception(vcpu);</blue>
<blue>	} else if (vcpu->arch.pio.count) {</blue>
<blue>		if (!vcpu->arch.pio.in) {</blue>
			/* FIXME: return into emulator if single-stepping.  */
			vcpu-&gt;arch.pio.count = 0;
		} else {
			writeback = false;
<blue>			vcpu->arch.complete_userspace_io = complete_emulated_pio;</blue>
		}
<blue>		r = 0;</blue>
<blue>	} else if (vcpu->mmio_needed) {</blue>
<blue>		++vcpu->stat.mmio_exits;</blue>

		if (!vcpu-&gt;mmio_is_write)
			writeback = false;
		r = 0;
<blue>		vcpu->arch.complete_userspace_io = complete_emulated_mmio;</blue>
<blue>	} else if (vcpu->arch.complete_userspace_io) {</blue>
		writeback = false;
		r = 0;
<blue>	} else if (r == EMULATION_RESTART)</blue>
		goto restart;
	else
		r = 1;

writeback:
	if (writeback) {
<blue>		unsigned long rflags = static_call(kvm_x86_get_rflags)(vcpu);</blue>
<blue>		toggle_interruptibility(vcpu, ctxt->interruptibility);</blue>
<blue>		vcpu->arch.emulate_regs_need_sync_to_vcpu = false;</blue>

		/*
		 * Note, EXCPT_DB is assumed to be fault-like as the emulator
		 * only supports code breakpoints and general detect #DB, both
		 * of which are fault-like.
		 */
<blue>		if (!ctxt->have_exception ||</blue>
<blue>		    exception_type(ctxt->exception.vector) == EXCPT_TRAP) {</blue>
<blue>			kvm_pmu_trigger_event(vcpu, PERF_COUNT_HW_INSTRUCTIONS);</blue>
<blue>			if (ctxt->is_branch)</blue>
<blue>				kvm_pmu_trigger_event(vcpu, PERF_COUNT_HW_BRANCH_INSTRUCTIONS);</blue>
<blue>			kvm_rip_write(vcpu, ctxt->eip);</blue>
<blue>			if (r && (ctxt->tf || (vcpu->guest_debug & KVM_GUESTDBG_SINGLESTEP)))</blue>
<yellow>				r = kvm_vcpu_do_singlestep(vcpu);</yellow>
			static_call_cond(kvm_x86_update_emulated_instruction)(vcpu);
<blue>			__kvm_set_rflags(vcpu, ctxt->eflags);</blue>
		}

		/*
		 * For STI, interrupts are shadowed; so KVM_REQ_EVENT will
		 * do nothing, and it will be requested again as soon as
		 * the shadow expires.  But we still need to check here,
		 * because POPF has no interrupt shadow.
		 */
<blue>		if (unlikely((ctxt->eflags & ~rflags) & X86_EFLAGS_IF))</blue>
<yellow>			kvm_make_request(KVM_REQ_EVENT, vcpu);</yellow>
	} else
<blue>		vcpu->arch.emulate_regs_need_sync_to_vcpu = true;</blue>

	return r;
<blue>}</blue>

int kvm_emulate_instruction(struct kvm_vcpu *vcpu, int emulation_type)
{
<blue>	return x86_emulate_instruction(vcpu, 0, emulation_type, NULL, 0);</blue>
}
EXPORT_SYMBOL_GPL(kvm_emulate_instruction);

int kvm_emulate_instruction_from_buffer(struct kvm_vcpu *vcpu,
					void *insn, int insn_len)
{
<yellow>	return x86_emulate_instruction(vcpu, 0, 0, insn, insn_len);</yellow>
}
EXPORT_SYMBOL_GPL(kvm_emulate_instruction_from_buffer);

static int complete_fast_pio_out_port_0x7e(struct kvm_vcpu *vcpu)
{
<yellow>	vcpu->arch.pio.count = 0;</yellow>
	return 1;
}

static int complete_fast_pio_out(struct kvm_vcpu *vcpu)
{
<blue>	vcpu->arch.pio.count = 0;</blue>

	if (unlikely(!kvm_is_linear_rip(vcpu, vcpu-&gt;arch.pio.linear_rip)))
<yellow>		return 1;</yellow>

<blue>	return kvm_skip_emulated_instruction(vcpu);</blue>
<blue>}</blue>

static int kvm_fast_pio_out(struct kvm_vcpu *vcpu, int size,
			    unsigned short port)
{
<blue>	unsigned long val = kvm_rax_read(vcpu);</blue>
	int ret = emulator_pio_out(vcpu, size, port, &amp;val, 1);

	if (ret)
		return ret;

	/*
	 * Workaround userspace that relies on old KVM behavior of %rip being
	 * incremented prior to exiting to userspace to handle &quot;OUT 0x7e&quot;.
	 */
<blue>	if (port == 0x7e &&</blue>
<yellow>	    kvm_check_has_quirk(vcpu->kvm, KVM_X86_QUIRK_OUT_7E_INC_RIP)) {</yellow>
<yellow>		vcpu->arch.complete_userspace_io =</yellow>
			complete_fast_pio_out_port_0x7e;
		kvm_skip_emulated_instruction(vcpu);
	} else {
<blue>		vcpu->arch.pio.linear_rip = kvm_get_linear_rip(vcpu);</blue>
		vcpu-&gt;arch.complete_userspace_io = complete_fast_pio_out;
	}
	return 0;
}

static int complete_fast_pio_in(struct kvm_vcpu *vcpu)
<blue>{</blue>
	unsigned long val;

	/* We should only ever be called with arch.pio.count equal to 1 */
<blue>	BUG_ON(vcpu->arch.pio.count != 1);</blue>

<blue>	if (unlikely(!kvm_is_linear_rip(vcpu, vcpu->arch.pio.linear_rip))) {</blue>
<yellow>		vcpu->arch.pio.count = 0;</yellow>
		return 1;
	}

	/* For size less than 4 we merge, else we zero extend */
<blue>	val = (vcpu->arch.pio.size < 4) ? kvm_rax_read(vcpu) : 0;</blue>

<blue>	complete_emulator_pio_in(vcpu, &val);</blue>
	kvm_rax_write(vcpu, val);

<blue>	return kvm_skip_emulated_instruction(vcpu);</blue>
}

static int kvm_fast_pio_in(struct kvm_vcpu *vcpu, int size,
			   unsigned short port)
{
	unsigned long val;
	int ret;

	/* For size less than 4 we merge, else we zero extend */
<blue>	val = (size < 4) ? kvm_rax_read(vcpu) : 0;</blue>

<blue>	ret = emulator_pio_in(vcpu, size, port, &val, 1);</blue>
	if (ret) {
		kvm_rax_write(vcpu, val);
		return ret;
	}

<blue>	vcpu->arch.pio.linear_rip = kvm_get_linear_rip(vcpu);</blue>
	vcpu-&gt;arch.complete_userspace_io = complete_fast_pio_in;

	return 0;
}

<blue>int kvm_fast_pio(struct kvm_vcpu *vcpu, int size, unsigned short port, int in)</blue>
<blue>{</blue>
	int ret;

<blue>	if (in)</blue>
<blue>		ret = kvm_fast_pio_in(vcpu, size, port);</blue>
	else
<blue>		ret = kvm_fast_pio_out(vcpu, size, port);</blue>
<blue>	return ret && kvm_skip_emulated_instruction(vcpu);</blue>
}
EXPORT_SYMBOL_GPL(kvm_fast_pio);

static int kvmclock_cpu_down_prep(unsigned int cpu)
{
<yellow>	__this_cpu_write(cpu_tsc_khz, 0);</yellow>
	return 0;
}

static void tsc_khz_changed(void *data)
{
	struct cpufreq_freqs *freq = data;
	unsigned long khz = 0;

<yellow>	WARN_ON_ONCE(boot_cpu_has(X86_FEATURE_CONSTANT_TSC));</yellow>

<yellow>	if (data)</yellow>
<yellow>		khz = freq->new;</yellow>
	else
<yellow>		khz = cpufreq_quick_get(raw_smp_processor_id());</yellow>
<yellow>	if (!khz)</yellow>
<yellow>		khz = tsc_khz;</yellow>
<yellow>	__this_cpu_write(cpu_tsc_khz, khz);</yellow>
}

#ifdef CONFIG_X86_64
static void kvm_hyperv_tsc_notifier(void)
{
	struct kvm *kvm;
	int cpu;

<yellow>	mutex_lock(&kvm_lock);</yellow>
	list_for_each_entry(kvm, &amp;vm_list, vm_list)
<yellow>		kvm_make_mclock_inprogress_request(kvm);</yellow>

	/* no guest entries from this point */
<yellow>	hyperv_stop_tsc_emulation();</yellow>

	/* TSC frequency always matches when on Hyper-V */
	if (!boot_cpu_has(X86_FEATURE_CONSTANT_TSC)) {
<yellow>		for_each_present_cpu(cpu)</yellow>
<yellow>			per_cpu(cpu_tsc_khz, cpu) = tsc_khz;</yellow>
	}
<yellow>	kvm_caps.max_guest_tsc_khz = tsc_khz;</yellow>

	list_for_each_entry(kvm, &amp;vm_list, vm_list) {
<yellow>		__kvm_start_pvclock_update(kvm);</yellow>
		pvclock_update_vm_gtod_copy(kvm);
		kvm_end_pvclock_update(kvm);
	}

<yellow>	mutex_unlock(&kvm_lock);</yellow>
}
#endif

static void __kvmclock_cpufreq_notifier(struct cpufreq_freqs *freq, int cpu)
{
	struct kvm *kvm;
	struct kvm_vcpu *vcpu;
	int send_ipi = 0;
	unsigned long i;

	/*
	 * We allow guests to temporarily run on slowing clocks,
	 * provided we notify them after, or to run on accelerating
	 * clocks, provided we notify them before.  Thus time never
	 * goes backwards.
	 *
	 * However, we have a problem.  We can&#x27;t atomically update
	 * the frequency of a given CPU from this function; it is
	 * merely a notifier, which can be called from any CPU.
	 * Changing the TSC frequency at arbitrary points in time
	 * requires a recomputation of local variables related to
	 * the TSC for each VCPU.  We must flag these local variables
	 * to be updated and be sure the update takes place with the
	 * new frequency before any guests proceed.
	 *
	 * Unfortunately, the combination of hotplug CPU and frequency
	 * change creates an intractable locking scenario; the order
	 * of when these callouts happen is undefined with respect to
	 * CPU hotplug, and they can race with each other.  As such,
	 * merely setting per_cpu(cpu_tsc_khz) = X during a hotadd is
	 * undefined; you can actually have a CPU frequency change take
	 * place in between the computation of X and the setting of the
	 * variable.  To protect against this problem, all updates of
	 * the per_cpu tsc_khz variable are done in an interrupt
	 * protected IPI, and all callers wishing to update the value
	 * must wait for a synchronous IPI to complete (which is trivial
	 * if the caller is on the CPU already).  This establishes the
	 * necessary total order on variable updates.
	 *
	 * Note that because a guest time update may take place
	 * anytime after the setting of the VCPU&#x27;s request bit, the
	 * correct TSC value must be set before the request.  However,
	 * to ensure the update actually makes it to any guest which
	 * starts running in hardware virtualization between the set
	 * and the acquisition of the spinlock, we must also ping the
	 * CPU after setting the request bit.
	 *
	 */

<yellow>	smp_call_function_single(cpu, tsc_khz_changed, freq, 1);</yellow>

	mutex_lock(&amp;kvm_lock);
<yellow>	list_for_each_entry(kvm, &vm_list, vm_list) {</yellow>
<yellow>		kvm_for_each_vcpu(i, vcpu, kvm) {</yellow>
<yellow>			if (vcpu->cpu != cpu)</yellow>
				continue;
<yellow>			kvm_make_request(KVM_REQ_CLOCK_UPDATE, vcpu);</yellow>
			if (vcpu-&gt;cpu != raw_smp_processor_id())
				send_ipi = 1;
		}
	}
<yellow>	mutex_unlock(&kvm_lock);</yellow>

<yellow>	if (freq->old < freq->new && send_ipi) {</yellow>
		/*
		 * We upscale the frequency.  Must make the guest
		 * doesn&#x27;t see old kvmclock values while running with
		 * the new frequency, otherwise we risk the guest sees
		 * time go backwards.
		 *
		 * In case we update the frequency for another cpu
		 * (which might be in guest context) send an interrupt
		 * to kick the cpu out of guest context.  Next time
		 * guest context is entered kvmclock will be updated,
		 * so the guest will not see stale values.
		 */
<yellow>		smp_call_function_single(cpu, tsc_khz_changed, freq, 1);</yellow>
	}
}

static int kvmclock_cpufreq_notifier(struct notifier_block *nb, unsigned long val,
				     void *data)
<yellow>{</yellow>
	struct cpufreq_freqs *freq = data;
	int cpu;

<yellow>	if (val == CPUFREQ_PRECHANGE && freq->old > freq->new)</yellow>
		return 0;
<yellow>	if (val == CPUFREQ_POSTCHANGE && freq->old < freq->new)</yellow>
		return 0;

<yellow>	for_each_cpu(cpu, freq->policy->cpus)</yellow>
<yellow>		__kvmclock_cpufreq_notifier(freq, cpu);</yellow>

	return 0;
}

static struct notifier_block kvmclock_cpufreq_notifier_block = {
	.notifier_call  = kvmclock_cpufreq_notifier
};

static int kvmclock_cpu_online(unsigned int cpu)
{
<yellow>	tsc_khz_changed(NULL);</yellow>
	return 0;
}

static void kvm_timer_init(void)
{
<yellow>	if (!boot_cpu_has(X86_FEATURE_CONSTANT_TSC)) {</yellow>
<yellow>		max_tsc_khz = tsc_khz;</yellow>

		if (IS_ENABLED(CONFIG_CPU_FREQ)) {
			struct cpufreq_policy *policy;
			int cpu;

			cpu = get_cpu();
			policy = cpufreq_cpu_get(cpu);
			if (policy) {
<yellow>				if (policy->cpuinfo.max_freq)</yellow>
<yellow>					max_tsc_khz = policy->cpuinfo.max_freq;</yellow>
<yellow>				cpufreq_cpu_put(policy);</yellow>
			}
<yellow>			put_cpu();</yellow>
		}
<yellow>		cpufreq_register_notifier(&kvmclock_cpufreq_notifier_block,</yellow>
					  CPUFREQ_TRANSITION_NOTIFIER);

		cpuhp_setup_state(CPUHP_AP_X86_KVM_CLK_ONLINE, &quot;x86/kvm/clk:online&quot;,
				  kvmclock_cpu_online, kvmclock_cpu_down_prep);
	}
}

#ifdef CONFIG_X86_64
static void pvclock_gtod_update_fn(struct work_struct *work)
{
	struct kvm *kvm;
	struct kvm_vcpu *vcpu;
	unsigned long i;

<yellow>	mutex_lock(&kvm_lock);</yellow>
<yellow>	list_for_each_entry(kvm, &vm_list, vm_list)</yellow>
<yellow>		kvm_for_each_vcpu(i, vcpu, kvm)</yellow>
<yellow>			kvm_make_request(KVM_REQ_MASTERCLOCK_UPDATE, vcpu);</yellow>
<yellow>	atomic_set(&kvm_guest_has_master_clock, 0);</yellow>
	mutex_unlock(&amp;kvm_lock);
}

static DECLARE_WORK(pvclock_gtod_work, pvclock_gtod_update_fn);

/*
 * Indirection to move queue_work() out of the tk_core.seq write held
 * region to prevent possible deadlocks against time accessors which
 * are invoked with work related locks held.
 */
static void pvclock_irq_work_fn(struct irq_work *w)
{
<yellow>	queue_work(system_long_wq, &pvclock_gtod_work);</yellow>
}

static DEFINE_IRQ_WORK(pvclock_irq_work, pvclock_irq_work_fn);

/*
 * Notification about pvclock gtod data update.
 */
<yellow>static int pvclock_gtod_notify(struct notifier_block *nb, unsigned long unused,</yellow>
			       void *priv)
{
	struct pvclock_gtod_data *gtod = &amp;pvclock_gtod_data;
	struct timekeeper *tk = priv;

<yellow>	update_pvclock_gtod(tk);</yellow>

	/*
	 * Disable master clock if host does not trust, or does not use,
	 * TSC based clocksource. Delegate queue_work() to irq_work as
	 * this is invoked with tk_core.seq write held.
	 */
	if (!gtod_is_based_on_tsc(gtod-&gt;clock.vclock_mode) &amp;&amp;
<yellow>	    atomic_read(&kvm_guest_has_master_clock) != 0)</yellow>
<yellow>		irq_work_queue(&pvclock_irq_work);</yellow>
	return 0;
<yellow>}</yellow>

static struct notifier_block pvclock_gtod_notifier = {
	.notifier_call = pvclock_gtod_notify,
};
#endif

int kvm_arch_init(void *opaque)
<yellow>{</yellow>
	struct kvm_x86_init_ops *ops = opaque;
	u64 host_pat;
	int r;

<yellow>	if (kvm_x86_ops.hardware_enable) {</yellow>
		pr_err(&quot;kvm: already loaded vendor module &#x27;%s&#x27;\n&quot;, kvm_x86_ops.name);
		return -EEXIST;
	}

<yellow>	if (!ops->cpu_has_kvm_support()) {</yellow>
<yellow>		pr_err_ratelimited("kvm: no hardware support for '%s'\n",</yellow>
				   ops-&gt;runtime_ops-&gt;name);
		return -EOPNOTSUPP;
	}
<yellow>	if (ops->disabled_by_bios()) {</yellow>
<yellow>		pr_err_ratelimited("kvm: support for '%s' disabled by bios\n",</yellow>
				   ops-&gt;runtime_ops-&gt;name);
		return -EOPNOTSUPP;
	}

	/*
	 * KVM explicitly assumes that the guest has an FPU and
	 * FXSAVE/FXRSTOR. For example, the KVM_GET_FPU explicitly casts the
	 * vCPU&#x27;s FPU state as a fxregs_state struct.
	 */
	if (!boot_cpu_has(X86_FEATURE_FPU) || !boot_cpu_has(X86_FEATURE_FXSR)) {
		printk(KERN_ERR &quot;kvm: inadequate fpu\n&quot;);
		return -EOPNOTSUPP;
	}

	if (IS_ENABLED(CONFIG_PREEMPT_RT) &amp;&amp; !boot_cpu_has(X86_FEATURE_CONSTANT_TSC)) {
		pr_err(&quot;RT requires X86_FEATURE_CONSTANT_TSC\n&quot;);
		return -EOPNOTSUPP;
	}

	/*
	 * KVM assumes that PAT entry &#x27;0&#x27; encodes WB memtype and simply zeroes
	 * the PAT bits in SPTEs.  Bail if PAT[0] is programmed to something
	 * other than WB.  Note, EPT doesn&#x27;t utilize the PAT, but don&#x27;t bother
	 * with an exception.  PAT[0] is set to WB on RESET and also by the
	 * kernel, i.e. failure indicates a kernel bug or broken firmware.
	 */
<yellow>	if (rdmsrl_safe(MSR_IA32_CR_PAT, &host_pat) ||</yellow>
<yellow>	    (host_pat & GENMASK(2, 0)) != 6) {</yellow>
		pr_err(&quot;kvm: host PAT[0] is not WB\n&quot;);
		return -EIO;
	}

<yellow>	x86_emulator_cache = kvm_alloc_emulator_cache();</yellow>
	if (!x86_emulator_cache) {
		pr_err(&quot;kvm: failed to allocate cache for x86 emulator\n&quot;);
		return -ENOMEM;
	}

<yellow>	user_return_msrs = alloc_percpu(struct kvm_user_return_msrs);</yellow>
	if (!user_return_msrs) {
		printk(KERN_ERR &quot;kvm: failed to allocate percpu kvm_user_return_msrs\n&quot;);
		r = -ENOMEM;
		goto out_free_x86_emulator_cache;
	}
<yellow>	kvm_nr_uret_msrs = 0;</yellow>

	r = kvm_mmu_vendor_module_init();
	if (r)
		goto out_free_percpu;

<yellow>	kvm_timer_init();</yellow>

<yellow>	if (boot_cpu_has(X86_FEATURE_XSAVE)) {</yellow>
<yellow>		host_xcr0 = xgetbv(XCR_XFEATURE_ENABLED_MASK);</yellow>
		kvm_caps.supported_xcr0 = host_xcr0 &amp; KVM_SUPPORTED_XCR0;
	}

<yellow>	if (pi_inject_timer == -1)</yellow>
<yellow>		pi_inject_timer = housekeeping_enabled(HK_TYPE_TIMER);</yellow>
#ifdef CONFIG_X86_64
<yellow>	pvclock_gtod_register_notifier(&pvclock_gtod_notifier);</yellow>

	if (hypervisor_is_type(X86_HYPER_MS_HYPERV))
<yellow>		set_hv_tscchange_cb(kvm_hyperv_tsc_notifier);</yellow>
#endif

	return 0;

out_free_percpu:
<yellow>	free_percpu(user_return_msrs);</yellow>
out_free_x86_emulator_cache:
<yellow>	kmem_cache_destroy(x86_emulator_cache);</yellow>
	return r;
}

void kvm_arch_exit(void)
{
#ifdef CONFIG_X86_64
<yellow>	if (hypervisor_is_type(X86_HYPER_MS_HYPERV))</yellow>
<yellow>		clear_hv_tscchange_cb();</yellow>
#endif
<yellow>	kvm_lapic_exit();</yellow>

	if (!boot_cpu_has(X86_FEATURE_CONSTANT_TSC)) {
<yellow>		cpufreq_unregister_notifier(&kvmclock_cpufreq_notifier_block,</yellow>
					    CPUFREQ_TRANSITION_NOTIFIER);
		cpuhp_remove_state_nocalls(CPUHP_AP_X86_KVM_CLK_ONLINE);
	}
#ifdef CONFIG_X86_64
<yellow>	pvclock_gtod_unregister_notifier(&pvclock_gtod_notifier);</yellow>
	irq_work_sync(&amp;pvclock_irq_work);
	cancel_work_sync(&amp;pvclock_gtod_work);
#endif
	kvm_x86_ops.hardware_enable = NULL;
	kvm_mmu_vendor_module_exit();
	free_percpu(user_return_msrs);
	kmem_cache_destroy(x86_emulator_cache);
#ifdef CONFIG_KVM_XEN
	static_key_deferred_flush(&amp;kvm_xen_enabled);
<yellow>	WARN_ON(static_branch_unlikely(&kvm_xen_enabled.key));</yellow>
#endif
<yellow>}</yellow>

static int __kvm_emulate_halt(struct kvm_vcpu *vcpu, int state, int reason)
{
	/*
	 * The vCPU has halted, e.g. executed HLT.  Update the run state if the
	 * local APIC is in-kernel, the run loop will detect the non-runnable
	 * state and halt the vCPU.  Exit to userspace if the local APIC is
	 * managed by userspace, in which case userspace is responsible for
	 * handling wake events.
	 */
<blue>	++vcpu->stat.halt_exits;</blue>
<yellow>	if (lapic_in_kernel(vcpu)) {</yellow>
<blue>		vcpu->arch.mp_state = state;</blue>
		return 1;
	} else {
<yellow>		vcpu->run->exit_reason = reason;</yellow>
		return 0;
	}
}

int kvm_emulate_halt_noskip(struct kvm_vcpu *vcpu)
{
<blue>	return __kvm_emulate_halt(vcpu, KVM_MP_STATE_HALTED, KVM_EXIT_HLT);</blue>
<blue>}</blue>
EXPORT_SYMBOL_GPL(kvm_emulate_halt_noskip);

int kvm_emulate_halt(struct kvm_vcpu *vcpu)
{
<blue>	int ret = kvm_skip_emulated_instruction(vcpu);</blue>
	/*
	 * TODO: we might be squashing a GUESTDBG_SINGLESTEP-triggered
	 * KVM_EXIT_DEBUG here.
	 */
<blue>	return kvm_emulate_halt_noskip(vcpu) && ret;</blue>
<blue>}</blue>
EXPORT_SYMBOL_GPL(kvm_emulate_halt);

int kvm_emulate_ap_reset_hold(struct kvm_vcpu *vcpu)
{
<yellow>	int ret = kvm_skip_emulated_instruction(vcpu);</yellow>

<yellow>	return __kvm_emulate_halt(vcpu, KVM_MP_STATE_AP_RESET_HOLD,</yellow>
					KVM_EXIT_AP_RESET_HOLD) &amp;&amp; ret;
<yellow>}</yellow>
EXPORT_SYMBOL_GPL(kvm_emulate_ap_reset_hold);

#ifdef CONFIG_X86_64
static int kvm_pv_clock_pairing(struct kvm_vcpu *vcpu, gpa_t paddr,
			        unsigned long clock_type)
{
	struct kvm_clock_pairing clock_pairing;
	struct timespec64 ts;
	u64 cycle;
	int ret;

<yellow>	if (clock_type != KVM_CLOCK_PAIRING_WALLCLOCK)</yellow>
		return -KVM_EOPNOTSUPP;

	/*
	 * When tsc is in permanent catchup mode guests won&#x27;t be able to use
	 * pvclock_read_retry loop to get consistent view of pvclock
	 */
<yellow>	if (vcpu->arch.tsc_always_catchup)</yellow>
		return -KVM_EOPNOTSUPP;

<yellow>	if (!kvm_get_walltime_and_clockread(&ts, &cycle))</yellow>
		return -KVM_EOPNOTSUPP;

<yellow>	clock_pairing.sec = ts.tv_sec;</yellow>
	clock_pairing.nsec = ts.tv_nsec;
<yellow>	clock_pairing.tsc = kvm_read_l1_tsc(vcpu, cycle);</yellow>
	clock_pairing.flags = 0;
	memset(&amp;clock_pairing.pad, 0, sizeof(clock_pairing.pad));

	ret = 0;
	if (kvm_write_guest(vcpu-&gt;kvm, paddr, &amp;clock_pairing,
			    sizeof(struct kvm_clock_pairing)))
		ret = -KVM_EFAULT;

	return ret;
}
#endif

/*
 * kvm_pv_kick_cpu_op:  Kick a vcpu.
 *
 * @apicid - apicid of vcpu to be kicked.
 */
static void kvm_pv_kick_cpu_op(struct kvm *kvm, int apicid)
{
	/*
	 * All other fields are unused for APIC_DM_REMRD, but may be consumed by
	 * common code, e.g. for tracing. Defer initialization to the compiler.
	 */
	struct kvm_lapic_irq lapic_irq = {
		.delivery_mode = APIC_DM_REMRD,
		.dest_mode = APIC_DEST_PHYSICAL,
		.shorthand = APIC_DEST_NOSHORT,
		.dest_id = apicid,
	};

	kvm_irq_delivery_to_apic(kvm, NULL, &amp;lapic_irq, NULL);
}

bool kvm_apicv_activated(struct kvm *kvm)
{
<blue>	return (READ_ONCE(kvm->arch.apicv_inhibit_reasons) == 0);</blue>
}
EXPORT_SYMBOL_GPL(kvm_apicv_activated);

bool kvm_vcpu_apicv_activated(struct kvm_vcpu *vcpu)
{
<blue>	ulong vm_reasons = READ_ONCE(vcpu->kvm->arch.apicv_inhibit_reasons);</blue>
	ulong vcpu_reasons = static_call(kvm_x86_vcpu_get_apicv_inhibit_reasons)(vcpu);

	return (vm_reasons | vcpu_reasons) == 0;
}
EXPORT_SYMBOL_GPL(kvm_vcpu_apicv_activated);

static void set_or_clear_apicv_inhibit(unsigned long *inhibits,
				       enum kvm_apicv_inhibit reason, bool set)
{
	if (set)
<blue>		__set_bit(reason, inhibits);</blue>
	else
<blue>		__clear_bit(reason, inhibits);</blue>

<blue>	trace_kvm_apicv_inhibit_changed(reason, set, *inhibits);</blue>
<blue>}</blue>

static void kvm_apicv_init(struct kvm *kvm)
{
	unsigned long *inhibits = &amp;kvm-&gt;arch.apicv_inhibit_reasons;

	init_rwsem(&amp;kvm-&gt;arch.apicv_update_lock);

	set_or_clear_apicv_inhibit(inhibits, APICV_INHIBIT_REASON_ABSENT, true);

<blue>	if (!enable_apicv)</blue>
<blue>		set_or_clear_apicv_inhibit(inhibits,</blue>
					   APICV_INHIBIT_REASON_DISABLE, true);
}

static void kvm_sched_yield(struct kvm_vcpu *vcpu, unsigned long dest_id)
{
	struct kvm_vcpu *target = NULL;
	struct kvm_apic_map *map;

<yellow>	vcpu->stat.directed_yield_attempted++;</yellow>

<yellow>	if (single_task_running())</yellow>
		goto no_yield;

<yellow>	rcu_read_lock();</yellow>
<yellow>	map = rcu_dereference(vcpu->kvm->arch.apic_map);</yellow>

<yellow>	if (likely(map) && dest_id <= map->max_apic_id && map->phys_map[dest_id])</yellow>
<yellow>		target = map->phys_map[dest_id]->vcpu;</yellow>

<yellow>	rcu_read_unlock();</yellow>

<yellow>	if (!target || !READ_ONCE(target->ready))</yellow>
		goto no_yield;

	/* Ignore requests to yield to self */
<yellow>	if (vcpu == target)</yellow>
		goto no_yield;

<yellow>	if (kvm_vcpu_yield_to(target) <= 0)</yellow>
		goto no_yield;

<yellow>	vcpu->stat.directed_yield_successful++;</yellow>

no_yield:
	return;
<yellow>}</yellow>

static int complete_hypercall_exit(struct kvm_vcpu *vcpu)
<yellow>{</yellow>
<yellow>	u64 ret = vcpu->run->hypercall.ret;</yellow>

<yellow>	if (!is_64_bit_mode(vcpu))</yellow>
<yellow>		ret = (u32)ret;</yellow>
<yellow>	kvm_rax_write(vcpu, ret);</yellow>
	++vcpu-&gt;stat.hypercalls;
<yellow>	return kvm_skip_emulated_instruction(vcpu);</yellow>
}

<yellow>int kvm_emulate_hypercall(struct kvm_vcpu *vcpu)</yellow>
{
	unsigned long nr, a0, a1, a2, a3, ret;
	int op_64_bit;

<yellow>	if (kvm_xen_hypercall_enabled(vcpu->kvm))</yellow>
<yellow>		return kvm_xen_hypercall(vcpu);</yellow>

<yellow>	if (kvm_hv_hypercall_enabled(vcpu))</yellow>
<yellow>		return kvm_hv_hypercall(vcpu);</yellow>

<yellow>	nr = kvm_rax_read(vcpu);</yellow>
	a0 = kvm_rbx_read(vcpu);
	a1 = kvm_rcx_read(vcpu);
	a2 = kvm_rdx_read(vcpu);
	a3 = kvm_rsi_read(vcpu);

<yellow>	trace_kvm_hypercall(nr, a0, a1, a2, a3);</yellow>

<yellow>	op_64_bit = is_64_bit_hypercall(vcpu);</yellow>
	if (!op_64_bit) {
		nr &amp;= 0xFFFFFFFF;
<yellow>		a0 &= 0xFFFFFFFF;</yellow>
		a1 &amp;= 0xFFFFFFFF;
		a2 &amp;= 0xFFFFFFFF;
<yellow>		a3 &= 0xFFFFFFFF;</yellow>
	}

<yellow>	if (static_call(kvm_x86_get_cpl)(vcpu) != 0) {</yellow>
		ret = -KVM_EPERM;
		goto out;
	}

	ret = -KVM_ENOSYS;

<yellow>	switch (nr) {</yellow>
	case KVM_HC_VAPIC_POLL_IRQ:
		ret = 0;
		break;
	case KVM_HC_KICK_CPU:
<yellow>		if (!guest_pv_has(vcpu, KVM_FEATURE_PV_UNHALT))</yellow>
			break;

<yellow>		kvm_pv_kick_cpu_op(vcpu->kvm, a1);</yellow>
<yellow>		kvm_sched_yield(vcpu, a1);</yellow>
		ret = 0;
		break;
#ifdef CONFIG_X86_64
	case KVM_HC_CLOCK_PAIRING:
<yellow>		ret = kvm_pv_clock_pairing(vcpu, a0, a1);</yellow>
<yellow>		break;</yellow>
#endif
	case KVM_HC_SEND_IPI:
<yellow>		if (!guest_pv_has(vcpu, KVM_FEATURE_PV_SEND_IPI))</yellow>
			break;

<yellow>		ret = kvm_pv_send_ipi(vcpu->kvm, a0, a1, a2, a3, op_64_bit);</yellow>
		break;
	case KVM_HC_SCHED_YIELD:
<yellow>		if (!guest_pv_has(vcpu, KVM_FEATURE_PV_SCHED_YIELD))</yellow>
			break;

<yellow>		kvm_sched_yield(vcpu, a0);</yellow>
		ret = 0;
		break;
	case KVM_HC_MAP_GPA_RANGE: {
		u64 gpa = a0, npages = a1, attrs = a2;

		ret = -KVM_ENOSYS;
<yellow>		if (!(vcpu->kvm->arch.hypercall_exit_enabled & (1 << KVM_HC_MAP_GPA_RANGE)))</yellow>
			break;

<yellow>		if (!PAGE_ALIGNED(gpa) || !npages ||</yellow>
<yellow>		    gpa_to_gfn(gpa) + npages <= gpa_to_gfn(gpa)) {</yellow>
			ret = -KVM_EINVAL;
			break;
		}

<yellow>		vcpu->run->exit_reason        = KVM_EXIT_HYPERCALL;</yellow>
		vcpu-&gt;run-&gt;hypercall.nr       = KVM_HC_MAP_GPA_RANGE;
		vcpu-&gt;run-&gt;hypercall.args[0]  = gpa;
		vcpu-&gt;run-&gt;hypercall.args[1]  = npages;
		vcpu-&gt;run-&gt;hypercall.args[2]  = attrs;
		vcpu-&gt;run-&gt;hypercall.longmode = op_64_bit;
		vcpu-&gt;arch.complete_userspace_io = complete_hypercall_exit;
		return 0;
	}
	default:
		ret = -KVM_ENOSYS;
		break;
	}
out:
<yellow>	if (!op_64_bit)</yellow>
		ret = (u32)ret;
<yellow>	kvm_rax_write(vcpu, ret);</yellow>

	++vcpu-&gt;stat.hypercalls;
<yellow>	return kvm_skip_emulated_instruction(vcpu);</yellow>
<yellow>}</yellow>
EXPORT_SYMBOL_GPL(kvm_emulate_hypercall);

static int emulator_fix_hypercall(struct x86_emulate_ctxt *ctxt)
<yellow>{</yellow>
<yellow>	struct kvm_vcpu *vcpu = emul_to_vcpu(ctxt);</yellow>
	char instruction[3];
<yellow>	unsigned long rip = kvm_rip_read(vcpu);</yellow>

	/*
	 * If the quirk is disabled, synthesize a #UD and let the guest pick up
	 * the pieces.
	 */
	if (!kvm_check_has_quirk(vcpu-&gt;kvm, KVM_X86_QUIRK_FIX_HYPERCALL_INSN)) {
<yellow>		ctxt->exception.error_code_valid = false;</yellow>
		ctxt-&gt;exception.vector = UD_VECTOR;
		ctxt-&gt;have_exception = true;
		return X86EMUL_PROPAGATE_FAULT;
	}

<yellow>	static_call(kvm_x86_patch_hypercall)(vcpu, instruction);</yellow>

	return emulator_write_emulated(ctxt, rip, instruction, 3,
		&amp;ctxt-&gt;exception);
}

static int dm_request_for_irq_injection(struct kvm_vcpu *vcpu)
{
<blue>	return vcpu->run->request_interrupt_window &&</blue>
		likely(!pic_in_kernel(vcpu-&gt;kvm));
}

/* Called within kvm-&gt;srcu read side.  */
static void post_kvm_run_save(struct kvm_vcpu *vcpu)
{
	struct kvm_run *kvm_run = vcpu-&gt;run;

<blue>	kvm_run->if_flag = static_call(kvm_x86_get_if_flag)(vcpu);</blue>
<blue>	kvm_run->cr8 = kvm_get_cr8(vcpu);</blue>
	kvm_run-&gt;apic_base = kvm_get_apic_base(vcpu);

<blue>	kvm_run->ready_for_interrupt_injection =</blue>
		pic_in_kernel(vcpu-&gt;kvm) ||
<yellow>		kvm_vcpu_ready_for_interrupt_injection(vcpu);</yellow>

	if (is_smm(vcpu))
<yellow>		kvm_run->flags |= KVM_RUN_X86_SMM;</yellow>
}

<blue>static void update_cr8_intercept(struct kvm_vcpu *vcpu)</blue>
{
	int max_irr, tpr;

<blue>	if (!kvm_x86_ops.update_cr8_intercept)</blue>
		return;

<blue>	if (!lapic_in_kernel(vcpu))</blue>
		return;

<blue>	if (vcpu->arch.apic->apicv_active)</blue>
		return;

<blue>	if (!vcpu->arch.apic->vapic_addr)</blue>
<blue>		max_irr = kvm_lapic_find_highest_irr(vcpu);</blue>
	else
		max_irr = -1;

	if (max_irr != -1)
<yellow>		max_irr >>= 4;</yellow>

<blue>	tpr = kvm_lapic_get_cr8(vcpu);</blue>

	static_call(kvm_x86_update_cr8_intercept)(vcpu, tpr, max_irr);
<blue>}</blue>


<yellow>int kvm_check_nested_events(struct kvm_vcpu *vcpu)</yellow>
{
<blue>	if (kvm_test_request(KVM_REQ_TRIPLE_FAULT, vcpu)) {</blue>
<yellow>		kvm_x86_ops.nested_ops->triple_fault(vcpu);</yellow>
		return 1;
	}

<blue>	return kvm_x86_ops.nested_ops->check_events(vcpu);</blue>
<blue>}</blue>

static void kvm_inject_exception(struct kvm_vcpu *vcpu)
{
<blue>	trace_kvm_inj_exception(vcpu->arch.exception.vector,</blue>
				vcpu-&gt;arch.exception.has_error_code,
				vcpu-&gt;arch.exception.error_code,
<blue>				vcpu->arch.exception.injected);</blue>

<blue>	if (vcpu->arch.exception.error_code && !is_protmode(vcpu))</blue>
<yellow>		vcpu->arch.exception.error_code = false;</yellow>
<blue>	static_call(kvm_x86_inject_exception)(vcpu);</blue>
}

/*
 * Check for any event (interrupt or exception) that is ready to be injected,
 * and if there is at least one event, inject the event with the highest
 * priority.  This handles both &quot;pending&quot; events, i.e. events that have never
 * been injected into the guest, and &quot;injected&quot; events, i.e. events that were
 * injected as part of a previous VM-Enter, but weren&#x27;t successfully delivered
 * and need to be re-injected.
 *
 * Note, this is not guaranteed to be invoked on a guest instruction boundary,
 * i.e. doesn&#x27;t guarantee that there&#x27;s an event window in the guest.  KVM must
 * be able to inject exceptions in the &quot;middle&quot; of an instruction, and so must
 * also be able to re-inject NMIs and IRQs in the middle of an instruction.
 * I.e. for exceptions and re-injected events, NOT invoking this on instruction
 * boundaries is necessary and correct.
 *
 * For simplicity, KVM uses a single path to inject all events (except events
 * that are injected directly from L1 to L2) and doesn&#x27;t explicitly track
 * instruction boundaries for asynchronous events.  However, because VM-Exits
 * that can occur during instruction execution typically result in KVM skipping
 * the instruction or injecting an exception, e.g. instruction and exception
 * intercepts, and because pending exceptions have higher priority than pending
 * interrupts, KVM still honors instruction boundaries in most scenarios.
 *
 * But, if a VM-Exit occurs during instruction execution, and KVM does NOT skip
 * the instruction or inject an exception, then KVM can incorrecty inject a new
 * asynchrounous event if the event became pending after the CPU fetched the
 * instruction (in the guest).  E.g. if a page fault (#PF, #NPF, EPT violation)
 * occurs and is resolved by KVM, a coincident NMI, SMI, IRQ, etc... can be
 * injected on the restarted instruction instead of being deferred until the
 * instruction completes.
 *
 * In practice, this virtualization hole is unlikely to be observed by the
 * guest, and even less likely to cause functional problems.  To detect the
 * hole, the guest would have to trigger an event on a side effect of an early
 * phase of instruction execution, e.g. on the instruction fetch from memory.
 * And for it to be a functional problem, the guest would need to depend on the
 * ordering between that side effect, the instruction completing, _and_ the
 * delivery of the asynchronous event.
 */
static int kvm_check_and_inject_events(struct kvm_vcpu *vcpu,
				       bool *req_immediate_exit)
{
	bool can_inject;
	int r;

	/*
	 * Process nested events first, as nested VM-Exit supercedes event
	 * re-injection.  If there&#x27;s an event queued for re-injection, it will
	 * be saved into the appropriate vmc{b,s}12 fields on nested VM-Exit.
	 */
<blue>	if (is_guest_mode(vcpu))</blue>
<blue>		r = kvm_check_nested_events(vcpu);</blue>
	else
		r = 0;

	/*
	 * Re-inject exceptions and events *especially* if immediate entry+exit
	 * to/from L2 is needed, as any event that has already been injected
	 * into L2 needs to complete its lifecycle before injecting a new event.
	 *
	 * Don&#x27;t re-inject an NMI or interrupt if there is a pending exception.
	 * This collision arises if an exception occurred while vectoring the
	 * injected event, KVM intercepted said exception, and KVM ultimately
	 * determined the fault belongs to the guest and queues the exception
	 * for injection back into the guest.
	 *
	 * &quot;Injected&quot; interrupts can also collide with pending exceptions if
	 * userspace ignores the &quot;ready for injection&quot; flag and blindly queues
	 * an interrupt.  In that case, prioritizing the exception is correct,
	 * as the exception &quot;occurred&quot; before the exit to userspace.  Trap-like
	 * exceptions, e.g. most #DBs, have higher priority than interrupts.
	 * And while fault-like exceptions, e.g. #GP and #PF, are the lowest
	 * priority, they&#x27;re only generated (pended) during instruction
	 * execution, and interrupts are recognized at instruction boundaries.
	 * Thus a pending fault-like exception means the fault occurred on the
	 * *previous* instruction and must be serviced prior to recognizing any
	 * new events in order to fully complete the previous instruction.
	 */
<blue>	if (vcpu->arch.exception.injected)</blue>
<blue>		kvm_inject_exception(vcpu);</blue>
<blue>	else if (kvm_is_exception_pending(vcpu))</blue>
		; /* see above */
<blue>	else if (vcpu->arch.nmi_injected)</blue>
<blue>		static_call(kvm_x86_inject_nmi)(vcpu);</blue>
<blue>	else if (vcpu->arch.interrupt.injected)</blue>
<blue>		static_call(kvm_x86_inject_irq)(vcpu, true);</blue>

	/*
	 * Exceptions that morph to VM-Exits are handled above, and pending
	 * exceptions on top of injected exceptions that do not VM-Exit should
	 * either morph to #DF or, sadly, override the injected exception.
	 */
<blue>	WARN_ON_ONCE(vcpu->arch.exception.injected &&</blue>
		     vcpu-&gt;arch.exception.pending);

	/*
	 * Bail if immediate entry+exit to/from the guest is needed to complete
	 * nested VM-Enter or event re-injection so that a different pending
	 * event can be serviced (or if KVM needs to exit to userspace).
	 *
	 * Otherwise, continue processing events even if VM-Exit occurred.  The
	 * VM-Exit will have cleared exceptions that were meant for L2, but
	 * there may now be events that can be injected into L1.
	 */
<blue>	if (r < 0)</blue>
		goto out;

	/*
	 * A pending exception VM-Exit should either result in nested VM-Exit
	 * or force an immediate re-entry and exit to/from L2, and exception
	 * VM-Exits cannot be injected (flag should _never_ be set).
	 */
<blue>	WARN_ON_ONCE(vcpu->arch.exception_vmexit.injected ||</blue>
		     vcpu-&gt;arch.exception_vmexit.pending);

	/*
	 * New events, other than exceptions, cannot be injected if KVM needs
	 * to re-inject a previous event.  See above comments on re-injecting
	 * for why pending exceptions get priority.
	 */
<blue>	can_inject = !kvm_event_needs_reinjection(vcpu);</blue>

<blue>	if (vcpu->arch.exception.pending) {</blue>
		/*
		 * Fault-class exceptions, except #DBs, set RF=1 in the RFLAGS
		 * value pushed on the stack.  Trap-like exception and all #DBs
		 * leave RF as-is (KVM follows Intel&#x27;s behavior in this regard;
		 * AMD states that code breakpoint #DBs excplitly clear RF=0).
		 *
		 * Note, most versions of Intel&#x27;s SDM and AMD&#x27;s APM incorrectly
		 * describe the behavior of General Detect #DBs, which are
		 * fault-like.  They do _not_ set RF, a la code breakpoints.
		 */
<blue>		if (exception_type(vcpu->arch.exception.vector) == EXCPT_FAULT)</blue>
<blue>			__kvm_set_rflags(vcpu, kvm_get_rflags(vcpu) |</blue>
					     X86_EFLAGS_RF);

<blue>		if (vcpu->arch.exception.vector == DB_VECTOR) {</blue>
<blue>			kvm_deliver_exception_payload(vcpu, &vcpu->arch.exception);</blue>
			if (vcpu-&gt;arch.dr7 &amp; DR7_GD) {
				vcpu-&gt;arch.dr7 &amp;= ~DR7_GD;
<blue>				kvm_update_dr7(vcpu);</blue>
			}
		}

<blue>		kvm_inject_exception(vcpu);</blue>

		vcpu-&gt;arch.exception.pending = false;
		vcpu-&gt;arch.exception.injected = true;

		can_inject = false;
	}

	/* Don&#x27;t inject interrupts if the user asked to avoid doing so */
<blue>	if (vcpu->guest_debug & KVM_GUESTDBG_BLOCKIRQ)</blue>
		return 0;

	/*
	 * Finally, inject interrupt events.  If an event cannot be injected
	 * due to architectural conditions (e.g. IF=0) a window-open exit
	 * will re-request KVM_REQ_EVENT.  Sometimes however an event is pending
	 * and can architecturally be injected, but we cannot do it right now:
	 * an interrupt could have arrived just now and we have to inject it
	 * as a vmexit, or there could already an event in the queue, which is
	 * indicated by can_inject.  In that case we request an immediate exit
	 * in order to make progress and get back here for another iteration.
	 * The kvm_x86_ops hooks communicate this by returning -EBUSY.
	 */
#ifdef CONFIG_KVM_SMM
<blue>	if (vcpu->arch.smi_pending) {</blue>
<yellow>		r = can_inject ? static_call(kvm_x86_smi_allowed)(vcpu, true) : -EBUSY;</yellow>
		if (r &lt; 0)
			goto out;
<yellow>		if (r) {</yellow>
<yellow>			vcpu->arch.smi_pending = false;</yellow>
			++vcpu-&gt;arch.smi_count;
			enter_smm(vcpu);
			can_inject = false;
		} else
			static_call(kvm_x86_enable_smi_window)(vcpu);
	}
#endif

<blue>	if (vcpu->arch.nmi_pending) {</blue>
<yellow>		r = can_inject ? static_call(kvm_x86_nmi_allowed)(vcpu, true) : -EBUSY;</yellow>
		if (r &lt; 0)
			goto out;
<yellow>		if (r) {</yellow>
<yellow>			--vcpu->arch.nmi_pending;</yellow>
			vcpu-&gt;arch.nmi_injected = true;
			static_call(kvm_x86_inject_nmi)(vcpu);
			can_inject = false;
<yellow>			WARN_ON(static_call(kvm_x86_nmi_allowed)(vcpu, true) < 0);</yellow>
		}
<yellow>		if (vcpu->arch.nmi_pending)</yellow>
<yellow>			static_call(kvm_x86_enable_nmi_window)(vcpu);</yellow>
	}

<blue>	if (kvm_cpu_has_injectable_intr(vcpu)) {</blue>
<blue>		r = can_inject ? static_call(kvm_x86_interrupt_allowed)(vcpu, true) : -EBUSY;</blue>
		if (r &lt; 0)
			goto out;
<blue>		if (r) {</blue>
<blue>			kvm_queue_interrupt(vcpu, kvm_cpu_get_interrupt(vcpu), false);</blue>
			static_call(kvm_x86_inject_irq)(vcpu, false);
<yellow>			WARN_ON(static_call(kvm_x86_interrupt_allowed)(vcpu, true) < 0);</yellow>
		}
<blue>		if (kvm_cpu_has_injectable_intr(vcpu))</blue>
<blue>			static_call(kvm_x86_enable_irq_window)(vcpu);</blue>
	}

<blue>	if (is_guest_mode(vcpu) &&</blue>
<blue>	    kvm_x86_ops.nested_ops->has_events &&</blue>
<blue>	    kvm_x86_ops.nested_ops->has_events(vcpu))</blue>
<yellow>		*req_immediate_exit = true;</yellow>

	/*
	 * KVM must never queue a new exception while injecting an event; KVM
	 * is done emulating and should only propagate the to-be-injected event
	 * to the VMCS/VMCB.  Queueing a new exception can put the vCPU into an
	 * infinite loop as KVM will bail from VM-Enter to inject the pending
	 * exception and start the cycle all over.
	 *
	 * Exempt triple faults as they have special handling and won&#x27;t put the
	 * vCPU into an infinite loop.  Triple fault can be queued when running
	 * VMX without unrestricted guest, as that requires KVM to emulate Real
	 * Mode events (see kvm_inject_realmode_interrupt()).
	 */
<blue>	WARN_ON_ONCE(vcpu->arch.exception.pending ||</blue>
		     vcpu-&gt;arch.exception_vmexit.pending);
	return 0;

out:
<blue>	if (r == -EBUSY) {</blue>
<blue>		*req_immediate_exit = true;</blue>
		r = 0;
	}
	return r;
<blue>}</blue>

static void process_nmi(struct kvm_vcpu *vcpu)
{
	unsigned limit = 2;

	/*
	 * x86 is limited to one NMI running, and one NMI pending after it.
	 * If an NMI is already in progress, limit further NMIs to just one.
	 * Otherwise, allow two (and we&#x27;ll inject the first one immediately).
	 */
<blue>	if (static_call(kvm_x86_get_nmi_mask)(vcpu) || vcpu->arch.nmi_injected)</blue>
		limit = 1;

<blue>	vcpu->arch.nmi_pending += atomic_xchg(&vcpu->arch.nmi_queued, 0);</blue>
	vcpu-&gt;arch.nmi_pending = min(vcpu-&gt;arch.nmi_pending, limit);
	kvm_make_request(KVM_REQ_EVENT, vcpu);
}

void kvm_make_scan_ioapic_request_mask(struct kvm *kvm,
				       unsigned long *vcpu_bitmap)
{
<yellow>	kvm_make_vcpus_request_mask(kvm, KVM_REQ_SCAN_IOAPIC, vcpu_bitmap);</yellow>
}

void kvm_make_scan_ioapic_request(struct kvm *kvm)
{
<blue>	kvm_make_all_cpus_request(kvm, KVM_REQ_SCAN_IOAPIC);</blue>
}

void kvm_vcpu_update_apicv(struct kvm_vcpu *vcpu)
{
<blue>	struct kvm_lapic *apic = vcpu->arch.apic;</blue>
	bool activate;

<yellow>	if (!lapic_in_kernel(vcpu))</yellow>
		return;

<blue>	down_read(&vcpu->kvm->arch.apicv_update_lock);</blue>
	preempt_disable();

	/* Do not activate APICV when APIC is disabled */
	activate = kvm_vcpu_apicv_activated(vcpu) &amp;&amp;
<blue>		   (kvm_get_apic_mode(vcpu) != LAPIC_MODE_DISABLED);</blue>

<blue>	if (apic->apicv_active == activate)</blue>
		goto out;

<blue>	apic->apicv_active = activate;</blue>
	kvm_apic_update_apicv(vcpu);
	static_call(kvm_x86_refresh_apicv_exec_ctrl)(vcpu);

	/*
	 * When APICv gets disabled, we may still have injected interrupts
	 * pending. At the same time, KVM_REQ_EVENT may not be set as APICv was
	 * still active when the interrupt got accepted. Make sure
	 * kvm_check_and_inject_events() is called to check for that.
	 */
<blue>	if (!apic->apicv_active)</blue>
<blue>		kvm_make_request(KVM_REQ_EVENT, vcpu);</blue>

out:
<blue>	preempt_enable();</blue>
<blue>	up_read(&vcpu->kvm->arch.apicv_update_lock);</blue>
<blue>}</blue>
EXPORT_SYMBOL_GPL(kvm_vcpu_update_apicv);

<blue>void __kvm_set_or_clear_apicv_inhibit(struct kvm *kvm,</blue>
				      enum kvm_apicv_inhibit reason, bool set)
<blue>{</blue>
	unsigned long old, new;

<blue>	lockdep_assert_held_write(&kvm->arch.apicv_update_lock);</blue>

<blue>	if (!static_call(kvm_x86_check_apicv_inhibit_reasons)(reason))</blue>
		return;

<blue>	old = new = kvm->arch.apicv_inhibit_reasons;</blue>

	set_or_clear_apicv_inhibit(&amp;new, reason, set);

	if (!!old != !!new) {
		/*
		 * Kick all vCPUs before setting apicv_inhibit_reasons to avoid
		 * false positives in the sanity check WARN in svm_vcpu_run().
		 * This task will wait for all vCPUs to ack the kick IRQ before
		 * updating apicv_inhibit_reasons, and all other vCPUs will
		 * block on acquiring apicv_update_lock so that vCPUs can&#x27;t
		 * redo svm_vcpu_run() without seeing the new inhibit state.
		 *
		 * Note, holding apicv_update_lock and taking it in the read
		 * side (handling the request) also prevents other vCPUs from
		 * servicing the request with a stale apicv_inhibit_reasons.
		 */
<blue>		kvm_make_all_cpus_request(kvm, KVM_REQ_APICV_UPDATE);</blue>
		kvm-&gt;arch.apicv_inhibit_reasons = new;
<blue>		if (new) {</blue>
			unsigned long gfn = gpa_to_gfn(APIC_DEFAULT_PHYS_BASE);
<yellow>			int idx = srcu_read_lock(&kvm->srcu);</yellow>

			kvm_zap_gfn_range(kvm, gfn, gfn+1);
<yellow>			srcu_read_unlock(&kvm->srcu, idx);</yellow>
		}
	} else {
<yellow>		kvm->arch.apicv_inhibit_reasons = new;</yellow>
	}
}

<blue>void kvm_set_or_clear_apicv_inhibit(struct kvm *kvm,</blue>
				    enum kvm_apicv_inhibit reason, bool set)
{
<blue>	if (!enable_apicv)</blue>
		return;

<blue>	down_write(&kvm->arch.apicv_update_lock);</blue>
	__kvm_set_or_clear_apicv_inhibit(kvm, reason, set);
	up_write(&amp;kvm-&gt;arch.apicv_update_lock);
<yellow>}</yellow>
EXPORT_SYMBOL_GPL(kvm_set_or_clear_apicv_inhibit);

static void vcpu_scan_ioapic(struct kvm_vcpu *vcpu)
{
<blue>	if (!kvm_apic_present(vcpu))</blue>
		return;

<blue>	bitmap_zero(vcpu->arch.ioapic_handled_vectors, 256);</blue>

	if (irqchip_split(vcpu-&gt;kvm))
<yellow>		kvm_scan_ioapic_routes(vcpu, vcpu->arch.ioapic_handled_vectors);</yellow>
	else {
<blue>		static_call_cond(kvm_x86_sync_pir_to_irr)(vcpu);</blue>
		if (ioapic_in_kernel(vcpu-&gt;kvm))
<blue>			kvm_ioapic_scan_entry(vcpu, vcpu->arch.ioapic_handled_vectors);</blue>
	}

<blue>	if (is_guest_mode(vcpu))</blue>
<yellow>		vcpu->arch.load_eoi_exitmap_pending = true;</yellow>
	else
<blue>		kvm_make_request(KVM_REQ_LOAD_EOI_EXITMAP, vcpu);</blue>
}

static void vcpu_load_eoi_exitmap(struct kvm_vcpu *vcpu)
{
	u64 eoi_exit_bitmap[4];

<yellow>	if (!kvm_apic_hw_enabled(vcpu->arch.apic))</yellow>
<blue>		return;</blue>

<blue>	if (to_hv_vcpu(vcpu)) {</blue>
<blue>		bitmap_or((ulong *)eoi_exit_bitmap,</blue>
			  vcpu-&gt;arch.ioapic_handled_vectors,
			  to_hv_synic(vcpu)-&gt;vec_bitmap, 256);
		static_call_cond(kvm_x86_load_eoi_exitmap)(vcpu, eoi_exit_bitmap);
		return;
	}

<yellow>	static_call_cond(kvm_x86_load_eoi_exitmap)(</yellow>
		vcpu, (u64 *)vcpu-&gt;arch.ioapic_handled_vectors);
}

void kvm_arch_mmu_notifier_invalidate_range(struct kvm *kvm,
					    unsigned long start, unsigned long end)
{
	unsigned long apic_address;

	/*
	 * The physical address of apic access page is stored in the VMCS.
	 * Update it when it becomes invalid.
	 */
<blue>	apic_address = gfn_to_hva(kvm, APIC_DEFAULT_PHYS_BASE >> PAGE_SHIFT);</blue>
<blue>	if (start <= apic_address && apic_address < end)</blue>
<yellow>		kvm_make_all_cpus_request(kvm, KVM_REQ_APIC_PAGE_RELOAD);</yellow>
<blue>}</blue>

void kvm_arch_guest_memory_reclaimed(struct kvm *kvm)
{
<blue>	static_call_cond(kvm_x86_guest_memory_reclaimed)(kvm);</blue>
}

static void kvm_vcpu_reload_apic_access_page(struct kvm_vcpu *vcpu)
{
<yellow>	if (!lapic_in_kernel(vcpu))</yellow>
		return;

<blue>	static_call_cond(kvm_x86_set_apic_access_page_addr)(vcpu);</blue>
}

void __kvm_request_immediate_exit(struct kvm_vcpu *vcpu)
{
<blue>	smp_send_reschedule(vcpu->cpu);</blue>
}
EXPORT_SYMBOL_GPL(__kvm_request_immediate_exit);

/*
 * Called within kvm-&gt;srcu read side.
 * Returns 1 to let vcpu_run() continue the guest execution loop without
 * exiting to the userspace.  Otherwise, the value will be returned to the
 * userspace.
 */
static int vcpu_enter_guest(struct kvm_vcpu *vcpu)
<blue>{</blue>
	int r;
	bool req_int_win =
<blue>		dm_request_for_irq_injection(vcpu) &&</blue>
<yellow>		kvm_cpu_accept_dm_intr(vcpu);</yellow>
	fastpath_t exit_fastpath;

	bool req_immediate_exit = false;

<blue>	if (kvm_request_pending(vcpu)) {</blue>
<blue>		if (kvm_check_request(KVM_REQ_VM_DEAD, vcpu)) {</blue>
			r = -EIO;
			goto out;
		}

<blue>		if (kvm_dirty_ring_check_request(vcpu)) {</blue>
			r = 0;
			goto out;
		}

<blue>		if (kvm_check_request(KVM_REQ_GET_NESTED_STATE_PAGES, vcpu)) {</blue>
			if (unlikely(!kvm_x86_ops.nested_ops-&gt;get_nested_state_pages(vcpu))) {
				r = 0;
				goto out;
			}
		}
<blue>		if (kvm_check_request(KVM_REQ_MMU_FREE_OBSOLETE_ROOTS, vcpu))</blue>
			kvm_mmu_free_obsolete_roots(vcpu);
<blue>		if (kvm_check_request(KVM_REQ_MIGRATE_TIMER, vcpu))</blue>
			__kvm_migrate_timers(vcpu);
<blue>		if (kvm_check_request(KVM_REQ_MASTERCLOCK_UPDATE, vcpu))</blue>
			kvm_update_masterclock(vcpu-&gt;kvm);
<blue>		if (kvm_check_request(KVM_REQ_GLOBAL_CLOCK_UPDATE, vcpu))</blue>
			kvm_gen_kvmclock_update(vcpu);
<blue>		if (kvm_check_request(KVM_REQ_CLOCK_UPDATE, vcpu)) {</blue>
			r = kvm_guest_time_update(vcpu);
			if (unlikely(r))
				goto out;
		}
<blue>		if (kvm_check_request(KVM_REQ_MMU_SYNC, vcpu))</blue>
			kvm_mmu_sync_roots(vcpu);
<blue>		if (kvm_check_request(KVM_REQ_LOAD_MMU_PGD, vcpu))</blue>
<blue>			kvm_mmu_load_pgd(vcpu);</blue>

		/*
		 * Note, the order matters here, as flushing &quot;all&quot; TLB entries
		 * also flushes the &quot;current&quot; TLB entries, i.e. servicing the
		 * flush &quot;all&quot; will clear any request to flush &quot;current&quot;.
		 */
<blue>		if (kvm_check_request(KVM_REQ_TLB_FLUSH, vcpu))</blue>
			kvm_vcpu_flush_tlb_all(vcpu);

<blue>		kvm_service_local_tlb_flush_requests(vcpu);</blue>

		/*
		 * Fall back to a &quot;full&quot; guest flush if Hyper-V&#x27;s precise
		 * flushing fails.  Note, Hyper-V&#x27;s flushing is per-vCPU, but
		 * the flushes are considered &quot;remote&quot; and not &quot;local&quot; because
		 * the requests can be initiated from other vCPUs.
		 */
<blue>		if (kvm_check_request(KVM_REQ_HV_TLB_FLUSH, vcpu) &&</blue>
		    kvm_hv_vcpu_flush_tlb(vcpu))
<yellow>			kvm_vcpu_flush_tlb_guest(vcpu);</yellow>

<blue>		if (kvm_check_request(KVM_REQ_REPORT_TPR_ACCESS, vcpu)) {</blue>
			vcpu-&gt;run-&gt;exit_reason = KVM_EXIT_TPR_ACCESS;
			r = 0;
			goto out;
		}
<blue>		if (kvm_test_request(KVM_REQ_TRIPLE_FAULT, vcpu)) {</blue>
<blue>			if (is_guest_mode(vcpu))</blue>
<blue>				kvm_x86_ops.nested_ops->triple_fault(vcpu);</blue>

<blue>			if (kvm_check_request(KVM_REQ_TRIPLE_FAULT, vcpu)) {</blue>
				vcpu-&gt;run-&gt;exit_reason = KVM_EXIT_SHUTDOWN;
				vcpu-&gt;mmio_needed = 0;
				r = 0;
				goto out;
			}
		}
<blue>		if (kvm_check_request(KVM_REQ_APF_HALT, vcpu)) {</blue>
			/* Page is swapped out. Do synthetic halt */
			vcpu-&gt;arch.apf.halted = true;
			r = 1;
			goto out;
		}
<blue>		if (kvm_check_request(KVM_REQ_STEAL_UPDATE, vcpu))</blue>
			record_steal_time(vcpu);
#ifdef CONFIG_KVM_SMM
<blue>		if (kvm_check_request(KVM_REQ_SMI, vcpu))</blue>
			process_smi(vcpu);
#endif
<blue>		if (kvm_check_request(KVM_REQ_NMI, vcpu))</blue>
			process_nmi(vcpu);
<blue>		if (kvm_check_request(KVM_REQ_PMU, vcpu))</blue>
			kvm_pmu_handle_event(vcpu);
<blue>		if (kvm_check_request(KVM_REQ_PMI, vcpu))</blue>
			kvm_pmu_deliver_pmi(vcpu);
<blue>		if (kvm_check_request(KVM_REQ_IOAPIC_EOI_EXIT, vcpu)) {</blue>
<yellow>			BUG_ON(vcpu->arch.pending_ioapic_eoi > 255);</yellow>
<yellow>			if (test_bit(vcpu->arch.pending_ioapic_eoi,</yellow>
				     vcpu-&gt;arch.ioapic_handled_vectors)) {
<yellow>				vcpu->run->exit_reason = KVM_EXIT_IOAPIC_EOI;</yellow>
				vcpu-&gt;run-&gt;eoi.vector =
						vcpu-&gt;arch.pending_ioapic_eoi;
				r = 0;
				goto out;
			}
		}
<blue>		if (kvm_check_request(KVM_REQ_SCAN_IOAPIC, vcpu))</blue>
<blue>			vcpu_scan_ioapic(vcpu);</blue>
<blue>		if (kvm_check_request(KVM_REQ_LOAD_EOI_EXITMAP, vcpu))</blue>
<blue>			vcpu_load_eoi_exitmap(vcpu);</blue>
<blue>		if (kvm_check_request(KVM_REQ_APIC_PAGE_RELOAD, vcpu))</blue>
<blue>			kvm_vcpu_reload_apic_access_page(vcpu);</blue>
<blue>		if (kvm_check_request(KVM_REQ_HV_CRASH, vcpu)) {</blue>
			vcpu-&gt;run-&gt;exit_reason = KVM_EXIT_SYSTEM_EVENT;
			vcpu-&gt;run-&gt;system_event.type = KVM_SYSTEM_EVENT_CRASH;
			vcpu-&gt;run-&gt;system_event.ndata = 0;
			r = 0;
			goto out;
		}
<blue>		if (kvm_check_request(KVM_REQ_HV_RESET, vcpu)) {</blue>
			vcpu-&gt;run-&gt;exit_reason = KVM_EXIT_SYSTEM_EVENT;
			vcpu-&gt;run-&gt;system_event.type = KVM_SYSTEM_EVENT_RESET;
			vcpu-&gt;run-&gt;system_event.ndata = 0;
			r = 0;
			goto out;
		}
<blue>		if (kvm_check_request(KVM_REQ_HV_EXIT, vcpu)) {</blue>
			struct kvm_vcpu_hv *hv_vcpu = to_hv_vcpu(vcpu);

			vcpu-&gt;run-&gt;exit_reason = KVM_EXIT_HYPERV;
			vcpu-&gt;run-&gt;hyperv = hv_vcpu-&gt;exit;
			r = 0;
			goto out;
		}

		/*
		 * KVM_REQ_HV_STIMER has to be processed after
		 * KVM_REQ_CLOCK_UPDATE, because Hyper-V SynIC timers
		 * depend on the guest clock being up-to-date
		 */
<blue>		if (kvm_check_request(KVM_REQ_HV_STIMER, vcpu))</blue>
			kvm_hv_process_stimers(vcpu);
<blue>		if (kvm_check_request(KVM_REQ_APICV_UPDATE, vcpu))</blue>
			kvm_vcpu_update_apicv(vcpu);
<blue>		if (kvm_check_request(KVM_REQ_APF_READY, vcpu))</blue>
			kvm_check_async_pf_completion(vcpu);
<blue>		if (kvm_check_request(KVM_REQ_MSR_FILTER_CHANGED, vcpu))</blue>
			static_call(kvm_x86_msr_filter_changed)(vcpu);

<blue>		if (kvm_check_request(KVM_REQ_UPDATE_CPU_DIRTY_LOGGING, vcpu))</blue>
			static_call(kvm_x86_update_cpu_dirty_logging)(vcpu);
	}

<blue>	if (kvm_check_request(KVM_REQ_EVENT, vcpu) || req_int_win ||</blue>
<blue>	    kvm_xen_has_interrupt(vcpu)) {</blue>
<blue>		++vcpu->stat.req_event;</blue>
		r = kvm_apic_accept_events(vcpu);
		if (r &lt; 0) {
			r = 0;
			goto out;
		}
<blue>		if (vcpu->arch.mp_state == KVM_MP_STATE_INIT_RECEIVED) {</blue>
			r = 1;
			goto out;
		}

<blue>		r = kvm_check_and_inject_events(vcpu, &req_immediate_exit);</blue>
		if (r &lt; 0) {
			r = 0;
			goto out;
		}
<blue>		if (req_int_win)</blue>
<yellow>			static_call(kvm_x86_enable_irq_window)(vcpu);</yellow>

<blue>		if (kvm_lapic_enabled(vcpu)) {</blue>
<blue>			update_cr8_intercept(vcpu);</blue>
			kvm_lapic_sync_to_vapic(vcpu);
		}
	}

<blue>	r = kvm_mmu_reload(vcpu);</blue>
	if (unlikely(r)) {
		goto cancel_injection;
	}

<blue>	preempt_disable();</blue>

	static_call(kvm_x86_prepare_switch_to_guest)(vcpu);

	/*
	 * Disable IRQs before setting IN_GUEST_MODE.  Posted interrupt
	 * IPI are then delayed after guest entry, which ensures that they
	 * result in virtual interrupt delivery.
	 */
<blue>	local_irq_disable();</blue>

	/* Store vcpu-&gt;apicv_active before vcpu-&gt;mode.  */
<blue>	smp_store_release(&vcpu->mode, IN_GUEST_MODE);</blue>

<blue>	kvm_vcpu_srcu_read_unlock(vcpu);</blue>

	/*
	 * 1) We should set -&gt;mode before checking -&gt;requests.  Please see
	 * the comment in kvm_vcpu_exiting_guest_mode().
	 *
	 * 2) For APICv, we should set -&gt;mode before checking PID.ON. This
	 * pairs with the memory barrier implicit in pi_test_and_set_on
	 * (see vmx_deliver_posted_interrupt).
	 *
	 * 3) This also orders the write to mode from any reads to the page
	 * tables done while the VCPU is running.  Please see the comment
	 * in kvm_flush_remote_tlbs.
	 */
	smp_mb__after_srcu_read_unlock();

	/*
	 * Process pending posted interrupts to handle the case where the
	 * notification IRQ arrived in the host, or was never sent (because the
	 * target vCPU wasn&#x27;t running).  Do this regardless of the vCPU&#x27;s APICv
	 * status, KVM doesn&#x27;t update assigned devices when APICv is inhibited,
	 * i.e. they can post interrupts even if APICv is temporarily disabled.
	 */
<blue>	if (kvm_lapic_enabled(vcpu))</blue>
<blue>		static_call_cond(kvm_x86_sync_pir_to_irr)(vcpu);</blue>

<blue>	if (kvm_vcpu_exit_request(vcpu)) {</blue>
<blue>		vcpu->mode = OUTSIDE_GUEST_MODE;</blue>
		smp_wmb();
		local_irq_enable();
<blue>		preempt_enable();</blue>
<blue>		kvm_vcpu_srcu_read_lock(vcpu);</blue>
		r = 1;
		goto cancel_injection;
	}

<blue>	if (req_immediate_exit) {</blue>
<blue>		kvm_make_request(KVM_REQ_EVENT, vcpu);</blue>
		static_call(kvm_x86_request_immediate_exit)(vcpu);
	}

<blue>	fpregs_assert_state_consistent();</blue>
	if (test_thread_flag(TIF_NEED_FPU_LOAD))
<blue>		switch_fpu_return();</blue>

<blue>	if (vcpu->arch.guest_fpu.xfd_err)</blue>
<yellow>		wrmsrl(MSR_IA32_XFD_ERR, vcpu->arch.guest_fpu.xfd_err);</yellow>

<blue>	if (unlikely(vcpu->arch.switch_db_regs)) {</blue>
<blue>		set_debugreg(0, 7);</blue>
		set_debugreg(vcpu-&gt;arch.eff_db[0], 0);
		set_debugreg(vcpu-&gt;arch.eff_db[1], 1);
		set_debugreg(vcpu-&gt;arch.eff_db[2], 2);
		set_debugreg(vcpu-&gt;arch.eff_db[3], 3);
<blue>	} else if (unlikely(hw_breakpoint_active())) {</blue>
<yellow>		set_debugreg(0, 7);</yellow>
	}

<blue>	guest_timing_enter_irqoff();</blue>

	for (;;) {
		/*
		 * Assert that vCPU vs. VM APICv state is consistent.  An APICv
		 * update must kick and wait for all vCPUs before toggling the
		 * per-VM state, and responsing vCPUs must wait for the update
		 * to complete before servicing KVM_REQ_APICV_UPDATE.
		 */
<blue>		WARN_ON_ONCE((kvm_vcpu_apicv_activated(vcpu) != kvm_vcpu_apicv_active(vcpu)) &&</blue>
			     (kvm_get_apic_mode(vcpu) != LAPIC_MODE_DISABLED));

<blue>		exit_fastpath = static_call(kvm_x86_vcpu_run)(vcpu);</blue>
		if (likely(exit_fastpath != EXIT_FASTPATH_REENTER_GUEST))
			break;

<yellow>		if (kvm_lapic_enabled(vcpu))</yellow>
<yellow>			static_call_cond(kvm_x86_sync_pir_to_irr)(vcpu);</yellow>

<yellow>		if (unlikely(kvm_vcpu_exit_request(vcpu))) {</yellow>
			exit_fastpath = EXIT_FASTPATH_EXIT_HANDLED;
			break;
		}
	}

	/*
	 * Do this here before restoring debug registers on the host.  And
	 * since we do this before handling the vmexit, a DR access vmexit
	 * can (a) read the correct value of the debug registers, (b) set
	 * KVM_DEBUGREG_WONT_EXIT again.
	 */
<blue>	if (unlikely(vcpu->arch.switch_db_regs & KVM_DEBUGREG_WONT_EXIT)) {</blue>
<blue>		WARN_ON(vcpu->guest_debug & KVM_GUESTDBG_USE_HW_BP);</blue>
<blue>		static_call(kvm_x86_sync_dirty_debug_regs)(vcpu);</blue>
<blue>		kvm_update_dr0123(vcpu);</blue>
<blue>		kvm_update_dr7(vcpu);</blue>
	}

	/*
	 * If the guest has used debug registers, at least dr7
	 * will be disabled while returning to the host.
	 * If we don&#x27;t have active breakpoints in the host, we don&#x27;t
	 * care about the messed up debug address registers. But if
	 * we have some of them active, restore the old state.
	 */
<blue>	if (hw_breakpoint_active())</blue>
<yellow>		hw_breakpoint_restore();</yellow>

<blue>	vcpu->arch.last_vmentry_cpu = vcpu->cpu;</blue>
<blue>	vcpu->arch.last_guest_tsc = kvm_read_l1_tsc(vcpu, rdtsc());</blue>

	vcpu-&gt;mode = OUTSIDE_GUEST_MODE;
	smp_wmb();

	/*
	 * Sync xfd before calling handle_exit_irqoff() which may
	 * rely on the fact that guest_fpu::xfd is up-to-date (e.g.
	 * in #NM irqoff handler).
	 */
<blue>	if (vcpu->arch.xfd_no_write_intercept)</blue>
<yellow>		fpu_sync_guest_vmexit_xfd_state();</yellow>

<blue>	static_call(kvm_x86_handle_exit_irqoff)(vcpu);</blue>

	if (vcpu-&gt;arch.guest_fpu.xfd_err)
<yellow>		wrmsrl(MSR_IA32_XFD_ERR, 0);</yellow>

	/*
	 * Consume any pending interrupts, including the possible source of
	 * VM-Exit on SVM and any ticks that occur between VM-Exit and now.
	 * An instruction is required after local_irq_enable() to fully unblock
	 * interrupts on processors that implement an interrupt shadow, the
	 * stat.exits increment will do nicely.
	 */
<blue>	kvm_before_interrupt(vcpu, KVM_HANDLING_IRQ);</blue>
	local_irq_enable();
	++vcpu-&gt;stat.exits;
<blue>	local_irq_disable();</blue>
<blue>	kvm_after_interrupt(vcpu);</blue>

	/*
	 * Wait until after servicing IRQs to account guest time so that any
	 * ticks that occurred while running the guest are properly accounted
	 * to the guest.  Waiting until IRQs are enabled degrades the accuracy
	 * of accounting via context tracking, but the loss of accuracy is
	 * acceptable for all known use cases.
	 */
	guest_timing_exit_irqoff();

	local_irq_enable();
<blue>	preempt_enable();</blue>

<blue>	kvm_vcpu_srcu_read_lock(vcpu);</blue>

	/*
	 * Profile KVM exit RIPs:
	 */
	if (unlikely(prof_on == KVM_PROFILING)) {
<yellow>		unsigned long rip = kvm_rip_read(vcpu);</yellow>
<yellow>		profile_hit(KVM_PROFILING, (void *)rip);</yellow>
	}

<blue>	if (unlikely(vcpu->arch.tsc_always_catchup))</blue>
<yellow>		kvm_make_request(KVM_REQ_CLOCK_UPDATE, vcpu);</yellow>

<blue>	if (vcpu->arch.apic_attention)</blue>
<yellow>		kvm_lapic_sync_from_vapic(vcpu);</yellow>

<blue>	r = static_call(kvm_x86_handle_exit)(vcpu, exit_fastpath);</blue>
	return r;

cancel_injection:
<blue>	if (req_immediate_exit)</blue>
<blue>		kvm_make_request(KVM_REQ_EVENT, vcpu);</blue>
<blue>	static_call(kvm_x86_cancel_injection)(vcpu);</blue>
	if (unlikely(vcpu-&gt;arch.apic_attention))
<yellow>		kvm_lapic_sync_from_vapic(vcpu);</yellow>
out:
	return r;
}

/* Called within kvm-&gt;srcu read side.  */
static inline int vcpu_block(struct kvm_vcpu *vcpu)
{
	bool hv_timer;

<blue>	if (!kvm_arch_vcpu_runnable(vcpu)) {</blue>
		/*
		 * Switch to the software timer before halt-polling/blocking as
		 * the guest&#x27;s timer may be a break event for the vCPU, and the
		 * hypervisor timer runs only when the CPU is in guest mode.
		 * Switch before halt-polling so that KVM recognizes an expired
		 * timer before blocking.
		 */
<blue>		hv_timer = kvm_lapic_hv_timer_in_use(vcpu);</blue>
		if (hv_timer)
<yellow>			kvm_lapic_switch_to_sw_timer(vcpu);</yellow>

<blue>		kvm_vcpu_srcu_read_unlock(vcpu);</blue>
<blue>		if (vcpu->arch.mp_state == KVM_MP_STATE_HALTED)</blue>
<blue>			kvm_vcpu_halt(vcpu);</blue>
		else
<blue>			kvm_vcpu_block(vcpu);</blue>
<blue>		kvm_vcpu_srcu_read_lock(vcpu);</blue>

		if (hv_timer)
<yellow>			kvm_lapic_switch_to_hv_timer(vcpu);</yellow>

		/*
		 * If the vCPU is not runnable, a signal or another host event
		 * of some kind is pending; service it without changing the
		 * vCPU&#x27;s activity state.
		 */
<blue>		if (!kvm_arch_vcpu_runnable(vcpu))</blue>
			return 1;
	}

	/*
	 * Evaluate nested events before exiting the halted state.  This allows
	 * the halt state to be recorded properly in the VMCS12&#x27;s activity
	 * state field (AMD does not have a similar field and a VM-Exit always
	 * causes a spurious wakeup from HLT).
	 */
<blue>	if (is_guest_mode(vcpu)) {</blue>
<blue>		if (kvm_check_nested_events(vcpu) < 0)</blue>
			return 0;
	}

<blue>	if (kvm_apic_accept_events(vcpu) < 0)</blue>
		return 0;
<blue>	switch(vcpu->arch.mp_state) {</blue>
	case KVM_MP_STATE_HALTED:
	case KVM_MP_STATE_AP_RESET_HOLD:
<blue>		vcpu->arch.pv.pv_unhalted = false;</blue>
		vcpu-&gt;arch.mp_state =
			KVM_MP_STATE_RUNNABLE;
		fallthrough;
	case KVM_MP_STATE_RUNNABLE:
<blue>		vcpu->arch.apf.halted = false;</blue>
		break;
	case KVM_MP_STATE_INIT_RECEIVED:
		break;
	default:
<yellow>		WARN_ON_ONCE(1);</yellow>
		break;
	}
	return 1;
}

static inline bool kvm_vcpu_running(struct kvm_vcpu *vcpu)
{
<blue>	return (vcpu->arch.mp_state == KVM_MP_STATE_RUNNABLE &&</blue>
<blue>		!vcpu->arch.apf.halted);</blue>
}

/* Called within kvm-&gt;srcu read side.  */
static int vcpu_run(struct kvm_vcpu *vcpu)
{
	int r;

<blue>	vcpu->arch.l1tf_flush_l1d = true;</blue>

	for (;;) {
		/*
		 * If another guest vCPU requests a PV TLB flush in the middle
		 * of instruction emulation, the rest of the emulation could
		 * use a stale page translation. Assume that any code after
		 * this point can start executing an instruction.
		 */
<blue>		vcpu->arch.at_instruction_boundary = false;</blue>
<blue>		if (kvm_vcpu_running(vcpu)) {</blue>
<blue>			r = vcpu_enter_guest(vcpu);</blue>
		} else {
<blue>			r = vcpu_block(vcpu);</blue>
		}

		if (r &lt;= 0)
			break;

<blue>		kvm_clear_request(KVM_REQ_UNBLOCK, vcpu);</blue>
<yellow>		if (kvm_xen_has_pending_events(vcpu))</yellow>
<yellow>			kvm_xen_inject_pending_events(vcpu);</yellow>

<blue>		if (kvm_cpu_has_pending_timer(vcpu))</blue>
<yellow>			kvm_inject_pending_timer_irqs(vcpu);</yellow>

<blue>		if (dm_request_for_irq_injection(vcpu) &&</blue>
<yellow>			kvm_vcpu_ready_for_interrupt_injection(vcpu)) {</yellow>
			r = 0;
<yellow>			vcpu->run->exit_reason = KVM_EXIT_IRQ_WINDOW_OPEN;</yellow>
			++vcpu-&gt;stat.request_irq_exits;
			break;
		}

<blue>		if (__xfer_to_guest_mode_work_pending()) {</blue>
<blue>			kvm_vcpu_srcu_read_unlock(vcpu);</blue>
<blue>			r = xfer_to_guest_mode_handle_work(vcpu);</blue>
<blue>			kvm_vcpu_srcu_read_lock(vcpu);</blue>
			if (r)
				return r;
		}
	}

	return r;
}

static inline int complete_emulated_io(struct kvm_vcpu *vcpu)
{
<blue>	return kvm_emulate_instruction(vcpu, EMULTYPE_NO_DECODE);</blue>
}

static int complete_emulated_pio(struct kvm_vcpu *vcpu)
{
<blue>	BUG_ON(!vcpu->arch.pio.count);</blue>

<blue>	return complete_emulated_io(vcpu);</blue>
}

/*
 * Implements the following, as a state machine:
 *
 * read:
 *   for each fragment
 *     for each mmio piece in the fragment
 *       write gpa, len
 *       exit
 *       copy data
 *   execute insn
 *
 * write:
 *   for each fragment
 *     for each mmio piece in the fragment
 *       write gpa, len
 *       copy data
 *       exit
 */
static int complete_emulated_mmio(struct kvm_vcpu *vcpu)
{
<blue>	struct kvm_run *run = vcpu->run;</blue>
	struct kvm_mmio_fragment *frag;
	unsigned len;

<yellow>	BUG_ON(!vcpu->mmio_needed);</yellow>

	/* Complete previous fragment */
<blue>	frag = &vcpu->mmio_fragments[vcpu->mmio_cur_fragment];</blue>
	len = min(8u, frag-&gt;len);
	if (!vcpu-&gt;mmio_is_write)
<blue>		memcpy(frag->data, run->mmio.data, len);</blue>

<blue>	if (frag->len <= 8) {</blue>
		/* Switch to the next fragment. */
		frag++;
<blue>		vcpu->mmio_cur_fragment++;</blue>
	} else {
		/* Go forward to the next mmio piece. */
<yellow>		frag->data += len;</yellow>
		frag-&gt;gpa += len;
		frag-&gt;len -= len;
	}

<blue>	if (vcpu->mmio_cur_fragment >= vcpu->mmio_nr_fragments) {</blue>
<blue>		vcpu->mmio_needed = 0;</blue>

		/* FIXME: return into emulator if single-stepping.  */
		if (vcpu-&gt;mmio_is_write)
			return 1;
<blue>		vcpu->mmio_read_completed = 1;</blue>
		return complete_emulated_io(vcpu);
	}

<yellow>	run->exit_reason = KVM_EXIT_MMIO;</yellow>
	run-&gt;mmio.phys_addr = frag-&gt;gpa;
	if (vcpu-&gt;mmio_is_write)
<yellow>		memcpy(run->mmio.data, frag->data, min(8u, frag->len));</yellow>
<yellow>	run->mmio.len = min(8u, frag->len);</yellow>
	run-&gt;mmio.is_write = vcpu-&gt;mmio_is_write;
	vcpu-&gt;arch.complete_userspace_io = complete_emulated_mmio;
	return 0;
<blue>}</blue>

/* Swap (qemu) user FPU context for the guest FPU context. */
static void kvm_load_guest_fpu(struct kvm_vcpu *vcpu)
{
	/* Exclude PKRU, it&#x27;s restored separately immediately after VM-Exit. */
<yellow>	fpu_swap_kvm_fpstate(&vcpu->arch.guest_fpu, true);</yellow>
	trace_kvm_fpu(1);
}

/* When vcpu_run ends, restore user space FPU context. */
static void kvm_put_guest_fpu(struct kvm_vcpu *vcpu)
{
<blue>	fpu_swap_kvm_fpstate(&vcpu->arch.guest_fpu, false);</blue>
	++vcpu-&gt;stat.fpu_reload;
<yellow>	trace_kvm_fpu(0);</yellow>
}

int kvm_arch_vcpu_ioctl_run(struct kvm_vcpu *vcpu)
{
	struct kvm_queued_exception *ex = &amp;vcpu-&gt;arch.exception;
<blue>	struct kvm_run *kvm_run = vcpu->run;</blue>
	int r;

	vcpu_load(vcpu);
	kvm_sigset_activate(vcpu);
	kvm_run-&gt;flags = 0;
	kvm_load_guest_fpu(vcpu);

<blue>	kvm_vcpu_srcu_read_lock(vcpu);</blue>
	if (unlikely(vcpu-&gt;arch.mp_state == KVM_MP_STATE_UNINITIALIZED)) {
<yellow>		if (kvm_run->immediate_exit) {</yellow>
			r = -EINTR;
			goto out;
		}
		/*
		 * It should be impossible for the hypervisor timer to be in
		 * use before KVM has ever run the vCPU.
		 */
<yellow>		WARN_ON_ONCE(kvm_lapic_hv_timer_in_use(vcpu));</yellow>

<yellow>		kvm_vcpu_srcu_read_unlock(vcpu);</yellow>
<yellow>		kvm_vcpu_block(vcpu);</yellow>
<yellow>		kvm_vcpu_srcu_read_lock(vcpu);</yellow>

		if (kvm_apic_accept_events(vcpu) &lt; 0) {
			r = 0;
			goto out;
		}
		r = -EAGAIN;
<yellow>		if (signal_pending(current)) {</yellow>
			r = -EINTR;
<yellow>			kvm_run->exit_reason = KVM_EXIT_INTR;</yellow>
			++vcpu-&gt;stat.signal_exits;
		}
		goto out;
	}

<blue>	if ((kvm_run->kvm_valid_regs & ~KVM_SYNC_X86_VALID_FIELDS) ||</blue>
<blue>	    (kvm_run->kvm_dirty_regs & ~KVM_SYNC_X86_VALID_FIELDS)) {</blue>
		r = -EINVAL;
		goto out;
	}

<blue>	if (kvm_run->kvm_dirty_regs) {</blue>
<yellow>		r = sync_regs(vcpu);</yellow>
		if (r != 0)
			goto out;
	}

	/* re-sync apic&#x27;s tpr */
<blue>	if (!lapic_in_kernel(vcpu)) {</blue>
<yellow>		if (kvm_set_cr8(vcpu, kvm_run->cr8) != 0) {</yellow>
			r = -EINVAL;
			goto out;
		}
	}

	/*
	 * If userspace set a pending exception and L2 is active, convert it to
	 * a pending VM-Exit if L1 wants to intercept the exception.
	 */
<blue>	if (vcpu->arch.exception_from_userspace && is_guest_mode(vcpu) &&</blue>
<yellow>	    kvm_x86_ops.nested_ops->is_exception_vmexit(vcpu, ex->vector,</yellow>
							ex-&gt;error_code)) {
<yellow>		kvm_queue_exception_vmexit(vcpu, ex->vector,</yellow>
					   ex-&gt;has_error_code, ex-&gt;error_code,
					   ex-&gt;has_payload, ex-&gt;payload);
		ex-&gt;injected = false;
		ex-&gt;pending = false;
	}
<blue>	vcpu->arch.exception_from_userspace = false;</blue>

	if (unlikely(vcpu-&gt;arch.complete_userspace_io)) {
		int (*cui)(struct kvm_vcpu *) = vcpu-&gt;arch.complete_userspace_io;
		vcpu-&gt;arch.complete_userspace_io = NULL;
<blue>		r = cui(vcpu);</blue>
		if (r &lt;= 0)
			goto out;
	} else {
<blue>		WARN_ON_ONCE(vcpu->arch.pio.count);</blue>
<blue>		WARN_ON_ONCE(vcpu->mmio_needed);</blue>
	}

<blue>	if (kvm_run->immediate_exit) {</blue>
		r = -EINTR;
		goto out;
	}

<blue>	r = static_call(kvm_x86_vcpu_pre_run)(vcpu);</blue>
	if (r &lt;= 0)
		goto out;

<blue>	r = vcpu_run(vcpu);</blue>

out:
<blue>	kvm_put_guest_fpu(vcpu);</blue>
	if (kvm_run-&gt;kvm_valid_regs)
<blue>		store_regs(vcpu);</blue>
<blue>	post_kvm_run_save(vcpu);</blue>
<blue>	kvm_vcpu_srcu_read_unlock(vcpu);</blue>

<blue>	kvm_sigset_deactivate(vcpu);</blue>
	vcpu_put(vcpu);
	return r;
}

static void __get_regs(struct kvm_vcpu *vcpu, struct kvm_regs *regs)
{
<blue>	if (vcpu->arch.emulate_regs_need_sync_to_vcpu) {</blue>
		/*
		 * We are here if userspace calls get_regs() in the middle of
		 * instruction emulation. Registers state needs to be copied
		 * back from emulation context to vcpu. Userspace shouldn&#x27;t do
		 * that usually, but some bad designed PV devices (vmware
		 * backdoor interface) need this to work
		 */
<yellow>		emulator_writeback_register_cache(vcpu->arch.emulate_ctxt);</yellow>
		vcpu-&gt;arch.emulate_regs_need_sync_to_vcpu = false;
	}
<blue>	regs->rax = kvm_rax_read(vcpu);</blue>
	regs-&gt;rbx = kvm_rbx_read(vcpu);
	regs-&gt;rcx = kvm_rcx_read(vcpu);
	regs-&gt;rdx = kvm_rdx_read(vcpu);
	regs-&gt;rsi = kvm_rsi_read(vcpu);
	regs-&gt;rdi = kvm_rdi_read(vcpu);
<blue>	regs->rsp = kvm_rsp_read(vcpu);</blue>
	regs-&gt;rbp = kvm_rbp_read(vcpu);
#ifdef CONFIG_X86_64
	regs-&gt;r8 = kvm_r8_read(vcpu);
	regs-&gt;r9 = kvm_r9_read(vcpu);
	regs-&gt;r10 = kvm_r10_read(vcpu);
	regs-&gt;r11 = kvm_r11_read(vcpu);
	regs-&gt;r12 = kvm_r12_read(vcpu);
	regs-&gt;r13 = kvm_r13_read(vcpu);
	regs-&gt;r14 = kvm_r14_read(vcpu);
	regs-&gt;r15 = kvm_r15_read(vcpu);
#endif

<blue>	regs->rip = kvm_rip_read(vcpu);</blue>
<blue>	regs->rflags = kvm_get_rflags(vcpu);</blue>
}

int kvm_arch_vcpu_ioctl_get_regs(struct kvm_vcpu *vcpu, struct kvm_regs *regs)
{
<blue>	vcpu_load(vcpu);</blue>
	__get_regs(vcpu, regs);
	vcpu_put(vcpu);
	return 0;
}

static void __set_regs(struct kvm_vcpu *vcpu, struct kvm_regs *regs)
{
<blue>	vcpu->arch.emulate_regs_need_sync_from_vcpu = true;</blue>
	vcpu-&gt;arch.emulate_regs_need_sync_to_vcpu = false;

	kvm_rax_write(vcpu, regs-&gt;rax);
	kvm_rbx_write(vcpu, regs-&gt;rbx);
	kvm_rcx_write(vcpu, regs-&gt;rcx);
	kvm_rdx_write(vcpu, regs-&gt;rdx);
	kvm_rsi_write(vcpu, regs-&gt;rsi);
	kvm_rdi_write(vcpu, regs-&gt;rdi);
	kvm_rsp_write(vcpu, regs-&gt;rsp);
	kvm_rbp_write(vcpu, regs-&gt;rbp);
#ifdef CONFIG_X86_64
	kvm_r8_write(vcpu, regs-&gt;r8);
	kvm_r9_write(vcpu, regs-&gt;r9);
	kvm_r10_write(vcpu, regs-&gt;r10);
	kvm_r11_write(vcpu, regs-&gt;r11);
	kvm_r12_write(vcpu, regs-&gt;r12);
	kvm_r13_write(vcpu, regs-&gt;r13);
	kvm_r14_write(vcpu, regs-&gt;r14);
	kvm_r15_write(vcpu, regs-&gt;r15);
#endif

	kvm_rip_write(vcpu, regs-&gt;rip);
	kvm_set_rflags(vcpu, regs-&gt;rflags | X86_EFLAGS_FIXED);

	vcpu-&gt;arch.exception.pending = false;
	vcpu-&gt;arch.exception_vmexit.pending = false;

	kvm_make_request(KVM_REQ_EVENT, vcpu);
}

int kvm_arch_vcpu_ioctl_set_regs(struct kvm_vcpu *vcpu, struct kvm_regs *regs)
{
<blue>	vcpu_load(vcpu);</blue>
	__set_regs(vcpu, regs);
	vcpu_put(vcpu);
	return 0;
}

static void __get_sregs_common(struct kvm_vcpu *vcpu, struct kvm_sregs *sregs)
{
	struct desc_ptr dt;

<blue>	if (vcpu->arch.guest_state_protected)</blue>
		goto skip_protected_regs;

<blue>	kvm_get_segment(vcpu, &sregs->cs, VCPU_SREG_CS);</blue>
	kvm_get_segment(vcpu, &amp;sregs-&gt;ds, VCPU_SREG_DS);
	kvm_get_segment(vcpu, &amp;sregs-&gt;es, VCPU_SREG_ES);
	kvm_get_segment(vcpu, &amp;sregs-&gt;fs, VCPU_SREG_FS);
	kvm_get_segment(vcpu, &amp;sregs-&gt;gs, VCPU_SREG_GS);
	kvm_get_segment(vcpu, &amp;sregs-&gt;ss, VCPU_SREG_SS);

	kvm_get_segment(vcpu, &amp;sregs-&gt;tr, VCPU_SREG_TR);
	kvm_get_segment(vcpu, &amp;sregs-&gt;ldt, VCPU_SREG_LDTR);

	static_call(kvm_x86_get_idt)(vcpu, &amp;dt);
	sregs-&gt;idt.limit = dt.size;
	sregs-&gt;idt.base = dt.address;
	static_call(kvm_x86_get_gdt)(vcpu, &amp;dt);
	sregs-&gt;gdt.limit = dt.size;
	sregs-&gt;gdt.base = dt.address;

	sregs-&gt;cr2 = vcpu-&gt;arch.cr2;
<blue>	sregs->cr3 = kvm_read_cr3(vcpu);</blue>

skip_protected_regs:
<blue>	sregs->cr0 = kvm_read_cr0(vcpu);</blue>
<blue>	sregs->cr4 = kvm_read_cr4(vcpu);</blue>
<blue>	sregs->cr8 = kvm_get_cr8(vcpu);</blue>
	sregs-&gt;efer = vcpu-&gt;arch.efer;
	sregs-&gt;apic_base = kvm_get_apic_base(vcpu);
}

<yellow>static void __get_sregs(struct kvm_vcpu *vcpu, struct kvm_sregs *sregs)</yellow>
{
<yellow>	__get_sregs_common(vcpu, sregs);</yellow>

<yellow>	if (vcpu->arch.guest_state_protected)</yellow>
		return;

<yellow>	if (vcpu->arch.interrupt.injected && !vcpu->arch.interrupt.soft)</yellow>
<yellow>		set_bit(vcpu->arch.interrupt.nr,</yellow>
			(unsigned long *)sregs-&gt;interrupt_bitmap);
<yellow>}</yellow>

static void __get_sregs2(struct kvm_vcpu *vcpu, struct kvm_sregs2 *sregs2)
{
	int i;

<blue>	__get_sregs_common(vcpu, (struct kvm_sregs *)sregs2);</blue>

<blue>	if (vcpu->arch.guest_state_protected)</blue>
		return;

<blue>	if (is_pae_paging(vcpu)) {</blue>
		for (i = 0 ; i &lt; 4 ; i++)
<yellow>			sregs2->pdptrs[i] = kvm_pdptr_read(vcpu, i);</yellow>
<yellow>		sregs2->flags |= KVM_SREGS2_FLAGS_PDPTRS_VALID;</yellow>
	}
}

int kvm_arch_vcpu_ioctl_get_sregs(struct kvm_vcpu *vcpu,
				  struct kvm_sregs *sregs)
{
<yellow>	vcpu_load(vcpu);</yellow>
	__get_sregs(vcpu, sregs);
	vcpu_put(vcpu);
	return 0;
}

int kvm_arch_vcpu_ioctl_get_mpstate(struct kvm_vcpu *vcpu,
				    struct kvm_mp_state *mp_state)
{
	int r;

<blue>	vcpu_load(vcpu);</blue>
	if (kvm_mpx_supported())
<yellow>		kvm_load_guest_fpu(vcpu);</yellow>

<blue>	r = kvm_apic_accept_events(vcpu);</blue>
	if (r &lt; 0)
		goto out;
	r = 0;

<blue>	if ((vcpu->arch.mp_state == KVM_MP_STATE_HALTED ||</blue>
<yellow>	     vcpu->arch.mp_state == KVM_MP_STATE_AP_RESET_HOLD) &&</yellow>
<yellow>	    vcpu->arch.pv.pv_unhalted)</yellow>
<yellow>		mp_state->mp_state = KVM_MP_STATE_RUNNABLE;</yellow>
	else
<blue>		mp_state->mp_state = vcpu->arch.mp_state;</blue>

out:
<blue>	if (kvm_mpx_supported())</blue>
<yellow>		kvm_put_guest_fpu(vcpu);</yellow>
<blue>	vcpu_put(vcpu);</blue>
	return r;
}

int kvm_arch_vcpu_ioctl_set_mpstate(struct kvm_vcpu *vcpu,
				    struct kvm_mp_state *mp_state)
{
	int ret = -EINVAL;

<blue>	vcpu_load(vcpu);</blue>

	switch (mp_state-&gt;mp_state) {
	case KVM_MP_STATE_UNINITIALIZED:
	case KVM_MP_STATE_HALTED:
	case KVM_MP_STATE_AP_RESET_HOLD:
	case KVM_MP_STATE_INIT_RECEIVED:
	case KVM_MP_STATE_SIPI_RECEIVED:
<yellow>		if (!lapic_in_kernel(vcpu))</yellow>
			goto out;
		break;

	case KVM_MP_STATE_RUNNABLE:
		break;

	default:
		goto out;
	}

	/*
	 * Pending INITs are reported using KVM_SET_VCPU_EVENTS, disallow
	 * forcing the guest into INIT/SIPI if those events are supposed to be
	 * blocked.  KVM prioritizes SMI over INIT, so reject INIT/SIPI state
	 * if an SMI is pending as well.
	 */
<blue>	if ((!kvm_apic_init_sipi_allowed(vcpu) || vcpu->arch.smi_pending) &&</blue>
<yellow>	    (mp_state->mp_state == KVM_MP_STATE_SIPI_RECEIVED ||</yellow>
	     mp_state-&gt;mp_state == KVM_MP_STATE_INIT_RECEIVED))
		goto out;

<blue>	if (mp_state->mp_state == KVM_MP_STATE_SIPI_RECEIVED) {</blue>
<yellow>		vcpu->arch.mp_state = KVM_MP_STATE_INIT_RECEIVED;</yellow>
		set_bit(KVM_APIC_SIPI, &amp;vcpu-&gt;arch.apic-&gt;pending_events);
	} else
<blue>		vcpu->arch.mp_state = mp_state->mp_state;</blue>
<blue>	kvm_make_request(KVM_REQ_EVENT, vcpu);</blue>

	ret = 0;
out:
<blue>	vcpu_put(vcpu);</blue>
	return ret;
}

int kvm_task_switch(struct kvm_vcpu *vcpu, u16 tss_selector, int idt_index,
		    int reason, bool has_error_code, u32 error_code)
{
<yellow>	struct x86_emulate_ctxt *ctxt = vcpu->arch.emulate_ctxt;</yellow>
	int ret;

	init_emulate_ctxt(vcpu);

	ret = emulator_task_switch(ctxt, tss_selector, idt_index, reason,
				   has_error_code, error_code);
	if (ret) {
<yellow>		vcpu->run->exit_reason = KVM_EXIT_INTERNAL_ERROR;</yellow>
		vcpu-&gt;run-&gt;internal.suberror = KVM_INTERNAL_ERROR_EMULATION;
		vcpu-&gt;run-&gt;internal.ndata = 0;
		return 0;
	}

<yellow>	kvm_rip_write(vcpu, ctxt->eip);</yellow>
	kvm_set_rflags(vcpu, ctxt-&gt;eflags);
	return 1;
<yellow>}</yellow>
EXPORT_SYMBOL_GPL(kvm_task_switch);

static bool kvm_is_valid_sregs(struct kvm_vcpu *vcpu, struct kvm_sregs *sregs)
{
<blue>	if ((sregs->efer & EFER_LME) && (sregs->cr0 & X86_CR0_PG)) {</blue>
		/*
		 * When EFER.LME and CR0.PG are set, the processor is in
		 * 64-bit mode (though maybe in a 32-bit code segment).
		 * CR4.PAE and EFER.LMA must be set.
		 */
<blue>		if (!(sregs->cr4 & X86_CR4_PAE) || !(sregs->efer & EFER_LMA))</blue>
			return false;
<blue>		if (kvm_vcpu_is_illegal_gpa(vcpu, sregs->cr3))</blue>
			return false;
	} else {
		/*
		 * Not in 64-bit mode: EFER.LMA is clear and the code
		 * segment cannot be 64-bit.
		 */
<blue>		if (sregs->efer & EFER_LMA || sregs->cs.l)</blue>
			return false;
	}

<blue>	return kvm_is_valid_cr4(vcpu, sregs->cr4);</blue>
}

<blue>static int __set_sregs_common(struct kvm_vcpu *vcpu, struct kvm_sregs *sregs,</blue>
		int *mmu_reset_needed, bool update_pdptrs)
{
	struct msr_data apic_base_msr;
	int idx;
	struct desc_ptr dt;

<blue>	if (!kvm_is_valid_sregs(vcpu, sregs))</blue>
		return -EINVAL;

<blue>	apic_base_msr.data = sregs->apic_base;</blue>
	apic_base_msr.host_initiated = true;
	if (kvm_set_apic_base(vcpu, &amp;apic_base_msr))
		return -EINVAL;

<blue>	if (vcpu->arch.guest_state_protected)</blue>
		return 0;

<blue>	dt.size = sregs->idt.limit;</blue>
	dt.address = sregs-&gt;idt.base;
	static_call(kvm_x86_set_idt)(vcpu, &amp;dt);
	dt.size = sregs-&gt;gdt.limit;
	dt.address = sregs-&gt;gdt.base;
	static_call(kvm_x86_set_gdt)(vcpu, &amp;dt);

	vcpu-&gt;arch.cr2 = sregs-&gt;cr2;
<blue>	*mmu_reset_needed |= kvm_read_cr3(vcpu) != sregs->cr3;</blue>
	vcpu-&gt;arch.cr3 = sregs-&gt;cr3;
	kvm_register_mark_dirty(vcpu, VCPU_EXREG_CR3);
	static_call_cond(kvm_x86_post_set_cr3)(vcpu, sregs-&gt;cr3);

<blue>	kvm_set_cr8(vcpu, sregs->cr8);</blue>

<blue>	*mmu_reset_needed |= vcpu->arch.efer != sregs->efer;</blue>
	static_call(kvm_x86_set_efer)(vcpu, sregs-&gt;efer);

<blue>	*mmu_reset_needed |= kvm_read_cr0(vcpu) != sregs->cr0;</blue>
	static_call(kvm_x86_set_cr0)(vcpu, sregs-&gt;cr0);
	vcpu-&gt;arch.cr0 = sregs-&gt;cr0;

<blue>	*mmu_reset_needed |= kvm_read_cr4(vcpu) != sregs->cr4;</blue>
	static_call(kvm_x86_set_cr4)(vcpu, sregs-&gt;cr4);

	if (update_pdptrs) {
<blue>		idx = srcu_read_lock(&vcpu->kvm->srcu);</blue>
<blue>		if (is_pae_paging(vcpu)) {</blue>
<yellow>			load_pdptrs(vcpu, kvm_read_cr3(vcpu));</yellow>
			*mmu_reset_needed = 1;
		}
<blue>		srcu_read_unlock(&vcpu->kvm->srcu, idx);</blue>
	}

<blue>	kvm_set_segment(vcpu, &sregs->cs, VCPU_SREG_CS);</blue>
	kvm_set_segment(vcpu, &amp;sregs-&gt;ds, VCPU_SREG_DS);
	kvm_set_segment(vcpu, &amp;sregs-&gt;es, VCPU_SREG_ES);
	kvm_set_segment(vcpu, &amp;sregs-&gt;fs, VCPU_SREG_FS);
	kvm_set_segment(vcpu, &amp;sregs-&gt;gs, VCPU_SREG_GS);
	kvm_set_segment(vcpu, &amp;sregs-&gt;ss, VCPU_SREG_SS);

	kvm_set_segment(vcpu, &amp;sregs-&gt;tr, VCPU_SREG_TR);
	kvm_set_segment(vcpu, &amp;sregs-&gt;ldt, VCPU_SREG_LDTR);

	update_cr8_intercept(vcpu);

	/* Older userspace won&#x27;t unhalt the vcpu on reset. */
<blue>	if (kvm_vcpu_is_bsp(vcpu) && kvm_rip_read(vcpu) == 0xfff0 &&</blue>
<blue>	    sregs->cs.selector == 0xf000 && sregs->cs.base == 0xffff0000 &&</blue>
<blue>	    !is_protmode(vcpu))</blue>
<blue>		vcpu->arch.mp_state = KVM_MP_STATE_RUNNABLE;</blue>

	return 0;
}

<yellow>static int __set_sregs(struct kvm_vcpu *vcpu, struct kvm_sregs *sregs)</yellow>
<yellow>{</yellow>
	int pending_vec, max_bits;
	int mmu_reset_needed = 0;
<yellow>	int ret = __set_sregs_common(vcpu, sregs, &mmu_reset_needed, true);</yellow>

	if (ret)
		return ret;

<yellow>	if (mmu_reset_needed)</yellow>
<yellow>		kvm_mmu_reset_context(vcpu);</yellow>

	max_bits = KVM_NR_INTERRUPTS;
	pending_vec = find_first_bit(
<yellow>		(const unsigned long *)sregs->interrupt_bitmap, max_bits);</yellow>

	if (pending_vec &lt; max_bits) {
<yellow>		kvm_queue_interrupt(vcpu, pending_vec, false);</yellow>
<yellow>		pr_debug("Set back pending irq %d\n", pending_vec);</yellow>
<yellow>		kvm_make_request(KVM_REQ_EVENT, vcpu);</yellow>
	}
	return 0;
}

static int __set_sregs2(struct kvm_vcpu *vcpu, struct kvm_sregs2 *sregs2)
{
	int mmu_reset_needed = 0;
<blue>	bool valid_pdptrs = sregs2->flags & KVM_SREGS2_FLAGS_PDPTRS_VALID;</blue>
<blue>	bool pae = (sregs2->cr0 & X86_CR0_PG) && (sregs2->cr4 & X86_CR4_PAE) &&</blue>
<blue>		!(sregs2->efer & EFER_LMA);</blue>
	int i, ret;

<blue>	if (sregs2->flags & ~KVM_SREGS2_FLAGS_PDPTRS_VALID)</blue>
		return -EINVAL;

<yellow>	if (valid_pdptrs && (!pae || vcpu->arch.guest_state_protected))</yellow>
		return -EINVAL;

<blue>	ret = __set_sregs_common(vcpu, (struct kvm_sregs *)sregs2,</blue>
				 &amp;mmu_reset_needed, !valid_pdptrs);
	if (ret)
		return ret;

	if (valid_pdptrs) {
		for (i = 0; i &lt; 4 ; i++)
<yellow>			kvm_pdptr_write(vcpu, i, sregs2->pdptrs[i]);</yellow>

<yellow>		kvm_register_mark_dirty(vcpu, VCPU_EXREG_PDPTR);</yellow>
		mmu_reset_needed = 1;
		vcpu-&gt;arch.pdptrs_from_userspace = true;
	}
<blue>	if (mmu_reset_needed)</blue>
<yellow>		kvm_mmu_reset_context(vcpu);</yellow>
	return 0;
}

int kvm_arch_vcpu_ioctl_set_sregs(struct kvm_vcpu *vcpu,
				  struct kvm_sregs *sregs)
{
	int ret;

<yellow>	vcpu_load(vcpu);</yellow>
	ret = __set_sregs(vcpu, sregs);
	vcpu_put(vcpu);
	return ret;
}

static void kvm_arch_vcpu_guestdbg_update_apicv_inhibit(struct kvm *kvm)
{
	bool set = false;
	struct kvm_vcpu *vcpu;
	unsigned long i;

<yellow>	if (!enable_apicv)</yellow>
		return;

<yellow>	down_write(&kvm->arch.apicv_update_lock);</yellow>

<yellow>	kvm_for_each_vcpu(i, vcpu, kvm) {</yellow>
<yellow>		if (vcpu->guest_debug & KVM_GUESTDBG_BLOCKIRQ) {</yellow>
			set = true;
			break;
		}
	}
<yellow>	__kvm_set_or_clear_apicv_inhibit(kvm, APICV_INHIBIT_REASON_BLOCKIRQ, set);</yellow>
	up_write(&amp;kvm-&gt;arch.apicv_update_lock);
}

int kvm_arch_vcpu_ioctl_set_guest_debug(struct kvm_vcpu *vcpu,
					struct kvm_guest_debug *dbg)
<yellow>{</yellow>
	unsigned long rflags;
	int i, r;

<yellow>	if (vcpu->arch.guest_state_protected)</yellow>
		return -EINVAL;

<yellow>	vcpu_load(vcpu);</yellow>

	if (dbg-&gt;control &amp; (KVM_GUESTDBG_INJECT_DB | KVM_GUESTDBG_INJECT_BP)) {
		r = -EBUSY;
<yellow>		if (kvm_is_exception_pending(vcpu))</yellow>
			goto out;
<yellow>		if (dbg->control & KVM_GUESTDBG_INJECT_DB)</yellow>
<yellow>			kvm_queue_exception(vcpu, DB_VECTOR);</yellow>
		else
<yellow>			kvm_queue_exception(vcpu, BP_VECTOR);</yellow>
	}

	/*
	 * Read rflags as long as potentially injected trace flags are still
	 * filtered out.
	 */
<yellow>	rflags = kvm_get_rflags(vcpu);</yellow>

<yellow>	vcpu->guest_debug = dbg->control;</yellow>
	if (!(vcpu-&gt;guest_debug &amp; KVM_GUESTDBG_ENABLE))
		vcpu-&gt;guest_debug = 0;

	if (vcpu-&gt;guest_debug &amp; KVM_GUESTDBG_USE_HW_BP) {
		for (i = 0; i &lt; KVM_NR_DB_REGS; ++i)
<yellow>			vcpu->arch.eff_db[i] = dbg->arch.debugreg[i];</yellow>
		vcpu-&gt;arch.guest_debug_dr7 = dbg-&gt;arch.debugreg[7];
	} else {
		for (i = 0; i &lt; KVM_NR_DB_REGS; i++)
<yellow>			vcpu->arch.eff_db[i] = vcpu->arch.db[i];</yellow>
	}
<yellow>	kvm_update_dr7(vcpu);</yellow>

<yellow>	if (vcpu->guest_debug & KVM_GUESTDBG_SINGLESTEP)</yellow>
<yellow>		vcpu->arch.singlestep_rip = kvm_get_linear_rip(vcpu);</yellow>

	/*
	 * Trigger an rflags update that will inject or remove the trace
	 * flags.
	 */
<yellow>	kvm_set_rflags(vcpu, rflags);</yellow>

	static_call(kvm_x86_update_exception_bitmap)(vcpu);

<yellow>	kvm_arch_vcpu_guestdbg_update_apicv_inhibit(vcpu->kvm);</yellow>

<yellow>	r = 0;</yellow>

out:
<yellow>	vcpu_put(vcpu);</yellow>
	return r;
<yellow>}</yellow>

/*
 * Translate a guest virtual address to a guest physical address.
 */
int kvm_arch_vcpu_ioctl_translate(struct kvm_vcpu *vcpu,
				    struct kvm_translation *tr)
{
<yellow>	unsigned long vaddr = tr->linear_address;</yellow>
	gpa_t gpa;
	int idx;

	vcpu_load(vcpu);

<yellow>	idx = srcu_read_lock(&vcpu->kvm->srcu);</yellow>
	gpa = kvm_mmu_gva_to_gpa_system(vcpu, vaddr, NULL);
<yellow>	srcu_read_unlock(&vcpu->kvm->srcu, idx);</yellow>
	tr-&gt;physical_address = gpa;
	tr-&gt;valid = gpa != INVALID_GPA;
	tr-&gt;writeable = 1;
	tr-&gt;usermode = 0;

	vcpu_put(vcpu);
	return 0;
}

int kvm_arch_vcpu_ioctl_get_fpu(struct kvm_vcpu *vcpu, struct kvm_fpu *fpu)
{
	struct fxregs_state *fxsave;

<yellow>	if (fpstate_is_confidential(&vcpu->arch.guest_fpu))</yellow>
		return 0;

<yellow>	vcpu_load(vcpu);</yellow>

	fxsave = &amp;vcpu-&gt;arch.guest_fpu.fpstate-&gt;regs.fxsave;
	memcpy(fpu-&gt;fpr, fxsave-&gt;st_space, 128);
	fpu-&gt;fcw = fxsave-&gt;cwd;
	fpu-&gt;fsw = fxsave-&gt;swd;
	fpu-&gt;ftwx = fxsave-&gt;twd;
	fpu-&gt;last_opcode = fxsave-&gt;fop;
	fpu-&gt;last_ip = fxsave-&gt;rip;
	fpu-&gt;last_dp = fxsave-&gt;rdp;
	memcpy(fpu-&gt;xmm, fxsave-&gt;xmm_space, sizeof(fxsave-&gt;xmm_space));

	vcpu_put(vcpu);
	return 0;
<yellow>}</yellow>

int kvm_arch_vcpu_ioctl_set_fpu(struct kvm_vcpu *vcpu, struct kvm_fpu *fpu)
{
	struct fxregs_state *fxsave;

<yellow>	if (fpstate_is_confidential(&vcpu->arch.guest_fpu))</yellow>
		return 0;

<yellow>	vcpu_load(vcpu);</yellow>

	fxsave = &amp;vcpu-&gt;arch.guest_fpu.fpstate-&gt;regs.fxsave;

	memcpy(fxsave-&gt;st_space, fpu-&gt;fpr, 128);
	fxsave-&gt;cwd = fpu-&gt;fcw;
	fxsave-&gt;swd = fpu-&gt;fsw;
	fxsave-&gt;twd = fpu-&gt;ftwx;
	fxsave-&gt;fop = fpu-&gt;last_opcode;
	fxsave-&gt;rip = fpu-&gt;last_ip;
	fxsave-&gt;rdp = fpu-&gt;last_dp;
	memcpy(fxsave-&gt;xmm_space, fpu-&gt;xmm, sizeof(fxsave-&gt;xmm_space));

	vcpu_put(vcpu);
	return 0;
<yellow>}</yellow>

static void store_regs(struct kvm_vcpu *vcpu)
{
	BUILD_BUG_ON(sizeof(struct kvm_sync_regs) &gt; SYNC_REGS_SIZE_BYTES);

<blue>	if (vcpu->run->kvm_valid_regs & KVM_SYNC_X86_REGS)</blue>
<yellow>		__get_regs(vcpu, &vcpu->run->s.regs.regs);</yellow>

<yellow>	if (vcpu->run->kvm_valid_regs & KVM_SYNC_X86_SREGS)</yellow>
<yellow>		__get_sregs(vcpu, &vcpu->run->s.regs.sregs);</yellow>

<yellow>	if (vcpu->run->kvm_valid_regs & KVM_SYNC_X86_EVENTS)</yellow>
<yellow>		kvm_vcpu_ioctl_x86_get_vcpu_events(</yellow>
				vcpu, &amp;vcpu-&gt;run-&gt;s.regs.events);
}

static int sync_regs(struct kvm_vcpu *vcpu)
{
<yellow>	if (vcpu->run->kvm_dirty_regs & KVM_SYNC_X86_REGS) {</yellow>
<yellow>		__set_regs(vcpu, &vcpu->run->s.regs.regs);</yellow>
		vcpu-&gt;run-&gt;kvm_dirty_regs &amp;= ~KVM_SYNC_X86_REGS;
	}
<yellow>	if (vcpu->run->kvm_dirty_regs & KVM_SYNC_X86_SREGS) {</yellow>
<yellow>		if (__set_sregs(vcpu, &vcpu->run->s.regs.sregs))</yellow>
			return -EINVAL;
<yellow>		vcpu->run->kvm_dirty_regs &= ~KVM_SYNC_X86_SREGS;</yellow>
	}
<yellow>	if (vcpu->run->kvm_dirty_regs & KVM_SYNC_X86_EVENTS) {</yellow>
<yellow>		if (kvm_vcpu_ioctl_x86_set_vcpu_events(</yellow>
				vcpu, &amp;vcpu-&gt;run-&gt;s.regs.events))
			return -EINVAL;
<yellow>		vcpu->run->kvm_dirty_regs &= ~KVM_SYNC_X86_EVENTS;</yellow>
	}

	return 0;
}

int kvm_arch_vcpu_precreate(struct kvm *kvm, unsigned int id)
{
<blue>	if (kvm_check_tsc_unstable() && kvm->created_vcpus)</blue>
<yellow>		pr_warn_once("kvm: SMP vm created on host with unstable TSC; "</yellow>
			     &quot;guest TSC will not be reliable\n&quot;);

<blue>	if (!kvm->arch.max_vcpu_ids)</blue>
<yellow>		kvm->arch.max_vcpu_ids = KVM_MAX_VCPU_IDS;</yellow>

<blue>	if (id >= kvm->arch.max_vcpu_ids)</blue>
		return -EINVAL;

<blue>	return static_call(kvm_x86_vcpu_precreate)(kvm);</blue>
<blue>}</blue>

int kvm_arch_vcpu_create(struct kvm_vcpu *vcpu)
{
	struct page *page;
	int r;

<blue>	vcpu->arch.last_vmentry_cpu = -1;</blue>
	vcpu-&gt;arch.regs_avail = ~0;
	vcpu-&gt;arch.regs_dirty = ~0;

	kvm_gpc_init(&amp;vcpu-&gt;arch.pv_time, vcpu-&gt;kvm, vcpu, KVM_HOST_USES_PFN);

<blue>	if (!irqchip_in_kernel(vcpu->kvm) || kvm_vcpu_is_reset_bsp(vcpu))</blue>
<blue>		vcpu->arch.mp_state = KVM_MP_STATE_RUNNABLE;</blue>
	else
		vcpu-&gt;arch.mp_state = KVM_MP_STATE_UNINITIALIZED;

	r = kvm_mmu_create(vcpu);
	if (r &lt; 0)
		return r;

<blue>	if (irqchip_in_kernel(vcpu->kvm)) {</blue>
<blue>		r = kvm_create_lapic(vcpu, lapic_timer_advance_ns);</blue>
		if (r &lt; 0)
			goto fail_mmu_destroy;

		/*
		 * Defer evaluating inhibits until the vCPU is first run, as
		 * this vCPU will not get notified of any changes until this
		 * vCPU is visible to other vCPUs (marked online and added to
		 * the set of vCPUs).  Opportunistically mark APICv active as
		 * VMX in particularly is highly unlikely to have inhibits.
		 * Ignore the current per-VM APICv state so that vCPU creation
		 * is guaranteed to run with a deterministic value, the request
		 * will ensure the vCPU gets the correct state before VM-Entry.
		 */
<blue>		if (enable_apicv) {</blue>
<blue>			vcpu->arch.apic->apicv_active = true;</blue>
			kvm_make_request(KVM_REQ_APICV_UPDATE, vcpu);
		}
	} else
<yellow>		static_branch_inc(&kvm_has_noapic_vcpu);</yellow>

	r = -ENOMEM;

<blue>	page = alloc_page(GFP_KERNEL_ACCOUNT | __GFP_ZERO);</blue>
	if (!page)
		goto fail_free_lapic;
<blue>	vcpu->arch.pio_data = page_address(page);</blue>

	vcpu-&gt;arch.mce_banks = kcalloc(KVM_MAX_MCE_BANKS * 4, sizeof(u64),
				       GFP_KERNEL_ACCOUNT);
	vcpu-&gt;arch.mci_ctl2_banks = kcalloc(KVM_MAX_MCE_BANKS, sizeof(u64),
					    GFP_KERNEL_ACCOUNT);
<blue>	if (!vcpu->arch.mce_banks || !vcpu->arch.mci_ctl2_banks)</blue>
		goto fail_free_mce_banks;
<blue>	vcpu->arch.mcg_cap = KVM_MAX_MCE_BANKS;</blue>

	if (!zalloc_cpumask_var(&amp;vcpu-&gt;arch.wbinvd_dirty_mask,
				GFP_KERNEL_ACCOUNT))
		goto fail_free_mce_banks;

<blue>	if (!alloc_emulate_ctxt(vcpu))</blue>
		goto free_wbinvd_dirty_mask;

	if (!fpu_alloc_guest_fpstate(&amp;vcpu-&gt;arch.guest_fpu)) {
		pr_err(&quot;kvm: failed to allocate vcpu&#x27;s fpu\n&quot;);
		goto free_emulate_ctxt;
	}

<blue>	vcpu->arch.maxphyaddr = cpuid_query_maxphyaddr(vcpu);</blue>
	vcpu-&gt;arch.reserved_gpa_bits = kvm_vcpu_reserved_gpa_bits_raw(vcpu);

	vcpu-&gt;arch.pat = MSR_IA32_CR_PAT_DEFAULT;

<blue>	kvm_async_pf_hash_reset(vcpu);</blue>

<blue>	vcpu->arch.perf_capabilities = kvm_caps.supported_perf_cap;</blue>
	kvm_pmu_init(vcpu);

	vcpu-&gt;arch.pending_external_vector = -1;
	vcpu-&gt;arch.preempted_in_kernel = false;

#if IS_ENABLED(CONFIG_HYPERV)
	vcpu-&gt;arch.hv_root_tdp = INVALID_PAGE;
#endif

	r = static_call(kvm_x86_vcpu_create)(vcpu);
	if (r)
		goto free_guest_fpu;

<blue>	vcpu->arch.arch_capabilities = kvm_get_arch_capabilities();</blue>
	vcpu-&gt;arch.msr_platform_info = MSR_PLATFORM_INFO_CPUID_FAULT;
	kvm_xen_init_vcpu(vcpu);
	kvm_vcpu_mtrr_init(vcpu);
	vcpu_load(vcpu);
	kvm_set_tsc_khz(vcpu, vcpu-&gt;kvm-&gt;arch.default_tsc_khz);
	kvm_vcpu_reset(vcpu, false);
	kvm_init_mmu(vcpu);
	vcpu_put(vcpu);
	return 0;

free_guest_fpu:
<yellow>	fpu_free_guest_fpstate(&vcpu->arch.guest_fpu);</yellow>
free_emulate_ctxt:
<yellow>	kmem_cache_free(x86_emulator_cache, vcpu->arch.emulate_ctxt);</yellow>
free_wbinvd_dirty_mask:
<yellow>	free_cpumask_var(vcpu->arch.wbinvd_dirty_mask);</yellow>
fail_free_mce_banks:
<yellow>	kfree(vcpu->arch.mce_banks);</yellow>
	kfree(vcpu-&gt;arch.mci_ctl2_banks);
	free_page((unsigned long)vcpu-&gt;arch.pio_data);
fail_free_lapic:
<yellow>	kvm_free_lapic(vcpu);</yellow>
fail_mmu_destroy:
<yellow>	kvm_mmu_destroy(vcpu);</yellow>
	return r;
<blue>}</blue>

void kvm_arch_vcpu_postcreate(struct kvm_vcpu *vcpu)
{
<blue>	struct kvm *kvm = vcpu->kvm;</blue>

	if (mutex_lock_killable(&amp;vcpu-&gt;mutex))
		return;
<blue>	vcpu_load(vcpu);</blue>
	kvm_synchronize_tsc(vcpu, 0);
	vcpu_put(vcpu);

	/* poll control enabled by default */
	vcpu-&gt;arch.msr_kvm_poll_control = 1;

	mutex_unlock(&amp;vcpu-&gt;mutex);

<blue>	if (kvmclock_periodic_sync && vcpu->vcpu_idx == 0)</blue>
<blue>		schedule_delayed_work(&kvm->arch.kvmclock_sync_work,</blue>
						KVMCLOCK_SYNC_PERIOD);
<blue>}</blue>

void kvm_arch_vcpu_destroy(struct kvm_vcpu *vcpu)
{
	int idx;

<yellow>	kvmclock_reset(vcpu);</yellow>

	static_call(kvm_x86_vcpu_free)(vcpu);

	kmem_cache_free(x86_emulator_cache, vcpu-&gt;arch.emulate_ctxt);
	free_cpumask_var(vcpu-&gt;arch.wbinvd_dirty_mask);
	fpu_free_guest_fpstate(&amp;vcpu-&gt;arch.guest_fpu);

	kvm_xen_destroy_vcpu(vcpu);
	kvm_hv_vcpu_uninit(vcpu);
	kvm_pmu_destroy(vcpu);
	kfree(vcpu-&gt;arch.mce_banks);
	kfree(vcpu-&gt;arch.mci_ctl2_banks);
	kvm_free_lapic(vcpu);
<yellow>	idx = srcu_read_lock(&vcpu->kvm->srcu);</yellow>
	kvm_mmu_destroy(vcpu);
<yellow>	srcu_read_unlock(&vcpu->kvm->srcu, idx);</yellow>
	free_page((unsigned long)vcpu-&gt;arch.pio_data);
	kvfree(vcpu-&gt;arch.cpuid_entries);
<yellow>	if (!lapic_in_kernel(vcpu))</yellow>
<yellow>		static_branch_dec(&kvm_has_noapic_vcpu);</yellow>
<yellow>}</yellow>

void kvm_vcpu_reset(struct kvm_vcpu *vcpu, bool init_event)
<blue>{</blue>
	struct kvm_cpuid_entry2 *cpuid_0x1;
<blue>	unsigned long old_cr0 = kvm_read_cr0(vcpu);</blue>
	unsigned long new_cr0;

	/*
	 * Several of the &quot;set&quot; flows, e.g. -&gt;set_cr0(), read other registers
	 * to handle side effects.  RESET emulation hits those flows and relies
	 * on emulated/virtualized registers, including those that are loaded
	 * into hardware, to be zeroed at vCPU creation.  Use CRs as a sentinel
	 * to detect improper or missing initialization.
	 */
<blue>	WARN_ON_ONCE(!init_event &&</blue>
		     (old_cr0 || kvm_read_cr3(vcpu) || kvm_read_cr4(vcpu)));

	/*
	 * SVM doesn&#x27;t unconditionally VM-Exit on INIT and SHUTDOWN, thus it&#x27;s
	 * possible to INIT the vCPU while L2 is active.  Force the vCPU back
	 * into L1 as EFER.SVME is cleared on INIT (along with all other EFER
	 * bits), i.e. virtualization is disabled.
	 */
<blue>	if (is_guest_mode(vcpu))</blue>
<yellow>		kvm_leave_nested(vcpu);</yellow>

<blue>	kvm_lapic_reset(vcpu, init_event);</blue>

<yellow>	WARN_ON_ONCE(is_guest_mode(vcpu) || is_smm(vcpu));</yellow>
<blue>	vcpu->arch.hflags = 0;</blue>

	vcpu-&gt;arch.smi_pending = 0;
	vcpu-&gt;arch.smi_count = 0;
	atomic_set(&amp;vcpu-&gt;arch.nmi_queued, 0);
	vcpu-&gt;arch.nmi_pending = 0;
	vcpu-&gt;arch.nmi_injected = false;
	kvm_clear_interrupt_queue(vcpu);
	kvm_clear_exception_queue(vcpu);

	memset(vcpu-&gt;arch.db, 0, sizeof(vcpu-&gt;arch.db));
<blue>	kvm_update_dr0123(vcpu);</blue>
<yellow>	vcpu->arch.dr6 = DR6_ACTIVE_LOW;</yellow>
	vcpu-&gt;arch.dr7 = DR7_FIXED_1;
<yellow>	kvm_update_dr7(vcpu);</yellow>

<blue>	vcpu->arch.cr2 = 0;</blue>

	kvm_make_request(KVM_REQ_EVENT, vcpu);
	vcpu-&gt;arch.apf.msr_en_val = 0;
	vcpu-&gt;arch.apf.msr_int_val = 0;
	vcpu-&gt;arch.st.msr_val = 0;

	kvmclock_reset(vcpu);

	kvm_clear_async_pf_completion_queue(vcpu);
<blue>	kvm_async_pf_hash_reset(vcpu);</blue>
<blue>	vcpu->arch.apf.halted = false;</blue>

<blue>	if (vcpu->arch.guest_fpu.fpstate && kvm_mpx_supported()) {</blue>
		struct fpstate *fpstate = vcpu-&gt;arch.guest_fpu.fpstate;

		/*
		 * All paths that lead to INIT are required to load the guest&#x27;s
		 * FPU state (because most paths are buried in KVM_RUN).
		 */
<yellow>		if (init_event)</yellow>
<yellow>			kvm_put_guest_fpu(vcpu);</yellow>

<yellow>		fpstate_clear_xstate_component(fpstate, XFEATURE_BNDREGS);</yellow>
		fpstate_clear_xstate_component(fpstate, XFEATURE_BNDCSR);

		if (init_event)
			kvm_load_guest_fpu(vcpu);
	}

<blue>	if (!init_event) {</blue>
<blue>		kvm_pmu_reset(vcpu);</blue>
		vcpu-&gt;arch.smbase = 0x30000;

		vcpu-&gt;arch.msr_misc_features_enables = 0;
		vcpu-&gt;arch.ia32_misc_enable_msr = MSR_IA32_MISC_ENABLE_PEBS_UNAVAIL |
						  MSR_IA32_MISC_ENABLE_BTS_UNAVAIL;

<yellow>		__kvm_set_xcr(vcpu, 0, XFEATURE_MASK_FP);</yellow>
<blue>		__kvm_set_msr(vcpu, MSR_IA32_XSS, 0, true);</blue>
	}

	/* All GPRs except RDX (handled below) are zeroed on RESET/INIT. */
<blue>	memset(vcpu->arch.regs, 0, sizeof(vcpu->arch.regs));</blue>
	kvm_register_mark_dirty(vcpu, VCPU_REGS_RSP);

	/*
	 * Fall back to KVM&#x27;s default Family/Model/Stepping of 0x600 (P6/Athlon)
	 * if no CPUID match is found.  Note, it&#x27;s impossible to get a match at
	 * RESET since KVM emulates RESET before exposing the vCPU to userspace,
	 * i.e. it&#x27;s impossible for kvm_find_cpuid_entry() to find a valid entry
	 * on RESET.  But, go through the motions in case that&#x27;s ever remedied.
	 */
	cpuid_0x1 = kvm_find_cpuid_entry(vcpu, 1);
<blue>	kvm_rdx_write(vcpu, cpuid_0x1 ? cpuid_0x1->eax : 0x600);</blue>

	static_call(kvm_x86_vcpu_reset)(vcpu, init_event);

	kvm_set_rflags(vcpu, X86_EFLAGS_FIXED);
	kvm_rip_write(vcpu, 0xfff0);

	vcpu-&gt;arch.cr3 = 0;
	kvm_register_mark_dirty(vcpu, VCPU_EXREG_CR3);

	/*
	 * CR0.CD/NW are set on RESET, preserved on INIT.  Note, some versions
	 * of Intel&#x27;s SDM list CD/NW as being set on INIT, but they contradict
	 * (or qualify) that with a footnote stating that CD/NW are preserved.
	 */
	new_cr0 = X86_CR0_ET;
	if (init_event)
<yellow>		new_cr0 |= (old_cr0 & (X86_CR0_NW | X86_CR0_CD));</yellow>
	else
		new_cr0 |= X86_CR0_NW | X86_CR0_CD;

<blue>	static_call(kvm_x86_set_cr0)(vcpu, new_cr0);</blue>
	static_call(kvm_x86_set_cr4)(vcpu, 0);
	static_call(kvm_x86_set_efer)(vcpu, 0);
	static_call(kvm_x86_update_exception_bitmap)(vcpu);

	/*
	 * On the standard CR0/CR4/EFER modification paths, there are several
	 * complex conditions determining whether the MMU has to be reset and/or
	 * which PCIDs have to be flushed.  However, CR0.WP and the paging-related
	 * bits in CR4 and EFER are irrelevant if CR0.PG was &#x27;0&#x27;; and a reset+flush
	 * is needed anyway if CR0.PG was &#x27;1&#x27; (which can only happen for INIT, as
	 * CR0 will be &#x27;0&#x27; prior to RESET).  So we only need to check CR0.PG here.
	 */
	if (old_cr0 &amp; X86_CR0_PG) {
<yellow>		kvm_make_request(KVM_REQ_TLB_FLUSH_GUEST, vcpu);</yellow>
		kvm_mmu_reset_context(vcpu);
	}

	/*
	 * Intel&#x27;s SDM states that all TLB entries are flushed on INIT.  AMD&#x27;s
	 * APM states the TLBs are untouched by INIT, but it also states that
	 * the TLBs are flushed on &quot;External initialization of the processor.&quot;
	 * Flush the guest TLB regardless of vendor, there is no meaningful
	 * benefit in relying on the guest to flush the TLB immediately after
	 * INIT.  A spurious TLB flush is benign and likely negligible from a
	 * performance perspective.
	 */
	if (init_event)
<yellow>		kvm_make_request(KVM_REQ_TLB_FLUSH_GUEST, vcpu);</yellow>
}
EXPORT_SYMBOL_GPL(kvm_vcpu_reset);

void kvm_vcpu_deliver_sipi_vector(struct kvm_vcpu *vcpu, u8 vector)
{
	struct kvm_segment cs;

<yellow>	kvm_get_segment(vcpu, &cs, VCPU_SREG_CS);</yellow>
	cs.selector = vector &lt;&lt; 8;
	cs.base = vector &lt;&lt; 12;
	kvm_set_segment(vcpu, &amp;cs, VCPU_SREG_CS);
	kvm_rip_write(vcpu, 0);
}
EXPORT_SYMBOL_GPL(kvm_vcpu_deliver_sipi_vector);

int kvm_arch_hardware_enable(void)
<blue>{</blue>
	struct kvm *kvm;
	struct kvm_vcpu *vcpu;
	unsigned long i;
	int ret;
	u64 local_tsc;
	u64 max_tsc = 0;
	bool stable, backwards_tsc = false;

<blue>	kvm_user_return_msr_cpu_online();</blue>
<blue>	ret = static_call(kvm_x86_hardware_enable)();</blue>
	if (ret != 0)
		return ret;

<blue>	local_tsc = rdtsc();</blue>
<blue>	stable = !kvm_check_tsc_unstable();</blue>
<blue>	list_for_each_entry(kvm, &vm_list, vm_list) {</blue>
<yellow>		kvm_for_each_vcpu(i, vcpu, kvm) {</yellow>
<yellow>			if (!stable && vcpu->cpu == smp_processor_id())</yellow>
<yellow>				kvm_make_request(KVM_REQ_CLOCK_UPDATE, vcpu);</yellow>
<yellow>			if (stable && vcpu->arch.last_host_tsc > local_tsc) {</yellow>
				backwards_tsc = true;
<yellow>				if (vcpu->arch.last_host_tsc > max_tsc)</yellow>
					max_tsc = vcpu-&gt;arch.last_host_tsc;
			}
		}
	}

	/*
	 * Sometimes, even reliable TSCs go backwards.  This happens on
	 * platforms that reset TSC during suspend or hibernate actions, but
	 * maintain synchronization.  We must compensate.  Fortunately, we can
	 * detect that condition here, which happens early in CPU bringup,
	 * before any KVM threads can be running.  Unfortunately, we can&#x27;t
	 * bring the TSCs fully up to date with real time, as we aren&#x27;t yet far
	 * enough into CPU bringup that we know how much real time has actually
	 * elapsed; our helper function, ktime_get_boottime_ns() will be using boot
	 * variables that haven&#x27;t been updated yet.
	 *
	 * So we simply find the maximum observed TSC above, then record the
	 * adjustment to TSC in each VCPU.  When the VCPU later gets loaded,
	 * the adjustment will be applied.  Note that we accumulate
	 * adjustments, in case multiple suspend cycles happen before some VCPU
	 * gets a chance to run again.  In the event that no KVM threads get a
	 * chance to run, we will miss the entire elapsed period, as we&#x27;ll have
	 * reset last_host_tsc, so VCPUs will not have the TSC adjusted and may
	 * loose cycle time.  This isn&#x27;t too big a deal, since the loss will be
	 * uniform across all VCPUs (not to mention the scenario is extremely
	 * unlikely). It is possible that a second hibernate recovery happens
	 * much faster than a first, causing the observed TSC here to be
	 * smaller; this would require additional padding adjustment, which is
	 * why we set last_host_tsc to the local tsc observed here.
	 *
	 * N.B. - this code below runs only on platforms with reliable TSC,
	 * as that is the only way backwards_tsc is set above.  Also note
	 * that this runs for ALL vcpus, which is not a bug; all VCPUs should
	 * have the same delta_cyc adjustment applied if backwards_tsc
	 * is detected.  Note further, this adjustment is only done once,
	 * as we reset last_host_tsc on all VCPUs to stop this from being
	 * called multiple times (one for each physical CPU bringup).
	 *
	 * Platforms with unreliable TSCs don&#x27;t have to deal with this, they
	 * will be compensated by the logic in vcpu_load, which sets the TSC to
	 * catchup mode.  This will catchup all VCPUs to real time, but cannot
	 * guarantee that they stay in perfect synchronization.
	 */
<yellow>	if (backwards_tsc) {</yellow>
<yellow>		u64 delta_cyc = max_tsc - local_tsc;</yellow>
		list_for_each_entry(kvm, &amp;vm_list, vm_list) {
<yellow>			kvm->arch.backwards_tsc_observed = true;</yellow>
			kvm_for_each_vcpu(i, vcpu, kvm) {
<yellow>				vcpu->arch.tsc_offset_adjustment += delta_cyc;</yellow>
				vcpu-&gt;arch.last_host_tsc = local_tsc;
				kvm_make_request(KVM_REQ_MASTERCLOCK_UPDATE, vcpu);
			}

			/*
			 * We have to disable TSC offset matching.. if you were
			 * booting a VM while issuing an S4 host suspend....
			 * you may have some problem.  Solving this issue is
			 * left as an exercise to the reader.
			 */
<yellow>			kvm->arch.last_tsc_nsec = 0;</yellow>
			kvm-&gt;arch.last_tsc_write = 0;
		}

	}
	return 0;
}

void kvm_arch_hardware_disable(void)
{
<yellow>	static_call(kvm_x86_hardware_disable)();</yellow>
<yellow>	drop_user_return_notifiers();</yellow>
<yellow>}</yellow>

static inline void kvm_ops_update(struct kvm_x86_init_ops *ops)
{
<yellow>	memcpy(&kvm_x86_ops, ops->runtime_ops, sizeof(kvm_x86_ops));</yellow>

#define __KVM_X86_OP(func) \
	static_call_update(kvm_x86_##func, kvm_x86_ops.func);
#define KVM_X86_OP(func) \
	WARN_ON(!kvm_x86_ops.func); __KVM_X86_OP(func)
#define KVM_X86_OP_OPTIONAL __KVM_X86_OP
#define KVM_X86_OP_OPTIONAL_RET0(func) \
	static_call_update(kvm_x86_##func, (void *)kvm_x86_ops.func ? : \
					   (void *)__static_call_return0);
#include &lt;asm/kvm-x86-ops.h&gt;
#undef __KVM_X86_OP

	kvm_pmu_ops_update(ops-&gt;pmu_ops);
}

int kvm_arch_hardware_setup(void *opaque)
<yellow>{</yellow>
	struct kvm_x86_init_ops *ops = opaque;
	int r;

<yellow>	rdmsrl_safe(MSR_EFER, &host_efer);</yellow>

	if (boot_cpu_has(X86_FEATURE_XSAVES))
<yellow>		rdmsrl(MSR_IA32_XSS, host_xss);</yellow>

<yellow>	kvm_init_pmu_capability();</yellow>

<yellow>	r = ops->hardware_setup();</yellow>
	if (r != 0)
		return r;

<yellow>	kvm_ops_update(ops);</yellow>

	kvm_register_perf_callbacks(ops-&gt;handle_intel_pt_intr);

	if (!kvm_cpu_cap_has(X86_FEATURE_XSAVES))
<yellow>		kvm_caps.supported_xss = 0;</yellow>

#define __kvm_cpu_cap_has(UNUSED_, f) kvm_cpu_cap_has(f)
<yellow>	cr4_reserved_bits = __cr4_reserved_bits(__kvm_cpu_cap_has, UNUSED_);</yellow>
#undef __kvm_cpu_cap_has

<yellow>	if (kvm_caps.has_tsc_control) {</yellow>
		/*
		 * Make sure the user can only configure tsc_khz values that
		 * fit into a signed integer.
		 * A min value is not calculated because it will always
		 * be 1 on all machines.
		 */
<yellow>		u64 max = min(0x7fffffffULL,</yellow>
			      __scale_tsc(kvm_caps.max_tsc_scaling_ratio, tsc_khz));
		kvm_caps.max_guest_tsc_khz = max;
	}
<yellow>	kvm_caps.default_tsc_scaling_ratio = 1ULL << kvm_caps.tsc_scaling_ratio_frac_bits;</yellow>
<yellow>	kvm_init_msr_list();</yellow>
	return 0;
}

void kvm_arch_hardware_unsetup(void)
{
<yellow>	kvm_unregister_perf_callbacks();</yellow>

	static_call(kvm_x86_hardware_unsetup)();
}

int kvm_arch_check_processor_compat(void *opaque)
{
<yellow>	struct cpuinfo_x86 *c = &cpu_data(smp_processor_id());</yellow>
	struct kvm_x86_init_ops *ops = opaque;

<yellow>	WARN_ON(!irqs_disabled());</yellow>

<yellow>	if (__cr4_reserved_bits(cpu_has, c) !=</yellow>
<yellow>	    __cr4_reserved_bits(cpu_has, &boot_cpu_data))</yellow>
		return -EIO;

<yellow>	return ops->check_processor_compatibility();</yellow>
<yellow>}</yellow>

bool kvm_vcpu_is_reset_bsp(struct kvm_vcpu *vcpu)
{
<blue>	return vcpu->kvm->arch.bsp_vcpu_id == vcpu->vcpu_id;</blue>
}

bool kvm_vcpu_is_bsp(struct kvm_vcpu *vcpu)
{
<yellow>	return (vcpu->arch.apic_base & MSR_IA32_APICBASE_BSP) != 0;</yellow>
}

__read_mostly DEFINE_STATIC_KEY_FALSE(kvm_has_noapic_vcpu);
EXPORT_SYMBOL_GPL(kvm_has_noapic_vcpu);

void kvm_arch_sched_in(struct kvm_vcpu *vcpu, int cpu)
{
	struct kvm_pmu *pmu = vcpu_to_pmu(vcpu);

<blue>	vcpu->arch.l1tf_flush_l1d = true;</blue>
<yellow>	if (pmu->version && unlikely(pmu->event_count)) {</yellow>
<yellow>		pmu->need_cleanup = true;</yellow>
		kvm_make_request(KVM_REQ_PMU, vcpu);
	}
<blue>	static_call(kvm_x86_sched_in)(vcpu, cpu);</blue>
}

void kvm_arch_free_vm(struct kvm *kvm)
{
<yellow>	kfree(to_kvm_hv(kvm)->hv_pa_pg);</yellow>
	__kvm_arch_free_vm(kvm);
}


int kvm_arch_init_vm(struct kvm *kvm, unsigned long type)
{
	int ret;
	unsigned long flags;

<blue>	if (type)</blue>
		return -EINVAL;

<blue>	ret = kvm_page_track_init(kvm);</blue>
	if (ret)
		goto out;

<blue>	ret = kvm_mmu_init_vm(kvm);</blue>
	if (ret)
		goto out_page_track;

<blue>	ret = static_call(kvm_x86_vm_init)(kvm);</blue>
	if (ret)
		goto out_uninit_mmu;

<blue>	INIT_HLIST_HEAD(&kvm->arch.mask_notifier_list);</blue>
	INIT_LIST_HEAD(&amp;kvm-&gt;arch.assigned_dev_head);
	atomic_set(&amp;kvm-&gt;arch.noncoherent_dma_count, 0);

	/* Reserve bit 0 of irq_sources_bitmap for userspace irq source */
	set_bit(KVM_USERSPACE_IRQ_SOURCE_ID, &amp;kvm-&gt;arch.irq_sources_bitmap);
	/* Reserve bit 1 of irq_sources_bitmap for irqfd-resampler */
	set_bit(KVM_IRQFD_RESAMPLE_IRQ_SOURCE_ID,
		&amp;kvm-&gt;arch.irq_sources_bitmap);

	raw_spin_lock_init(&amp;kvm-&gt;arch.tsc_write_lock);
	mutex_init(&amp;kvm-&gt;arch.apic_map_lock);
	seqcount_raw_spinlock_init(&amp;kvm-&gt;arch.pvclock_sc, &amp;kvm-&gt;arch.tsc_write_lock);
	kvm-&gt;arch.kvmclock_offset = -get_kvmclock_base_ns();

	raw_spin_lock_irqsave(&amp;kvm-&gt;arch.tsc_write_lock, flags);
	pvclock_update_vm_gtod_copy(kvm);
	raw_spin_unlock_irqrestore(&amp;kvm-&gt;arch.tsc_write_lock, flags);

<blue>	kvm->arch.default_tsc_khz = max_tsc_khz ? : tsc_khz;</blue>
	kvm-&gt;arch.guest_can_read_msr_platform_info = true;
<blue>	kvm->arch.enable_pmu = enable_pmu;</blue>

#if IS_ENABLED(CONFIG_HYPERV)
	spin_lock_init(&amp;kvm-&gt;arch.hv_root_tdp_lock);
	kvm-&gt;arch.hv_root_tdp = INVALID_PAGE;
#endif

	INIT_DELAYED_WORK(&amp;kvm-&gt;arch.kvmclock_update_work, kvmclock_update_fn);
	INIT_DELAYED_WORK(&amp;kvm-&gt;arch.kvmclock_sync_work, kvmclock_sync_fn);

<blue>	kvm_apicv_init(kvm);</blue>
<blue>	kvm_hv_init_vm(kvm);</blue>
	kvm_xen_init_vm(kvm);

	return 0;

out_uninit_mmu:
<yellow>	kvm_mmu_uninit_vm(kvm);</yellow>
out_page_track:
<yellow>	kvm_page_track_cleanup(kvm);</yellow>
out:
	return ret;
<blue>}</blue>

int kvm_arch_post_init_vm(struct kvm *kvm)
{
<blue>	return kvm_mmu_post_init_vm(kvm);</blue>
}

static void kvm_unload_vcpu_mmu(struct kvm_vcpu *vcpu)
{
	vcpu_load(vcpu);
	kvm_mmu_unload(vcpu);
	vcpu_put(vcpu);
}

static void kvm_unload_vcpu_mmus(struct kvm *kvm)
{
	unsigned long i;
	struct kvm_vcpu *vcpu;

<yellow>	kvm_for_each_vcpu(i, vcpu, kvm) {</yellow>
<yellow>		kvm_clear_async_pf_completion_queue(vcpu);</yellow>
		kvm_unload_vcpu_mmu(vcpu);
	}
}

void kvm_arch_sync_events(struct kvm *kvm)
{
<yellow>	cancel_delayed_work_sync(&kvm->arch.kvmclock_sync_work);</yellow>
	cancel_delayed_work_sync(&amp;kvm-&gt;arch.kvmclock_update_work);
	kvm_free_pit(kvm);
}

/**
 * __x86_set_memory_region: Setup KVM internal memory slot
 *
 * @kvm: the kvm pointer to the VM.
 * @id: the slot ID to setup.
 * @gpa: the GPA to install the slot (unused when @size == 0).
 * @size: the size of the slot. Set to zero to uninstall a slot.
 *
 * This function helps to setup a KVM internal memory slot.  Specify
 * @size &gt; 0 to install a new slot, while @size == 0 to uninstall a
 * slot.  The return code can be one of the following:
 *
 *   HVA:           on success (uninstall will return a bogus HVA)
 *   -errno:        on error
 *
 * The caller should always use IS_ERR() to check the return value
 * before use.  Note, the KVM internal memory slots are guaranteed to
 * remain valid and unchanged until the VM is destroyed, i.e., the
 * GPA-&gt;HVA translation will not change.  However, the HVA is a user
 * address, i.e. its accessibility is not guaranteed, and must be
 * accessed via __copy_{to,from}_user().
 */
void __user * __x86_set_memory_region(struct kvm *kvm, int id, gpa_t gpa,
				      u32 size)
<blue>{</blue>
	int i, r;
	unsigned long hva, old_npages;
<blue>	struct kvm_memslots *slots = kvm_memslots(kvm);</blue>
	struct kvm_memory_slot *slot;

	/* Called with kvm-&gt;slots_lock held.  */
<blue>	if (WARN_ON(id >= KVM_MEM_SLOTS_NUM))</blue>
		return ERR_PTR_USR(-EINVAL);

<blue>	slot = id_to_memslot(slots, id);</blue>
<blue>	if (size) {</blue>
<yellow>		if (slot && slot->npages)</yellow>
			return ERR_PTR_USR(-EEXIST);

		/*
		 * MAP_SHARED to prevent internal slot pages from being moved
		 * by fork()/COW.
		 */
<blue>		hva = vm_mmap(NULL, 0, size, PROT_READ | PROT_WRITE,</blue>
			      MAP_SHARED | MAP_ANONYMOUS, 0);
		if (IS_ERR((void *)hva))
			return (void __user *)hva;
	} else {
<yellow>		if (!slot || !slot->npages)</yellow>
			return NULL;

		old_npages = slot-&gt;npages;
<yellow>		hva = slot->userspace_addr;</yellow>
	}

	for (i = 0; i &lt; KVM_ADDRESS_SPACE_NUM; i++) {
		struct kvm_userspace_memory_region m;

		m.slot = id | (i &lt;&lt; 16);
		m.flags = 0;
<blue>		m.guest_phys_addr = gpa;</blue>
		m.userspace_addr = hva;
		m.memory_size = size;
<blue>		r = __kvm_set_memory_region(kvm, &m);</blue>
		if (r &lt; 0)
<yellow>			return ERR_PTR_USR(r);</yellow>
	}

<blue>	if (!size)</blue>
<yellow>		vm_munmap(hva, old_npages * PAGE_SIZE);</yellow>

<blue>	return (void __user *)hva;</blue>
}
EXPORT_SYMBOL_GPL(__x86_set_memory_region);

void kvm_arch_pre_destroy_vm(struct kvm *kvm)
{
<yellow>	kvm_mmu_pre_destroy_vm(kvm);</yellow>
}

void kvm_arch_destroy_vm(struct kvm *kvm)
{
<yellow>	if (current->mm == kvm->mm) {</yellow>
		/*
		 * Free memory regions allocated on behalf of userspace,
		 * unless the memory map has changed due to process exit
		 * or fd copying.
		 */
<yellow>		mutex_lock(&kvm->slots_lock);</yellow>
		__x86_set_memory_region(kvm, APIC_ACCESS_PAGE_PRIVATE_MEMSLOT,
					0, 0);
		__x86_set_memory_region(kvm, IDENTITY_PAGETABLE_PRIVATE_MEMSLOT,
					0, 0);
		__x86_set_memory_region(kvm, TSS_PRIVATE_MEMSLOT, 0, 0);
		mutex_unlock(&amp;kvm-&gt;slots_lock);
	}
<yellow>	kvm_unload_vcpu_mmus(kvm);</yellow>
<yellow>	static_call_cond(kvm_x86_vm_destroy)(kvm);</yellow>
<yellow>	kvm_free_msr_filter(srcu_dereference_check(kvm->arch.msr_filter, &kvm->srcu, 1));</yellow>
<yellow>	kvm_pic_destroy(kvm);</yellow>
	kvm_ioapic_destroy(kvm);
	kvm_destroy_vcpus(kvm);
	kvfree(rcu_dereference_check(kvm-&gt;arch.apic_map, 1));
	kfree(srcu_dereference_check(kvm-&gt;arch.pmu_event_filter, &amp;kvm-&gt;srcu, 1));
	kvm_mmu_uninit_vm(kvm);
	kvm_page_track_cleanup(kvm);
	kvm_xen_destroy_vm(kvm);
	kvm_hv_destroy_vm(kvm);
}

static void memslot_rmap_free(struct kvm_memory_slot *slot)
{
	int i;

	for (i = 0; i &lt; KVM_NR_PAGE_SIZES; ++i) {
<blue>		kvfree(slot->arch.rmap[i]);</blue>
		slot-&gt;arch.rmap[i] = NULL;
	}
}

void kvm_arch_free_memslot(struct kvm *kvm, struct kvm_memory_slot *slot)
{
	int i;

<blue>	memslot_rmap_free(slot);</blue>

	for (i = 1; i &lt; KVM_NR_PAGE_SIZES; ++i) {
<blue>		kvfree(slot->arch.lpage_info[i - 1]);</blue>
		slot-&gt;arch.lpage_info[i - 1] = NULL;
	}

	kvm_page_track_free_memslot(slot);
}

int memslot_rmap_alloc(struct kvm_memory_slot *slot, unsigned long npages)
<blue>{</blue>
	const int sz = sizeof(*slot-&gt;arch.rmap[0]);
	int i;

<blue>	for (i = 0; i < KVM_NR_PAGE_SIZES; ++i) {</blue>
<blue>		int level = i + 1;</blue>
<blue>		int lpages = __kvm_mmu_slot_lpages(slot, npages, level);</blue>

		if (slot-&gt;arch.rmap[i])
			continue;

		slot-&gt;arch.rmap[i] = __vcalloc(lpages, sz, GFP_KERNEL_ACCOUNT);
		if (!slot-&gt;arch.rmap[i]) {
<yellow>			memslot_rmap_free(slot);</yellow>
			return -ENOMEM;
		}
	}

	return 0;
<blue>}</blue>

static int kvm_alloc_memslot_metadata(struct kvm *kvm,
				      struct kvm_memory_slot *slot)
{
<blue>	unsigned long npages = slot->npages;</blue>
	int i, r;

	/*
	 * Clear out the previous array pointers for the KVM_MR_MOVE case.  The
	 * old arrays will be freed by __kvm_set_memory_region() if installing
	 * the new memslot is successful.
	 */
	memset(&amp;slot-&gt;arch, 0, sizeof(slot-&gt;arch));

<blue>	if (kvm_memslots_have_rmaps(kvm)) {</blue>
<blue>		r = memslot_rmap_alloc(slot, npages);</blue>
<blue>		if (r)</blue>
			return r;
	}

<blue>	for (i = 1; i < KVM_NR_PAGE_SIZES; ++i) {</blue>
		struct kvm_lpage_info *linfo;
		unsigned long ugfn;
		int lpages;
<blue>		int level = i + 1;</blue>

		lpages = __kvm_mmu_slot_lpages(slot, npages, level);

		linfo = __vcalloc(lpages, sizeof(*linfo), GFP_KERNEL_ACCOUNT);
		if (!linfo)
			goto out_free;

<blue>		slot->arch.lpage_info[i - 1] = linfo;</blue>

		if (slot-&gt;base_gfn &amp; (KVM_PAGES_PER_HPAGE(level) - 1))
<blue>			linfo[0].disallow_lpage = 1;</blue>
<blue>		if ((slot->base_gfn + npages) & (KVM_PAGES_PER_HPAGE(level) - 1))</blue>
<blue>			linfo[lpages - 1].disallow_lpage = 1;</blue>
<blue>		ugfn = slot->userspace_addr >> PAGE_SHIFT;</blue>
		/*
		 * If the gfn and userspace address are not aligned wrt each
		 * other, disable large page support for this slot.
		 */
		if ((slot-&gt;base_gfn ^ ugfn) &amp; (KVM_PAGES_PER_HPAGE(level) - 1)) {
			unsigned long j;

<blue>			for (j = 0; j < lpages; ++j)</blue>
<blue>				linfo[j].disallow_lpage = 1;</blue>
		}
	}

<blue>	if (kvm_page_track_create_memslot(kvm, slot, npages))</blue>
		goto out_free;

	return 0;

out_free:
<yellow>	memslot_rmap_free(slot);</yellow>

	for (i = 1; i &lt; KVM_NR_PAGE_SIZES; ++i) {
<yellow>		kvfree(slot->arch.lpage_info[i - 1]);</yellow>
		slot-&gt;arch.lpage_info[i - 1] = NULL;
	}
	return -ENOMEM;
}

void kvm_arch_memslots_updated(struct kvm *kvm, u64 gen)
<blue>{</blue>
	struct kvm_vcpu *vcpu;
	unsigned long i;

	/*
	 * memslots-&gt;generation has been incremented.
	 * mmio generation may have reached its maximum value.
	 */
<blue>	kvm_mmu_invalidate_mmio_sptes(kvm, gen);</blue>

	/* Force re-initialization of steal_time cache */
	kvm_for_each_vcpu(i, vcpu, kvm)
<blue>		kvm_vcpu_kick(vcpu);</blue>
}

int kvm_arch_prepare_memory_region(struct kvm *kvm,
				   const struct kvm_memory_slot *old,
				   struct kvm_memory_slot *new,
				   enum kvm_mr_change change)
{
<blue>	if (change == KVM_MR_CREATE || change == KVM_MR_MOVE) {</blue>
<blue>		if ((new->base_gfn + new->npages - 1) > kvm_mmu_max_gfn())</blue>
			return -EINVAL;

<blue>		return kvm_alloc_memslot_metadata(kvm, new);</blue>
	}

<blue>	if (change == KVM_MR_FLAGS_ONLY)</blue>
<yellow>		memcpy(&new->arch, &old->arch, sizeof(old->arch));</yellow>
<blue>	else if (WARN_ON_ONCE(change != KVM_MR_DELETE))</blue>
		return -EIO;

	return 0;
<blue>}</blue>


static void kvm_mmu_update_cpu_dirty_logging(struct kvm *kvm, bool enable)
{
	struct kvm_arch *ka = &amp;kvm-&gt;arch;

<yellow>	if (!kvm_x86_ops.cpu_dirty_log_size)</yellow>
		return;

<yellow>	if ((enable && ++ka->cpu_dirty_logging_count == 1) ||</yellow>
<yellow>	    (!enable && --ka->cpu_dirty_logging_count == 0))</yellow>
<yellow>		kvm_make_all_cpus_request(kvm, KVM_REQ_UPDATE_CPU_DIRTY_LOGGING);</yellow>

<yellow>	WARN_ON_ONCE(ka->cpu_dirty_logging_count < 0);</yellow>
}

static void kvm_mmu_slot_apply_flags(struct kvm *kvm,
				     struct kvm_memory_slot *old,
				     const struct kvm_memory_slot *new,
				     enum kvm_mr_change change)
{
<blue>	u32 old_flags = old ? old->flags : 0;</blue>
<blue>	u32 new_flags = new ? new->flags : 0;</blue>
	bool log_dirty_pages = new_flags &amp; KVM_MEM_LOG_DIRTY_PAGES;

	/*
	 * Update CPU dirty logging if dirty logging is being toggled.  This
	 * applies to all operations.
	 */
<blue>	if ((old_flags ^ new_flags) & KVM_MEM_LOG_DIRTY_PAGES)</blue>
<yellow>		kvm_mmu_update_cpu_dirty_logging(kvm, log_dirty_pages);</yellow>

	/*
	 * Nothing more to do for RO slots (which can&#x27;t be dirtied and can&#x27;t be
	 * made writable) or CREATE/MOVE/DELETE of a slot.
	 *
	 * For a memslot with dirty logging disabled:
	 * CREATE:      No dirty mappings will already exist.
	 * MOVE/DELETE: The old mappings will already have been cleaned up by
	 *		kvm_arch_flush_shadow_memslot()
	 *
	 * For a memslot with dirty logging enabled:
	 * CREATE:      No shadow pages exist, thus nothing to write-protect
	 *		and no dirty bits to clear.
	 * MOVE/DELETE: The old mappings will already have been cleaned up by
	 *		kvm_arch_flush_shadow_memslot().
	 */
<blue>	if ((change != KVM_MR_FLAGS_ONLY) || (new_flags & KVM_MEM_READONLY))</blue>
		return;

	/*
	 * READONLY and non-flags changes were filtered out above, and the only
	 * other flag is LOG_DIRTY_PAGES, i.e. something is wrong if dirty
	 * logging isn&#x27;t being toggled on or off.
	 */
<yellow>	if (WARN_ON_ONCE(!((old_flags ^ new_flags) & KVM_MEM_LOG_DIRTY_PAGES)))</yellow>
		return;

<yellow>	if (!log_dirty_pages) {</yellow>
		/*
		 * Dirty logging tracks sptes in 4k granularity, meaning that
		 * large sptes have to be split.  If live migration succeeds,
		 * the guest in the source machine will be destroyed and large
		 * sptes will be created in the destination.  However, if the
		 * guest continues to run in the source machine (for example if
		 * live migration fails), small sptes will remain around and
		 * cause bad performance.
		 *
		 * Scan sptes if dirty logging has been stopped, dropping those
		 * which can be collapsed into a single large-page spte.  Later
		 * page faults will create the large-page sptes.
		 */
<yellow>		kvm_mmu_zap_collapsible_sptes(kvm, new);</yellow>
	} else {
		/*
		 * Initially-all-set does not require write protecting any page,
		 * because they&#x27;re all assumed to be dirty.
		 */
<yellow>		if (kvm_dirty_log_manual_protect_and_init_set(kvm))</yellow>
			return;

<yellow>		if (READ_ONCE(eager_page_split))</yellow>
<yellow>			kvm_mmu_slot_try_split_huge_pages(kvm, new, PG_LEVEL_4K);</yellow>

<yellow>		if (kvm_x86_ops.cpu_dirty_log_size) {</yellow>
<yellow>			kvm_mmu_slot_leaf_clear_dirty(kvm, new);</yellow>
			kvm_mmu_slot_remove_write_access(kvm, new, PG_LEVEL_2M);
		} else {
<yellow>			kvm_mmu_slot_remove_write_access(kvm, new, PG_LEVEL_4K);</yellow>
		}

		/*
		 * Unconditionally flush the TLBs after enabling dirty logging.
		 * A flush is almost always going to be necessary (see below),
		 * and unconditionally flushing allows the helpers to omit
		 * the subtly complex checks when removing write access.
		 *
		 * Do the flush outside of mmu_lock to reduce the amount of
		 * time mmu_lock is held.  Flushing after dropping mmu_lock is
		 * safe as KVM only needs to guarantee the slot is fully
		 * write-protected before returning to userspace, i.e. before
		 * userspace can consume the dirty status.
		 *
		 * Flushing outside of mmu_lock requires KVM to be careful when
		 * making decisions based on writable status of an SPTE, e.g. a
		 * !writable SPTE doesn&#x27;t guarantee a CPU can&#x27;t perform writes.
		 *
		 * Specifically, KVM also write-protects guest page tables to
		 * monitor changes when using shadow paging, and must guarantee
		 * no CPUs can write to those page before mmu_lock is dropped.
		 * Because CPUs may have stale TLB entries at this point, a
		 * !writable SPTE doesn&#x27;t guarantee CPUs can&#x27;t perform writes.
		 *
		 * KVM also allows making SPTES writable outside of mmu_lock,
		 * e.g. to allow dirty logging without taking mmu_lock.
		 *
		 * To handle these scenarios, KVM uses a separate software-only
		 * bit (MMU-writable) to track if a SPTE is !writable due to
		 * a guest page table being write-protected (KVM clears the
		 * MMU-writable flag when write-protecting for shadow paging).
		 *
		 * The use of MMU-writable is also the primary motivation for
		 * the unconditional flush.  Because KVM must guarantee that a
		 * CPU doesn&#x27;t contain stale, writable TLB entries for a
		 * !MMU-writable SPTE, KVM must flush if it encounters any
		 * MMU-writable SPTE regardless of whether the actual hardware
		 * writable bit was set.  I.e. KVM is almost guaranteed to need
		 * to flush, while unconditionally flushing allows the &quot;remove
		 * write access&quot; helpers to ignore MMU-writable entirely.
		 *
		 * See is_writable_pte() for more details (the case involving
		 * access-tracked SPTEs is particularly relevant).
		 */
<yellow>		kvm_arch_flush_remote_tlbs_memslot(kvm, new);</yellow>
	}
}

void kvm_arch_commit_memory_region(struct kvm *kvm,
				struct kvm_memory_slot *old,
				const struct kvm_memory_slot *new,
				enum kvm_mr_change change)
{
<blue>	if (!kvm->arch.n_requested_mmu_pages &&</blue>
	    (change == KVM_MR_CREATE || change == KVM_MR_DELETE)) {
		unsigned long nr_mmu_pages;

<blue>		nr_mmu_pages = kvm->nr_memslot_pages / KVM_MEMSLOT_PAGES_TO_MMU_PAGES_RATIO;</blue>
		nr_mmu_pages = max(nr_mmu_pages, KVM_MIN_ALLOC_MMU_PAGES);
		kvm_mmu_change_mmu_pages(kvm, nr_mmu_pages);
	}

<blue>	kvm_mmu_slot_apply_flags(kvm, old, new, change);</blue>

	/* Free the arrays associated with the old memslot. */
<blue>	if (change == KVM_MR_MOVE)</blue>
<yellow>		kvm_arch_free_memslot(kvm, old);</yellow>
<blue>}</blue>

void kvm_arch_flush_shadow_all(struct kvm *kvm)
{
<yellow>	kvm_mmu_zap_all(kvm);</yellow>
}

void kvm_arch_flush_shadow_memslot(struct kvm *kvm,
				   struct kvm_memory_slot *slot)
{
<blue>	kvm_page_track_flush_slot(kvm, slot);</blue>
}

static inline bool kvm_guest_apic_has_interrupt(struct kvm_vcpu *vcpu)
{
<blue>	return (is_guest_mode(vcpu) &&</blue>
<blue>		static_call(kvm_x86_guest_apic_has_interrupt)(vcpu));</blue>
}

static inline bool kvm_vcpu_has_events(struct kvm_vcpu *vcpu)
{
<blue>	if (!list_empty_careful(&vcpu->async_pf.done))</blue>
		return true;

<blue>	if (kvm_apic_has_pending_init_or_sipi(vcpu) &&</blue>
<yellow>	    kvm_apic_init_sipi_allowed(vcpu))</yellow>
		return true;

<blue>	if (vcpu->arch.pv.pv_unhalted)</blue>
		return true;

<blue>	if (kvm_is_exception_pending(vcpu))</blue>
		return true;

<blue>	if (kvm_test_request(KVM_REQ_NMI, vcpu) ||</blue>
<blue>	    (vcpu->arch.nmi_pending &&</blue>
<yellow>	     static_call(kvm_x86_nmi_allowed)(vcpu, false)))</yellow>
		return true;

#ifdef CONFIG_KVM_SMM
<blue>	if (kvm_test_request(KVM_REQ_SMI, vcpu) ||</blue>
<blue>	    (vcpu->arch.smi_pending &&</blue>
<yellow>	     static_call(kvm_x86_smi_allowed)(vcpu, false)))</yellow>
		return true;
#endif

<blue>	if (kvm_arch_interrupt_allowed(vcpu) &&</blue>
<blue>	    (kvm_cpu_has_interrupt(vcpu) ||</blue>
<blue>	    kvm_guest_apic_has_interrupt(vcpu)))</blue>
		return true;

<blue>	if (kvm_hv_has_stimer_pending(vcpu))</blue>
		return true;

<blue>	if (is_guest_mode(vcpu) &&</blue>
<blue>	    kvm_x86_ops.nested_ops->has_events &&</blue>
<blue>	    kvm_x86_ops.nested_ops->has_events(vcpu))</blue>
		return true;

<blue>	if (kvm_xen_has_pending_events(vcpu))</blue>
		return true;

	return false;
<blue>}</blue>

<blue>int kvm_arch_vcpu_runnable(struct kvm_vcpu *vcpu)</blue>
{
<blue>	return kvm_vcpu_running(vcpu) || kvm_vcpu_has_events(vcpu);</blue>
<blue>}</blue>

<yellow>bool kvm_arch_dy_has_pending_interrupt(struct kvm_vcpu *vcpu)</yellow>
{
<yellow>	if (kvm_vcpu_apicv_active(vcpu) &&</yellow>
<yellow>	    static_call(kvm_x86_dy_apicv_has_pending_interrupt)(vcpu))</yellow>
		return true;

<yellow>	return false;</yellow>
<yellow>}</yellow>

bool kvm_arch_dy_runnable(struct kvm_vcpu *vcpu)
{
<yellow>	if (READ_ONCE(vcpu->arch.pv.pv_unhalted))</yellow>
		return true;

<yellow>	if (kvm_test_request(KVM_REQ_NMI, vcpu) ||</yellow>
#ifdef CONFIG_KVM_SMM
<yellow>		kvm_test_request(KVM_REQ_SMI, vcpu) ||</yellow>
#endif
<yellow>		 kvm_test_request(KVM_REQ_EVENT, vcpu))</yellow>
		return true;

<yellow>	return kvm_arch_dy_has_pending_interrupt(vcpu);</yellow>
<yellow>}</yellow>

bool kvm_arch_vcpu_in_kernel(struct kvm_vcpu *vcpu)
{
<yellow>	if (vcpu->arch.guest_state_protected)</yellow>
		return true;

<yellow>	return vcpu->arch.preempted_in_kernel;</yellow>
<yellow>}</yellow>

unsigned long kvm_arch_vcpu_get_ip(struct kvm_vcpu *vcpu)
{
<yellow>	return kvm_rip_read(vcpu);</yellow>
}

int kvm_arch_vcpu_should_kick(struct kvm_vcpu *vcpu)
{
<blue>	return kvm_vcpu_exiting_guest_mode(vcpu) == IN_GUEST_MODE;</blue>
}

int kvm_arch_interrupt_allowed(struct kvm_vcpu *vcpu)
{
<blue>	return static_call(kvm_x86_interrupt_allowed)(vcpu, false);</blue>
}

<yellow>unsigned long kvm_get_linear_rip(struct kvm_vcpu *vcpu)</yellow>
<blue>{</blue>
	/* Can&#x27;t read the RIP when guest state is protected, just return 0 */
<blue>	if (vcpu->arch.guest_state_protected)</blue>
		return 0;

<blue>	if (is_64_bit_mode(vcpu))</blue>
<blue>		return kvm_rip_read(vcpu);</blue>
<yellow>	return (u32)(get_segment_base(vcpu, VCPU_SREG_CS) +</yellow>
<yellow>		     kvm_rip_read(vcpu));</yellow>
}
EXPORT_SYMBOL_GPL(kvm_get_linear_rip);

bool kvm_is_linear_rip(struct kvm_vcpu *vcpu, unsigned long linear_rip)
{
<yellow>	return kvm_get_linear_rip(vcpu) == linear_rip;</yellow>
}
EXPORT_SYMBOL_GPL(kvm_is_linear_rip);

unsigned long kvm_get_rflags(struct kvm_vcpu *vcpu)
{
	unsigned long rflags;

<blue>	rflags = static_call(kvm_x86_get_rflags)(vcpu);</blue>
<yellow>	if (vcpu->guest_debug & KVM_GUESTDBG_SINGLESTEP)</yellow>
<yellow>		rflags &= ~X86_EFLAGS_TF;</yellow>
	return rflags;
<yellow>}</yellow>
EXPORT_SYMBOL_GPL(kvm_get_rflags);

static void __kvm_set_rflags(struct kvm_vcpu *vcpu, unsigned long rflags)
{
<blue>	if (vcpu->guest_debug & KVM_GUESTDBG_SINGLESTEP &&</blue>
<yellow>	    kvm_is_linear_rip(vcpu, vcpu->arch.singlestep_rip))</yellow>
<yellow>		rflags |= X86_EFLAGS_TF;</yellow>
<blue>	static_call(kvm_x86_set_rflags)(vcpu, rflags);</blue>
}

void kvm_set_rflags(struct kvm_vcpu *vcpu, unsigned long rflags)
{
<blue>	__kvm_set_rflags(vcpu, rflags);</blue>
	kvm_make_request(KVM_REQ_EVENT, vcpu);
}
EXPORT_SYMBOL_GPL(kvm_set_rflags);

static inline u32 kvm_async_pf_hash_fn(gfn_t gfn)
{
	BUILD_BUG_ON(!is_power_of_2(ASYNC_PF_PER_VCPU));

	return hash_32(gfn &amp; 0xffffffff, order_base_2(ASYNC_PF_PER_VCPU));
}

static inline u32 kvm_async_pf_next_probe(u32 key)
{
<yellow>	return (key + 1) & (ASYNC_PF_PER_VCPU - 1);</yellow>
}

static void kvm_add_async_pf_gfn(struct kvm_vcpu *vcpu, gfn_t gfn)
{
	u32 key = kvm_async_pf_hash_fn(gfn);

	while (vcpu-&gt;arch.apf.gfns[key] != ~0)
<yellow>		key = kvm_async_pf_next_probe(key);</yellow>

<yellow>	vcpu->arch.apf.gfns[key] = gfn;</yellow>
}

static u32 kvm_async_pf_gfn_slot(struct kvm_vcpu *vcpu, gfn_t gfn)
{
	int i;
	u32 key = kvm_async_pf_hash_fn(gfn);

<yellow>	for (i = 0; i < ASYNC_PF_PER_VCPU &&</yellow>
<yellow>		     (vcpu->arch.apf.gfns[key] != gfn &&</yellow>
<yellow>		      vcpu->arch.apf.gfns[key] != ~0); i++)</yellow>
		key = kvm_async_pf_next_probe(key);

	return key;
}

bool kvm_find_async_pf_gfn(struct kvm_vcpu *vcpu, gfn_t gfn)
{
<yellow>	return vcpu->arch.apf.gfns[kvm_async_pf_gfn_slot(vcpu, gfn)] == gfn;</yellow>
}

static void kvm_del_async_pf_gfn(struct kvm_vcpu *vcpu, gfn_t gfn)
{
	u32 i, j, k;

<yellow>	i = j = kvm_async_pf_gfn_slot(vcpu, gfn);</yellow>

<yellow>	if (WARN_ON_ONCE(vcpu->arch.apf.gfns[i] != gfn))</yellow>
		return;

	while (true) {
<yellow>		vcpu->arch.apf.gfns[i] = ~0;</yellow>
		do {
<yellow>			j = kvm_async_pf_next_probe(j);</yellow>
			if (vcpu-&gt;arch.apf.gfns[j] == ~0)
				return;
<yellow>			k = kvm_async_pf_hash_fn(vcpu->arch.apf.gfns[j]);</yellow>
			/*
			 * k lies cyclically in ]i,j]
			 * |    i.k.j |
			 * |....j i.k.| or  |.k..j i...|
			 */
<yellow>		} while ((i <= j) ? (i < k && k <= j) : (i < k || k <= j));</yellow>
<yellow>		vcpu->arch.apf.gfns[i] = vcpu->arch.apf.gfns[j];</yellow>
		i = j;
	}
}

static inline int apf_put_user_notpresent(struct kvm_vcpu *vcpu)
{
	u32 reason = KVM_PV_REASON_PAGE_NOT_PRESENT;

<yellow>	return kvm_write_guest_cached(vcpu->kvm, &vcpu->arch.apf.data, &reason,</yellow>
				      sizeof(reason));
}

static inline int apf_put_user_ready(struct kvm_vcpu *vcpu, u32 token)
{
	unsigned int offset = offsetof(struct kvm_vcpu_pv_apf_data, token);

	return kvm_write_guest_offset_cached(vcpu-&gt;kvm, &amp;vcpu-&gt;arch.apf.data,
					     &amp;token, offset, sizeof(token));
}

static inline bool apf_pageready_slot_free(struct kvm_vcpu *vcpu)
{
	unsigned int offset = offsetof(struct kvm_vcpu_pv_apf_data, token);
	u32 val;

<yellow>	if (kvm_read_guest_offset_cached(vcpu->kvm, &vcpu->arch.apf.data,</yellow>
					 &amp;val, offset, sizeof(val)))
		return false;

<yellow>	return !val;</yellow>
}

<yellow>static bool kvm_can_deliver_async_pf(struct kvm_vcpu *vcpu)</yellow>
{

<yellow>	if (!kvm_pv_async_pf_enabled(vcpu))</yellow>
<yellow>		return false;</yellow>

<yellow>	if (vcpu->arch.apf.send_user_only &&</yellow>
<yellow>	    static_call(kvm_x86_get_cpl)(vcpu) == 0)</yellow>
		return false;

<yellow>	if (is_guest_mode(vcpu)) {</yellow>
		/*
		 * L1 needs to opt into the special #PF vmexits that are
		 * used to deliver async page faults.
		 */
<yellow>		return vcpu->arch.apf.delivery_as_pf_vmexit;</yellow>
	} else {
		/*
		 * Play it safe in case the guest temporarily disables paging.
		 * The real mode IDT in particular is unlikely to have a #PF
		 * exception setup.
		 */
<yellow>		return is_paging(vcpu);</yellow>
	}
<yellow>}</yellow>

bool kvm_can_do_async_pf(struct kvm_vcpu *vcpu)
{
<yellow>	if (unlikely(!lapic_in_kernel(vcpu) ||</yellow>
		     kvm_event_needs_reinjection(vcpu) ||
		     kvm_is_exception_pending(vcpu)))
<yellow>		return false;</yellow>

<yellow>	if (kvm_hlt_in_guest(vcpu->kvm) && !kvm_can_deliver_async_pf(vcpu))</yellow>
		return false;

	/*
	 * If interrupts are off we cannot even use an artificial
	 * halt state.
	 */
<yellow>	return kvm_arch_interrupt_allowed(vcpu);</yellow>
<yellow>}</yellow>

bool kvm_arch_async_page_not_present(struct kvm_vcpu *vcpu,
				     struct kvm_async_pf *work)
<yellow>{</yellow>
	struct x86_exception fault;

<yellow>	trace_kvm_async_pf_not_present(work->arch.token, work->cr2_or_gpa);</yellow>
<yellow>	kvm_add_async_pf_gfn(vcpu, work->arch.gfn);</yellow>

	if (kvm_can_deliver_async_pf(vcpu) &amp;&amp;
<yellow>	    !apf_put_user_notpresent(vcpu)) {</yellow>
		fault.vector = PF_VECTOR;
		fault.error_code_valid = true;
		fault.error_code = 0;
		fault.nested_page_fault = false;
<yellow>		fault.address = work->arch.token;</yellow>
		fault.async_page_fault = true;
		kvm_inject_page_fault(vcpu, &amp;fault);
		return true;
	} else {
		/*
		 * It is not possible to deliver a paravirtualized asynchronous
		 * page fault, but putting the guest in an artificial halt state
		 * can be beneficial nevertheless: if an interrupt arrives, we
		 * can deliver it timely and perhaps the guest will schedule
		 * another process.  When the instruction that triggered a page
		 * fault is retried, hopefully the page will be ready in the host.
		 */
<yellow>		kvm_make_request(KVM_REQ_APF_HALT, vcpu);</yellow>
		return false;
	}
}

void kvm_arch_async_page_present(struct kvm_vcpu *vcpu,
				 struct kvm_async_pf *work)
{
	struct kvm_lapic_irq irq = {
		.delivery_mode = APIC_DM_FIXED,
<yellow>		.vector = vcpu->arch.apf.vec</yellow>
	};

<yellow>	if (work->wakeup_all)</yellow>
<yellow>		work->arch.token = ~0; /* broadcast wakeup */</yellow>
	else
<yellow>		kvm_del_async_pf_gfn(vcpu, work->arch.gfn);</yellow>
<yellow>	trace_kvm_async_pf_ready(work->arch.token, work->cr2_or_gpa);</yellow>

<yellow>	if ((work->wakeup_all || work->notpresent_injected) &&</yellow>
<yellow>	    kvm_pv_async_pf_enabled(vcpu) &&</yellow>
<yellow>	    !apf_put_user_ready(vcpu, work->arch.token)) {</yellow>
<yellow>		vcpu->arch.apf.pageready_pending = true;</yellow>
		kvm_apic_set_irq(vcpu, &amp;irq, NULL);
	}

<yellow>	vcpu->arch.apf.halted = false;</yellow>
	vcpu-&gt;arch.mp_state = KVM_MP_STATE_RUNNABLE;
}

void kvm_arch_async_page_present_queued(struct kvm_vcpu *vcpu)
{
<yellow>	kvm_make_request(KVM_REQ_APF_READY, vcpu);</yellow>
<yellow>	if (!vcpu->arch.apf.pageready_pending)</yellow>
<yellow>		kvm_vcpu_kick(vcpu);</yellow>
<yellow>}</yellow>

bool kvm_arch_can_dequeue_async_page_present(struct kvm_vcpu *vcpu)
<yellow>{</yellow>
<yellow>	if (!kvm_pv_async_pf_enabled(vcpu))</yellow>
		return true;
	else
<yellow>		return kvm_lapic_enabled(vcpu) && apf_pageready_slot_free(vcpu);</yellow>
}

void kvm_arch_start_assignment(struct kvm *kvm)
{
<yellow>	if (atomic_inc_return(&kvm->arch.assigned_device_count) == 1)</yellow>
<yellow>		static_call_cond(kvm_x86_pi_start_assignment)(kvm);</yellow>
<yellow>}</yellow>
EXPORT_SYMBOL_GPL(kvm_arch_start_assignment);

void kvm_arch_end_assignment(struct kvm *kvm)
{
<yellow>	atomic_dec(&kvm->arch.assigned_device_count);</yellow>
}
EXPORT_SYMBOL_GPL(kvm_arch_end_assignment);

bool noinstr kvm_arch_has_assigned_device(struct kvm *kvm)
{
	return arch_atomic_read(&amp;kvm-&gt;arch.assigned_device_count);
}
EXPORT_SYMBOL_GPL(kvm_arch_has_assigned_device);

void kvm_arch_register_noncoherent_dma(struct kvm *kvm)
{
<yellow>	atomic_inc(&kvm->arch.noncoherent_dma_count);</yellow>
}
EXPORT_SYMBOL_GPL(kvm_arch_register_noncoherent_dma);

void kvm_arch_unregister_noncoherent_dma(struct kvm *kvm)
{
<yellow>	atomic_dec(&kvm->arch.noncoherent_dma_count);</yellow>
}
EXPORT_SYMBOL_GPL(kvm_arch_unregister_noncoherent_dma);

bool kvm_arch_has_noncoherent_dma(struct kvm *kvm)
{
<blue>	return atomic_read(&kvm->arch.noncoherent_dma_count);</blue>
}
EXPORT_SYMBOL_GPL(kvm_arch_has_noncoherent_dma);

bool kvm_arch_has_irq_bypass(void)
{
	return true;
<yellow>}</yellow>

int kvm_arch_irq_bypass_add_producer(struct irq_bypass_consumer *cons,
				      struct irq_bypass_producer *prod)
{
	struct kvm_kernel_irqfd *irqfd =
		container_of(cons, struct kvm_kernel_irqfd, consumer);
	int ret;

<yellow>	irqfd->producer = prod;</yellow>
<yellow>	kvm_arch_start_assignment(irqfd->kvm);</yellow>
	ret = static_call(kvm_x86_pi_update_irte)(irqfd-&gt;kvm,
<yellow>					 prod->irq, irqfd->gsi, 1);</yellow>

	if (ret)
<yellow>		kvm_arch_end_assignment(irqfd->kvm);</yellow>

	return ret;
<yellow>}</yellow>

void kvm_arch_irq_bypass_del_producer(struct irq_bypass_consumer *cons,
				      struct irq_bypass_producer *prod)
{
	int ret;
	struct kvm_kernel_irqfd *irqfd =
		container_of(cons, struct kvm_kernel_irqfd, consumer);

<yellow>	WARN_ON(irqfd->producer != prod);</yellow>
<yellow>	irqfd->producer = NULL;</yellow>

	/*
	 * When producer of consumer is unregistered, we change back to
	 * remapped mode, so we can re-use the current implementation
	 * when the irq is masked/disabled or the consumer side (KVM
	 * int this case doesn&#x27;t want to receive the interrupts.
	*/
	ret = static_call(kvm_x86_pi_update_irte)(irqfd-&gt;kvm, prod-&gt;irq, irqfd-&gt;gsi, 0);
	if (ret)
		printk(KERN_INFO &quot;irq bypass consumer (token %p) unregistration&quot;
		       &quot; fails: %d\n&quot;, irqfd-&gt;consumer.token, ret);

<yellow>	kvm_arch_end_assignment(irqfd->kvm);</yellow>
}

int kvm_arch_update_irqfd_routing(struct kvm *kvm, unsigned int host_irq,
				   uint32_t guest_irq, bool set)
{
<yellow>	return static_call(kvm_x86_pi_update_irte)(kvm, host_irq, guest_irq, set);</yellow>
}

bool kvm_arch_irqfd_route_changed(struct kvm_kernel_irq_routing_entry *old,
				  struct kvm_kernel_irq_routing_entry *new)
{
<yellow>	if (new->type != KVM_IRQ_ROUTING_MSI)</yellow>
		return true;

<yellow>	return !!memcmp(&old->msi, &new->msi, sizeof(new->msi));</yellow>
<yellow>}</yellow>

bool kvm_vector_hashing_enabled(void)
{
<yellow>	return vector_hashing;</yellow>
}

bool kvm_arch_no_poll(struct kvm_vcpu *vcpu)
{
<blue>	return (vcpu->arch.msr_kvm_poll_control & 1) == 0;</blue>
}
EXPORT_SYMBOL_GPL(kvm_arch_no_poll);


int kvm_spec_ctrl_test_value(u64 value)
<blue>{</blue>
	/*
	 * test that setting IA32_SPEC_CTRL to given value
	 * is allowed by the host processor
	 */

	u64 saved_value;
	unsigned long flags;
	int ret = 0;

<blue>	local_irq_save(flags);</blue>

<blue>	if (rdmsrl_safe(MSR_IA32_SPEC_CTRL, &saved_value))</blue>
		ret = 1;
<blue>	else if (wrmsrl_safe(MSR_IA32_SPEC_CTRL, value))</blue>
		ret = 1;
	else
<blue>		wrmsrl(MSR_IA32_SPEC_CTRL, saved_value);</blue>

<blue>	local_irq_restore(flags);</blue>

	return ret;
}
EXPORT_SYMBOL_GPL(kvm_spec_ctrl_test_value);

void kvm_fixup_and_inject_pf_error(struct kvm_vcpu *vcpu, gva_t gva, u16 error_code)
{
<yellow>	struct kvm_mmu *mmu = vcpu->arch.walk_mmu;</yellow>
	struct x86_exception fault;
	u64 access = error_code &amp;
		(PFERR_WRITE_MASK | PFERR_FETCH_MASK | PFERR_USER_MASK);

	if (!(error_code &amp; PFERR_PRESENT_MASK) ||
<yellow>	    mmu->gva_to_gpa(vcpu, mmu, gva, access, &fault) != INVALID_GPA) {</yellow>
		/*
		 * If vcpu-&gt;arch.walk_mmu-&gt;gva_to_gpa succeeded, the page
		 * tables probably do not match the TLB.  Just proceed
		 * with the error code that the processor gave.
		 */
<yellow>		fault.vector = PF_VECTOR;</yellow>
		fault.error_code_valid = true;
		fault.error_code = error_code;
		fault.nested_page_fault = false;
		fault.address = gva;
		fault.async_page_fault = false;
	}
<yellow>	vcpu->arch.walk_mmu->inject_page_fault(vcpu, &fault);</yellow>
}
EXPORT_SYMBOL_GPL(kvm_fixup_and_inject_pf_error);

/*
 * Handles kvm_read/write_guest_virt*() result and either injects #PF or returns
 * KVM_EXIT_INTERNAL_ERROR for cases not currently handled by KVM. Return value
 * indicates whether exit to userspace is needed.
 */
<yellow>int kvm_handle_memory_failure(struct kvm_vcpu *vcpu, int r,</yellow>
			      struct x86_exception *e)
{
<yellow>	if (r == X86EMUL_PROPAGATE_FAULT) {</yellow>
<yellow>		if (KVM_BUG_ON(!e, vcpu->kvm))</yellow>
			return -EIO;

<yellow>		kvm_inject_emulated_page_fault(vcpu, e);</yellow>
		return 1;
	}

	/*
	 * In case kvm_read/write_guest_virt*() failed with X86EMUL_IO_NEEDED
	 * while handling a VMX instruction KVM could&#x27;ve handled the request
	 * correctly by exiting to userspace and performing I/O but there
	 * doesn&#x27;t seem to be a real use-case behind such requests, just return
	 * KVM_EXIT_INTERNAL_ERROR for now.
	 */
<yellow>	kvm_prepare_emulation_failure_exit(vcpu);</yellow>

	return 0;
<yellow>}</yellow>
EXPORT_SYMBOL_GPL(kvm_handle_memory_failure);

int kvm_handle_invpcid(struct kvm_vcpu *vcpu, unsigned long type, gva_t gva)
<blue>{</blue>
	bool pcid_enabled;
	struct x86_exception e;
	struct {
		u64 pcid;
		u64 gla;
	} operand;
	int r;

<blue>	r = kvm_read_guest_virt(vcpu, gva, &operand, sizeof(operand), &e);</blue>
	if (r != X86EMUL_CONTINUE)
<yellow>		return kvm_handle_memory_failure(vcpu, r, &e);</yellow>

<blue>	if (operand.pcid >> 12 != 0) {</blue>
		kvm_inject_gp(vcpu, 0);
		return 1;
	}

<blue>	pcid_enabled = kvm_read_cr4_bits(vcpu, X86_CR4_PCIDE);</blue>

	switch (type) {
	case INVPCID_TYPE_INDIV_ADDR:
<blue>		if ((!pcid_enabled && (operand.pcid != 0)) ||</blue>
<blue>		    is_noncanonical_address(operand.gla, vcpu)) {</blue>
			kvm_inject_gp(vcpu, 0);
			return 1;
		}
<blue>		kvm_mmu_invpcid_gva(vcpu, operand.gla, operand.pcid);</blue>
		return kvm_skip_emulated_instruction(vcpu);

	case INVPCID_TYPE_SINGLE_CTXT:
<yellow>		if (!pcid_enabled && (operand.pcid != 0)) {</yellow>
			kvm_inject_gp(vcpu, 0);
			return 1;
		}

<yellow>		kvm_invalidate_pcid(vcpu, operand.pcid);</yellow>
		return kvm_skip_emulated_instruction(vcpu);

	case INVPCID_TYPE_ALL_NON_GLOBAL:
		/*
		 * Currently, KVM doesn&#x27;t mark global entries in the shadow
		 * page tables, so a non-global flush just degenerates to a
		 * global flush. If needed, we could optimize this later by
		 * keeping track of global entries in shadow page tables.
		 */

		fallthrough;
	case INVPCID_TYPE_ALL_INCL_GLOBAL:
<yellow>		kvm_make_request(KVM_REQ_TLB_FLUSH_GUEST, vcpu);</yellow>
<blue>		return kvm_skip_emulated_instruction(vcpu);</blue>

	default:
<yellow>		kvm_inject_gp(vcpu, 0);</yellow>
		return 1;
	}
}
EXPORT_SYMBOL_GPL(kvm_handle_invpcid);

static int complete_sev_es_emulated_mmio(struct kvm_vcpu *vcpu)
{
<yellow>	struct kvm_run *run = vcpu->run;</yellow>
	struct kvm_mmio_fragment *frag;
	unsigned int len;

<yellow>	BUG_ON(!vcpu->mmio_needed);</yellow>

	/* Complete previous fragment */
<yellow>	frag = &vcpu->mmio_fragments[vcpu->mmio_cur_fragment];</yellow>
	len = min(8u, frag-&gt;len);
	if (!vcpu-&gt;mmio_is_write)
<yellow>		memcpy(frag->data, run->mmio.data, len);</yellow>

<yellow>	if (frag->len <= 8) {</yellow>
		/* Switch to the next fragment. */
		frag++;
<yellow>		vcpu->mmio_cur_fragment++;</yellow>
	} else {
		/* Go forward to the next mmio piece. */
<yellow>		frag->data += len;</yellow>
		frag-&gt;gpa += len;
		frag-&gt;len -= len;
	}

<yellow>	if (vcpu->mmio_cur_fragment >= vcpu->mmio_nr_fragments) {</yellow>
<yellow>		vcpu->mmio_needed = 0;</yellow>

		// VMG change, at this point, we&#x27;re always done
		// RIP has already been advanced
		return 1;
	}

	// More MMIO is needed
<yellow>	run->mmio.phys_addr = frag->gpa;</yellow>
	run-&gt;mmio.len = min(8u, frag-&gt;len);
	run-&gt;mmio.is_write = vcpu-&gt;mmio_is_write;
	if (run-&gt;mmio.is_write)
<yellow>		memcpy(run->mmio.data, frag->data, min(8u, frag->len));</yellow>
<yellow>	run->exit_reason = KVM_EXIT_MMIO;</yellow>

	vcpu-&gt;arch.complete_userspace_io = complete_sev_es_emulated_mmio;

	return 0;
<yellow>}</yellow>

int kvm_sev_es_mmio_write(struct kvm_vcpu *vcpu, gpa_t gpa, unsigned int bytes,
			  void *data)
{
	int handled;
	struct kvm_mmio_fragment *frag;

<yellow>	if (!data)</yellow>
		return -EINVAL;

<yellow>	handled = write_emultor.read_write_mmio(vcpu, gpa, bytes, data);</yellow>
	if (handled == bytes)
		return 1;

	bytes -= handled;
	gpa += handled;
	data += handled;

	/*TODO: Check if need to increment number of frags */
	frag = vcpu-&gt;mmio_fragments;
<yellow>	vcpu->mmio_nr_fragments = 1;</yellow>
	frag-&gt;len = bytes;
	frag-&gt;gpa = gpa;
	frag-&gt;data = data;

	vcpu-&gt;mmio_needed = 1;
	vcpu-&gt;mmio_cur_fragment = 0;

	vcpu-&gt;run-&gt;mmio.phys_addr = gpa;
	vcpu-&gt;run-&gt;mmio.len = min(8u, frag-&gt;len);
	vcpu-&gt;run-&gt;mmio.is_write = 1;
	memcpy(vcpu-&gt;run-&gt;mmio.data, frag-&gt;data, min(8u, frag-&gt;len));
	vcpu-&gt;run-&gt;exit_reason = KVM_EXIT_MMIO;

	vcpu-&gt;arch.complete_userspace_io = complete_sev_es_emulated_mmio;

	return 0;
<yellow>}</yellow>
EXPORT_SYMBOL_GPL(kvm_sev_es_mmio_write);

int kvm_sev_es_mmio_read(struct kvm_vcpu *vcpu, gpa_t gpa, unsigned int bytes,
			 void *data)
{
	int handled;
	struct kvm_mmio_fragment *frag;

<yellow>	if (!data)</yellow>
		return -EINVAL;

<yellow>	handled = read_emultor.read_write_mmio(vcpu, gpa, bytes, data);</yellow>
	if (handled == bytes)
		return 1;

	bytes -= handled;
	gpa += handled;
	data += handled;

	/*TODO: Check if need to increment number of frags */
	frag = vcpu-&gt;mmio_fragments;
<yellow>	vcpu->mmio_nr_fragments = 1;</yellow>
	frag-&gt;len = bytes;
	frag-&gt;gpa = gpa;
	frag-&gt;data = data;

	vcpu-&gt;mmio_needed = 1;
	vcpu-&gt;mmio_cur_fragment = 0;

	vcpu-&gt;run-&gt;mmio.phys_addr = gpa;
	vcpu-&gt;run-&gt;mmio.len = min(8u, frag-&gt;len);
	vcpu-&gt;run-&gt;mmio.is_write = 0;
	vcpu-&gt;run-&gt;exit_reason = KVM_EXIT_MMIO;

	vcpu-&gt;arch.complete_userspace_io = complete_sev_es_emulated_mmio;

	return 0;
<yellow>}</yellow>
EXPORT_SYMBOL_GPL(kvm_sev_es_mmio_read);

static void advance_sev_es_emulated_pio(struct kvm_vcpu *vcpu, unsigned count, int size)
{
<yellow>	vcpu->arch.sev_pio_count -= count;</yellow>
	vcpu-&gt;arch.sev_pio_data += count * size;
}

static int kvm_sev_es_outs(struct kvm_vcpu *vcpu, unsigned int size,
			   unsigned int port);

static int complete_sev_es_emulated_outs(struct kvm_vcpu *vcpu)
{
<yellow>	int size = vcpu->arch.pio.size;</yellow>
	int port = vcpu-&gt;arch.pio.port;

<yellow>	vcpu->arch.pio.count = 0;</yellow>
	if (vcpu-&gt;arch.sev_pio_count)
<yellow>		return kvm_sev_es_outs(vcpu, size, port);</yellow>
	return 1;
<yellow>}</yellow>

static int kvm_sev_es_outs(struct kvm_vcpu *vcpu, unsigned int size,
			   unsigned int port)
{
	for (;;) {
		unsigned int count =
<yellow>			min_t(unsigned int, PAGE_SIZE / size, vcpu->arch.sev_pio_count);</yellow>
<yellow>		int ret = emulator_pio_out(vcpu, size, port, vcpu->arch.sev_pio_data, count);</yellow>

		/* memcpy done already by emulator_pio_out.  */
		advance_sev_es_emulated_pio(vcpu, count, size);
		if (!ret)
			break;

		/* Emulation done by the kernel.  */
<yellow>		if (!vcpu->arch.sev_pio_count)</yellow>
			return 1;
	}

<yellow>	vcpu->arch.complete_userspace_io = complete_sev_es_emulated_outs;</yellow>
<yellow>	return 0;</yellow>
}

static int kvm_sev_es_ins(struct kvm_vcpu *vcpu, unsigned int size,
			  unsigned int port);

static int complete_sev_es_emulated_ins(struct kvm_vcpu *vcpu)
{
<yellow>	unsigned count = vcpu->arch.pio.count;</yellow>
	int size = vcpu-&gt;arch.pio.size;
	int port = vcpu-&gt;arch.pio.port;

	complete_emulator_pio_in(vcpu, vcpu-&gt;arch.sev_pio_data);
	advance_sev_es_emulated_pio(vcpu, count, size);
	if (vcpu-&gt;arch.sev_pio_count)
<yellow>		return kvm_sev_es_ins(vcpu, size, port);</yellow>
	return 1;
<yellow>}</yellow>

static int kvm_sev_es_ins(struct kvm_vcpu *vcpu, unsigned int size,
			  unsigned int port)
{
	for (;;) {
		unsigned int count =
<yellow>			min_t(unsigned int, PAGE_SIZE / size, vcpu->arch.sev_pio_count);</yellow>
<yellow>		if (!emulator_pio_in(vcpu, size, port, vcpu->arch.sev_pio_data, count))</yellow>
			break;

		/* Emulation done by the kernel.  */
<yellow>		advance_sev_es_emulated_pio(vcpu, count, size);</yellow>
		if (!vcpu-&gt;arch.sev_pio_count)
			return 1;
	}

<yellow>	vcpu->arch.complete_userspace_io = complete_sev_es_emulated_ins;</yellow>
	return 0;
<yellow>}</yellow>

int kvm_sev_es_string_io(struct kvm_vcpu *vcpu, unsigned int size,
			 unsigned int port, void *data,  unsigned int count,
			 int in)
{
<yellow>	vcpu->arch.sev_pio_data = data;</yellow>
	vcpu-&gt;arch.sev_pio_count = count;
<yellow>	return in ? kvm_sev_es_ins(vcpu, size, port)</yellow>
<yellow>		  : kvm_sev_es_outs(vcpu, size, port);</yellow>
<yellow>}</yellow>
EXPORT_SYMBOL_GPL(kvm_sev_es_string_io);

EXPORT_TRACEPOINT_SYMBOL_GPL(kvm_entry);
EXPORT_TRACEPOINT_SYMBOL_GPL(kvm_exit);
EXPORT_TRACEPOINT_SYMBOL_GPL(kvm_fast_mmio);
EXPORT_TRACEPOINT_SYMBOL_GPL(kvm_inj_virq);
EXPORT_TRACEPOINT_SYMBOL_GPL(kvm_page_fault);
EXPORT_TRACEPOINT_SYMBOL_GPL(kvm_msr);
EXPORT_TRACEPOINT_SYMBOL_GPL(kvm_cr);
EXPORT_TRACEPOINT_SYMBOL_GPL(kvm_nested_vmenter);
EXPORT_TRACEPOINT_SYMBOL_GPL(kvm_nested_vmexit);
EXPORT_TRACEPOINT_SYMBOL_GPL(kvm_nested_vmexit_inject);
EXPORT_TRACEPOINT_SYMBOL_GPL(kvm_nested_intr_vmexit);
EXPORT_TRACEPOINT_SYMBOL_GPL(kvm_nested_vmenter_failed);
EXPORT_TRACEPOINT_SYMBOL_GPL(kvm_invlpga);
EXPORT_TRACEPOINT_SYMBOL_GPL(kvm_skinit);
EXPORT_TRACEPOINT_SYMBOL_GPL(kvm_nested_intercepts);
EXPORT_TRACEPOINT_SYMBOL_GPL(kvm_write_tsc_offset);
EXPORT_TRACEPOINT_SYMBOL_GPL(kvm_ple_window_update);
EXPORT_TRACEPOINT_SYMBOL_GPL(kvm_pml_full);
EXPORT_TRACEPOINT_SYMBOL_GPL(kvm_pi_irte_update);
EXPORT_TRACEPOINT_SYMBOL_GPL(kvm_avic_unaccelerated_access);
EXPORT_TRACEPOINT_SYMBOL_GPL(kvm_avic_incomplete_ipi);
EXPORT_TRACEPOINT_SYMBOL_GPL(kvm_avic_ga_log);
EXPORT_TRACEPOINT_SYMBOL_GPL(kvm_avic_kick_vcpu_slowpath);
EXPORT_TRACEPOINT_SYMBOL_GPL(kvm_avic_doorbell);
EXPORT_TRACEPOINT_SYMBOL_GPL(kvm_apicv_accept_irq);
EXPORT_TRACEPOINT_SYMBOL_GPL(kvm_vmgexit_enter);
EXPORT_TRACEPOINT_SYMBOL_GPL(kvm_vmgexit_exit);
EXPORT_TRACEPOINT_SYMBOL_GPL(kvm_vmgexit_msr_protocol_enter);
EXPORT_TRACEPOINT_SYMBOL_GPL(kvm_vmgexit_msr_protocol_exit);

static int __init kvm_x86_init(void)
{
	kvm_mmu_x86_module_init();
	mitigate_smt_rsb &amp;= boot_cpu_has_bug(X86_BUG_SMT_RSB) &amp;&amp; cpu_smt_possible();
	return 0;
}
module_init(kvm_x86_init);

static void __exit kvm_x86_exit(void)
{
	/*
	 * If module_init() is implemented, module_exit() must also be
	 * implemented to allow module unload.
	 */
}
module_exit(kvm_x86_exit);


</code></pre></td></tr></table>
</div><script>const fileList = document.getElementById('file_list')
fileList.innerHTML+=`<li><a href="/kvm_coverage/coverage/linux/arch/x86/kvm/mmu/mmu.c.html">mmu.c 48.3%</li>`
fileList.innerHTML+=`<li><a href="/kvm_coverage/coverage/linux/arch/x86/kvm/vmx/nested.c.html">nested.c 81.0%</li>`
fileList.innerHTML+=`<li><a href="/kvm_coverage/coverage/linux/arch/x86/kvm/vmx/vmx.c.html">vmx.c 57.3%</li>`
fileList.innerHTML+=`<li><a href="/kvm_coverage/coverage/linux/arch/x86/kvm/x86.c.html">x86.c 50.8%</li>`
</script></body></html>