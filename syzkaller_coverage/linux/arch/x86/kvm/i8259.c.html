<doctype html>
<html lang="ja">
<head>
<meta charset="utf-8">
<script src="https://cdn.rawgit.com/google/code-prettify/master/loader/run_prettify.js"></script>
<style>
    code{
        font-family:Monaco, Menlo, Consolas, 'Courier New', Courier, monospace, sans-serif;
        font-size: 14px;
        line-height: 18px;
        overflow: auto;
        resize: horizontal;
    }
    code_line{
        font-family: Monaco, Menlo, Consolas, 'Courier New', Courier, monospace, sans-serif;;
        font-size: 14px;
        line-height: 18px;
        overflow: auto;
        resize: horizontal;
        color:#303134;
    }
    blue{
        background-color:#BEEDE8;
    }
    yellow{
        background-color:#FFFF99;
    }
    red{
        background-color:#FF99AC;
    }
</style>

</head>
<body>
<table summary='blob content' class='blob' cellspacing="15">
<tr><td align="right"><pre><code_line>1.<br>2.<br>3.<br>4.<br>5.<br>6.<br>7.<br>8.<br>9.<br>10.<br>11.<br>12.<br>13.<br>14.<br>15.<br>16.<br>17.<br>18.<br>19.<br>20.<br>21.<br>22.<br>23.<br>24.<br>25.<br>26.<br>27.<br>28.<br>29.<br>30.<br>31.<br>32.<br>33.<br>34.<br>35.<br>36.<br>37.<br>38.<br>39.<br>40.<br>41.<br>42.<br>43.<br>44.<br>45.<br>46.<br>47.<br>48.<br>49.<br>50.<br>51.<br>52.<br>53.<br>54.<br>55.<br>56.<br>57.<br>58.<br>59.<br>60.<br>61.<br>62.<br>63.<br>64.<br>65.<br>66.<br>67.<br>68.<br>69.<br>70.<br>71.<br>72.<br>73.<br>74.<br>75.<br>76.<br>77.<br>78.<br>79.<br>80.<br>81.<br>82.<br>83.<br>84.<br>85.<br>86.<br>87.<br>88.<br>89.<br>90.<br>91.<br>92.<br>93.<br>94.<br>95.<br>96.<br>97.<br>98.<br>99.<br>100.<br>101.<br>102.<br>103.<br>104.<br>105.<br>106.<br>107.<br>108.<br>109.<br>110.<br>111.<br>112.<br>113.<br>114.<br>115.<br>116.<br>117.<br>118.<br>119.<br>120.<br>121.<br>122.<br>123.<br>124.<br>125.<br>126.<br>127.<br>128.<br>129.<br>130.<br>131.<br>132.<br>133.<br>134.<br>135.<br>136.<br>137.<br>138.<br>139.<br>140.<br>141.<br>142.<br>143.<br>144.<br>145.<br>146.<br>147.<br>148.<br>149.<br>150.<br>151.<br>152.<br>153.<br>154.<br>155.<br>156.<br>157.<br>158.<br>159.<br>160.<br>161.<br>162.<br>163.<br>164.<br>165.<br>166.<br>167.<br>168.<br>169.<br>170.<br>171.<br>172.<br>173.<br>174.<br>175.<br>176.<br>177.<br>178.<br>179.<br>180.<br>181.<br>182.<br>183.<br>184.<br>185.<br>186.<br>187.<br>188.<br>189.<br>190.<br>191.<br>192.<br>193.<br>194.<br>195.<br>196.<br>197.<br>198.<br>199.<br>200.<br>201.<br>202.<br>203.<br>204.<br>205.<br>206.<br>207.<br>208.<br>209.<br>210.<br>211.<br>212.<br>213.<br>214.<br>215.<br>216.<br>217.<br>218.<br>219.<br>220.<br>221.<br>222.<br>223.<br>224.<br>225.<br>226.<br>227.<br>228.<br>229.<br>230.<br>231.<br>232.<br>233.<br>234.<br>235.<br>236.<br>237.<br>238.<br>239.<br>240.<br>241.<br>242.<br>243.<br>244.<br>245.<br>246.<br>247.<br>248.<br>249.<br>250.<br>251.<br>252.<br>253.<br>254.<br>255.<br>256.<br>257.<br>258.<br>259.<br>260.<br>261.<br>262.<br>263.<br>264.<br>265.<br>266.<br>267.<br>268.<br>269.<br>270.<br>271.<br>272.<br>273.<br>274.<br>275.<br>276.<br>277.<br>278.<br>279.<br>280.<br>281.<br>282.<br>283.<br>284.<br>285.<br>286.<br>287.<br>288.<br>289.<br>290.<br>291.<br>292.<br>293.<br>294.<br>295.<br>296.<br>297.<br>298.<br>299.<br>300.<br>301.<br>302.<br>303.<br>304.<br>305.<br>306.<br>307.<br>308.<br>309.<br>310.<br>311.<br>312.<br>313.<br>314.<br>315.<br>316.<br>317.<br>318.<br>319.<br>320.<br>321.<br>322.<br>323.<br>324.<br>325.<br>326.<br>327.<br>328.<br>329.<br>330.<br>331.<br>332.<br>333.<br>334.<br>335.<br>336.<br>337.<br>338.<br>339.<br>340.<br>341.<br>342.<br>343.<br>344.<br>345.<br>346.<br>347.<br>348.<br>349.<br>350.<br>351.<br>352.<br>353.<br>354.<br>355.<br>356.<br>357.<br>358.<br>359.<br>360.<br>361.<br>362.<br>363.<br>364.<br>365.<br>366.<br>367.<br>368.<br>369.<br>370.<br>371.<br>372.<br>373.<br>374.<br>375.<br>376.<br>377.<br>378.<br>379.<br>380.<br>381.<br>382.<br>383.<br>384.<br>385.<br>386.<br>387.<br>388.<br>389.<br>390.<br>391.<br>392.<br>393.<br>394.<br>395.<br>396.<br>397.<br>398.<br>399.<br>400.<br>401.<br>402.<br>403.<br>404.<br>405.<br>406.<br>407.<br>408.<br>409.<br>410.<br>411.<br>412.<br>413.<br>414.<br>415.<br>416.<br>417.<br>418.<br>419.<br>420.<br>421.<br>422.<br>423.<br>424.<br>425.<br>426.<br>427.<br>428.<br>429.<br>430.<br>431.<br>432.<br>433.<br>434.<br>435.<br>436.<br>437.<br>438.<br>439.<br>440.<br>441.<br>442.<br>443.<br>444.<br>445.<br>446.<br>447.<br>448.<br>449.<br>450.<br>451.<br>452.<br>453.<br>454.<br>455.<br>456.<br>457.<br>458.<br>459.<br>460.<br>461.<br>462.<br>463.<br>464.<br>465.<br>466.<br>467.<br>468.<br>469.<br>470.<br>471.<br>472.<br>473.<br>474.<br>475.<br>476.<br>477.<br>478.<br>479.<br>480.<br>481.<br>482.<br>483.<br>484.<br>485.<br>486.<br>487.<br>488.<br>489.<br>490.<br>491.<br>492.<br>493.<br>494.<br>495.<br>496.<br>497.<br>498.<br>499.<br>500.<br>501.<br>502.<br>503.<br>504.<br>505.<br>506.<br>507.<br>508.<br>509.<br>510.<br>511.<br>512.<br>513.<br>514.<br>515.<br>516.<br>517.<br>518.<br>519.<br>520.<br>521.<br>522.<br>523.<br>524.<br>525.<br>526.<br>527.<br>528.<br>529.<br>530.<br>531.<br>532.<br>533.<br>534.<br>535.<br>536.<br>537.<br>538.<br>539.<br>540.<br>541.<br>542.<br>543.<br>544.<br>545.<br>546.<br>547.<br>548.<br>549.<br>550.<br>551.<br>552.<br>553.<br>554.<br>555.<br>556.<br>557.<br>558.<br>559.<br>560.<br>561.<br>562.<br>563.<br>564.<br>565.<br>566.<br>567.<br>568.<br>569.<br>570.<br>571.<br>572.<br>573.<br>574.<br>575.<br>576.<br>577.<br>578.<br>579.<br>580.<br>581.<br>582.<br>583.<br>584.<br>585.<br>586.<br>587.<br>588.<br>589.<br>590.<br>591.<br>592.<br>593.<br>594.<br>595.<br>596.<br>597.<br>598.<br>599.<br>600.<br>601.<br>602.<br>603.<br>604.<br>605.<br>606.<br>607.<br>608.<br>609.<br>610.<br>611.<br>612.<br>613.<br>614.<br>615.<br>616.<br>617.<br>618.<br>619.<br>620.<br>621.<br>622.<br>623.<br>624.<br>625.<br>626.<br>627.<br>628.<br>629.<br>630.<br>631.<br>632.<br>633.<br>634.<br>635.<br>636.<br>637.<br>638.<br>639.<br>640.<br>641.<br>642.<br>643.<br>644.<br>645.<br>646.<br>647.<br>648.<br>649.<br>650.<br>651.<br>652.<br>653.<br>654.<br>655.<br>656.<br></code_line></pre></td>
<td class='lines'><pre><code class="prettyprint">/*
 * 8259 interrupt controller emulation
 *
 * Copyright (c) 2003-2004 Fabrice Bellard
 * Copyright (c) 2007 Intel Corporation
 * Copyright 2009 Red Hat, Inc. and/or its affiliates.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the &quot;Software&quot;), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 * Authors:
 *   Yaozu (Eddie) Dong &lt;Eddie.dong@intel.com&gt;
 *   Port from Qemu.
 */
#include &lt;linux/mm.h&gt;
#include &lt;linux/slab.h&gt;
#include &lt;linux/bitops.h&gt;
#include &quot;irq.h&quot;

#include &lt;linux/kvm_host.h&gt;
#include &quot;trace.h&quot;

#define pr_pic_unimpl(fmt, ...)	\
	pr_err_ratelimited(&quot;kvm: pic: &quot; fmt, ## __VA_ARGS__)

static void pic_irq_request(struct kvm *kvm, int level);

static void pic_lock(struct kvm_pic *s)
	__acquires(&amp;s-&gt;lock)
{
<blue>	spin_lock(&s->lock);</blue>
}

static void pic_unlock(struct kvm_pic *s)
	__releases(&amp;s-&gt;lock)
<blue>{</blue>
<blue>	bool wakeup = s->wakeup_needed;</blue>
	struct kvm_vcpu *vcpu;
	unsigned long i;

<blue>	s->wakeup_needed = false;</blue>

	spin_unlock(&amp;s-&gt;lock);

	if (wakeup) {
<blue>		kvm_for_each_vcpu(i, vcpu, s->kvm) {</blue>
<blue>			if (kvm_apic_accept_pic_intr(vcpu)) {</blue>
<blue>				kvm_make_request(KVM_REQ_EVENT, vcpu);</blue>
				kvm_vcpu_kick(vcpu);
				return;
			}
		}
	}
}

static void pic_clear_isr(struct kvm_kpic_state *s, int irq)
{
<yellow>	s->isr &= ~(1 << irq);</yellow>
	if (s != &amp;s-&gt;pics_state-&gt;pics[0])
<yellow>		irq += 8;</yellow>
	/*
	 * We are dropping lock while calling ack notifiers since ack
	 * notifier callbacks for assigned devices call into PIC recursively.
	 * Other interrupt may be delivered to PIC while lock is dropped but
	 * it should be safe since PIC state is already updated at this stage.
	 */
<yellow>	pic_unlock(s->pics_state);</yellow>
	kvm_notify_acked_irq(s-&gt;pics_state-&gt;kvm, SELECT_PIC(irq), irq);
	pic_lock(s-&gt;pics_state);
}

/*
 * set irq level. If an edge is detected, then the IRR is set to 1
 */
static inline int pic_set_irq1(struct kvm_kpic_state *s, int irq, int level)
{
	int mask, ret = 1;
	mask = 1 &lt;&lt; irq;
<blue>	if (s->elcr & mask)	/* level triggered */</blue>
		if (level) {
<blue>			ret = !(s->irr & mask);</blue>
			s-&gt;irr |= mask;
<blue>			s->last_irr |= mask;</blue>
		} else {
<blue>			s->irr &= ~mask;</blue>
			s-&gt;last_irr &amp;= ~mask;
		}
	else	/* edge triggered */
		if (level) {
<blue>			if ((s->last_irr & mask) == 0) {</blue>
<blue>				ret = !(s->irr & mask);</blue>
				s-&gt;irr |= mask;
			}
<blue>			s->last_irr |= mask;</blue>
		} else
<blue>			s->last_irr &= ~mask;</blue>

	return (s-&gt;imr &amp; mask) ? -1 : ret;
}

/*
 * return the highest priority found in mask (highest = smallest
 * number). Return 8 if no irq
 */
<blue>static inline int get_priority(struct kvm_kpic_state *s, int mask)</blue>
{
	int priority;
<blue>	if (mask == 0)</blue>
		return 8;
	priority = 0;
<blue>	while ((mask & (1 << ((priority + s->priority_add) & 7))) == 0)</blue>
		priority++;
	return priority;
}

/*
 * return the pic wanted interrupt. return -1 if none
 */
static int pic_get_irq(struct kvm_kpic_state *s)
{
	int mask, cur_priority, priority;

<blue>	mask = s->irr & ~s->imr;</blue>
<blue>	priority = get_priority(s, mask);</blue>
<blue>	if (priority == 8)</blue>
		return -1;
	/*
	 * compute current priority. If special fully nested mode on the
	 * master, the IRQ coming from the slave is not taken into account
	 * for the priority computation.
	 */
<blue>	mask = s->isr;</blue>
<blue>	if (s->special_fully_nested_mode && s == &s->pics_state->pics[0])</blue>
<blue>		mask &= ~(1 << 2);</blue>
<blue>	cur_priority = get_priority(s, mask);</blue>
<blue>	if (priority < cur_priority)</blue>
		/*
		 * higher priority found: an irq should be generated
		 */
		return (priority + s-&gt;priority_add) &amp; 7;
	else
		return -1;
<blue>}</blue>

/*
 * raise irq to CPU if necessary. must be called every time the active
 * irq may change
 */
static void pic_update_irq(struct kvm_pic *s)
{
	int irq2, irq;

<blue>	irq2 = pic_get_irq(&s->pics[1]);</blue>
	if (irq2 &gt;= 0) {
		/*
		 * if irq request by slave pic, signal master PIC
		 */
<blue>		pic_set_irq1(&s->pics[0], 2, 1);</blue>
<blue>		pic_set_irq1(&s->pics[0], 2, 0);</blue>
	}
<blue>	irq = pic_get_irq(&s->pics[0]);</blue>
<blue>	pic_irq_request(s->kvm, irq >= 0);</blue>
}

void kvm_pic_update_irq(struct kvm_pic *s)
{
<blue>	pic_lock(s);</blue>
	pic_update_irq(s);
	pic_unlock(s);
}

int kvm_pic_set_irq(struct kvm_pic *s, int irq, int irq_source_id, int level)
{
	int ret, irq_level;

<blue>	BUG_ON(irq < 0 || irq >= PIC_NUM_PINS);</blue>

<blue>	pic_lock(s);</blue>
<blue>	irq_level = __kvm_irq_line_state(&s->irq_states[irq],</blue>
					 irq_source_id, level);
<blue>	ret = pic_set_irq1(&s->pics[irq >> 3], irq & 7, irq_level);</blue>
<blue>	pic_update_irq(s);</blue>
<blue>	trace_kvm_pic_set_irq(irq >> 3, irq & 7, s->pics[irq >> 3].elcr,</blue>
			      s-&gt;pics[irq &gt;&gt; 3].imr, ret == 0);
<blue>	pic_unlock(s);</blue>

	return ret;
}

void kvm_pic_clear_all(struct kvm_pic *s, int irq_source_id)
{
	int i;

<yellow>	pic_lock(s);</yellow>
	for (i = 0; i &lt; PIC_NUM_PINS; i++)
<yellow>		__clear_bit(irq_source_id, &s->irq_states[i]);</yellow>
<yellow>	pic_unlock(s);</yellow>
}

/*
 * acknowledge interrupt &#x27;irq&#x27;
 */
<yellow>static inline void pic_intack(struct kvm_kpic_state *s, int irq)</yellow>
{
<yellow>	s->isr |= 1 << irq;</yellow>
	/*
	 * We don&#x27;t clear a level sensitive interrupt here
	 */
	if (!(s-&gt;elcr &amp; (1 &lt;&lt; irq)))
<yellow>		s->irr &= ~(1 << irq);</yellow>

<yellow>	if (s->auto_eoi) {</yellow>
<yellow>		if (s->rotate_on_auto_eoi)</yellow>
<yellow>			s->priority_add = (irq + 1) & 7;</yellow>
<yellow>		pic_clear_isr(s, irq);</yellow>
	}

}

int kvm_pic_read_irq(struct kvm *kvm)
{
	int irq, irq2, intno;
<yellow>	struct kvm_pic *s = kvm->arch.vpic;</yellow>

	s-&gt;output = 0;

	pic_lock(s);
	irq = pic_get_irq(&amp;s-&gt;pics[0]);
	if (irq &gt;= 0) {
<yellow>		pic_intack(&s->pics[0], irq);</yellow>
<yellow>		if (irq == 2) {</yellow>
<yellow>			irq2 = pic_get_irq(&s->pics[1]);</yellow>
			if (irq2 &gt;= 0)
<yellow>				pic_intack(&s->pics[1], irq2);</yellow>
			else
				/*
				 * spurious IRQ on slave controller
				 */
				irq2 = 7;
<yellow>			intno = s->pics[1].irq_base + irq2;</yellow>
		} else
<yellow>			intno = s->pics[0].irq_base + irq;</yellow>
	} else {
		/*
		 * spurious IRQ on host controller
		 */
		irq = 7;
<yellow>		intno = s->pics[0].irq_base + irq;</yellow>
	}
<yellow>	pic_update_irq(s);</yellow>
	pic_unlock(s);

	return intno;
}

static void kvm_pic_reset(struct kvm_kpic_state *s)
{
	int irq;
	unsigned long i;
	struct kvm_vcpu *vcpu;
<yellow>	u8 edge_irr = s->irr & ~s->elcr;</yellow>
	bool found = false;

	s-&gt;last_irr = 0;
	s-&gt;irr &amp;= s-&gt;elcr;
	s-&gt;imr = 0;
	s-&gt;priority_add = 0;
	s-&gt;special_mask = 0;
	s-&gt;read_reg_select = 0;
	if (!s-&gt;init4) {
<yellow>		s->special_fully_nested_mode = 0;</yellow>
		s-&gt;auto_eoi = 0;
	}
<yellow>	s->init_state = 1;</yellow>

<yellow>	kvm_for_each_vcpu(i, vcpu, s->pics_state->kvm)</yellow>
<yellow>		if (kvm_apic_accept_pic_intr(vcpu)) {</yellow>
			found = true;
			break;
		}


	if (!found)
		return;

<yellow>	for (irq = 0; irq < PIC_NUM_PINS/2; irq++)</yellow>
<yellow>		if (edge_irr & (1 << irq))</yellow>
<yellow>			pic_clear_isr(s, irq);</yellow>
}

static void pic_ioport_write(void *opaque, u32 addr, u32 val)
<blue>{</blue>
	struct kvm_kpic_state *s = opaque;
	int priority, cmd, irq;

	addr &amp;= 1;
<blue>	if (addr == 0) {</blue>
<blue>		if (val & 0x10) {</blue>
<yellow>			s->init4 = val & 1;</yellow>
			if (val &amp; 0x02)
<yellow>				pr_pic_unimpl("single mode not supported");</yellow>
<yellow>			if (val & 0x08)</yellow>
<yellow>				pr_pic_unimpl(</yellow>
						&quot;level sensitive irq not supported&quot;);
<yellow>			kvm_pic_reset(s);</yellow>
<blue>		} else if (val & 0x08) {</blue>
<blue>			if (val & 0x04)</blue>
<blue>				s->poll = 1;</blue>
<blue>			if (val & 0x02)</blue>
<yellow>				s->read_reg_select = val & 1;</yellow>
<blue>			if (val & 0x40)</blue>
<yellow>				s->special_mask = (val >> 5) & 1;</yellow>
		} else {
<yellow>			cmd = val >> 5;</yellow>
			switch (cmd) {
			case 0:
			case 4:
<yellow>				s->rotate_on_auto_eoi = cmd >> 2;</yellow>
				break;
			case 1:	/* end of interrupt */
			case 5:
<yellow>				priority = get_priority(s, s->isr);</yellow>
<yellow>				if (priority != 8) {</yellow>
					irq = (priority + s-&gt;priority_add) &amp; 7;
<yellow>					if (cmd == 5)</yellow>
<yellow>						s->priority_add = (irq + 1) & 7;</yellow>
<yellow>					pic_clear_isr(s, irq);</yellow>
					pic_update_irq(s-&gt;pics_state);
				}
				break;
			case 3:
<yellow>				irq = val & 7;</yellow>
				pic_clear_isr(s, irq);
				pic_update_irq(s-&gt;pics_state);
				break;
			case 6:
<yellow>				s->priority_add = (val + 1) & 7;</yellow>
				pic_update_irq(s-&gt;pics_state);
				break;
			case 7:
				irq = val &amp; 7;
<yellow>				s->priority_add = (irq + 1) & 7;</yellow>
				pic_clear_isr(s, irq);
				pic_update_irq(s-&gt;pics_state);
<yellow>				break;</yellow>
			default:
				break;	/* no operation */
			}
		}
	} else
<blue>		switch (s->init_state) {</blue>
		case 0: { /* normal mode */
<blue>			u8 imr_diff = s->imr ^ val,</blue>
				off = (s == &amp;s-&gt;pics_state-&gt;pics[0]) ? 0 : 8;
			s-&gt;imr = val;
<blue>			for (irq = 0; irq < PIC_NUM_PINS/2; irq++)</blue>
<blue>				if (imr_diff & (1 << irq))</blue>
					kvm_fire_mask_notifiers(
						s-&gt;pics_state-&gt;kvm,
						SELECT_PIC(irq + off),
						irq + off,
<blue>						!!(s->imr & (1 << irq)));</blue>
<blue>			pic_update_irq(s->pics_state);</blue>
			break;
		}
		case 1:
<yellow>			s->irq_base = val & 0xf8;</yellow>
			s-&gt;init_state = 2;
			break;
		case 2:
<yellow>			if (s->init4)</yellow>
<yellow>				s->init_state = 3;</yellow>
			else
<yellow>				s->init_state = 0;</yellow>
			break;
		case 3:
<yellow>			s->special_fully_nested_mode = (val >> 4) & 1;</yellow>
			s-&gt;auto_eoi = (val &gt;&gt; 1) &amp; 1;
			s-&gt;init_state = 0;
			break;
		}
}

static u32 pic_poll_read(struct kvm_kpic_state *s, u32 addr1)
{
	int ret;

	ret = pic_get_irq(s);
	if (ret &gt;= 0) {
		if (addr1 &gt;&gt; 7) {
<yellow>			s->pics_state->pics[0].isr &= ~(1 << 2);</yellow>
			s-&gt;pics_state-&gt;pics[0].irr &amp;= ~(1 &lt;&lt; 2);
		}
<yellow>		s->irr &= ~(1 << ret);</yellow>
		pic_clear_isr(s, ret);
		if (addr1 &gt;&gt; 7 || ret != 2)
<yellow>			pic_update_irq(s->pics_state);</yellow>
	} else {
		ret = 0x07;
<yellow>		pic_update_irq(s->pics_state);</yellow>
	}

	return ret;
}

static u32 pic_ioport_read(void *opaque, u32 addr)
{
	struct kvm_kpic_state *s = opaque;
	int ret;

	if (s-&gt;poll) {
<yellow>		ret = pic_poll_read(s, addr);</yellow>
<yellow>		s->poll = 0;</yellow>
	} else
<blue>		if ((addr & 1) == 0)</blue>
<blue>			if (s->read_reg_select)</blue>
<yellow>				ret = s->isr;</yellow>
			else
<blue>				ret = s->irr;</blue>
		else
<blue>			ret = s->imr;</blue>
	return ret;
}

static void elcr_ioport_write(void *opaque, u32 val)
{
	struct kvm_kpic_state *s = opaque;
	s-&gt;elcr = val &amp; s-&gt;elcr_mask;
}

static u32 elcr_ioport_read(void *opaque)
{
	struct kvm_kpic_state *s = opaque;
	return s-&gt;elcr;
}

static int picdev_write(struct kvm_pic *s,
			 gpa_t addr, int len, const void *val)
{
<blue>	unsigned char data = *(unsigned char *)val;</blue>

	if (len != 1) {
<blue>		pr_pic_unimpl("non byte write\n");</blue>
		return 0;
	}
<blue>	switch (addr) {</blue>
	case 0x20:
	case 0x21:
<yellow>		pic_lock(s);</yellow>
		pic_ioport_write(&amp;s-&gt;pics[0], addr, data);
		pic_unlock(s);
		break;
	case 0xa0:
	case 0xa1:
<blue>		pic_lock(s);</blue>
		pic_ioport_write(&amp;s-&gt;pics[1], addr, data);
		pic_unlock(s);
		break;
	case 0x4d0:
	case 0x4d1:
		pic_lock(s);
<yellow>		elcr_ioport_write(&s->pics[addr & 1], data);</yellow>
		pic_unlock(s);
		break;
	default:
		return -EOPNOTSUPP;
	}
	return 0;
<blue>}</blue>

static int picdev_read(struct kvm_pic *s,
		       gpa_t addr, int len, void *val)
{
	unsigned char *data = (unsigned char *)val;

<blue>	if (len != 1) {</blue>
<blue>		memset(val, 0, len);</blue>
<blue>		pr_pic_unimpl("non byte read\n");</blue>
		return 0;
	}
<blue>	switch (addr) {</blue>
	case 0x20:
	case 0x21:
	case 0xa0:
	case 0xa1:
		pic_lock(s);
<blue>		*data = pic_ioport_read(&s->pics[addr >> 7], addr);</blue>
		pic_unlock(s);
		break;
	case 0x4d0:
	case 0x4d1:
		pic_lock(s);
<blue>		*data = elcr_ioport_read(&s->pics[addr & 1]);</blue>
		pic_unlock(s);
		break;
	default:
		return -EOPNOTSUPP;
	}
	return 0;
<blue>}</blue>

static int picdev_master_write(struct kvm_vcpu *vcpu, struct kvm_io_device *dev,
			       gpa_t addr, int len, const void *val)
{
<yellow>	return picdev_write(container_of(dev, struct kvm_pic, dev_master),</yellow>
			    addr, len, val);
}

static int picdev_master_read(struct kvm_vcpu *vcpu, struct kvm_io_device *dev,
			      gpa_t addr, int len, void *val)
{
<blue>	return picdev_read(container_of(dev, struct kvm_pic, dev_master),</blue>
			    addr, len, val);
}

static int picdev_slave_write(struct kvm_vcpu *vcpu, struct kvm_io_device *dev,
			      gpa_t addr, int len, const void *val)
{
<blue>	return picdev_write(container_of(dev, struct kvm_pic, dev_slave),</blue>
			    addr, len, val);
}

static int picdev_slave_read(struct kvm_vcpu *vcpu, struct kvm_io_device *dev,
			     gpa_t addr, int len, void *val)
{
<blue>	return picdev_read(container_of(dev, struct kvm_pic, dev_slave),</blue>
			    addr, len, val);
}

static int picdev_elcr_write(struct kvm_vcpu *vcpu, struct kvm_io_device *dev,
			     gpa_t addr, int len, const void *val)
{
<blue>	return picdev_write(container_of(dev, struct kvm_pic, dev_elcr),</blue>
			    addr, len, val);
}

static int picdev_elcr_read(struct kvm_vcpu *vcpu, struct kvm_io_device *dev,
			    gpa_t addr, int len, void *val)
{
<blue>	return picdev_read(container_of(dev, struct kvm_pic, dev_elcr),</blue>
			    addr, len, val);
}

/*
 * callback when PIC0 irq status changed
 */
static void pic_irq_request(struct kvm *kvm, int level)
{
	struct kvm_pic *s = kvm-&gt;arch.vpic;

	if (!s-&gt;output)
<blue>		s->wakeup_needed = true;</blue>
<blue>	s->output = level;</blue>
}

static const struct kvm_io_device_ops picdev_master_ops = {
	.read     = picdev_master_read,
	.write    = picdev_master_write,
};

static const struct kvm_io_device_ops picdev_slave_ops = {
	.read     = picdev_slave_read,
	.write    = picdev_slave_write,
};

static const struct kvm_io_device_ops picdev_elcr_ops = {
	.read     = picdev_elcr_read,
	.write    = picdev_elcr_write,
};

int kvm_pic_init(struct kvm *kvm)
{
	struct kvm_pic *s;
	int ret;

<blue>	s = kzalloc(sizeof(struct kvm_pic), GFP_KERNEL_ACCOUNT);</blue>
	if (!s)
		return -ENOMEM;
<blue>	spin_lock_init(&s->lock);</blue>
	s-&gt;kvm = kvm;
	s-&gt;pics[0].elcr_mask = 0xf8;
	s-&gt;pics[1].elcr_mask = 0xde;
	s-&gt;pics[0].pics_state = s;
	s-&gt;pics[1].pics_state = s;

	/*
	 * Initialize PIO device
	 */
	kvm_iodevice_init(&amp;s-&gt;dev_master, &amp;picdev_master_ops);
	kvm_iodevice_init(&amp;s-&gt;dev_slave, &amp;picdev_slave_ops);
	kvm_iodevice_init(&amp;s-&gt;dev_elcr, &amp;picdev_elcr_ops);
	mutex_lock(&amp;kvm-&gt;slots_lock);
	ret = kvm_io_bus_register_dev(kvm, KVM_PIO_BUS, 0x20, 2,
				      &amp;s-&gt;dev_master);
	if (ret &lt; 0)
		goto fail_unlock;

<blue>	ret = kvm_io_bus_register_dev(kvm, KVM_PIO_BUS, 0xa0, 2, &s->dev_slave);</blue>
	if (ret &lt; 0)
		goto fail_unreg_2;

<blue>	ret = kvm_io_bus_register_dev(kvm, KVM_PIO_BUS, 0x4d0, 2, &s->dev_elcr);</blue>
	if (ret &lt; 0)
		goto fail_unreg_1;

<blue>	mutex_unlock(&kvm->slots_lock);</blue>

	kvm-&gt;arch.vpic = s;

	return 0;

fail_unreg_1:
<yellow>	kvm_io_bus_unregister_dev(kvm, KVM_PIO_BUS, &s->dev_slave);</yellow>

fail_unreg_2:
<yellow>	kvm_io_bus_unregister_dev(kvm, KVM_PIO_BUS, &s->dev_master);</yellow>

fail_unlock:
<yellow>	mutex_unlock(&kvm->slots_lock);</yellow>

	kfree(s);

	return ret;
<blue>}</blue>

void kvm_pic_destroy(struct kvm *kvm)
{
<yellow>	struct kvm_pic *vpic = kvm->arch.vpic;</yellow>

	if (!vpic)
		return;

<yellow>	mutex_lock(&kvm->slots_lock);</yellow>
	kvm_io_bus_unregister_dev(vpic-&gt;kvm, KVM_PIO_BUS, &amp;vpic-&gt;dev_master);
	kvm_io_bus_unregister_dev(vpic-&gt;kvm, KVM_PIO_BUS, &amp;vpic-&gt;dev_slave);
	kvm_io_bus_unregister_dev(vpic-&gt;kvm, KVM_PIO_BUS, &amp;vpic-&gt;dev_elcr);
	mutex_unlock(&amp;kvm-&gt;slots_lock);

	kvm-&gt;arch.vpic = NULL;
	kfree(vpic);
<yellow>}</yellow>


</code></pre></td></tr></table>
</body>
</html>
