<doctype html>
    <html lang="ja">
    <head><title>nested.c</title><meta charset="utf-8">
    <script src="https://cdn.rawgit.com/google/code-prettify/master/loader/run_prettify.js"></script>
    <style>
        code{
            font-family:Monaco, Menlo, Consolas, 'Courier New', Courier, monospace, sans-serif;
            font-size: 14px;
            line-height: 18px;
            overflow: auto;
            resize: horizontal;
        }
        code_line{
            font-family: Monaco, Menlo, Consolas, 'Courier New', Courier, monospace, sans-serif;;
            font-size: 14px;
            line-height: 18px;
            overflow: auto;
            resize: horizontal;
            color:#303134;
        }
        blue{
            background-color:#BEEDE8;
        }
        yellow{
            background-color:#FFFF99;
        }
        red{
            background-color:#FF99AC;
        }
        .split {
            height: 100%;
            position: fixed;
            z-index: 1;
            top: 0;
            overflow-x: hidden;
        }
        .tree {
            left: 0;
            width: 20%;
        }
        .right {
            border-left: 2px solid #444;
            right: 0;
            width: 80%;
            /* font-family: 'Courier New', Courier, monospace;
                    color: rgb(80, 80, 80); */
        }
    </style>
    </head>
    <body>
    <div class="split tree">
        <ul id="file_list">
        </ul>
    </div>
    <div class="split right">
    <table summary='blob content' class='blob' cellspacing="15">
    <tr><td align="right"><pre><code_line><script>for (let i = 1; i <= 1821; i++){
            document.write(i+".\n");
    }
            </script></code_line></pre></td>
<td class='lines'><pre><code class="prettyprint">// SPDX-License-Identifier: GPL-2.0-only
/*
 * Kernel-based Virtual Machine driver for Linux
 *
 * AMD SVM support
 *
 * Copyright (C) 2006 Qumranet, Inc.
 * Copyright 2010 Red Hat, Inc. and/or its affiliates.
 *
 * Authors:
 *   Yaniv Kamay  &lt;yaniv@qumranet.com&gt;
 *   Avi Kivity   &lt;avi@qumranet.com&gt;
 */

#define pr_fmt(fmt) KBUILD_MODNAME &quot;: &quot; fmt

#include &lt;linux/kvm_types.h&gt;
#include &lt;linux/kvm_host.h&gt;
#include &lt;linux/kernel.h&gt;

#include &lt;asm/msr-index.h&gt;
#include &lt;asm/debugreg.h&gt;

#include &quot;kvm_emulate.h&quot;
#include &quot;trace.h&quot;
#include &quot;mmu.h&quot;
#include &quot;x86.h&quot;
#include &quot;smm.h&quot;
#include &quot;cpuid.h&quot;
#include &quot;lapic.h&quot;
#include &quot;svm.h&quot;
#include &quot;hyperv.h&quot;

#define CC KVM_NESTED_VMENTER_CONSISTENCY_CHECK

static void nested_svm_inject_npf_exit(struct kvm_vcpu *vcpu,
				       struct x86_exception *fault)
{
	struct vcpu_svm *svm = to_svm(vcpu);
<yellow>	struct vmcb *vmcb = svm->vmcb;</yellow>

	if (vmcb-&gt;control.exit_code != SVM_EXIT_NPF) {
		/*
		 * TODO: track the cause of the nested page fault, and
		 * correctly fill in the high bits of exit_info_1.
		 */
		vmcb-&gt;control.exit_code = SVM_EXIT_NPF;
<yellow>		vmcb->control.exit_code_hi = 0;</yellow>
		vmcb-&gt;control.exit_info_1 = (1ULL &lt;&lt; 32);
		vmcb-&gt;control.exit_info_2 = fault-&gt;address;
	}

<yellow>	vmcb->control.exit_info_1 &= ~0xffffffffULL;</yellow>
	vmcb-&gt;control.exit_info_1 |= fault-&gt;error_code;

	nested_svm_vmexit(svm);
}

static u64 nested_svm_get_tdp_pdptr(struct kvm_vcpu *vcpu, int index)
<yellow>{</yellow>
	struct vcpu_svm *svm = to_svm(vcpu);
<yellow>	u64 cr3 = svm->nested.ctl.nested_cr3;</yellow>
	u64 pdpte;
	int ret;

	ret = kvm_vcpu_read_guest_page(vcpu, gpa_to_gfn(cr3), &amp;pdpte,
				       offset_in_page(cr3) + index * 8, 8);
	if (ret)
		return 0;
<yellow>	return pdpte;</yellow>
}

static unsigned long nested_svm_get_tdp_cr3(struct kvm_vcpu *vcpu)
{
	struct vcpu_svm *svm = to_svm(vcpu);

<yellow>	return svm->nested.ctl.nested_cr3;</yellow>
}

static void nested_svm_init_mmu_context(struct kvm_vcpu *vcpu)
{
	struct vcpu_svm *svm = to_svm(vcpu);

<yellow>	WARN_ON(mmu_is_nested(vcpu));</yellow>

<yellow>	vcpu->arch.mmu = &vcpu->arch.guest_mmu;</yellow>

	/*
	 * The NPT format depends on L1&#x27;s CR4 and EFER, which is in vmcb01.  Note,
	 * when called via KVM_SET_NESTED_STATE, that state may _not_ match current
	 * vCPU state.  CR0.WP is explicitly ignored, while CR0.PG is required.
	 */
	kvm_init_shadow_npt_mmu(vcpu, X86_CR0_PG, svm-&gt;vmcb01.ptr-&gt;save.cr4,
				svm-&gt;vmcb01.ptr-&gt;save.efer,
				svm-&gt;nested.ctl.nested_cr3);
	vcpu-&gt;arch.mmu-&gt;get_guest_pgd     = nested_svm_get_tdp_cr3;
	vcpu-&gt;arch.mmu-&gt;get_pdptr         = nested_svm_get_tdp_pdptr;
	vcpu-&gt;arch.mmu-&gt;inject_page_fault = nested_svm_inject_npf_exit;
	vcpu-&gt;arch.walk_mmu              = &amp;vcpu-&gt;arch.nested_mmu;
}

static void nested_svm_uninit_mmu_context(struct kvm_vcpu *vcpu)
{
	vcpu-&gt;arch.mmu = &amp;vcpu-&gt;arch.root_mmu;
	vcpu-&gt;arch.walk_mmu = &amp;vcpu-&gt;arch.root_mmu;
}

static bool nested_vmcb_needs_vls_intercept(struct vcpu_svm *svm)
{
<yellow>	if (!svm->v_vmload_vmsave_enabled)</yellow>
		return true;

<yellow>	if (!nested_npt_enabled(svm))</yellow>
		return true;

	if (!(svm-&gt;nested.ctl.virt_ext &amp; VIRTUAL_VMLOAD_VMSAVE_ENABLE_MASK))
		return true;

	return false;
}

void recalc_intercepts(struct vcpu_svm *svm)
{
	struct vmcb_control_area *c, *h;
	struct vmcb_ctrl_area_cached *g;
	unsigned int i;

<blue>	vmcb_mark_dirty(svm->vmcb, VMCB_INTERCEPTS);</blue>

<blue>	if (!is_guest_mode(&svm->vcpu))</blue>
		return;

<yellow>	c = &svm->vmcb->control;</yellow>
	h = &amp;svm-&gt;vmcb01.ptr-&gt;control;
	g = &amp;svm-&gt;nested.ctl;

	for (i = 0; i &lt; MAX_INTERCEPT; i++)
<yellow>		c->intercepts[i] = h->intercepts[i];</yellow>

<yellow>	if (g->int_ctl & V_INTR_MASKING_MASK) {</yellow>
		/*
		 * If L2 is active and V_INTR_MASKING is enabled in vmcb12,
		 * disable intercept of CR8 writes as L2&#x27;s CR8 does not affect
		 * any interrupt KVM may want to inject.
		 *
		 * Similarly, disable intercept of virtual interrupts (used to
		 * detect interrupt windows) if the saved RFLAGS.IF is &#x27;0&#x27;, as
		 * the effective RFLAGS.IF for L1 interrupts will never be set
		 * while L2 is running (L2&#x27;s RFLAGS.IF doesn&#x27;t affect L1 IRQs).
		 */
<yellow>		vmcb_clr_intercept(c, INTERCEPT_CR8_WRITE);</yellow>
		if (!(svm-&gt;vmcb01.ptr-&gt;save.rflags &amp; X86_EFLAGS_IF))
<yellow>			vmcb_clr_intercept(c, INTERCEPT_VINTR);</yellow>
	}

	/*
	 * We want to see VMMCALLs from a nested guest only when Hyper-V L2 TLB
	 * flush feature is enabled.
	 */
<yellow>	if (!nested_svm_l2_tlb_flush_enabled(&svm->vcpu))</yellow>
<yellow>		vmcb_clr_intercept(c, INTERCEPT_VMMCALL);</yellow>

	for (i = 0; i &lt; MAX_INTERCEPT; i++)
<yellow>		c->intercepts[i] |= g->intercepts[i];</yellow>

	/* If SMI is not intercepted, ignore guest SMI intercept as well  */
<yellow>	if (!intercept_smi)</yellow>
<yellow>		vmcb_clr_intercept(c, INTERCEPT_SMI);</yellow>

<yellow>	if (nested_vmcb_needs_vls_intercept(svm)) {</yellow>
		/*
		 * If the virtual VMLOAD/VMSAVE is not enabled for the L2,
		 * we must intercept these instructions to correctly
		 * emulate them in case L1 doesn&#x27;t intercept them.
		 */
<yellow>		vmcb_set_intercept(c, INTERCEPT_VMLOAD);</yellow>
		vmcb_set_intercept(c, INTERCEPT_VMSAVE);
	} else {
<yellow>		WARN_ON(!(c->virt_ext & VIRTUAL_VMLOAD_VMSAVE_ENABLE_MASK));</yellow>
	}
<yellow>}</yellow>

/*
 * Merge L0&#x27;s (KVM) and L1&#x27;s (Nested VMCB) MSR permission bitmaps. The function
 * is optimized in that it only merges the parts where KVM MSR permission bitmap
 * may contain zero bits.
 */
static bool nested_svm_vmrun_msrpm(struct vcpu_svm *svm)
<yellow>{</yellow>
	struct hv_vmcb_enlightenments *hve = &amp;svm-&gt;nested.ctl.hv_enlightenments;
	int i;

	/*
	 * MSR bitmap update can be skipped when:
	 * - MSR bitmap for L1 hasn&#x27;t changed.
	 * - Nested hypervisor (L1) is attempting to launch the same L2 as
	 *   before.
	 * - Nested hypervisor (L1) is using Hyper-V emulation interface and
	 * tells KVM (L0) there were no changes in MSR bitmap for L2.
	 */
<yellow>	if (!svm->nested.force_msr_bitmap_recalc &&</yellow>
<yellow>	    kvm_hv_hypercall_enabled(&svm->vcpu) &&</yellow>
	    hve-&gt;hv_enlightenments_control.msr_bitmap &amp;&amp;
<yellow>	    (svm->nested.ctl.clean & BIT(HV_VMCB_NESTED_ENLIGHTENMENTS)))</yellow>
		goto set_msrpm_base_pa;

<yellow>	if (!(vmcb12_is_intercept(&svm->nested.ctl, INTERCEPT_MSR_PROT)))</yellow>
		return true;

<yellow>	for (i = 0; i < MSRPM_OFFSETS; i++) {</yellow>
		u32 value, p;
		u64 offset;

<yellow>		if (msrpm_offsets[i] == 0xffffffff)</yellow>
			break;

<yellow>		p      = msrpm_offsets[i];</yellow>

		/* x2apic msrs are intercepted always for the nested guest */
		if (is_x2apic_msrpm_offset(p))
			continue;

<yellow>		offset = svm->nested.ctl.msrpm_base_pa + (p * 4);</yellow>

		if (kvm_vcpu_read_guest(&amp;svm-&gt;vcpu, offset, &amp;value, 4))
<yellow>			return false;</yellow>

<yellow>		svm->nested.msrpm[p] = svm->msrpm[p] | value;</yellow>
	}

<yellow>	svm->nested.force_msr_bitmap_recalc = false;</yellow>

set_msrpm_base_pa:
<yellow>	svm->vmcb->control.msrpm_base_pa = __sme_set(__pa(svm->nested.msrpm));</yellow>

	return true;
}

/*
 * Bits 11:0 of bitmap address are ignored by hardware
 */
static bool nested_svm_check_bitmap_pa(struct kvm_vcpu *vcpu, u64 pa, u32 size)
{
	u64 addr = PAGE_ALIGN(pa);

	return kvm_vcpu_is_legal_gpa(vcpu, addr) &amp;&amp;
	    kvm_vcpu_is_legal_gpa(vcpu, addr + size - 1);
}

static bool nested_svm_check_tlb_ctl(struct kvm_vcpu *vcpu, u8 tlb_ctl)
{
	/* Nested FLUSHBYASID is not supported yet.  */
	switch(tlb_ctl) {
		case TLB_CONTROL_DO_NOTHING:
		case TLB_CONTROL_FLUSH_ALL_ASID:
			return true;
		default:
			return false;
	}
}

static bool __nested_vmcb_check_controls(struct kvm_vcpu *vcpu,
					 struct vmcb_ctrl_area_cached *control)
{
<yellow>	if (CC(!vmcb12_is_intercept(control, INTERCEPT_VMRUN)))</yellow>
		return false;

<yellow>	if (CC(control->asid == 0))</yellow>
		return false;

<yellow>	if (CC((control->nested_ctl & SVM_NESTED_CTL_NP_ENABLE) && !npt_enabled))</yellow>
		return false;

<yellow>	if (CC(!nested_svm_check_bitmap_pa(vcpu, control->msrpm_base_pa,</yellow>
					   MSRPM_SIZE)))
		return false;
<yellow>	if (CC(!nested_svm_check_bitmap_pa(vcpu, control->iopm_base_pa,</yellow>
					   IOPM_SIZE)))
		return false;

<yellow>	if (CC(!nested_svm_check_tlb_ctl(vcpu, control->tlb_ctl)))</yellow>
		return false;

<yellow>	if (CC((control->int_ctl & V_NMI_ENABLE_MASK) &&</yellow>
	       !vmcb12_is_intercept(control, INTERCEPT_NMI))) {
		return false;
	}

	return true;
<yellow>}</yellow>

/* Common checks that apply to both L1 and L2 state.  */
static bool __nested_vmcb_check_save(struct kvm_vcpu *vcpu,
				     struct vmcb_save_area_cached *save)
{
<yellow>	if (CC(!(save->efer & EFER_SVME)))</yellow>
		return false;

<yellow>	if (CC((save->cr0 & X86_CR0_CD) == 0 && (save->cr0 & X86_CR0_NW)) ||</yellow>
<yellow>	    CC(save->cr0 & ~0xffffffffULL))</yellow>
		return false;

<yellow>	if (CC(!kvm_dr6_valid(save->dr6)) || CC(!kvm_dr7_valid(save->dr7)))</yellow>
		return false;

	/*
	 * These checks are also performed by KVM_SET_SREGS,
	 * except that EFER.LMA is not checked by SVM against
	 * CR0.PG &amp;&amp; EFER.LME.
	 */
<yellow>	if ((save->efer & EFER_LME) && (save->cr0 & X86_CR0_PG)) {</yellow>
<yellow>		if (CC(!(save->cr4 & X86_CR4_PAE)) ||</yellow>
<yellow>		    CC(!(save->cr0 & X86_CR0_PE)) ||</yellow>
<yellow>		    CC(kvm_vcpu_is_illegal_gpa(vcpu, save->cr3)))</yellow>
			return false;
	}

	/* Note, SVM doesn&#x27;t have any additional restrictions on CR4. */
<yellow>	if (CC(!__kvm_is_valid_cr4(vcpu, save->cr4)))</yellow>
		return false;

<yellow>	if (CC(!kvm_valid_efer(vcpu, save->efer)))</yellow>
		return false;

	return true;
<yellow>}</yellow>

static bool nested_vmcb_check_save(struct kvm_vcpu *vcpu)
{
	struct vcpu_svm *svm = to_svm(vcpu);
	struct vmcb_save_area_cached *save = &amp;svm-&gt;nested.save;

	return __nested_vmcb_check_save(vcpu, save);
}

static bool nested_vmcb_check_controls(struct kvm_vcpu *vcpu)
{
	struct vcpu_svm *svm = to_svm(vcpu);
	struct vmcb_ctrl_area_cached *ctl = &amp;svm-&gt;nested.ctl;

<yellow>	return __nested_vmcb_check_controls(vcpu, ctl);</yellow>
}

static
void __nested_copy_vmcb_control_to_cache(struct kvm_vcpu *vcpu,
					 struct vmcb_ctrl_area_cached *to,
					 struct vmcb_control_area *from)
{
	unsigned int i;

	for (i = 0; i &lt; MAX_INTERCEPT; i++)
<yellow>		to->intercepts[i] = from->intercepts[i];</yellow>

<yellow>	to->iopm_base_pa        = from->iopm_base_pa;</yellow>
	to-&gt;msrpm_base_pa       = from-&gt;msrpm_base_pa;
	to-&gt;tsc_offset          = from-&gt;tsc_offset;
	to-&gt;tlb_ctl             = from-&gt;tlb_ctl;
	to-&gt;int_ctl             = from-&gt;int_ctl;
	to-&gt;int_vector          = from-&gt;int_vector;
	to-&gt;int_state           = from-&gt;int_state;
	to-&gt;exit_code           = from-&gt;exit_code;
	to-&gt;exit_code_hi        = from-&gt;exit_code_hi;
	to-&gt;exit_info_1         = from-&gt;exit_info_1;
	to-&gt;exit_info_2         = from-&gt;exit_info_2;
	to-&gt;exit_int_info       = from-&gt;exit_int_info;
	to-&gt;exit_int_info_err   = from-&gt;exit_int_info_err;
	to-&gt;nested_ctl          = from-&gt;nested_ctl;
	to-&gt;event_inj           = from-&gt;event_inj;
	to-&gt;event_inj_err       = from-&gt;event_inj_err;
	to-&gt;next_rip            = from-&gt;next_rip;
	to-&gt;nested_cr3          = from-&gt;nested_cr3;
	to-&gt;virt_ext            = from-&gt;virt_ext;
	to-&gt;pause_filter_count  = from-&gt;pause_filter_count;
	to-&gt;pause_filter_thresh = from-&gt;pause_filter_thresh;

	/* Copy asid here because nested_vmcb_check_controls will check it.  */
	to-&gt;asid           = from-&gt;asid;
	to-&gt;msrpm_base_pa &amp;= ~0x0fffULL;
	to-&gt;iopm_base_pa  &amp;= ~0x0fffULL;

	/* Hyper-V extensions (Enlightened VMCB) */
<yellow>	if (kvm_hv_hypercall_enabled(vcpu)) {</yellow>
<yellow>		to->clean = from->clean;</yellow>
		memcpy(&amp;to-&gt;hv_enlightenments, &amp;from-&gt;hv_enlightenments,
		       sizeof(to-&gt;hv_enlightenments));
	}
<yellow>}</yellow>

void nested_copy_vmcb_control_to_cache(struct vcpu_svm *svm,
				       struct vmcb_control_area *control)
{
<yellow>	__nested_copy_vmcb_control_to_cache(&svm->vcpu, &svm->nested.ctl, control);</yellow>
}

static void __nested_copy_vmcb_save_to_cache(struct vmcb_save_area_cached *to,
					     struct vmcb_save_area *from)
{
	/*
	 * Copy only fields that are validated, as we need them
	 * to avoid TOC/TOU races.
	 */
<yellow>	to->efer = from->efer;</yellow>
	to-&gt;cr0 = from-&gt;cr0;
	to-&gt;cr3 = from-&gt;cr3;
	to-&gt;cr4 = from-&gt;cr4;

	to-&gt;dr6 = from-&gt;dr6;
	to-&gt;dr7 = from-&gt;dr7;
}

void nested_copy_vmcb_save_to_cache(struct vcpu_svm *svm,
				    struct vmcb_save_area *save)
{
<yellow>	__nested_copy_vmcb_save_to_cache(&svm->nested.save, save);</yellow>
}

/*
 * Synchronize fields that are written by the processor, so that
 * they can be copied back into the vmcb12.
 */
void nested_sync_control_from_vmcb02(struct vcpu_svm *svm)
{
	u32 mask;
<yellow>	svm->nested.ctl.event_inj      = svm->vmcb->control.event_inj;</yellow>
	svm-&gt;nested.ctl.event_inj_err  = svm-&gt;vmcb-&gt;control.event_inj_err;

	/* Only a few fields of int_ctl are written by the processor.  */
	mask = V_IRQ_MASK | V_TPR_MASK;
	/*
	 * Don&#x27;t sync vmcb02 V_IRQ back to vmcb12 if KVM (L0) is intercepting
	 * virtual interrupts in order to request an interrupt window, as KVM
	 * has usurped vmcb02&#x27;s int_ctl.  If an interrupt window opens before
	 * the next VM-Exit, svm_clear_vintr() will restore vmcb12&#x27;s int_ctl.
	 * If no window opens, V_IRQ will be correctly preserved in vmcb12&#x27;s
	 * int_ctl (because it was never recognized while L2 was running).
	 */
	if (svm_is_intercept(svm, INTERCEPT_VINTR) &amp;&amp;
<yellow>	    !test_bit(INTERCEPT_VINTR, (unsigned long *)svm->nested.ctl.intercepts))</yellow>
		mask &amp;= ~V_IRQ_MASK;

<yellow>	if (nested_vgif_enabled(svm))</yellow>
<yellow>		mask |= V_GIF_MASK;</yellow>

<yellow>	if (nested_vnmi_enabled(svm))</yellow>
<yellow>		mask |= V_NMI_BLOCKING_MASK | V_NMI_PENDING_MASK;</yellow>

<yellow>	svm->nested.ctl.int_ctl        &= ~mask;</yellow>
	svm-&gt;nested.ctl.int_ctl        |= svm-&gt;vmcb-&gt;control.int_ctl &amp; mask;
}

/*
 * Transfer any event that L0 or L1 wanted to inject into L2 to
 * EXIT_INT_INFO.
 */
static void nested_save_pending_event_to_vmcb12(struct vcpu_svm *svm,
						struct vmcb *vmcb12)
{
	struct kvm_vcpu *vcpu = &amp;svm-&gt;vcpu;
	u32 exit_int_info = 0;
	unsigned int nr;

<yellow>	if (vcpu->arch.exception.injected) {</yellow>
<yellow>		nr = vcpu->arch.exception.vector;</yellow>
<yellow>		exit_int_info = nr | SVM_EVTINJ_VALID | SVM_EVTINJ_TYPE_EXEPT;</yellow>

<yellow>		if (vcpu->arch.exception.has_error_code) {</yellow>
			exit_int_info |= SVM_EVTINJ_VALID_ERR;
			vmcb12-&gt;control.exit_int_info_err =
<yellow>				vcpu->arch.exception.error_code;</yellow>
		}

<yellow>	} else if (vcpu->arch.nmi_injected) {</yellow>
		exit_int_info = SVM_EVTINJ_VALID | SVM_EVTINJ_TYPE_NMI;

<yellow>	} else if (vcpu->arch.interrupt.injected) {</yellow>
<yellow>		nr = vcpu->arch.interrupt.nr;</yellow>
<yellow>		exit_int_info = nr | SVM_EVTINJ_VALID;</yellow>

<yellow>		if (vcpu->arch.interrupt.soft)</yellow>
<yellow>			exit_int_info |= SVM_EVTINJ_TYPE_SOFT;</yellow>
		else
			exit_int_info |= SVM_EVTINJ_TYPE_INTR;
	}

<yellow>	vmcb12->control.exit_int_info = exit_int_info;</yellow>
}

static void nested_svm_transition_tlb_flush(struct kvm_vcpu *vcpu)
{
	/*
	 * KVM_REQ_HV_TLB_FLUSH flushes entries from either L1&#x27;s VP_ID or
	 * L2&#x27;s VP_ID upon request from the guest. Make sure we check for
	 * pending entries in the right FIFO upon L1/L2 transition as these
	 * requests are put by other vCPUs asynchronously.
	 */
<yellow>	if (to_hv_vcpu(vcpu) && npt_enabled)</yellow>
<yellow>		kvm_make_request(KVM_REQ_HV_TLB_FLUSH, vcpu);</yellow>

	/*
	 * TODO: optimize unconditional TLB flush/MMU sync.  A partial list of
	 * things to fix before this can be conditional:
	 *
	 *  - Flush TLBs for both L1 and L2 remote TLB flush
	 *  - Honor L1&#x27;s request to flush an ASID on nested VMRUN
	 *  - Sync nested NPT MMU on VMRUN that flushes L2&#x27;s ASID[*]
	 *  - Don&#x27;t crush a pending TLB flush in vmcb02 on nested VMRUN
	 *  - Flush L1&#x27;s ASID on KVM_REQ_TLB_FLUSH_GUEST
	 *
	 * [*] Unlike nested EPT, SVM&#x27;s ASID management can invalidate nested
	 *     NPT guest-physical mappings on VMRUN.
	 */
<yellow>	kvm_make_request(KVM_REQ_MMU_SYNC, vcpu);</yellow>
	kvm_make_request(KVM_REQ_TLB_FLUSH_CURRENT, vcpu);
}

/*
 * Load guest&#x27;s/host&#x27;s cr3 on nested vmentry or vmexit. @nested_npt is true
 * if we are emulating VM-Entry into a guest with NPT enabled.
 */
static int nested_svm_load_cr3(struct kvm_vcpu *vcpu, unsigned long cr3,
			       bool nested_npt, bool reload_pdptrs)
{
<yellow>	if (CC(kvm_vcpu_is_illegal_gpa(vcpu, cr3)))</yellow>
		return -EINVAL;

<yellow>	if (reload_pdptrs && !nested_npt && is_pae_paging(vcpu) &&</yellow>
<yellow>	    CC(!load_pdptrs(vcpu, cr3)))</yellow>
		return -EINVAL;

<yellow>	vcpu->arch.cr3 = cr3;</yellow>

	/* Re-initialize the MMU, e.g. to pick up CR4 MMU role changes. */
	kvm_init_mmu(vcpu);

	if (!nested_npt)
<yellow>		kvm_mmu_new_pgd(vcpu, cr3);</yellow>

	return 0;
<yellow>}</yellow>

void nested_vmcb02_compute_g_pat(struct vcpu_svm *svm)
{
<yellow>	if (!svm->nested.vmcb02.ptr)</yellow>
		return;

	/* FIXME: merge g_pat from vmcb01 and vmcb12.  */
<yellow>	svm->nested.vmcb02.ptr->save.g_pat = svm->vmcb01.ptr->save.g_pat;</yellow>
<yellow>}</yellow>

static void nested_vmcb02_prepare_save(struct vcpu_svm *svm, struct vmcb *vmcb12)
{
	bool new_vmcb12 = false;
	struct vmcb *vmcb01 = svm-&gt;vmcb01.ptr;
	struct vmcb *vmcb02 = svm-&gt;nested.vmcb02.ptr;

<yellow>	nested_vmcb02_compute_g_pat(svm);</yellow>

	/* Load the nested guest state */
<yellow>	if (svm->nested.vmcb12_gpa != svm->nested.last_vmcb12_gpa) {</yellow>
		new_vmcb12 = true;
		svm-&gt;nested.last_vmcb12_gpa = svm-&gt;nested.vmcb12_gpa;
<yellow>		svm->nested.force_msr_bitmap_recalc = true;</yellow>
	}

<yellow>	if (unlikely(new_vmcb12 || vmcb_is_dirty(vmcb12, VMCB_SEG))) {</yellow>
<yellow>		vmcb02->save.es = vmcb12->save.es;</yellow>
		vmcb02-&gt;save.cs = vmcb12-&gt;save.cs;
		vmcb02-&gt;save.ss = vmcb12-&gt;save.ss;
		vmcb02-&gt;save.ds = vmcb12-&gt;save.ds;
		vmcb02-&gt;save.cpl = vmcb12-&gt;save.cpl;
		vmcb_mark_dirty(vmcb02, VMCB_SEG);
	}

<yellow>	if (unlikely(new_vmcb12 || vmcb_is_dirty(vmcb12, VMCB_DT))) {</yellow>
<yellow>		vmcb02->save.gdtr = vmcb12->save.gdtr;</yellow>
		vmcb02-&gt;save.idtr = vmcb12-&gt;save.idtr;
<yellow>		vmcb_mark_dirty(vmcb02, VMCB_DT);</yellow>
	}

<yellow>	kvm_set_rflags(&svm->vcpu, vmcb12->save.rflags | X86_EFLAGS_FIXED);</yellow>

	svm_set_efer(&amp;svm-&gt;vcpu, svm-&gt;nested.save.efer);

	svm_set_cr0(&amp;svm-&gt;vcpu, svm-&gt;nested.save.cr0);
	svm_set_cr4(&amp;svm-&gt;vcpu, svm-&gt;nested.save.cr4);

	svm-&gt;vcpu.arch.cr2 = vmcb12-&gt;save.cr2;

	kvm_rax_write(&amp;svm-&gt;vcpu, vmcb12-&gt;save.rax);
	kvm_rsp_write(&amp;svm-&gt;vcpu, vmcb12-&gt;save.rsp);
	kvm_rip_write(&amp;svm-&gt;vcpu, vmcb12-&gt;save.rip);

	/* In case we don&#x27;t even reach vcpu_run, the fields are not updated */
	vmcb02-&gt;save.rax = vmcb12-&gt;save.rax;
	vmcb02-&gt;save.rsp = vmcb12-&gt;save.rsp;
	vmcb02-&gt;save.rip = vmcb12-&gt;save.rip;

	/* These bits will be set properly on the first execution when new_vmc12 is true */
<yellow>	if (unlikely(new_vmcb12 || vmcb_is_dirty(vmcb12, VMCB_DR))) {</yellow>
<yellow>		vmcb02->save.dr7 = svm->nested.save.dr7 | DR7_FIXED_1;</yellow>
		svm-&gt;vcpu.arch.dr6  = svm-&gt;nested.save.dr6 | DR6_ACTIVE_LOW;
		vmcb_mark_dirty(vmcb02, VMCB_DR);
	}

<yellow>	if (unlikely(svm->lbrv_enabled && (svm->nested.ctl.virt_ext & LBR_CTL_ENABLE_MASK))) {</yellow>
		/*
		 * Reserved bits of DEBUGCTL are ignored.  Be consistent with
		 * svm_set_msr&#x27;s definition of reserved bits.
		 */
<yellow>		svm_copy_lbrs(vmcb02, vmcb12);</yellow>
		vmcb02-&gt;save.dbgctl &amp;= ~DEBUGCTL_RESERVED_BITS;
		svm_update_lbrv(&amp;svm-&gt;vcpu);

<yellow>	} else if (unlikely(vmcb01->control.virt_ext & LBR_CTL_ENABLE_MASK)) {</yellow>
<yellow>		svm_copy_lbrs(vmcb02, vmcb01);</yellow>
	}
}

static inline bool is_evtinj_soft(u32 evtinj)
{
<yellow>	u32 type = evtinj & SVM_EVTINJ_TYPE_MASK;</yellow>
	u8 vector = evtinj &amp; SVM_EVTINJ_VEC_MASK;

	if (!(evtinj &amp; SVM_EVTINJ_VALID))
		return false;

	if (type == SVM_EVTINJ_TYPE_SOFT)
		return true;

<yellow>	return type == SVM_EVTINJ_TYPE_EXEPT && kvm_exception_is_soft(vector);</yellow>
}

static bool is_evtinj_nmi(u32 evtinj)
{
<yellow>	u32 type = evtinj & SVM_EVTINJ_TYPE_MASK;</yellow>

<yellow>	if (!(evtinj & SVM_EVTINJ_VALID))</yellow>
		return false;

	return type == SVM_EVTINJ_TYPE_NMI;
}

static void nested_vmcb02_prepare_control(struct vcpu_svm *svm,
					  unsigned long vmcb12_rip,
					  unsigned long vmcb12_csbase)
{
	u32 int_ctl_vmcb01_bits = V_INTR_MASKING_MASK;
	u32 int_ctl_vmcb12_bits = V_TPR_MASK | V_IRQ_INJECTION_BITS_MASK;

	struct kvm_vcpu *vcpu = &amp;svm-&gt;vcpu;
<yellow>	struct vmcb *vmcb01 = svm->vmcb01.ptr;</yellow>
	struct vmcb *vmcb02 = svm-&gt;nested.vmcb02.ptr;
	u32 pause_count12;
	u32 pause_thresh12;

	/*
	 * Filled at exit: exit_code, exit_code_hi, exit_info_1, exit_info_2,
	 * exit_int_info, exit_int_info_err, next_rip, insn_len, insn_bytes.
	 */

<yellow>	if (svm->vgif_enabled && (svm->nested.ctl.int_ctl & V_GIF_ENABLE_MASK))</yellow>
		int_ctl_vmcb12_bits |= (V_GIF_MASK | V_GIF_ENABLE_MASK);
	else
		int_ctl_vmcb01_bits |= (V_GIF_MASK | V_GIF_ENABLE_MASK);

<yellow>	if (vnmi) {</yellow>
<yellow>		if (vmcb01->control.int_ctl & V_NMI_PENDING_MASK) {</yellow>
<yellow>			svm->vcpu.arch.nmi_pending++;</yellow>
			kvm_make_request(KVM_REQ_EVENT, &amp;svm-&gt;vcpu);
		}
<yellow>		if (nested_vnmi_enabled(svm))</yellow>
<yellow>			int_ctl_vmcb12_bits |= (V_NMI_PENDING_MASK |</yellow>
						V_NMI_ENABLE_MASK |
						V_NMI_BLOCKING_MASK);
	}

	/* Copied from vmcb01.  msrpm_base can be overwritten later.  */
<yellow>	vmcb02->control.nested_ctl = vmcb01->control.nested_ctl;</yellow>
	vmcb02-&gt;control.iopm_base_pa = vmcb01-&gt;control.iopm_base_pa;
	vmcb02-&gt;control.msrpm_base_pa = vmcb01-&gt;control.msrpm_base_pa;

	/* Done at vmrun: asid.  */

	/* Also overwritten later if necessary.  */
	vmcb02-&gt;control.tlb_ctl = TLB_CONTROL_DO_NOTHING;

	/* nested_cr3.  */
	if (nested_npt_enabled(svm))
<yellow>		nested_svm_init_mmu_context(vcpu);</yellow>

<yellow>	vcpu->arch.tsc_offset = kvm_calc_nested_tsc_offset(</yellow>
			vcpu-&gt;arch.l1_tsc_offset,
			svm-&gt;nested.ctl.tsc_offset,
			svm-&gt;tsc_ratio_msr);

	vmcb02-&gt;control.tsc_offset = vcpu-&gt;arch.tsc_offset;

	if (svm-&gt;tsc_ratio_msr != kvm_caps.default_tsc_scaling_ratio) {
<yellow>		WARN_ON(!svm->tsc_scaling_enabled);</yellow>
<yellow>		nested_svm_update_tsc_ratio_msr(vcpu);</yellow>
	}

	vmcb02-&gt;control.int_ctl             =
<yellow>		(svm->nested.ctl.int_ctl & int_ctl_vmcb12_bits) |</yellow>
		(vmcb01-&gt;control.int_ctl &amp; int_ctl_vmcb01_bits);

	vmcb02-&gt;control.int_vector          = svm-&gt;nested.ctl.int_vector;
	vmcb02-&gt;control.int_state           = svm-&gt;nested.ctl.int_state;
	vmcb02-&gt;control.event_inj           = svm-&gt;nested.ctl.event_inj;
	vmcb02-&gt;control.event_inj_err       = svm-&gt;nested.ctl.event_inj_err;

	/*
	 * next_rip is consumed on VMRUN as the return address pushed on the
	 * stack for injected soft exceptions/interrupts.  If nrips is exposed
	 * to L1, take it verbatim from vmcb12.  If nrips is supported in
	 * hardware but not exposed to L1, stuff the actual L2 RIP to emulate
	 * what a nrips=0 CPU would do (L1 is responsible for advancing RIP
	 * prior to injecting the event).
	 */
	if (svm-&gt;nrips_enabled)
<yellow>		vmcb02->control.next_rip    = svm->nested.ctl.next_rip;</yellow>
<yellow>	else if (boot_cpu_has(X86_FEATURE_NRIPS))</yellow>
<yellow>		vmcb02->control.next_rip    = vmcb12_rip;</yellow>

<yellow>	svm->nmi_l1_to_l2 = is_evtinj_nmi(vmcb02->control.event_inj);</yellow>
<yellow>	if (is_evtinj_soft(vmcb02->control.event_inj)) {</yellow>
<yellow>		svm->soft_int_injected = true;</yellow>
		svm-&gt;soft_int_csbase = vmcb12_csbase;
		svm-&gt;soft_int_old_rip = vmcb12_rip;
		if (svm-&gt;nrips_enabled)
<yellow>			svm->soft_int_next_rip = svm->nested.ctl.next_rip;</yellow>
		else
<yellow>			svm->soft_int_next_rip = vmcb12_rip;</yellow>
	}

<yellow>	vmcb02->control.virt_ext            = vmcb01->control.virt_ext &</yellow>
					      LBR_CTL_ENABLE_MASK;
	if (svm-&gt;lbrv_enabled)
		vmcb02-&gt;control.virt_ext  |=
<yellow>			(svm->nested.ctl.virt_ext & LBR_CTL_ENABLE_MASK);</yellow>

<yellow>	if (!nested_vmcb_needs_vls_intercept(svm))</yellow>
<yellow>		vmcb02->control.virt_ext |= VIRTUAL_VMLOAD_VMSAVE_ENABLE_MASK;</yellow>

<yellow>	pause_count12 = svm->pause_filter_enabled ? svm->nested.ctl.pause_filter_count : 0;</yellow>
<yellow>	pause_thresh12 = svm->pause_threshold_enabled ? svm->nested.ctl.pause_filter_thresh : 0;</yellow>
<yellow>	if (kvm_pause_in_guest(svm->vcpu.kvm)) {</yellow>
		/* use guest values since host doesn&#x27;t intercept PAUSE */
<yellow>		vmcb02->control.pause_filter_count = pause_count12;</yellow>
		vmcb02-&gt;control.pause_filter_thresh = pause_thresh12;

	} else {
		/* start from host values otherwise */
<yellow>		vmcb02->control.pause_filter_count = vmcb01->control.pause_filter_count;</yellow>
		vmcb02-&gt;control.pause_filter_thresh = vmcb01-&gt;control.pause_filter_thresh;

		/* ... but ensure filtering is disabled if so requested.  */
		if (vmcb12_is_intercept(&amp;svm-&gt;nested.ctl, INTERCEPT_PAUSE)) {
<yellow>			if (!pause_count12)</yellow>
<yellow>				vmcb02->control.pause_filter_count = 0;</yellow>
<yellow>			if (!pause_thresh12)</yellow>
<yellow>				vmcb02->control.pause_filter_thresh = 0;</yellow>
		}
	}

<yellow>	nested_svm_transition_tlb_flush(vcpu);</yellow>

	/* Enter Guest-Mode */
	enter_guest_mode(vcpu);

	/*
	 * Merge guest and host intercepts - must be called with vcpu in
	 * guest-mode to take effect.
	 */
<yellow>	recalc_intercepts(svm);</yellow>
<yellow>}</yellow>

static void nested_svm_copy_common_state(struct vmcb *from_vmcb, struct vmcb *to_vmcb)
{
	/*
	 * Some VMCB state is shared between L1 and L2 and thus has to be
	 * moved at the time of nested vmrun and vmexit.
	 *
	 * VMLOAD/VMSAVE state would also belong in this category, but KVM
	 * always performs VMLOAD and VMSAVE from the VMCB01.
	 */
	to_vmcb-&gt;save.spec_ctrl = from_vmcb-&gt;save.spec_ctrl;
}

int enter_svm_guest_mode(struct kvm_vcpu *vcpu, u64 vmcb12_gpa,
			 struct vmcb *vmcb12, bool from_vmrun)
{
	struct vcpu_svm *svm = to_svm(vcpu);
	int ret;

<yellow>	trace_kvm_nested_vmenter(svm->vmcb->save.rip,</yellow>
				 vmcb12_gpa,
				 vmcb12-&gt;save.rip,
				 vmcb12-&gt;control.int_ctl,
				 vmcb12-&gt;control.event_inj,
				 vmcb12-&gt;control.nested_ctl,
				 vmcb12-&gt;control.nested_cr3,
				 vmcb12-&gt;save.cr3,
				 KVM_ISA_SVM);

<yellow>	trace_kvm_nested_intercepts(vmcb12->control.intercepts[INTERCEPT_CR] & 0xffff,</yellow>
				    vmcb12-&gt;control.intercepts[INTERCEPT_CR] &gt;&gt; 16,
				    vmcb12-&gt;control.intercepts[INTERCEPT_EXCEPTION],
				    vmcb12-&gt;control.intercepts[INTERCEPT_WORD3],
				    vmcb12-&gt;control.intercepts[INTERCEPT_WORD4],
				    vmcb12-&gt;control.intercepts[INTERCEPT_WORD5]);


<yellow>	svm->nested.vmcb12_gpa = vmcb12_gpa;</yellow>

<yellow>	WARN_ON(svm->vmcb == svm->nested.vmcb02.ptr);</yellow>

<yellow>	nested_svm_copy_common_state(svm->vmcb01.ptr, svm->nested.vmcb02.ptr);</yellow>

	svm_switch_vmcb(svm, &amp;svm-&gt;nested.vmcb02);
	nested_vmcb02_prepare_control(svm, vmcb12-&gt;save.rip, vmcb12-&gt;save.cs.base);
<yellow>	nested_vmcb02_prepare_save(svm, vmcb12);</yellow>

	ret = nested_svm_load_cr3(&amp;svm-&gt;vcpu, svm-&gt;nested.save.cr3,
<yellow>				  nested_npt_enabled(svm), from_vmrun);</yellow>
	if (ret)
		return ret;

<yellow>	if (!from_vmrun)</yellow>
<yellow>		kvm_make_request(KVM_REQ_GET_NESTED_STATE_PAGES, vcpu);</yellow>

<yellow>	svm_set_gif(svm, true);</yellow>

<yellow>	if (kvm_vcpu_apicv_active(vcpu))</yellow>
<yellow>		kvm_make_request(KVM_REQ_APICV_UPDATE, vcpu);</yellow>

<yellow>	nested_svm_hv_update_vm_vp_ids(vcpu);</yellow>

	return 0;
<yellow>}</yellow>

int nested_svm_vmrun(struct kvm_vcpu *vcpu)
<yellow>{</yellow>
	struct vcpu_svm *svm = to_svm(vcpu);
	int ret;
	struct vmcb *vmcb12;
	struct kvm_host_map map;
	u64 vmcb12_gpa;
<yellow>	struct vmcb *vmcb01 = svm->vmcb01.ptr;</yellow>

	if (!svm-&gt;nested.hsave_msr) {
<yellow>		kvm_inject_gp(vcpu, 0);</yellow>
		return 1;
	}

<yellow>	if (is_smm(vcpu)) {</yellow>
<yellow>		kvm_queue_exception(vcpu, UD_VECTOR);</yellow>
		return 1;
	}

	/* This fails when VP assist page is enabled but the supplied GPA is bogus */
<yellow>	ret = kvm_hv_verify_vp_assist(vcpu);</yellow>
	if (ret) {
<yellow>		kvm_inject_gp(vcpu, 0);</yellow>
		return ret;
	}

<yellow>	vmcb12_gpa = svm->vmcb->save.rax;</yellow>
	ret = kvm_vcpu_map(vcpu, gpa_to_gfn(vmcb12_gpa), &amp;map);
	if (ret == -EINVAL) {
		kvm_inject_gp(vcpu, 0);
		return 1;
<yellow>	} else if (ret) {</yellow>
<yellow>		return kvm_skip_emulated_instruction(vcpu);</yellow>
	}

<yellow>	ret = kvm_skip_emulated_instruction(vcpu);</yellow>

	vmcb12 = map.hva;

<yellow>	if (WARN_ON_ONCE(!svm->nested.initialized))</yellow>
		return -EINVAL;

<yellow>	nested_copy_vmcb_control_to_cache(svm, &vmcb12->control);</yellow>
	nested_copy_vmcb_save_to_cache(svm, &amp;vmcb12-&gt;save);

	if (!nested_vmcb_check_save(vcpu) ||
<yellow>	    !nested_vmcb_check_controls(vcpu)) {</yellow>
<yellow>		vmcb12->control.exit_code    = SVM_EXIT_ERR;</yellow>
		vmcb12-&gt;control.exit_code_hi = 0;
		vmcb12-&gt;control.exit_info_1  = 0;
		vmcb12-&gt;control.exit_info_2  = 0;
		goto out;
	}

	/*
	 * Since vmcb01 is not in use, we can use it to store some of the L1
	 * state.
	 */
<yellow>	vmcb01->save.efer   = vcpu->arch.efer;</yellow>
<yellow>	vmcb01->save.cr0    = kvm_read_cr0(vcpu);</yellow>
	vmcb01-&gt;save.cr4    = vcpu-&gt;arch.cr4;
	vmcb01-&gt;save.rflags = kvm_get_rflags(vcpu);
<yellow>	vmcb01->save.rip    = kvm_rip_read(vcpu);</yellow>

<yellow>	if (!npt_enabled)</yellow>
<yellow>		vmcb01->save.cr3 = kvm_read_cr3(vcpu);</yellow>

<yellow>	svm->nested.nested_run_pending = 1;</yellow>

	if (enter_svm_guest_mode(vcpu, vmcb12_gpa, vmcb12, true))
		goto out_exit_err;

<yellow>	if (nested_svm_vmrun_msrpm(svm))</yellow>
		goto out;

out_exit_err:
<yellow>	svm->nested.nested_run_pending = 0;</yellow>
	svm-&gt;nmi_l1_to_l2 = false;
	svm-&gt;soft_int_injected = false;

	svm-&gt;vmcb-&gt;control.exit_code    = SVM_EXIT_ERR;
	svm-&gt;vmcb-&gt;control.exit_code_hi = 0;
	svm-&gt;vmcb-&gt;control.exit_info_1  = 0;
	svm-&gt;vmcb-&gt;control.exit_info_2  = 0;

	nested_svm_vmexit(svm);

out:
<yellow>	kvm_vcpu_unmap(vcpu, &map, true);</yellow>

	return ret;
}

/* Copy state save area fields which are handled by VMRUN */
void svm_copy_vmrun_state(struct vmcb_save_area *to_save,
			  struct vmcb_save_area *from_save)
{
<yellow>	to_save->es = from_save->es;</yellow>
	to_save-&gt;cs = from_save-&gt;cs;
	to_save-&gt;ss = from_save-&gt;ss;
	to_save-&gt;ds = from_save-&gt;ds;
	to_save-&gt;gdtr = from_save-&gt;gdtr;
	to_save-&gt;idtr = from_save-&gt;idtr;
	to_save-&gt;rflags = from_save-&gt;rflags | X86_EFLAGS_FIXED;
	to_save-&gt;efer = from_save-&gt;efer;
	to_save-&gt;cr0 = from_save-&gt;cr0;
	to_save-&gt;cr3 = from_save-&gt;cr3;
	to_save-&gt;cr4 = from_save-&gt;cr4;
	to_save-&gt;rax = from_save-&gt;rax;
	to_save-&gt;rsp = from_save-&gt;rsp;
	to_save-&gt;rip = from_save-&gt;rip;
	to_save-&gt;cpl = 0;
}

void svm_copy_vmloadsave_state(struct vmcb *to_vmcb, struct vmcb *from_vmcb)
{
<yellow>	to_vmcb->save.fs = from_vmcb->save.fs;</yellow>
	to_vmcb-&gt;save.gs = from_vmcb-&gt;save.gs;
	to_vmcb-&gt;save.tr = from_vmcb-&gt;save.tr;
	to_vmcb-&gt;save.ldtr = from_vmcb-&gt;save.ldtr;
	to_vmcb-&gt;save.kernel_gs_base = from_vmcb-&gt;save.kernel_gs_base;
	to_vmcb-&gt;save.star = from_vmcb-&gt;save.star;
	to_vmcb-&gt;save.lstar = from_vmcb-&gt;save.lstar;
	to_vmcb-&gt;save.cstar = from_vmcb-&gt;save.cstar;
	to_vmcb-&gt;save.sfmask = from_vmcb-&gt;save.sfmask;
	to_vmcb-&gt;save.sysenter_cs = from_vmcb-&gt;save.sysenter_cs;
	to_vmcb-&gt;save.sysenter_esp = from_vmcb-&gt;save.sysenter_esp;
	to_vmcb-&gt;save.sysenter_eip = from_vmcb-&gt;save.sysenter_eip;
}

int nested_svm_vmexit(struct vcpu_svm *svm)
<yellow>{</yellow>
	struct kvm_vcpu *vcpu = &amp;svm-&gt;vcpu;
<yellow>	struct vmcb *vmcb01 = svm->vmcb01.ptr;</yellow>
	struct vmcb *vmcb02 = svm-&gt;nested.vmcb02.ptr;
	struct vmcb *vmcb12;
	struct kvm_host_map map;
	int rc;

	rc = kvm_vcpu_map(vcpu, gpa_to_gfn(svm-&gt;nested.vmcb12_gpa), &amp;map);
	if (rc) {
<yellow>		if (rc == -EINVAL)</yellow>
<yellow>			kvm_inject_gp(vcpu, 0);</yellow>
		return 1;
	}

	vmcb12 = map.hva;

	/* Exit Guest-Mode */
<yellow>	leave_guest_mode(vcpu);</yellow>
	svm-&gt;nested.vmcb12_gpa = 0;
<yellow>	WARN_ON_ONCE(svm->nested.nested_run_pending);</yellow>

<yellow>	kvm_clear_request(KVM_REQ_GET_NESTED_STATE_PAGES, vcpu);</yellow>

	/* in case we halted in L2 */
	svm-&gt;vcpu.arch.mp_state = KVM_MP_STATE_RUNNABLE;

	/* Give the current vmcb to the guest */

	vmcb12-&gt;save.es     = vmcb02-&gt;save.es;
	vmcb12-&gt;save.cs     = vmcb02-&gt;save.cs;
	vmcb12-&gt;save.ss     = vmcb02-&gt;save.ss;
	vmcb12-&gt;save.ds     = vmcb02-&gt;save.ds;
	vmcb12-&gt;save.gdtr   = vmcb02-&gt;save.gdtr;
	vmcb12-&gt;save.idtr   = vmcb02-&gt;save.idtr;
	vmcb12-&gt;save.efer   = svm-&gt;vcpu.arch.efer;
<yellow>	vmcb12->save.cr0    = kvm_read_cr0(vcpu);</yellow>
<yellow>	vmcb12->save.cr3    = kvm_read_cr3(vcpu);</yellow>
	vmcb12-&gt;save.cr2    = vmcb02-&gt;save.cr2;
	vmcb12-&gt;save.cr4    = svm-&gt;vcpu.arch.cr4;
	vmcb12-&gt;save.rflags = kvm_get_rflags(vcpu);
<yellow>	vmcb12->save.rip    = kvm_rip_read(vcpu);</yellow>
<yellow>	vmcb12->save.rsp    = kvm_rsp_read(vcpu);</yellow>
	vmcb12-&gt;save.rax    = kvm_rax_read(vcpu);
	vmcb12-&gt;save.dr7    = vmcb02-&gt;save.dr7;
	vmcb12-&gt;save.dr6    = svm-&gt;vcpu.arch.dr6;
	vmcb12-&gt;save.cpl    = vmcb02-&gt;save.cpl;

	vmcb12-&gt;control.int_state         = vmcb02-&gt;control.int_state;
	vmcb12-&gt;control.exit_code         = vmcb02-&gt;control.exit_code;
	vmcb12-&gt;control.exit_code_hi      = vmcb02-&gt;control.exit_code_hi;
	vmcb12-&gt;control.exit_info_1       = vmcb02-&gt;control.exit_info_1;
	vmcb12-&gt;control.exit_info_2       = vmcb02-&gt;control.exit_info_2;

	if (vmcb12-&gt;control.exit_code != SVM_EXIT_ERR)
<yellow>		nested_save_pending_event_to_vmcb12(svm, vmcb12);</yellow>

<yellow>	if (svm->nrips_enabled)</yellow>
<yellow>		vmcb12->control.next_rip  = vmcb02->control.next_rip;</yellow>

<yellow>	vmcb12->control.int_ctl           = svm->nested.ctl.int_ctl;</yellow>
	vmcb12-&gt;control.event_inj         = svm-&gt;nested.ctl.event_inj;
	vmcb12-&gt;control.event_inj_err     = svm-&gt;nested.ctl.event_inj_err;

<yellow>	if (!kvm_pause_in_guest(vcpu->kvm)) {</yellow>
<yellow>		vmcb01->control.pause_filter_count = vmcb02->control.pause_filter_count;</yellow>
		vmcb_mark_dirty(vmcb01, VMCB_INTERCEPTS);

	}

<yellow>	nested_svm_copy_common_state(svm->nested.vmcb02.ptr, svm->vmcb01.ptr);</yellow>

	svm_switch_vmcb(svm, &amp;svm-&gt;vmcb01);

	/*
	 * Rules for synchronizing int_ctl bits from vmcb02 to vmcb01:
	 *
	 * V_IRQ, V_IRQ_VECTOR, V_INTR_PRIO_MASK, V_IGN_TPR:  If L1 doesn&#x27;t
	 * intercept interrupts, then KVM will use vmcb02&#x27;s V_IRQ (and related
	 * flags) to detect interrupt windows for L1 IRQs (even if L1 uses
	 * virtual interrupt masking).  Raise KVM_REQ_EVENT to ensure that
	 * KVM re-requests an interrupt window if necessary, which implicitly
	 * copies this bits from vmcb02 to vmcb01.
	 *
	 * V_TPR: If L1 doesn&#x27;t use virtual interrupt masking, then L1&#x27;s vTPR
	 * is stored in vmcb02, but its value doesn&#x27;t need to be copied from/to
	 * vmcb01 because it is copied from/to the virtual APIC&#x27;s TPR register
	 * on each VM entry/exit.
	 *
	 * V_GIF: If nested vGIF is not used, KVM uses vmcb02&#x27;s V_GIF for L1&#x27;s
	 * V_GIF.  However, GIF is architecturally clear on each VM exit, thus
	 * there is no need to copy V_GIF from vmcb02 to vmcb01.
	 */
	if (!nested_exit_on_intr(svm))
<yellow>		kvm_make_request(KVM_REQ_EVENT, &svm->vcpu);</yellow>

<yellow>	if (unlikely(svm->lbrv_enabled && (svm->nested.ctl.virt_ext & LBR_CTL_ENABLE_MASK))) {</yellow>
<yellow>		svm_copy_lbrs(vmcb12, vmcb02);</yellow>
		svm_update_lbrv(vcpu);
<yellow>	} else if (unlikely(vmcb01->control.virt_ext & LBR_CTL_ENABLE_MASK)) {</yellow>
<yellow>		svm_copy_lbrs(vmcb01, vmcb02);</yellow>
		svm_update_lbrv(vcpu);
	}

<yellow>	if (vnmi) {</yellow>
<yellow>		if (vmcb02->control.int_ctl & V_NMI_BLOCKING_MASK)</yellow>
<yellow>			vmcb01->control.int_ctl |= V_NMI_BLOCKING_MASK;</yellow>
		else
<yellow>			vmcb01->control.int_ctl &= ~V_NMI_BLOCKING_MASK;</yellow>

<yellow>		if (vcpu->arch.nmi_pending) {</yellow>
<yellow>			vcpu->arch.nmi_pending--;</yellow>
			vmcb01-&gt;control.int_ctl |= V_NMI_PENDING_MASK;
		} else {
<yellow>			vmcb01->control.int_ctl &= ~V_NMI_PENDING_MASK;</yellow>
		}
	}

	/*
	 * On vmexit the  GIF is set to false and
	 * no event can be injected in L1.
	 */
<yellow>	svm_set_gif(svm, false);</yellow>
	vmcb01-&gt;control.exit_int_info = 0;

	svm-&gt;vcpu.arch.tsc_offset = svm-&gt;vcpu.arch.l1_tsc_offset;
	if (vmcb01-&gt;control.tsc_offset != svm-&gt;vcpu.arch.tsc_offset) {
		vmcb01-&gt;control.tsc_offset = svm-&gt;vcpu.arch.tsc_offset;
<yellow>		vmcb_mark_dirty(vmcb01, VMCB_INTERCEPTS);</yellow>
	}

<yellow>	if (svm->tsc_ratio_msr != kvm_caps.default_tsc_scaling_ratio) {</yellow>
<yellow>		WARN_ON(!svm->tsc_scaling_enabled);</yellow>
<yellow>		vcpu->arch.tsc_scaling_ratio = vcpu->arch.l1_tsc_scaling_ratio;</yellow>
		__svm_write_tsc_multiplier(vcpu-&gt;arch.tsc_scaling_ratio);
	}

<yellow>	svm->nested.ctl.nested_cr3 = 0;</yellow>

	/*
	 * Restore processor state that had been saved in vmcb01
	 */
	kvm_set_rflags(vcpu, vmcb01-&gt;save.rflags);
	svm_set_efer(vcpu, vmcb01-&gt;save.efer);
	svm_set_cr0(vcpu, vmcb01-&gt;save.cr0 | X86_CR0_PE);
	svm_set_cr4(vcpu, vmcb01-&gt;save.cr4);
	kvm_rax_write(vcpu, vmcb01-&gt;save.rax);
	kvm_rsp_write(vcpu, vmcb01-&gt;save.rsp);
	kvm_rip_write(vcpu, vmcb01-&gt;save.rip);

	svm-&gt;vcpu.arch.dr7 = DR7_FIXED_1;
	kvm_update_dr7(&amp;svm-&gt;vcpu);

<yellow>	trace_kvm_nested_vmexit_inject(vmcb12->control.exit_code,</yellow>
				       vmcb12-&gt;control.exit_info_1,
				       vmcb12-&gt;control.exit_info_2,
				       vmcb12-&gt;control.exit_int_info,
				       vmcb12-&gt;control.exit_int_info_err,
				       KVM_ISA_SVM);

<yellow>	kvm_vcpu_unmap(vcpu, &map, true);</yellow>

	nested_svm_transition_tlb_flush(vcpu);

	nested_svm_uninit_mmu_context(vcpu);

	rc = nested_svm_load_cr3(vcpu, vmcb01-&gt;save.cr3, false, true);
	if (rc)
		return 1;

	/*
	 * Drop what we picked up for L2 via svm_complete_interrupts() so it
	 * doesn&#x27;t end up in L1.
	 */
<yellow>	svm->vcpu.arch.nmi_injected = false;</yellow>
	kvm_clear_exception_queue(vcpu);
	kvm_clear_interrupt_queue(vcpu);

	/*
	 * If we are here following the completion of a VMRUN that
	 * is being single-stepped, queue the pending #DB intercept
	 * right now so that it an be accounted for before we execute
	 * L1&#x27;s next instruction.
	 */
	if (unlikely(vmcb01-&gt;save.rflags &amp; X86_EFLAGS_TF))
<yellow>		kvm_queue_exception(&(svm->vcpu), DB_VECTOR);</yellow>

	/*
	 * Un-inhibit the AVIC right away, so that other vCPUs can start
	 * to benefit from it right away.
	 */
<yellow>	if (kvm_apicv_activated(vcpu->kvm))</yellow>
<yellow>		__kvm_vcpu_update_apicv(vcpu);</yellow>

	return 0;
}

<yellow>static void nested_svm_triple_fault(struct kvm_vcpu *vcpu)</yellow>
{
	struct vcpu_svm *svm = to_svm(vcpu);

<yellow>	if (!vmcb12_is_intercept(&svm->nested.ctl, INTERCEPT_SHUTDOWN))</yellow>
		return;

<yellow>	kvm_clear_request(KVM_REQ_TRIPLE_FAULT, vcpu);</yellow>
	nested_svm_simple_vmexit(to_svm(vcpu), SVM_EXIT_SHUTDOWN);
<yellow>}</yellow>

int svm_allocate_nested(struct vcpu_svm *svm)
{
	struct page *vmcb02_page;

<blue>	if (svm->nested.initialized)</blue>
		return 0;

<blue>	vmcb02_page = alloc_page(GFP_KERNEL_ACCOUNT | __GFP_ZERO);</blue>
	if (!vmcb02_page)
		return -ENOMEM;
<blue>	svm->nested.vmcb02.ptr = page_address(vmcb02_page);</blue>
	svm-&gt;nested.vmcb02.pa = __sme_set(page_to_pfn(vmcb02_page) &lt;&lt; PAGE_SHIFT);

	svm-&gt;nested.msrpm = svm_vcpu_alloc_msrpm();
	if (!svm-&gt;nested.msrpm)
		goto err_free_vmcb02;
<blue>	svm_vcpu_init_msrpm(&svm->vcpu, svm->nested.msrpm);</blue>

	svm-&gt;nested.initialized = true;
	return 0;

err_free_vmcb02:
<yellow>	__free_page(vmcb02_page);</yellow>
	return -ENOMEM;
<yellow>}</yellow>

void svm_free_nested(struct vcpu_svm *svm)
{
<blue>	if (!svm->nested.initialized)</blue>
		return;

<blue>	if (WARN_ON_ONCE(svm->vmcb != svm->vmcb01.ptr))</blue>
		svm_switch_vmcb(svm, &amp;svm-&gt;vmcb01);

<blue>	svm_vcpu_free_msrpm(svm->nested.msrpm);</blue>
	svm-&gt;nested.msrpm = NULL;

	__free_page(virt_to_page(svm-&gt;nested.vmcb02.ptr));
	svm-&gt;nested.vmcb02.ptr = NULL;

	/*
	 * When last_vmcb12_gpa matches the current vmcb12 gpa,
	 * some vmcb12 fields are not loaded if they are marked clean
	 * in the vmcb12, since in this case they are up to date already.
	 *
	 * When the vmcb02 is freed, this optimization becomes invalid.
	 */
	svm-&gt;nested.last_vmcb12_gpa = INVALID_GPA;

	svm-&gt;nested.initialized = false;
<yellow>}</yellow>

void svm_leave_nested(struct kvm_vcpu *vcpu)
{
	struct vcpu_svm *svm = to_svm(vcpu);

<blue>	if (is_guest_mode(vcpu)) {</blue>
<yellow>		svm->nested.nested_run_pending = 0;</yellow>
		svm-&gt;nested.vmcb12_gpa = INVALID_GPA;

<yellow>		leave_guest_mode(vcpu);</yellow>

		svm_switch_vmcb(svm, &amp;svm-&gt;vmcb01);

		nested_svm_uninit_mmu_context(vcpu);
		vmcb_mark_all_dirty(svm-&gt;vmcb);
	}

<blue>	kvm_clear_request(KVM_REQ_GET_NESTED_STATE_PAGES, vcpu);</blue>
}

static int nested_svm_exit_handled_msr(struct vcpu_svm *svm)
{
	u32 offset, msr, value;
	int write, mask;

<yellow>	if (!(vmcb12_is_intercept(&svm->nested.ctl, INTERCEPT_MSR_PROT)))</yellow>
		return NESTED_EXIT_HOST;

<yellow>	msr    = svm->vcpu.arch.regs[VCPU_REGS_RCX];</yellow>
	offset = svm_msrpm_offset(msr);
	write  = svm-&gt;vmcb-&gt;control.exit_info_1 &amp; 1;
<yellow>	mask   = 1 << ((2 * (msr & 0xf)) + write);</yellow>

	if (offset == MSR_INVALID)
		return NESTED_EXIT_DONE;

	/* Offset is in 32 bit units but need in 8 bit units */
	offset *= 4;

<yellow>	if (kvm_vcpu_read_guest(&svm->vcpu, svm->nested.ctl.msrpm_base_pa + offset, &value, 4))</yellow>
		return NESTED_EXIT_DONE;

	return (value &amp; mask) ? NESTED_EXIT_DONE : NESTED_EXIT_HOST;
}

static int nested_svm_intercept_ioio(struct vcpu_svm *svm)
{
	unsigned port, size, iopm_len;
	u16 val, mask;
	u8 start_bit;
	u64 gpa;

<yellow>	if (!(vmcb12_is_intercept(&svm->nested.ctl, INTERCEPT_IOIO_PROT)))</yellow>
		return NESTED_EXIT_HOST;

<yellow>	port = svm->vmcb->control.exit_info_1 >> 16;</yellow>
	size = (svm-&gt;vmcb-&gt;control.exit_info_1 &amp; SVM_IOIO_SIZE_MASK) &gt;&gt;
		SVM_IOIO_SIZE_SHIFT;
	gpa  = svm-&gt;nested.ctl.iopm_base_pa + (port / 8);
	start_bit = port % 8;
	iopm_len = (start_bit + size &gt; 8) ? 2 : 1;
<yellow>	mask = (0xf >> (4 - size)) << start_bit;</yellow>
<yellow>	val = 0;</yellow>

	if (kvm_vcpu_read_guest(&amp;svm-&gt;vcpu, gpa, &amp;val, iopm_len))
		return NESTED_EXIT_DONE;

	return (val &amp; mask) ? NESTED_EXIT_DONE : NESTED_EXIT_HOST;
}

static int nested_svm_intercept(struct vcpu_svm *svm)
{
<yellow>	u32 exit_code = svm->vmcb->control.exit_code;</yellow>
	int vmexit = NESTED_EXIT_HOST;

	switch (exit_code) {
	case SVM_EXIT_MSR:
<yellow>		vmexit = nested_svm_exit_handled_msr(svm);</yellow>
		break;
	case SVM_EXIT_IOIO:
<yellow>		vmexit = nested_svm_intercept_ioio(svm);</yellow>
		break;
	case SVM_EXIT_READ_CR0 ... SVM_EXIT_WRITE_CR8: {
		if (vmcb12_is_intercept(&amp;svm-&gt;nested.ctl, exit_code))
			vmexit = NESTED_EXIT_DONE;
		break;
	}
	case SVM_EXIT_READ_DR0 ... SVM_EXIT_WRITE_DR7: {
<yellow>		if (vmcb12_is_intercept(&svm->nested.ctl, exit_code))</yellow>
			vmexit = NESTED_EXIT_DONE;
		break;
	}
	case SVM_EXIT_EXCP_BASE ... SVM_EXIT_EXCP_BASE + 0x1f: {
		/*
		 * Host-intercepted exceptions have been checked already in
		 * nested_svm_exit_special.  There is nothing to do here,
		 * the vmexit is injected by svm_check_nested_events.
		 */
		vmexit = NESTED_EXIT_DONE;
		break;
	}
	case SVM_EXIT_ERR: {
		vmexit = NESTED_EXIT_DONE;
		break;
	}
	default: {
<yellow>		if (vmcb12_is_intercept(&svm->nested.ctl, exit_code))</yellow>
			vmexit = NESTED_EXIT_DONE;
	}
	}

	return vmexit;
}

int nested_svm_exit_handled(struct vcpu_svm *svm)
<yellow>{</yellow>
	int vmexit;

<yellow>	vmexit = nested_svm_intercept(svm);</yellow>

<yellow>	if (vmexit == NESTED_EXIT_DONE)</yellow>
<yellow>		nested_svm_vmexit(svm);</yellow>

	return vmexit;
}

int nested_svm_check_permissions(struct kvm_vcpu *vcpu)
{
<blue>	if (!(vcpu->arch.efer & EFER_SVME) || !is_paging(vcpu)) {</blue>
<blue>		kvm_queue_exception(vcpu, UD_VECTOR);</blue>
<blue>		return 1;</blue>
	}

<yellow>	if (to_svm(vcpu)->vmcb->save.cpl) {</yellow>
<yellow>		kvm_inject_gp(vcpu, 0);</yellow>
		return 1;
	}

	return 0;
<yellow>}</yellow>

static bool nested_svm_is_exception_vmexit(struct kvm_vcpu *vcpu, u8 vector,
					   u32 error_code)
{
	struct vcpu_svm *svm = to_svm(vcpu);

<yellow>	return (svm->nested.ctl.intercepts[INTERCEPT_EXCEPTION] & BIT(vector));</yellow>
}

static void nested_svm_inject_exception_vmexit(struct kvm_vcpu *vcpu)
{
	struct kvm_queued_exception *ex = &amp;vcpu-&gt;arch.exception_vmexit;
	struct vcpu_svm *svm = to_svm(vcpu);
<yellow>	struct vmcb *vmcb = svm->vmcb;</yellow>

	vmcb-&gt;control.exit_code = SVM_EXIT_EXCP_BASE + ex-&gt;vector;
	vmcb-&gt;control.exit_code_hi = 0;

<yellow>	if (ex->has_error_code)</yellow>
<yellow>		vmcb->control.exit_info_1 = ex->error_code;</yellow>

	/*
	 * EXITINFO2 is undefined for all exception intercepts other
	 * than #PF.
	 */
<yellow>	if (ex->vector == PF_VECTOR) {</yellow>
<yellow>		if (ex->has_payload)</yellow>
<yellow>			vmcb->control.exit_info_2 = ex->payload;</yellow>
		else
<yellow>			vmcb->control.exit_info_2 = vcpu->arch.cr2;</yellow>
<yellow>	} else if (ex->vector == DB_VECTOR) {</yellow>
		/* See kvm_check_and_inject_events().  */
<yellow>		kvm_deliver_exception_payload(vcpu, ex);</yellow>

		if (vcpu-&gt;arch.dr7 &amp; DR7_GD) {
<yellow>			vcpu->arch.dr7 &= ~DR7_GD;</yellow>
			kvm_update_dr7(vcpu);
		}
	} else {
<yellow>		WARN_ON(ex->has_payload);</yellow>
	}

<yellow>	nested_svm_vmexit(svm);</yellow>
}

static inline bool nested_exit_on_init(struct vcpu_svm *svm)
{
<yellow>	return vmcb12_is_intercept(&svm->nested.ctl, INTERCEPT_INIT);</yellow>
}

static int svm_check_nested_events(struct kvm_vcpu *vcpu)
{
<yellow>	struct kvm_lapic *apic = vcpu->arch.apic;</yellow>
	struct vcpu_svm *svm = to_svm(vcpu);
	/*
	 * Only a pending nested run blocks a pending exception.  If there is a
	 * previously injected event, the pending exception occurred while said
	 * event was being delivered and thus needs to be handled.
	 */
<yellow>	bool block_nested_exceptions = svm->nested.nested_run_pending;</yellow>
	/*
	 * New events (not exceptions) are only recognized at instruction
	 * boundaries.  If an event needs reinjection, then KVM is handling a
	 * VM-Exit that occurred _during_ instruction execution; new events are
	 * blocked until the instruction completes.
	 */
	bool block_nested_events = block_nested_exceptions ||
<yellow>				   kvm_event_needs_reinjection(vcpu);</yellow>

<yellow>	if (lapic_in_kernel(vcpu) &&</yellow>
<yellow>	    test_bit(KVM_APIC_INIT, &apic->pending_events)) {</yellow>
<yellow>		if (block_nested_events)</yellow>
			return -EBUSY;
<yellow>		if (!nested_exit_on_init(svm))</yellow>
			return 0;
<yellow>		nested_svm_simple_vmexit(svm, SVM_EXIT_INIT);</yellow>
		return 0;
	}

<yellow>	if (vcpu->arch.exception_vmexit.pending) {</yellow>
<yellow>		if (block_nested_exceptions)</yellow>
                        return -EBUSY;
<yellow>		nested_svm_inject_exception_vmexit(vcpu);</yellow>
		return 0;
	}

<yellow>	if (vcpu->arch.exception.pending) {</yellow>
<yellow>		if (block_nested_exceptions)</yellow>
			return -EBUSY;
		return 0;
	}

#ifdef CONFIG_KVM_SMM
<yellow>	if (vcpu->arch.smi_pending && !svm_smi_blocked(vcpu)) {</yellow>
<yellow>		if (block_nested_events)</yellow>
			return -EBUSY;
<yellow>		if (!nested_exit_on_smi(svm))</yellow>
			return 0;
<yellow>		nested_svm_simple_vmexit(svm, SVM_EXIT_SMI);</yellow>
		return 0;
	}
#endif

<yellow>	if (vcpu->arch.nmi_pending && !svm_nmi_blocked(vcpu)) {</yellow>
<yellow>		if (block_nested_events)</yellow>
			return -EBUSY;
<yellow>		if (!nested_exit_on_nmi(svm))</yellow>
			return 0;
<yellow>		nested_svm_simple_vmexit(svm, SVM_EXIT_NMI);</yellow>
		return 0;
	}

<yellow>	if (kvm_cpu_has_interrupt(vcpu) && !svm_interrupt_blocked(vcpu)) {</yellow>
<yellow>		if (block_nested_events)</yellow>
			return -EBUSY;
<yellow>		if (!nested_exit_on_intr(svm))</yellow>
			return 0;
<yellow>		trace_kvm_nested_intr_vmexit(svm->vmcb->save.rip);</yellow>
<yellow>		nested_svm_simple_vmexit(svm, SVM_EXIT_INTR);</yellow>
		return 0;
	}

	return 0;
<yellow>}</yellow>

int nested_svm_exit_special(struct vcpu_svm *svm)
<yellow>{</yellow>
<yellow>	u32 exit_code = svm->vmcb->control.exit_code;</yellow>
	struct kvm_vcpu *vcpu = &amp;svm-&gt;vcpu;

	switch (exit_code) {
	case SVM_EXIT_INTR:
	case SVM_EXIT_NMI:
	case SVM_EXIT_NPF:
		return NESTED_EXIT_HOST;
	case SVM_EXIT_EXCP_BASE ... SVM_EXIT_EXCP_BASE + 0x1f: {
		u32 excp_bits = 1 &lt;&lt; (exit_code - SVM_EXIT_EXCP_BASE);

<yellow>		if (svm->vmcb01.ptr->control.intercepts[INTERCEPT_EXCEPTION] &</yellow>
		    excp_bits)
			return NESTED_EXIT_HOST;
<yellow>		else if (exit_code == SVM_EXIT_EXCP_BASE + PF_VECTOR &&</yellow>
<yellow>			 svm->vcpu.arch.apf.host_apf_flags)</yellow>
			/* Trap async PF even if not shadowing */
			return NESTED_EXIT_HOST;
		break;
	}
	case SVM_EXIT_VMMCALL:
		/* Hyper-V L2 TLB flush hypercall is handled by L0 */
<yellow>		if (guest_hv_cpuid_has_l2_tlb_flush(vcpu) &&</yellow>
<yellow>		    nested_svm_l2_tlb_flush_enabled(vcpu) &&</yellow>
<yellow>		    kvm_hv_is_tlb_flush_hcall(vcpu))</yellow>
			return NESTED_EXIT_HOST;
		break;
	default:
		break;
	}

	return NESTED_EXIT_CONTINUE;
}

void nested_svm_update_tsc_ratio_msr(struct kvm_vcpu *vcpu)
{
	struct vcpu_svm *svm = to_svm(vcpu);

	vcpu-&gt;arch.tsc_scaling_ratio =
<yellow>		kvm_calc_nested_tsc_multiplier(vcpu->arch.l1_tsc_scaling_ratio,</yellow>
					       svm-&gt;tsc_ratio_msr);
	__svm_write_tsc_multiplier(vcpu-&gt;arch.tsc_scaling_ratio);
}

/* Inverse operation of nested_copy_vmcb_control_to_cache(). asid is copied too. */
static void nested_copy_vmcb_cache_to_control(struct vmcb_control_area *dst,
					      struct vmcb_ctrl_area_cached *from)
{
	unsigned int i;

<yellow>	memset(dst, 0, sizeof(struct vmcb_control_area));</yellow>

	for (i = 0; i &lt; MAX_INTERCEPT; i++)
<yellow>		dst->intercepts[i] = from->intercepts[i];</yellow>

<yellow>	dst->iopm_base_pa         = from->iopm_base_pa;</yellow>
	dst-&gt;msrpm_base_pa        = from-&gt;msrpm_base_pa;
	dst-&gt;tsc_offset           = from-&gt;tsc_offset;
	dst-&gt;asid                 = from-&gt;asid;
	dst-&gt;tlb_ctl              = from-&gt;tlb_ctl;
	dst-&gt;int_ctl              = from-&gt;int_ctl;
	dst-&gt;int_vector           = from-&gt;int_vector;
	dst-&gt;int_state            = from-&gt;int_state;
	dst-&gt;exit_code            = from-&gt;exit_code;
	dst-&gt;exit_code_hi         = from-&gt;exit_code_hi;
	dst-&gt;exit_info_1          = from-&gt;exit_info_1;
	dst-&gt;exit_info_2          = from-&gt;exit_info_2;
	dst-&gt;exit_int_info        = from-&gt;exit_int_info;
	dst-&gt;exit_int_info_err    = from-&gt;exit_int_info_err;
	dst-&gt;nested_ctl           = from-&gt;nested_ctl;
	dst-&gt;event_inj            = from-&gt;event_inj;
	dst-&gt;event_inj_err        = from-&gt;event_inj_err;
	dst-&gt;next_rip             = from-&gt;next_rip;
	dst-&gt;nested_cr3           = from-&gt;nested_cr3;
	dst-&gt;virt_ext              = from-&gt;virt_ext;
	dst-&gt;pause_filter_count   = from-&gt;pause_filter_count;
	dst-&gt;pause_filter_thresh  = from-&gt;pause_filter_thresh;
	/* &#x27;clean&#x27; and &#x27;hv_enlightenments&#x27; are not changed by KVM */
}

static int svm_get_nested_state(struct kvm_vcpu *vcpu,
				struct kvm_nested_state __user *user_kvm_nested_state,
				u32 user_data_size)
<yellow>{</yellow>
	struct vcpu_svm *svm;
	struct vmcb_control_area *ctl;
	unsigned long r;
<blue>	struct kvm_nested_state kvm_state = {</blue>
		.flags = 0,
		.format = KVM_STATE_NESTED_FORMAT_SVM,
		.size = sizeof(kvm_state),
	};
<yellow>	struct vmcb __user *user_vmcb = (struct vmcb __user *)</yellow>
		&amp;user_kvm_nested_state-&gt;data.svm[0];

	if (!vcpu)
		return kvm_state.size + KVM_STATE_NESTED_SVM_VMCB_SIZE;

	svm = to_svm(vcpu);

<blue>	if (user_data_size < kvm_state.size)</blue>
		goto out;

	/* First fill in the header and copy it out.  */
<blue>	if (is_guest_mode(vcpu)) {</blue>
<yellow>		kvm_state.hdr.svm.vmcb_pa = svm->nested.vmcb12_gpa;</yellow>
		kvm_state.size += KVM_STATE_NESTED_SVM_VMCB_SIZE;
		kvm_state.flags |= KVM_STATE_NESTED_GUEST_MODE;

<yellow>		if (svm->nested.nested_run_pending)</yellow>
<yellow>			kvm_state.flags |= KVM_STATE_NESTED_RUN_PENDING;</yellow>
	}

<blue>	if (gif_set(svm))</blue>
<blue>		kvm_state.flags |= KVM_STATE_NESTED_GIF_SET;</blue>

<blue>	if (copy_to_user(user_kvm_nested_state, &kvm_state, sizeof(kvm_state)))</blue>
		return -EFAULT;

<blue>	if (!is_guest_mode(vcpu))</blue>
		goto out;

	/*
	 * Copy over the full size of the VMCB rather than just the size
	 * of the structs.
	 */
<yellow>	if (clear_user(user_vmcb, KVM_STATE_NESTED_SVM_VMCB_SIZE))</yellow>
		return -EFAULT;

<yellow>	ctl = kzalloc(sizeof(*ctl), GFP_KERNEL);</yellow>
	if (!ctl)
		return -ENOMEM;

<yellow>	nested_copy_vmcb_cache_to_control(ctl, &svm->nested.ctl);</yellow>
	r = copy_to_user(&amp;user_vmcb-&gt;control, ctl,
			 sizeof(user_vmcb-&gt;control));
	kfree(ctl);
	if (r)
		return -EFAULT;

<yellow>	if (copy_to_user(&user_vmcb->save, &svm->vmcb01.ptr->save,</yellow>
			 sizeof(user_vmcb-&gt;save)))
		return -EFAULT;
out:
<blue>	return kvm_state.size;</blue>
}

static int svm_set_nested_state(struct kvm_vcpu *vcpu,
				struct kvm_nested_state __user *user_kvm_nested_state,
				struct kvm_nested_state *kvm_state)
<yellow>{</yellow>
	struct vcpu_svm *svm = to_svm(vcpu);
	struct vmcb __user *user_vmcb = (struct vmcb __user *)
		&amp;user_kvm_nested_state-&gt;data.svm[0];
	struct vmcb_control_area *ctl;
	struct vmcb_save_area *save;
	struct vmcb_save_area_cached save_cached;
	struct vmcb_ctrl_area_cached ctl_cached;
	unsigned long cr0;
	int ret;

	BUILD_BUG_ON(sizeof(struct vmcb_control_area) + sizeof(struct vmcb_save_area) &gt;
		     KVM_STATE_NESTED_SVM_VMCB_SIZE);

<blue>	if (kvm_state->format != KVM_STATE_NESTED_FORMAT_SVM)</blue>
		return -EINVAL;

<blue>	if (kvm_state->flags & ~(KVM_STATE_NESTED_GUEST_MODE |</blue>
				 KVM_STATE_NESTED_RUN_PENDING |
				 KVM_STATE_NESTED_GIF_SET))
		return -EINVAL;

	/*
	 * If in guest mode, vcpu-&gt;arch.efer actually refers to the L2 guest&#x27;s
	 * EFER.SVME, but EFER.SVME still has to be 1 for VMRUN to succeed.
	 */
<blue>	if (!(vcpu->arch.efer & EFER_SVME)) {</blue>
		/* GIF=1 and no guest mode are required if SVME=0.  */
<blue>		if (kvm_state->flags != KVM_STATE_NESTED_GIF_SET)</blue>
			return -EINVAL;
	}

	/* SMM temporarily disables SVM, so we cannot be in guest mode.  */
<yellow>	if (is_smm(vcpu) && (kvm_state->flags & KVM_STATE_NESTED_GUEST_MODE))</yellow>
		return -EINVAL;

<yellow>	if (!(kvm_state->flags & KVM_STATE_NESTED_GUEST_MODE)) {</yellow>
<yellow>		svm_leave_nested(vcpu);</yellow>
		svm_set_gif(svm, !!(kvm_state-&gt;flags &amp; KVM_STATE_NESTED_GIF_SET));
		return 0;
	}

<yellow>	if (!page_address_valid(vcpu, kvm_state->hdr.svm.vmcb_pa))</yellow>
		return -EINVAL;
<yellow>	if (kvm_state->size < sizeof(*kvm_state) + KVM_STATE_NESTED_SVM_VMCB_SIZE)</yellow>
		return -EINVAL;

	ret  = -ENOMEM;
<yellow>	ctl  = kzalloc(sizeof(*ctl),  GFP_KERNEL_ACCOUNT);</yellow>
	save = kzalloc(sizeof(*save), GFP_KERNEL_ACCOUNT);
<yellow>	if (!ctl || !save)</yellow>
		goto out_free;

	ret = -EFAULT;
<yellow>	if (copy_from_user(ctl, &user_vmcb->control, sizeof(*ctl)))</yellow>
		goto out_free;
<yellow>	if (copy_from_user(save, &user_vmcb->save, sizeof(*save)))</yellow>
		goto out_free;

	ret = -EINVAL;
<yellow>	__nested_copy_vmcb_control_to_cache(vcpu, &ctl_cached, ctl);</yellow>
	if (!__nested_vmcb_check_controls(vcpu, &amp;ctl_cached))
		goto out_free;

	/*
	 * Processor state contains L2 state.  Check that it is
	 * valid for guest mode (see nested_vmcb_check_save).
	 */
<yellow>	cr0 = kvm_read_cr0(vcpu);</yellow>
        if (((cr0 &amp; X86_CR0_CD) == 0) &amp;&amp; (cr0 &amp; X86_CR0_NW))
		goto out_free;

	/*
	 * Validate host state saved from before VMRUN (see
	 * nested_svm_check_permissions).
	 */
<yellow>	__nested_copy_vmcb_save_to_cache(&save_cached, save);</yellow>
	if (!(save-&gt;cr0 &amp; X86_CR0_PG) ||
	    !(save-&gt;cr0 &amp; X86_CR0_PE) ||
<yellow>	    (save->rflags & X86_EFLAGS_VM) ||</yellow>
<yellow>	    !__nested_vmcb_check_save(vcpu, &save_cached))</yellow>
		goto out_free;


	/*
	 * All checks done, we can enter guest mode. Userspace provides
	 * vmcb12.control, which will be combined with L1 and stored into
	 * vmcb02, and the L1 save state which we store in vmcb01.
	 * L2 registers if needed are moved from the current VMCB to VMCB02.
	 */

<yellow>	if (is_guest_mode(vcpu))</yellow>
<yellow>		svm_leave_nested(vcpu);</yellow>
	else
<yellow>		svm->nested.vmcb02.ptr->save = svm->vmcb01.ptr->save;</yellow>

<yellow>	svm_set_gif(svm, !!(kvm_state->flags & KVM_STATE_NESTED_GIF_SET));</yellow>

	svm-&gt;nested.nested_run_pending =
		!!(kvm_state-&gt;flags &amp; KVM_STATE_NESTED_RUN_PENDING);

	svm-&gt;nested.vmcb12_gpa = kvm_state-&gt;hdr.svm.vmcb_pa;

	svm_copy_vmrun_state(&amp;svm-&gt;vmcb01.ptr-&gt;save, save);
	nested_copy_vmcb_control_to_cache(svm, ctl);

	svm_switch_vmcb(svm, &amp;svm-&gt;nested.vmcb02);
	nested_vmcb02_prepare_control(svm, svm-&gt;vmcb-&gt;save.rip, svm-&gt;vmcb-&gt;save.cs.base);

	/*
	 * While the nested guest CR3 is already checked and set by
	 * KVM_SET_SREGS, it was set when nested state was yet loaded,
	 * thus MMU might not be initialized correctly.
	 * Set it again to fix this.
	 */

	ret = nested_svm_load_cr3(&amp;svm-&gt;vcpu, vcpu-&gt;arch.cr3,
				  nested_npt_enabled(svm), false);
<yellow>	if (WARN_ON_ONCE(ret))</yellow>
		goto out_free;

<yellow>	svm->nested.force_msr_bitmap_recalc = true;</yellow>

	kvm_make_request(KVM_REQ_GET_NESTED_STATE_PAGES, vcpu);
	ret = 0;
out_free:
<yellow>	kfree(save);</yellow>
	kfree(ctl);

	return ret;
}

static bool svm_get_nested_state_pages(struct kvm_vcpu *vcpu)
{
	struct vcpu_svm *svm = to_svm(vcpu);

<yellow>	if (WARN_ON(!is_guest_mode(vcpu)))</yellow>
		return true;

<yellow>	if (!vcpu->arch.pdptrs_from_userspace &&</yellow>
<yellow>	    !nested_npt_enabled(svm) && is_pae_paging(vcpu))</yellow>
		/*
		 * Reload the guest&#x27;s PDPTRs since after a migration
		 * the guest CR3 might be restored prior to setting the nested
		 * state which can lead to a load of wrong PDPTRs.
		 */
<yellow>		if (CC(!load_pdptrs(vcpu, vcpu->arch.cr3)))</yellow>
<yellow>			return false;</yellow>

<yellow>	if (!nested_svm_vmrun_msrpm(svm)) {</yellow>
<yellow>		vcpu->run->exit_reason = KVM_EXIT_INTERNAL_ERROR;</yellow>
		vcpu-&gt;run-&gt;internal.suberror =
			KVM_INTERNAL_ERROR_EMULATION;
		vcpu-&gt;run-&gt;internal.ndata = 0;
		return false;
	}

<yellow>	if (kvm_hv_verify_vp_assist(vcpu))</yellow>
		return false;

	return true;
<yellow>}</yellow>

struct kvm_x86_nested_ops svm_nested_ops = {
	.leave_nested = svm_leave_nested,
	.is_exception_vmexit = nested_svm_is_exception_vmexit,
	.check_events = svm_check_nested_events,
	.triple_fault = nested_svm_triple_fault,
	.get_nested_state_pages = svm_get_nested_state_pages,
	.get_state = svm_get_nested_state,
	.set_state = svm_set_nested_state,
	.hv_inject_synthetic_vmexit_post_tlb_flush = svm_hv_inject_synthetic_vmexit_post_tlb_flush,
};

    </code></pre></td></tr></table>
    </div><script>const fileList = document.getElementById('file_list')
fileList.innerHTML+=`<li><yellow>baseline covered, syzkaller not covered</yellow></li><li><blue>baseline covered, syzkaller covered</blue></li><li><red>baseline not covered, syzkaller covered</red></li>`
fileList.innerHTML+=`<li>vmx<ul>
<li><a href="../vmx/baseline_all.html">baseline_all</a></li>
<li><a href="../vmx/baseline_syzkaller.html">baseline_syzkaller</a></li>
<li><a href="../vmx/all_wo-harness.html">all_wo-harness</a></li>
<li><a href="../vmx/all_wo-config.html">all_wo-config</a></li>
<li><a href="../vmx/all_wo-validator.html">all_wo-validator</a></li>
<li><a href="../vmx/all_syzkaller.html">all_syzkaller</a></li>
</ul></li>`
fileList.innerHTML+=`<li>svm<ul>
<li><a href="./baseline_all.html">baseline_all</a></li>
<li><a href="./baseline_syzkaller.html">baseline_syzkaller</a></li>
<li><a href="./all_wo-harness.html">all_wo-harness</a></li>
<li><a href="./all_wo-config.html">all_wo-config</a></li>
<li><a href="./all_wo-validator.html">all_wo-validator</a></li>
<li><a href="./all_syzkaller.html">all_syzkaller</a></li>
</ul></li>`
</script></body></html>