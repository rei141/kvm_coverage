<doctype html>
<html lang="ja">
<head>
<meta charset="utf-8">
<script src="https://cdn.rawgit.com/google/code-prettify/master/loader/run_prettify.js"></script>
<style>
    code{
        font-family:Monaco, Menlo, Consolas, 'Courier New', Courier, monospace, sans-serif;
        font-size: 14px;
        line-height: 18px;
        overflow: auto;
        resize: horizontal;
    }
    code_line{
        font-family: Monaco, Menlo, Consolas, 'Courier New', Courier, monospace, sans-serif;;
        font-size: 14px;
        line-height: 18px;
        overflow: auto;
        resize: horizontal;
        color:#303134;
    }
    blue{
        background-color:#BEEDE8;
    }
    yellow{
        background-color:#FFFF99;
    }
    red{
        background-color:#FF99AC;
    }
</style>

</head>
<body>
<table summary='blob content' class='blob' cellspacing="15">
<tr><td align="right"><pre><code_line>1.<br>2.<br>3.<br>4.<br>5.<br>6.<br>7.<br>8.<br>9.<br>10.<br>11.<br>12.<br>13.<br>14.<br>15.<br>16.<br>17.<br>18.<br>19.<br>20.<br>21.<br>22.<br>23.<br>24.<br>25.<br>26.<br>27.<br>28.<br>29.<br>30.<br>31.<br>32.<br>33.<br>34.<br>35.<br>36.<br>37.<br>38.<br>39.<br>40.<br>41.<br>42.<br>43.<br>44.<br>45.<br>46.<br>47.<br>48.<br>49.<br>50.<br>51.<br>52.<br>53.<br>54.<br>55.<br>56.<br>57.<br>58.<br>59.<br>60.<br>61.<br>62.<br>63.<br>64.<br>65.<br>66.<br>67.<br>68.<br>69.<br>70.<br>71.<br>72.<br>73.<br>74.<br>75.<br>76.<br>77.<br>78.<br>79.<br>80.<br>81.<br>82.<br>83.<br>84.<br>85.<br>86.<br>87.<br>88.<br>89.<br>90.<br>91.<br>92.<br>93.<br>94.<br>95.<br>96.<br>97.<br>98.<br>99.<br>100.<br>101.<br>102.<br>103.<br>104.<br>105.<br>106.<br>107.<br>108.<br>109.<br>110.<br>111.<br>112.<br>113.<br>114.<br>115.<br>116.<br>117.<br>118.<br>119.<br>120.<br>121.<br>122.<br>123.<br>124.<br>125.<br>126.<br>127.<br>128.<br>129.<br>130.<br>131.<br>132.<br>133.<br>134.<br>135.<br>136.<br>137.<br>138.<br>139.<br>140.<br>141.<br>142.<br>143.<br>144.<br>145.<br>146.<br>147.<br>148.<br>149.<br>150.<br>151.<br>152.<br>153.<br>154.<br>155.<br>156.<br>157.<br>158.<br>159.<br>160.<br>161.<br>162.<br>163.<br>164.<br>165.<br>166.<br>167.<br>168.<br>169.<br>170.<br>171.<br>172.<br>173.<br>174.<br>175.<br>176.<br>177.<br>178.<br>179.<br>180.<br>181.<br>182.<br>183.<br>184.<br>185.<br>186.<br>187.<br>188.<br>189.<br>190.<br>191.<br>192.<br>193.<br>194.<br>195.<br>196.<br>197.<br>198.<br>199.<br>200.<br>201.<br>202.<br>203.<br>204.<br>205.<br>206.<br>207.<br>208.<br>209.<br>210.<br>211.<br>212.<br>213.<br>214.<br>215.<br>216.<br>217.<br>218.<br>219.<br>220.<br>221.<br>222.<br>223.<br>224.<br>225.<br>226.<br>227.<br>228.<br>229.<br>230.<br>231.<br>232.<br>233.<br>234.<br>235.<br>236.<br>237.<br>238.<br>239.<br>240.<br>241.<br>242.<br>243.<br>244.<br>245.<br>246.<br>247.<br>248.<br>249.<br>250.<br>251.<br>252.<br>253.<br>254.<br>255.<br>256.<br>257.<br>258.<br>259.<br>260.<br>261.<br>262.<br>263.<br>264.<br>265.<br>266.<br>267.<br>268.<br>269.<br>270.<br>271.<br>272.<br>273.<br>274.<br>275.<br>276.<br>277.<br>278.<br>279.<br>280.<br>281.<br>282.<br>283.<br>284.<br>285.<br>286.<br>287.<br>288.<br>289.<br>290.<br>291.<br>292.<br>293.<br>294.<br>295.<br>296.<br>297.<br>298.<br>299.<br>300.<br>301.<br>302.<br>303.<br>304.<br>305.<br>306.<br>307.<br>308.<br>309.<br>310.<br>311.<br>312.<br>313.<br>314.<br>315.<br>316.<br>317.<br>318.<br>319.<br>320.<br>321.<br>322.<br>323.<br>324.<br>325.<br>326.<br>327.<br>328.<br>329.<br>330.<br>331.<br>332.<br>333.<br>334.<br>335.<br>336.<br>337.<br>338.<br>339.<br>340.<br>341.<br>342.<br>343.<br>344.<br>345.<br>346.<br>347.<br>348.<br>349.<br>350.<br>351.<br>352.<br>353.<br>354.<br>355.<br>356.<br>357.<br>358.<br>359.<br>360.<br>361.<br>362.<br>363.<br>364.<br>365.<br>366.<br>367.<br>368.<br>369.<br>370.<br>371.<br>372.<br>373.<br>374.<br>375.<br>376.<br>377.<br>378.<br>379.<br>380.<br>381.<br>382.<br>383.<br>384.<br>385.<br>386.<br>387.<br>388.<br>389.<br>390.<br>391.<br>392.<br>393.<br>394.<br>395.<br>396.<br>397.<br>398.<br>399.<br>400.<br>401.<br>402.<br>403.<br>404.<br>405.<br>406.<br>407.<br>408.<br>409.<br>410.<br>411.<br>412.<br>413.<br>414.<br>415.<br>416.<br>417.<br>418.<br>419.<br>420.<br>421.<br>422.<br>423.<br>424.<br>425.<br>426.<br>427.<br>428.<br>429.<br>430.<br>431.<br>432.<br>433.<br>434.<br>435.<br>436.<br>437.<br>438.<br>439.<br>440.<br>441.<br>442.<br>443.<br>444.<br>445.<br>446.<br>447.<br>448.<br>449.<br>450.<br>451.<br>452.<br>453.<br>454.<br>455.<br>456.<br>457.<br>458.<br>459.<br>460.<br>461.<br>462.<br>463.<br>464.<br>465.<br>466.<br>467.<br>468.<br>469.<br>470.<br>471.<br>472.<br>473.<br>474.<br>475.<br>476.<br>477.<br>478.<br>479.<br>480.<br>481.<br>482.<br>483.<br>484.<br>485.<br>486.<br>487.<br>488.<br>489.<br>490.<br>491.<br>492.<br>493.<br>494.<br>495.<br>496.<br>497.<br>498.<br>499.<br>500.<br>501.<br>502.<br>503.<br>504.<br>505.<br>506.<br>507.<br>508.<br>509.<br>510.<br>511.<br>512.<br>513.<br>514.<br>515.<br>516.<br>517.<br>518.<br>519.<br>520.<br>521.<br>522.<br>523.<br>524.<br>525.<br>526.<br>527.<br>528.<br>529.<br>530.<br>531.<br>532.<br>533.<br>534.<br>535.<br>536.<br>537.<br>538.<br>539.<br>540.<br>541.<br>542.<br>543.<br>544.<br>545.<br>546.<br>547.<br>548.<br>549.<br>550.<br>551.<br>552.<br>553.<br>554.<br>555.<br>556.<br>557.<br>558.<br>559.<br>560.<br>561.<br>562.<br>563.<br>564.<br>565.<br>566.<br>567.<br>568.<br>569.<br>570.<br>571.<br>572.<br>573.<br>574.<br>575.<br>576.<br>577.<br>578.<br>579.<br>580.<br>581.<br>582.<br>583.<br>584.<br>585.<br>586.<br>587.<br>588.<br>589.<br>590.<br>591.<br>592.<br>593.<br>594.<br>595.<br>596.<br>597.<br>598.<br>599.<br>600.<br>601.<br>602.<br>603.<br>604.<br>605.<br>606.<br>607.<br>608.<br>609.<br>610.<br>611.<br>612.<br>613.<br>614.<br>615.<br>616.<br>617.<br>618.<br>619.<br>620.<br>621.<br>622.<br>623.<br>624.<br>625.<br>626.<br>627.<br>628.<br>629.<br>630.<br>631.<br>632.<br>633.<br>634.<br>635.<br>636.<br>637.<br>638.<br>639.<br>640.<br>641.<br>642.<br>643.<br>644.<br>645.<br>646.<br>647.<br>648.<br>649.<br>650.<br>651.<br>652.<br>653.<br>654.<br>655.<br>656.<br>657.<br>658.<br>659.<br>660.<br>661.<br>662.<br>663.<br>664.<br>665.<br>666.<br>667.<br>668.<br>669.<br>670.<br>671.<br>672.<br>673.<br>674.<br>675.<br>676.<br>677.<br>678.<br>679.<br>680.<br>681.<br>682.<br>683.<br>684.<br>685.<br>686.<br>687.<br>688.<br>689.<br>690.<br>691.<br>692.<br>693.<br>694.<br>695.<br>696.<br>697.<br>698.<br>699.<br>700.<br>701.<br>702.<br>703.<br>704.<br>705.<br>706.<br>707.<br>708.<br>709.<br>710.<br>711.<br>712.<br>713.<br>714.<br>715.<br>716.<br>717.<br>718.<br>719.<br>720.<br>721.<br>722.<br>723.<br>724.<br>725.<br>726.<br>727.<br>728.<br>729.<br>730.<br>731.<br>732.<br>733.<br>734.<br>735.<br>736.<br>737.<br>738.<br>739.<br>740.<br>741.<br>742.<br>743.<br>744.<br>745.<br>746.<br>747.<br>748.<br>749.<br>750.<br>751.<br>752.<br>753.<br>754.<br>755.<br>756.<br>757.<br>758.<br>759.<br>760.<br>761.<br>762.<br>763.<br>764.<br>765.<br>766.<br>767.<br>768.<br>769.<br>770.<br>771.<br>772.<br>773.<br>774.<br>775.<br>776.<br>777.<br>778.<br>779.<br>780.<br>781.<br>782.<br>783.<br>784.<br>785.<br>786.<br>787.<br>788.<br>789.<br>790.<br>791.<br>792.<br>793.<br>794.<br>795.<br>796.<br>797.<br>798.<br>799.<br>800.<br>801.<br>802.<br>803.<br>804.<br>805.<br>806.<br>807.<br>808.<br>809.<br>810.<br>811.<br>812.<br>813.<br>814.<br>815.<br>816.<br>817.<br>818.<br>819.<br>820.<br>821.<br>822.<br>823.<br>824.<br>825.<br>826.<br>827.<br>828.<br>829.<br>830.<br>831.<br>832.<br>833.<br>834.<br>835.<br>836.<br>837.<br>838.<br>839.<br>840.<br>841.<br>842.<br>843.<br>844.<br>845.<br>846.<br>847.<br>848.<br>849.<br>850.<br>851.<br>852.<br>853.<br>854.<br>855.<br>856.<br>857.<br>858.<br>859.<br>860.<br>861.<br>862.<br>863.<br>864.<br>865.<br>866.<br>867.<br>868.<br>869.<br>870.<br>871.<br>872.<br>873.<br>874.<br>875.<br>876.<br>877.<br>878.<br>879.<br>880.<br>881.<br>882.<br>883.<br>884.<br>885.<br>886.<br>887.<br>888.<br>889.<br>890.<br>891.<br>892.<br>893.<br>894.<br>895.<br>896.<br>897.<br>898.<br>899.<br>900.<br>901.<br>902.<br>903.<br>904.<br>905.<br>906.<br>907.<br>908.<br>909.<br>910.<br>911.<br>912.<br>913.<br>914.<br>915.<br>916.<br>917.<br>918.<br>919.<br>920.<br>921.<br>922.<br>923.<br>924.<br>925.<br>926.<br>927.<br>928.<br>929.<br>930.<br>931.<br>932.<br>933.<br>934.<br>935.<br>936.<br>937.<br>938.<br>939.<br>940.<br>941.<br>942.<br>943.<br>944.<br>945.<br>946.<br>947.<br>948.<br>949.<br>950.<br>951.<br>952.<br>953.<br>954.<br>955.<br>956.<br>957.<br>958.<br>959.<br>960.<br>961.<br>962.<br>963.<br>964.<br>965.<br>966.<br>967.<br>968.<br>969.<br>970.<br>971.<br>972.<br>973.<br>974.<br>975.<br>976.<br>977.<br>978.<br>979.<br>980.<br>981.<br>982.<br>983.<br>984.<br>985.<br>986.<br>987.<br>988.<br>989.<br>990.<br>991.<br>992.<br>993.<br>994.<br>995.<br>996.<br>997.<br>998.<br>999.<br>1000.<br>1001.<br>1002.<br>1003.<br>1004.<br>1005.<br>1006.<br>1007.<br>1008.<br>1009.<br>1010.<br>1011.<br>1012.<br>1013.<br>1014.<br>1015.<br>1016.<br>1017.<br>1018.<br>1019.<br>1020.<br>1021.<br>1022.<br>1023.<br>1024.<br>1025.<br>1026.<br>1027.<br>1028.<br>1029.<br>1030.<br>1031.<br>1032.<br>1033.<br>1034.<br>1035.<br>1036.<br>1037.<br>1038.<br>1039.<br>1040.<br>1041.<br>1042.<br>1043.<br>1044.<br>1045.<br>1046.<br>1047.<br>1048.<br>1049.<br>1050.<br>1051.<br>1052.<br>1053.<br>1054.<br>1055.<br>1056.<br>1057.<br>1058.<br>1059.<br>1060.<br>1061.<br>1062.<br>1063.<br>1064.<br>1065.<br>1066.<br>1067.<br>1068.<br>1069.<br>1070.<br>1071.<br>1072.<br>1073.<br>1074.<br>1075.<br>1076.<br>1077.<br>1078.<br>1079.<br>1080.<br>1081.<br>1082.<br>1083.<br>1084.<br>1085.<br>1086.<br>1087.<br>1088.<br>1089.<br>1090.<br>1091.<br>1092.<br>1093.<br>1094.<br>1095.<br>1096.<br>1097.<br>1098.<br>1099.<br>1100.<br>1101.<br>1102.<br>1103.<br>1104.<br>1105.<br>1106.<br>1107.<br>1108.<br>1109.<br>1110.<br>1111.<br>1112.<br>1113.<br>1114.<br>1115.<br>1116.<br>1117.<br>1118.<br>1119.<br>1120.<br>1121.<br>1122.<br>1123.<br>1124.<br>1125.<br>1126.<br>1127.<br>1128.<br>1129.<br>1130.<br>1131.<br>1132.<br>1133.<br>1134.<br>1135.<br>1136.<br>1137.<br>1138.<br>1139.<br>1140.<br>1141.<br>1142.<br>1143.<br>1144.<br>1145.<br>1146.<br>1147.<br>1148.<br>1149.<br>1150.<br>1151.<br>1152.<br>1153.<br>1154.<br>1155.<br>1156.<br>1157.<br>1158.<br>1159.<br>1160.<br>1161.<br>1162.<br>1163.<br>1164.<br>1165.<br>1166.<br>1167.<br>1168.<br>1169.<br>1170.<br>1171.<br>1172.<br>1173.<br>1174.<br>1175.<br>1176.<br>1177.<br>1178.<br>1179.<br>1180.<br>1181.<br>1182.<br>1183.<br>1184.<br>1185.<br>1186.<br>1187.<br>1188.<br>1189.<br>1190.<br>1191.<br>1192.<br>1193.<br>1194.<br>1195.<br>1196.<br>1197.<br>1198.<br>1199.<br>1200.<br>1201.<br>1202.<br>1203.<br>1204.<br>1205.<br>1206.<br>1207.<br>1208.<br>1209.<br>1210.<br>1211.<br>1212.<br>1213.<br>1214.<br>1215.<br>1216.<br>1217.<br>1218.<br>1219.<br>1220.<br>1221.<br>1222.<br>1223.<br>1224.<br>1225.<br>1226.<br>1227.<br>1228.<br>1229.<br>1230.<br>1231.<br>1232.<br>1233.<br>1234.<br>1235.<br>1236.<br>1237.<br>1238.<br>1239.<br>1240.<br>1241.<br>1242.<br>1243.<br>1244.<br>1245.<br>1246.<br>1247.<br>1248.<br>1249.<br>1250.<br>1251.<br>1252.<br>1253.<br>1254.<br>1255.<br>1256.<br>1257.<br>1258.<br>1259.<br>1260.<br>1261.<br>1262.<br>1263.<br>1264.<br>1265.<br>1266.<br>1267.<br>1268.<br>1269.<br>1270.<br>1271.<br>1272.<br>1273.<br>1274.<br>1275.<br>1276.<br>1277.<br>1278.<br>1279.<br>1280.<br>1281.<br>1282.<br>1283.<br>1284.<br>1285.<br>1286.<br>1287.<br>1288.<br>1289.<br>1290.<br>1291.<br>1292.<br>1293.<br>1294.<br>1295.<br>1296.<br>1297.<br>1298.<br>1299.<br>1300.<br>1301.<br>1302.<br>1303.<br>1304.<br>1305.<br>1306.<br>1307.<br>1308.<br>1309.<br>1310.<br>1311.<br>1312.<br>1313.<br>1314.<br>1315.<br>1316.<br>1317.<br>1318.<br>1319.<br>1320.<br>1321.<br>1322.<br>1323.<br>1324.<br>1325.<br>1326.<br>1327.<br>1328.<br>1329.<br>1330.<br>1331.<br>1332.<br>1333.<br>1334.<br>1335.<br>1336.<br>1337.<br>1338.<br>1339.<br>1340.<br>1341.<br>1342.<br>1343.<br>1344.<br>1345.<br>1346.<br>1347.<br>1348.<br>1349.<br>1350.<br>1351.<br>1352.<br>1353.<br>1354.<br>1355.<br>1356.<br>1357.<br>1358.<br>1359.<br>1360.<br>1361.<br>1362.<br>1363.<br>1364.<br>1365.<br>1366.<br>1367.<br>1368.<br>1369.<br>1370.<br>1371.<br>1372.<br>1373.<br>1374.<br>1375.<br>1376.<br>1377.<br>1378.<br>1379.<br>1380.<br>1381.<br>1382.<br>1383.<br>1384.<br>1385.<br>1386.<br>1387.<br>1388.<br>1389.<br>1390.<br>1391.<br>1392.<br>1393.<br>1394.<br>1395.<br>1396.<br>1397.<br>1398.<br>1399.<br>1400.<br>1401.<br>1402.<br>1403.<br>1404.<br>1405.<br>1406.<br>1407.<br>1408.<br>1409.<br>1410.<br>1411.<br>1412.<br>1413.<br>1414.<br>1415.<br>1416.<br>1417.<br>1418.<br>1419.<br>1420.<br>1421.<br>1422.<br>1423.<br>1424.<br>1425.<br>1426.<br>1427.<br>1428.<br>1429.<br>1430.<br>1431.<br>1432.<br>1433.<br>1434.<br>1435.<br>1436.<br>1437.<br>1438.<br>1439.<br>1440.<br>1441.<br>1442.<br>1443.<br>1444.<br>1445.<br>1446.<br>1447.<br>1448.<br>1449.<br>1450.<br>1451.<br>1452.<br>1453.<br>1454.<br>1455.<br>1456.<br>1457.<br>1458.<br>1459.<br>1460.<br>1461.<br>1462.<br>1463.<br>1464.<br>1465.<br>1466.<br>1467.<br>1468.<br>1469.<br>1470.<br>1471.<br>1472.<br>1473.<br>1474.<br>1475.<br>1476.<br>1477.<br>1478.<br>1479.<br>1480.<br>1481.<br>1482.<br>1483.<br>1484.<br>1485.<br>1486.<br>1487.<br>1488.<br>1489.<br>1490.<br>1491.<br>1492.<br>1493.<br>1494.<br>1495.<br>1496.<br>1497.<br>1498.<br>1499.<br>1500.<br>1501.<br>1502.<br>1503.<br>1504.<br>1505.<br>1506.<br>1507.<br>1508.<br>1509.<br>1510.<br>1511.<br>1512.<br>1513.<br>1514.<br>1515.<br>1516.<br>1517.<br>1518.<br>1519.<br>1520.<br>1521.<br>1522.<br>1523.<br>1524.<br>1525.<br>1526.<br>1527.<br>1528.<br>1529.<br>1530.<br>1531.<br>1532.<br>1533.<br>1534.<br>1535.<br>1536.<br>1537.<br>1538.<br>1539.<br>1540.<br>1541.<br>1542.<br>1543.<br>1544.<br>1545.<br>1546.<br>1547.<br>1548.<br>1549.<br>1550.<br>1551.<br>1552.<br>1553.<br>1554.<br>1555.<br>1556.<br>1557.<br>1558.<br>1559.<br>1560.<br>1561.<br>1562.<br>1563.<br>1564.<br>1565.<br>1566.<br>1567.<br>1568.<br>1569.<br>1570.<br>1571.<br>1572.<br>1573.<br>1574.<br>1575.<br>1576.<br>1577.<br>1578.<br>1579.<br>1580.<br>1581.<br>1582.<br>1583.<br>1584.<br>1585.<br>1586.<br>1587.<br>1588.<br>1589.<br>1590.<br>1591.<br>1592.<br>1593.<br>1594.<br>1595.<br>1596.<br>1597.<br>1598.<br>1599.<br>1600.<br>1601.<br>1602.<br>1603.<br>1604.<br>1605.<br>1606.<br>1607.<br>1608.<br>1609.<br>1610.<br>1611.<br>1612.<br>1613.<br>1614.<br>1615.<br>1616.<br>1617.<br>1618.<br>1619.<br>1620.<br>1621.<br>1622.<br>1623.<br>1624.<br>1625.<br>1626.<br>1627.<br>1628.<br>1629.<br>1630.<br>1631.<br>1632.<br>1633.<br>1634.<br>1635.<br>1636.<br>1637.<br>1638.<br>1639.<br>1640.<br>1641.<br>1642.<br>1643.<br>1644.<br>1645.<br>1646.<br>1647.<br>1648.<br>1649.<br>1650.<br>1651.<br>1652.<br>1653.<br>1654.<br>1655.<br>1656.<br>1657.<br>1658.<br>1659.<br>1660.<br>1661.<br>1662.<br>1663.<br>1664.<br>1665.<br>1666.<br>1667.<br>1668.<br>1669.<br>1670.<br>1671.<br>1672.<br>1673.<br>1674.<br>1675.<br>1676.<br>1677.<br>1678.<br>1679.<br>1680.<br>1681.<br>1682.<br>1683.<br>1684.<br>1685.<br>1686.<br>1687.<br>1688.<br>1689.<br>1690.<br>1691.<br>1692.<br>1693.<br>1694.<br>1695.<br>1696.<br>1697.<br>1698.<br>1699.<br>1700.<br>1701.<br>1702.<br>1703.<br>1704.<br>1705.<br>1706.<br>1707.<br>1708.<br>1709.<br>1710.<br>1711.<br>1712.<br>1713.<br>1714.<br>1715.<br>1716.<br>1717.<br>1718.<br>1719.<br>1720.<br>1721.<br>1722.<br>1723.<br>1724.<br>1725.<br>1726.<br>1727.<br>1728.<br>1729.<br>1730.<br>1731.<br>1732.<br>1733.<br>1734.<br>1735.<br>1736.<br>1737.<br>1738.<br>1739.<br>1740.<br>1741.<br>1742.<br>1743.<br>1744.<br>1745.<br>1746.<br>1747.<br>1748.<br>1749.<br>1750.<br>1751.<br>1752.<br>1753.<br>1754.<br>1755.<br>1756.<br>1757.<br>1758.<br>1759.<br>1760.<br>1761.<br>1762.<br>1763.<br>1764.<br>1765.<br>1766.<br>1767.<br>1768.<br>1769.<br>1770.<br>1771.<br>1772.<br>1773.<br>1774.<br>1775.<br>1776.<br>1777.<br>1778.<br>1779.<br>1780.<br>1781.<br>1782.<br>1783.<br>1784.<br>1785.<br>1786.<br>1787.<br>1788.<br>1789.<br>1790.<br>1791.<br>1792.<br>1793.<br>1794.<br>1795.<br>1796.<br>1797.<br>1798.<br>1799.<br>1800.<br>1801.<br>1802.<br>1803.<br>1804.<br>1805.<br>1806.<br>1807.<br>1808.<br>1809.<br>1810.<br>1811.<br>1812.<br>1813.<br>1814.<br>1815.<br>1816.<br>1817.<br>1818.<br>1819.<br>1820.<br>1821.<br>1822.<br>1823.<br>1824.<br>1825.<br>1826.<br>1827.<br>1828.<br>1829.<br>1830.<br>1831.<br>1832.<br>1833.<br>1834.<br>1835.<br>1836.<br>1837.<br>1838.<br>1839.<br>1840.<br>1841.<br>1842.<br>1843.<br>1844.<br>1845.<br>1846.<br>1847.<br>1848.<br>1849.<br>1850.<br>1851.<br>1852.<br>1853.<br>1854.<br>1855.<br>1856.<br>1857.<br>1858.<br>1859.<br>1860.<br>1861.<br>1862.<br>1863.<br>1864.<br>1865.<br>1866.<br>1867.<br>1868.<br>1869.<br>1870.<br>1871.<br>1872.<br>1873.<br>1874.<br>1875.<br>1876.<br>1877.<br>1878.<br>1879.<br>1880.<br>1881.<br>1882.<br>1883.<br>1884.<br>1885.<br>1886.<br>1887.<br>1888.<br>1889.<br>1890.<br>1891.<br>1892.<br>1893.<br>1894.<br>1895.<br>1896.<br>1897.<br>1898.<br>1899.<br>1900.<br>1901.<br>1902.<br>1903.<br>1904.<br>1905.<br>1906.<br>1907.<br>1908.<br>1909.<br>1910.<br>1911.<br>1912.<br>1913.<br>1914.<br>1915.<br>1916.<br>1917.<br>1918.<br>1919.<br>1920.<br>1921.<br>1922.<br>1923.<br>1924.<br>1925.<br>1926.<br>1927.<br>1928.<br>1929.<br>1930.<br>1931.<br>1932.<br>1933.<br>1934.<br>1935.<br>1936.<br>1937.<br>1938.<br>1939.<br>1940.<br>1941.<br>1942.<br>1943.<br>1944.<br>1945.<br>1946.<br>1947.<br>1948.<br>1949.<br>1950.<br>1951.<br>1952.<br>1953.<br>1954.<br>1955.<br>1956.<br>1957.<br>1958.<br>1959.<br>1960.<br>1961.<br>1962.<br>1963.<br>1964.<br>1965.<br>1966.<br>1967.<br>1968.<br>1969.<br>1970.<br>1971.<br>1972.<br>1973.<br>1974.<br>1975.<br>1976.<br>1977.<br>1978.<br>1979.<br>1980.<br>1981.<br>1982.<br>1983.<br>1984.<br>1985.<br>1986.<br>1987.<br>1988.<br>1989.<br>1990.<br>1991.<br>1992.<br>1993.<br>1994.<br>1995.<br>1996.<br>1997.<br>1998.<br>1999.<br>2000.<br>2001.<br>2002.<br>2003.<br>2004.<br>2005.<br>2006.<br>2007.<br>2008.<br>2009.<br>2010.<br>2011.<br>2012.<br>2013.<br>2014.<br>2015.<br>2016.<br>2017.<br>2018.<br>2019.<br>2020.<br>2021.<br>2022.<br>2023.<br>2024.<br>2025.<br>2026.<br>2027.<br>2028.<br>2029.<br>2030.<br>2031.<br>2032.<br>2033.<br>2034.<br>2035.<br>2036.<br>2037.<br>2038.<br>2039.<br>2040.<br>2041.<br>2042.<br>2043.<br>2044.<br>2045.<br>2046.<br>2047.<br>2048.<br>2049.<br>2050.<br>2051.<br>2052.<br>2053.<br>2054.<br>2055.<br>2056.<br>2057.<br>2058.<br>2059.<br>2060.<br>2061.<br>2062.<br>2063.<br>2064.<br>2065.<br>2066.<br>2067.<br>2068.<br>2069.<br>2070.<br>2071.<br>2072.<br>2073.<br>2074.<br>2075.<br>2076.<br>2077.<br>2078.<br>2079.<br>2080.<br>2081.<br>2082.<br>2083.<br>2084.<br>2085.<br>2086.<br>2087.<br>2088.<br>2089.<br>2090.<br>2091.<br>2092.<br>2093.<br>2094.<br>2095.<br>2096.<br>2097.<br>2098.<br>2099.<br>2100.<br>2101.<br>2102.<br>2103.<br>2104.<br>2105.<br>2106.<br>2107.<br>2108.<br>2109.<br>2110.<br>2111.<br>2112.<br>2113.<br>2114.<br>2115.<br>2116.<br>2117.<br>2118.<br>2119.<br>2120.<br>2121.<br>2122.<br>2123.<br>2124.<br>2125.<br>2126.<br>2127.<br>2128.<br>2129.<br>2130.<br>2131.<br>2132.<br>2133.<br>2134.<br>2135.<br>2136.<br>2137.<br>2138.<br>2139.<br>2140.<br>2141.<br>2142.<br>2143.<br>2144.<br>2145.<br>2146.<br>2147.<br>2148.<br>2149.<br>2150.<br>2151.<br>2152.<br>2153.<br>2154.<br>2155.<br>2156.<br>2157.<br>2158.<br>2159.<br>2160.<br>2161.<br>2162.<br>2163.<br>2164.<br>2165.<br>2166.<br>2167.<br>2168.<br>2169.<br>2170.<br>2171.<br>2172.<br>2173.<br>2174.<br>2175.<br>2176.<br>2177.<br>2178.<br>2179.<br>2180.<br>2181.<br>2182.<br>2183.<br>2184.<br>2185.<br>2186.<br>2187.<br>2188.<br>2189.<br>2190.<br>2191.<br>2192.<br>2193.<br>2194.<br>2195.<br>2196.<br>2197.<br>2198.<br>2199.<br>2200.<br>2201.<br>2202.<br>2203.<br>2204.<br>2205.<br>2206.<br>2207.<br>2208.<br>2209.<br>2210.<br>2211.<br>2212.<br>2213.<br>2214.<br>2215.<br>2216.<br>2217.<br>2218.<br>2219.<br>2220.<br>2221.<br>2222.<br>2223.<br>2224.<br>2225.<br>2226.<br>2227.<br>2228.<br>2229.<br>2230.<br>2231.<br>2232.<br>2233.<br>2234.<br>2235.<br>2236.<br>2237.<br>2238.<br>2239.<br>2240.<br>2241.<br>2242.<br>2243.<br>2244.<br>2245.<br>2246.<br>2247.<br>2248.<br>2249.<br>2250.<br>2251.<br>2252.<br>2253.<br>2254.<br>2255.<br>2256.<br>2257.<br>2258.<br>2259.<br>2260.<br>2261.<br>2262.<br>2263.<br>2264.<br>2265.<br>2266.<br>2267.<br>2268.<br>2269.<br>2270.<br>2271.<br>2272.<br>2273.<br>2274.<br>2275.<br>2276.<br>2277.<br>2278.<br>2279.<br>2280.<br>2281.<br>2282.<br>2283.<br>2284.<br>2285.<br>2286.<br>2287.<br>2288.<br>2289.<br>2290.<br>2291.<br>2292.<br>2293.<br>2294.<br>2295.<br>2296.<br>2297.<br>2298.<br>2299.<br>2300.<br>2301.<br>2302.<br>2303.<br>2304.<br>2305.<br>2306.<br>2307.<br>2308.<br>2309.<br>2310.<br>2311.<br>2312.<br>2313.<br>2314.<br>2315.<br>2316.<br>2317.<br>2318.<br>2319.<br>2320.<br>2321.<br>2322.<br>2323.<br>2324.<br>2325.<br>2326.<br>2327.<br>2328.<br>2329.<br>2330.<br>2331.<br>2332.<br>2333.<br>2334.<br>2335.<br>2336.<br>2337.<br>2338.<br>2339.<br>2340.<br>2341.<br>2342.<br>2343.<br>2344.<br>2345.<br>2346.<br>2347.<br>2348.<br>2349.<br>2350.<br>2351.<br>2352.<br>2353.<br>2354.<br>2355.<br>2356.<br>2357.<br>2358.<br>2359.<br>2360.<br>2361.<br>2362.<br>2363.<br>2364.<br>2365.<br>2366.<br>2367.<br>2368.<br>2369.<br>2370.<br>2371.<br>2372.<br>2373.<br>2374.<br>2375.<br>2376.<br>2377.<br>2378.<br>2379.<br>2380.<br>2381.<br>2382.<br>2383.<br>2384.<br>2385.<br>2386.<br>2387.<br>2388.<br>2389.<br>2390.<br>2391.<br>2392.<br>2393.<br>2394.<br>2395.<br>2396.<br>2397.<br>2398.<br>2399.<br>2400.<br>2401.<br>2402.<br>2403.<br>2404.<br>2405.<br>2406.<br>2407.<br>2408.<br>2409.<br>2410.<br>2411.<br>2412.<br>2413.<br>2414.<br>2415.<br>2416.<br>2417.<br>2418.<br>2419.<br>2420.<br>2421.<br>2422.<br>2423.<br>2424.<br>2425.<br>2426.<br>2427.<br>2428.<br>2429.<br>2430.<br>2431.<br>2432.<br>2433.<br>2434.<br>2435.<br>2436.<br>2437.<br>2438.<br>2439.<br>2440.<br>2441.<br>2442.<br>2443.<br>2444.<br>2445.<br>2446.<br>2447.<br>2448.<br>2449.<br>2450.<br>2451.<br>2452.<br>2453.<br>2454.<br>2455.<br>2456.<br>2457.<br>2458.<br>2459.<br>2460.<br>2461.<br>2462.<br>2463.<br>2464.<br>2465.<br>2466.<br>2467.<br>2468.<br>2469.<br>2470.<br>2471.<br>2472.<br>2473.<br>2474.<br>2475.<br>2476.<br>2477.<br>2478.<br>2479.<br>2480.<br>2481.<br>2482.<br>2483.<br>2484.<br>2485.<br>2486.<br>2487.<br>2488.<br>2489.<br>2490.<br>2491.<br>2492.<br>2493.<br>2494.<br>2495.<br>2496.<br>2497.<br>2498.<br>2499.<br>2500.<br>2501.<br>2502.<br>2503.<br>2504.<br>2505.<br>2506.<br>2507.<br>2508.<br>2509.<br>2510.<br>2511.<br>2512.<br>2513.<br>2514.<br>2515.<br>2516.<br>2517.<br>2518.<br>2519.<br>2520.<br>2521.<br>2522.<br>2523.<br>2524.<br>2525.<br>2526.<br>2527.<br>2528.<br>2529.<br>2530.<br>2531.<br>2532.<br>2533.<br>2534.<br>2535.<br>2536.<br>2537.<br>2538.<br>2539.<br>2540.<br>2541.<br>2542.<br>2543.<br>2544.<br>2545.<br>2546.<br>2547.<br>2548.<br>2549.<br>2550.<br>2551.<br>2552.<br>2553.<br>2554.<br>2555.<br>2556.<br>2557.<br>2558.<br>2559.<br>2560.<br>2561.<br>2562.<br>2563.<br>2564.<br>2565.<br>2566.<br>2567.<br>2568.<br>2569.<br>2570.<br>2571.<br>2572.<br>2573.<br>2574.<br>2575.<br>2576.<br>2577.<br>2578.<br>2579.<br>2580.<br>2581.<br>2582.<br>2583.<br>2584.<br>2585.<br>2586.<br>2587.<br>2588.<br>2589.<br>2590.<br>2591.<br>2592.<br>2593.<br>2594.<br>2595.<br>2596.<br>2597.<br>2598.<br>2599.<br>2600.<br>2601.<br>2602.<br>2603.<br>2604.<br>2605.<br>2606.<br>2607.<br>2608.<br>2609.<br>2610.<br>2611.<br>2612.<br>2613.<br>2614.<br>2615.<br>2616.<br>2617.<br>2618.<br>2619.<br>2620.<br>2621.<br>2622.<br>2623.<br>2624.<br>2625.<br>2626.<br>2627.<br>2628.<br>2629.<br>2630.<br>2631.<br>2632.<br>2633.<br>2634.<br>2635.<br>2636.<br>2637.<br>2638.<br>2639.<br>2640.<br>2641.<br>2642.<br>2643.<br>2644.<br>2645.<br>2646.<br>2647.<br>2648.<br>2649.<br>2650.<br>2651.<br>2652.<br>2653.<br>2654.<br>2655.<br>2656.<br>2657.<br>2658.<br>2659.<br>2660.<br>2661.<br>2662.<br>2663.<br>2664.<br>2665.<br>2666.<br>2667.<br>2668.<br>2669.<br>2670.<br>2671.<br>2672.<br>2673.<br>2674.<br>2675.<br>2676.<br>2677.<br>2678.<br>2679.<br>2680.<br>2681.<br>2682.<br>2683.<br>2684.<br>2685.<br>2686.<br>2687.<br>2688.<br>2689.<br>2690.<br>2691.<br>2692.<br>2693.<br>2694.<br>2695.<br>2696.<br>2697.<br>2698.<br>2699.<br>2700.<br>2701.<br>2702.<br>2703.<br>2704.<br>2705.<br>2706.<br>2707.<br>2708.<br>2709.<br>2710.<br>2711.<br>2712.<br>2713.<br>2714.<br>2715.<br>2716.<br>2717.<br>2718.<br>2719.<br>2720.<br>2721.<br>2722.<br>2723.<br>2724.<br>2725.<br>2726.<br>2727.<br>2728.<br>2729.<br>2730.<br>2731.<br>2732.<br>2733.<br>2734.<br>2735.<br>2736.<br>2737.<br>2738.<br>2739.<br>2740.<br>2741.<br>2742.<br>2743.<br>2744.<br>2745.<br>2746.<br>2747.<br>2748.<br>2749.<br>2750.<br>2751.<br>2752.<br>2753.<br>2754.<br>2755.<br>2756.<br>2757.<br>2758.<br>2759.<br>2760.<br>2761.<br>2762.<br>2763.<br>2764.<br>2765.<br>2766.<br>2767.<br>2768.<br>2769.<br>2770.<br>2771.<br>2772.<br>2773.<br>2774.<br>2775.<br>2776.<br>2777.<br>2778.<br>2779.<br>2780.<br>2781.<br>2782.<br>2783.<br>2784.<br>2785.<br>2786.<br>2787.<br>2788.<br>2789.<br>2790.<br>2791.<br>2792.<br>2793.<br>2794.<br>2795.<br>2796.<br>2797.<br>2798.<br>2799.<br>2800.<br>2801.<br>2802.<br>2803.<br>2804.<br>2805.<br>2806.<br>2807.<br>2808.<br>2809.<br>2810.<br>2811.<br>2812.<br>2813.<br>2814.<br>2815.<br>2816.<br>2817.<br>2818.<br>2819.<br>2820.<br>2821.<br>2822.<br>2823.<br>2824.<br>2825.<br>2826.<br>2827.<br>2828.<br>2829.<br>2830.<br>2831.<br>2832.<br>2833.<br>2834.<br>2835.<br>2836.<br>2837.<br>2838.<br>2839.<br>2840.<br>2841.<br>2842.<br>2843.<br>2844.<br>2845.<br>2846.<br>2847.<br>2848.<br>2849.<br>2850.<br>2851.<br>2852.<br>2853.<br>2854.<br>2855.<br>2856.<br>2857.<br>2858.<br>2859.<br>2860.<br>2861.<br>2862.<br>2863.<br>2864.<br>2865.<br>2866.<br>2867.<br>2868.<br>2869.<br>2870.<br>2871.<br>2872.<br>2873.<br>2874.<br>2875.<br>2876.<br>2877.<br>2878.<br>2879.<br>2880.<br>2881.<br>2882.<br>2883.<br>2884.<br>2885.<br>2886.<br>2887.<br>2888.<br>2889.<br>2890.<br>2891.<br>2892.<br>2893.<br>2894.<br>2895.<br>2896.<br>2897.<br>2898.<br>2899.<br>2900.<br>2901.<br>2902.<br>2903.<br>2904.<br>2905.<br>2906.<br>2907.<br>2908.<br>2909.<br>2910.<br>2911.<br>2912.<br>2913.<br>2914.<br>2915.<br>2916.<br>2917.<br>2918.<br>2919.<br>2920.<br>2921.<br>2922.<br>2923.<br>2924.<br>2925.<br>2926.<br>2927.<br>2928.<br>2929.<br>2930.<br>2931.<br>2932.<br>2933.<br>2934.<br>2935.<br>2936.<br>2937.<br>2938.<br>2939.<br>2940.<br>2941.<br>2942.<br>2943.<br>2944.<br>2945.<br>2946.<br>2947.<br>2948.<br>2949.<br>2950.<br>2951.<br>2952.<br>2953.<br>2954.<br>2955.<br>2956.<br>2957.<br>2958.<br>2959.<br>2960.<br>2961.<br>2962.<br>2963.<br>2964.<br>2965.<br>2966.<br>2967.<br>2968.<br>2969.<br>2970.<br>2971.<br>2972.<br>2973.<br>2974.<br>2975.<br>2976.<br>2977.<br>2978.<br>2979.<br>2980.<br>2981.<br>2982.<br>2983.<br>2984.<br>2985.<br>2986.<br>2987.<br>2988.<br>2989.<br>2990.<br>2991.<br>2992.<br>2993.<br>2994.<br>2995.<br>2996.<br>2997.<br>2998.<br>2999.<br>3000.<br>3001.<br>3002.<br>3003.<br>3004.<br>3005.<br>3006.<br>3007.<br>3008.<br>3009.<br>3010.<br>3011.<br>3012.<br>3013.<br>3014.<br>3015.<br>3016.<br>3017.<br>3018.<br>3019.<br>3020.<br>3021.<br>3022.<br>3023.<br>3024.<br>3025.<br>3026.<br>3027.<br>3028.<br>3029.<br>3030.<br>3031.<br>3032.<br>3033.<br>3034.<br>3035.<br>3036.<br>3037.<br>3038.<br>3039.<br>3040.<br>3041.<br>3042.<br>3043.<br>3044.<br>3045.<br>3046.<br>3047.<br>3048.<br>3049.<br>3050.<br>3051.<br>3052.<br>3053.<br>3054.<br>3055.<br>3056.<br>3057.<br>3058.<br>3059.<br>3060.<br>3061.<br>3062.<br>3063.<br>3064.<br>3065.<br>3066.<br>3067.<br>3068.<br>3069.<br>3070.<br>3071.<br>3072.<br>3073.<br>3074.<br>3075.<br>3076.<br>3077.<br>3078.<br>3079.<br>3080.<br>3081.<br>3082.<br>3083.<br>3084.<br>3085.<br>3086.<br>3087.<br>3088.<br>3089.<br>3090.<br>3091.<br>3092.<br>3093.<br>3094.<br>3095.<br>3096.<br>3097.<br>3098.<br>3099.<br>3100.<br>3101.<br>3102.<br>3103.<br>3104.<br>3105.<br>3106.<br>3107.<br>3108.<br>3109.<br>3110.<br>3111.<br>3112.<br>3113.<br>3114.<br>3115.<br>3116.<br>3117.<br>3118.<br>3119.<br>3120.<br>3121.<br>3122.<br>3123.<br>3124.<br>3125.<br>3126.<br>3127.<br>3128.<br>3129.<br>3130.<br>3131.<br>3132.<br>3133.<br>3134.<br>3135.<br>3136.<br>3137.<br>3138.<br>3139.<br>3140.<br>3141.<br>3142.<br>3143.<br>3144.<br>3145.<br>3146.<br>3147.<br>3148.<br>3149.<br>3150.<br>3151.<br>3152.<br>3153.<br>3154.<br>3155.<br>3156.<br>3157.<br>3158.<br>3159.<br>3160.<br>3161.<br>3162.<br>3163.<br>3164.<br>3165.<br>3166.<br>3167.<br>3168.<br>3169.<br>3170.<br>3171.<br>3172.<br>3173.<br>3174.<br>3175.<br>3176.<br>3177.<br>3178.<br>3179.<br>3180.<br>3181.<br>3182.<br>3183.<br>3184.<br>3185.<br>3186.<br>3187.<br>3188.<br>3189.<br>3190.<br>3191.<br>3192.<br>3193.<br>3194.<br>3195.<br>3196.<br>3197.<br>3198.<br>3199.<br>3200.<br>3201.<br>3202.<br>3203.<br>3204.<br>3205.<br>3206.<br>3207.<br>3208.<br>3209.<br>3210.<br>3211.<br>3212.<br>3213.<br>3214.<br>3215.<br>3216.<br>3217.<br>3218.<br>3219.<br>3220.<br>3221.<br>3222.<br>3223.<br>3224.<br>3225.<br>3226.<br>3227.<br>3228.<br>3229.<br>3230.<br>3231.<br>3232.<br>3233.<br>3234.<br>3235.<br>3236.<br>3237.<br>3238.<br>3239.<br>3240.<br>3241.<br>3242.<br>3243.<br>3244.<br>3245.<br>3246.<br>3247.<br>3248.<br>3249.<br>3250.<br>3251.<br>3252.<br>3253.<br>3254.<br>3255.<br>3256.<br>3257.<br>3258.<br>3259.<br>3260.<br>3261.<br>3262.<br>3263.<br>3264.<br>3265.<br>3266.<br>3267.<br>3268.<br>3269.<br>3270.<br>3271.<br>3272.<br>3273.<br>3274.<br>3275.<br>3276.<br>3277.<br>3278.<br>3279.<br>3280.<br>3281.<br>3282.<br>3283.<br>3284.<br>3285.<br>3286.<br>3287.<br>3288.<br>3289.<br>3290.<br>3291.<br>3292.<br>3293.<br>3294.<br>3295.<br>3296.<br>3297.<br>3298.<br>3299.<br>3300.<br>3301.<br>3302.<br>3303.<br>3304.<br>3305.<br>3306.<br>3307.<br>3308.<br>3309.<br>3310.<br>3311.<br>3312.<br>3313.<br>3314.<br>3315.<br>3316.<br>3317.<br>3318.<br>3319.<br>3320.<br>3321.<br>3322.<br>3323.<br>3324.<br>3325.<br>3326.<br>3327.<br>3328.<br>3329.<br>3330.<br>3331.<br>3332.<br>3333.<br>3334.<br>3335.<br>3336.<br>3337.<br>3338.<br>3339.<br>3340.<br>3341.<br>3342.<br>3343.<br>3344.<br>3345.<br>3346.<br>3347.<br>3348.<br>3349.<br>3350.<br>3351.<br>3352.<br>3353.<br>3354.<br>3355.<br>3356.<br>3357.<br>3358.<br>3359.<br>3360.<br>3361.<br>3362.<br>3363.<br>3364.<br>3365.<br>3366.<br>3367.<br>3368.<br>3369.<br>3370.<br>3371.<br>3372.<br>3373.<br>3374.<br>3375.<br>3376.<br>3377.<br>3378.<br>3379.<br>3380.<br>3381.<br>3382.<br>3383.<br>3384.<br>3385.<br>3386.<br>3387.<br>3388.<br>3389.<br>3390.<br>3391.<br>3392.<br>3393.<br>3394.<br>3395.<br>3396.<br>3397.<br>3398.<br>3399.<br>3400.<br>3401.<br>3402.<br>3403.<br>3404.<br>3405.<br>3406.<br>3407.<br>3408.<br>3409.<br>3410.<br>3411.<br>3412.<br>3413.<br>3414.<br>3415.<br>3416.<br>3417.<br>3418.<br>3419.<br>3420.<br>3421.<br>3422.<br>3423.<br>3424.<br>3425.<br>3426.<br>3427.<br>3428.<br>3429.<br>3430.<br>3431.<br>3432.<br>3433.<br>3434.<br>3435.<br>3436.<br>3437.<br>3438.<br>3439.<br>3440.<br>3441.<br>3442.<br>3443.<br>3444.<br>3445.<br>3446.<br>3447.<br>3448.<br>3449.<br>3450.<br>3451.<br>3452.<br>3453.<br>3454.<br>3455.<br>3456.<br>3457.<br>3458.<br>3459.<br>3460.<br>3461.<br>3462.<br>3463.<br>3464.<br>3465.<br>3466.<br>3467.<br>3468.<br>3469.<br>3470.<br>3471.<br>3472.<br>3473.<br>3474.<br>3475.<br>3476.<br>3477.<br>3478.<br>3479.<br>3480.<br>3481.<br>3482.<br>3483.<br>3484.<br>3485.<br>3486.<br>3487.<br>3488.<br>3489.<br>3490.<br>3491.<br>3492.<br>3493.<br>3494.<br>3495.<br>3496.<br>3497.<br>3498.<br>3499.<br>3500.<br>3501.<br>3502.<br>3503.<br>3504.<br>3505.<br>3506.<br>3507.<br>3508.<br>3509.<br>3510.<br>3511.<br>3512.<br>3513.<br>3514.<br>3515.<br>3516.<br>3517.<br>3518.<br>3519.<br>3520.<br>3521.<br>3522.<br>3523.<br>3524.<br>3525.<br>3526.<br>3527.<br>3528.<br>3529.<br>3530.<br>3531.<br>3532.<br>3533.<br>3534.<br>3535.<br>3536.<br>3537.<br>3538.<br>3539.<br>3540.<br>3541.<br>3542.<br>3543.<br>3544.<br>3545.<br>3546.<br>3547.<br>3548.<br>3549.<br>3550.<br>3551.<br>3552.<br>3553.<br>3554.<br>3555.<br>3556.<br>3557.<br>3558.<br>3559.<br>3560.<br>3561.<br>3562.<br>3563.<br>3564.<br>3565.<br>3566.<br>3567.<br>3568.<br>3569.<br>3570.<br>3571.<br>3572.<br>3573.<br>3574.<br>3575.<br>3576.<br>3577.<br>3578.<br>3579.<br>3580.<br>3581.<br>3582.<br>3583.<br>3584.<br>3585.<br>3586.<br>3587.<br>3588.<br>3589.<br>3590.<br>3591.<br>3592.<br>3593.<br>3594.<br>3595.<br>3596.<br>3597.<br>3598.<br>3599.<br>3600.<br>3601.<br>3602.<br>3603.<br>3604.<br>3605.<br>3606.<br>3607.<br>3608.<br>3609.<br>3610.<br>3611.<br>3612.<br>3613.<br>3614.<br>3615.<br>3616.<br>3617.<br>3618.<br>3619.<br>3620.<br>3621.<br>3622.<br>3623.<br>3624.<br>3625.<br>3626.<br>3627.<br>3628.<br>3629.<br>3630.<br>3631.<br>3632.<br>3633.<br>3634.<br>3635.<br>3636.<br>3637.<br>3638.<br>3639.<br>3640.<br>3641.<br>3642.<br>3643.<br>3644.<br>3645.<br>3646.<br>3647.<br>3648.<br>3649.<br>3650.<br>3651.<br>3652.<br>3653.<br>3654.<br>3655.<br>3656.<br>3657.<br>3658.<br>3659.<br>3660.<br>3661.<br>3662.<br>3663.<br>3664.<br>3665.<br>3666.<br>3667.<br>3668.<br>3669.<br>3670.<br>3671.<br>3672.<br>3673.<br>3674.<br>3675.<br>3676.<br>3677.<br>3678.<br>3679.<br>3680.<br>3681.<br>3682.<br>3683.<br>3684.<br>3685.<br>3686.<br>3687.<br>3688.<br>3689.<br>3690.<br>3691.<br>3692.<br>3693.<br>3694.<br>3695.<br>3696.<br>3697.<br>3698.<br>3699.<br>3700.<br>3701.<br>3702.<br>3703.<br>3704.<br>3705.<br>3706.<br>3707.<br>3708.<br>3709.<br>3710.<br>3711.<br>3712.<br>3713.<br>3714.<br>3715.<br>3716.<br>3717.<br>3718.<br>3719.<br>3720.<br>3721.<br>3722.<br>3723.<br>3724.<br>3725.<br>3726.<br>3727.<br>3728.<br>3729.<br>3730.<br>3731.<br>3732.<br>3733.<br>3734.<br>3735.<br>3736.<br>3737.<br>3738.<br>3739.<br>3740.<br>3741.<br>3742.<br>3743.<br>3744.<br>3745.<br>3746.<br>3747.<br>3748.<br>3749.<br>3750.<br>3751.<br>3752.<br>3753.<br>3754.<br>3755.<br>3756.<br>3757.<br>3758.<br>3759.<br>3760.<br>3761.<br>3762.<br>3763.<br>3764.<br>3765.<br>3766.<br>3767.<br>3768.<br>3769.<br>3770.<br>3771.<br>3772.<br>3773.<br>3774.<br>3775.<br>3776.<br>3777.<br>3778.<br>3779.<br>3780.<br>3781.<br>3782.<br>3783.<br>3784.<br>3785.<br>3786.<br>3787.<br>3788.<br>3789.<br>3790.<br>3791.<br>3792.<br>3793.<br>3794.<br>3795.<br>3796.<br>3797.<br>3798.<br>3799.<br>3800.<br>3801.<br>3802.<br>3803.<br>3804.<br>3805.<br>3806.<br>3807.<br>3808.<br>3809.<br>3810.<br>3811.<br>3812.<br>3813.<br>3814.<br>3815.<br>3816.<br>3817.<br>3818.<br>3819.<br>3820.<br>3821.<br>3822.<br>3823.<br>3824.<br>3825.<br>3826.<br>3827.<br>3828.<br>3829.<br>3830.<br>3831.<br>3832.<br>3833.<br>3834.<br>3835.<br>3836.<br>3837.<br>3838.<br>3839.<br>3840.<br>3841.<br>3842.<br>3843.<br>3844.<br>3845.<br>3846.<br>3847.<br>3848.<br>3849.<br>3850.<br>3851.<br>3852.<br>3853.<br>3854.<br>3855.<br>3856.<br>3857.<br>3858.<br>3859.<br>3860.<br>3861.<br>3862.<br>3863.<br>3864.<br>3865.<br>3866.<br>3867.<br>3868.<br>3869.<br>3870.<br>3871.<br>3872.<br>3873.<br>3874.<br>3875.<br>3876.<br>3877.<br>3878.<br>3879.<br>3880.<br>3881.<br>3882.<br>3883.<br>3884.<br>3885.<br>3886.<br>3887.<br>3888.<br>3889.<br>3890.<br>3891.<br>3892.<br>3893.<br>3894.<br>3895.<br>3896.<br>3897.<br>3898.<br>3899.<br>3900.<br>3901.<br>3902.<br>3903.<br>3904.<br>3905.<br>3906.<br>3907.<br>3908.<br>3909.<br>3910.<br>3911.<br>3912.<br>3913.<br>3914.<br>3915.<br>3916.<br>3917.<br>3918.<br>3919.<br>3920.<br>3921.<br>3922.<br>3923.<br>3924.<br>3925.<br>3926.<br>3927.<br>3928.<br>3929.<br>3930.<br>3931.<br>3932.<br>3933.<br>3934.<br>3935.<br>3936.<br>3937.<br>3938.<br>3939.<br>3940.<br>3941.<br>3942.<br>3943.<br>3944.<br>3945.<br>3946.<br>3947.<br>3948.<br>3949.<br>3950.<br>3951.<br>3952.<br>3953.<br>3954.<br>3955.<br>3956.<br>3957.<br>3958.<br>3959.<br>3960.<br>3961.<br>3962.<br>3963.<br>3964.<br>3965.<br>3966.<br>3967.<br>3968.<br>3969.<br>3970.<br>3971.<br>3972.<br>3973.<br>3974.<br>3975.<br>3976.<br>3977.<br>3978.<br>3979.<br>3980.<br>3981.<br>3982.<br>3983.<br>3984.<br>3985.<br>3986.<br>3987.<br>3988.<br>3989.<br>3990.<br>3991.<br>3992.<br>3993.<br>3994.<br>3995.<br>3996.<br>3997.<br>3998.<br>3999.<br>4000.<br>4001.<br>4002.<br>4003.<br>4004.<br>4005.<br>4006.<br>4007.<br>4008.<br>4009.<br>4010.<br>4011.<br>4012.<br>4013.<br>4014.<br>4015.<br>4016.<br>4017.<br>4018.<br>4019.<br>4020.<br>4021.<br>4022.<br>4023.<br>4024.<br>4025.<br>4026.<br>4027.<br>4028.<br>4029.<br>4030.<br>4031.<br>4032.<br>4033.<br>4034.<br>4035.<br>4036.<br>4037.<br>4038.<br>4039.<br>4040.<br>4041.<br>4042.<br>4043.<br>4044.<br>4045.<br>4046.<br>4047.<br>4048.<br>4049.<br>4050.<br>4051.<br>4052.<br>4053.<br>4054.<br>4055.<br>4056.<br>4057.<br>4058.<br>4059.<br>4060.<br>4061.<br>4062.<br>4063.<br>4064.<br>4065.<br>4066.<br>4067.<br>4068.<br>4069.<br>4070.<br>4071.<br>4072.<br>4073.<br>4074.<br>4075.<br>4076.<br>4077.<br>4078.<br>4079.<br>4080.<br>4081.<br>4082.<br>4083.<br>4084.<br>4085.<br>4086.<br>4087.<br>4088.<br>4089.<br>4090.<br>4091.<br>4092.<br>4093.<br>4094.<br>4095.<br>4096.<br>4097.<br>4098.<br>4099.<br>4100.<br>4101.<br>4102.<br>4103.<br>4104.<br>4105.<br>4106.<br>4107.<br>4108.<br>4109.<br>4110.<br>4111.<br>4112.<br>4113.<br>4114.<br>4115.<br>4116.<br>4117.<br>4118.<br>4119.<br>4120.<br>4121.<br>4122.<br>4123.<br>4124.<br>4125.<br>4126.<br>4127.<br>4128.<br>4129.<br>4130.<br>4131.<br>4132.<br>4133.<br>4134.<br>4135.<br>4136.<br>4137.<br>4138.<br>4139.<br>4140.<br>4141.<br>4142.<br>4143.<br>4144.<br>4145.<br>4146.<br>4147.<br>4148.<br>4149.<br>4150.<br>4151.<br>4152.<br>4153.<br>4154.<br>4155.<br>4156.<br>4157.<br>4158.<br>4159.<br>4160.<br>4161.<br>4162.<br>4163.<br>4164.<br>4165.<br>4166.<br>4167.<br>4168.<br>4169.<br>4170.<br>4171.<br>4172.<br>4173.<br>4174.<br>4175.<br>4176.<br>4177.<br>4178.<br>4179.<br>4180.<br>4181.<br>4182.<br>4183.<br>4184.<br>4185.<br>4186.<br>4187.<br>4188.<br>4189.<br>4190.<br>4191.<br>4192.<br>4193.<br>4194.<br>4195.<br>4196.<br>4197.<br>4198.<br>4199.<br>4200.<br>4201.<br>4202.<br>4203.<br>4204.<br>4205.<br>4206.<br>4207.<br>4208.<br>4209.<br>4210.<br>4211.<br>4212.<br>4213.<br>4214.<br>4215.<br>4216.<br>4217.<br>4218.<br>4219.<br>4220.<br>4221.<br>4222.<br>4223.<br>4224.<br>4225.<br>4226.<br>4227.<br>4228.<br>4229.<br>4230.<br>4231.<br>4232.<br>4233.<br>4234.<br>4235.<br>4236.<br>4237.<br>4238.<br>4239.<br>4240.<br>4241.<br>4242.<br>4243.<br>4244.<br>4245.<br>4246.<br>4247.<br>4248.<br>4249.<br>4250.<br>4251.<br>4252.<br>4253.<br>4254.<br>4255.<br>4256.<br>4257.<br>4258.<br>4259.<br>4260.<br>4261.<br>4262.<br>4263.<br>4264.<br>4265.<br>4266.<br>4267.<br>4268.<br>4269.<br>4270.<br>4271.<br>4272.<br>4273.<br>4274.<br>4275.<br>4276.<br>4277.<br>4278.<br>4279.<br>4280.<br>4281.<br>4282.<br>4283.<br>4284.<br>4285.<br>4286.<br>4287.<br>4288.<br>4289.<br>4290.<br>4291.<br>4292.<br>4293.<br>4294.<br>4295.<br>4296.<br>4297.<br>4298.<br>4299.<br>4300.<br>4301.<br>4302.<br>4303.<br>4304.<br>4305.<br>4306.<br>4307.<br>4308.<br>4309.<br>4310.<br>4311.<br>4312.<br>4313.<br>4314.<br>4315.<br>4316.<br>4317.<br>4318.<br>4319.<br>4320.<br>4321.<br>4322.<br>4323.<br>4324.<br>4325.<br>4326.<br>4327.<br>4328.<br>4329.<br>4330.<br>4331.<br>4332.<br>4333.<br>4334.<br>4335.<br>4336.<br>4337.<br>4338.<br>4339.<br>4340.<br>4341.<br>4342.<br>4343.<br>4344.<br>4345.<br>4346.<br>4347.<br>4348.<br>4349.<br>4350.<br>4351.<br>4352.<br>4353.<br>4354.<br>4355.<br>4356.<br>4357.<br>4358.<br>4359.<br>4360.<br>4361.<br>4362.<br>4363.<br>4364.<br>4365.<br>4366.<br>4367.<br>4368.<br>4369.<br>4370.<br>4371.<br>4372.<br>4373.<br>4374.<br>4375.<br>4376.<br>4377.<br>4378.<br>4379.<br>4380.<br>4381.<br>4382.<br>4383.<br>4384.<br>4385.<br>4386.<br>4387.<br>4388.<br>4389.<br>4390.<br>4391.<br>4392.<br>4393.<br>4394.<br>4395.<br>4396.<br>4397.<br>4398.<br>4399.<br>4400.<br>4401.<br>4402.<br>4403.<br>4404.<br>4405.<br>4406.<br>4407.<br>4408.<br>4409.<br>4410.<br>4411.<br>4412.<br>4413.<br>4414.<br>4415.<br>4416.<br>4417.<br>4418.<br>4419.<br>4420.<br>4421.<br>4422.<br>4423.<br>4424.<br>4425.<br>4426.<br>4427.<br>4428.<br>4429.<br>4430.<br>4431.<br>4432.<br>4433.<br>4434.<br>4435.<br>4436.<br>4437.<br>4438.<br>4439.<br>4440.<br>4441.<br>4442.<br>4443.<br>4444.<br>4445.<br>4446.<br>4447.<br>4448.<br>4449.<br>4450.<br>4451.<br>4452.<br>4453.<br>4454.<br>4455.<br>4456.<br>4457.<br>4458.<br>4459.<br>4460.<br>4461.<br>4462.<br>4463.<br>4464.<br>4465.<br>4466.<br>4467.<br>4468.<br>4469.<br>4470.<br>4471.<br>4472.<br>4473.<br>4474.<br>4475.<br>4476.<br>4477.<br>4478.<br>4479.<br>4480.<br>4481.<br>4482.<br>4483.<br>4484.<br>4485.<br>4486.<br>4487.<br>4488.<br>4489.<br>4490.<br>4491.<br>4492.<br>4493.<br>4494.<br>4495.<br>4496.<br>4497.<br>4498.<br>4499.<br>4500.<br>4501.<br>4502.<br>4503.<br>4504.<br>4505.<br>4506.<br>4507.<br>4508.<br>4509.<br>4510.<br>4511.<br>4512.<br>4513.<br>4514.<br>4515.<br>4516.<br>4517.<br>4518.<br>4519.<br>4520.<br>4521.<br>4522.<br>4523.<br>4524.<br>4525.<br>4526.<br>4527.<br>4528.<br>4529.<br>4530.<br>4531.<br>4532.<br>4533.<br>4534.<br>4535.<br>4536.<br>4537.<br>4538.<br>4539.<br>4540.<br>4541.<br>4542.<br>4543.<br>4544.<br>4545.<br>4546.<br>4547.<br>4548.<br>4549.<br>4550.<br>4551.<br>4552.<br>4553.<br>4554.<br>4555.<br>4556.<br>4557.<br>4558.<br>4559.<br>4560.<br>4561.<br>4562.<br>4563.<br>4564.<br>4565.<br>4566.<br>4567.<br>4568.<br>4569.<br>4570.<br>4571.<br>4572.<br>4573.<br>4574.<br>4575.<br>4576.<br>4577.<br>4578.<br>4579.<br>4580.<br>4581.<br>4582.<br>4583.<br>4584.<br>4585.<br>4586.<br>4587.<br>4588.<br>4589.<br>4590.<br>4591.<br>4592.<br>4593.<br>4594.<br>4595.<br>4596.<br>4597.<br>4598.<br>4599.<br>4600.<br>4601.<br>4602.<br>4603.<br>4604.<br>4605.<br>4606.<br>4607.<br>4608.<br>4609.<br>4610.<br>4611.<br>4612.<br>4613.<br>4614.<br>4615.<br>4616.<br>4617.<br>4618.<br>4619.<br>4620.<br>4621.<br>4622.<br>4623.<br>4624.<br>4625.<br>4626.<br>4627.<br>4628.<br>4629.<br>4630.<br>4631.<br>4632.<br>4633.<br>4634.<br>4635.<br>4636.<br>4637.<br>4638.<br>4639.<br>4640.<br>4641.<br>4642.<br>4643.<br>4644.<br>4645.<br>4646.<br>4647.<br>4648.<br>4649.<br>4650.<br>4651.<br>4652.<br>4653.<br>4654.<br>4655.<br>4656.<br>4657.<br>4658.<br>4659.<br>4660.<br>4661.<br>4662.<br>4663.<br>4664.<br>4665.<br>4666.<br>4667.<br>4668.<br>4669.<br>4670.<br>4671.<br>4672.<br>4673.<br>4674.<br>4675.<br>4676.<br>4677.<br>4678.<br>4679.<br>4680.<br>4681.<br>4682.<br>4683.<br>4684.<br>4685.<br>4686.<br>4687.<br>4688.<br>4689.<br>4690.<br>4691.<br>4692.<br>4693.<br>4694.<br>4695.<br>4696.<br>4697.<br>4698.<br>4699.<br>4700.<br>4701.<br>4702.<br>4703.<br>4704.<br>4705.<br>4706.<br>4707.<br>4708.<br>4709.<br>4710.<br>4711.<br>4712.<br>4713.<br>4714.<br>4715.<br>4716.<br>4717.<br>4718.<br>4719.<br>4720.<br>4721.<br>4722.<br>4723.<br>4724.<br>4725.<br>4726.<br>4727.<br>4728.<br>4729.<br>4730.<br>4731.<br>4732.<br>4733.<br>4734.<br>4735.<br>4736.<br>4737.<br>4738.<br>4739.<br>4740.<br>4741.<br>4742.<br>4743.<br>4744.<br>4745.<br>4746.<br>4747.<br>4748.<br>4749.<br>4750.<br>4751.<br>4752.<br>4753.<br>4754.<br>4755.<br>4756.<br>4757.<br>4758.<br>4759.<br>4760.<br>4761.<br>4762.<br>4763.<br>4764.<br>4765.<br>4766.<br>4767.<br>4768.<br>4769.<br>4770.<br>4771.<br>4772.<br>4773.<br>4774.<br>4775.<br>4776.<br>4777.<br>4778.<br>4779.<br>4780.<br>4781.<br>4782.<br>4783.<br>4784.<br>4785.<br>4786.<br>4787.<br>4788.<br>4789.<br>4790.<br>4791.<br>4792.<br>4793.<br>4794.<br>4795.<br>4796.<br>4797.<br>4798.<br>4799.<br>4800.<br>4801.<br>4802.<br>4803.<br>4804.<br>4805.<br>4806.<br>4807.<br>4808.<br>4809.<br>4810.<br>4811.<br>4812.<br>4813.<br>4814.<br>4815.<br>4816.<br>4817.<br>4818.<br>4819.<br>4820.<br>4821.<br>4822.<br>4823.<br>4824.<br>4825.<br>4826.<br>4827.<br>4828.<br>4829.<br>4830.<br>4831.<br>4832.<br>4833.<br>4834.<br>4835.<br>4836.<br>4837.<br>4838.<br>4839.<br>4840.<br>4841.<br>4842.<br>4843.<br>4844.<br>4845.<br>4846.<br>4847.<br>4848.<br>4849.<br>4850.<br>4851.<br>4852.<br>4853.<br>4854.<br>4855.<br>4856.<br>4857.<br>4858.<br>4859.<br>4860.<br>4861.<br>4862.<br>4863.<br>4864.<br>4865.<br>4866.<br>4867.<br>4868.<br>4869.<br>4870.<br>4871.<br>4872.<br>4873.<br>4874.<br>4875.<br>4876.<br>4877.<br>4878.<br>4879.<br>4880.<br>4881.<br>4882.<br>4883.<br>4884.<br>4885.<br>4886.<br>4887.<br>4888.<br>4889.<br>4890.<br>4891.<br>4892.<br>4893.<br>4894.<br>4895.<br>4896.<br>4897.<br>4898.<br>4899.<br>4900.<br>4901.<br>4902.<br>4903.<br>4904.<br>4905.<br>4906.<br>4907.<br>4908.<br>4909.<br>4910.<br>4911.<br>4912.<br>4913.<br>4914.<br>4915.<br>4916.<br>4917.<br>4918.<br>4919.<br>4920.<br>4921.<br>4922.<br>4923.<br>4924.<br>4925.<br>4926.<br>4927.<br>4928.<br>4929.<br>4930.<br>4931.<br>4932.<br>4933.<br>4934.<br>4935.<br>4936.<br>4937.<br>4938.<br>4939.<br>4940.<br>4941.<br>4942.<br>4943.<br>4944.<br>4945.<br>4946.<br>4947.<br>4948.<br>4949.<br>4950.<br>4951.<br>4952.<br>4953.<br>4954.<br>4955.<br>4956.<br>4957.<br>4958.<br>4959.<br>4960.<br>4961.<br>4962.<br>4963.<br>4964.<br>4965.<br>4966.<br>4967.<br>4968.<br>4969.<br>4970.<br>4971.<br>4972.<br>4973.<br>4974.<br>4975.<br>4976.<br>4977.<br>4978.<br>4979.<br>4980.<br>4981.<br>4982.<br>4983.<br>4984.<br>4985.<br>4986.<br>4987.<br>4988.<br>4989.<br>4990.<br>4991.<br>4992.<br>4993.<br>4994.<br>4995.<br>4996.<br>4997.<br>4998.<br>4999.<br>5000.<br>5001.<br>5002.<br>5003.<br>5004.<br>5005.<br>5006.<br>5007.<br>5008.<br>5009.<br>5010.<br>5011.<br>5012.<br>5013.<br>5014.<br>5015.<br>5016.<br>5017.<br>5018.<br>5019.<br>5020.<br>5021.<br>5022.<br>5023.<br>5024.<br>5025.<br>5026.<br>5027.<br>5028.<br>5029.<br>5030.<br>5031.<br>5032.<br>5033.<br>5034.<br>5035.<br>5036.<br>5037.<br>5038.<br>5039.<br>5040.<br>5041.<br>5042.<br>5043.<br>5044.<br>5045.<br>5046.<br>5047.<br>5048.<br>5049.<br>5050.<br>5051.<br>5052.<br>5053.<br>5054.<br>5055.<br>5056.<br>5057.<br>5058.<br>5059.<br>5060.<br>5061.<br>5062.<br>5063.<br>5064.<br>5065.<br>5066.<br>5067.<br>5068.<br>5069.<br>5070.<br>5071.<br>5072.<br>5073.<br>5074.<br>5075.<br>5076.<br>5077.<br>5078.<br>5079.<br>5080.<br>5081.<br>5082.<br>5083.<br>5084.<br>5085.<br>5086.<br>5087.<br>5088.<br>5089.<br>5090.<br>5091.<br>5092.<br>5093.<br>5094.<br>5095.<br>5096.<br>5097.<br>5098.<br>5099.<br>5100.<br>5101.<br>5102.<br>5103.<br>5104.<br>5105.<br>5106.<br>5107.<br>5108.<br>5109.<br>5110.<br>5111.<br>5112.<br>5113.<br>5114.<br>5115.<br>5116.<br>5117.<br>5118.<br>5119.<br>5120.<br>5121.<br>5122.<br>5123.<br>5124.<br>5125.<br>5126.<br>5127.<br>5128.<br>5129.<br>5130.<br>5131.<br>5132.<br>5133.<br>5134.<br>5135.<br>5136.<br>5137.<br>5138.<br>5139.<br>5140.<br>5141.<br>5142.<br>5143.<br>5144.<br>5145.<br>5146.<br>5147.<br>5148.<br>5149.<br>5150.<br>5151.<br>5152.<br>5153.<br>5154.<br>5155.<br>5156.<br>5157.<br>5158.<br>5159.<br>5160.<br>5161.<br>5162.<br>5163.<br>5164.<br>5165.<br>5166.<br>5167.<br>5168.<br>5169.<br>5170.<br>5171.<br>5172.<br>5173.<br>5174.<br>5175.<br>5176.<br>5177.<br>5178.<br>5179.<br>5180.<br>5181.<br>5182.<br>5183.<br>5184.<br>5185.<br>5186.<br>5187.<br>5188.<br>5189.<br>5190.<br>5191.<br>5192.<br>5193.<br>5194.<br>5195.<br>5196.<br>5197.<br>5198.<br>5199.<br>5200.<br>5201.<br>5202.<br>5203.<br>5204.<br>5205.<br>5206.<br>5207.<br>5208.<br>5209.<br>5210.<br>5211.<br>5212.<br>5213.<br>5214.<br>5215.<br>5216.<br>5217.<br>5218.<br>5219.<br>5220.<br>5221.<br>5222.<br>5223.<br>5224.<br>5225.<br>5226.<br>5227.<br>5228.<br>5229.<br>5230.<br>5231.<br>5232.<br>5233.<br>5234.<br>5235.<br>5236.<br>5237.<br>5238.<br>5239.<br>5240.<br>5241.<br>5242.<br>5243.<br>5244.<br>5245.<br>5246.<br>5247.<br>5248.<br>5249.<br>5250.<br>5251.<br>5252.<br>5253.<br>5254.<br>5255.<br>5256.<br>5257.<br>5258.<br>5259.<br>5260.<br>5261.<br>5262.<br>5263.<br>5264.<br>5265.<br>5266.<br>5267.<br>5268.<br>5269.<br>5270.<br>5271.<br>5272.<br>5273.<br>5274.<br>5275.<br>5276.<br>5277.<br>5278.<br>5279.<br>5280.<br>5281.<br>5282.<br>5283.<br>5284.<br>5285.<br>5286.<br>5287.<br>5288.<br>5289.<br>5290.<br>5291.<br>5292.<br>5293.<br>5294.<br>5295.<br>5296.<br>5297.<br>5298.<br>5299.<br>5300.<br>5301.<br>5302.<br>5303.<br>5304.<br>5305.<br>5306.<br>5307.<br>5308.<br>5309.<br>5310.<br>5311.<br>5312.<br>5313.<br>5314.<br>5315.<br>5316.<br>5317.<br>5318.<br>5319.<br>5320.<br>5321.<br>5322.<br>5323.<br>5324.<br>5325.<br>5326.<br>5327.<br>5328.<br>5329.<br>5330.<br>5331.<br>5332.<br>5333.<br>5334.<br>5335.<br>5336.<br>5337.<br>5338.<br>5339.<br>5340.<br>5341.<br>5342.<br>5343.<br>5344.<br>5345.<br>5346.<br>5347.<br>5348.<br>5349.<br>5350.<br>5351.<br>5352.<br>5353.<br>5354.<br>5355.<br>5356.<br>5357.<br>5358.<br>5359.<br>5360.<br>5361.<br>5362.<br>5363.<br>5364.<br>5365.<br>5366.<br>5367.<br>5368.<br>5369.<br>5370.<br>5371.<br>5372.<br>5373.<br>5374.<br>5375.<br>5376.<br>5377.<br>5378.<br>5379.<br>5380.<br>5381.<br>5382.<br>5383.<br>5384.<br>5385.<br>5386.<br>5387.<br>5388.<br>5389.<br>5390.<br>5391.<br>5392.<br>5393.<br>5394.<br>5395.<br>5396.<br>5397.<br>5398.<br>5399.<br>5400.<br>5401.<br>5402.<br>5403.<br>5404.<br>5405.<br>5406.<br>5407.<br>5408.<br>5409.<br>5410.<br>5411.<br>5412.<br>5413.<br>5414.<br>5415.<br>5416.<br>5417.<br>5418.<br>5419.<br>5420.<br>5421.<br>5422.<br>5423.<br>5424.<br>5425.<br>5426.<br>5427.<br>5428.<br>5429.<br>5430.<br>5431.<br>5432.<br>5433.<br>5434.<br>5435.<br>5436.<br>5437.<br>5438.<br>5439.<br>5440.<br>5441.<br>5442.<br>5443.<br>5444.<br>5445.<br>5446.<br>5447.<br>5448.<br>5449.<br>5450.<br>5451.<br>5452.<br>5453.<br>5454.<br>5455.<br>5456.<br>5457.<br>5458.<br>5459.<br>5460.<br>5461.<br>5462.<br>5463.<br>5464.<br>5465.<br>5466.<br>5467.<br>5468.<br>5469.<br>5470.<br>5471.<br>5472.<br>5473.<br>5474.<br>5475.<br>5476.<br>5477.<br>5478.<br>5479.<br>5480.<br>5481.<br>5482.<br>5483.<br>5484.<br>5485.<br>5486.<br>5487.<br>5488.<br>5489.<br>5490.<br>5491.<br>5492.<br>5493.<br>5494.<br>5495.<br>5496.<br>5497.<br>5498.<br>5499.<br>5500.<br>5501.<br>5502.<br>5503.<br>5504.<br>5505.<br>5506.<br>5507.<br>5508.<br>5509.<br>5510.<br>5511.<br>5512.<br>5513.<br>5514.<br>5515.<br>5516.<br>5517.<br>5518.<br>5519.<br>5520.<br>5521.<br>5522.<br>5523.<br>5524.<br>5525.<br>5526.<br>5527.<br>5528.<br>5529.<br>5530.<br>5531.<br>5532.<br>5533.<br>5534.<br>5535.<br>5536.<br>5537.<br>5538.<br>5539.<br>5540.<br>5541.<br>5542.<br>5543.<br>5544.<br>5545.<br>5546.<br>5547.<br>5548.<br>5549.<br>5550.<br>5551.<br>5552.<br>5553.<br>5554.<br>5555.<br>5556.<br>5557.<br>5558.<br>5559.<br>5560.<br>5561.<br>5562.<br>5563.<br>5564.<br>5565.<br>5566.<br>5567.<br>5568.<br>5569.<br>5570.<br>5571.<br>5572.<br>5573.<br>5574.<br>5575.<br>5576.<br>5577.<br>5578.<br>5579.<br>5580.<br>5581.<br>5582.<br>5583.<br>5584.<br>5585.<br>5586.<br>5587.<br>5588.<br>5589.<br>5590.<br>5591.<br>5592.<br>5593.<br>5594.<br>5595.<br>5596.<br>5597.<br>5598.<br>5599.<br>5600.<br>5601.<br>5602.<br>5603.<br>5604.<br>5605.<br>5606.<br>5607.<br>5608.<br>5609.<br>5610.<br>5611.<br>5612.<br>5613.<br>5614.<br>5615.<br>5616.<br>5617.<br>5618.<br>5619.<br>5620.<br>5621.<br>5622.<br>5623.<br>5624.<br>5625.<br>5626.<br>5627.<br>5628.<br>5629.<br>5630.<br>5631.<br>5632.<br>5633.<br>5634.<br>5635.<br>5636.<br>5637.<br>5638.<br>5639.<br>5640.<br>5641.<br>5642.<br>5643.<br>5644.<br>5645.<br>5646.<br>5647.<br>5648.<br>5649.<br>5650.<br>5651.<br>5652.<br>5653.<br>5654.<br>5655.<br>5656.<br>5657.<br>5658.<br>5659.<br>5660.<br>5661.<br>5662.<br>5663.<br>5664.<br>5665.<br>5666.<br>5667.<br>5668.<br>5669.<br>5670.<br>5671.<br>5672.<br>5673.<br>5674.<br>5675.<br>5676.<br>5677.<br>5678.<br>5679.<br>5680.<br>5681.<br>5682.<br>5683.<br>5684.<br>5685.<br>5686.<br>5687.<br>5688.<br>5689.<br>5690.<br>5691.<br>5692.<br>5693.<br>5694.<br>5695.<br>5696.<br>5697.<br>5698.<br>5699.<br>5700.<br>5701.<br>5702.<br>5703.<br>5704.<br>5705.<br>5706.<br>5707.<br>5708.<br>5709.<br>5710.<br>5711.<br>5712.<br>5713.<br>5714.<br>5715.<br>5716.<br>5717.<br>5718.<br>5719.<br>5720.<br>5721.<br>5722.<br>5723.<br>5724.<br>5725.<br>5726.<br>5727.<br>5728.<br>5729.<br>5730.<br>5731.<br>5732.<br>5733.<br>5734.<br>5735.<br>5736.<br>5737.<br>5738.<br>5739.<br>5740.<br>5741.<br>5742.<br>5743.<br>5744.<br>5745.<br>5746.<br>5747.<br>5748.<br>5749.<br>5750.<br>5751.<br>5752.<br>5753.<br>5754.<br>5755.<br>5756.<br>5757.<br>5758.<br>5759.<br>5760.<br>5761.<br>5762.<br>5763.<br>5764.<br>5765.<br>5766.<br>5767.<br>5768.<br>5769.<br>5770.<br>5771.<br>5772.<br>5773.<br>5774.<br>5775.<br>5776.<br>5777.<br>5778.<br>5779.<br>5780.<br>5781.<br>5782.<br>5783.<br>5784.<br>5785.<br>5786.<br>5787.<br>5788.<br>5789.<br>5790.<br>5791.<br>5792.<br>5793.<br>5794.<br>5795.<br>5796.<br>5797.<br>5798.<br>5799.<br>5800.<br>5801.<br>5802.<br>5803.<br>5804.<br>5805.<br>5806.<br>5807.<br>5808.<br>5809.<br>5810.<br>5811.<br>5812.<br>5813.<br>5814.<br>5815.<br>5816.<br>5817.<br>5818.<br>5819.<br>5820.<br>5821.<br>5822.<br>5823.<br>5824.<br>5825.<br>5826.<br>5827.<br>5828.<br>5829.<br>5830.<br>5831.<br>5832.<br>5833.<br>5834.<br>5835.<br>5836.<br>5837.<br>5838.<br>5839.<br>5840.<br>5841.<br>5842.<br>5843.<br>5844.<br>5845.<br>5846.<br>5847.<br>5848.<br>5849.<br>5850.<br>5851.<br>5852.<br>5853.<br>5854.<br></code_line></pre></td>
<td class='lines'><pre><code class="prettyprint">// SPDX-License-Identifier: GPL-2.0-only
/******************************************************************************
 * emulate.c
 *
 * Generic x86 (32-bit and 64-bit) instruction decoder and emulator.
 *
 * Copyright (c) 2005 Keir Fraser
 *
 * Linux coding style, mod r/m decoder, segment base fixes, real-mode
 * privileged instructions:
 *
 * Copyright (C) 2006 Qumranet
 * Copyright 2010 Red Hat, Inc. and/or its affiliates.
 *
 *   Avi Kivity &lt;avi@qumranet.com&gt;
 *   Yaniv Kamay &lt;yaniv@qumranet.com&gt;
 *
 * From: xen-unstable 10676:af9809f51f81a3c43f276f00c81a52ef558afda4
 */

#include &lt;linux/kvm_host.h&gt;
#include &quot;kvm_cache_regs.h&quot;
#include &quot;kvm_emulate.h&quot;
#include &lt;linux/stringify.h&gt;
#include &lt;asm/debugreg.h&gt;
#include &lt;asm/nospec-branch.h&gt;
#include &lt;asm/ibt.h&gt;

#include &quot;x86.h&quot;
#include &quot;tss.h&quot;
#include &quot;mmu.h&quot;
#include &quot;pmu.h&quot;

/*
 * Operand types
 */
#define OpNone             0ull
#define OpImplicit         1ull  /* No generic decode */
#define OpReg              2ull  /* Register */
#define OpMem              3ull  /* Memory */
#define OpAcc              4ull  /* Accumulator: AL/AX/EAX/RAX */
#define OpDI               5ull  /* ES:DI/EDI/RDI */
#define OpMem64            6ull  /* Memory, 64-bit */
#define OpImmUByte         7ull  /* Zero-extended 8-bit immediate */
#define OpDX               8ull  /* DX register */
#define OpCL               9ull  /* CL register (for shifts) */
#define OpImmByte         10ull  /* 8-bit sign extended immediate */
#define OpOne             11ull  /* Implied 1 */
#define OpImm             12ull  /* Sign extended up to 32-bit immediate */
#define OpMem16           13ull  /* Memory operand (16-bit). */
#define OpMem32           14ull  /* Memory operand (32-bit). */
#define OpImmU            15ull  /* Immediate operand, zero extended */
#define OpSI              16ull  /* SI/ESI/RSI */
#define OpImmFAddr        17ull  /* Immediate far address */
#define OpMemFAddr        18ull  /* Far address in memory */
#define OpImmU16          19ull  /* Immediate operand, 16 bits, zero extended */
#define OpES              20ull  /* ES */
#define OpCS              21ull  /* CS */
#define OpSS              22ull  /* SS */
#define OpDS              23ull  /* DS */
#define OpFS              24ull  /* FS */
#define OpGS              25ull  /* GS */
#define OpMem8            26ull  /* 8-bit zero extended memory operand */
#define OpImm64           27ull  /* Sign extended 16/32/64-bit immediate */
#define OpXLat            28ull  /* memory at BX/EBX/RBX + zero-extended AL */
#define OpAccLo           29ull  /* Low part of extended acc (AX/AX/EAX/RAX) */
#define OpAccHi           30ull  /* High part of extended acc (-/DX/EDX/RDX) */

#define OpBits             5  /* Width of operand field */
#define OpMask             ((1ull &lt;&lt; OpBits) - 1)

/*
 * Opcode effective-address decode tables.
 * Note that we only emulate instructions that have at least one memory
 * operand (excluding implicit stack references). We assume that stack
 * references and instruction fetches will never occur in special memory
 * areas that require emulation. So, for example, &#x27;mov &lt;imm&gt;,&lt;reg&gt;&#x27; need
 * not be handled.
 */

/* Operand sizes: 8-bit operands or specified/overridden size. */
#define ByteOp      (1&lt;&lt;0)	/* 8-bit operands. */
/* Destination operand type. */
#define DstShift    1
#define ImplicitOps (OpImplicit &lt;&lt; DstShift)
#define DstReg      (OpReg &lt;&lt; DstShift)
#define DstMem      (OpMem &lt;&lt; DstShift)
#define DstAcc      (OpAcc &lt;&lt; DstShift)
#define DstDI       (OpDI &lt;&lt; DstShift)
#define DstMem64    (OpMem64 &lt;&lt; DstShift)
#define DstMem16    (OpMem16 &lt;&lt; DstShift)
#define DstImmUByte (OpImmUByte &lt;&lt; DstShift)
#define DstDX       (OpDX &lt;&lt; DstShift)
#define DstAccLo    (OpAccLo &lt;&lt; DstShift)
#define DstMask     (OpMask &lt;&lt; DstShift)
/* Source operand type. */
#define SrcShift    6
#define SrcNone     (OpNone &lt;&lt; SrcShift)
#define SrcReg      (OpReg &lt;&lt; SrcShift)
#define SrcMem      (OpMem &lt;&lt; SrcShift)
#define SrcMem16    (OpMem16 &lt;&lt; SrcShift)
#define SrcMem32    (OpMem32 &lt;&lt; SrcShift)
#define SrcImm      (OpImm &lt;&lt; SrcShift)
#define SrcImmByte  (OpImmByte &lt;&lt; SrcShift)
#define SrcOne      (OpOne &lt;&lt; SrcShift)
#define SrcImmUByte (OpImmUByte &lt;&lt; SrcShift)
#define SrcImmU     (OpImmU &lt;&lt; SrcShift)
#define SrcSI       (OpSI &lt;&lt; SrcShift)
#define SrcXLat     (OpXLat &lt;&lt; SrcShift)
#define SrcImmFAddr (OpImmFAddr &lt;&lt; SrcShift)
#define SrcMemFAddr (OpMemFAddr &lt;&lt; SrcShift)
#define SrcAcc      (OpAcc &lt;&lt; SrcShift)
#define SrcImmU16   (OpImmU16 &lt;&lt; SrcShift)
#define SrcImm64    (OpImm64 &lt;&lt; SrcShift)
#define SrcDX       (OpDX &lt;&lt; SrcShift)
#define SrcMem8     (OpMem8 &lt;&lt; SrcShift)
#define SrcAccHi    (OpAccHi &lt;&lt; SrcShift)
#define SrcMask     (OpMask &lt;&lt; SrcShift)
#define BitOp       (1&lt;&lt;11)
#define MemAbs      (1&lt;&lt;12)      /* Memory operand is absolute displacement */
#define String      (1&lt;&lt;13)     /* String instruction (rep capable) */
#define Stack       (1&lt;&lt;14)     /* Stack instruction (push/pop) */
#define GroupMask   (7&lt;&lt;15)     /* Opcode uses one of the group mechanisms */
#define Group       (1&lt;&lt;15)     /* Bits 3:5 of modrm byte extend opcode */
#define GroupDual   (2&lt;&lt;15)     /* Alternate decoding of mod == 3 */
#define Prefix      (3&lt;&lt;15)     /* Instruction varies with 66/f2/f3 prefix */
#define RMExt       (4&lt;&lt;15)     /* Opcode extension in ModRM r/m if mod == 3 */
#define Escape      (5&lt;&lt;15)     /* Escape to coprocessor instruction */
#define InstrDual   (6&lt;&lt;15)     /* Alternate instruction decoding of mod == 3 */
#define ModeDual    (7&lt;&lt;15)     /* Different instruction for 32/64 bit */
#define Sse         (1&lt;&lt;18)     /* SSE Vector instruction */
/* Generic ModRM decode. */
#define ModRM       (1&lt;&lt;19)
/* Destination is only written; never read. */
#define Mov         (1&lt;&lt;20)
/* Misc flags */
#define Prot        (1&lt;&lt;21) /* instruction generates #UD if not in prot-mode */
#define EmulateOnUD (1&lt;&lt;22) /* Emulate if unsupported by the host */
#define NoAccess    (1&lt;&lt;23) /* Don&#x27;t access memory (lea/invlpg/verr etc) */
#define Op3264      (1&lt;&lt;24) /* Operand is 64b in long mode, 32b otherwise */
#define Undefined   (1&lt;&lt;25) /* No Such Instruction */
#define Lock        (1&lt;&lt;26) /* lock prefix is allowed for the instruction */
#define Priv        (1&lt;&lt;27) /* instruction generates #GP if current CPL != 0 */
#define No64	    (1&lt;&lt;28)
#define PageTable   (1 &lt;&lt; 29)   /* instruction used to write page table */
#define NotImpl     (1 &lt;&lt; 30)   /* instruction is not implemented */
/* Source 2 operand type */
#define Src2Shift   (31)
#define Src2None    (OpNone &lt;&lt; Src2Shift)
#define Src2Mem     (OpMem &lt;&lt; Src2Shift)
#define Src2CL      (OpCL &lt;&lt; Src2Shift)
#define Src2ImmByte (OpImmByte &lt;&lt; Src2Shift)
#define Src2One     (OpOne &lt;&lt; Src2Shift)
#define Src2Imm     (OpImm &lt;&lt; Src2Shift)
#define Src2ES      (OpES &lt;&lt; Src2Shift)
#define Src2CS      (OpCS &lt;&lt; Src2Shift)
#define Src2SS      (OpSS &lt;&lt; Src2Shift)
#define Src2DS      (OpDS &lt;&lt; Src2Shift)
#define Src2FS      (OpFS &lt;&lt; Src2Shift)
#define Src2GS      (OpGS &lt;&lt; Src2Shift)
#define Src2Mask    (OpMask &lt;&lt; Src2Shift)
#define Mmx         ((u64)1 &lt;&lt; 40)  /* MMX Vector instruction */
#define AlignMask   ((u64)7 &lt;&lt; 41)
#define Aligned     ((u64)1 &lt;&lt; 41)  /* Explicitly aligned (e.g. MOVDQA) */
#define Unaligned   ((u64)2 &lt;&lt; 41)  /* Explicitly unaligned (e.g. MOVDQU) */
#define Avx         ((u64)3 &lt;&lt; 41)  /* Advanced Vector Extensions */
#define Aligned16   ((u64)4 &lt;&lt; 41)  /* Aligned to 16 byte boundary (e.g. FXSAVE) */
#define Fastop      ((u64)1 &lt;&lt; 44)  /* Use opcode::u.fastop */
#define NoWrite     ((u64)1 &lt;&lt; 45)  /* No writeback */
#define SrcWrite    ((u64)1 &lt;&lt; 46)  /* Write back src operand */
#define NoMod	    ((u64)1 &lt;&lt; 47)  /* Mod field is ignored */
#define Intercept   ((u64)1 &lt;&lt; 48)  /* Has valid intercept field */
#define CheckPerm   ((u64)1 &lt;&lt; 49)  /* Has valid check_perm field */
#define PrivUD      ((u64)1 &lt;&lt; 51)  /* #UD instead of #GP on CPL &gt; 0 */
#define NearBranch  ((u64)1 &lt;&lt; 52)  /* Near branches */
#define No16	    ((u64)1 &lt;&lt; 53)  /* No 16 bit operand */
#define IncSP       ((u64)1 &lt;&lt; 54)  /* SP is incremented before ModRM calc */
#define TwoMemOp    ((u64)1 &lt;&lt; 55)  /* Instruction has two memory operand */
#define IsBranch    ((u64)1 &lt;&lt; 56)  /* Instruction is considered a branch. */

#define DstXacc     (DstAccLo | SrcAccHi | SrcWrite)

#define X2(x...) x, x
#define X3(x...) X2(x), x
#define X4(x...) X2(x), X2(x)
#define X5(x...) X4(x), x
#define X6(x...) X4(x), X2(x)
#define X7(x...) X4(x), X3(x)
#define X8(x...) X4(x), X4(x)
#define X16(x...) X8(x), X8(x)

struct opcode {
	u64 flags;
	u8 intercept;
	u8 pad[7];
	union {
		int (*execute)(struct x86_emulate_ctxt *ctxt);
		const struct opcode *group;
		const struct group_dual *gdual;
		const struct gprefix *gprefix;
		const struct escape *esc;
		const struct instr_dual *idual;
		const struct mode_dual *mdual;
		void (*fastop)(struct fastop *fake);
	} u;
	int (*check_perm)(struct x86_emulate_ctxt *ctxt);
};

struct group_dual {
	struct opcode mod012[8];
	struct opcode mod3[8];
};

struct gprefix {
	struct opcode pfx_no;
	struct opcode pfx_66;
	struct opcode pfx_f2;
	struct opcode pfx_f3;
};

struct escape {
	struct opcode op[8];
	struct opcode high[64];
};

struct instr_dual {
	struct opcode mod012;
	struct opcode mod3;
};

struct mode_dual {
	struct opcode mode32;
	struct opcode mode64;
};

#define EFLG_RESERVED_ZEROS_MASK 0xffc0802a

enum x86_transfer_type {
	X86_TRANSFER_NONE,
	X86_TRANSFER_CALL_JMP,
	X86_TRANSFER_RET,
	X86_TRANSFER_TASK_SWITCH,
};

static ulong reg_read(struct x86_emulate_ctxt *ctxt, unsigned nr)
{
<blue>	if (KVM_EMULATOR_BUG_ON(nr >= NR_EMULATOR_GPRS, ctxt))</blue>
		nr &amp;= NR_EMULATOR_GPRS - 1;

<blue>	if (!(ctxt->regs_valid & (1 << nr))) {</blue>
<blue>		ctxt->regs_valid |= 1 << nr;</blue>
		ctxt-&gt;_regs[nr] = ctxt-&gt;ops-&gt;read_gpr(ctxt, nr);
	}
<blue>	return ctxt->_regs[nr];</blue>
}

static ulong *reg_write(struct x86_emulate_ctxt *ctxt, unsigned nr)
{
<blue>	if (KVM_EMULATOR_BUG_ON(nr >= NR_EMULATOR_GPRS, ctxt))</blue>
		nr &amp;= NR_EMULATOR_GPRS - 1;

	BUILD_BUG_ON(sizeof(ctxt-&gt;regs_dirty) * BITS_PER_BYTE &lt; NR_EMULATOR_GPRS);
	BUILD_BUG_ON(sizeof(ctxt-&gt;regs_valid) * BITS_PER_BYTE &lt; NR_EMULATOR_GPRS);

<blue>	ctxt->regs_valid |= 1 << nr;</blue>
	ctxt-&gt;regs_dirty |= 1 &lt;&lt; nr;
	return &amp;ctxt-&gt;_regs[nr];
}

static ulong *reg_rmw(struct x86_emulate_ctxt *ctxt, unsigned nr)
{
<blue>	reg_read(ctxt, nr);</blue>
<blue>	return reg_write(ctxt, nr);</blue>
}

static void writeback_registers(struct x86_emulate_ctxt *ctxt)
{
<blue>	unsigned long dirty = ctxt->regs_dirty;</blue>
	unsigned reg;

<blue>	for_each_set_bit(reg, &dirty, NR_EMULATOR_GPRS)</blue>
<blue>		ctxt->ops->write_gpr(ctxt, reg, ctxt->_regs[reg]);</blue>
<blue>}</blue>

static void invalidate_registers(struct x86_emulate_ctxt *ctxt)
{
<yellow>	ctxt->regs_dirty = 0;</yellow>
	ctxt-&gt;regs_valid = 0;
}

/*
 * These EFLAGS bits are restored from saved value during emulation, and
 * any changes are written back to the saved value after emulation.
 */
#define EFLAGS_MASK (X86_EFLAGS_OF|X86_EFLAGS_SF|X86_EFLAGS_ZF|X86_EFLAGS_AF|\
		     X86_EFLAGS_PF|X86_EFLAGS_CF)

#ifdef CONFIG_X86_64
#define ON64(x) x
#else
#define ON64(x)
#endif

/*
 * fastop functions have a special calling convention:
 *
 * dst:    rax        (in/out)
 * src:    rdx        (in/out)
 * src2:   rcx        (in)
 * flags:  rflags     (in/out)
 * ex:     rsi        (in:fastop pointer, out:zero if exception)
 *
 * Moreover, they are all exactly FASTOP_SIZE bytes long, so functions for
 * different operand sizes can be reached by calculation, rather than a jump
 * table (which would be bigger than the code).
 *
 * The 16 byte alignment, considering 5 bytes for the RET thunk, 3 for ENDBR
 * and 1 for the straight line speculation INT3, leaves 7 bytes for the
 * body of the function.  Currently none is larger than 4.
 */
static int fastop(struct x86_emulate_ctxt *ctxt, fastop_t fop);

#define FASTOP_SIZE	16

#define __FOP_FUNC(name) \
	&quot;.align &quot; __stringify(FASTOP_SIZE) &quot; \n\t&quot; \
	&quot;.type &quot; name &quot;, @function \n\t&quot; \
	name &quot;:\n\t&quot; \
	ASM_ENDBR \
	IBT_NOSEAL(name)

#define FOP_FUNC(name) \
	__FOP_FUNC(#name)

#define __FOP_RET(name) \
	&quot;11: &quot; ASM_RET \
	&quot;.size &quot; name &quot;, .-&quot; name &quot;\n\t&quot;

#define FOP_RET(name) \
	__FOP_RET(#name)

#define __FOP_START(op, align) \
	extern void em_##op(struct fastop *fake); \
	asm(&quot;.pushsection .text, \&quot;ax\&quot; \n\t&quot; \
	    &quot;.global em_&quot; #op &quot; \n\t&quot; \
	    &quot;.align &quot; __stringify(align) &quot; \n\t&quot; \
	    &quot;em_&quot; #op &quot;:\n\t&quot;

#define FOP_START(op) __FOP_START(op, FASTOP_SIZE)

#define FOP_END \
	    &quot;.popsection&quot;)

#define __FOPNOP(name) \
	__FOP_FUNC(name) \
	__FOP_RET(name)

#define FOPNOP() \
	__FOPNOP(__stringify(__UNIQUE_ID(nop)))

#define FOP1E(op,  dst) \
	__FOP_FUNC(#op &quot;_&quot; #dst) \
	&quot;10: &quot; #op &quot; %&quot; #dst &quot; \n\t&quot; \
	__FOP_RET(#op &quot;_&quot; #dst)

#define FOP1EEX(op,  dst) \
	FOP1E(op, dst) _ASM_EXTABLE_TYPE_REG(10b, 11b, EX_TYPE_ZERO_REG, %%esi)

#define FASTOP1(op) \
	FOP_START(op) \
	FOP1E(op##b, al) \
	FOP1E(op##w, ax) \
	FOP1E(op##l, eax) \
	ON64(FOP1E(op##q, rax))	\
	FOP_END

/* 1-operand, using src2 (for MUL/DIV r/m) */
#define FASTOP1SRC2(op, name) \
	FOP_START(name) \
	FOP1E(op, cl) \
	FOP1E(op, cx) \
	FOP1E(op, ecx) \
	ON64(FOP1E(op, rcx)) \
	FOP_END

/* 1-operand, using src2 (for MUL/DIV r/m), with exceptions */
#define FASTOP1SRC2EX(op, name) \
	FOP_START(name) \
	FOP1EEX(op, cl) \
	FOP1EEX(op, cx) \
	FOP1EEX(op, ecx) \
	ON64(FOP1EEX(op, rcx)) \
	FOP_END

#define FOP2E(op,  dst, src)	   \
	__FOP_FUNC(#op &quot;_&quot; #dst &quot;_&quot; #src) \
	#op &quot; %&quot; #src &quot;, %&quot; #dst &quot; \n\t&quot; \
	__FOP_RET(#op &quot;_&quot; #dst &quot;_&quot; #src)

#define FASTOP2(op) \
	FOP_START(op) \
	FOP2E(op##b, al, dl) \
	FOP2E(op##w, ax, dx) \
	FOP2E(op##l, eax, edx) \
	ON64(FOP2E(op##q, rax, rdx)) \
	FOP_END

/* 2 operand, word only */
#define FASTOP2W(op) \
	FOP_START(op) \
	FOPNOP() \
	FOP2E(op##w, ax, dx) \
	FOP2E(op##l, eax, edx) \
	ON64(FOP2E(op##q, rax, rdx)) \
	FOP_END

/* 2 operand, src is CL */
#define FASTOP2CL(op) \
	FOP_START(op) \
	FOP2E(op##b, al, cl) \
	FOP2E(op##w, ax, cl) \
	FOP2E(op##l, eax, cl) \
	ON64(FOP2E(op##q, rax, cl)) \
	FOP_END

/* 2 operand, src and dest are reversed */
#define FASTOP2R(op, name) \
	FOP_START(name) \
	FOP2E(op##b, dl, al) \
	FOP2E(op##w, dx, ax) \
	FOP2E(op##l, edx, eax) \
	ON64(FOP2E(op##q, rdx, rax)) \
	FOP_END

#define FOP3E(op,  dst, src, src2) \
	__FOP_FUNC(#op &quot;_&quot; #dst &quot;_&quot; #src &quot;_&quot; #src2) \
	#op &quot; %&quot; #src2 &quot;, %&quot; #src &quot;, %&quot; #dst &quot; \n\t&quot;\
	__FOP_RET(#op &quot;_&quot; #dst &quot;_&quot; #src &quot;_&quot; #src2)

/* 3-operand, word-only, src2=cl */
#define FASTOP3WCL(op) \
	FOP_START(op) \
	FOPNOP() \
	FOP3E(op##w, ax, dx, cl) \
	FOP3E(op##l, eax, edx, cl) \
	ON64(FOP3E(op##q, rax, rdx, cl)) \
	FOP_END

/* Special case for SETcc - 1 instruction per cc */
#define FOP_SETCC(op) \
	FOP_FUNC(op) \
	#op &quot; %al \n\t&quot; \
	FOP_RET(op)

FOP_START(setcc)
FOP_SETCC(seto)
FOP_SETCC(setno)
FOP_SETCC(setc)
FOP_SETCC(setnc)
FOP_SETCC(setz)
FOP_SETCC(setnz)
FOP_SETCC(setbe)
FOP_SETCC(setnbe)
FOP_SETCC(sets)
FOP_SETCC(setns)
FOP_SETCC(setp)
FOP_SETCC(setnp)
FOP_SETCC(setl)
FOP_SETCC(setnl)
FOP_SETCC(setle)
FOP_SETCC(setnle)
FOP_END;

FOP_START(salc)
FOP_FUNC(salc)
&quot;pushf; sbb %al, %al; popf \n\t&quot;
FOP_RET(salc)
FOP_END;

/*
 * XXX: inoutclob user must know where the argument is being expanded.
 *      Using asm goto would allow us to remove _fault.
 */
#define asm_safe(insn, inoutclob...) \
({ \
	int _fault = 0; \
 \
	asm volatile(&quot;1:&quot; insn &quot;\n&quot; \
	             &quot;2:\n&quot; \
		     _ASM_EXTABLE_TYPE_REG(1b, 2b, EX_TYPE_ONE_REG, %[_fault]) \
	             : [_fault] &quot;+r&quot;(_fault) inoutclob ); \
 \
	_fault ? X86EMUL_UNHANDLEABLE : X86EMUL_CONTINUE; \
})

static int emulator_check_intercept(struct x86_emulate_ctxt *ctxt,
				    enum x86_intercept intercept,
				    enum x86_intercept_stage stage)
{
	struct x86_instruction_info info = {
		.intercept  = intercept,
<blue>		.rep_prefix = ctxt->rep_prefix,</blue>
		.modrm_mod  = ctxt-&gt;modrm_mod,
		.modrm_reg  = ctxt-&gt;modrm_reg,
		.modrm_rm   = ctxt-&gt;modrm_rm,
		.src_val    = ctxt-&gt;src.val64,
		.dst_val    = ctxt-&gt;dst.val64,
		.src_bytes  = ctxt-&gt;src.bytes,
		.dst_bytes  = ctxt-&gt;dst.bytes,
		.ad_bytes   = ctxt-&gt;ad_bytes,
		.next_rip   = ctxt-&gt;eip,
	};

	return ctxt-&gt;ops-&gt;intercept(ctxt, &amp;info, stage);
}

static void assign_masked(ulong *dest, ulong src, ulong mask)
{
	*dest = (*dest &amp; ~mask) | (src &amp; mask);
}

static void assign_register(unsigned long *reg, u64 val, int bytes)
{
	/* The 4-byte case *is* correct: in 64-bit mode we zero-extend. */
	switch (bytes) {
	case 1:
<blue>		*(u8 *)reg = (u8)val;</blue>
		break;
	case 2:
<yellow>		*(u16 *)reg = (u16)val;</yellow>
		break;
	case 4:
<yellow>		*reg = (u32)val;</yellow>
		break;	/* 64b: zero-extend */
	case 8:
<blue>		*reg = val;</blue>
		break;
	}
}

static inline unsigned long ad_mask(struct x86_emulate_ctxt *ctxt)
{
<yellow>	return (1UL << (ctxt->ad_bytes << 3)) - 1;</yellow>
}

static ulong stack_mask(struct x86_emulate_ctxt *ctxt)
{
	u16 sel;
	struct desc_struct ss;

<yellow>	if (ctxt->mode == X86EMUL_MODE_PROT64)</yellow>
		return ~0UL;
<yellow>	ctxt->ops->get_segment(ctxt, &sel, &ss, NULL, VCPU_SREG_SS);</yellow>
	return ~0U &gt;&gt; ((ss.d ^ 1) * 16);  /* d=0: 0xffff; d=1: 0xffffffff */
}

static int stack_size(struct x86_emulate_ctxt *ctxt)
{
<yellow>	return (__fls(stack_mask(ctxt)) + 1) >> 3;</yellow>
}

/* Access/update address held in a register, based on addressing mode. */
static inline unsigned long
address_mask(struct x86_emulate_ctxt *ctxt, unsigned long reg)
{
<blue>	if (ctxt->ad_bytes == sizeof(unsigned long))</blue>
		return reg;
	else
<yellow>		return reg & ad_mask(ctxt);</yellow>
}

static inline unsigned long
register_address(struct x86_emulate_ctxt *ctxt, int reg)
{
<blue>	return address_mask(ctxt, reg_read(ctxt, reg));</blue>
}

static void masked_increment(ulong *reg, ulong mask, int inc)
{
	assign_masked(reg, *reg + inc, mask);
}

static inline void
register_address_increment(struct x86_emulate_ctxt *ctxt, int reg, int inc)
{
<blue>	ulong *preg = reg_rmw(ctxt, reg);</blue>

<blue>	assign_register(preg, *preg + inc, ctxt->ad_bytes);</blue>
}

static void rsp_increment(struct x86_emulate_ctxt *ctxt, int inc)
{
<yellow>	masked_increment(reg_rmw(ctxt, VCPU_REGS_RSP), stack_mask(ctxt), inc);</yellow>
}

static u32 desc_limit_scaled(struct desc_struct *desc)
{
<yellow>	u32 limit = get_desc_limit(desc);</yellow>

<yellow>	return desc->g ? (limit << 12) | 0xfff : limit;</yellow>
}

static unsigned long seg_base(struct x86_emulate_ctxt *ctxt, int seg)
{
<blue>	if (ctxt->mode == X86EMUL_MODE_PROT64 && seg < VCPU_SREG_FS)</blue>
		return 0;

<yellow>	return ctxt->ops->get_cached_segment_base(ctxt, seg);</yellow>
}

static int emulate_exception(struct x86_emulate_ctxt *ctxt, int vec,
			     u32 error, bool valid)
{
	if (KVM_EMULATOR_BUG_ON(vec &gt; 0x1f, ctxt))
		return X86EMUL_UNHANDLEABLE;

<yellow>	ctxt->exception.vector = vec;</yellow>
	ctxt-&gt;exception.error_code = error;
	ctxt-&gt;exception.error_code_valid = valid;
	return X86EMUL_PROPAGATE_FAULT;
}

static int emulate_db(struct x86_emulate_ctxt *ctxt)
{
	return emulate_exception(ctxt, DB_VECTOR, 0, false);
}

static int emulate_gp(struct x86_emulate_ctxt *ctxt, int err)
{
<yellow>	return emulate_exception(ctxt, GP_VECTOR, err, true);</yellow>
}

static int emulate_ss(struct x86_emulate_ctxt *ctxt, int err)
{
<yellow>	return emulate_exception(ctxt, SS_VECTOR, err, true);</yellow>
}

static int emulate_ud(struct x86_emulate_ctxt *ctxt)
{
<yellow>	return emulate_exception(ctxt, UD_VECTOR, 0, false);</yellow>
}

static int emulate_ts(struct x86_emulate_ctxt *ctxt, int err)
{
<yellow>	return emulate_exception(ctxt, TS_VECTOR, err, true);</yellow>
}

static int emulate_de(struct x86_emulate_ctxt *ctxt)
{
<yellow>	return emulate_exception(ctxt, DE_VECTOR, 0, false);</yellow>
}

static int emulate_nm(struct x86_emulate_ctxt *ctxt)
{
<yellow>	return emulate_exception(ctxt, NM_VECTOR, 0, false);</yellow>
}

static u16 get_segment_selector(struct x86_emulate_ctxt *ctxt, unsigned seg)
{
	u16 selector;
	struct desc_struct desc;

<yellow>	ctxt->ops->get_segment(ctxt, &selector, &desc, NULL, seg);</yellow>
	return selector;
}

static void set_segment_selector(struct x86_emulate_ctxt *ctxt, u16 selector,
				 unsigned seg)
{
	u16 dummy;
	u32 base3;
	struct desc_struct desc;

<yellow>	ctxt->ops->get_segment(ctxt, &dummy, &desc, &base3, seg);</yellow>
	ctxt-&gt;ops-&gt;set_segment(ctxt, selector, &amp;desc, base3, seg);
}

static inline u8 ctxt_virt_addr_bits(struct x86_emulate_ctxt *ctxt)
{
<blue>	return (ctxt->ops->get_cr(ctxt, 4) & X86_CR4_LA57) ? 57 : 48;</blue>
}

static inline bool emul_is_noncanonical_address(u64 la,
						struct x86_emulate_ctxt *ctxt)
{
<yellow>	return !__is_canonical_address(la, ctxt_virt_addr_bits(ctxt));</yellow>
}

/*
 * x86 defines three classes of vector instructions: explicitly
 * aligned, explicitly unaligned, and the rest, which change behaviour
 * depending on whether they&#x27;re AVX encoded or not.
 *
 * Also included is CMPXCHG16B which is not a vector instruction, yet it is
 * subject to the same check.  FXSAVE and FXRSTOR are checked here too as their
 * 512 bytes of data must be aligned to a 16 byte boundary.
 */
static unsigned insn_alignment(struct x86_emulate_ctxt *ctxt, unsigned size)
{
	u64 alignment = ctxt-&gt;d &amp; AlignMask;

<blue>	if (likely(size < 16))</blue>
		return 1;

	switch (alignment) {
	case Unaligned:
	case Avx:
		return 1;
	case Aligned16:
		return 16;
	case Aligned:
	default:
		return size;
	}
}

static __always_inline int __linearize(struct x86_emulate_ctxt *ctxt,
				       struct segmented_address addr,
				       unsigned *max_size, unsigned size,
				       bool write, bool fetch,
				       enum x86emul_mode mode, ulong *linear)
{
	struct desc_struct desc;
	bool usable;
	ulong la;
	u32 lim;
	u16 sel;
	u8  va_bits;

<blue>	la = seg_base(ctxt, addr.seg) + addr.ea;</blue>
	*max_size = 0;
	switch (mode) {
	case X86EMUL_MODE_PROT64:
<blue>		*linear = la;</blue>
<blue>		va_bits = ctxt_virt_addr_bits(ctxt);</blue>
<blue>		if (!__is_canonical_address(la, va_bits))</blue>
			goto bad;

<blue>		*max_size = min_t(u64, ~0u, (1ull << va_bits) - la);</blue>
		if (size &gt; *max_size)
			goto bad;
		break;
	default:
		*linear = la = (u32)la;
		usable = ctxt-&gt;ops-&gt;get_segment(ctxt, &amp;sel, &amp;desc, NULL,
						addr.seg);
		if (!usable)
			goto bad;
		/* code segment in protected mode or read-only data segment */
<yellow>		if ((((ctxt->mode != X86EMUL_MODE_REAL) && (desc.type & 8))</yellow>
<yellow>					|| !(desc.type & 2)) && write)</yellow>
			goto bad;
		/* unreadable code segment */
<yellow>		if (!fetch && (desc.type & 8) && !(desc.type & 2))</yellow>
			goto bad;
<yellow>		lim = desc_limit_scaled(&desc);</yellow>
<yellow>		if (!(desc.type & 8) && (desc.type & 4)) {</yellow>
			/* expand-down segment */
<yellow>			if (addr.ea <= lim)</yellow>
				goto bad;
<yellow>			lim = desc.d ? 0xffffffff : 0xffff;</yellow>
		}
<yellow>		if (addr.ea > lim)</yellow>
			goto bad;
<yellow>		if (lim == 0xffffffff)</yellow>
			*max_size = ~0u;
		else {
<yellow>			*max_size = (u64)lim + 1 - addr.ea;</yellow>
<yellow>			if (size > *max_size)</yellow>
				goto bad;
		}
		break;
	}
<blue>	if (la & (insn_alignment(ctxt, size) - 1))</blue>
<yellow>		return emulate_gp(ctxt, 0);</yellow>
	return X86EMUL_CONTINUE;
bad:
<yellow>	if (addr.seg == VCPU_SREG_SS)</yellow>
<yellow>		return emulate_ss(ctxt, 0);</yellow>
	else
<yellow>		return emulate_gp(ctxt, 0);</yellow>
}

<blue>static int linearize(struct x86_emulate_ctxt *ctxt,</blue>
		     struct segmented_address addr,
		     unsigned size, bool write,
		     ulong *linear)
{
	unsigned max_size;
<blue>	return __linearize(ctxt, addr, &max_size, size, write, false,</blue>
			   ctxt-&gt;mode, linear);
<yellow>}</yellow>

static inline int assign_eip(struct x86_emulate_ctxt *ctxt, ulong dst)
<yellow>{</yellow>
	ulong linear;
	int rc;
	unsigned max_size;
	struct segmented_address addr = { .seg = VCPU_SREG_CS,
					   .ea = dst };

<yellow>	if (ctxt->op_bytes != sizeof(unsigned long))</yellow>
<yellow>		addr.ea = dst & ((1UL << (ctxt->op_bytes << 3)) - 1);</yellow>
<yellow>	rc = __linearize(ctxt, addr, &max_size, 1, false, true, ctxt->mode, &linear);</yellow>
	if (rc == X86EMUL_CONTINUE)
<yellow>		ctxt->_eip = addr.ea;</yellow>
	return rc;
}

static inline int emulator_recalc_and_set_mode(struct x86_emulate_ctxt *ctxt)
{
	u64 efer;
	struct desc_struct cs;
	u16 selector;
	u32 base3;

<yellow>	ctxt->ops->get_msr(ctxt, MSR_EFER, &efer);</yellow>

	if (!(ctxt-&gt;ops-&gt;get_cr(ctxt, 0) &amp; X86_CR0_PE)) {
		/* Real mode. cpu must not have long mode active */
<yellow>		if (efer & EFER_LMA)</yellow>
<yellow>			return X86EMUL_UNHANDLEABLE;</yellow>
<yellow>		ctxt->mode = X86EMUL_MODE_REAL;</yellow>
		return X86EMUL_CONTINUE;
	}

<yellow>	if (ctxt->eflags & X86_EFLAGS_VM) {</yellow>
		/* Protected/VM86 mode. cpu must not have long mode active */
<yellow>		if (efer & EFER_LMA)</yellow>
			return X86EMUL_UNHANDLEABLE;
<yellow>		ctxt->mode = X86EMUL_MODE_VM86;</yellow>
		return X86EMUL_CONTINUE;
	}

<yellow>	if (!ctxt->ops->get_segment(ctxt, &selector, &cs, &base3, VCPU_SREG_CS))</yellow>
		return X86EMUL_UNHANDLEABLE;

<yellow>	if (efer & EFER_LMA) {</yellow>
<yellow>		if (cs.l) {</yellow>
			/* Proper long mode */
<yellow>			ctxt->mode = X86EMUL_MODE_PROT64;</yellow>
<yellow>		} else if (cs.d) {</yellow>
			/* 32 bit compatibility mode*/
<yellow>			ctxt->mode = X86EMUL_MODE_PROT32;</yellow>
		} else {
<yellow>			ctxt->mode = X86EMUL_MODE_PROT16;</yellow>
		}
	} else {
		/* Legacy 32 bit / 16 bit mode */
<yellow>		ctxt->mode = cs.d ? X86EMUL_MODE_PROT32 : X86EMUL_MODE_PROT16;</yellow>
	}

	return X86EMUL_CONTINUE;
}

static inline int assign_eip_near(struct x86_emulate_ctxt *ctxt, ulong dst)
{
<yellow>	return assign_eip(ctxt, dst);</yellow>
}

static int assign_eip_far(struct x86_emulate_ctxt *ctxt, ulong dst)
{
<yellow>	int rc = emulator_recalc_and_set_mode(ctxt);</yellow>

	if (rc != X86EMUL_CONTINUE)
		return rc;

	return assign_eip(ctxt, dst);
}

static inline int jmp_rel(struct x86_emulate_ctxt *ctxt, int rel)
{
	return assign_eip_near(ctxt, ctxt-&gt;_eip + rel);
}

static int linear_read_system(struct x86_emulate_ctxt *ctxt, ulong linear,
			      void *data, unsigned size)
{
<yellow>	return ctxt->ops->read_std(ctxt, linear, data, size, &ctxt->exception, true);</yellow>
}

static int linear_write_system(struct x86_emulate_ctxt *ctxt,
			       ulong linear, void *data,
			       unsigned int size)
{
<yellow>	return ctxt->ops->write_std(ctxt, linear, data, size, &ctxt->exception, true);</yellow>
}

<yellow>static int segmented_read_std(struct x86_emulate_ctxt *ctxt,</yellow>
			      struct segmented_address addr,
			      void *data,
			      unsigned size)
{
	int rc;
	ulong linear;

<yellow>	rc = linearize(ctxt, addr, size, false, &linear);</yellow>
	if (rc != X86EMUL_CONTINUE)
		return rc;
<yellow>	return ctxt->ops->read_std(ctxt, linear, data, size, &ctxt->exception, false);</yellow>
}

<yellow>static int segmented_write_std(struct x86_emulate_ctxt *ctxt,</yellow>
			       struct segmented_address addr,
			       void *data,
			       unsigned int size)
{
	int rc;
	ulong linear;

<yellow>	rc = linearize(ctxt, addr, size, true, &linear);</yellow>
	if (rc != X86EMUL_CONTINUE)
		return rc;
<yellow>	return ctxt->ops->write_std(ctxt, linear, data, size, &ctxt->exception, false);</yellow>
}

/*
 * Prefetch the remaining bytes of the instruction without crossing page
 * boundary if they are not in fetch_cache yet.
 */
static int __do_insn_fetch_bytes(struct x86_emulate_ctxt *ctxt, int op_size)
<blue>{</blue>
	int rc;
	unsigned size, max_size;
	unsigned long linear;
<blue>	int cur_size = ctxt->fetch.end - ctxt->fetch.data;</blue>
	struct segmented_address addr = { .seg = VCPU_SREG_CS,
					   .ea = ctxt-&gt;eip + cur_size };

	/*
	 * We do not know exactly how many bytes will be needed, and
	 * __linearize is expensive, so fetch as much as possible.  We
	 * just have to avoid going beyond the 15 byte limit, the end
	 * of the segment, or the end of the page.
	 *
	 * __linearize is called with size 0 so that it does not do any
	 * boundary check itself.  Instead, we use max_size to check
	 * against op_size.
	 */
<blue>	rc = __linearize(ctxt, addr, &max_size, 0, false, true, ctxt->mode,</blue>
			 &amp;linear);
	if (unlikely(rc != X86EMUL_CONTINUE))
		return rc;

<blue>	size = min_t(unsigned, 15UL ^ cur_size, max_size);</blue>
	size = min_t(unsigned, size, PAGE_SIZE - offset_in_page(linear));

	/*
	 * One instruction can only straddle two pages,
	 * and one has been loaded at the beginning of
	 * x86_decode_insn.  So, if not enough bytes
	 * still, we must have hit the 15-byte boundary.
	 */
	if (unlikely(size &lt; op_size))
<yellow>		return emulate_gp(ctxt, 0);</yellow>

<blue>	rc = ctxt->ops->fetch(ctxt, linear, ctxt->fetch.end,</blue>
			      size, &amp;ctxt-&gt;exception);
	if (unlikely(rc != X86EMUL_CONTINUE))
		return rc;
<blue>	ctxt->fetch.end += size;</blue>
	return X86EMUL_CONTINUE;
}

static __always_inline int do_insn_fetch_bytes(struct x86_emulate_ctxt *ctxt,
					       unsigned size)
{
<blue>	unsigned done_size = ctxt->fetch.end - ctxt->fetch.ptr;</blue>

	if (unlikely(done_size &lt; size))
<yellow>		return __do_insn_fetch_bytes(ctxt, size - done_size);</yellow>
	else
		return X86EMUL_CONTINUE;
}

/* Fetch next part of the instruction being emulated. */
#define insn_fetch(_type, _ctxt)					\
({	_type _x;							\
									\
	rc = do_insn_fetch_bytes(_ctxt, sizeof(_type));			\
	if (rc != X86EMUL_CONTINUE)					\
		goto done;						\
	ctxt-&gt;_eip += sizeof(_type);					\
	memcpy(&amp;_x, ctxt-&gt;fetch.ptr, sizeof(_type));			\
	ctxt-&gt;fetch.ptr += sizeof(_type);				\
	_x;								\
})

#define insn_fetch_arr(_arr, _size, _ctxt)				\
({									\
	rc = do_insn_fetch_bytes(_ctxt, _size);				\
	if (rc != X86EMUL_CONTINUE)					\
		goto done;						\
	ctxt-&gt;_eip += (_size);						\
	memcpy(_arr, ctxt-&gt;fetch.ptr, _size);				\
	ctxt-&gt;fetch.ptr += (_size);					\
})

/*
 * Given the &#x27;reg&#x27; portion of a ModRM byte, and a register block, return a
 * pointer into the block that addresses the relevant register.
 * @highbyte_regs specifies whether to decode AH,CH,DH,BH.
 */
<blue>static void *decode_register(struct x86_emulate_ctxt *ctxt, u8 modrm_reg,</blue>
			     int byteop)
{
	void *p;
<blue>	int highbyte_regs = (ctxt->rex_prefix == 0) && byteop;</blue>

<blue>	if (highbyte_regs && modrm_reg >= 4 && modrm_reg < 8)</blue>
<blue>		p = (unsigned char *)reg_rmw(ctxt, modrm_reg & 3) + 1;</blue>
	else
<blue>		p = reg_rmw(ctxt, modrm_reg);</blue>
	return p;
<blue>}</blue>

static int read_descriptor(struct x86_emulate_ctxt *ctxt,
			   struct segmented_address addr,
			   u16 *size, unsigned long *address, int op_bytes)
{
	int rc;

	if (op_bytes == 2)
		op_bytes = 3;
	*address = 0;
<yellow>	rc = segmented_read_std(ctxt, addr, size, 2);</yellow>
	if (rc != X86EMUL_CONTINUE)
		return rc;
	addr.ea += 2;
<yellow>	rc = segmented_read_std(ctxt, addr, address, op_bytes);</yellow>
	return rc;
}

FASTOP2(add);
FASTOP2(or);
FASTOP2(adc);
FASTOP2(sbb);
FASTOP2(and);
FASTOP2(sub);
FASTOP2(xor);
FASTOP2(cmp);
FASTOP2(test);

FASTOP1SRC2(mul, mul_ex);
FASTOP1SRC2(imul, imul_ex);
FASTOP1SRC2EX(div, div_ex);
FASTOP1SRC2EX(idiv, idiv_ex);

FASTOP3WCL(shld);
FASTOP3WCL(shrd);

FASTOP2W(imul);

FASTOP1(not);
FASTOP1(neg);
FASTOP1(inc);
FASTOP1(dec);

FASTOP2CL(rol);
FASTOP2CL(ror);
FASTOP2CL(rcl);
FASTOP2CL(rcr);
FASTOP2CL(shl);
FASTOP2CL(shr);
FASTOP2CL(sar);

FASTOP2W(bsf);
FASTOP2W(bsr);
FASTOP2W(bt);
FASTOP2W(bts);
FASTOP2W(btr);
FASTOP2W(btc);

FASTOP2(xadd);

FASTOP2R(cmp, cmp_r);

static int em_bsf_c(struct x86_emulate_ctxt *ctxt)
{
	/* If src is zero, do not writeback, but update flags */
<yellow>	if (ctxt->src.val == 0)</yellow>
<yellow>		ctxt->dst.type = OP_NONE;</yellow>
<yellow>	return fastop(ctxt, em_bsf);</yellow>
}

static int em_bsr_c(struct x86_emulate_ctxt *ctxt)
{
	/* If src is zero, do not writeback, but update flags */
<yellow>	if (ctxt->src.val == 0)</yellow>
<yellow>		ctxt->dst.type = OP_NONE;</yellow>
<yellow>	return fastop(ctxt, em_bsr);</yellow>
}

static __always_inline u8 test_cc(unsigned int condition, unsigned long flags)
{
	u8 rc;
<yellow>	void (*fop)(void) = (void *)em_setcc + FASTOP_SIZE * (condition & 0xf);</yellow>

	flags = (flags &amp; EFLAGS_MASK) | X86_EFLAGS_IF;
	asm(&quot;push %[flags]; popf; &quot; CALL_NOSPEC
	    : &quot;=a&quot;(rc) : [thunk_target]&quot;r&quot;(fop), [flags]&quot;r&quot;(flags));
	return rc;
}

static void fetch_register_operand(struct operand *op)
{
<blue>	switch (op->bytes) {</blue>
	case 1:
<blue>		op->val = *(u8 *)op->addr.reg;</blue>
		break;
	case 2:
<blue>		op->val = *(u16 *)op->addr.reg;</blue>
		break;
	case 4:
<yellow>		op->val = *(u32 *)op->addr.reg;</yellow>
		break;
	case 8:
<yellow>		op->val = *(u64 *)op->addr.reg;</yellow>
		break;
	}
<blue>}</blue>

<yellow>static int em_fninit(struct x86_emulate_ctxt *ctxt)</yellow>
{
<yellow>	if (ctxt->ops->get_cr(ctxt, 0) & (X86_CR0_TS | X86_CR0_EM))</yellow>
<yellow>		return emulate_nm(ctxt);</yellow>

<yellow>	kvm_fpu_get();</yellow>
<yellow>	asm volatile("fninit");</yellow>
<yellow>	kvm_fpu_put();</yellow>
	return X86EMUL_CONTINUE;
<yellow>}</yellow>

<yellow>static int em_fnstcw(struct x86_emulate_ctxt *ctxt)</yellow>
<yellow>{</yellow>
	u16 fcw;

<yellow>	if (ctxt->ops->get_cr(ctxt, 0) & (X86_CR0_TS | X86_CR0_EM))</yellow>
<yellow>		return emulate_nm(ctxt);</yellow>

<yellow>	kvm_fpu_get();</yellow>
<yellow>	asm volatile("fnstcw %0": "+m"(fcw));</yellow>
<yellow>	kvm_fpu_put();</yellow>

	ctxt-&gt;dst.val = fcw;

	return X86EMUL_CONTINUE;
}

<yellow>static int em_fnstsw(struct x86_emulate_ctxt *ctxt)</yellow>
<yellow>{</yellow>
	u16 fsw;

<yellow>	if (ctxt->ops->get_cr(ctxt, 0) & (X86_CR0_TS | X86_CR0_EM))</yellow>
<yellow>		return emulate_nm(ctxt);</yellow>

<yellow>	kvm_fpu_get();</yellow>
<yellow>	asm volatile("fnstsw %0": "+m"(fsw));</yellow>
<yellow>	kvm_fpu_put();</yellow>

	ctxt-&gt;dst.val = fsw;

	return X86EMUL_CONTINUE;
}

static void decode_register_operand(struct x86_emulate_ctxt *ctxt,
				    struct operand *op)
{
	unsigned int reg;

<blue>	if (ctxt->d & ModRM)</blue>
<blue>		reg = ctxt->modrm_reg;</blue>
	else
<yellow>		reg = (ctxt->b & 7) | ((ctxt->rex_prefix & 1) << 3);</yellow>

<blue>	if (ctxt->d & Sse) {</blue>
<yellow>		op->type = OP_XMM;</yellow>
		op-&gt;bytes = 16;
		op-&gt;addr.xmm = reg;
<yellow>		kvm_read_sse_reg(reg, &op->vec_val);</yellow>
		return;
	}
<blue>	if (ctxt->d & Mmx) {</blue>
		reg &amp;= 7;
<yellow>		op->type = OP_MM;</yellow>
		op-&gt;bytes = 8;
		op-&gt;addr.mm = reg;
		return;
	}

<blue>	op->type = OP_REG;</blue>
<blue>	op->bytes = (ctxt->d & ByteOp) ? 1 : ctxt->op_bytes;</blue>
	op-&gt;addr.reg = decode_register(ctxt, reg, ctxt-&gt;d &amp; ByteOp);

	fetch_register_operand(op);
	op-&gt;orig_val = op-&gt;val;
}

static void adjust_modrm_seg(struct x86_emulate_ctxt *ctxt, int base_reg)
{
<blue>	if (base_reg == VCPU_REGS_RSP || base_reg == VCPU_REGS_RBP)</blue>
<yellow>		ctxt->modrm_seg = VCPU_SREG_SS;</yellow>
}

static int decode_modrm(struct x86_emulate_ctxt *ctxt,
			struct operand *op)
{
	u8 sib;
	int index_reg, base_reg, scale;
	int rc = X86EMUL_CONTINUE;
	ulong modrm_ea = 0;

<blue>	ctxt->modrm_reg = ((ctxt->rex_prefix << 1) & 8); /* REX.R */</blue>
	index_reg = (ctxt-&gt;rex_prefix &lt;&lt; 2) &amp; 8; /* REX.X */
	base_reg = (ctxt-&gt;rex_prefix &lt;&lt; 3) &amp; 8; /* REX.B */

	ctxt-&gt;modrm_mod = (ctxt-&gt;modrm &amp; 0xc0) &gt;&gt; 6;
	ctxt-&gt;modrm_reg |= (ctxt-&gt;modrm &amp; 0x38) &gt;&gt; 3;
	ctxt-&gt;modrm_rm = base_reg | (ctxt-&gt;modrm &amp; 0x07);
	ctxt-&gt;modrm_seg = VCPU_SREG_DS;

<blue>	if (ctxt->modrm_mod == 3 || (ctxt->d & NoMod)) {</blue>
<yellow>		op->type = OP_REG;</yellow>
<yellow>		op->bytes = (ctxt->d & ByteOp) ? 1 : ctxt->op_bytes;</yellow>
		op-&gt;addr.reg = decode_register(ctxt, ctxt-&gt;modrm_rm,
				ctxt-&gt;d &amp; ByteOp);
		if (ctxt-&gt;d &amp; Sse) {
<yellow>			op->type = OP_XMM;</yellow>
			op-&gt;bytes = 16;
			op-&gt;addr.xmm = ctxt-&gt;modrm_rm;
<yellow>			kvm_read_sse_reg(ctxt->modrm_rm, &op->vec_val);</yellow>
			return rc;
		}
<yellow>		if (ctxt->d & Mmx) {</yellow>
<yellow>			op->type = OP_MM;</yellow>
			op-&gt;bytes = 8;
			op-&gt;addr.mm = ctxt-&gt;modrm_rm &amp; 7;
			return rc;
		}
<yellow>		fetch_register_operand(op);</yellow>
		return rc;
	}

<blue>	op->type = OP_MEM;</blue>

	if (ctxt-&gt;ad_bytes == 2) {
<yellow>		unsigned bx = reg_read(ctxt, VCPU_REGS_RBX);</yellow>
		unsigned bp = reg_read(ctxt, VCPU_REGS_RBP);
		unsigned si = reg_read(ctxt, VCPU_REGS_RSI);
		unsigned di = reg_read(ctxt, VCPU_REGS_RDI);

		/* 16-bit ModR/M decode. */
		switch (ctxt-&gt;modrm_mod) {
		case 0:
<yellow>			if (ctxt->modrm_rm == 6)</yellow>
<yellow>				modrm_ea += insn_fetch(u16, ctxt);</yellow>
			break;
		case 1:
<yellow>			modrm_ea += insn_fetch(s8, ctxt);</yellow>
			break;
		case 2:
<yellow>			modrm_ea += insn_fetch(u16, ctxt);</yellow>
			break;
		}
<yellow>		switch (ctxt->modrm_rm) {</yellow>
		case 0:
<yellow>			modrm_ea += bx + si;</yellow>
			break;
		case 1:
<yellow>			modrm_ea += bx + di;</yellow>
			break;
		case 2:
<yellow>			modrm_ea += bp + si;</yellow>
			break;
		case 3:
<yellow>			modrm_ea += bp + di;</yellow>
			break;
		case 4:
<yellow>			modrm_ea += si;</yellow>
			break;
		case 5:
<yellow>			modrm_ea += di;</yellow>
			break;
		case 6:
<yellow>			if (ctxt->modrm_mod != 0)</yellow>
<yellow>				modrm_ea += bp;</yellow>
			break;
		case 7:
<yellow>			modrm_ea += bx;</yellow>
			break;
		}
<yellow>		if (ctxt->modrm_rm == 2 || ctxt->modrm_rm == 3 ||</yellow>
<yellow>		    (ctxt->modrm_rm == 6 && ctxt->modrm_mod != 0))</yellow>
<yellow>			ctxt->modrm_seg = VCPU_SREG_SS;</yellow>
<yellow>		modrm_ea = (u16)modrm_ea;</yellow>
	} else {
		/* 32/64-bit ModR/M decode. */
<blue>		if ((ctxt->modrm_rm & 7) == 4) {</blue>
<blue>			sib = insn_fetch(u8, ctxt);</blue>
			index_reg |= (sib &gt;&gt; 3) &amp; 7;
			base_reg |= sib &amp; 7;
			scale = sib &gt;&gt; 6;

<yellow>			if ((base_reg & 7) == 5 && ctxt->modrm_mod == 0)</yellow>
<yellow>				modrm_ea += insn_fetch(s32, ctxt);</yellow>
			else {
				modrm_ea += reg_read(ctxt, base_reg);
<blue>				adjust_modrm_seg(ctxt, base_reg);</blue>
				/* Increment ESP on POP [ESP] */
<blue>				if ((ctxt->d & IncSP) &&</blue>
				    base_reg == VCPU_REGS_RSP)
<yellow>					modrm_ea += ctxt->op_bytes;</yellow>
			}
<blue>			if (index_reg != 4)</blue>
<blue>				modrm_ea += reg_read(ctxt, index_reg) << scale;</blue>
<blue>		} else if ((ctxt->modrm_rm & 7) == 5 && ctxt->modrm_mod == 0) {</blue>
<blue>			modrm_ea += insn_fetch(s32, ctxt);</blue>
			if (ctxt-&gt;mode == X86EMUL_MODE_PROT64)
<blue>				ctxt->rip_relative = 1;</blue>
		} else {
			base_reg = ctxt-&gt;modrm_rm;
<blue>			modrm_ea += reg_read(ctxt, base_reg);</blue>
<yellow>			adjust_modrm_seg(ctxt, base_reg);</yellow>
		}
<blue>		switch (ctxt->modrm_mod) {</blue>
		case 1:
<yellow>			modrm_ea += insn_fetch(s8, ctxt);</yellow>
			break;
		case 2:
<blue>			modrm_ea += insn_fetch(s32, ctxt);</blue>
			break;
		}
	}
<blue>	op->addr.mem.ea = modrm_ea;</blue>
	if (ctxt-&gt;ad_bytes != 8)
<yellow>		ctxt->memop.addr.mem.ea = (u32)ctxt->memop.addr.mem.ea;</yellow>

done:
	return rc;
}

static int decode_abs(struct x86_emulate_ctxt *ctxt,
		      struct operand *op)
{
	int rc = X86EMUL_CONTINUE;

<yellow>	op->type = OP_MEM;</yellow>
	switch (ctxt-&gt;ad_bytes) {
	case 2:
<yellow>		op->addr.mem.ea = insn_fetch(u16, ctxt);</yellow>
		break;
	case 4:
<yellow>		op->addr.mem.ea = insn_fetch(u32, ctxt);</yellow>
		break;
	case 8:
<yellow>		op->addr.mem.ea = insn_fetch(u64, ctxt);</yellow>
		break;
	}
done:
	return rc;
}

static void fetch_bit_operand(struct x86_emulate_ctxt *ctxt)
{
	long sv = 0, mask;

<yellow>	if (ctxt->dst.type == OP_MEM && ctxt->src.type == OP_REG) {</yellow>
		mask = ~((long)ctxt-&gt;dst.bytes * 8 - 1);

		if (ctxt-&gt;src.bytes == 2)
<yellow>			sv = (s16)ctxt->src.val & (s16)mask;</yellow>
<yellow>		else if (ctxt->src.bytes == 4)</yellow>
<yellow>			sv = (s32)ctxt->src.val & (s32)mask;</yellow>
		else
<yellow>			sv = (s64)ctxt->src.val & (s64)mask;</yellow>

<yellow>		ctxt->dst.addr.mem.ea = address_mask(ctxt,</yellow>
<yellow>					   ctxt->dst.addr.mem.ea + (sv >> 3));</yellow>
	}

	/* only subword offset */
<yellow>	ctxt->src.val &= (ctxt->dst.bytes << 3) - 1;</yellow>
}

static int read_emulated(struct x86_emulate_ctxt *ctxt,
			 unsigned long addr, void *dest, unsigned size)
{
	int rc;
	struct read_cache *mc = &amp;ctxt-&gt;mem_read;

<blue>	if (mc->pos < mc->end)</blue>
		goto read_cached;

<blue>	if (KVM_EMULATOR_BUG_ON((mc->end + size) >= sizeof(mc->data), ctxt))</blue>
		return X86EMUL_UNHANDLEABLE;

<blue>	rc = ctxt->ops->read_emulated(ctxt, addr, mc->data + mc->end, size,</blue>
				      &amp;ctxt-&gt;exception);
	if (rc != X86EMUL_CONTINUE)
		return rc;

<blue>	mc->end += size;</blue>

read_cached:
<blue>	memcpy(dest, mc->data + mc->pos, size);</blue>
	mc-&gt;pos += size;
	return X86EMUL_CONTINUE;
<blue>}</blue>

static int segmented_read(struct x86_emulate_ctxt *ctxt,
			  struct segmented_address addr,
			  void *data,
			  unsigned size)
{
	int rc;
	ulong linear;

<yellow>	rc = linearize(ctxt, addr, size, false, &linear);</yellow>
	if (rc != X86EMUL_CONTINUE)
		return rc;
<blue>	return read_emulated(ctxt, linear, data, size);</blue>
}

<blue>static int segmented_write(struct x86_emulate_ctxt *ctxt,</blue>
			   struct segmented_address addr,
			   const void *data,
			   unsigned size)
{
	int rc;
	ulong linear;

<blue>	rc = linearize(ctxt, addr, size, true, &linear);</blue>
	if (rc != X86EMUL_CONTINUE)
		return rc;
<blue>	return ctxt->ops->write_emulated(ctxt, linear, data, size,</blue>
					 &amp;ctxt-&gt;exception);
}

static int segmented_cmpxchg(struct x86_emulate_ctxt *ctxt,
			     struct segmented_address addr,
			     const void *orig_data, const void *data,
			     unsigned size)
{
	int rc;
	ulong linear;

<yellow>	rc = linearize(ctxt, addr, size, true, &linear);</yellow>
	if (rc != X86EMUL_CONTINUE)
		return rc;
<yellow>	return ctxt->ops->cmpxchg_emulated(ctxt, linear, orig_data, data,</yellow>
					   size, &amp;ctxt-&gt;exception);
}

static int pio_in_emulated(struct x86_emulate_ctxt *ctxt,
			   unsigned int size, unsigned short port,
			   void *dest)
{
	struct read_cache *rc = &amp;ctxt-&gt;io_read;

	if (rc-&gt;pos == rc-&gt;end) { /* refill pio read ahead */
		unsigned int in_page, n;
<blue>		unsigned int count = ctxt->rep_prefix ?</blue>
<blue>			address_mask(ctxt, reg_read(ctxt, VCPU_REGS_RCX)) : 1;</blue>
<blue>		in_page = (ctxt->eflags & X86_EFLAGS_DF) ?</blue>
<yellow>			offset_in_page(reg_read(ctxt, VCPU_REGS_RDI)) :</yellow>
<blue>			PAGE_SIZE - offset_in_page(reg_read(ctxt, VCPU_REGS_RDI));</blue>
<blue>		n = min3(in_page, (unsigned int)sizeof(rc->data) / size, count);</blue>
		if (n == 0)
			n = 1;
		rc-&gt;pos = rc-&gt;end = 0;
		if (!ctxt-&gt;ops-&gt;pio_in_emulated(ctxt, size, port, rc-&gt;data, n))
			return 0;
<blue>		rc->end = n * size;</blue>
	}

<blue>	if (ctxt->rep_prefix && (ctxt->d & String) &&</blue>
<blue>	    !(ctxt->eflags & X86_EFLAGS_DF)) {</blue>
<blue>		ctxt->dst.data = rc->data + rc->pos;</blue>
		ctxt-&gt;dst.type = OP_MEM_STR;
		ctxt-&gt;dst.count = (rc-&gt;end - rc-&gt;pos) / size;
		rc-&gt;pos = rc-&gt;end;
	} else {
<yellow>		memcpy(dest, rc->data + rc->pos, size);</yellow>
		rc-&gt;pos += size;
	}
	return 1;
}

static int read_interrupt_descriptor(struct x86_emulate_ctxt *ctxt,
				     u16 index, struct desc_struct *desc)
{
	struct desc_ptr dt;
	ulong addr;

<yellow>	ctxt->ops->get_idt(ctxt, &dt);</yellow>

	if (dt.size &lt; index * 8 + 7)
<yellow>		return emulate_gp(ctxt, index << 3 | 0x2);</yellow>

	addr = dt.address + index * 8;
<yellow>	return linear_read_system(ctxt, addr, desc, sizeof(*desc));</yellow>
}

static void get_descriptor_table_ptr(struct x86_emulate_ctxt *ctxt,
				     u16 selector, struct desc_ptr *dt)
{
	const struct x86_emulate_ops *ops = ctxt-&gt;ops;
	u32 base3 = 0;

	if (selector &amp; 1 &lt;&lt; 2) {
		struct desc_struct desc;
		u16 sel;

<yellow>		memset(dt, 0, sizeof(*dt));</yellow>
		if (!ops-&gt;get_segment(ctxt, &amp;sel, &amp;desc, &amp;base3,
				      VCPU_SREG_LDTR))
			return;

<yellow>		dt->size = desc_limit_scaled(&desc); /* what if limit > 65535? */</yellow>
<yellow>		dt->address = get_desc_base(&desc) | ((u64)base3 << 32);</yellow>
	} else
<yellow>		ops->get_gdt(ctxt, dt);</yellow>
}

static int get_descriptor_ptr(struct x86_emulate_ctxt *ctxt,
			      u16 selector, ulong *desc_addr_p)
<yellow>{</yellow>
	struct desc_ptr dt;
<yellow>	u16 index = selector >> 3;</yellow>
	ulong addr;

<yellow>	get_descriptor_table_ptr(ctxt, selector, &dt);</yellow>

<yellow>	if (dt.size < index * 8 + 7)</yellow>
<yellow>		return emulate_gp(ctxt, selector & 0xfffc);</yellow>

<yellow>	addr = dt.address + index * 8;</yellow>

#ifdef CONFIG_X86_64
	if (addr &gt;&gt; 32 != 0) {
		u64 efer = 0;

<yellow>		ctxt->ops->get_msr(ctxt, MSR_EFER, &efer);</yellow>
		if (!(efer &amp; EFER_LMA))
<yellow>			addr &= (u32)-1;</yellow>
	}
#endif

<yellow>	*desc_addr_p = addr;</yellow>
	return X86EMUL_CONTINUE;
}

/* allowed just for 8 bytes segments */
<yellow>static int read_segment_descriptor(struct x86_emulate_ctxt *ctxt,</yellow>
				   u16 selector, struct desc_struct *desc,
				   ulong *desc_addr_p)
{
	int rc;

<yellow>	rc = get_descriptor_ptr(ctxt, selector, desc_addr_p);</yellow>
<yellow>	if (rc != X86EMUL_CONTINUE)</yellow>
		return rc;

<yellow>	return linear_read_system(ctxt, *desc_addr_p, desc, sizeof(*desc));</yellow>
}

/* allowed just for 8 bytes segments */
static int write_segment_descriptor(struct x86_emulate_ctxt *ctxt,
				    u16 selector, struct desc_struct *desc)
<yellow>{</yellow>
	int rc;
	ulong addr;

<yellow>	rc = get_descriptor_ptr(ctxt, selector, &addr);</yellow>
	if (rc != X86EMUL_CONTINUE)
		return rc;

<yellow>	return linear_write_system(ctxt, addr, desc, sizeof(*desc));</yellow>
}

static int __load_segment_descriptor(struct x86_emulate_ctxt *ctxt,
				     u16 selector, int seg, u8 cpl,
				     enum x86_transfer_type transfer,
				     struct desc_struct *desc)
<yellow>{</yellow>
	struct desc_struct seg_desc, old_desc;
	u8 dpl, rpl;
	unsigned err_vec = GP_VECTOR;
	u32 err_code = 0;
<yellow>	bool null_selector = !(selector & ~0x3); /* 0000-0003 are null */</yellow>
	ulong desc_addr;
	int ret;
	u16 dummy;
	u32 base3 = 0;

<yellow>	memset(&seg_desc, 0, sizeof(seg_desc));</yellow>

	if (ctxt-&gt;mode == X86EMUL_MODE_REAL) {
		/* set real mode segment descriptor (keep limit etc. for
		 * unreal mode) */
<yellow>		ctxt->ops->get_segment(ctxt, &dummy, &seg_desc, NULL, seg);</yellow>
		set_desc_base(&amp;seg_desc, selector &lt;&lt; 4);
		goto load;
<yellow>	} else if (seg <= VCPU_SREG_GS && ctxt->mode == X86EMUL_MODE_VM86) {</yellow>
		/* VM86 needs a clean new segment descriptor */
<yellow>		set_desc_base(&seg_desc, selector << 4);</yellow>
		set_desc_limit(&amp;seg_desc, 0xffff);
		seg_desc.type = 3;
		seg_desc.p = 1;
		seg_desc.s = 1;
		seg_desc.dpl = 3;
		goto load;
	}

<yellow>	rpl = selector & 3;</yellow>

	/* TR should be in GDT only */
<yellow>	if (seg == VCPU_SREG_TR && (selector & (1 << 2)))</yellow>
		goto exception;

	/* NULL selector is not valid for TR, CS and (except for long mode) SS */
<yellow>	if (null_selector) {</yellow>
<yellow>		if (seg == VCPU_SREG_CS || seg == VCPU_SREG_TR)</yellow>
			goto exception;

<yellow>		if (seg == VCPU_SREG_SS) {</yellow>
<yellow>			if (ctxt->mode != X86EMUL_MODE_PROT64 || rpl != cpl)</yellow>
				goto exception;

			/*
			 * ctxt-&gt;ops-&gt;set_segment expects the CPL to be in
			 * SS.DPL, so fake an expand-up 32-bit data segment.
			 */
<yellow>			seg_desc.type = 3;</yellow>
			seg_desc.p = 1;
			seg_desc.s = 1;
			seg_desc.dpl = cpl;
			seg_desc.d = 1;
			seg_desc.g = 1;
		}

		/* Skip all following checks */
		goto load;
	}

<yellow>	ret = read_segment_descriptor(ctxt, selector, &seg_desc, &desc_addr);</yellow>
	if (ret != X86EMUL_CONTINUE)
		return ret;

	err_code = selector &amp; 0xfffc;
<yellow>	err_vec = (transfer == X86_TRANSFER_TASK_SWITCH) ? TS_VECTOR :</yellow>
							   GP_VECTOR;

	/* can&#x27;t load system descriptor into segment selector */
<yellow>	if (seg <= VCPU_SREG_GS && !seg_desc.s) {</yellow>
<yellow>		if (transfer == X86_TRANSFER_CALL_JMP)</yellow>
			return X86EMUL_UNHANDLEABLE;
		goto exception;
	}

<yellow>	dpl = seg_desc.dpl;</yellow>

	switch (seg) {
	case VCPU_SREG_SS:
		/*
		 * segment is not a writable data segment or segment
		 * selector&#x27;s RPL != CPL or segment selector&#x27;s RPL != CPL
		 */
<yellow>		if (rpl != cpl || (seg_desc.type & 0xa) != 0x2 || dpl != cpl)</yellow>
			goto exception;
		break;
	case VCPU_SREG_CS:
<yellow>		if (!(seg_desc.type & 8))</yellow>
			goto exception;

<yellow>		if (transfer == X86_TRANSFER_RET) {</yellow>
			/* RET can never return to an inner privilege level. */
<yellow>			if (rpl < cpl)</yellow>
				goto exception;
			/* Outer-privilege level return is not implemented */
<yellow>			if (rpl > cpl)</yellow>
				return X86EMUL_UNHANDLEABLE;
		}
<yellow>		if (transfer == X86_TRANSFER_RET || transfer == X86_TRANSFER_TASK_SWITCH) {</yellow>
<yellow>			if (seg_desc.type & 4) {</yellow>
				/* conforming */
<yellow>				if (dpl > rpl)</yellow>
					goto exception;
			} else {
				/* nonconforming */
<yellow>				if (dpl != rpl)</yellow>
					goto exception;
			}
		} else { /* X86_TRANSFER_CALL_JMP */
<yellow>			if (seg_desc.type & 4) {</yellow>
				/* conforming */
<yellow>				if (dpl > cpl)</yellow>
					goto exception;
			} else {
				/* nonconforming */
<yellow>				if (rpl > cpl || dpl != cpl)</yellow>
					goto exception;
			}
		}
		/* in long-mode d/b must be clear if l is set */
<yellow>		if (seg_desc.d && seg_desc.l) {</yellow>
			u64 efer = 0;

<yellow>			ctxt->ops->get_msr(ctxt, MSR_EFER, &efer);</yellow>
<yellow>			if (efer & EFER_LMA)</yellow>
				goto exception;
		}

		/* CS(RPL) &lt;- CPL */
<yellow>		selector = (selector & 0xfffc) | cpl;</yellow>
		break;
	case VCPU_SREG_TR:
<yellow>		if (seg_desc.s || (seg_desc.type != 1 && seg_desc.type != 9))</yellow>
			goto exception;
		break;
	case VCPU_SREG_LDTR:
<yellow>		if (seg_desc.s || seg_desc.type != 2)</yellow>
			goto exception;
		break;
	default: /*  DS, ES, FS, or GS */
		/*
		 * segment is not a data or readable code segment or
		 * ((segment is a data or nonconforming code segment)
		 * and (both RPL and CPL &gt; DPL))
		 */
<yellow>		if ((seg_desc.type & 0xa) == 0x8 ||</yellow>
<yellow>		    (((seg_desc.type & 0xc) != 0xc) &&</yellow>
<yellow>		     (rpl > dpl && cpl > dpl)))</yellow>
			goto exception;
		break;
	}

<yellow>	if (!seg_desc.p) {</yellow>
<yellow>		err_vec = (seg == VCPU_SREG_SS) ? SS_VECTOR : NP_VECTOR;</yellow>
		goto exception;
	}

<yellow>	if (seg_desc.s) {</yellow>
		/* mark segment as accessed */
<yellow>		if (!(seg_desc.type & 1)) {</yellow>
<yellow>			seg_desc.type |= 1;</yellow>
<yellow>			ret = write_segment_descriptor(ctxt, selector,</yellow>
						       &amp;seg_desc);
			if (ret != X86EMUL_CONTINUE)
				return ret;
		}
<yellow>	} else if (ctxt->mode == X86EMUL_MODE_PROT64) {</yellow>
<yellow>		ret = linear_read_system(ctxt, desc_addr+8, &base3, sizeof(base3));</yellow>
		if (ret != X86EMUL_CONTINUE)
			return ret;
<yellow>		if (emul_is_noncanonical_address(get_desc_base(&seg_desc) |</yellow>
						 ((u64)base3 &lt;&lt; 32), ctxt))
<yellow>			return emulate_gp(ctxt, err_code);</yellow>
	}

	if (seg == VCPU_SREG_TR) {
<yellow>		old_desc = seg_desc;</yellow>
		seg_desc.type |= 2; /* busy */
<yellow>		ret = ctxt->ops->cmpxchg_emulated(ctxt, desc_addr, &old_desc, &seg_desc,</yellow>
						  sizeof(seg_desc), &amp;ctxt-&gt;exception);
		if (ret != X86EMUL_CONTINUE)
			return ret;
	}
load:
<yellow>	ctxt->ops->set_segment(ctxt, selector, &seg_desc, base3, seg);</yellow>
	if (desc)
<yellow>		*desc = seg_desc;</yellow>
	return X86EMUL_CONTINUE;
exception:
<yellow>	return emulate_exception(ctxt, err_vec, err_code, true);</yellow>
}

static int load_segment_descriptor(struct x86_emulate_ctxt *ctxt,
				   u16 selector, int seg)
{
<yellow>	u8 cpl = ctxt->ops->cpl(ctxt);</yellow>

	/*
	 * None of MOV, POP and LSS can load a NULL selector in CPL=3, but
	 * they can load it at CPL&lt;3 (Intel&#x27;s manual says only LSS can,
	 * but it&#x27;s wrong).
	 *
	 * However, the Intel manual says that putting IST=1/DPL=3 in
	 * an interrupt gate will result in SS=3 (the AMD manual instead
	 * says it doesn&#x27;t), so allow SS=3 in __load_segment_descriptor
	 * and only forbid it here.
	 */
<yellow>	if (seg == VCPU_SREG_SS && selector == 3 &&</yellow>
<yellow>	    ctxt->mode == X86EMUL_MODE_PROT64)</yellow>
<yellow>		return emulate_exception(ctxt, GP_VECTOR, 0, true);</yellow>

<yellow>	return __load_segment_descriptor(ctxt, selector, seg, cpl,</yellow>
					 X86_TRANSFER_NONE, NULL);
<yellow>}</yellow>

static void write_register_operand(struct operand *op)
{
<blue>	return assign_register(op->addr.reg, op->val, op->bytes);</blue>
}

static int writeback(struct x86_emulate_ctxt *ctxt, struct operand *op)
<blue>{</blue>
<blue>	switch (op->type) {</blue>
	case OP_REG:
<blue>		write_register_operand(op);</blue>
		break;
	case OP_MEM:
<blue>		if (ctxt->lock_prefix)</blue>
<yellow>			return segmented_cmpxchg(ctxt,</yellow>
						 op-&gt;addr.mem,
						 &amp;op-&gt;orig_val,
						 &amp;op-&gt;val,
						 op-&gt;bytes);
		else
<blue>			return segmented_write(ctxt,</blue>
					       op-&gt;addr.mem,
					       &amp;op-&gt;val,
					       op-&gt;bytes);
		break;
	case OP_MEM_STR:
		return segmented_write(ctxt,
				       op-&gt;addr.mem,
				       op-&gt;data,
<blue>				       op->bytes * op->count);</blue>
		break;
	case OP_XMM:
<yellow>		kvm_write_sse_reg(op->addr.xmm, &op->vec_val);</yellow>
		break;
	case OP_MM:
<yellow>		kvm_write_mmx_reg(op->addr.mm, &op->mm_val);</yellow>
		break;
	case OP_NONE:
		/* no writeback */
		break;
	default:
		break;
	}
	return X86EMUL_CONTINUE;
}

static int push(struct x86_emulate_ctxt *ctxt, void *data, int bytes)
{
	struct segmented_address addr;

<yellow>	rsp_increment(ctxt, -bytes);</yellow>
<yellow>	addr.ea = reg_read(ctxt, VCPU_REGS_RSP) & stack_mask(ctxt);</yellow>
	addr.seg = VCPU_SREG_SS;

<yellow>	return segmented_write(ctxt, addr, data, bytes);</yellow>
}

static int em_push(struct x86_emulate_ctxt *ctxt)
{
	/* Disable writeback. */
<yellow>	ctxt->dst.type = OP_NONE;</yellow>
	return push(ctxt, &amp;ctxt-&gt;src.val, ctxt-&gt;op_bytes);
}

static int emulate_pop(struct x86_emulate_ctxt *ctxt,
		       void *dest, int len)
<yellow>{</yellow>
	int rc;
	struct segmented_address addr;

<yellow>	addr.ea = reg_read(ctxt, VCPU_REGS_RSP) & stack_mask(ctxt);</yellow>
	addr.seg = VCPU_SREG_SS;
<yellow>	rc = segmented_read(ctxt, addr, dest, len);</yellow>
<yellow>	if (rc != X86EMUL_CONTINUE)</yellow>
		return rc;

<yellow>	rsp_increment(ctxt, len);</yellow>
	return rc;
}

static int em_pop(struct x86_emulate_ctxt *ctxt)
{
<yellow>	return emulate_pop(ctxt, &ctxt->dst.val, ctxt->op_bytes);</yellow>
}

static int emulate_popf(struct x86_emulate_ctxt *ctxt,
			void *dest, int len)
{
	int rc;
	unsigned long val, change_mask;
<yellow>	int iopl = (ctxt->eflags & X86_EFLAGS_IOPL) >> X86_EFLAGS_IOPL_BIT;</yellow>
	int cpl = ctxt-&gt;ops-&gt;cpl(ctxt);

	rc = emulate_pop(ctxt, &amp;val, len);
	if (rc != X86EMUL_CONTINUE)
		return rc;

	change_mask = X86_EFLAGS_CF | X86_EFLAGS_PF | X86_EFLAGS_AF |
		      X86_EFLAGS_ZF | X86_EFLAGS_SF | X86_EFLAGS_OF |
		      X86_EFLAGS_TF | X86_EFLAGS_DF | X86_EFLAGS_NT |
		      X86_EFLAGS_AC | X86_EFLAGS_ID;

	switch(ctxt-&gt;mode) {
	case X86EMUL_MODE_PROT64:
	case X86EMUL_MODE_PROT32:
	case X86EMUL_MODE_PROT16:
<yellow>		if (cpl == 0)</yellow>
			change_mask |= X86_EFLAGS_IOPL;
<yellow>		if (cpl <= iopl)</yellow>
			change_mask |= X86_EFLAGS_IF;
		break;
	case X86EMUL_MODE_VM86:
<yellow>		if (iopl < 3)</yellow>
<yellow>			return emulate_gp(ctxt, 0);</yellow>
		change_mask |= X86_EFLAGS_IF;
		break;
	default: /* real mode */
		change_mask |= (X86_EFLAGS_IOPL | X86_EFLAGS_IF);
		break;
	}

	*(unsigned long *)dest =
<yellow>		(ctxt->eflags & ~change_mask) | (val & change_mask);</yellow>

	return rc;
}

static int em_popf(struct x86_emulate_ctxt *ctxt)
<yellow>{</yellow>
<yellow>	ctxt->dst.type = OP_REG;</yellow>
	ctxt-&gt;dst.addr.reg = &amp;ctxt-&gt;eflags;
	ctxt-&gt;dst.bytes = ctxt-&gt;op_bytes;
<yellow>	return emulate_popf(ctxt, &ctxt->dst.val, ctxt->op_bytes);</yellow>
}

static int em_enter(struct x86_emulate_ctxt *ctxt)
<yellow>{</yellow>
	int rc;
<yellow>	unsigned frame_size = ctxt->src.val;</yellow>
<yellow>	unsigned nesting_level = ctxt->src2.val & 31;</yellow>
	ulong rbp;

	if (nesting_level)
		return X86EMUL_UNHANDLEABLE;

	rbp = reg_read(ctxt, VCPU_REGS_RBP);
<yellow>	rc = push(ctxt, &rbp, stack_size(ctxt));</yellow>
	if (rc != X86EMUL_CONTINUE)
		return rc;
<yellow>	assign_masked(reg_rmw(ctxt, VCPU_REGS_RBP), reg_read(ctxt, VCPU_REGS_RSP),</yellow>
		      stack_mask(ctxt));
<yellow>	assign_masked(reg_rmw(ctxt, VCPU_REGS_RSP),</yellow>
<yellow>		      reg_read(ctxt, VCPU_REGS_RSP) - frame_size,</yellow>
		      stack_mask(ctxt));
	return X86EMUL_CONTINUE;
}

static int em_leave(struct x86_emulate_ctxt *ctxt)
{
<yellow>	assign_masked(reg_rmw(ctxt, VCPU_REGS_RSP), reg_read(ctxt, VCPU_REGS_RBP),</yellow>
		      stack_mask(ctxt));
	return emulate_pop(ctxt, reg_rmw(ctxt, VCPU_REGS_RBP), ctxt-&gt;op_bytes);
}

static int em_push_sreg(struct x86_emulate_ctxt *ctxt)
{
<yellow>	int seg = ctxt->src2.val;</yellow>

	ctxt-&gt;src.val = get_segment_selector(ctxt, seg);
	if (ctxt-&gt;op_bytes == 4) {
<yellow>		rsp_increment(ctxt, -2);</yellow>
		ctxt-&gt;op_bytes = 2;
	}

<yellow>	return em_push(ctxt);</yellow>
}

static int em_pop_sreg(struct x86_emulate_ctxt *ctxt)
<yellow>{</yellow>
<yellow>	int seg = ctxt->src2.val;</yellow>
	unsigned long selector;
	int rc;

	rc = emulate_pop(ctxt, &amp;selector, 2);
	if (rc != X86EMUL_CONTINUE)
		return rc;

<yellow>	if (seg == VCPU_SREG_SS)</yellow>
<yellow>		ctxt->interruptibility = KVM_X86_SHADOW_INT_MOV_SS;</yellow>
<yellow>	if (ctxt->op_bytes > 2)</yellow>
<yellow>		rsp_increment(ctxt, ctxt->op_bytes - 2);</yellow>

<yellow>	rc = load_segment_descriptor(ctxt, (u16)selector, seg);</yellow>
	return rc;
}

static int em_pusha(struct x86_emulate_ctxt *ctxt)
{
<yellow>	unsigned long old_esp = reg_read(ctxt, VCPU_REGS_RSP);</yellow>
	int rc = X86EMUL_CONTINUE;
	int reg = VCPU_REGS_RAX;

<yellow>	while (reg <= VCPU_REGS_RDI) {</yellow>
		(reg == VCPU_REGS_RSP) ?
<yellow>		(ctxt->src.val = old_esp) : (ctxt->src.val = reg_read(ctxt, reg));</yellow>

		rc = em_push(ctxt);
		if (rc != X86EMUL_CONTINUE)
			return rc;

		++reg;
	}

	return rc;
<yellow>}</yellow>

static int em_pushf(struct x86_emulate_ctxt *ctxt)
{
<yellow>	ctxt->src.val = (unsigned long)ctxt->eflags & ~X86_EFLAGS_VM;</yellow>
	return em_push(ctxt);
}

static int em_popa(struct x86_emulate_ctxt *ctxt)
<yellow>{</yellow>
	int rc = X86EMUL_CONTINUE;
	int reg = VCPU_REGS_RDI;
	u32 val;

	while (reg &gt;= VCPU_REGS_RAX) {
<yellow>		if (reg == VCPU_REGS_RSP) {</yellow>
<yellow>			rsp_increment(ctxt, ctxt->op_bytes);</yellow>
			--reg;
		}

<yellow>		rc = emulate_pop(ctxt, &val, ctxt->op_bytes);</yellow>
		if (rc != X86EMUL_CONTINUE)
			break;
<yellow>		assign_register(reg_rmw(ctxt, reg), val, ctxt->op_bytes);</yellow>
<yellow>		--reg;</yellow>
	}
	return rc;
}

static int __emulate_int_real(struct x86_emulate_ctxt *ctxt, int irq)
<yellow>{</yellow>
<yellow>	const struct x86_emulate_ops *ops = ctxt->ops;</yellow>
	int rc;
	struct desc_ptr dt;
	gva_t cs_addr;
	gva_t eip_addr;
	u16 cs, eip;

	/* TODO: Add limit checks */
	ctxt-&gt;src.val = ctxt-&gt;eflags;
	rc = em_push(ctxt);
	if (rc != X86EMUL_CONTINUE)
		return rc;

<yellow>	ctxt->eflags &= ~(X86_EFLAGS_IF | X86_EFLAGS_TF | X86_EFLAGS_AC);</yellow>

	ctxt-&gt;src.val = get_segment_selector(ctxt, VCPU_SREG_CS);
	rc = em_push(ctxt);
	if (rc != X86EMUL_CONTINUE)
		return rc;

<yellow>	ctxt->src.val = ctxt->_eip;</yellow>
	rc = em_push(ctxt);
	if (rc != X86EMUL_CONTINUE)
		return rc;

<yellow>	ops->get_idt(ctxt, &dt);</yellow>

	eip_addr = dt.address + (irq &lt;&lt; 2);
	cs_addr = dt.address + (irq &lt;&lt; 2) + 2;

	rc = linear_read_system(ctxt, cs_addr, &amp;cs, 2);
	if (rc != X86EMUL_CONTINUE)
		return rc;

<yellow>	rc = linear_read_system(ctxt, eip_addr, &eip, 2);</yellow>
	if (rc != X86EMUL_CONTINUE)
		return rc;

<yellow>	rc = load_segment_descriptor(ctxt, cs, VCPU_SREG_CS);</yellow>
	if (rc != X86EMUL_CONTINUE)
		return rc;

<yellow>	ctxt->_eip = eip;</yellow>

	return rc;
}

int emulate_int_real(struct x86_emulate_ctxt *ctxt, int irq)
{
	int rc;

<yellow>	invalidate_registers(ctxt);</yellow>
	rc = __emulate_int_real(ctxt, irq);
	if (rc == X86EMUL_CONTINUE)
<yellow>		writeback_registers(ctxt);</yellow>
	return rc;
<yellow>}</yellow>

static int emulate_int(struct x86_emulate_ctxt *ctxt, int irq)
{
<yellow>	switch(ctxt->mode) {</yellow>
	case X86EMUL_MODE_REAL:
<yellow>		return __emulate_int_real(ctxt, irq);</yellow>
	case X86EMUL_MODE_VM86:
	case X86EMUL_MODE_PROT16:
	case X86EMUL_MODE_PROT32:
	case X86EMUL_MODE_PROT64:
	default:
		/* Protected mode interrupts unimplemented yet */
		return X86EMUL_UNHANDLEABLE;
	}
}

static int emulate_iret_real(struct x86_emulate_ctxt *ctxt)
{
	int rc = X86EMUL_CONTINUE;
	unsigned long temp_eip = 0;
	unsigned long temp_eflags = 0;
	unsigned long cs = 0;
	unsigned long mask = X86_EFLAGS_CF | X86_EFLAGS_PF | X86_EFLAGS_AF |
			     X86_EFLAGS_ZF | X86_EFLAGS_SF | X86_EFLAGS_TF |
			     X86_EFLAGS_IF | X86_EFLAGS_DF | X86_EFLAGS_OF |
			     X86_EFLAGS_IOPL | X86_EFLAGS_NT | X86_EFLAGS_RF |
			     X86_EFLAGS_AC | X86_EFLAGS_ID |
			     X86_EFLAGS_FIXED;
	unsigned long vm86_mask = X86_EFLAGS_VM | X86_EFLAGS_VIF |
				  X86_EFLAGS_VIP;

	/* TODO: Add stack limit check */

<yellow>	rc = emulate_pop(ctxt, &temp_eip, ctxt->op_bytes);</yellow>

	if (rc != X86EMUL_CONTINUE)
		return rc;

<yellow>	if (temp_eip & ~0xffff)</yellow>
<yellow>		return emulate_gp(ctxt, 0);</yellow>

<yellow>	rc = emulate_pop(ctxt, &cs, ctxt->op_bytes);</yellow>

	if (rc != X86EMUL_CONTINUE)
		return rc;

<yellow>	rc = emulate_pop(ctxt, &temp_eflags, ctxt->op_bytes);</yellow>

	if (rc != X86EMUL_CONTINUE)
		return rc;

<yellow>	rc = load_segment_descriptor(ctxt, (u16)cs, VCPU_SREG_CS);</yellow>

	if (rc != X86EMUL_CONTINUE)
		return rc;

<yellow>	ctxt->_eip = temp_eip;</yellow>

	if (ctxt-&gt;op_bytes == 4)
<yellow>		ctxt->eflags = ((temp_eflags & mask) | (ctxt->eflags & vm86_mask));</yellow>
<yellow>	else if (ctxt->op_bytes == 2) {</yellow>
<yellow>		ctxt->eflags &= ~0xffff;</yellow>
		ctxt-&gt;eflags |= temp_eflags;
	}

<yellow>	ctxt->eflags &= ~EFLG_RESERVED_ZEROS_MASK; /* Clear reserved zeros */</yellow>
	ctxt-&gt;eflags |= X86_EFLAGS_FIXED;
	ctxt-&gt;ops-&gt;set_nmi_mask(ctxt, false);

	return rc;
}

static int em_iret(struct x86_emulate_ctxt *ctxt)
<yellow>{</yellow>
<yellow>	switch(ctxt->mode) {</yellow>
	case X86EMUL_MODE_REAL:
<yellow>		return emulate_iret_real(ctxt);</yellow>
	case X86EMUL_MODE_VM86:
	case X86EMUL_MODE_PROT16:
	case X86EMUL_MODE_PROT32:
	case X86EMUL_MODE_PROT64:
	default:
		/* iret from protected mode unimplemented yet */
		return X86EMUL_UNHANDLEABLE;
	}
}

static int em_jmp_far(struct x86_emulate_ctxt *ctxt)
<yellow>{</yellow>
	int rc;
	unsigned short sel;
	struct desc_struct new_desc;
<yellow>	u8 cpl = ctxt->ops->cpl(ctxt);</yellow>

	memcpy(&amp;sel, ctxt-&gt;src.valptr + ctxt-&gt;op_bytes, 2);

	rc = __load_segment_descriptor(ctxt, sel, VCPU_SREG_CS, cpl,
				       X86_TRANSFER_CALL_JMP,
				       &amp;new_desc);
	if (rc != X86EMUL_CONTINUE)
		return rc;

<yellow>	rc = assign_eip_far(ctxt, ctxt->src.val);</yellow>
	/* Error handling is not implemented. */
	if (rc != X86EMUL_CONTINUE)
<yellow>		return X86EMUL_UNHANDLEABLE;</yellow>

	return rc;
}

static int em_jmp_abs(struct x86_emulate_ctxt *ctxt)
{
<yellow>	return assign_eip_near(ctxt, ctxt->src.val);</yellow>
}

static int em_call_near_abs(struct x86_emulate_ctxt *ctxt)
{
	int rc;
	long int old_eip;

<yellow>	old_eip = ctxt->_eip;</yellow>
	rc = assign_eip_near(ctxt, ctxt-&gt;src.val);
	if (rc != X86EMUL_CONTINUE)
		return rc;
<yellow>	ctxt->src.val = old_eip;</yellow>
	rc = em_push(ctxt);
	return rc;
<yellow>}</yellow>

static int em_cmpxchg8b(struct x86_emulate_ctxt *ctxt)
{
<yellow>	u64 old = ctxt->dst.orig_val64;</yellow>

<yellow>	if (ctxt->dst.bytes == 16)</yellow>
		return X86EMUL_UNHANDLEABLE;

	if (((u32) (old &gt;&gt; 0) != (u32) reg_read(ctxt, VCPU_REGS_RAX)) ||
<yellow>	    ((u32) (old >> 32) != (u32) reg_read(ctxt, VCPU_REGS_RDX))) {</yellow>
<yellow>		*reg_write(ctxt, VCPU_REGS_RAX) = (u32) (old >> 0);</yellow>
		*reg_write(ctxt, VCPU_REGS_RDX) = (u32) (old &gt;&gt; 32);
		ctxt-&gt;eflags &amp;= ~X86_EFLAGS_ZF;
	} else {
<yellow>		ctxt->dst.val64 = ((u64)reg_read(ctxt, VCPU_REGS_RCX) << 32) |</yellow>
			(u32) reg_read(ctxt, VCPU_REGS_RBX);

		ctxt-&gt;eflags |= X86_EFLAGS_ZF;
	}
	return X86EMUL_CONTINUE;
<yellow>}</yellow>

static int em_ret(struct x86_emulate_ctxt *ctxt)
<yellow>{</yellow>
	int rc;
	unsigned long eip;

<yellow>	rc = emulate_pop(ctxt, &eip, ctxt->op_bytes);</yellow>
	if (rc != X86EMUL_CONTINUE)
		return rc;

<yellow>	return assign_eip_near(ctxt, eip);</yellow>
}

static int em_ret_far(struct x86_emulate_ctxt *ctxt)
<yellow>{</yellow>
	int rc;
	unsigned long eip, cs;
<yellow>	int cpl = ctxt->ops->cpl(ctxt);</yellow>
	struct desc_struct new_desc;

	rc = emulate_pop(ctxt, &amp;eip, ctxt-&gt;op_bytes);
	if (rc != X86EMUL_CONTINUE)
		return rc;
<yellow>	rc = emulate_pop(ctxt, &cs, ctxt->op_bytes);</yellow>
	if (rc != X86EMUL_CONTINUE)
		return rc;
<yellow>	rc = __load_segment_descriptor(ctxt, (u16)cs, VCPU_SREG_CS, cpl,</yellow>
				       X86_TRANSFER_RET,
				       &amp;new_desc);
	if (rc != X86EMUL_CONTINUE)
		return rc;
<yellow>	rc = assign_eip_far(ctxt, eip);</yellow>
	/* Error handling is not implemented. */
	if (rc != X86EMUL_CONTINUE)
<yellow>		return X86EMUL_UNHANDLEABLE;</yellow>

	return rc;
}

<yellow>static int em_ret_far_imm(struct x86_emulate_ctxt *ctxt)</yellow>
<yellow>{</yellow>
        int rc;

<yellow>        rc = em_ret_far(ctxt);</yellow>
        if (rc != X86EMUL_CONTINUE)
                return rc;
<yellow>        rsp_increment(ctxt, ctxt->src.val);</yellow>
        return X86EMUL_CONTINUE;
}

static int em_cmpxchg(struct x86_emulate_ctxt *ctxt)
{
	/* Save real source value, then compare EAX against destination. */
<yellow>	ctxt->dst.orig_val = ctxt->dst.val;</yellow>
	ctxt-&gt;dst.val = reg_read(ctxt, VCPU_REGS_RAX);
	ctxt-&gt;src.orig_val = ctxt-&gt;src.val;
	ctxt-&gt;src.val = ctxt-&gt;dst.orig_val;
	fastop(ctxt, em_cmp);

	if (ctxt-&gt;eflags &amp; X86_EFLAGS_ZF) {
		/* Success: write back to memory; no update of EAX */
<yellow>		ctxt->src.type = OP_NONE;</yellow>
<yellow>		ctxt->dst.val = ctxt->src.orig_val;</yellow>
	} else {
		/* Failure: write the value we saw to EAX. */
<yellow>		ctxt->src.type = OP_REG;</yellow>
		ctxt-&gt;src.addr.reg = reg_rmw(ctxt, VCPU_REGS_RAX);
		ctxt-&gt;src.val = ctxt-&gt;dst.orig_val;
		/* Create write-cycle to dest by writing the same value */
		ctxt-&gt;dst.val = ctxt-&gt;dst.orig_val;
	}
	return X86EMUL_CONTINUE;
}

static int em_lseg(struct x86_emulate_ctxt *ctxt)
<yellow>{</yellow>
<yellow>	int seg = ctxt->src2.val;</yellow>
	unsigned short sel;
	int rc;

	memcpy(&amp;sel, ctxt-&gt;src.valptr + ctxt-&gt;op_bytes, 2);

	rc = load_segment_descriptor(ctxt, sel, seg);
	if (rc != X86EMUL_CONTINUE)
		return rc;

<yellow>	ctxt->dst.val = ctxt->src.val;</yellow>
	return rc;
}

static int emulator_has_longmode(struct x86_emulate_ctxt *ctxt)
{
#ifdef CONFIG_X86_64
<yellow>	return ctxt->ops->guest_has_long_mode(ctxt);</yellow>
#else
	return false;
#endif
}

static void rsm_set_desc_flags(struct desc_struct *desc, u32 flags)
{
	desc-&gt;g    = (flags &gt;&gt; 23) &amp; 1;
	desc-&gt;d    = (flags &gt;&gt; 22) &amp; 1;
	desc-&gt;l    = (flags &gt;&gt; 21) &amp; 1;
	desc-&gt;avl  = (flags &gt;&gt; 20) &amp; 1;
	desc-&gt;p    = (flags &gt;&gt; 15) &amp; 1;
	desc-&gt;dpl  = (flags &gt;&gt; 13) &amp; 3;
	desc-&gt;s    = (flags &gt;&gt; 12) &amp; 1;
	desc-&gt;type = (flags &gt;&gt;  8) &amp; 15;
}

static int rsm_load_seg_32(struct x86_emulate_ctxt *ctxt, const char *smstate,
			   int n)
{
	struct desc_struct desc;
	int offset;
	u16 selector;

<yellow>	selector = GET_SMSTATE(u32, smstate, 0x7fa8 + n * 4);</yellow>

	if (n &lt; 3)
<yellow>		offset = 0x7f84 + n * 12;</yellow>
	else
<yellow>		offset = 0x7f2c + (n - 3) * 12;</yellow>

<yellow>	set_desc_base(&desc,      GET_SMSTATE(u32, smstate, offset + 8));</yellow>
	set_desc_limit(&amp;desc,     GET_SMSTATE(u32, smstate, offset + 4));
	rsm_set_desc_flags(&amp;desc, GET_SMSTATE(u32, smstate, offset));
	ctxt-&gt;ops-&gt;set_segment(ctxt, selector, &amp;desc, 0, n);
	return X86EMUL_CONTINUE;
}

#ifdef CONFIG_X86_64
static int rsm_load_seg_64(struct x86_emulate_ctxt *ctxt, const char *smstate,
			   int n)
{
	struct desc_struct desc;
	int offset;
	u16 selector;
	u32 base3;

	offset = 0x7e00 + n * 16;

<yellow>	selector =                GET_SMSTATE(u16, smstate, offset);</yellow>
	rsm_set_desc_flags(&amp;desc, GET_SMSTATE(u16, smstate, offset + 2) &lt;&lt; 8);
	set_desc_limit(&amp;desc,     GET_SMSTATE(u32, smstate, offset + 4));
	set_desc_base(&amp;desc,      GET_SMSTATE(u32, smstate, offset + 8));
	base3 =                   GET_SMSTATE(u32, smstate, offset + 12);

	ctxt-&gt;ops-&gt;set_segment(ctxt, selector, &amp;desc, base3, n);
	return X86EMUL_CONTINUE;
}
#endif

static int rsm_enter_protected_mode(struct x86_emulate_ctxt *ctxt,
				    u64 cr0, u64 cr3, u64 cr4)
{
	int bad;
	u64 pcid;

	/* In order to later set CR4.PCIDE, CR3[11:0] must be zero.  */
	pcid = 0;
<yellow>	if (cr4 & X86_CR4_PCIDE) {</yellow>
<yellow>		pcid = cr3 & 0xfff;</yellow>
		cr3 &amp;= ~0xfff;
	}

<yellow>	bad = ctxt->ops->set_cr(ctxt, 3, cr3);</yellow>
	if (bad)
		return X86EMUL_UNHANDLEABLE;

	/*
	 * First enable PAE, long mode needs it before CR0.PG = 1 is set.
	 * Then enable protected mode.	However, PCID cannot be enabled
	 * if EFER.LMA=0, so set it separately.
	 */
<yellow>	bad = ctxt->ops->set_cr(ctxt, 4, cr4 & ~X86_CR4_PCIDE);</yellow>
	if (bad)
		return X86EMUL_UNHANDLEABLE;

<yellow>	bad = ctxt->ops->set_cr(ctxt, 0, cr0);</yellow>
	if (bad)
		return X86EMUL_UNHANDLEABLE;

<yellow>	if (cr4 & X86_CR4_PCIDE) {</yellow>
<yellow>		bad = ctxt->ops->set_cr(ctxt, 4, cr4);</yellow>
		if (bad)
			return X86EMUL_UNHANDLEABLE;
<yellow>		if (pcid) {</yellow>
<yellow>			bad = ctxt->ops->set_cr(ctxt, 3, cr3 | pcid);</yellow>
			if (bad)
				return X86EMUL_UNHANDLEABLE;
		}

	}

	return X86EMUL_CONTINUE;
<yellow>}</yellow>

static int rsm_load_state_32(struct x86_emulate_ctxt *ctxt,
			     const char *smstate)
{
	struct desc_struct desc;
	struct desc_ptr dt;
	u16 selector;
	u32 val, cr0, cr3, cr4;
	int i;

<yellow>	cr0 =                      GET_SMSTATE(u32, smstate, 0x7ffc);</yellow>
	cr3 =                      GET_SMSTATE(u32, smstate, 0x7ff8);
	ctxt-&gt;eflags =             GET_SMSTATE(u32, smstate, 0x7ff4) | X86_EFLAGS_FIXED;
	ctxt-&gt;_eip =               GET_SMSTATE(u32, smstate, 0x7ff0);

	for (i = 0; i &lt; 8; i++)
<yellow>		*reg_write(ctxt, i) = GET_SMSTATE(u32, smstate, 0x7fd0 + i * 4);</yellow>

	val = GET_SMSTATE(u32, smstate, 0x7fcc);

<yellow>	if (ctxt->ops->set_dr(ctxt, 6, val))</yellow>
		return X86EMUL_UNHANDLEABLE;

	val = GET_SMSTATE(u32, smstate, 0x7fc8);

<yellow>	if (ctxt->ops->set_dr(ctxt, 7, val))</yellow>
		return X86EMUL_UNHANDLEABLE;

	selector =                 GET_SMSTATE(u32, smstate, 0x7fc4);
<yellow>	set_desc_base(&desc,       GET_SMSTATE(u32, smstate, 0x7f64));</yellow>
	set_desc_limit(&amp;desc,      GET_SMSTATE(u32, smstate, 0x7f60));
	rsm_set_desc_flags(&amp;desc,  GET_SMSTATE(u32, smstate, 0x7f5c));
	ctxt-&gt;ops-&gt;set_segment(ctxt, selector, &amp;desc, 0, VCPU_SREG_TR);

	selector =                 GET_SMSTATE(u32, smstate, 0x7fc0);
	set_desc_base(&amp;desc,       GET_SMSTATE(u32, smstate, 0x7f80));
	set_desc_limit(&amp;desc,      GET_SMSTATE(u32, smstate, 0x7f7c));
	rsm_set_desc_flags(&amp;desc,  GET_SMSTATE(u32, smstate, 0x7f78));
	ctxt-&gt;ops-&gt;set_segment(ctxt, selector, &amp;desc, 0, VCPU_SREG_LDTR);

	dt.address =               GET_SMSTATE(u32, smstate, 0x7f74);
	dt.size =                  GET_SMSTATE(u32, smstate, 0x7f70);
	ctxt-&gt;ops-&gt;set_gdt(ctxt, &amp;dt);

	dt.address =               GET_SMSTATE(u32, smstate, 0x7f58);
	dt.size =                  GET_SMSTATE(u32, smstate, 0x7f54);
	ctxt-&gt;ops-&gt;set_idt(ctxt, &amp;dt);

	for (i = 0; i &lt; 6; i++) {
<yellow>		int r = rsm_load_seg_32(ctxt, smstate, i);</yellow>
		if (r != X86EMUL_CONTINUE)
			return r;
	}

	cr4 = GET_SMSTATE(u32, smstate, 0x7f14);

<yellow>	ctxt->ops->set_smbase(ctxt, GET_SMSTATE(u32, smstate, 0x7ef8));</yellow>

	return rsm_enter_protected_mode(ctxt, cr0, cr3, cr4);
}

#ifdef CONFIG_X86_64
static int rsm_load_state_64(struct x86_emulate_ctxt *ctxt,
			     const char *smstate)
{
	struct desc_struct desc;
	struct desc_ptr dt;
	u64 val, cr0, cr3, cr4;
	u32 base3;
	u16 selector;
	int i, r;

	for (i = 0; i &lt; 16; i++)
<yellow>		*reg_write(ctxt, i) = GET_SMSTATE(u64, smstate, 0x7ff8 - i * 8);</yellow>

<yellow>	ctxt->_eip   = GET_SMSTATE(u64, smstate, 0x7f78);</yellow>
	ctxt-&gt;eflags = GET_SMSTATE(u32, smstate, 0x7f70) | X86_EFLAGS_FIXED;

	val = GET_SMSTATE(u64, smstate, 0x7f68);

	if (ctxt-&gt;ops-&gt;set_dr(ctxt, 6, val))
		return X86EMUL_UNHANDLEABLE;

	val = GET_SMSTATE(u64, smstate, 0x7f60);

<yellow>	if (ctxt->ops->set_dr(ctxt, 7, val))</yellow>
		return X86EMUL_UNHANDLEABLE;

<yellow>	cr0 =                       GET_SMSTATE(u64, smstate, 0x7f58);</yellow>
	cr3 =                       GET_SMSTATE(u64, smstate, 0x7f50);
	cr4 =                       GET_SMSTATE(u64, smstate, 0x7f48);
	ctxt-&gt;ops-&gt;set_smbase(ctxt, GET_SMSTATE(u32, smstate, 0x7f00));
	val =                       GET_SMSTATE(u64, smstate, 0x7ed0);

	if (ctxt-&gt;ops-&gt;set_msr(ctxt, MSR_EFER, val &amp; ~EFER_LMA))
		return X86EMUL_UNHANDLEABLE;

	selector =                  GET_SMSTATE(u32, smstate, 0x7e90);
<yellow>	rsm_set_desc_flags(&desc,   GET_SMSTATE(u32, smstate, 0x7e92) << 8);</yellow>
	set_desc_limit(&amp;desc,       GET_SMSTATE(u32, smstate, 0x7e94));
	set_desc_base(&amp;desc,        GET_SMSTATE(u32, smstate, 0x7e98));
	base3 =                     GET_SMSTATE(u32, smstate, 0x7e9c);
	ctxt-&gt;ops-&gt;set_segment(ctxt, selector, &amp;desc, base3, VCPU_SREG_TR);

	dt.size =                   GET_SMSTATE(u32, smstate, 0x7e84);
	dt.address =                GET_SMSTATE(u64, smstate, 0x7e88);
	ctxt-&gt;ops-&gt;set_idt(ctxt, &amp;dt);

	selector =                  GET_SMSTATE(u32, smstate, 0x7e70);
	rsm_set_desc_flags(&amp;desc,   GET_SMSTATE(u32, smstate, 0x7e72) &lt;&lt; 8);
	set_desc_limit(&amp;desc,       GET_SMSTATE(u32, smstate, 0x7e74));
	set_desc_base(&amp;desc,        GET_SMSTATE(u32, smstate, 0x7e78));
	base3 =                     GET_SMSTATE(u32, smstate, 0x7e7c);
	ctxt-&gt;ops-&gt;set_segment(ctxt, selector, &amp;desc, base3, VCPU_SREG_LDTR);

	dt.size =                   GET_SMSTATE(u32, smstate, 0x7e64);
	dt.address =                GET_SMSTATE(u64, smstate, 0x7e68);
	ctxt-&gt;ops-&gt;set_gdt(ctxt, &amp;dt);

	r = rsm_enter_protected_mode(ctxt, cr0, cr3, cr4);
	if (r != X86EMUL_CONTINUE)
		return r;

<yellow>	for (i = 0; i < 6; i++) {</yellow>
<yellow>		r = rsm_load_seg_64(ctxt, smstate, i);</yellow>
		if (r != X86EMUL_CONTINUE)
			return r;
	}

	return X86EMUL_CONTINUE;
}
#endif

static int em_rsm(struct x86_emulate_ctxt *ctxt)
<yellow>{</yellow>
	unsigned long cr0, cr4, efer;
	char buf[512];
	u64 smbase;
	int ret;

<yellow>	if ((ctxt->ops->get_hflags(ctxt) & X86EMUL_SMM_MASK) == 0)</yellow>
<yellow>		return emulate_ud(ctxt);</yellow>

<yellow>	smbase = ctxt->ops->get_smbase(ctxt);</yellow>

	ret = ctxt-&gt;ops-&gt;read_phys(ctxt, smbase + 0xfe00, buf, sizeof(buf));
	if (ret != X86EMUL_CONTINUE)
		return X86EMUL_UNHANDLEABLE;

<yellow>	if ((ctxt->ops->get_hflags(ctxt) & X86EMUL_SMM_INSIDE_NMI_MASK) == 0)</yellow>
<yellow>		ctxt->ops->set_nmi_mask(ctxt, false);</yellow>

<yellow>	ctxt->ops->exiting_smm(ctxt);</yellow>

	/*
	 * Get back to real mode, to prepare a safe state in which to load
	 * CR0/CR3/CR4/EFER.  It&#x27;s all a bit more complicated if the vCPU
	 * supports long mode.
	 */
	if (emulator_has_longmode(ctxt)) {
		struct desc_struct cs_desc;

		/* Zero CR4.PCIDE before CR0.PG.  */
<yellow>		cr4 = ctxt->ops->get_cr(ctxt, 4);</yellow>
		if (cr4 &amp; X86_CR4_PCIDE)
<yellow>			ctxt->ops->set_cr(ctxt, 4, cr4 & ~X86_CR4_PCIDE);</yellow>

		/* A 32-bit code segment is required to clear EFER.LMA.  */
<yellow>		memset(&cs_desc, 0, sizeof(cs_desc));</yellow>
		cs_desc.type = 0xb;
		cs_desc.s = cs_desc.g = cs_desc.p = 1;
		ctxt-&gt;ops-&gt;set_segment(ctxt, 0, &amp;cs_desc, 0, VCPU_SREG_CS);
	}

	/* For the 64-bit case, this will clear EFER.LMA.  */
<yellow>	cr0 = ctxt->ops->get_cr(ctxt, 0);</yellow>
	if (cr0 &amp; X86_CR0_PE)
<yellow>		ctxt->ops->set_cr(ctxt, 0, cr0 & ~(X86_CR0_PG | X86_CR0_PE));</yellow>

<yellow>	if (emulator_has_longmode(ctxt)) {</yellow>
		/* Clear CR4.PAE before clearing EFER.LME. */
<yellow>		cr4 = ctxt->ops->get_cr(ctxt, 4);</yellow>
		if (cr4 &amp; X86_CR4_PAE)
<yellow>			ctxt->ops->set_cr(ctxt, 4, cr4 & ~X86_CR4_PAE);</yellow>

		/* And finally go back to 32-bit mode.  */
		efer = 0;
<yellow>		ctxt->ops->set_msr(ctxt, MSR_EFER, efer);</yellow>
	}

	/*
	 * Give leave_smm() a chance to make ISA-specific changes to the vCPU
	 * state (e.g. enter guest mode) before loading state from the SMM
	 * state-save area.
	 */
<yellow>	if (ctxt->ops->leave_smm(ctxt, buf))</yellow>
		goto emulate_shutdown;

#ifdef CONFIG_X86_64
<yellow>	if (emulator_has_longmode(ctxt))</yellow>
<yellow>		ret = rsm_load_state_64(ctxt, buf);</yellow>
	else
#endif
<yellow>		ret = rsm_load_state_32(ctxt, buf);</yellow>

	if (ret != X86EMUL_CONTINUE)
		goto emulate_shutdown;

	/*
	 * Note, the ctxt-&gt;ops callbacks are responsible for handling side
	 * effects when writing MSRs and CRs, e.g. MMU context resets, CPUID
	 * runtime updates, etc...  If that changes, e.g. this flow is moved
	 * out of the emulator to make it look more like enter_smm(), then
	 * those side effects need to be explicitly handled for both success
	 * and shutdown.
	 */
<yellow>	return emulator_recalc_and_set_mode(ctxt);</yellow>

emulate_shutdown:
<yellow>	ctxt->ops->triple_fault(ctxt);</yellow>
	return X86EMUL_CONTINUE;
}

static void
setup_syscalls_segments(struct desc_struct *cs, struct desc_struct *ss)
{
	cs-&gt;l = 0;		/* will be adjusted later */
	set_desc_base(cs, 0);	/* flat segment */
	cs-&gt;g = 1;		/* 4kb granularity */
	set_desc_limit(cs, 0xfffff);	/* 4GB limit */
	cs-&gt;type = 0x0b;	/* Read, Execute, Accessed */
	cs-&gt;s = 1;
	cs-&gt;dpl = 0;		/* will be adjusted later */
	cs-&gt;p = 1;
	cs-&gt;d = 1;
	cs-&gt;avl = 0;

	set_desc_base(ss, 0);	/* flat segment */
	set_desc_limit(ss, 0xfffff);	/* 4GB limit */
	ss-&gt;g = 1;		/* 4kb granularity */
	ss-&gt;s = 1;
	ss-&gt;type = 0x03;	/* Read/Write, Accessed */
	ss-&gt;d = 1;		/* 32bit stack segment */
	ss-&gt;dpl = 0;
	ss-&gt;p = 1;
	ss-&gt;l = 0;
	ss-&gt;avl = 0;
}

static bool vendor_intel(struct x86_emulate_ctxt *ctxt)
<yellow>{</yellow>
	u32 eax, ebx, ecx, edx;

	eax = ecx = 0;
<yellow>	ctxt->ops->get_cpuid(ctxt, &eax, &ebx, &ecx, &edx, true);</yellow>
<yellow>	return is_guest_vendor_intel(ebx, ecx, edx);</yellow>
}

static bool em_syscall_is_enabled(struct x86_emulate_ctxt *ctxt)
{
	const struct x86_emulate_ops *ops = ctxt-&gt;ops;
	u32 eax, ebx, ecx, edx;

	/*
	 * syscall should always be enabled in longmode - so only become
	 * vendor specific (cpuid) if other modes are active...
	 */
<yellow>	if (ctxt->mode == X86EMUL_MODE_PROT64)</yellow>
		return true;

	eax = 0x00000000;
	ecx = 0x00000000;
<yellow>	ops->get_cpuid(ctxt, &eax, &ebx, &ecx, &edx, true);</yellow>
	/*
	 * remark: Intel CPUs only support &quot;syscall&quot; in 64bit longmode. Also a
	 * 64bit guest with a 32bit compat-app running will #UD !! While this
	 * behaviour can be fixed (by emulating) into AMD response - CPUs of
	 * AMD can&#x27;t behave like Intel.
	 */
	if (is_guest_vendor_intel(ebx, ecx, edx))
		return false;

<yellow>	if (is_guest_vendor_amd(ebx, ecx, edx) ||</yellow>
<yellow>	    is_guest_vendor_hygon(ebx, ecx, edx))</yellow>
		return true;

	/*
	 * default: (not Intel, not AMD, not Hygon), apply Intel&#x27;s
	 * stricter rules...
	 */
	return false;
}

static int em_syscall(struct x86_emulate_ctxt *ctxt)
<yellow>{</yellow>
<yellow>	const struct x86_emulate_ops *ops = ctxt->ops;</yellow>
	struct desc_struct cs, ss;
	u64 msr_data;
	u16 cs_sel, ss_sel;
	u64 efer = 0;

	/* syscall is not available in real mode */
	if (ctxt-&gt;mode == X86EMUL_MODE_REAL ||
	    ctxt-&gt;mode == X86EMUL_MODE_VM86)
<yellow>		return emulate_ud(ctxt);</yellow>

<yellow>	if (!(em_syscall_is_enabled(ctxt)))</yellow>
		return emulate_ud(ctxt);

<yellow>	ops->get_msr(ctxt, MSR_EFER, &efer);</yellow>
	if (!(efer &amp; EFER_SCE))
		return emulate_ud(ctxt);

	setup_syscalls_segments(&amp;cs, &amp;ss);
<yellow>	ops->get_msr(ctxt, MSR_STAR, &msr_data);</yellow>
	msr_data &gt;&gt;= 32;
	cs_sel = (u16)(msr_data &amp; 0xfffc);
	ss_sel = (u16)(msr_data + 8);

	if (efer &amp; EFER_LMA) {
		cs.d = 0;
<yellow>		cs.l = 1;</yellow>
	}
<yellow>	ops->set_segment(ctxt, cs_sel, &cs, 0, VCPU_SREG_CS);</yellow>
	ops-&gt;set_segment(ctxt, ss_sel, &amp;ss, 0, VCPU_SREG_SS);

	*reg_write(ctxt, VCPU_REGS_RCX) = ctxt-&gt;_eip;
	if (efer &amp; EFER_LMA) {
#ifdef CONFIG_X86_64
<yellow>		*reg_write(ctxt, VCPU_REGS_R11) = ctxt->eflags;</yellow>

<yellow>		ops->get_msr(ctxt,</yellow>
			     ctxt-&gt;mode == X86EMUL_MODE_PROT64 ?
			     MSR_LSTAR : MSR_CSTAR, &amp;msr_data);
		ctxt-&gt;_eip = msr_data;

		ops-&gt;get_msr(ctxt, MSR_SYSCALL_MASK, &amp;msr_data);
		ctxt-&gt;eflags &amp;= ~msr_data;
<yellow>		ctxt->eflags |= X86_EFLAGS_FIXED;</yellow>
#endif
	} else {
		/* legacy mode */
<yellow>		ops->get_msr(ctxt, MSR_STAR, &msr_data);</yellow>
		ctxt-&gt;_eip = (u32)msr_data;

		ctxt-&gt;eflags &amp;= ~(X86_EFLAGS_VM | X86_EFLAGS_IF);
	}

	ctxt-&gt;tf = (ctxt-&gt;eflags &amp; X86_EFLAGS_TF) != 0;
	return X86EMUL_CONTINUE;
}

static int em_sysenter(struct x86_emulate_ctxt *ctxt)
<yellow>{</yellow>
<yellow>	const struct x86_emulate_ops *ops = ctxt->ops;</yellow>
	struct desc_struct cs, ss;
	u64 msr_data;
	u16 cs_sel, ss_sel;
	u64 efer = 0;

	ops-&gt;get_msr(ctxt, MSR_EFER, &amp;efer);
	/* inject #GP if in real mode */
	if (ctxt-&gt;mode == X86EMUL_MODE_REAL)
<yellow>		return emulate_gp(ctxt, 0);</yellow>

	/*
	 * Not recognized on AMD in compat mode (but is recognized in legacy
	 * mode).
	 */
<yellow>	if ((ctxt->mode != X86EMUL_MODE_PROT64) && (efer & EFER_LMA)</yellow>
<yellow>	    && !vendor_intel(ctxt))</yellow>
<yellow>		return emulate_ud(ctxt);</yellow>

	/* sysenter/sysexit have not been tested in 64bit mode. */
<yellow>	if (ctxt->mode == X86EMUL_MODE_PROT64)</yellow>
		return X86EMUL_UNHANDLEABLE;

<yellow>	ops->get_msr(ctxt, MSR_IA32_SYSENTER_CS, &msr_data);</yellow>
	if ((msr_data &amp; 0xfffc) == 0x0)
		return emulate_gp(ctxt, 0);

	setup_syscalls_segments(&amp;cs, &amp;ss);
<yellow>	ctxt->eflags &= ~(X86_EFLAGS_VM | X86_EFLAGS_IF);</yellow>
	cs_sel = (u16)msr_data &amp; ~SEGMENT_RPL_MASK;
	ss_sel = cs_sel + 8;
	if (efer &amp; EFER_LMA) {
		cs.d = 0;
<yellow>		cs.l = 1;</yellow>
	}

<yellow>	ops->set_segment(ctxt, cs_sel, &cs, 0, VCPU_SREG_CS);</yellow>
	ops-&gt;set_segment(ctxt, ss_sel, &amp;ss, 0, VCPU_SREG_SS);

	ops-&gt;get_msr(ctxt, MSR_IA32_SYSENTER_EIP, &amp;msr_data);
<yellow>	ctxt->_eip = (efer & EFER_LMA) ? msr_data : (u32)msr_data;</yellow>

	ops-&gt;get_msr(ctxt, MSR_IA32_SYSENTER_ESP, &amp;msr_data);
<yellow>	*reg_write(ctxt, VCPU_REGS_RSP) = (efer & EFER_LMA) ? msr_data :</yellow>
<yellow>							      (u32)msr_data;</yellow>
	if (efer &amp; EFER_LMA)
<yellow>		ctxt->mode = X86EMUL_MODE_PROT64;</yellow>

	return X86EMUL_CONTINUE;
}

static int em_sysexit(struct x86_emulate_ctxt *ctxt)
<yellow>{</yellow>
<yellow>	const struct x86_emulate_ops *ops = ctxt->ops;</yellow>
	struct desc_struct cs, ss;
	u64 msr_data, rcx, rdx;
	int usermode;
	u16 cs_sel = 0, ss_sel = 0;

	/* inject #GP if in real mode or Virtual 8086 mode */
	if (ctxt-&gt;mode == X86EMUL_MODE_REAL ||
	    ctxt-&gt;mode == X86EMUL_MODE_VM86)
<yellow>		return emulate_gp(ctxt, 0);</yellow>

	setup_syscalls_segments(&amp;cs, &amp;ss);

<yellow>	if ((ctxt->rex_prefix & 0x8) != 0x0)</yellow>
		usermode = X86EMUL_MODE_PROT64;
	else
		usermode = X86EMUL_MODE_PROT32;

<yellow>	rcx = reg_read(ctxt, VCPU_REGS_RCX);</yellow>
	rdx = reg_read(ctxt, VCPU_REGS_RDX);

	cs.dpl = 3;
	ss.dpl = 3;
	ops-&gt;get_msr(ctxt, MSR_IA32_SYSENTER_CS, &amp;msr_data);
	switch (usermode) {
	case X86EMUL_MODE_PROT32:
		cs_sel = (u16)(msr_data + 16);
		if ((msr_data &amp; 0xfffc) == 0x0)
			return emulate_gp(ctxt, 0);
<yellow>		ss_sel = (u16)(msr_data + 24);</yellow>
		rcx = (u32)rcx;
		rdx = (u32)rdx;
		break;
	case X86EMUL_MODE_PROT64:
		cs_sel = (u16)(msr_data + 32);
		if (msr_data == 0x0)
			return emulate_gp(ctxt, 0);
<yellow>		ss_sel = cs_sel + 8;</yellow>
		cs.d = 0;
<yellow>		cs.l = 1;</yellow>
<yellow>		if (emul_is_noncanonical_address(rcx, ctxt) ||</yellow>
<yellow>		    emul_is_noncanonical_address(rdx, ctxt))</yellow>
			return emulate_gp(ctxt, 0);
		break;
	}
	cs_sel |= SEGMENT_RPL_MASK;
<yellow>	ss_sel |= SEGMENT_RPL_MASK;</yellow>

	ops-&gt;set_segment(ctxt, cs_sel, &amp;cs, 0, VCPU_SREG_CS);
	ops-&gt;set_segment(ctxt, ss_sel, &amp;ss, 0, VCPU_SREG_SS);

	ctxt-&gt;_eip = rdx;
	ctxt-&gt;mode = usermode;
	*reg_write(ctxt, VCPU_REGS_RSP) = rcx;

	return X86EMUL_CONTINUE;
}

<blue>static bool emulator_bad_iopl(struct x86_emulate_ctxt *ctxt)</blue>
{
	int iopl;
<blue>	if (ctxt->mode == X86EMUL_MODE_REAL)</blue>
		return false;
<blue>	if (ctxt->mode == X86EMUL_MODE_VM86)</blue>
		return true;
<blue>	iopl = (ctxt->eflags & X86_EFLAGS_IOPL) >> X86_EFLAGS_IOPL_BIT;</blue>
	return ctxt-&gt;ops-&gt;cpl(ctxt) &gt; iopl;
}

#define VMWARE_PORT_VMPORT	(0x5658)
#define VMWARE_PORT_VMRPC	(0x5659)

static bool emulator_io_port_access_allowed(struct x86_emulate_ctxt *ctxt,
					    u16 port, u16 len)
<yellow>{</yellow>
<yellow>	const struct x86_emulate_ops *ops = ctxt->ops;</yellow>
	struct desc_struct tr_seg;
	u32 base3;
	int r;
	u16 tr, io_bitmap_ptr, perm, bit_idx = port &amp; 0x7;
	unsigned mask = (1 &lt;&lt; len) - 1;
	unsigned long base;

	/*
	 * VMware allows access to these ports even if denied
	 * by TSS I/O permission bitmap. Mimic behavior.
	 */
<yellow>	if (enable_vmware_backdoor &&</yellow>
<yellow>	    ((port == VMWARE_PORT_VMPORT) || (port == VMWARE_PORT_VMRPC)))</yellow>
		return true;

<yellow>	ops->get_segment(ctxt, &tr, &tr_seg, &base3, VCPU_SREG_TR);</yellow>
	if (!tr_seg.p)
		return false;
<yellow>	if (desc_limit_scaled(&tr_seg) < 103)</yellow>
		return false;
<yellow>	base = get_desc_base(&tr_seg);</yellow>
#ifdef CONFIG_X86_64
	base |= ((u64)base3) &lt;&lt; 32;
#endif
	r = ops-&gt;read_std(ctxt, base + 102, &amp;io_bitmap_ptr, 2, NULL, true);
	if (r != X86EMUL_CONTINUE)
		return false;
<yellow>	if (io_bitmap_ptr + port/8 > desc_limit_scaled(&tr_seg))</yellow>
		return false;
<yellow>	r = ops->read_std(ctxt, base + io_bitmap_ptr + port/8, &perm, 2, NULL, true);</yellow>
	if (r != X86EMUL_CONTINUE)
		return false;
	if ((perm &gt;&gt; bit_idx) &amp; mask)
		return false;
	return true;
}

<blue>static bool emulator_io_permited(struct x86_emulate_ctxt *ctxt,</blue>
				 u16 port, u16 len)
{
<blue>	if (ctxt->perm_ok)</blue>
		return true;

<blue>	if (emulator_bad_iopl(ctxt))</blue>
		if (!emulator_io_port_access_allowed(ctxt, port, len))
			return false;

<blue>	ctxt->perm_ok = true;</blue>

	return true;
}

static void string_registers_quirk(struct x86_emulate_ctxt *ctxt)
{
	/*
	 * Intel CPUs mask the counter and pointers in quite strange
	 * manner when ECX is zero due to REP-string optimizations.
	 */
#ifdef CONFIG_X86_64
<yellow>	if (ctxt->ad_bytes != 4 || !vendor_intel(ctxt))</yellow>
		return;

<yellow>	*reg_write(ctxt, VCPU_REGS_RCX) = 0;</yellow>

	switch (ctxt-&gt;b) {
	case 0xa4:	/* movsb */
	case 0xa5:	/* movsd/w */
<yellow>		*reg_rmw(ctxt, VCPU_REGS_RSI) &= (u32)-1;</yellow>
		fallthrough;
	case 0xaa:	/* stosb */
	case 0xab:	/* stosd/w */
<yellow>		*reg_rmw(ctxt, VCPU_REGS_RDI) &= (u32)-1;</yellow>
	}
#endif
}

static void save_state_to_tss16(struct x86_emulate_ctxt *ctxt,
				struct tss_segment_16 *tss)
{
<yellow>	tss->ip = ctxt->_eip;</yellow>
	tss-&gt;flag = ctxt-&gt;eflags;
	tss-&gt;ax = reg_read(ctxt, VCPU_REGS_RAX);
	tss-&gt;cx = reg_read(ctxt, VCPU_REGS_RCX);
	tss-&gt;dx = reg_read(ctxt, VCPU_REGS_RDX);
	tss-&gt;bx = reg_read(ctxt, VCPU_REGS_RBX);
	tss-&gt;sp = reg_read(ctxt, VCPU_REGS_RSP);
	tss-&gt;bp = reg_read(ctxt, VCPU_REGS_RBP);
	tss-&gt;si = reg_read(ctxt, VCPU_REGS_RSI);
	tss-&gt;di = reg_read(ctxt, VCPU_REGS_RDI);

	tss-&gt;es = get_segment_selector(ctxt, VCPU_SREG_ES);
	tss-&gt;cs = get_segment_selector(ctxt, VCPU_SREG_CS);
	tss-&gt;ss = get_segment_selector(ctxt, VCPU_SREG_SS);
	tss-&gt;ds = get_segment_selector(ctxt, VCPU_SREG_DS);
	tss-&gt;ldt = get_segment_selector(ctxt, VCPU_SREG_LDTR);
}

static int load_state_from_tss16(struct x86_emulate_ctxt *ctxt,
				 struct tss_segment_16 *tss)
{
	int ret;
	u8 cpl;

<yellow>	ctxt->_eip = tss->ip;</yellow>
	ctxt-&gt;eflags = tss-&gt;flag | 2;
	*reg_write(ctxt, VCPU_REGS_RAX) = tss-&gt;ax;
	*reg_write(ctxt, VCPU_REGS_RCX) = tss-&gt;cx;
	*reg_write(ctxt, VCPU_REGS_RDX) = tss-&gt;dx;
	*reg_write(ctxt, VCPU_REGS_RBX) = tss-&gt;bx;
	*reg_write(ctxt, VCPU_REGS_RSP) = tss-&gt;sp;
	*reg_write(ctxt, VCPU_REGS_RBP) = tss-&gt;bp;
	*reg_write(ctxt, VCPU_REGS_RSI) = tss-&gt;si;
	*reg_write(ctxt, VCPU_REGS_RDI) = tss-&gt;di;

	/*
	 * SDM says that segment selectors are loaded before segment
	 * descriptors
	 */
	set_segment_selector(ctxt, tss-&gt;ldt, VCPU_SREG_LDTR);
	set_segment_selector(ctxt, tss-&gt;es, VCPU_SREG_ES);
	set_segment_selector(ctxt, tss-&gt;cs, VCPU_SREG_CS);
	set_segment_selector(ctxt, tss-&gt;ss, VCPU_SREG_SS);
	set_segment_selector(ctxt, tss-&gt;ds, VCPU_SREG_DS);

	cpl = tss-&gt;cs &amp; 3;

	/*
	 * Now load segment descriptors. If fault happens at this stage
	 * it is handled in a context of new task
	 */
	ret = __load_segment_descriptor(ctxt, tss-&gt;ldt, VCPU_SREG_LDTR, cpl,
					X86_TRANSFER_TASK_SWITCH, NULL);
	if (ret != X86EMUL_CONTINUE)
		return ret;
<yellow>	ret = __load_segment_descriptor(ctxt, tss->es, VCPU_SREG_ES, cpl,</yellow>
					X86_TRANSFER_TASK_SWITCH, NULL);
	if (ret != X86EMUL_CONTINUE)
		return ret;
<yellow>	ret = __load_segment_descriptor(ctxt, tss->cs, VCPU_SREG_CS, cpl,</yellow>
					X86_TRANSFER_TASK_SWITCH, NULL);
	if (ret != X86EMUL_CONTINUE)
		return ret;
<yellow>	ret = __load_segment_descriptor(ctxt, tss->ss, VCPU_SREG_SS, cpl,</yellow>
					X86_TRANSFER_TASK_SWITCH, NULL);
	if (ret != X86EMUL_CONTINUE)
		return ret;
<yellow>	ret = __load_segment_descriptor(ctxt, tss->ds, VCPU_SREG_DS, cpl,</yellow>
					X86_TRANSFER_TASK_SWITCH, NULL);
	if (ret != X86EMUL_CONTINUE)
		return ret;

	return X86EMUL_CONTINUE;
}

static int task_switch_16(struct x86_emulate_ctxt *ctxt, u16 old_tss_sel,
			  ulong old_tss_base, struct desc_struct *new_desc)
{
	struct tss_segment_16 tss_seg;
	int ret;
<yellow>	u32 new_tss_base = get_desc_base(new_desc);</yellow>

	ret = linear_read_system(ctxt, old_tss_base, &amp;tss_seg, sizeof(tss_seg));
	if (ret != X86EMUL_CONTINUE)
		return ret;

<yellow>	save_state_to_tss16(ctxt, &tss_seg);</yellow>

	ret = linear_write_system(ctxt, old_tss_base, &amp;tss_seg, sizeof(tss_seg));
	if (ret != X86EMUL_CONTINUE)
		return ret;

	ret = linear_read_system(ctxt, new_tss_base, &amp;tss_seg, sizeof(tss_seg));
	if (ret != X86EMUL_CONTINUE)
		return ret;

<yellow>	if (old_tss_sel != 0xffff) {</yellow>
<yellow>		tss_seg.prev_task_link = old_tss_sel;</yellow>

		ret = linear_write_system(ctxt, new_tss_base,
					  &amp;tss_seg.prev_task_link,
					  sizeof(tss_seg.prev_task_link));
		if (ret != X86EMUL_CONTINUE)
			return ret;
	}

<yellow>	return load_state_from_tss16(ctxt, &tss_seg);</yellow>
}

static void save_state_to_tss32(struct x86_emulate_ctxt *ctxt,
				struct tss_segment_32 *tss)
{
	/* CR3 and ldt selector are not saved intentionally */
<yellow>	tss->eip = ctxt->_eip;</yellow>
	tss-&gt;eflags = ctxt-&gt;eflags;
	tss-&gt;eax = reg_read(ctxt, VCPU_REGS_RAX);
	tss-&gt;ecx = reg_read(ctxt, VCPU_REGS_RCX);
	tss-&gt;edx = reg_read(ctxt, VCPU_REGS_RDX);
	tss-&gt;ebx = reg_read(ctxt, VCPU_REGS_RBX);
	tss-&gt;esp = reg_read(ctxt, VCPU_REGS_RSP);
	tss-&gt;ebp = reg_read(ctxt, VCPU_REGS_RBP);
	tss-&gt;esi = reg_read(ctxt, VCPU_REGS_RSI);
	tss-&gt;edi = reg_read(ctxt, VCPU_REGS_RDI);

	tss-&gt;es = get_segment_selector(ctxt, VCPU_SREG_ES);
	tss-&gt;cs = get_segment_selector(ctxt, VCPU_SREG_CS);
	tss-&gt;ss = get_segment_selector(ctxt, VCPU_SREG_SS);
	tss-&gt;ds = get_segment_selector(ctxt, VCPU_SREG_DS);
	tss-&gt;fs = get_segment_selector(ctxt, VCPU_SREG_FS);
	tss-&gt;gs = get_segment_selector(ctxt, VCPU_SREG_GS);
}

static int load_state_from_tss32(struct x86_emulate_ctxt *ctxt,
				 struct tss_segment_32 *tss)
{
	int ret;
	u8 cpl;

<yellow>	if (ctxt->ops->set_cr(ctxt, 3, tss->cr3))</yellow>
<yellow>		return emulate_gp(ctxt, 0);</yellow>
<yellow>	ctxt->_eip = tss->eip;</yellow>
	ctxt-&gt;eflags = tss-&gt;eflags | 2;

	/* General purpose registers */
	*reg_write(ctxt, VCPU_REGS_RAX) = tss-&gt;eax;
	*reg_write(ctxt, VCPU_REGS_RCX) = tss-&gt;ecx;
	*reg_write(ctxt, VCPU_REGS_RDX) = tss-&gt;edx;
	*reg_write(ctxt, VCPU_REGS_RBX) = tss-&gt;ebx;
	*reg_write(ctxt, VCPU_REGS_RSP) = tss-&gt;esp;
	*reg_write(ctxt, VCPU_REGS_RBP) = tss-&gt;ebp;
	*reg_write(ctxt, VCPU_REGS_RSI) = tss-&gt;esi;
	*reg_write(ctxt, VCPU_REGS_RDI) = tss-&gt;edi;

	/*
	 * SDM says that segment selectors are loaded before segment
	 * descriptors.  This is important because CPL checks will
	 * use CS.RPL.
	 */
	set_segment_selector(ctxt, tss-&gt;ldt_selector, VCPU_SREG_LDTR);
	set_segment_selector(ctxt, tss-&gt;es, VCPU_SREG_ES);
	set_segment_selector(ctxt, tss-&gt;cs, VCPU_SREG_CS);
	set_segment_selector(ctxt, tss-&gt;ss, VCPU_SREG_SS);
	set_segment_selector(ctxt, tss-&gt;ds, VCPU_SREG_DS);
	set_segment_selector(ctxt, tss-&gt;fs, VCPU_SREG_FS);
	set_segment_selector(ctxt, tss-&gt;gs, VCPU_SREG_GS);

	/*
	 * If we&#x27;re switching between Protected Mode and VM86, we need to make
	 * sure to update the mode before loading the segment descriptors so
	 * that the selectors are interpreted correctly.
	 */
	if (ctxt-&gt;eflags &amp; X86_EFLAGS_VM) {
<yellow>		ctxt->mode = X86EMUL_MODE_VM86;</yellow>
		cpl = 3;
	} else {
<yellow>		ctxt->mode = X86EMUL_MODE_PROT32;</yellow>
		cpl = tss-&gt;cs &amp; 3;
	}

	/*
	 * Now load segment descriptors. If fault happens at this stage
	 * it is handled in a context of new task
	 */
<yellow>	ret = __load_segment_descriptor(ctxt, tss->ldt_selector, VCPU_SREG_LDTR,</yellow>
					cpl, X86_TRANSFER_TASK_SWITCH, NULL);
	if (ret != X86EMUL_CONTINUE)
		return ret;
<yellow>	ret = __load_segment_descriptor(ctxt, tss->es, VCPU_SREG_ES, cpl,</yellow>
					X86_TRANSFER_TASK_SWITCH, NULL);
	if (ret != X86EMUL_CONTINUE)
		return ret;
<yellow>	ret = __load_segment_descriptor(ctxt, tss->cs, VCPU_SREG_CS, cpl,</yellow>
					X86_TRANSFER_TASK_SWITCH, NULL);
	if (ret != X86EMUL_CONTINUE)
		return ret;
<yellow>	ret = __load_segment_descriptor(ctxt, tss->ss, VCPU_SREG_SS, cpl,</yellow>
					X86_TRANSFER_TASK_SWITCH, NULL);
	if (ret != X86EMUL_CONTINUE)
		return ret;
<yellow>	ret = __load_segment_descriptor(ctxt, tss->ds, VCPU_SREG_DS, cpl,</yellow>
					X86_TRANSFER_TASK_SWITCH, NULL);
	if (ret != X86EMUL_CONTINUE)
		return ret;
<yellow>	ret = __load_segment_descriptor(ctxt, tss->fs, VCPU_SREG_FS, cpl,</yellow>
					X86_TRANSFER_TASK_SWITCH, NULL);
	if (ret != X86EMUL_CONTINUE)
		return ret;
<yellow>	ret = __load_segment_descriptor(ctxt, tss->gs, VCPU_SREG_GS, cpl,</yellow>
					X86_TRANSFER_TASK_SWITCH, NULL);

	return ret;
}

static int task_switch_32(struct x86_emulate_ctxt *ctxt, u16 old_tss_sel,
			  ulong old_tss_base, struct desc_struct *new_desc)
<yellow>{</yellow>
	struct tss_segment_32 tss_seg;
	int ret;
<yellow>	u32 new_tss_base = get_desc_base(new_desc);</yellow>
	u32 eip_offset = offsetof(struct tss_segment_32, eip);
	u32 ldt_sel_offset = offsetof(struct tss_segment_32, ldt_selector);

	ret = linear_read_system(ctxt, old_tss_base, &amp;tss_seg, sizeof(tss_seg));
	if (ret != X86EMUL_CONTINUE)
		return ret;

<yellow>	save_state_to_tss32(ctxt, &tss_seg);</yellow>

	/* Only GP registers and segment selectors are saved */
	ret = linear_write_system(ctxt, old_tss_base + eip_offset, &amp;tss_seg.eip,
				  ldt_sel_offset - eip_offset);
	if (ret != X86EMUL_CONTINUE)
		return ret;

	ret = linear_read_system(ctxt, new_tss_base, &amp;tss_seg, sizeof(tss_seg));
	if (ret != X86EMUL_CONTINUE)
		return ret;

	if (old_tss_sel != 0xffff) {
<yellow>		tss_seg.prev_task_link = old_tss_sel;</yellow>

<yellow>		ret = linear_write_system(ctxt, new_tss_base,</yellow>
					  &amp;tss_seg.prev_task_link,
					  sizeof(tss_seg.prev_task_link));
		if (ret != X86EMUL_CONTINUE)
			return ret;
	}

<yellow>	return load_state_from_tss32(ctxt, &tss_seg);</yellow>
}

static int emulator_do_task_switch(struct x86_emulate_ctxt *ctxt,
				   u16 tss_selector, int idt_index, int reason,
				   bool has_error_code, u32 error_code)
{
	const struct x86_emulate_ops *ops = ctxt-&gt;ops;
	struct desc_struct curr_tss_desc, next_tss_desc;
	int ret;
	u16 old_tss_sel = get_segment_selector(ctxt, VCPU_SREG_TR);
	ulong old_tss_base =
		ops-&gt;get_cached_segment_base(ctxt, VCPU_SREG_TR);
	u32 desc_limit;
	ulong desc_addr, dr7;

	/* FIXME: old_tss_base == ~0 ? */

<yellow>	ret = read_segment_descriptor(ctxt, tss_selector, &next_tss_desc, &desc_addr);</yellow>
	if (ret != X86EMUL_CONTINUE)
		return ret;
<yellow>	ret = read_segment_descriptor(ctxt, old_tss_sel, &curr_tss_desc, &desc_addr);</yellow>
	if (ret != X86EMUL_CONTINUE)
		return ret;

	/* FIXME: check that next_tss_desc is tss */

	/*
	 * Check privileges. The three cases are task switch caused by...
	 *
	 * 1. jmp/call/int to task gate: Check against DPL of the task gate
	 * 2. Exception/IRQ/iret: No check is performed
	 * 3. jmp/call to TSS/task-gate: No check is performed since the
	 *    hardware checks it before exiting.
	 */
<yellow>	if (reason == TASK_SWITCH_GATE) {</yellow>
<yellow>		if (idt_index != -1) {</yellow>
			/* Software interrupts */
			struct desc_struct task_gate_desc;
			int dpl;

<yellow>			ret = read_interrupt_descriptor(ctxt, idt_index,</yellow>
							&amp;task_gate_desc);
			if (ret != X86EMUL_CONTINUE)
<yellow>				return ret;</yellow>

<yellow>			dpl = task_gate_desc.dpl;</yellow>
<yellow>			if ((tss_selector & 3) > dpl || ops->cpl(ctxt) > dpl)</yellow>
<yellow>				return emulate_gp(ctxt, (idt_index << 3) | 0x2);</yellow>
		}
	}

<yellow>	desc_limit = desc_limit_scaled(&next_tss_desc);</yellow>
<yellow>	if (!next_tss_desc.p ||</yellow>
<yellow>	    ((desc_limit < 0x67 && (next_tss_desc.type & 8)) ||</yellow>
	     desc_limit &lt; 0x2b)) {
<yellow>		return emulate_ts(ctxt, tss_selector & 0xfffc);</yellow>
	}

<yellow>	if (reason == TASK_SWITCH_IRET || reason == TASK_SWITCH_JMP) {</yellow>
<yellow>		curr_tss_desc.type &= ~(1 << 1); /* clear busy flag */</yellow>
		write_segment_descriptor(ctxt, old_tss_sel, &amp;curr_tss_desc);
	}

	if (reason == TASK_SWITCH_IRET)
<yellow>		ctxt->eflags = ctxt->eflags & ~X86_EFLAGS_NT;</yellow>

	/* set back link to prev task only if NT bit is set in eflags
	   note that old_tss_sel is not used after this point */
<yellow>	if (reason != TASK_SWITCH_CALL && reason != TASK_SWITCH_GATE)</yellow>
		old_tss_sel = 0xffff;

<yellow>	if (next_tss_desc.type & 8)</yellow>
<yellow>		ret = task_switch_32(ctxt, old_tss_sel, old_tss_base, &next_tss_desc);</yellow>
	else
<yellow>		ret = task_switch_16(ctxt, old_tss_sel,</yellow>
				     old_tss_base, &amp;next_tss_desc);
<yellow>	if (ret != X86EMUL_CONTINUE)</yellow>
		return ret;

<yellow>	if (reason == TASK_SWITCH_CALL || reason == TASK_SWITCH_GATE)</yellow>
<yellow>		ctxt->eflags = ctxt->eflags | X86_EFLAGS_NT;</yellow>

<yellow>	if (reason != TASK_SWITCH_IRET) {</yellow>
<yellow>		next_tss_desc.type |= (1 << 1); /* set busy flag */</yellow>
		write_segment_descriptor(ctxt, tss_selector, &amp;next_tss_desc);
	}

<yellow>	ops->set_cr(ctxt, 0,  ops->get_cr(ctxt, 0) | X86_CR0_TS);</yellow>
	ops-&gt;set_segment(ctxt, tss_selector, &amp;next_tss_desc, 0, VCPU_SREG_TR);

	if (has_error_code) {
<yellow>		ctxt->op_bytes = ctxt->ad_bytes = (next_tss_desc.type & 8) ? 4 : 2;</yellow>
		ctxt-&gt;lock_prefix = 0;
		ctxt-&gt;src.val = (unsigned long) error_code;
		ret = em_push(ctxt);
	}

<yellow>	ops->get_dr(ctxt, 7, &dr7);</yellow>
	ops-&gt;set_dr(ctxt, 7, dr7 &amp; ~(DR_LOCAL_ENABLE_MASK | DR_LOCAL_SLOWDOWN));

	return ret;
}

int emulator_task_switch(struct x86_emulate_ctxt *ctxt,
			 u16 tss_selector, int idt_index, int reason,
			 bool has_error_code, u32 error_code)
<yellow>{</yellow>
	int rc;

<yellow>	invalidate_registers(ctxt);</yellow>
	ctxt-&gt;_eip = ctxt-&gt;eip;
	ctxt-&gt;dst.type = OP_NONE;

<yellow>	rc = emulator_do_task_switch(ctxt, tss_selector, idt_index, reason,</yellow>
				     has_error_code, error_code);

	if (rc == X86EMUL_CONTINUE) {
<yellow>		ctxt->eip = ctxt->_eip;</yellow>
		writeback_registers(ctxt);
	}

<yellow>	return (rc == X86EMUL_UNHANDLEABLE) ? EMULATION_FAILED : EMULATION_OK;</yellow>
}

static void string_addr_inc(struct x86_emulate_ctxt *ctxt, int reg,
		struct operand *op)
{
<blue>	int df = (ctxt->eflags & X86_EFLAGS_DF) ? -op->count : op->count;</blue>

<blue>	register_address_increment(ctxt, reg, df * op->bytes);</blue>
<blue>	op->addr.mem.ea = register_address(ctxt, reg);</blue>
}

static int em_das(struct x86_emulate_ctxt *ctxt)
{
	u8 al, old_al;
	bool af, cf, old_cf;

<yellow>	cf = ctxt->eflags & X86_EFLAGS_CF;</yellow>
	al = ctxt-&gt;dst.val;

	old_al = al;
	old_cf = cf;
	cf = false;
<yellow>	af = ctxt->eflags & X86_EFLAGS_AF;</yellow>
	if ((al &amp; 0x0f) &gt; 9 || af) {
<yellow>		al -= 6;</yellow>
		cf = old_cf | (al &gt;= 250);
		af = true;
	} else {
		af = false;
	}
<yellow>	if (old_al > 0x99 || old_cf) {</yellow>
		al -= 0x60;
		cf = true;
	}

	ctxt-&gt;dst.val = al;
	/* Set PF, ZF, SF */
<yellow>	ctxt->src.type = OP_IMM;</yellow>
	ctxt-&gt;src.val = 0;
	ctxt-&gt;src.bytes = 1;
	fastop(ctxt, em_or);
	ctxt-&gt;eflags &amp;= ~(X86_EFLAGS_AF | X86_EFLAGS_CF);
	if (cf)
<yellow>		ctxt->eflags |= X86_EFLAGS_CF;</yellow>
<yellow>	if (af)</yellow>
<yellow>		ctxt->eflags |= X86_EFLAGS_AF;</yellow>
	return X86EMUL_CONTINUE;
<yellow>}</yellow>

static int em_aam(struct x86_emulate_ctxt *ctxt)
{
	u8 al, ah;

<yellow>	if (ctxt->src.val == 0)</yellow>
<yellow>		return emulate_de(ctxt);</yellow>

<yellow>	al = ctxt->dst.val & 0xff;</yellow>
	ah = al / ctxt-&gt;src.val;
	al %= ctxt-&gt;src.val;

	ctxt-&gt;dst.val = (ctxt-&gt;dst.val &amp; 0xffff0000) | al | (ah &lt;&lt; 8);

	/* Set PF, ZF, SF */
	ctxt-&gt;src.type = OP_IMM;
	ctxt-&gt;src.val = 0;
	ctxt-&gt;src.bytes = 1;
	fastop(ctxt, em_or);

	return X86EMUL_CONTINUE;
<yellow>}</yellow>

static int em_aad(struct x86_emulate_ctxt *ctxt)
{
<yellow>	u8 al = ctxt->dst.val & 0xff;</yellow>
	u8 ah = (ctxt-&gt;dst.val &gt;&gt; 8) &amp; 0xff;

	al = (al + (ah * ctxt-&gt;src.val)) &amp; 0xff;

	ctxt-&gt;dst.val = (ctxt-&gt;dst.val &amp; 0xffff0000) | al;

	/* Set PF, ZF, SF */
	ctxt-&gt;src.type = OP_IMM;
	ctxt-&gt;src.val = 0;
	ctxt-&gt;src.bytes = 1;
	fastop(ctxt, em_or);

	return X86EMUL_CONTINUE;
}

<yellow>static int em_call(struct x86_emulate_ctxt *ctxt)</yellow>
{
	int rc;
<yellow>	long rel = ctxt->src.val;</yellow>

	ctxt-&gt;src.val = (unsigned long)ctxt-&gt;_eip;
	rc = jmp_rel(ctxt, rel);
	if (rc != X86EMUL_CONTINUE)
		return rc;
<yellow>	return em_push(ctxt);</yellow>
<yellow>}</yellow>

static int em_call_far(struct x86_emulate_ctxt *ctxt)
<yellow>{</yellow>
	u16 sel, old_cs;
	ulong old_eip;
	int rc;
	struct desc_struct old_desc, new_desc;
<yellow>	const struct x86_emulate_ops *ops = ctxt->ops;</yellow>
	int cpl = ctxt-&gt;ops-&gt;cpl(ctxt);
	enum x86emul_mode prev_mode = ctxt-&gt;mode;

	old_eip = ctxt-&gt;_eip;
	ops-&gt;get_segment(ctxt, &amp;old_cs, &amp;old_desc, NULL, VCPU_SREG_CS);

	memcpy(&amp;sel, ctxt-&gt;src.valptr + ctxt-&gt;op_bytes, 2);
	rc = __load_segment_descriptor(ctxt, sel, VCPU_SREG_CS, cpl,
				       X86_TRANSFER_CALL_JMP, &amp;new_desc);
	if (rc != X86EMUL_CONTINUE)
		return rc;

<yellow>	rc = assign_eip_far(ctxt, ctxt->src.val);</yellow>
	if (rc != X86EMUL_CONTINUE)
		goto fail;

<yellow>	ctxt->src.val = old_cs;</yellow>
	rc = em_push(ctxt);
	if (rc != X86EMUL_CONTINUE)
		goto fail;

<yellow>	ctxt->src.val = old_eip;</yellow>
	rc = em_push(ctxt);
	/* If we failed, we tainted the memory, but the very least we should
	   restore cs */
	if (rc != X86EMUL_CONTINUE) {
<yellow>		pr_warn_once("faulting far call emulation tainted memory\n");</yellow>
		goto fail;
	}
	return rc;
fail:
<yellow>	ops->set_segment(ctxt, old_cs, &old_desc, 0, VCPU_SREG_CS);</yellow>
	ctxt-&gt;mode = prev_mode;
	return rc;

}

<yellow>static int em_ret_near_imm(struct x86_emulate_ctxt *ctxt)</yellow>
<yellow>{</yellow>
	int rc;
	unsigned long eip;

<yellow>	rc = emulate_pop(ctxt, &eip, ctxt->op_bytes);</yellow>
	if (rc != X86EMUL_CONTINUE)
		return rc;
<yellow>	rc = assign_eip_near(ctxt, eip);</yellow>
	if (rc != X86EMUL_CONTINUE)
		return rc;
<yellow>	rsp_increment(ctxt, ctxt->src.val);</yellow>
	return X86EMUL_CONTINUE;
}

static int em_xchg(struct x86_emulate_ctxt *ctxt)
{
	/* Write back the register source. */
<yellow>	ctxt->src.val = ctxt->dst.val;</yellow>
<yellow>	write_register_operand(&ctxt->src);</yellow>

	/* Write back the memory destination with implicit LOCK prefix. */
<yellow>	ctxt->dst.val = ctxt->src.orig_val;</yellow>
	ctxt-&gt;lock_prefix = 1;
	return X86EMUL_CONTINUE;
}

static int em_imul_3op(struct x86_emulate_ctxt *ctxt)
{
<yellow>	ctxt->dst.val = ctxt->src2.val;</yellow>
	return fastop(ctxt, em_imul);
}

static int em_cwd(struct x86_emulate_ctxt *ctxt)
{
<yellow>	ctxt->dst.type = OP_REG;</yellow>
	ctxt-&gt;dst.bytes = ctxt-&gt;src.bytes;
	ctxt-&gt;dst.addr.reg = reg_rmw(ctxt, VCPU_REGS_RDX);
<yellow>	ctxt->dst.val = ~((ctxt->src.val >> (ctxt->src.bytes * 8 - 1)) - 1);</yellow>

	return X86EMUL_CONTINUE;
}

static int em_rdpid(struct x86_emulate_ctxt *ctxt)
<yellow>{</yellow>
	u64 tsc_aux = 0;

<yellow>	if (!ctxt->ops->guest_has_rdpid(ctxt))</yellow>
<yellow>		return emulate_ud(ctxt);</yellow>

<yellow>	ctxt->ops->get_msr(ctxt, MSR_TSC_AUX, &tsc_aux);</yellow>
	ctxt-&gt;dst.val = tsc_aux;
	return X86EMUL_CONTINUE;
}

static int em_rdtsc(struct x86_emulate_ctxt *ctxt)
{
	u64 tsc = 0;

<yellow>	ctxt->ops->get_msr(ctxt, MSR_IA32_TSC, &tsc);</yellow>
	*reg_write(ctxt, VCPU_REGS_RAX) = (u32)tsc;
	*reg_write(ctxt, VCPU_REGS_RDX) = tsc &gt;&gt; 32;
	return X86EMUL_CONTINUE;
}

static int em_rdpmc(struct x86_emulate_ctxt *ctxt)
<yellow>{</yellow>
	u64 pmc;

<yellow>	if (ctxt->ops->read_pmc(ctxt, reg_read(ctxt, VCPU_REGS_RCX), &pmc))</yellow>
<yellow>		return emulate_gp(ctxt, 0);</yellow>
<yellow>	*reg_write(ctxt, VCPU_REGS_RAX) = (u32)pmc;</yellow>
	*reg_write(ctxt, VCPU_REGS_RDX) = pmc &gt;&gt; 32;
	return X86EMUL_CONTINUE;
}

static int em_mov(struct x86_emulate_ctxt *ctxt)
{
<blue>	memcpy(ctxt->dst.valptr, ctxt->src.valptr, sizeof(ctxt->src.valptr));</blue>
	return X86EMUL_CONTINUE;
}

static int em_movbe(struct x86_emulate_ctxt *ctxt)
{
	u16 tmp;

<yellow>	if (!ctxt->ops->guest_has_movbe(ctxt))</yellow>
<yellow>		return emulate_ud(ctxt);</yellow>

<yellow>	switch (ctxt->op_bytes) {</yellow>
	case 2:
		/*
		 * From MOVBE definition: &quot;...When the operand size is 16 bits,
		 * the upper word of the destination register remains unchanged
		 * ...&quot;
		 *
		 * Both casting -&gt;valptr and -&gt;val to u16 breaks strict aliasing
		 * rules so we have to do the operation almost per hand.
		 */
<yellow>		tmp = (u16)ctxt->src.val;</yellow>
		ctxt-&gt;dst.val &amp;= ~0xffffUL;
		ctxt-&gt;dst.val |= (unsigned long)swab16(tmp);
		break;
	case 4:
<yellow>		ctxt->dst.val = swab32((u32)ctxt->src.val);</yellow>
		break;
	case 8:
<yellow>		ctxt->dst.val = swab64(ctxt->src.val);</yellow>
		break;
	default:
<yellow>		BUG();</yellow>
	}
	return X86EMUL_CONTINUE;
<yellow>}</yellow>

<yellow>static int em_cr_write(struct x86_emulate_ctxt *ctxt)</yellow>
<yellow>{</yellow>
<yellow>	int cr_num = ctxt->modrm_reg;</yellow>
	int r;

	if (ctxt-&gt;ops-&gt;set_cr(ctxt, cr_num, ctxt-&gt;src.val))
<yellow>		return emulate_gp(ctxt, 0);</yellow>

	/* Disable writeback. */
<yellow>	ctxt->dst.type = OP_NONE;</yellow>

	if (cr_num == 0) {
		/*
		 * CR0 write might have updated CR0.PE and/or CR0.PG
		 * which can affect the cpu&#x27;s execution mode.
		 */
<yellow>		r = emulator_recalc_and_set_mode(ctxt);</yellow>
<yellow>		if (r != X86EMUL_CONTINUE)</yellow>
			return r;
	}

	return X86EMUL_CONTINUE;
}

static int em_dr_write(struct x86_emulate_ctxt *ctxt)
{
	unsigned long val;

<yellow>	if (ctxt->mode == X86EMUL_MODE_PROT64)</yellow>
		val = ctxt-&gt;src.val &amp; ~0ULL;
	else
<yellow>		val = ctxt->src.val & ~0U;</yellow>

	/* #UD condition is already handled. */
<yellow>	if (ctxt->ops->set_dr(ctxt, ctxt->modrm_reg, val) < 0)</yellow>
<yellow>		return emulate_gp(ctxt, 0);</yellow>

	/* Disable writeback. */
<yellow>	ctxt->dst.type = OP_NONE;</yellow>
	return X86EMUL_CONTINUE;
<yellow>}</yellow>

static int em_wrmsr(struct x86_emulate_ctxt *ctxt)
{
<yellow>	u64 msr_index = reg_read(ctxt, VCPU_REGS_RCX);</yellow>
	u64 msr_data;
	int r;

	msr_data = (u32)reg_read(ctxt, VCPU_REGS_RAX)
		| ((u64)reg_read(ctxt, VCPU_REGS_RDX) &lt;&lt; 32);
	r = ctxt-&gt;ops-&gt;set_msr_with_filter(ctxt, msr_index, msr_data);

	if (r == X86EMUL_PROPAGATE_FAULT)
<yellow>		return emulate_gp(ctxt, 0);</yellow>

	return r;
<yellow>}</yellow>

static int em_rdmsr(struct x86_emulate_ctxt *ctxt)
<yellow>{</yellow>
<yellow>	u64 msr_index = reg_read(ctxt, VCPU_REGS_RCX);</yellow>
	u64 msr_data;
	int r;

	r = ctxt-&gt;ops-&gt;get_msr_with_filter(ctxt, msr_index, &amp;msr_data);

	if (r == X86EMUL_PROPAGATE_FAULT)
<yellow>		return emulate_gp(ctxt, 0);</yellow>

<yellow>	if (r == X86EMUL_CONTINUE) {</yellow>
<yellow>		*reg_write(ctxt, VCPU_REGS_RAX) = (u32)msr_data;</yellow>
		*reg_write(ctxt, VCPU_REGS_RDX) = msr_data &gt;&gt; 32;
	}
	return r;
}

static int em_store_sreg(struct x86_emulate_ctxt *ctxt, int segment)
{
	if (segment &gt; VCPU_SREG_GS &amp;&amp;
<yellow>	    (ctxt->ops->get_cr(ctxt, 4) & X86_CR4_UMIP) &&</yellow>
<yellow>	    ctxt->ops->cpl(ctxt) > 0)</yellow>
<yellow>		return emulate_gp(ctxt, 0);</yellow>

<yellow>	ctxt->dst.val = get_segment_selector(ctxt, segment);</yellow>
	if (ctxt-&gt;dst.bytes == 4 &amp;&amp; ctxt-&gt;dst.type == OP_MEM)
<yellow>		ctxt->dst.bytes = 2;</yellow>
	return X86EMUL_CONTINUE;
}

static int em_mov_rm_sreg(struct x86_emulate_ctxt *ctxt)
<yellow>{</yellow>
<yellow>	if (ctxt->modrm_reg > VCPU_SREG_GS)</yellow>
<yellow>		return emulate_ud(ctxt);</yellow>

<yellow>	return em_store_sreg(ctxt, ctxt->modrm_reg);</yellow>
}

static int em_mov_sreg_rm(struct x86_emulate_ctxt *ctxt)
{
<yellow>	u16 sel = ctxt->src.val;</yellow>

<yellow>	if (ctxt->modrm_reg == VCPU_SREG_CS || ctxt->modrm_reg > VCPU_SREG_GS)</yellow>
<yellow>		return emulate_ud(ctxt);</yellow>

<yellow>	if (ctxt->modrm_reg == VCPU_SREG_SS)</yellow>
<yellow>		ctxt->interruptibility = KVM_X86_SHADOW_INT_MOV_SS;</yellow>

	/* Disable writeback. */
<yellow>	ctxt->dst.type = OP_NONE;</yellow>
	return load_segment_descriptor(ctxt, sel, ctxt-&gt;modrm_reg);
<yellow>}</yellow>

static int em_sldt(struct x86_emulate_ctxt *ctxt)
<yellow>{</yellow>
<yellow>	return em_store_sreg(ctxt, VCPU_SREG_LDTR);</yellow>
}

static int em_lldt(struct x86_emulate_ctxt *ctxt)
{
<yellow>	u16 sel = ctxt->src.val;</yellow>

	/* Disable writeback. */
	ctxt-&gt;dst.type = OP_NONE;
	return load_segment_descriptor(ctxt, sel, VCPU_SREG_LDTR);
}

static int em_str(struct x86_emulate_ctxt *ctxt)
<yellow>{</yellow>
<yellow>	return em_store_sreg(ctxt, VCPU_SREG_TR);</yellow>
}

static int em_ltr(struct x86_emulate_ctxt *ctxt)
{
<yellow>	u16 sel = ctxt->src.val;</yellow>

	/* Disable writeback. */
	ctxt-&gt;dst.type = OP_NONE;
	return load_segment_descriptor(ctxt, sel, VCPU_SREG_TR);
}

static int em_invlpg(struct x86_emulate_ctxt *ctxt)
{
	int rc;
	ulong linear;

<yellow>	rc = linearize(ctxt, ctxt->src.addr.mem, 1, false, &linear);</yellow>
	if (rc == X86EMUL_CONTINUE)
<yellow>		ctxt->ops->invlpg(ctxt, linear);</yellow>
	/* Disable writeback. */
<yellow>	ctxt->dst.type = OP_NONE;</yellow>
	return X86EMUL_CONTINUE;
}

static int em_clts(struct x86_emulate_ctxt *ctxt)
{
	ulong cr0;

<yellow>	cr0 = ctxt->ops->get_cr(ctxt, 0);</yellow>
	cr0 &amp;= ~X86_CR0_TS;
	ctxt-&gt;ops-&gt;set_cr(ctxt, 0, cr0);
	return X86EMUL_CONTINUE;
}

static int em_hypercall(struct x86_emulate_ctxt *ctxt)
{
<yellow>	int rc = ctxt->ops->fix_hypercall(ctxt);</yellow>

	if (rc != X86EMUL_CONTINUE)
		return rc;

	/* Let the processor re-execute the fixed hypercall */
<yellow>	ctxt->_eip = ctxt->eip;</yellow>
	/* Disable writeback. */
	ctxt-&gt;dst.type = OP_NONE;
	return X86EMUL_CONTINUE;
<yellow>}</yellow>

static int emulate_store_desc_ptr(struct x86_emulate_ctxt *ctxt,
				  void (*get)(struct x86_emulate_ctxt *ctxt,
					      struct desc_ptr *ptr))
<yellow>{</yellow>
	struct desc_ptr desc_ptr;

<yellow>	if ((ctxt->ops->get_cr(ctxt, 4) & X86_CR4_UMIP) &&</yellow>
<yellow>	    ctxt->ops->cpl(ctxt) > 0)</yellow>
<yellow>		return emulate_gp(ctxt, 0);</yellow>

<yellow>	if (ctxt->mode == X86EMUL_MODE_PROT64)</yellow>
<yellow>		ctxt->op_bytes = 8;</yellow>
<yellow>	get(ctxt, &desc_ptr);</yellow>
	if (ctxt-&gt;op_bytes == 2) {
		ctxt-&gt;op_bytes = 4;
<yellow>		desc_ptr.address &= 0x00ffffff;</yellow>
	}
	/* Disable writeback. */
<yellow>	ctxt->dst.type = OP_NONE;</yellow>
	return segmented_write_std(ctxt, ctxt-&gt;dst.addr.mem,
<yellow>				   &desc_ptr, 2 + ctxt->op_bytes);</yellow>
}

static int em_sgdt(struct x86_emulate_ctxt *ctxt)
{
<yellow>	return emulate_store_desc_ptr(ctxt, ctxt->ops->get_gdt);</yellow>
}

static int em_sidt(struct x86_emulate_ctxt *ctxt)
{
<yellow>	return emulate_store_desc_ptr(ctxt, ctxt->ops->get_idt);</yellow>
}

static int em_lgdt_lidt(struct x86_emulate_ctxt *ctxt, bool lgdt)
<yellow>{</yellow>
	struct desc_ptr desc_ptr;
	int rc;

<yellow>	if (ctxt->mode == X86EMUL_MODE_PROT64)</yellow>
<yellow>		ctxt->op_bytes = 8;</yellow>
<yellow>	rc = read_descriptor(ctxt, ctxt->src.addr.mem,</yellow>
			     &amp;desc_ptr.size, &amp;desc_ptr.address,
<yellow>			     ctxt->op_bytes);</yellow>
	if (rc != X86EMUL_CONTINUE)
		return rc;
<yellow>	if (ctxt->mode == X86EMUL_MODE_PROT64 &&</yellow>
<yellow>	    emul_is_noncanonical_address(desc_ptr.address, ctxt))</yellow>
<yellow>		return emulate_gp(ctxt, 0);</yellow>
<yellow>	if (lgdt)</yellow>
<yellow>		ctxt->ops->set_gdt(ctxt, &desc_ptr);</yellow>
	else
<yellow>		ctxt->ops->set_idt(ctxt, &desc_ptr);</yellow>
	/* Disable writeback. */
<yellow>	ctxt->dst.type = OP_NONE;</yellow>
	return X86EMUL_CONTINUE;
}

static int em_lgdt(struct x86_emulate_ctxt *ctxt)
{
<yellow>	return em_lgdt_lidt(ctxt, true);</yellow>
}

static int em_lidt(struct x86_emulate_ctxt *ctxt)
{
<yellow>	return em_lgdt_lidt(ctxt, false);</yellow>
}

static int em_smsw(struct x86_emulate_ctxt *ctxt)
{
<yellow>	if ((ctxt->ops->get_cr(ctxt, 4) & X86_CR4_UMIP) &&</yellow>
<yellow>	    ctxt->ops->cpl(ctxt) > 0)</yellow>
<yellow>		return emulate_gp(ctxt, 0);</yellow>

<yellow>	if (ctxt->dst.type == OP_MEM)</yellow>
<yellow>		ctxt->dst.bytes = 2;</yellow>
<yellow>	ctxt->dst.val = ctxt->ops->get_cr(ctxt, 0);</yellow>
	return X86EMUL_CONTINUE;
<yellow>}</yellow>

static int em_lmsw(struct x86_emulate_ctxt *ctxt)
{
<yellow>	ctxt->ops->set_cr(ctxt, 0, (ctxt->ops->get_cr(ctxt, 0) & ~0x0eul)</yellow>
			  | (ctxt-&gt;src.val &amp; 0x0f));
	ctxt-&gt;dst.type = OP_NONE;
	return X86EMUL_CONTINUE;
}

<yellow>static int em_loop(struct x86_emulate_ctxt *ctxt)</yellow>
{
	int rc = X86EMUL_CONTINUE;

<yellow>	register_address_increment(ctxt, VCPU_REGS_RCX, -1);</yellow>
<yellow>	if ((address_mask(ctxt, reg_read(ctxt, VCPU_REGS_RCX)) != 0) &&</yellow>
<yellow>	    (ctxt->b == 0xe2 || test_cc(ctxt->b ^ 0x5, ctxt->eflags)))</yellow>
<yellow>		rc = jmp_rel(ctxt, ctxt->src.val);</yellow>

	return rc;
<yellow>}</yellow>

<yellow>static int em_jcxz(struct x86_emulate_ctxt *ctxt)</yellow>
{
	int rc = X86EMUL_CONTINUE;

<yellow>	if (address_mask(ctxt, reg_read(ctxt, VCPU_REGS_RCX)) == 0)</yellow>
<yellow>		rc = jmp_rel(ctxt, ctxt->src.val);</yellow>

	return rc;
<yellow>}</yellow>

static int em_in(struct x86_emulate_ctxt *ctxt)
{
<blue>	if (!pio_in_emulated(ctxt, ctxt->dst.bytes, ctxt->src.val,</blue>
			     &amp;ctxt-&gt;dst.val))
		return X86EMUL_IO_NEEDED;

<blue>	return X86EMUL_CONTINUE;</blue>
}

static int em_out(struct x86_emulate_ctxt *ctxt)
{
<yellow>	ctxt->ops->pio_out_emulated(ctxt, ctxt->src.bytes, ctxt->dst.val,</yellow>
				    &amp;ctxt-&gt;src.val, 1);
	/* Disable writeback. */
	ctxt-&gt;dst.type = OP_NONE;
	return X86EMUL_CONTINUE;
}

static int em_cli(struct x86_emulate_ctxt *ctxt)
{
<yellow>	if (emulator_bad_iopl(ctxt))</yellow>
<yellow>		return emulate_gp(ctxt, 0);</yellow>

<yellow>	ctxt->eflags &= ~X86_EFLAGS_IF;</yellow>
	return X86EMUL_CONTINUE;
<yellow>}</yellow>

static int em_sti(struct x86_emulate_ctxt *ctxt)
{
<yellow>	if (emulator_bad_iopl(ctxt))</yellow>
<yellow>		return emulate_gp(ctxt, 0);</yellow>

<yellow>	ctxt->interruptibility = KVM_X86_SHADOW_INT_STI;</yellow>
	ctxt-&gt;eflags |= X86_EFLAGS_IF;
	return X86EMUL_CONTINUE;
<yellow>}</yellow>

static int em_cpuid(struct x86_emulate_ctxt *ctxt)
<yellow>{</yellow>
	u32 eax, ebx, ecx, edx;
	u64 msr = 0;

<yellow>	ctxt->ops->get_msr(ctxt, MSR_MISC_FEATURES_ENABLES, &msr);</yellow>
	if (msr &amp; MSR_MISC_FEATURES_ENABLES_CPUID_FAULT &amp;&amp;
<yellow>	    ctxt->ops->cpl(ctxt)) {</yellow>
<yellow>		return emulate_gp(ctxt, 0);</yellow>
	}

<yellow>	eax = reg_read(ctxt, VCPU_REGS_RAX);</yellow>
	ecx = reg_read(ctxt, VCPU_REGS_RCX);
	ctxt-&gt;ops-&gt;get_cpuid(ctxt, &amp;eax, &amp;ebx, &amp;ecx, &amp;edx, false);
	*reg_write(ctxt, VCPU_REGS_RAX) = eax;
	*reg_write(ctxt, VCPU_REGS_RBX) = ebx;
	*reg_write(ctxt, VCPU_REGS_RCX) = ecx;
	*reg_write(ctxt, VCPU_REGS_RDX) = edx;
	return X86EMUL_CONTINUE;
}

static int em_sahf(struct x86_emulate_ctxt *ctxt)
{
	u32 flags;

	flags = X86_EFLAGS_CF | X86_EFLAGS_PF | X86_EFLAGS_AF | X86_EFLAGS_ZF |
		X86_EFLAGS_SF;
<yellow>	flags &= *reg_rmw(ctxt, VCPU_REGS_RAX) >> 8;</yellow>

	ctxt-&gt;eflags &amp;= ~0xffUL;
	ctxt-&gt;eflags |= flags | X86_EFLAGS_FIXED;
	return X86EMUL_CONTINUE;
}

static int em_lahf(struct x86_emulate_ctxt *ctxt)
{
<yellow>	*reg_rmw(ctxt, VCPU_REGS_RAX) &= ~0xff00UL;</yellow>
	*reg_rmw(ctxt, VCPU_REGS_RAX) |= (ctxt-&gt;eflags &amp; 0xff) &lt;&lt; 8;
	return X86EMUL_CONTINUE;
}

static int em_bswap(struct x86_emulate_ctxt *ctxt)
{
<yellow>	switch (ctxt->op_bytes) {</yellow>
#ifdef CONFIG_X86_64
	case 8:
<yellow>		asm("bswap %0" : "+r"(ctxt->dst.val));</yellow>
		break;
#endif
	default:
<yellow>		asm("bswap %0" : "+r"(*(u32 *)&ctxt->dst.val));</yellow>
		break;
	}
	return X86EMUL_CONTINUE;
<yellow>}</yellow>

static int em_clflush(struct x86_emulate_ctxt *ctxt)
{
	/* emulating clflush regardless of cpuid */
	return X86EMUL_CONTINUE;
<yellow>}</yellow>

static int em_clflushopt(struct x86_emulate_ctxt *ctxt)
{
	/* emulating clflushopt regardless of cpuid */
	return X86EMUL_CONTINUE;
}

static int em_movsxd(struct x86_emulate_ctxt *ctxt)
{
<yellow>	ctxt->dst.val = (s32) ctxt->src.val;</yellow>
	return X86EMUL_CONTINUE;
}

static int check_fxsr(struct x86_emulate_ctxt *ctxt)
{
<yellow>	if (!ctxt->ops->guest_has_fxsr(ctxt))</yellow>
<yellow>		return emulate_ud(ctxt);</yellow>

<yellow>	if (ctxt->ops->get_cr(ctxt, 0) & (X86_CR0_TS | X86_CR0_EM))</yellow>
<yellow>		return emulate_nm(ctxt);</yellow>

	/*
	 * Don&#x27;t emulate a case that should never be hit, instead of working
	 * around a lack of fxsave64/fxrstor64 on old compilers.
	 */
<yellow>	if (ctxt->mode >= X86EMUL_MODE_PROT64)</yellow>
		return X86EMUL_UNHANDLEABLE;

	return X86EMUL_CONTINUE;
<yellow>}</yellow>

/*
 * Hardware doesn&#x27;t save and restore XMM 0-7 without CR4.OSFXSR, but does save
 * and restore MXCSR.
 */
static size_t __fxstate_size(int nregs)
{
	return offsetof(struct fxregs_state, xmm_space[0]) + nregs * 16;
}

static inline size_t fxstate_size(struct x86_emulate_ctxt *ctxt)
{
	bool cr4_osfxsr;
<yellow>	if (ctxt->mode == X86EMUL_MODE_PROT64)</yellow>
		return __fxstate_size(16);

<yellow>	cr4_osfxsr = ctxt->ops->get_cr(ctxt, 4) & X86_CR4_OSFXSR;</yellow>
	return __fxstate_size(cr4_osfxsr ? 8 : 0);
}

/*
 * FXSAVE and FXRSTOR have 4 different formats depending on execution mode,
 *  1) 16 bit mode
 *  2) 32 bit mode
 *     - like (1), but FIP and FDP (foo) are only 16 bit.  At least Intel CPUs
 *       preserve whole 32 bit values, though, so (1) and (2) are the same wrt.
 *       save and restore
 *  3) 64-bit mode with REX.W prefix
 *     - like (2), but XMM 8-15 are being saved and restored
 *  4) 64-bit mode without REX.W prefix
 *     - like (3), but FIP and FDP are 64 bit
 *
 * Emulation uses (3) for (1) and (2) and preserves XMM 8-15 to reach the
 * desired result.  (4) is not emulated.
 *
 * Note: Guest and host CPUID.(EAX=07H,ECX=0H):EBX[bit 13] (deprecate FPU CS
 * and FPU DS) should match.
 */
<yellow>static int em_fxsave(struct x86_emulate_ctxt *ctxt)</yellow>
{
	struct fxregs_state fx_state;
	int rc;

<yellow>	rc = check_fxsr(ctxt);</yellow>
<yellow>	if (rc != X86EMUL_CONTINUE)</yellow>
		return rc;

<yellow>	kvm_fpu_get();</yellow>

<yellow>	rc = asm_safe("fxsave %[fx]", , [fx] "+m"(fx_state));</yellow>

<yellow>	kvm_fpu_put();</yellow>

	if (rc != X86EMUL_CONTINUE)
		return rc;

<yellow>	return segmented_write_std(ctxt, ctxt->memop.addr.mem, &fx_state,</yellow>
<yellow>		                   fxstate_size(ctxt));</yellow>
<yellow>}</yellow>

/*
 * FXRSTOR might restore XMM registers not provided by the guest. Fill
 * in the host registers (via FXSAVE) instead, so they won&#x27;t be modified.
 * (preemption has to stay disabled until FXRSTOR).
 *
 * Use noinline to keep the stack for other functions called by callers small.
 */
static noinline int fxregs_fixup(struct fxregs_state *fx_state,
				 const size_t used_size)
{
	struct fxregs_state fx_tmp;
	int rc;

<yellow>	rc = asm_safe("fxsave %[fx]", , [fx] "+m"(fx_tmp));</yellow>
	memcpy((void *)fx_state + used_size, (void *)&amp;fx_tmp + used_size,
	       __fxstate_size(16) - used_size);

	return rc;
}

<yellow>static int em_fxrstor(struct x86_emulate_ctxt *ctxt)</yellow>
{
	struct fxregs_state fx_state;
	int rc;
	size_t size;

<yellow>	rc = check_fxsr(ctxt);</yellow>
<yellow>	if (rc != X86EMUL_CONTINUE)</yellow>
		return rc;

<yellow>	size = fxstate_size(ctxt);</yellow>
<yellow>	rc = segmented_read_std(ctxt, ctxt->memop.addr.mem, &fx_state, size);</yellow>
	if (rc != X86EMUL_CONTINUE)
		return rc;

<yellow>	kvm_fpu_get();</yellow>

<yellow>	if (size < __fxstate_size(16)) {</yellow>
<yellow>		rc = fxregs_fixup(&fx_state, size);</yellow>
		if (rc != X86EMUL_CONTINUE)
			goto out;
	}

<yellow>	if (fx_state.mxcsr >> 16) {</yellow>
<yellow>		rc = emulate_gp(ctxt, 0);</yellow>
		goto out;
	}

	if (rc == X86EMUL_CONTINUE)
<yellow>		rc = asm_safe("fxrstor %[fx]", : [fx] "m"(fx_state));</yellow>

out:
<yellow>	kvm_fpu_put();</yellow>

	return rc;
<yellow>}</yellow>

<yellow>static int em_xsetbv(struct x86_emulate_ctxt *ctxt)</yellow>
{
	u32 eax, ecx, edx;

<yellow>	if (!(ctxt->ops->get_cr(ctxt, 4) & X86_CR4_OSXSAVE))</yellow>
<yellow>		return emulate_ud(ctxt);</yellow>

<yellow>	eax = reg_read(ctxt, VCPU_REGS_RAX);</yellow>
	edx = reg_read(ctxt, VCPU_REGS_RDX);
	ecx = reg_read(ctxt, VCPU_REGS_RCX);

	if (ctxt-&gt;ops-&gt;set_xcr(ctxt, ecx, ((u64)edx &lt;&lt; 32) | eax))
<yellow>		return emulate_gp(ctxt, 0);</yellow>

	return X86EMUL_CONTINUE;
<yellow>}</yellow>

static bool valid_cr(int nr)
{
	switch (nr) {
	case 0:
	case 2 ... 4:
	case 8:
		return true;
	default:
		return false;
	}
}

static int check_cr_access(struct x86_emulate_ctxt *ctxt)
{
<yellow>	if (!valid_cr(ctxt->modrm_reg))</yellow>
<yellow>		return emulate_ud(ctxt);</yellow>

	return X86EMUL_CONTINUE;
<yellow>}</yellow>

static int check_dr7_gd(struct x86_emulate_ctxt *ctxt)
{
	unsigned long dr7;

<yellow>	ctxt->ops->get_dr(ctxt, 7, &dr7);</yellow>

	return dr7 &amp; DR7_GD;
}

static int check_dr_read(struct x86_emulate_ctxt *ctxt)
<yellow>{</yellow>
<yellow>	int dr = ctxt->modrm_reg;</yellow>
	u64 cr4;

	if (dr &gt; 7)
<yellow>		return emulate_ud(ctxt);</yellow>

<yellow>	cr4 = ctxt->ops->get_cr(ctxt, 4);</yellow>
<yellow>	if ((cr4 & X86_CR4_DE) && (dr == 4 || dr == 5))</yellow>
		return emulate_ud(ctxt);

<yellow>	if (check_dr7_gd(ctxt)) {</yellow>
		ulong dr6;

<yellow>		ctxt->ops->get_dr(ctxt, 6, &dr6);</yellow>
		dr6 &amp;= ~DR_TRAP_BITS;
		dr6 |= DR6_BD | DR6_ACTIVE_LOW;
		ctxt-&gt;ops-&gt;set_dr(ctxt, 6, dr6);
		return emulate_db(ctxt);
	}

	return X86EMUL_CONTINUE;
}

static int check_dr_write(struct x86_emulate_ctxt *ctxt)
{
<yellow>	u64 new_val = ctxt->src.val64;</yellow>
	int dr = ctxt-&gt;modrm_reg;

<yellow>	if ((dr == 6 || dr == 7) && (new_val & 0xffffffff00000000ULL))</yellow>
<yellow>		return emulate_gp(ctxt, 0);</yellow>

<yellow>	return check_dr_read(ctxt);</yellow>
<yellow>}</yellow>

static int check_svme(struct x86_emulate_ctxt *ctxt)
<yellow>{</yellow>
	u64 efer = 0;

<yellow>	ctxt->ops->get_msr(ctxt, MSR_EFER, &efer);</yellow>

<yellow>	if (!(efer & EFER_SVME))</yellow>
<yellow>		return emulate_ud(ctxt);</yellow>

	return X86EMUL_CONTINUE;
}

static int check_svme_pa(struct x86_emulate_ctxt *ctxt)
<yellow>{</yellow>
<yellow>	u64 rax = reg_read(ctxt, VCPU_REGS_RAX);</yellow>

	/* Valid physical address? */
	if (rax &amp; 0xffff000000000000ULL)
<yellow>		return emulate_gp(ctxt, 0);</yellow>

<yellow>	return check_svme(ctxt);</yellow>
}

<yellow>static int check_rdtsc(struct x86_emulate_ctxt *ctxt)</yellow>
{
<yellow>	u64 cr4 = ctxt->ops->get_cr(ctxt, 4);</yellow>

<yellow>	if (cr4 & X86_CR4_TSD && ctxt->ops->cpl(ctxt))</yellow>
<yellow>		return emulate_gp(ctxt, 0);</yellow>

<yellow>	return X86EMUL_CONTINUE;</yellow>
<yellow>}</yellow>

static int check_rdpmc(struct x86_emulate_ctxt *ctxt)
{
<yellow>	u64 cr4 = ctxt->ops->get_cr(ctxt, 4);</yellow>
	u64 rcx = reg_read(ctxt, VCPU_REGS_RCX);

	/*
	 * VMware allows access to these Pseduo-PMCs even when read via RDPMC
	 * in Ring3 when CR4.PCE=0.
	 */
<yellow>	if (enable_vmware_backdoor && is_vmware_backdoor_pmc(rcx))</yellow>
		return X86EMUL_CONTINUE;

	/*
	 * If CR4.PCE is set, the SDM requires CPL=0 or CR0.PE=0.  The CR0.PE
	 * check however is unnecessary because CPL is always 0 outside
	 * protected mode.
	 */
<yellow>	if ((!(cr4 & X86_CR4_PCE) && ctxt->ops->cpl(ctxt)) ||</yellow>
<yellow>	    ctxt->ops->check_pmc(ctxt, rcx))</yellow>
<yellow>		return emulate_gp(ctxt, 0);</yellow>

	return X86EMUL_CONTINUE;
<yellow>}</yellow>

static int check_perm_in(struct x86_emulate_ctxt *ctxt)
{
<blue>	ctxt->dst.bytes = min(ctxt->dst.bytes, 4u);</blue>
<blue>	if (!emulator_io_permited(ctxt, ctxt->src.val, ctxt->dst.bytes))</blue>
<yellow>		return emulate_gp(ctxt, 0);</yellow>

	return X86EMUL_CONTINUE;
<blue>}</blue>

static int check_perm_out(struct x86_emulate_ctxt *ctxt)
{
<yellow>	ctxt->src.bytes = min(ctxt->src.bytes, 4u);</yellow>
<yellow>	if (!emulator_io_permited(ctxt, ctxt->dst.val, ctxt->src.bytes))</yellow>
<yellow>		return emulate_gp(ctxt, 0);</yellow>

	return X86EMUL_CONTINUE;
<yellow>}</yellow>

#define D(_y) { .flags = (_y) }
#define DI(_y, _i) { .flags = (_y)|Intercept, .intercept = x86_intercept_##_i }
#define DIP(_y, _i, _p) { .flags = (_y)|Intercept|CheckPerm, \
		      .intercept = x86_intercept_##_i, .check_perm = (_p) }
#define N    D(NotImpl)
#define EXT(_f, _e) { .flags = ((_f) | RMExt), .u.group = (_e) }
#define G(_f, _g) { .flags = ((_f) | Group | ModRM), .u.group = (_g) }
#define GD(_f, _g) { .flags = ((_f) | GroupDual | ModRM), .u.gdual = (_g) }
#define ID(_f, _i) { .flags = ((_f) | InstrDual | ModRM), .u.idual = (_i) }
#define MD(_f, _m) { .flags = ((_f) | ModeDual), .u.mdual = (_m) }
#define E(_f, _e) { .flags = ((_f) | Escape | ModRM), .u.esc = (_e) }
#define I(_f, _e) { .flags = (_f), .u.execute = (_e) }
#define F(_f, _e) { .flags = (_f) | Fastop, .u.fastop = (_e) }
#define II(_f, _e, _i) \
	{ .flags = (_f)|Intercept, .u.execute = (_e), .intercept = x86_intercept_##_i }
#define IIP(_f, _e, _i, _p) \
	{ .flags = (_f)|Intercept|CheckPerm, .u.execute = (_e), \
	  .intercept = x86_intercept_##_i, .check_perm = (_p) }
#define GP(_f, _g) { .flags = ((_f) | Prefix), .u.gprefix = (_g) }

#define D2bv(_f)      D((_f) | ByteOp), D(_f)
#define D2bvIP(_f, _i, _p) DIP((_f) | ByteOp, _i, _p), DIP(_f, _i, _p)
#define I2bv(_f, _e)  I((_f) | ByteOp, _e), I(_f, _e)
#define F2bv(_f, _e)  F((_f) | ByteOp, _e), F(_f, _e)
#define I2bvIP(_f, _e, _i, _p) \
	IIP((_f) | ByteOp, _e, _i, _p), IIP(_f, _e, _i, _p)

#define F6ALU(_f, _e) F2bv((_f) | DstMem | SrcReg | ModRM, _e),		\
		F2bv(((_f) | DstReg | SrcMem | ModRM) &amp; ~Lock, _e),	\
		F2bv(((_f) &amp; ~Lock) | DstAcc | SrcImm, _e)

static const struct opcode group7_rm0[] = {
	N,
	I(SrcNone | Priv | EmulateOnUD,	em_hypercall),
	N, N, N, N, N, N,
};

static const struct opcode group7_rm1[] = {
	DI(SrcNone | Priv, monitor),
	DI(SrcNone | Priv, mwait),
	N, N, N, N, N, N,
};

static const struct opcode group7_rm2[] = {
	N,
	II(ImplicitOps | Priv,			em_xsetbv,	xsetbv),
	N, N, N, N, N, N,
};

static const struct opcode group7_rm3[] = {
	DIP(SrcNone | Prot | Priv,		vmrun,		check_svme_pa),
	II(SrcNone  | Prot | EmulateOnUD,	em_hypercall,	vmmcall),
	DIP(SrcNone | Prot | Priv,		vmload,		check_svme_pa),
	DIP(SrcNone | Prot | Priv,		vmsave,		check_svme_pa),
	DIP(SrcNone | Prot | Priv,		stgi,		check_svme),
	DIP(SrcNone | Prot | Priv,		clgi,		check_svme),
	DIP(SrcNone | Prot | Priv,		skinit,		check_svme),
	DIP(SrcNone | Prot | Priv,		invlpga,	check_svme),
};

static const struct opcode group7_rm7[] = {
	N,
	DIP(SrcNone, rdtscp, check_rdtsc),
	N, N, N, N, N, N,
};

static const struct opcode group1[] = {
	F(Lock, em_add),
	F(Lock | PageTable, em_or),
	F(Lock, em_adc),
	F(Lock, em_sbb),
	F(Lock | PageTable, em_and),
	F(Lock, em_sub),
	F(Lock, em_xor),
	F(NoWrite, em_cmp),
};

static const struct opcode group1A[] = {
	I(DstMem | SrcNone | Mov | Stack | IncSP | TwoMemOp, em_pop), N, N, N, N, N, N, N,
};

static const struct opcode group2[] = {
	F(DstMem | ModRM, em_rol),
	F(DstMem | ModRM, em_ror),
	F(DstMem | ModRM, em_rcl),
	F(DstMem | ModRM, em_rcr),
	F(DstMem | ModRM, em_shl),
	F(DstMem | ModRM, em_shr),
	F(DstMem | ModRM, em_shl),
	F(DstMem | ModRM, em_sar),
};

static const struct opcode group3[] = {
	F(DstMem | SrcImm | NoWrite, em_test),
	F(DstMem | SrcImm | NoWrite, em_test),
	F(DstMem | SrcNone | Lock, em_not),
	F(DstMem | SrcNone | Lock, em_neg),
	F(DstXacc | Src2Mem, em_mul_ex),
	F(DstXacc | Src2Mem, em_imul_ex),
	F(DstXacc | Src2Mem, em_div_ex),
	F(DstXacc | Src2Mem, em_idiv_ex),
};

static const struct opcode group4[] = {
	F(ByteOp | DstMem | SrcNone | Lock, em_inc),
	F(ByteOp | DstMem | SrcNone | Lock, em_dec),
	N, N, N, N, N, N,
};

static const struct opcode group5[] = {
	F(DstMem | SrcNone | Lock,		em_inc),
	F(DstMem | SrcNone | Lock,		em_dec),
	I(SrcMem | NearBranch | IsBranch,       em_call_near_abs),
	I(SrcMemFAddr | ImplicitOps | IsBranch, em_call_far),
	I(SrcMem | NearBranch | IsBranch,       em_jmp_abs),
	I(SrcMemFAddr | ImplicitOps | IsBranch, em_jmp_far),
	I(SrcMem | Stack | TwoMemOp,		em_push), D(Undefined),
};

static const struct opcode group6[] = {
	II(Prot | DstMem,	   em_sldt, sldt),
	II(Prot | DstMem,	   em_str, str),
	II(Prot | Priv | SrcMem16, em_lldt, lldt),
	II(Prot | Priv | SrcMem16, em_ltr, ltr),
	N, N, N, N,
};

static const struct group_dual group7 = { {
	II(Mov | DstMem,			em_sgdt, sgdt),
	II(Mov | DstMem,			em_sidt, sidt),
	II(SrcMem | Priv,			em_lgdt, lgdt),
	II(SrcMem | Priv,			em_lidt, lidt),
	II(SrcNone | DstMem | Mov,		em_smsw, smsw), N,
	II(SrcMem16 | Mov | Priv,		em_lmsw, lmsw),
	II(SrcMem | ByteOp | Priv | NoAccess,	em_invlpg, invlpg),
}, {
	EXT(0, group7_rm0),
	EXT(0, group7_rm1),
	EXT(0, group7_rm2),
	EXT(0, group7_rm3),
	II(SrcNone | DstMem | Mov,		em_smsw, smsw), N,
	II(SrcMem16 | Mov | Priv,		em_lmsw, lmsw),
	EXT(0, group7_rm7),
} };

static const struct opcode group8[] = {
	N, N, N, N,
	F(DstMem | SrcImmByte | NoWrite,		em_bt),
	F(DstMem | SrcImmByte | Lock | PageTable,	em_bts),
	F(DstMem | SrcImmByte | Lock,			em_btr),
	F(DstMem | SrcImmByte | Lock | PageTable,	em_btc),
};

/*
 * The &quot;memory&quot; destination is actually always a register, since we come
 * from the register case of group9.
 */
static const struct gprefix pfx_0f_c7_7 = {
	N, N, N, II(DstMem | ModRM | Op3264 | EmulateOnUD, em_rdpid, rdpid),
};


static const struct group_dual group9 = { {
	N, I(DstMem64 | Lock | PageTable, em_cmpxchg8b), N, N, N, N, N, N,
}, {
	N, N, N, N, N, N, N,
	GP(0, &amp;pfx_0f_c7_7),
} };

static const struct opcode group11[] = {
	I(DstMem | SrcImm | Mov | PageTable, em_mov),
	X7(D(Undefined)),
};

static const struct gprefix pfx_0f_ae_7 = {
	I(SrcMem | ByteOp, em_clflush), I(SrcMem | ByteOp, em_clflushopt), N, N,
};

static const struct group_dual group15 = { {
	I(ModRM | Aligned16, em_fxsave),
	I(ModRM | Aligned16, em_fxrstor),
	N, N, N, N, N, GP(0, &amp;pfx_0f_ae_7),
}, {
	N, N, N, N, N, N, N, N,
} };

static const struct gprefix pfx_0f_6f_0f_7f = {
	I(Mmx, em_mov), I(Sse | Aligned, em_mov), N, I(Sse | Unaligned, em_mov),
};

static const struct instr_dual instr_dual_0f_2b = {
	I(0, em_mov), N
};

static const struct gprefix pfx_0f_2b = {
	ID(0, &amp;instr_dual_0f_2b), ID(0, &amp;instr_dual_0f_2b), N, N,
};

static const struct gprefix pfx_0f_10_0f_11 = {
	I(Unaligned, em_mov), I(Unaligned, em_mov), N, N,
};

static const struct gprefix pfx_0f_28_0f_29 = {
	I(Aligned, em_mov), I(Aligned, em_mov), N, N,
};

static const struct gprefix pfx_0f_e7 = {
	N, I(Sse, em_mov), N, N,
};

static const struct escape escape_d9 = { {
	N, N, N, N, N, N, N, I(DstMem16 | Mov, em_fnstcw),
}, {
	/* 0xC0 - 0xC7 */
	N, N, N, N, N, N, N, N,
	/* 0xC8 - 0xCF */
	N, N, N, N, N, N, N, N,
	/* 0xD0 - 0xC7 */
	N, N, N, N, N, N, N, N,
	/* 0xD8 - 0xDF */
	N, N, N, N, N, N, N, N,
	/* 0xE0 - 0xE7 */
	N, N, N, N, N, N, N, N,
	/* 0xE8 - 0xEF */
	N, N, N, N, N, N, N, N,
	/* 0xF0 - 0xF7 */
	N, N, N, N, N, N, N, N,
	/* 0xF8 - 0xFF */
	N, N, N, N, N, N, N, N,
} };

static const struct escape escape_db = { {
	N, N, N, N, N, N, N, N,
}, {
	/* 0xC0 - 0xC7 */
	N, N, N, N, N, N, N, N,
	/* 0xC8 - 0xCF */
	N, N, N, N, N, N, N, N,
	/* 0xD0 - 0xC7 */
	N, N, N, N, N, N, N, N,
	/* 0xD8 - 0xDF */
	N, N, N, N, N, N, N, N,
	/* 0xE0 - 0xE7 */
	N, N, N, I(ImplicitOps, em_fninit), N, N, N, N,
	/* 0xE8 - 0xEF */
	N, N, N, N, N, N, N, N,
	/* 0xF0 - 0xF7 */
	N, N, N, N, N, N, N, N,
	/* 0xF8 - 0xFF */
	N, N, N, N, N, N, N, N,
} };

static const struct escape escape_dd = { {
	N, N, N, N, N, N, N, I(DstMem16 | Mov, em_fnstsw),
}, {
	/* 0xC0 - 0xC7 */
	N, N, N, N, N, N, N, N,
	/* 0xC8 - 0xCF */
	N, N, N, N, N, N, N, N,
	/* 0xD0 - 0xC7 */
	N, N, N, N, N, N, N, N,
	/* 0xD8 - 0xDF */
	N, N, N, N, N, N, N, N,
	/* 0xE0 - 0xE7 */
	N, N, N, N, N, N, N, N,
	/* 0xE8 - 0xEF */
	N, N, N, N, N, N, N, N,
	/* 0xF0 - 0xF7 */
	N, N, N, N, N, N, N, N,
	/* 0xF8 - 0xFF */
	N, N, N, N, N, N, N, N,
} };

static const struct instr_dual instr_dual_0f_c3 = {
	I(DstMem | SrcReg | ModRM | No16 | Mov, em_mov), N
};

static const struct mode_dual mode_dual_63 = {
	N, I(DstReg | SrcMem32 | ModRM | Mov, em_movsxd)
};

static const struct instr_dual instr_dual_8d = {
	D(DstReg | SrcMem | ModRM | NoAccess), N
};

static const struct opcode opcode_table[256] = {
	/* 0x00 - 0x07 */
	F6ALU(Lock, em_add),
	I(ImplicitOps | Stack | No64 | Src2ES, em_push_sreg),
	I(ImplicitOps | Stack | No64 | Src2ES, em_pop_sreg),
	/* 0x08 - 0x0F */
	F6ALU(Lock | PageTable, em_or),
	I(ImplicitOps | Stack | No64 | Src2CS, em_push_sreg),
	N,
	/* 0x10 - 0x17 */
	F6ALU(Lock, em_adc),
	I(ImplicitOps | Stack | No64 | Src2SS, em_push_sreg),
	I(ImplicitOps | Stack | No64 | Src2SS, em_pop_sreg),
	/* 0x18 - 0x1F */
	F6ALU(Lock, em_sbb),
	I(ImplicitOps | Stack | No64 | Src2DS, em_push_sreg),
	I(ImplicitOps | Stack | No64 | Src2DS, em_pop_sreg),
	/* 0x20 - 0x27 */
	F6ALU(Lock | PageTable, em_and), N, N,
	/* 0x28 - 0x2F */
	F6ALU(Lock, em_sub), N, I(ByteOp | DstAcc | No64, em_das),
	/* 0x30 - 0x37 */
	F6ALU(Lock, em_xor), N, N,
	/* 0x38 - 0x3F */
	F6ALU(NoWrite, em_cmp), N, N,
	/* 0x40 - 0x4F */
	X8(F(DstReg, em_inc)), X8(F(DstReg, em_dec)),
	/* 0x50 - 0x57 */
	X8(I(SrcReg | Stack, em_push)),
	/* 0x58 - 0x5F */
	X8(I(DstReg | Stack, em_pop)),
	/* 0x60 - 0x67 */
	I(ImplicitOps | Stack | No64, em_pusha),
	I(ImplicitOps | Stack | No64, em_popa),
	N, MD(ModRM, &amp;mode_dual_63),
	N, N, N, N,
	/* 0x68 - 0x6F */
	I(SrcImm | Mov | Stack, em_push),
	I(DstReg | SrcMem | ModRM | Src2Imm, em_imul_3op),
	I(SrcImmByte | Mov | Stack, em_push),
	I(DstReg | SrcMem | ModRM | Src2ImmByte, em_imul_3op),
	I2bvIP(DstDI | SrcDX | Mov | String | Unaligned, em_in, ins, check_perm_in), /* insb, insw/insd */
	I2bvIP(SrcSI | DstDX | String, em_out, outs, check_perm_out), /* outsb, outsw/outsd */
	/* 0x70 - 0x7F */
	X16(D(SrcImmByte | NearBranch | IsBranch)),
	/* 0x80 - 0x87 */
	G(ByteOp | DstMem | SrcImm, group1),
	G(DstMem | SrcImm, group1),
	G(ByteOp | DstMem | SrcImm | No64, group1),
	G(DstMem | SrcImmByte, group1),
	F2bv(DstMem | SrcReg | ModRM | NoWrite, em_test),
	I2bv(DstMem | SrcReg | ModRM | Lock | PageTable, em_xchg),
	/* 0x88 - 0x8F */
	I2bv(DstMem | SrcReg | ModRM | Mov | PageTable, em_mov),
	I2bv(DstReg | SrcMem | ModRM | Mov, em_mov),
	I(DstMem | SrcNone | ModRM | Mov | PageTable, em_mov_rm_sreg),
	ID(0, &amp;instr_dual_8d),
	I(ImplicitOps | SrcMem16 | ModRM, em_mov_sreg_rm),
	G(0, group1A),
	/* 0x90 - 0x97 */
	DI(SrcAcc | DstReg, pause), X7(D(SrcAcc | DstReg)),
	/* 0x98 - 0x9F */
	D(DstAcc | SrcNone), I(ImplicitOps | SrcAcc, em_cwd),
	I(SrcImmFAddr | No64 | IsBranch, em_call_far), N,
	II(ImplicitOps | Stack, em_pushf, pushf),
	II(ImplicitOps | Stack, em_popf, popf),
	I(ImplicitOps, em_sahf), I(ImplicitOps, em_lahf),
	/* 0xA0 - 0xA7 */
	I2bv(DstAcc | SrcMem | Mov | MemAbs, em_mov),
	I2bv(DstMem | SrcAcc | Mov | MemAbs | PageTable, em_mov),
	I2bv(SrcSI | DstDI | Mov | String | TwoMemOp, em_mov),
	F2bv(SrcSI | DstDI | String | NoWrite | TwoMemOp, em_cmp_r),
	/* 0xA8 - 0xAF */
	F2bv(DstAcc | SrcImm | NoWrite, em_test),
	I2bv(SrcAcc | DstDI | Mov | String, em_mov),
	I2bv(SrcSI | DstAcc | Mov | String, em_mov),
	F2bv(SrcAcc | DstDI | String | NoWrite, em_cmp_r),
	/* 0xB0 - 0xB7 */
	X8(I(ByteOp | DstReg | SrcImm | Mov, em_mov)),
	/* 0xB8 - 0xBF */
	X8(I(DstReg | SrcImm64 | Mov, em_mov)),
	/* 0xC0 - 0xC7 */
	G(ByteOp | Src2ImmByte, group2), G(Src2ImmByte, group2),
	I(ImplicitOps | NearBranch | SrcImmU16 | IsBranch, em_ret_near_imm),
	I(ImplicitOps | NearBranch | IsBranch, em_ret),
	I(DstReg | SrcMemFAddr | ModRM | No64 | Src2ES, em_lseg),
	I(DstReg | SrcMemFAddr | ModRM | No64 | Src2DS, em_lseg),
	G(ByteOp, group11), G(0, group11),
	/* 0xC8 - 0xCF */
	I(Stack | SrcImmU16 | Src2ImmByte | IsBranch, em_enter),
	I(Stack | IsBranch, em_leave),
	I(ImplicitOps | SrcImmU16 | IsBranch, em_ret_far_imm),
	I(ImplicitOps | IsBranch, em_ret_far),
	D(ImplicitOps | IsBranch), DI(SrcImmByte | IsBranch, intn),
	D(ImplicitOps | No64 | IsBranch),
	II(ImplicitOps | IsBranch, em_iret, iret),
	/* 0xD0 - 0xD7 */
	G(Src2One | ByteOp, group2), G(Src2One, group2),
	G(Src2CL | ByteOp, group2), G(Src2CL, group2),
	I(DstAcc | SrcImmUByte | No64, em_aam),
	I(DstAcc | SrcImmUByte | No64, em_aad),
	F(DstAcc | ByteOp | No64, em_salc),
	I(DstAcc | SrcXLat | ByteOp, em_mov),
	/* 0xD8 - 0xDF */
	N, E(0, &amp;escape_d9), N, E(0, &amp;escape_db), N, E(0, &amp;escape_dd), N, N,
	/* 0xE0 - 0xE7 */
	X3(I(SrcImmByte | NearBranch | IsBranch, em_loop)),
	I(SrcImmByte | NearBranch | IsBranch, em_jcxz),
	I2bvIP(SrcImmUByte | DstAcc, em_in,  in,  check_perm_in),
	I2bvIP(SrcAcc | DstImmUByte, em_out, out, check_perm_out),
	/* 0xE8 - 0xEF */
	I(SrcImm | NearBranch | IsBranch, em_call),
	D(SrcImm | ImplicitOps | NearBranch | IsBranch),
	I(SrcImmFAddr | No64 | IsBranch, em_jmp_far),
	D(SrcImmByte | ImplicitOps | NearBranch | IsBranch),
	I2bvIP(SrcDX | DstAcc, em_in,  in,  check_perm_in),
	I2bvIP(SrcAcc | DstDX, em_out, out, check_perm_out),
	/* 0xF0 - 0xF7 */
	N, DI(ImplicitOps, icebp), N, N,
	DI(ImplicitOps | Priv, hlt), D(ImplicitOps),
	G(ByteOp, group3), G(0, group3),
	/* 0xF8 - 0xFF */
	D(ImplicitOps), D(ImplicitOps),
	I(ImplicitOps, em_cli), I(ImplicitOps, em_sti),
	D(ImplicitOps), D(ImplicitOps), G(0, group4), G(0, group5),
};

static const struct opcode twobyte_table[256] = {
	/* 0x00 - 0x0F */
	G(0, group6), GD(0, &amp;group7), N, N,
	N, I(ImplicitOps | EmulateOnUD | IsBranch, em_syscall),
	II(ImplicitOps | Priv, em_clts, clts), N,
	DI(ImplicitOps | Priv, invd), DI(ImplicitOps | Priv, wbinvd), N, N,
	N, D(ImplicitOps | ModRM | SrcMem | NoAccess), N, N,
	/* 0x10 - 0x1F */
	GP(ModRM | DstReg | SrcMem | Mov | Sse, &amp;pfx_0f_10_0f_11),
	GP(ModRM | DstMem | SrcReg | Mov | Sse, &amp;pfx_0f_10_0f_11),
	N, N, N, N, N, N,
	D(ImplicitOps | ModRM | SrcMem | NoAccess), /* 4 * prefetch + 4 * reserved NOP */
	D(ImplicitOps | ModRM | SrcMem | NoAccess), N, N,
	D(ImplicitOps | ModRM | SrcMem | NoAccess), /* 8 * reserved NOP */
	D(ImplicitOps | ModRM | SrcMem | NoAccess), /* 8 * reserved NOP */
	D(ImplicitOps | ModRM | SrcMem | NoAccess), /* 8 * reserved NOP */
	D(ImplicitOps | ModRM | SrcMem | NoAccess), /* NOP + 7 * reserved NOP */
	/* 0x20 - 0x2F */
	DIP(ModRM | DstMem | Priv | Op3264 | NoMod, cr_read, check_cr_access),
	DIP(ModRM | DstMem | Priv | Op3264 | NoMod, dr_read, check_dr_read),
	IIP(ModRM | SrcMem | Priv | Op3264 | NoMod, em_cr_write, cr_write,
						check_cr_access),
	IIP(ModRM | SrcMem | Priv | Op3264 | NoMod, em_dr_write, dr_write,
						check_dr_write),
	N, N, N, N,
	GP(ModRM | DstReg | SrcMem | Mov | Sse, &amp;pfx_0f_28_0f_29),
	GP(ModRM | DstMem | SrcReg | Mov | Sse, &amp;pfx_0f_28_0f_29),
	N, GP(ModRM | DstMem | SrcReg | Mov | Sse, &amp;pfx_0f_2b),
	N, N, N, N,
	/* 0x30 - 0x3F */
	II(ImplicitOps | Priv, em_wrmsr, wrmsr),
	IIP(ImplicitOps, em_rdtsc, rdtsc, check_rdtsc),
	II(ImplicitOps | Priv, em_rdmsr, rdmsr),
	IIP(ImplicitOps, em_rdpmc, rdpmc, check_rdpmc),
	I(ImplicitOps | EmulateOnUD | IsBranch, em_sysenter),
	I(ImplicitOps | Priv | EmulateOnUD | IsBranch, em_sysexit),
	N, N,
	N, N, N, N, N, N, N, N,
	/* 0x40 - 0x4F */
	X16(D(DstReg | SrcMem | ModRM)),
	/* 0x50 - 0x5F */
	N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N,
	/* 0x60 - 0x6F */
	N, N, N, N,
	N, N, N, N,
	N, N, N, N,
	N, N, N, GP(SrcMem | DstReg | ModRM | Mov, &amp;pfx_0f_6f_0f_7f),
	/* 0x70 - 0x7F */
	N, N, N, N,
	N, N, N, N,
	N, N, N, N,
	N, N, N, GP(SrcReg | DstMem | ModRM | Mov, &amp;pfx_0f_6f_0f_7f),
	/* 0x80 - 0x8F */
	X16(D(SrcImm | NearBranch | IsBranch)),
	/* 0x90 - 0x9F */
	X16(D(ByteOp | DstMem | SrcNone | ModRM| Mov)),
	/* 0xA0 - 0xA7 */
	I(Stack | Src2FS, em_push_sreg), I(Stack | Src2FS, em_pop_sreg),
	II(ImplicitOps, em_cpuid, cpuid),
	F(DstMem | SrcReg | ModRM | BitOp | NoWrite, em_bt),
	F(DstMem | SrcReg | Src2ImmByte | ModRM, em_shld),
	F(DstMem | SrcReg | Src2CL | ModRM, em_shld), N, N,
	/* 0xA8 - 0xAF */
	I(Stack | Src2GS, em_push_sreg), I(Stack | Src2GS, em_pop_sreg),
	II(EmulateOnUD | ImplicitOps, em_rsm, rsm),
	F(DstMem | SrcReg | ModRM | BitOp | Lock | PageTable, em_bts),
	F(DstMem | SrcReg | Src2ImmByte | ModRM, em_shrd),
	F(DstMem | SrcReg | Src2CL | ModRM, em_shrd),
	GD(0, &amp;group15), F(DstReg | SrcMem | ModRM, em_imul),
	/* 0xB0 - 0xB7 */
	I2bv(DstMem | SrcReg | ModRM | Lock | PageTable | SrcWrite, em_cmpxchg),
	I(DstReg | SrcMemFAddr | ModRM | Src2SS, em_lseg),
	F(DstMem | SrcReg | ModRM | BitOp | Lock, em_btr),
	I(DstReg | SrcMemFAddr | ModRM | Src2FS, em_lseg),
	I(DstReg | SrcMemFAddr | ModRM | Src2GS, em_lseg),
	D(DstReg | SrcMem8 | ModRM | Mov), D(DstReg | SrcMem16 | ModRM | Mov),
	/* 0xB8 - 0xBF */
	N, N,
	G(BitOp, group8),
	F(DstMem | SrcReg | ModRM | BitOp | Lock | PageTable, em_btc),
	I(DstReg | SrcMem | ModRM, em_bsf_c),
	I(DstReg | SrcMem | ModRM, em_bsr_c),
	D(DstReg | SrcMem8 | ModRM | Mov), D(DstReg | SrcMem16 | ModRM | Mov),
	/* 0xC0 - 0xC7 */
	F2bv(DstMem | SrcReg | ModRM | SrcWrite | Lock, em_xadd),
	N, ID(0, &amp;instr_dual_0f_c3),
	N, N, N, GD(0, &amp;group9),
	/* 0xC8 - 0xCF */
	X8(I(DstReg, em_bswap)),
	/* 0xD0 - 0xDF */
	N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N,
	/* 0xE0 - 0xEF */
	N, N, N, N, N, N, N, GP(SrcReg | DstMem | ModRM | Mov, &amp;pfx_0f_e7),
	N, N, N, N, N, N, N, N,
	/* 0xF0 - 0xFF */
	N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N
};

static const struct instr_dual instr_dual_0f_38_f0 = {
	I(DstReg | SrcMem | Mov, em_movbe), N
};

static const struct instr_dual instr_dual_0f_38_f1 = {
	I(DstMem | SrcReg | Mov, em_movbe), N
};

static const struct gprefix three_byte_0f_38_f0 = {
	ID(0, &amp;instr_dual_0f_38_f0), N, N, N
};

static const struct gprefix three_byte_0f_38_f1 = {
	ID(0, &amp;instr_dual_0f_38_f1), N, N, N
};

/*
 * Insns below are selected by the prefix which indexed by the third opcode
 * byte.
 */
static const struct opcode opcode_map_0f_38[256] = {
	/* 0x00 - 0x7f */
	X16(N), X16(N), X16(N), X16(N), X16(N), X16(N), X16(N), X16(N),
	/* 0x80 - 0xef */
	X16(N), X16(N), X16(N), X16(N), X16(N), X16(N), X16(N),
	/* 0xf0 - 0xf1 */
	GP(EmulateOnUD | ModRM, &amp;three_byte_0f_38_f0),
	GP(EmulateOnUD | ModRM, &amp;three_byte_0f_38_f1),
	/* 0xf2 - 0xff */
	N, N, X4(N), X8(N)
};

#undef D
#undef N
#undef G
#undef GD
#undef I
#undef GP
#undef EXT
#undef MD
#undef ID

#undef D2bv
#undef D2bvIP
#undef I2bv
#undef I2bvIP
#undef I6ALU

static unsigned imm_size(struct x86_emulate_ctxt *ctxt)
{
	unsigned size;

<blue>	size = (ctxt->d & ByteOp) ? 1 : ctxt->op_bytes;</blue>
	if (size == 8)
		size = 4;
	return size;
}

static int decode_imm(struct x86_emulate_ctxt *ctxt, struct operand *op,
		      unsigned size, bool sign_extension)
<blue>{</blue>
	int rc = X86EMUL_CONTINUE;

<blue>	op->type = OP_IMM;</blue>
	op-&gt;bytes = size;
	op-&gt;addr.mem.ea = ctxt-&gt;_eip;
	/* NB. Immediates are sign-extended as necessary. */
	switch (op-&gt;bytes) {
	case 1:
<blue>		op->val = insn_fetch(s8, ctxt);</blue>
		break;
	case 2:
<yellow>		op->val = insn_fetch(s16, ctxt);</yellow>
		break;
	case 4:
<yellow>		op->val = insn_fetch(s32, ctxt);</yellow>
		break;
	case 8:
<yellow>		op->val = insn_fetch(s64, ctxt);</yellow>
		break;
	}
<blue>	if (!sign_extension) {</blue>
<yellow>		switch (op->bytes) {</yellow>
		case 1:
<yellow>			op->val &= 0xff;</yellow>
			break;
		case 2:
<yellow>			op->val &= 0xffff;</yellow>
			break;
		case 4:
<yellow>			op->val &= 0xffffffff;</yellow>
			break;
		}
	}
done:
	return rc;
}

static int decode_operand(struct x86_emulate_ctxt *ctxt, struct operand *op,
			  unsigned d)
{
	int rc = X86EMUL_CONTINUE;

<blue>	switch (d) {</blue>
	case OpReg:
<blue>		decode_register_operand(ctxt, op);</blue>
		break;
	case OpImmUByte:
<yellow>		rc = decode_imm(ctxt, op, 1, false);</yellow>
		break;
	case OpMem:
<blue>		ctxt->memop.bytes = (ctxt->d & ByteOp) ? 1 : ctxt->op_bytes;</blue>
	mem_common:
<blue>		*op = ctxt->memop;</blue>
		ctxt-&gt;memopp = op;
		if (ctxt-&gt;d &amp; BitOp)
<yellow>			fetch_bit_operand(ctxt);</yellow>
<blue>		op->orig_val = op->val;</blue>
		break;
	case OpMem64:
<yellow>		ctxt->memop.bytes = (ctxt->op_bytes == 8) ? 16 : 8;</yellow>
		goto mem_common;
	case OpAcc:
<yellow>		op->type = OP_REG;</yellow>
<yellow>		op->bytes = (ctxt->d & ByteOp) ? 1 : ctxt->op_bytes;</yellow>
		op-&gt;addr.reg = reg_rmw(ctxt, VCPU_REGS_RAX);
		fetch_register_operand(op);
		op-&gt;orig_val = op-&gt;val;
		break;
	case OpAccLo:
<yellow>		op->type = OP_REG;</yellow>
<yellow>		op->bytes = (ctxt->d & ByteOp) ? 2 : ctxt->op_bytes;</yellow>
		op-&gt;addr.reg = reg_rmw(ctxt, VCPU_REGS_RAX);
		fetch_register_operand(op);
		op-&gt;orig_val = op-&gt;val;
		break;
	case OpAccHi:
<yellow>		if (ctxt->d & ByteOp) {</yellow>
<yellow>			op->type = OP_NONE;</yellow>
			break;
		}
<yellow>		op->type = OP_REG;</yellow>
		op-&gt;bytes = ctxt-&gt;op_bytes;
		op-&gt;addr.reg = reg_rmw(ctxt, VCPU_REGS_RDX);
		fetch_register_operand(op);
		op-&gt;orig_val = op-&gt;val;
		break;
	case OpDI:
<blue>		op->type = OP_MEM;</blue>
<blue>		op->bytes = (ctxt->d & ByteOp) ? 1 : ctxt->op_bytes;</blue>
<blue>		op->addr.mem.ea =</blue>
<yellow>			register_address(ctxt, VCPU_REGS_RDI);</yellow>
		op-&gt;addr.mem.seg = VCPU_SREG_ES;
		op-&gt;val = 0;
		op-&gt;count = 1;
		break;
	case OpDX:
<blue>		op->type = OP_REG;</blue>
		op-&gt;bytes = 2;
		op-&gt;addr.reg = reg_rmw(ctxt, VCPU_REGS_RDX);
		fetch_register_operand(op);
		break;
	case OpCL:
<yellow>		op->type = OP_IMM;</yellow>
		op-&gt;bytes = 1;
		op-&gt;val = reg_read(ctxt, VCPU_REGS_RCX) &amp; 0xff;
		break;
	case OpImmByte:
<yellow>		rc = decode_imm(ctxt, op, 1, true);</yellow>
		break;
	case OpOne:
<yellow>		op->type = OP_IMM;</yellow>
		op-&gt;bytes = 1;
		op-&gt;val = 1;
		break;
	case OpImm:
<blue>		rc = decode_imm(ctxt, op, imm_size(ctxt), true);</blue>
		break;
	case OpImm64:
<yellow>		rc = decode_imm(ctxt, op, ctxt->op_bytes, true);</yellow>
		break;
	case OpMem8:
<yellow>		ctxt->memop.bytes = 1;</yellow>
		if (ctxt-&gt;memop.type == OP_REG) {
			ctxt-&gt;memop.addr.reg = decode_register(ctxt,
<yellow>					ctxt->modrm_rm, true);</yellow>
			fetch_register_operand(&amp;ctxt-&gt;memop);
		}
		goto mem_common;
	case OpMem16:
<yellow>		ctxt->memop.bytes = 2;</yellow>
		goto mem_common;
	case OpMem32:
<yellow>		ctxt->memop.bytes = 4;</yellow>
		goto mem_common;
	case OpImmU16:
<yellow>		rc = decode_imm(ctxt, op, 2, false);</yellow>
		break;
	case OpImmU:
<yellow>		rc = decode_imm(ctxt, op, imm_size(ctxt), false);</yellow>
		break;
	case OpSI:
<yellow>		op->type = OP_MEM;</yellow>
<yellow>		op->bytes = (ctxt->d & ByteOp) ? 1 : ctxt->op_bytes;</yellow>
<yellow>		op->addr.mem.ea =</yellow>
<yellow>			register_address(ctxt, VCPU_REGS_RSI);</yellow>
		op-&gt;addr.mem.seg = ctxt-&gt;seg_override;
		op-&gt;val = 0;
		op-&gt;count = 1;
		break;
	case OpXLat:
<yellow>		op->type = OP_MEM;</yellow>
<yellow>		op->bytes = (ctxt->d & ByteOp) ? 1 : ctxt->op_bytes;</yellow>
<yellow>		op->addr.mem.ea =</yellow>
<yellow>			address_mask(ctxt,</yellow>
				reg_read(ctxt, VCPU_REGS_RBX) +
				(reg_read(ctxt, VCPU_REGS_RAX) &amp; 0xff));
		op-&gt;addr.mem.seg = ctxt-&gt;seg_override;
		op-&gt;val = 0;
		break;
	case OpImmFAddr:
<yellow>		op->type = OP_IMM;</yellow>
		op-&gt;addr.mem.ea = ctxt-&gt;_eip;
		op-&gt;bytes = ctxt-&gt;op_bytes + 2;
<yellow>		insn_fetch_arr(op->valptr, op->bytes, ctxt);</yellow>
		break;
	case OpMemFAddr:
<yellow>		ctxt->memop.bytes = ctxt->op_bytes + 2;</yellow>
		goto mem_common;
	case OpES:
<yellow>		op->type = OP_IMM;</yellow>
		op-&gt;val = VCPU_SREG_ES;
		break;
	case OpCS:
<yellow>		op->type = OP_IMM;</yellow>
		op-&gt;val = VCPU_SREG_CS;
		break;
	case OpSS:
<yellow>		op->type = OP_IMM;</yellow>
		op-&gt;val = VCPU_SREG_SS;
		break;
	case OpDS:
<yellow>		op->type = OP_IMM;</yellow>
		op-&gt;val = VCPU_SREG_DS;
		break;
	case OpFS:
<yellow>		op->type = OP_IMM;</yellow>
		op-&gt;val = VCPU_SREG_FS;
		break;
	case OpGS:
<yellow>		op->type = OP_IMM;</yellow>
		op-&gt;val = VCPU_SREG_GS;
		break;
	case OpImplicit:
		/* Special instructions do their own operand decoding. */
	default:
<blue>		op->type = OP_NONE; /* Disable writeback. */</blue>
		break;
	}

done:
	return rc;
<blue>}</blue>

int x86_decode_insn(struct x86_emulate_ctxt *ctxt, void *insn, int insn_len, int emulation_type)
<blue>{</blue>
	int rc = X86EMUL_CONTINUE;
<blue>	int mode = ctxt->mode;</blue>
	int def_op_bytes, def_ad_bytes, goffset, simd_prefix;
	bool op_prefix = false;
	bool has_seg_override = false;
	struct opcode opcode;
	u16 dummy;
	struct desc_struct desc;

	ctxt-&gt;memop.type = OP_NONE;
	ctxt-&gt;memopp = NULL;
	ctxt-&gt;_eip = ctxt-&gt;eip;
	ctxt-&gt;fetch.ptr = ctxt-&gt;fetch.data;
	ctxt-&gt;fetch.end = ctxt-&gt;fetch.data + insn_len;
	ctxt-&gt;opcode_len = 1;
	ctxt-&gt;intercept = x86_intercept_none;
	if (insn_len &gt; 0)
<yellow>		memcpy(ctxt->fetch.data, insn, insn_len);</yellow>
	else {
<blue>		rc = __do_insn_fetch_bytes(ctxt, 1);</blue>
		if (rc != X86EMUL_CONTINUE)
			goto done;
	}

<blue>	switch (mode) {</blue>
	case X86EMUL_MODE_REAL:
	case X86EMUL_MODE_VM86:
		def_op_bytes = def_ad_bytes = 2;
<yellow>		ctxt->ops->get_segment(ctxt, &dummy, &desc, NULL, VCPU_SREG_CS);</yellow>
		if (desc.d)
			def_op_bytes = def_ad_bytes = 4;
		break;
	case X86EMUL_MODE_PROT16:
		def_op_bytes = def_ad_bytes = 2;
		break;
	case X86EMUL_MODE_PROT32:
		def_op_bytes = def_ad_bytes = 4;
		break;
#ifdef CONFIG_X86_64
	case X86EMUL_MODE_PROT64:
		def_op_bytes = 4;
		def_ad_bytes = 8;
		break;
#endif
	default:
		return EMULATION_FAILED;
	}

<blue>	ctxt->op_bytes = def_op_bytes;</blue>
	ctxt-&gt;ad_bytes = def_ad_bytes;

	/* Legacy prefixes. */
	for (;;) {
<blue>		switch (ctxt->b = insn_fetch(u8, ctxt)) {</blue>
		case 0x66:	/* operand-size override */
			op_prefix = true;
			/* switch between 2/4 bytes */
<blue>			ctxt->op_bytes = def_op_bytes ^ 6;</blue>
			break;
		case 0x67:	/* address-size override */
<yellow>			if (mode == X86EMUL_MODE_PROT64)</yellow>
				/* switch between 4/8 bytes */
<yellow>				ctxt->ad_bytes = def_ad_bytes ^ 12;</yellow>
			else
				/* switch between 2/4 bytes */
<yellow>				ctxt->ad_bytes = def_ad_bytes ^ 6;</yellow>
			break;
		case 0x26:	/* ES override */
			has_seg_override = true;
<yellow>			ctxt->seg_override = VCPU_SREG_ES;</yellow>
			break;
		case 0x2e:	/* CS override */
			has_seg_override = true;
<yellow>			ctxt->seg_override = VCPU_SREG_CS;</yellow>
			break;
		case 0x36:	/* SS override */
			has_seg_override = true;
<yellow>			ctxt->seg_override = VCPU_SREG_SS;</yellow>
			break;
		case 0x3e:	/* DS override */
			has_seg_override = true;
<yellow>			ctxt->seg_override = VCPU_SREG_DS;</yellow>
			break;
		case 0x64:	/* FS override */
			has_seg_override = true;
<yellow>			ctxt->seg_override = VCPU_SREG_FS;</yellow>
			break;
		case 0x65:	/* GS override */
			has_seg_override = true;
<yellow>			ctxt->seg_override = VCPU_SREG_GS;</yellow>
			break;
		case 0x40 ... 0x4f: /* REX */
<yellow>			if (mode != X86EMUL_MODE_PROT64)</yellow>
				goto done_prefixes;
			ctxt-&gt;rex_prefix = ctxt-&gt;b;
			continue;
		case 0xf0:	/* LOCK */
<blue>			ctxt->lock_prefix = 1;</blue>
			break;
		case 0xf2:	/* REPNE/REPNZ */
		case 0xf3:	/* REP/REPE/REPZ */
<blue>			ctxt->rep_prefix = ctxt->b;</blue>
			break;
		default:
			goto done_prefixes;
		}

		/* Any legacy prefix after a REX prefix nullifies its effect. */

<blue>		ctxt->rex_prefix = 0;</blue>
	}

done_prefixes:

	/* REX prefix. */
<blue>	if (ctxt->rex_prefix & 8)</blue>
<yellow>		ctxt->op_bytes = 8;	/* REX.W */</yellow>

	/* Opcode byte(s). */
<blue>	opcode = opcode_table[ctxt->b];</blue>
	/* Two-byte opcode? */
	if (ctxt-&gt;b == 0x0f) {
<blue>		ctxt->opcode_len = 2;</blue>
<blue>		ctxt->b = insn_fetch(u8, ctxt);</blue>
		opcode = twobyte_table[ctxt-&gt;b];

		/* 0F_38 opcode map */
		if (ctxt-&gt;b == 0x38) {
<blue>			ctxt->opcode_len = 3;</blue>
<blue>			ctxt->b = insn_fetch(u8, ctxt);</blue>
			opcode = opcode_map_0f_38[ctxt-&gt;b];
		}
	}
<blue>	ctxt->d = opcode.flags;</blue>

	if (ctxt-&gt;d &amp; ModRM)
<blue>		ctxt->modrm = insn_fetch(u8, ctxt);</blue>

	/* vex-prefix instructions are not implemented */
<blue>	if (ctxt->opcode_len == 1 && (ctxt->b == 0xc5 || ctxt->b == 0xc4) &&</blue>
<yellow>	    (mode == X86EMUL_MODE_PROT64 || (ctxt->modrm & 0xc0) == 0xc0)) {</yellow>
<yellow>		ctxt->d = NotImpl;</yellow>
	}

<blue>	while (ctxt->d & GroupMask) {</blue>
<blue>		switch (ctxt->d & GroupMask) {</blue>
		case Group:
<blue>			goffset = (ctxt->modrm >> 3) & 7;</blue>
			opcode = opcode.u.group[goffset];
			break;
		case GroupDual:
<blue>			goffset = (ctxt->modrm >> 3) & 7;</blue>
			if ((ctxt-&gt;modrm &gt;&gt; 6) == 3)
<blue>				opcode = opcode.u.gdual->mod3[goffset];</blue>
			else
<yellow>				opcode = opcode.u.gdual->mod012[goffset];</yellow>
			break;
		case RMExt:
<blue>			goffset = ctxt->modrm & 7;</blue>
			opcode = opcode.u.group[goffset];
			break;
		case Prefix:
<yellow>			if (ctxt->rep_prefix && op_prefix)</yellow>
				return EMULATION_FAILED;
<yellow>			simd_prefix = op_prefix ? 0x66 : ctxt->rep_prefix;</yellow>
<yellow>			switch (simd_prefix) {</yellow>
<yellow>			case 0x00: opcode = opcode.u.gprefix->pfx_no; break;</yellow>
<yellow>			case 0x66: opcode = opcode.u.gprefix->pfx_66; break;</yellow>
<yellow>			case 0xf2: opcode = opcode.u.gprefix->pfx_f2; break;</yellow>
<yellow>			case 0xf3: opcode = opcode.u.gprefix->pfx_f3; break;</yellow>
			}
			break;
		case Escape:
<yellow>			if (ctxt->modrm > 0xbf) {</yellow>
				size_t size = ARRAY_SIZE(opcode.u.esc-&gt;high);
<yellow>				u32 index = array_index_nospec(</yellow>
					ctxt-&gt;modrm - 0xc0, size);

				opcode = opcode.u.esc-&gt;high[index];
			} else {
<yellow>				opcode = opcode.u.esc->op[(ctxt->modrm >> 3) & 7];</yellow>
			}
			break;
		case InstrDual:
<yellow>			if ((ctxt->modrm >> 6) == 3)</yellow>
<yellow>				opcode = opcode.u.idual->mod3;</yellow>
			else
<yellow>				opcode = opcode.u.idual->mod012;</yellow>
			break;
		case ModeDual:
<yellow>			if (ctxt->mode == X86EMUL_MODE_PROT64)</yellow>
<yellow>				opcode = opcode.u.mdual->mode64;</yellow>
			else
<yellow>				opcode = opcode.u.mdual->mode32;</yellow>
			break;
		default:
			return EMULATION_FAILED;
		}

		ctxt-&gt;d &amp;= ~(u64)GroupMask;
<blue>		ctxt->d |= opcode.flags;</blue>
	}

<blue>	ctxt->is_branch = opcode.flags & IsBranch;</blue>

	/* Unrecognised? */
	if (ctxt-&gt;d == 0)
		return EMULATION_FAILED;

<blue>	ctxt->execute = opcode.u.execute;</blue>

<yellow>	if (unlikely(emulation_type & EMULTYPE_TRAP_UD) &&</yellow>
<blue>	    likely(!(ctxt->d & EmulateOnUD)))</blue>
		return EMULATION_FAILED;

<blue>	if (unlikely(ctxt->d &</blue>
	    (NotImpl|Stack|Op3264|Sse|Mmx|Intercept|CheckPerm|NearBranch|
	     No16))) {
		/*
		 * These are copied unconditionally here, and checked unconditionally
		 * in x86_emulate_insn.
		 */
<blue>		ctxt->check_perm = opcode.check_perm;</blue>
		ctxt-&gt;intercept = opcode.intercept;

		if (ctxt-&gt;d &amp; NotImpl)
			return EMULATION_FAILED;

<blue>		if (mode == X86EMUL_MODE_PROT64) {</blue>
<blue>			if (ctxt->op_bytes == 4 && (ctxt->d & Stack))</blue>
<yellow>				ctxt->op_bytes = 8;</yellow>
<blue>			else if (ctxt->d & NearBranch)</blue>
				ctxt-&gt;op_bytes = 8;
		}

<blue>		if (ctxt->d & Op3264) {</blue>
			if (mode == X86EMUL_MODE_PROT64)
				ctxt-&gt;op_bytes = 8;
			else
<yellow>				ctxt->op_bytes = 4;</yellow>
		}

<blue>		if ((ctxt->d & No16) && ctxt->op_bytes == 2)</blue>
<yellow>			ctxt->op_bytes = 4;</yellow>

<blue>		if (ctxt->d & Sse)</blue>
<yellow>			ctxt->op_bytes = 16;</yellow>
<blue>		else if (ctxt->d & Mmx)</blue>
<yellow>			ctxt->op_bytes = 8;</yellow>
	}

	/* ModRM and SIB bytes. */
<blue>	if (ctxt->d & ModRM) {</blue>
<blue>		rc = decode_modrm(ctxt, &ctxt->memop);</blue>
<blue>		if (!has_seg_override) {</blue>
			has_seg_override = true;
<blue>			ctxt->seg_override = ctxt->modrm_seg;</blue>
		}
<blue>	} else if (ctxt->d & MemAbs)</blue>
<yellow>		rc = decode_abs(ctxt, &ctxt->memop);</yellow>
	if (rc != X86EMUL_CONTINUE)
		goto done;

<blue>	if (!has_seg_override)</blue>
<blue>		ctxt->seg_override = VCPU_SREG_DS;</blue>

<blue>	ctxt->memop.addr.mem.seg = ctxt->seg_override;</blue>

	/*
	 * Decode and fetch the source operand: register, memory
	 * or immediate.
	 */
	rc = decode_operand(ctxt, &amp;ctxt-&gt;src, (ctxt-&gt;d &gt;&gt; SrcShift) &amp; OpMask);
	if (rc != X86EMUL_CONTINUE)
		goto done;

	/*
	 * Decode and fetch the second source operand: register, memory
	 * or immediate.
	 */
<blue>	rc = decode_operand(ctxt, &ctxt->src2, (ctxt->d >> Src2Shift) & OpMask);</blue>
	if (rc != X86EMUL_CONTINUE)
		goto done;

	/* Decode and fetch the destination operand: register or memory. */
<blue>	rc = decode_operand(ctxt, &ctxt->dst, (ctxt->d >> DstShift) & OpMask);</blue>

<blue>	if (ctxt->rip_relative && likely(ctxt->memopp))</blue>
<blue>		ctxt->memopp->addr.mem.ea = address_mask(ctxt,</blue>
<blue>					ctxt->memopp->addr.mem.ea + ctxt->_eip);</blue>

done:
<blue>	if (rc == X86EMUL_PROPAGATE_FAULT)</blue>
<blue>		ctxt->have_exception = true;</blue>
<blue>	return (rc != X86EMUL_CONTINUE) ? EMULATION_FAILED : EMULATION_OK;</blue>
}

bool x86_page_table_writing_insn(struct x86_emulate_ctxt *ctxt)
{
<blue>	return ctxt->d & PageTable;</blue>
}

static bool string_insn_completed(struct x86_emulate_ctxt *ctxt)
{
	/* The second termination condition only applies for REPE
	 * and REPNE. Test if the repeat string operation prefix is
	 * REPE/REPZ or REPNE/REPNZ and if it&#x27;s the case it tests the
	 * corresponding termination condition according to:
	 * 	- if REPE/REPZ and ZF = 0 then done
	 * 	- if REPNE/REPNZ and ZF = 1 then done
	 */
<blue>	if (((ctxt->b == 0xa6) || (ctxt->b == 0xa7) ||</blue>
	     (ctxt-&gt;b == 0xae) || (ctxt-&gt;b == 0xaf))
<yellow>	    && (((ctxt->rep_prefix == REPE_PREFIX) &&</yellow>
<yellow>		 ((ctxt->eflags & X86_EFLAGS_ZF) == 0))</yellow>
<yellow>		|| ((ctxt->rep_prefix == REPNE_PREFIX) &&</yellow>
<yellow>		    ((ctxt->eflags & X86_EFLAGS_ZF) == X86_EFLAGS_ZF))))</yellow>
		return true;

	return false;
}

static int flush_pending_x87_faults(struct x86_emulate_ctxt *ctxt)
{
	int rc;

<yellow>	kvm_fpu_get();</yellow>
<yellow>	rc = asm_safe("fwait");</yellow>
<yellow>	kvm_fpu_put();</yellow>

	if (unlikely(rc != X86EMUL_CONTINUE))
<yellow>		return emulate_exception(ctxt, MF_VECTOR, 0, false);</yellow>

	return X86EMUL_CONTINUE;
}

static void fetch_possible_mmx_operand(struct operand *op)
{
<yellow>	if (op->type == OP_MM)</yellow>
<yellow>		kvm_read_mmx_reg(op->addr.mm, &op->mm_val);</yellow>
}

static int fastop(struct x86_emulate_ctxt *ctxt, fastop_t fop)
{
<blue>	ulong flags = (ctxt->eflags & EFLAGS_MASK) | X86_EFLAGS_IF;</blue>

	if (!(ctxt-&gt;d &amp; ByteOp))
<yellow>		fop += __ffs(ctxt->dst.bytes) * FASTOP_SIZE;</yellow>

	asm(&quot;push %[flags]; popf; &quot; CALL_NOSPEC &quot; ; pushf; pop %[flags]\n&quot;
	    : &quot;+a&quot;(ctxt-&gt;dst.val), &quot;+d&quot;(ctxt-&gt;src.val), [flags]&quot;+D&quot;(flags),
	      [thunk_target]&quot;+S&quot;(fop), ASM_CALL_CONSTRAINT
<blue>	    : "c"(ctxt->src2.val));</blue>

	ctxt-&gt;eflags = (ctxt-&gt;eflags &amp; ~EFLAGS_MASK) | (flags &amp; EFLAGS_MASK);
	if (!fop) /* exception is returned in fop variable */
<yellow>		return emulate_de(ctxt);</yellow>
	return X86EMUL_CONTINUE;
<blue>}</blue>

void init_decode_cache(struct x86_emulate_ctxt *ctxt)
{
	/* Clear fields that are set conditionally but read without a guard. */
<blue>	ctxt->rip_relative = false;</blue>
	ctxt-&gt;rex_prefix = 0;
	ctxt-&gt;lock_prefix = 0;
	ctxt-&gt;rep_prefix = 0;
	ctxt-&gt;regs_valid = 0;
	ctxt-&gt;regs_dirty = 0;

	ctxt-&gt;io_read.pos = 0;
	ctxt-&gt;io_read.end = 0;
	ctxt-&gt;mem_read.end = 0;
}

int x86_emulate_insn(struct x86_emulate_ctxt *ctxt)
<blue>{</blue>
<blue>	const struct x86_emulate_ops *ops = ctxt->ops;</blue>
	int rc = X86EMUL_CONTINUE;
	int saved_dst_type = ctxt-&gt;dst.type;
	unsigned emul_flags;

	ctxt-&gt;mem_read.pos = 0;

	/* LOCK prefix is allowed only with some instructions */
<yellow>	if (ctxt->lock_prefix && (!(ctxt->d & Lock) || ctxt->dst.type != OP_MEM)) {</yellow>
<yellow>		rc = emulate_ud(ctxt);</yellow>
		goto done;
	}

<blue>	if ((ctxt->d & SrcMask) == SrcMemFAddr && ctxt->src.type != OP_MEM) {</blue>
		rc = emulate_ud(ctxt);
		goto done;
	}

<blue>	emul_flags = ctxt->ops->get_hflags(ctxt);</blue>
	if (unlikely(ctxt-&gt;d &amp;
		     (No64|Undefined|Sse|Mmx|Intercept|CheckPerm|Priv|Prot|String))) {
<blue>		if ((ctxt->mode == X86EMUL_MODE_PROT64 && (ctxt->d & No64)) ||</blue>
<blue>				(ctxt->d & Undefined)) {</blue>
			rc = emulate_ud(ctxt);
			goto done;
		}

<blue>		if (((ctxt->d & (Sse|Mmx)) && ((ops->get_cr(ctxt, 0) & X86_CR0_EM)))</blue>
<blue>		    || ((ctxt->d & Sse) && !(ops->get_cr(ctxt, 4) & X86_CR4_OSFXSR))) {</blue>
			rc = emulate_ud(ctxt);
			goto done;
		}

<yellow>		if ((ctxt->d & (Sse|Mmx)) && (ops->get_cr(ctxt, 0) & X86_CR0_TS)) {</yellow>
<yellow>			rc = emulate_nm(ctxt);</yellow>
			goto done;
		}

<blue>		if (ctxt->d & Mmx) {</blue>
<yellow>			rc = flush_pending_x87_faults(ctxt);</yellow>
			if (rc != X86EMUL_CONTINUE)
				goto done;
			/*
			 * Now that we know the fpu is exception safe, we can fetch
			 * operands from it.
			 */
<yellow>			fetch_possible_mmx_operand(&ctxt->src);</yellow>
<yellow>			fetch_possible_mmx_operand(&ctxt->src2);</yellow>
<yellow>			if (!(ctxt->d & Mov))</yellow>
<yellow>				fetch_possible_mmx_operand(&ctxt->dst);</yellow>
		}

<blue>		if (unlikely(emul_flags & X86EMUL_GUEST_MASK) && ctxt->intercept) {</blue>
<blue>			rc = emulator_check_intercept(ctxt, ctxt->intercept,</blue>
						      X86_ICPT_PRE_EXCEPT);
			if (rc != X86EMUL_CONTINUE)
				goto done;
		}

		/* Instruction can only be executed in protected mode */
<blue>		if ((ctxt->d & Prot) && ctxt->mode < X86EMUL_MODE_PROT16) {</blue>
			rc = emulate_ud(ctxt);
			goto done;
		}

		/* Privileged instruction can be executed only in CPL=0 */
<blue>		if ((ctxt->d & Priv) && ops->cpl(ctxt)) {</blue>
<yellow>			if (ctxt->d & PrivUD)</yellow>
				rc = emulate_ud(ctxt);
			else
<yellow>				rc = emulate_gp(ctxt, 0);</yellow>
			goto done;
		}

		/* Do instruction specific permission checks */
<blue>		if (ctxt->d & CheckPerm) {</blue>
<blue>			rc = ctxt->check_perm(ctxt);</blue>
			if (rc != X86EMUL_CONTINUE)
				goto done;
		}

<blue>		if (unlikely(emul_flags & X86EMUL_GUEST_MASK) && (ctxt->d & Intercept)) {</blue>
<yellow>			rc = emulator_check_intercept(ctxt, ctxt->intercept,</yellow>
						      X86_ICPT_POST_EXCEPT);
<yellow>			if (rc != X86EMUL_CONTINUE)</yellow>
				goto done;
		}

<blue>		if (ctxt->rep_prefix && (ctxt->d & String)) {</blue>
			/* All REP prefixes have the same first termination condition */
<blue>			if (address_mask(ctxt, reg_read(ctxt, VCPU_REGS_RCX)) == 0) {</blue>
<yellow>				string_registers_quirk(ctxt);</yellow>
<blue>				ctxt->eip = ctxt->_eip;</blue>
				ctxt-&gt;eflags &amp;= ~X86_EFLAGS_RF;
				goto done;
			}
		}
	}

<blue>	if ((ctxt->src.type == OP_MEM) && !(ctxt->d & NoAccess)) {</blue>
<blue>		rc = segmented_read(ctxt, ctxt->src.addr.mem,</blue>
				    ctxt-&gt;src.valptr, ctxt-&gt;src.bytes);
		if (rc != X86EMUL_CONTINUE)
			goto done;
<blue>		ctxt->src.orig_val64 = ctxt->src.val64;</blue>
	}

<blue>	if (ctxt->src2.type == OP_MEM) {</blue>
<yellow>		rc = segmented_read(ctxt, ctxt->src2.addr.mem,</yellow>
				    &amp;ctxt-&gt;src2.val, ctxt-&gt;src2.bytes);
		if (rc != X86EMUL_CONTINUE)
			goto done;
	}

<blue>	if ((ctxt->d & DstMask) == ImplicitOps)</blue>
		goto special_insn;


<blue>	if ((ctxt->dst.type == OP_MEM) && !(ctxt->d & Mov)) {</blue>
		/* optimisation - avoid slow emulated read if Mov */
<blue>		rc = segmented_read(ctxt, ctxt->dst.addr.mem,</blue>
				   &amp;ctxt-&gt;dst.val, ctxt-&gt;dst.bytes);
		if (rc != X86EMUL_CONTINUE) {
<blue>			if (!(ctxt->d & NoWrite) &&</blue>
			    rc == X86EMUL_PROPAGATE_FAULT &amp;&amp;
<yellow>			    ctxt->exception.vector == PF_VECTOR)</yellow>
<yellow>				ctxt->exception.error_code |= PFERR_WRITE_MASK;</yellow>
			goto done;
		}
	}
	/* Copy full 64-bit value for CMPXCHG8B.  */
<blue>	ctxt->dst.orig_val64 = ctxt->dst.val64;</blue>

special_insn:

<blue>	if (unlikely(emul_flags & X86EMUL_GUEST_MASK) && (ctxt->d & Intercept)) {</blue>
<yellow>		rc = emulator_check_intercept(ctxt, ctxt->intercept,</yellow>
					      X86_ICPT_POST_MEMACCESS);
		if (rc != X86EMUL_CONTINUE)
			goto done;
	}

<blue>	if (ctxt->rep_prefix && (ctxt->d & String))</blue>
<blue>		ctxt->eflags |= X86_EFLAGS_RF;</blue>
	else
<blue>		ctxt->eflags &= ~X86_EFLAGS_RF;</blue>

<blue>	if (ctxt->execute) {</blue>
<blue>		if (ctxt->d & Fastop)</blue>
<blue>			rc = fastop(ctxt, ctxt->fop);</blue>
		else
<blue>			rc = ctxt->execute(ctxt);</blue>
		if (rc != X86EMUL_CONTINUE)
			goto done;
		goto writeback;
	}

<yellow>	if (ctxt->opcode_len == 2)</yellow>
		goto twobyte_insn;
<yellow>	else if (ctxt->opcode_len == 3)</yellow>
		goto threebyte_insn;

<yellow>	switch (ctxt->b) {</yellow>
	case 0x70 ... 0x7f: /* jcc (short) */
<yellow>		if (test_cc(ctxt->b, ctxt->eflags))</yellow>
<yellow>			rc = jmp_rel(ctxt, ctxt->src.val);</yellow>
		break;
	case 0x8d: /* lea r16/r32, m */
<yellow>		ctxt->dst.val = ctxt->src.addr.mem.ea;</yellow>
		break;
	case 0x90 ... 0x97: /* nop / xchg reg, rax */
<yellow>		if (ctxt->dst.addr.reg == reg_rmw(ctxt, VCPU_REGS_RAX))</yellow>
<yellow>			ctxt->dst.type = OP_NONE;</yellow>
		else
<yellow>			rc = em_xchg(ctxt);</yellow>
		break;
	case 0x98: /* cbw/cwde/cdqe */
<yellow>		switch (ctxt->op_bytes) {</yellow>
<yellow>		case 2: ctxt->dst.val = (s8)ctxt->dst.val; break;</yellow>
<yellow>		case 4: ctxt->dst.val = (s16)ctxt->dst.val; break;</yellow>
<yellow>		case 8: ctxt->dst.val = (s32)ctxt->dst.val; break;</yellow>
		}
		break;
	case 0xcc:		/* int3 */
<yellow>		rc = emulate_int(ctxt, 3);</yellow>
		break;
	case 0xcd:		/* int n */
<yellow>		rc = emulate_int(ctxt, ctxt->src.val);</yellow>
		break;
	case 0xce:		/* into */
<yellow>		if (ctxt->eflags & X86_EFLAGS_OF)</yellow>
<yellow>			rc = emulate_int(ctxt, 4);</yellow>
		break;
	case 0xe9: /* jmp rel */
	case 0xeb: /* jmp rel short */
<yellow>		rc = jmp_rel(ctxt, ctxt->src.val);</yellow>
		ctxt-&gt;dst.type = OP_NONE; /* Disable writeback. */
		break;
	case 0xf4:              /* hlt */
<yellow>		ctxt->ops->halt(ctxt);</yellow>
		break;
	case 0xf5:	/* cmc */
		/* complement carry flag from eflags reg */
<yellow>		ctxt->eflags ^= X86_EFLAGS_CF;</yellow>
		break;
	case 0xf8: /* clc */
<yellow>		ctxt->eflags &= ~X86_EFLAGS_CF;</yellow>
		break;
	case 0xf9: /* stc */
<yellow>		ctxt->eflags |= X86_EFLAGS_CF;</yellow>
		break;
	case 0xfc: /* cld */
<yellow>		ctxt->eflags &= ~X86_EFLAGS_DF;</yellow>
		break;
	case 0xfd: /* std */
<yellow>		ctxt->eflags |= X86_EFLAGS_DF;</yellow>
		break;
	default:
		goto cannot_emulate;
	}

<blue>	if (rc != X86EMUL_CONTINUE)</blue>
		goto done;

writeback:
<blue>	if (ctxt->d & SrcWrite) {</blue>
<yellow>		BUG_ON(ctxt->src.type == OP_MEM || ctxt->src.type == OP_MEM_STR);</yellow>
<yellow>		rc = writeback(ctxt, &ctxt->src);</yellow>
		if (rc != X86EMUL_CONTINUE)
			goto done;
	}
<blue>	if (!(ctxt->d & NoWrite)) {</blue>
<blue>		rc = writeback(ctxt, &ctxt->dst);</blue>
		if (rc != X86EMUL_CONTINUE)
			goto done;
	}

	/*
	 * restore dst type in case the decoding will be reused
	 * (happens for string instruction )
	 */
<blue>	ctxt->dst.type = saved_dst_type;</blue>

<blue>	if ((ctxt->d & SrcMask) == SrcSI)</blue>
<yellow>		string_addr_inc(ctxt, VCPU_REGS_RSI, &ctxt->src);</yellow>

<blue>	if ((ctxt->d & DstMask) == DstDI)</blue>
<blue>		string_addr_inc(ctxt, VCPU_REGS_RDI, &ctxt->dst);</blue>

<blue>	if (ctxt->rep_prefix && (ctxt->d & String)) {</blue>
		unsigned int count;
		struct read_cache *r = &amp;ctxt-&gt;io_read;
<blue>		if ((ctxt->d & SrcMask) == SrcSI)</blue>
<yellow>			count = ctxt->src.count;</yellow>
		else
<blue>			count = ctxt->dst.count;</blue>
<blue>		register_address_increment(ctxt, VCPU_REGS_RCX, -count);</blue>

<blue>		if (!string_insn_completed(ctxt)) {</blue>
			/*
			 * Re-enter guest when pio read ahead buffer is empty
			 * or, if it is not used, after each 1024 iteration.
			 */
<blue>			if ((r->end != 0 || reg_read(ctxt, VCPU_REGS_RCX) & 0x3ff) &&</blue>
<blue>			    (r->end == 0 || r->end != r->pos)) {</blue>
				/*
				 * Reset read cache. Usually happens before
				 * decode, but since instruction is restarted
				 * we have to do it here.
				 */
<yellow>				ctxt->mem_read.end = 0;</yellow>
				writeback_registers(ctxt);
				return EMULATION_RESTART;
			}
			goto done; /* skip rip writeback */
		}
<yellow>		ctxt->eflags &= ~X86_EFLAGS_RF;</yellow>
	}

<blue>	ctxt->eip = ctxt->_eip;</blue>
	if (ctxt-&gt;mode != X86EMUL_MODE_PROT64)
<yellow>		ctxt->eip = (u32)ctxt->_eip;</yellow>

done:
<blue>	if (rc == X86EMUL_PROPAGATE_FAULT) {</blue>
<yellow>		if (KVM_EMULATOR_BUG_ON(ctxt->exception.vector > 0x1f, ctxt))</yellow>
			return EMULATION_FAILED;
<yellow>		ctxt->have_exception = true;</yellow>
	}
<blue>	if (rc == X86EMUL_INTERCEPTED)</blue>
		return EMULATION_INTERCEPTED;

<blue>	if (rc == X86EMUL_CONTINUE)</blue>
<blue>		writeback_registers(ctxt);</blue>

<blue>	return (rc == X86EMUL_UNHANDLEABLE) ? EMULATION_FAILED : EMULATION_OK;</blue>

twobyte_insn:
<yellow>	switch (ctxt->b) {</yellow>
	case 0x09:		/* wbinvd */
<yellow>		(ctxt->ops->wbinvd)(ctxt);</yellow>
		break;
	case 0x08:		/* invd */
	case 0x0d:		/* GrpP (prefetch) */
	case 0x18:		/* Grp16 (prefetch/nop) */
	case 0x1f:		/* nop */
		break;
	case 0x20: /* mov cr, reg */
<yellow>		ctxt->dst.val = ops->get_cr(ctxt, ctxt->modrm_reg);</yellow>
		break;
	case 0x21: /* mov from dr to reg */
<yellow>		ops->get_dr(ctxt, ctxt->modrm_reg, &ctxt->dst.val);</yellow>
		break;
	case 0x40 ... 0x4f:	/* cmov */
<yellow>		if (test_cc(ctxt->b, ctxt->eflags))</yellow>
<yellow>			ctxt->dst.val = ctxt->src.val;</yellow>
<yellow>		else if (ctxt->op_bytes != 4)</yellow>
			ctxt-&gt;dst.type = OP_NONE; /* no writeback */
		break;
	case 0x80 ... 0x8f: /* jnz rel, etc*/
<yellow>		if (test_cc(ctxt->b, ctxt->eflags))</yellow>
<yellow>			rc = jmp_rel(ctxt, ctxt->src.val);</yellow>
		break;
	case 0x90 ... 0x9f:     /* setcc r/m8 */
<yellow>		ctxt->dst.val = test_cc(ctxt->b, ctxt->eflags);</yellow>
		break;
	case 0xb6 ... 0xb7:	/* movzx */
<yellow>		ctxt->dst.bytes = ctxt->op_bytes;</yellow>
<yellow>		ctxt->dst.val = (ctxt->src.bytes == 1) ? (u8) ctxt->src.val</yellow>
<yellow>						       : (u16) ctxt->src.val;</yellow>
		break;
	case 0xbe ... 0xbf:	/* movsx */
<yellow>		ctxt->dst.bytes = ctxt->op_bytes;</yellow>
<yellow>		ctxt->dst.val = (ctxt->src.bytes == 1) ? (s8) ctxt->src.val :</yellow>
							(s16) ctxt-&gt;src.val;
		break;
	default:
		goto cannot_emulate;
	}

threebyte_insn:

	if (rc != X86EMUL_CONTINUE)
		goto done;

	goto writeback;

cannot_emulate:
	return EMULATION_FAILED;
}

void emulator_invalidate_register_cache(struct x86_emulate_ctxt *ctxt)
{
<yellow>	invalidate_registers(ctxt);</yellow>
}

void emulator_writeback_register_cache(struct x86_emulate_ctxt *ctxt)
{
<yellow>	writeback_registers(ctxt);</yellow>
}

bool emulator_can_use_gpa(struct x86_emulate_ctxt *ctxt)
{
<blue>	if (ctxt->rep_prefix && (ctxt->d & String))</blue>
		return false;

<blue>	if (ctxt->d & TwoMemOp)</blue>
		return false;

	return true;
<blue>}</blue>


</code></pre></td></tr></table>
</body>
</html>
