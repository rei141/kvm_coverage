<doctype html>
<html lang="ja">
<head>
<meta charset="utf-8">
<script src="https://cdn.rawgit.com/google/code-prettify/master/loader/run_prettify.js"></script>
<style>
    code{
        font-family:Monaco, Menlo, Consolas, 'Courier New', Courier, monospace, sans-serif;
        font-size: 14px;
        line-height: 18px;
        overflow: auto;
        resize: horizontal;
    }
    code_line{
        font-family: Monaco, Menlo, Consolas, 'Courier New', Courier, monospace, sans-serif;;
        font-size: 14px;
        line-height: 18px;
        overflow: auto;
        resize: horizontal;
        color:#303134;
    }
    blue{
        background-color:#BEEDE8;
    }
    yellow{
        background-color:#FFFF99;
    }
    red{
        background-color:#FF99AC;
    }
</style>

</head>
<body>
<table summary='blob content' class='blob' cellspacing="15">
<tr><td align="right"><pre><code_line>1.<br>2.<br>3.<br>4.<br>5.<br>6.<br>7.<br>8.<br>9.<br>10.<br>11.<br>12.<br>13.<br>14.<br>15.<br>16.<br>17.<br>18.<br>19.<br>20.<br>21.<br>22.<br>23.<br>24.<br>25.<br>26.<br>27.<br>28.<br>29.<br>30.<br>31.<br>32.<br>33.<br>34.<br>35.<br>36.<br>37.<br>38.<br>39.<br>40.<br>41.<br>42.<br>43.<br>44.<br>45.<br>46.<br>47.<br>48.<br>49.<br>50.<br>51.<br>52.<br>53.<br>54.<br>55.<br>56.<br>57.<br>58.<br>59.<br>60.<br>61.<br>62.<br>63.<br>64.<br>65.<br>66.<br>67.<br>68.<br>69.<br>70.<br>71.<br>72.<br>73.<br>74.<br>75.<br>76.<br>77.<br>78.<br>79.<br>80.<br>81.<br>82.<br>83.<br>84.<br>85.<br>86.<br>87.<br>88.<br>89.<br>90.<br>91.<br>92.<br>93.<br>94.<br>95.<br>96.<br>97.<br>98.<br>99.<br>100.<br>101.<br>102.<br>103.<br>104.<br>105.<br>106.<br>107.<br>108.<br>109.<br>110.<br>111.<br>112.<br>113.<br>114.<br>115.<br>116.<br>117.<br>118.<br>119.<br>120.<br>121.<br>122.<br>123.<br>124.<br>125.<br>126.<br>127.<br>128.<br>129.<br>130.<br>131.<br>132.<br>133.<br>134.<br>135.<br>136.<br>137.<br>138.<br>139.<br>140.<br>141.<br>142.<br>143.<br>144.<br>145.<br>146.<br>147.<br>148.<br>149.<br>150.<br>151.<br>152.<br>153.<br>154.<br>155.<br>156.<br>157.<br>158.<br>159.<br>160.<br>161.<br>162.<br>163.<br>164.<br>165.<br>166.<br>167.<br>168.<br>169.<br>170.<br>171.<br>172.<br>173.<br>174.<br>175.<br>176.<br>177.<br>178.<br>179.<br>180.<br>181.<br>182.<br>183.<br>184.<br>185.<br>186.<br>187.<br>188.<br>189.<br>190.<br>191.<br>192.<br>193.<br>194.<br>195.<br>196.<br>197.<br>198.<br>199.<br>200.<br>201.<br>202.<br>203.<br>204.<br>205.<br>206.<br>207.<br>208.<br>209.<br>210.<br>211.<br>212.<br>213.<br>214.<br>215.<br>216.<br>217.<br>218.<br>219.<br>220.<br>221.<br>222.<br>223.<br>224.<br>225.<br>226.<br>227.<br>228.<br>229.<br>230.<br>231.<br>232.<br>233.<br>234.<br>235.<br>236.<br>237.<br>238.<br>239.<br>240.<br>241.<br>242.<br>243.<br>244.<br>245.<br>246.<br>247.<br>248.<br>249.<br>250.<br>251.<br>252.<br>253.<br>254.<br>255.<br>256.<br>257.<br>258.<br>259.<br>260.<br>261.<br>262.<br>263.<br>264.<br>265.<br>266.<br>267.<br>268.<br>269.<br>270.<br>271.<br>272.<br>273.<br>274.<br>275.<br>276.<br>277.<br>278.<br>279.<br>280.<br>281.<br>282.<br>283.<br>284.<br>285.<br>286.<br>287.<br>288.<br>289.<br>290.<br>291.<br>292.<br>293.<br>294.<br>295.<br>296.<br>297.<br>298.<br>299.<br>300.<br>301.<br>302.<br>303.<br>304.<br>305.<br>306.<br>307.<br>308.<br>309.<br>310.<br>311.<br>312.<br>313.<br>314.<br>315.<br>316.<br>317.<br>318.<br>319.<br>320.<br>321.<br>322.<br>323.<br>324.<br>325.<br>326.<br>327.<br>328.<br>329.<br>330.<br>331.<br>332.<br>333.<br>334.<br>335.<br>336.<br>337.<br>338.<br>339.<br>340.<br>341.<br>342.<br>343.<br>344.<br>345.<br>346.<br>347.<br>348.<br>349.<br>350.<br>351.<br>352.<br>353.<br>354.<br>355.<br>356.<br>357.<br>358.<br>359.<br>360.<br>361.<br>362.<br>363.<br>364.<br>365.<br>366.<br>367.<br>368.<br>369.<br>370.<br>371.<br>372.<br>373.<br>374.<br>375.<br>376.<br>377.<br>378.<br>379.<br>380.<br>381.<br>382.<br>383.<br>384.<br>385.<br>386.<br>387.<br>388.<br>389.<br>390.<br>391.<br>392.<br>393.<br>394.<br>395.<br>396.<br>397.<br>398.<br>399.<br>400.<br>401.<br>402.<br>403.<br>404.<br>405.<br>406.<br>407.<br>408.<br>409.<br>410.<br>411.<br>412.<br>413.<br>414.<br>415.<br>416.<br>417.<br>418.<br>419.<br>420.<br>421.<br>422.<br>423.<br>424.<br>425.<br>426.<br>427.<br>428.<br>429.<br>430.<br>431.<br>432.<br>433.<br>434.<br>435.<br>436.<br>437.<br>438.<br>439.<br>440.<br>441.<br>442.<br>443.<br>444.<br>445.<br>446.<br>447.<br>448.<br>449.<br>450.<br>451.<br>452.<br>453.<br>454.<br>455.<br>456.<br>457.<br>458.<br>459.<br>460.<br>461.<br>462.<br>463.<br>464.<br>465.<br>466.<br>467.<br>468.<br>469.<br>470.<br>471.<br>472.<br>473.<br>474.<br>475.<br>476.<br>477.<br>478.<br>479.<br>480.<br>481.<br>482.<br>483.<br>484.<br>485.<br>486.<br>487.<br>488.<br>489.<br>490.<br>491.<br>492.<br>493.<br>494.<br>495.<br>496.<br>497.<br>498.<br>499.<br>500.<br>501.<br>502.<br>503.<br>504.<br>505.<br>506.<br>507.<br>508.<br>509.<br>510.<br>511.<br>512.<br>513.<br>514.<br>515.<br>516.<br>517.<br>518.<br>519.<br>520.<br>521.<br>522.<br>523.<br>524.<br>525.<br>526.<br>527.<br>528.<br>529.<br>530.<br>531.<br>532.<br>533.<br>534.<br>535.<br>536.<br>537.<br>538.<br>539.<br>540.<br>541.<br>542.<br>543.<br>544.<br>545.<br>546.<br>547.<br>548.<br>549.<br>550.<br>551.<br>552.<br>553.<br>554.<br>555.<br>556.<br>557.<br>558.<br>559.<br>560.<br>561.<br>562.<br>563.<br>564.<br>565.<br>566.<br>567.<br>568.<br>569.<br>570.<br>571.<br>572.<br>573.<br>574.<br>575.<br>576.<br>577.<br>578.<br>579.<br>580.<br>581.<br>582.<br>583.<br>584.<br>585.<br>586.<br>587.<br>588.<br>589.<br>590.<br>591.<br>592.<br>593.<br>594.<br>595.<br>596.<br>597.<br>598.<br>599.<br>600.<br>601.<br>602.<br>603.<br>604.<br>605.<br>606.<br>607.<br>608.<br>609.<br>610.<br>611.<br>612.<br>613.<br>614.<br>615.<br>616.<br>617.<br>618.<br>619.<br>620.<br>621.<br>622.<br>623.<br>624.<br>625.<br>626.<br>627.<br>628.<br>629.<br>630.<br>631.<br>632.<br>633.<br>634.<br>635.<br>636.<br>637.<br>638.<br>639.<br>640.<br>641.<br>642.<br>643.<br>644.<br>645.<br>646.<br>647.<br>648.<br>649.<br>650.<br>651.<br>652.<br>653.<br>654.<br>655.<br>656.<br>657.<br>658.<br>659.<br>660.<br>661.<br>662.<br>663.<br>664.<br>665.<br>666.<br>667.<br>668.<br>669.<br>670.<br>671.<br>672.<br>673.<br>674.<br>675.<br>676.<br>677.<br>678.<br>679.<br>680.<br>681.<br>682.<br>683.<br>684.<br>685.<br>686.<br>687.<br>688.<br>689.<br>690.<br>691.<br>692.<br>693.<br>694.<br>695.<br>696.<br>697.<br>698.<br>699.<br>700.<br>701.<br>702.<br>703.<br>704.<br>705.<br>706.<br>707.<br>708.<br>709.<br>710.<br>711.<br>712.<br>713.<br>714.<br>715.<br>716.<br>717.<br>718.<br>719.<br>720.<br>721.<br>722.<br>723.<br>724.<br>725.<br>726.<br>727.<br>728.<br>729.<br>730.<br>731.<br>732.<br>733.<br>734.<br>735.<br>736.<br>737.<br>738.<br>739.<br>740.<br>741.<br>742.<br>743.<br>744.<br>745.<br>746.<br>747.<br>748.<br>749.<br>750.<br>751.<br>752.<br>753.<br>754.<br>755.<br>756.<br>757.<br>758.<br>759.<br>760.<br>761.<br>762.<br>763.<br>764.<br>765.<br>766.<br>767.<br>768.<br>769.<br>770.<br>771.<br>772.<br>773.<br>774.<br>775.<br>776.<br>777.<br>778.<br>779.<br>780.<br>781.<br>782.<br>783.<br>784.<br>785.<br>786.<br>787.<br>788.<br>789.<br>790.<br>791.<br>792.<br>793.<br>794.<br>795.<br>796.<br>797.<br>798.<br>799.<br>800.<br>801.<br>802.<br>803.<br>804.<br>805.<br>806.<br>807.<br>808.<br>809.<br>810.<br>811.<br>812.<br>813.<br>814.<br>815.<br>816.<br>817.<br>818.<br>819.<br>820.<br>821.<br>822.<br>823.<br>824.<br>825.<br>826.<br>827.<br>828.<br>829.<br>830.<br>831.<br>832.<br>833.<br>834.<br>835.<br>836.<br>837.<br>838.<br>839.<br>840.<br>841.<br>842.<br>843.<br>844.<br>845.<br>846.<br>847.<br>848.<br>849.<br>850.<br>851.<br>852.<br>853.<br>854.<br>855.<br>856.<br>857.<br>858.<br>859.<br>860.<br>861.<br>862.<br>863.<br>864.<br>865.<br>866.<br>867.<br>868.<br>869.<br>870.<br>871.<br>872.<br>873.<br>874.<br>875.<br>876.<br>877.<br>878.<br>879.<br>880.<br>881.<br>882.<br>883.<br>884.<br>885.<br>886.<br>887.<br>888.<br>889.<br>890.<br>891.<br>892.<br>893.<br>894.<br>895.<br>896.<br>897.<br>898.<br>899.<br>900.<br>901.<br>902.<br>903.<br>904.<br>905.<br>906.<br>907.<br>908.<br>909.<br>910.<br>911.<br>912.<br>913.<br>914.<br>915.<br>916.<br>917.<br>918.<br>919.<br>920.<br>921.<br>922.<br>923.<br>924.<br>925.<br>926.<br>927.<br>928.<br>929.<br>930.<br>931.<br>932.<br>933.<br>934.<br>935.<br>936.<br>937.<br>938.<br>939.<br>940.<br>941.<br>942.<br>943.<br>944.<br>945.<br>946.<br>947.<br>948.<br>949.<br>950.<br>951.<br>952.<br>953.<br>954.<br>955.<br>956.<br>957.<br>958.<br>959.<br>960.<br>961.<br>962.<br>963.<br>964.<br>965.<br>966.<br>967.<br>968.<br>969.<br>970.<br>971.<br>972.<br>973.<br>974.<br>975.<br>976.<br>977.<br>978.<br>979.<br>980.<br>981.<br>982.<br>983.<br>984.<br>985.<br>986.<br>987.<br>988.<br>989.<br>990.<br>991.<br>992.<br>993.<br>994.<br>995.<br>996.<br>997.<br>998.<br>999.<br>1000.<br>1001.<br>1002.<br>1003.<br>1004.<br>1005.<br>1006.<br>1007.<br>1008.<br>1009.<br>1010.<br>1011.<br>1012.<br>1013.<br>1014.<br>1015.<br>1016.<br>1017.<br>1018.<br>1019.<br>1020.<br>1021.<br>1022.<br>1023.<br>1024.<br>1025.<br>1026.<br>1027.<br>1028.<br>1029.<br>1030.<br>1031.<br>1032.<br>1033.<br>1034.<br>1035.<br>1036.<br>1037.<br>1038.<br>1039.<br>1040.<br>1041.<br>1042.<br>1043.<br>1044.<br>1045.<br>1046.<br>1047.<br>1048.<br>1049.<br>1050.<br>1051.<br>1052.<br>1053.<br>1054.<br>1055.<br>1056.<br>1057.<br>1058.<br>1059.<br>1060.<br>1061.<br>1062.<br>1063.<br>1064.<br>1065.<br>1066.<br>1067.<br>1068.<br>1069.<br>1070.<br>1071.<br>1072.<br>1073.<br>1074.<br>1075.<br>1076.<br>1077.<br>1078.<br>1079.<br>1080.<br>1081.<br>1082.<br>1083.<br>1084.<br>1085.<br>1086.<br>1087.<br>1088.<br>1089.<br>1090.<br>1091.<br>1092.<br>1093.<br>1094.<br>1095.<br>1096.<br>1097.<br>1098.<br>1099.<br>1100.<br>1101.<br>1102.<br>1103.<br>1104.<br>1105.<br>1106.<br>1107.<br>1108.<br>1109.<br>1110.<br>1111.<br>1112.<br>1113.<br>1114.<br>1115.<br>1116.<br>1117.<br>1118.<br>1119.<br>1120.<br>1121.<br>1122.<br>1123.<br>1124.<br>1125.<br>1126.<br>1127.<br>1128.<br>1129.<br>1130.<br>1131.<br>1132.<br>1133.<br>1134.<br>1135.<br>1136.<br>1137.<br>1138.<br>1139.<br>1140.<br>1141.<br>1142.<br>1143.<br>1144.<br>1145.<br>1146.<br>1147.<br>1148.<br>1149.<br>1150.<br>1151.<br>1152.<br>1153.<br>1154.<br>1155.<br>1156.<br>1157.<br>1158.<br>1159.<br>1160.<br>1161.<br>1162.<br>1163.<br>1164.<br>1165.<br>1166.<br>1167.<br>1168.<br>1169.<br>1170.<br>1171.<br>1172.<br>1173.<br>1174.<br>1175.<br>1176.<br>1177.<br>1178.<br>1179.<br>1180.<br>1181.<br>1182.<br>1183.<br>1184.<br>1185.<br>1186.<br>1187.<br>1188.<br>1189.<br>1190.<br>1191.<br>1192.<br>1193.<br>1194.<br>1195.<br>1196.<br>1197.<br>1198.<br>1199.<br>1200.<br>1201.<br>1202.<br>1203.<br>1204.<br>1205.<br>1206.<br>1207.<br>1208.<br>1209.<br>1210.<br>1211.<br>1212.<br>1213.<br>1214.<br>1215.<br>1216.<br>1217.<br>1218.<br>1219.<br>1220.<br>1221.<br>1222.<br>1223.<br>1224.<br>1225.<br>1226.<br>1227.<br>1228.<br>1229.<br>1230.<br>1231.<br>1232.<br>1233.<br>1234.<br>1235.<br>1236.<br>1237.<br>1238.<br>1239.<br>1240.<br>1241.<br>1242.<br>1243.<br>1244.<br>1245.<br>1246.<br>1247.<br>1248.<br>1249.<br>1250.<br>1251.<br>1252.<br>1253.<br>1254.<br>1255.<br>1256.<br>1257.<br>1258.<br>1259.<br>1260.<br>1261.<br>1262.<br>1263.<br>1264.<br>1265.<br>1266.<br>1267.<br>1268.<br>1269.<br>1270.<br>1271.<br>1272.<br>1273.<br>1274.<br>1275.<br>1276.<br>1277.<br>1278.<br>1279.<br>1280.<br>1281.<br>1282.<br>1283.<br>1284.<br>1285.<br>1286.<br>1287.<br>1288.<br>1289.<br>1290.<br>1291.<br>1292.<br>1293.<br>1294.<br>1295.<br>1296.<br>1297.<br>1298.<br>1299.<br>1300.<br>1301.<br>1302.<br>1303.<br>1304.<br>1305.<br>1306.<br>1307.<br>1308.<br>1309.<br>1310.<br>1311.<br>1312.<br>1313.<br>1314.<br>1315.<br>1316.<br>1317.<br>1318.<br>1319.<br>1320.<br>1321.<br>1322.<br>1323.<br>1324.<br>1325.<br>1326.<br>1327.<br>1328.<br>1329.<br>1330.<br>1331.<br>1332.<br>1333.<br>1334.<br>1335.<br>1336.<br>1337.<br>1338.<br>1339.<br>1340.<br>1341.<br>1342.<br>1343.<br>1344.<br>1345.<br>1346.<br>1347.<br>1348.<br>1349.<br>1350.<br>1351.<br>1352.<br>1353.<br>1354.<br>1355.<br>1356.<br>1357.<br>1358.<br>1359.<br>1360.<br>1361.<br>1362.<br>1363.<br>1364.<br>1365.<br>1366.<br>1367.<br>1368.<br>1369.<br>1370.<br>1371.<br>1372.<br>1373.<br>1374.<br>1375.<br>1376.<br>1377.<br>1378.<br>1379.<br>1380.<br>1381.<br>1382.<br>1383.<br>1384.<br>1385.<br>1386.<br>1387.<br>1388.<br>1389.<br>1390.<br>1391.<br>1392.<br>1393.<br>1394.<br>1395.<br>1396.<br>1397.<br>1398.<br>1399.<br>1400.<br>1401.<br>1402.<br>1403.<br>1404.<br>1405.<br>1406.<br>1407.<br>1408.<br>1409.<br>1410.<br>1411.<br>1412.<br>1413.<br>1414.<br>1415.<br>1416.<br>1417.<br>1418.<br>1419.<br>1420.<br>1421.<br>1422.<br>1423.<br>1424.<br>1425.<br>1426.<br>1427.<br>1428.<br>1429.<br>1430.<br>1431.<br>1432.<br>1433.<br>1434.<br>1435.<br>1436.<br>1437.<br>1438.<br>1439.<br>1440.<br>1441.<br>1442.<br>1443.<br>1444.<br>1445.<br>1446.<br>1447.<br>1448.<br>1449.<br>1450.<br>1451.<br>1452.<br>1453.<br>1454.<br>1455.<br>1456.<br>1457.<br>1458.<br>1459.<br>1460.<br>1461.<br>1462.<br>1463.<br>1464.<br>1465.<br>1466.<br>1467.<br>1468.<br>1469.<br>1470.<br>1471.<br>1472.<br>1473.<br>1474.<br>1475.<br>1476.<br>1477.<br>1478.<br>1479.<br>1480.<br>1481.<br>1482.<br>1483.<br>1484.<br>1485.<br>1486.<br>1487.<br>1488.<br>1489.<br>1490.<br>1491.<br>1492.<br>1493.<br>1494.<br>1495.<br>1496.<br>1497.<br>1498.<br>1499.<br>1500.<br>1501.<br>1502.<br>1503.<br>1504.<br>1505.<br>1506.<br>1507.<br>1508.<br>1509.<br>1510.<br>1511.<br>1512.<br>1513.<br>1514.<br>1515.<br>1516.<br>1517.<br>1518.<br>1519.<br>1520.<br>1521.<br>1522.<br>1523.<br>1524.<br>1525.<br>1526.<br>1527.<br>1528.<br>1529.<br>1530.<br>1531.<br>1532.<br>1533.<br>1534.<br>1535.<br>1536.<br>1537.<br>1538.<br>1539.<br>1540.<br>1541.<br>1542.<br>1543.<br>1544.<br>1545.<br>1546.<br>1547.<br>1548.<br>1549.<br>1550.<br>1551.<br>1552.<br>1553.<br>1554.<br>1555.<br>1556.<br>1557.<br>1558.<br>1559.<br>1560.<br>1561.<br>1562.<br>1563.<br>1564.<br>1565.<br>1566.<br>1567.<br>1568.<br>1569.<br>1570.<br>1571.<br>1572.<br>1573.<br>1574.<br>1575.<br>1576.<br>1577.<br>1578.<br>1579.<br>1580.<br>1581.<br>1582.<br>1583.<br>1584.<br>1585.<br>1586.<br>1587.<br>1588.<br>1589.<br>1590.<br>1591.<br>1592.<br>1593.<br>1594.<br>1595.<br>1596.<br>1597.<br>1598.<br>1599.<br>1600.<br>1601.<br>1602.<br>1603.<br>1604.<br>1605.<br>1606.<br>1607.<br>1608.<br>1609.<br>1610.<br>1611.<br>1612.<br>1613.<br>1614.<br>1615.<br>1616.<br>1617.<br>1618.<br>1619.<br>1620.<br>1621.<br>1622.<br>1623.<br>1624.<br>1625.<br>1626.<br>1627.<br>1628.<br>1629.<br>1630.<br>1631.<br>1632.<br>1633.<br>1634.<br>1635.<br>1636.<br>1637.<br>1638.<br>1639.<br>1640.<br>1641.<br>1642.<br>1643.<br>1644.<br>1645.<br>1646.<br>1647.<br>1648.<br>1649.<br>1650.<br>1651.<br>1652.<br>1653.<br>1654.<br>1655.<br>1656.<br>1657.<br>1658.<br>1659.<br>1660.<br>1661.<br>1662.<br>1663.<br>1664.<br>1665.<br>1666.<br>1667.<br>1668.<br>1669.<br>1670.<br>1671.<br>1672.<br>1673.<br>1674.<br>1675.<br>1676.<br>1677.<br>1678.<br>1679.<br>1680.<br>1681.<br>1682.<br>1683.<br>1684.<br>1685.<br>1686.<br>1687.<br>1688.<br>1689.<br>1690.<br>1691.<br>1692.<br>1693.<br>1694.<br>1695.<br>1696.<br>1697.<br>1698.<br>1699.<br>1700.<br>1701.<br>1702.<br>1703.<br>1704.<br>1705.<br>1706.<br>1707.<br>1708.<br>1709.<br>1710.<br>1711.<br>1712.<br>1713.<br>1714.<br>1715.<br>1716.<br>1717.<br>1718.<br>1719.<br>1720.<br>1721.<br>1722.<br>1723.<br>1724.<br>1725.<br>1726.<br>1727.<br>1728.<br>1729.<br>1730.<br>1731.<br>1732.<br>1733.<br>1734.<br>1735.<br>1736.<br>1737.<br>1738.<br>1739.<br>1740.<br>1741.<br>1742.<br>1743.<br>1744.<br>1745.<br>1746.<br>1747.<br>1748.<br>1749.<br>1750.<br>1751.<br>1752.<br>1753.<br>1754.<br>1755.<br>1756.<br>1757.<br>1758.<br>1759.<br>1760.<br>1761.<br>1762.<br>1763.<br>1764.<br>1765.<br>1766.<br>1767.<br>1768.<br>1769.<br>1770.<br>1771.<br>1772.<br>1773.<br>1774.<br>1775.<br>1776.<br>1777.<br>1778.<br>1779.<br>1780.<br>1781.<br>1782.<br>1783.<br>1784.<br>1785.<br>1786.<br>1787.<br>1788.<br>1789.<br>1790.<br>1791.<br>1792.<br>1793.<br>1794.<br>1795.<br>1796.<br>1797.<br>1798.<br>1799.<br>1800.<br>1801.<br>1802.<br>1803.<br>1804.<br>1805.<br>1806.<br>1807.<br>1808.<br>1809.<br>1810.<br>1811.<br>1812.<br>1813.<br>1814.<br>1815.<br>1816.<br>1817.<br>1818.<br>1819.<br>1820.<br>1821.<br>1822.<br>1823.<br>1824.<br>1825.<br>1826.<br>1827.<br>1828.<br>1829.<br>1830.<br>1831.<br>1832.<br>1833.<br>1834.<br>1835.<br>1836.<br>1837.<br>1838.<br>1839.<br>1840.<br>1841.<br>1842.<br>1843.<br>1844.<br>1845.<br>1846.<br>1847.<br>1848.<br>1849.<br>1850.<br>1851.<br>1852.<br>1853.<br>1854.<br>1855.<br>1856.<br>1857.<br>1858.<br>1859.<br>1860.<br>1861.<br>1862.<br>1863.<br>1864.<br>1865.<br>1866.<br>1867.<br>1868.<br>1869.<br>1870.<br>1871.<br>1872.<br>1873.<br>1874.<br>1875.<br>1876.<br>1877.<br>1878.<br>1879.<br>1880.<br>1881.<br>1882.<br>1883.<br>1884.<br>1885.<br>1886.<br>1887.<br>1888.<br>1889.<br>1890.<br>1891.<br>1892.<br>1893.<br>1894.<br>1895.<br>1896.<br>1897.<br>1898.<br>1899.<br>1900.<br>1901.<br>1902.<br>1903.<br>1904.<br>1905.<br>1906.<br>1907.<br>1908.<br>1909.<br>1910.<br>1911.<br>1912.<br>1913.<br>1914.<br>1915.<br>1916.<br>1917.<br>1918.<br>1919.<br>1920.<br>1921.<br>1922.<br>1923.<br>1924.<br>1925.<br>1926.<br>1927.<br>1928.<br>1929.<br>1930.<br>1931.<br>1932.<br>1933.<br>1934.<br>1935.<br>1936.<br>1937.<br>1938.<br>1939.<br>1940.<br>1941.<br>1942.<br>1943.<br>1944.<br>1945.<br>1946.<br>1947.<br>1948.<br>1949.<br>1950.<br>1951.<br>1952.<br>1953.<br>1954.<br>1955.<br>1956.<br>1957.<br>1958.<br>1959.<br>1960.<br>1961.<br>1962.<br>1963.<br>1964.<br>1965.<br>1966.<br>1967.<br>1968.<br>1969.<br>1970.<br>1971.<br>1972.<br>1973.<br>1974.<br>1975.<br>1976.<br>1977.<br>1978.<br>1979.<br>1980.<br>1981.<br>1982.<br>1983.<br>1984.<br>1985.<br>1986.<br>1987.<br>1988.<br>1989.<br>1990.<br>1991.<br>1992.<br>1993.<br>1994.<br>1995.<br>1996.<br>1997.<br>1998.<br>1999.<br>2000.<br>2001.<br>2002.<br>2003.<br>2004.<br>2005.<br>2006.<br>2007.<br>2008.<br>2009.<br>2010.<br>2011.<br>2012.<br>2013.<br>2014.<br>2015.<br>2016.<br>2017.<br>2018.<br>2019.<br>2020.<br>2021.<br>2022.<br>2023.<br>2024.<br>2025.<br>2026.<br>2027.<br>2028.<br>2029.<br>2030.<br>2031.<br>2032.<br>2033.<br>2034.<br>2035.<br>2036.<br>2037.<br>2038.<br>2039.<br>2040.<br>2041.<br>2042.<br>2043.<br>2044.<br>2045.<br>2046.<br>2047.<br>2048.<br>2049.<br>2050.<br>2051.<br>2052.<br>2053.<br>2054.<br>2055.<br>2056.<br>2057.<br>2058.<br>2059.<br>2060.<br>2061.<br>2062.<br>2063.<br>2064.<br>2065.<br>2066.<br>2067.<br>2068.<br>2069.<br>2070.<br>2071.<br>2072.<br>2073.<br>2074.<br>2075.<br>2076.<br>2077.<br>2078.<br>2079.<br>2080.<br>2081.<br>2082.<br>2083.<br>2084.<br>2085.<br>2086.<br>2087.<br>2088.<br>2089.<br>2090.<br>2091.<br>2092.<br>2093.<br>2094.<br>2095.<br>2096.<br>2097.<br>2098.<br>2099.<br>2100.<br>2101.<br>2102.<br>2103.<br>2104.<br>2105.<br>2106.<br>2107.<br>2108.<br>2109.<br>2110.<br>2111.<br>2112.<br>2113.<br>2114.<br>2115.<br>2116.<br>2117.<br>2118.<br>2119.<br>2120.<br>2121.<br>2122.<br>2123.<br>2124.<br>2125.<br>2126.<br>2127.<br>2128.<br>2129.<br>2130.<br>2131.<br>2132.<br>2133.<br>2134.<br>2135.<br>2136.<br>2137.<br>2138.<br>2139.<br>2140.<br>2141.<br>2142.<br>2143.<br>2144.<br>2145.<br>2146.<br>2147.<br>2148.<br>2149.<br>2150.<br>2151.<br>2152.<br>2153.<br>2154.<br>2155.<br>2156.<br>2157.<br>2158.<br>2159.<br>2160.<br>2161.<br>2162.<br>2163.<br>2164.<br>2165.<br>2166.<br>2167.<br>2168.<br>2169.<br>2170.<br>2171.<br>2172.<br>2173.<br>2174.<br>2175.<br>2176.<br>2177.<br>2178.<br>2179.<br>2180.<br>2181.<br>2182.<br>2183.<br>2184.<br>2185.<br>2186.<br>2187.<br>2188.<br>2189.<br>2190.<br>2191.<br>2192.<br>2193.<br>2194.<br>2195.<br>2196.<br>2197.<br>2198.<br>2199.<br>2200.<br>2201.<br>2202.<br>2203.<br>2204.<br>2205.<br>2206.<br>2207.<br>2208.<br>2209.<br>2210.<br>2211.<br>2212.<br>2213.<br>2214.<br>2215.<br>2216.<br>2217.<br>2218.<br>2219.<br>2220.<br>2221.<br>2222.<br>2223.<br>2224.<br>2225.<br>2226.<br>2227.<br>2228.<br>2229.<br>2230.<br>2231.<br>2232.<br>2233.<br>2234.<br>2235.<br>2236.<br>2237.<br>2238.<br>2239.<br>2240.<br>2241.<br>2242.<br>2243.<br>2244.<br>2245.<br>2246.<br>2247.<br>2248.<br>2249.<br>2250.<br>2251.<br>2252.<br>2253.<br>2254.<br>2255.<br>2256.<br>2257.<br>2258.<br>2259.<br>2260.<br>2261.<br>2262.<br>2263.<br>2264.<br>2265.<br>2266.<br>2267.<br>2268.<br>2269.<br>2270.<br>2271.<br>2272.<br>2273.<br>2274.<br>2275.<br>2276.<br>2277.<br>2278.<br>2279.<br>2280.<br>2281.<br>2282.<br>2283.<br>2284.<br>2285.<br>2286.<br>2287.<br>2288.<br>2289.<br>2290.<br>2291.<br>2292.<br>2293.<br>2294.<br>2295.<br>2296.<br>2297.<br>2298.<br>2299.<br>2300.<br>2301.<br>2302.<br>2303.<br>2304.<br>2305.<br>2306.<br>2307.<br>2308.<br>2309.<br>2310.<br>2311.<br>2312.<br>2313.<br>2314.<br>2315.<br>2316.<br>2317.<br>2318.<br>2319.<br>2320.<br>2321.<br>2322.<br>2323.<br>2324.<br>2325.<br>2326.<br>2327.<br>2328.<br>2329.<br>2330.<br>2331.<br>2332.<br>2333.<br>2334.<br>2335.<br>2336.<br>2337.<br>2338.<br>2339.<br>2340.<br>2341.<br>2342.<br>2343.<br>2344.<br>2345.<br>2346.<br>2347.<br>2348.<br>2349.<br>2350.<br>2351.<br>2352.<br>2353.<br>2354.<br>2355.<br>2356.<br>2357.<br>2358.<br>2359.<br>2360.<br>2361.<br>2362.<br>2363.<br>2364.<br>2365.<br>2366.<br>2367.<br>2368.<br>2369.<br>2370.<br>2371.<br>2372.<br>2373.<br>2374.<br>2375.<br>2376.<br>2377.<br>2378.<br>2379.<br>2380.<br>2381.<br>2382.<br>2383.<br>2384.<br>2385.<br>2386.<br>2387.<br>2388.<br>2389.<br>2390.<br>2391.<br>2392.<br>2393.<br>2394.<br>2395.<br>2396.<br>2397.<br>2398.<br>2399.<br>2400.<br>2401.<br>2402.<br>2403.<br>2404.<br>2405.<br>2406.<br>2407.<br>2408.<br>2409.<br>2410.<br>2411.<br>2412.<br>2413.<br>2414.<br>2415.<br>2416.<br>2417.<br>2418.<br>2419.<br>2420.<br>2421.<br>2422.<br>2423.<br>2424.<br>2425.<br>2426.<br>2427.<br>2428.<br>2429.<br>2430.<br>2431.<br>2432.<br>2433.<br>2434.<br>2435.<br>2436.<br>2437.<br>2438.<br>2439.<br>2440.<br>2441.<br>2442.<br>2443.<br>2444.<br>2445.<br>2446.<br>2447.<br>2448.<br>2449.<br>2450.<br>2451.<br>2452.<br>2453.<br>2454.<br>2455.<br>2456.<br>2457.<br>2458.<br>2459.<br>2460.<br>2461.<br>2462.<br>2463.<br>2464.<br>2465.<br>2466.<br>2467.<br>2468.<br>2469.<br>2470.<br>2471.<br>2472.<br>2473.<br>2474.<br>2475.<br>2476.<br>2477.<br>2478.<br>2479.<br>2480.<br>2481.<br>2482.<br>2483.<br>2484.<br>2485.<br>2486.<br>2487.<br>2488.<br>2489.<br>2490.<br>2491.<br>2492.<br>2493.<br>2494.<br>2495.<br>2496.<br>2497.<br>2498.<br>2499.<br>2500.<br>2501.<br>2502.<br>2503.<br>2504.<br>2505.<br>2506.<br>2507.<br>2508.<br>2509.<br>2510.<br>2511.<br>2512.<br>2513.<br>2514.<br>2515.<br>2516.<br>2517.<br>2518.<br>2519.<br>2520.<br>2521.<br>2522.<br>2523.<br>2524.<br>2525.<br>2526.<br>2527.<br>2528.<br>2529.<br>2530.<br>2531.<br>2532.<br>2533.<br>2534.<br>2535.<br>2536.<br>2537.<br>2538.<br>2539.<br>2540.<br>2541.<br>2542.<br>2543.<br>2544.<br>2545.<br>2546.<br>2547.<br>2548.<br>2549.<br>2550.<br>2551.<br>2552.<br>2553.<br>2554.<br>2555.<br>2556.<br>2557.<br>2558.<br>2559.<br>2560.<br>2561.<br>2562.<br>2563.<br>2564.<br>2565.<br>2566.<br>2567.<br>2568.<br>2569.<br>2570.<br>2571.<br>2572.<br>2573.<br>2574.<br>2575.<br>2576.<br>2577.<br>2578.<br>2579.<br>2580.<br>2581.<br>2582.<br>2583.<br>2584.<br>2585.<br>2586.<br>2587.<br>2588.<br>2589.<br>2590.<br>2591.<br>2592.<br>2593.<br>2594.<br>2595.<br>2596.<br>2597.<br>2598.<br>2599.<br>2600.<br>2601.<br>2602.<br>2603.<br>2604.<br>2605.<br>2606.<br>2607.<br>2608.<br>2609.<br>2610.<br>2611.<br>2612.<br>2613.<br>2614.<br>2615.<br>2616.<br>2617.<br>2618.<br>2619.<br>2620.<br>2621.<br>2622.<br>2623.<br>2624.<br>2625.<br>2626.<br>2627.<br>2628.<br>2629.<br>2630.<br>2631.<br>2632.<br>2633.<br>2634.<br>2635.<br>2636.<br>2637.<br>2638.<br>2639.<br>2640.<br>2641.<br>2642.<br>2643.<br>2644.<br>2645.<br>2646.<br>2647.<br>2648.<br>2649.<br>2650.<br>2651.<br>2652.<br>2653.<br>2654.<br>2655.<br>2656.<br>2657.<br>2658.<br>2659.<br>2660.<br>2661.<br>2662.<br>2663.<br>2664.<br>2665.<br>2666.<br>2667.<br>2668.<br>2669.<br>2670.<br>2671.<br>2672.<br>2673.<br>2674.<br>2675.<br>2676.<br>2677.<br>2678.<br>2679.<br>2680.<br>2681.<br>2682.<br>2683.<br>2684.<br>2685.<br>2686.<br>2687.<br>2688.<br>2689.<br>2690.<br>2691.<br>2692.<br>2693.<br>2694.<br>2695.<br>2696.<br>2697.<br>2698.<br>2699.<br>2700.<br>2701.<br>2702.<br>2703.<br>2704.<br>2705.<br>2706.<br>2707.<br>2708.<br>2709.<br>2710.<br>2711.<br>2712.<br>2713.<br>2714.<br>2715.<br>2716.<br>2717.<br>2718.<br>2719.<br>2720.<br>2721.<br>2722.<br>2723.<br>2724.<br>2725.<br>2726.<br>2727.<br>2728.<br>2729.<br>2730.<br>2731.<br>2732.<br>2733.<br>2734.<br>2735.<br>2736.<br>2737.<br>2738.<br>2739.<br>2740.<br>2741.<br>2742.<br>2743.<br>2744.<br>2745.<br>2746.<br>2747.<br>2748.<br>2749.<br>2750.<br>2751.<br>2752.<br>2753.<br>2754.<br>2755.<br>2756.<br>2757.<br>2758.<br>2759.<br>2760.<br>2761.<br>2762.<br>2763.<br>2764.<br>2765.<br>2766.<br>2767.<br>2768.<br>2769.<br>2770.<br>2771.<br>2772.<br>2773.<br>2774.<br>2775.<br>2776.<br>2777.<br>2778.<br>2779.<br>2780.<br>2781.<br>2782.<br>2783.<br>2784.<br>2785.<br>2786.<br>2787.<br>2788.<br>2789.<br>2790.<br>2791.<br>2792.<br>2793.<br>2794.<br>2795.<br>2796.<br>2797.<br>2798.<br>2799.<br>2800.<br>2801.<br>2802.<br>2803.<br>2804.<br>2805.<br>2806.<br>2807.<br>2808.<br>2809.<br>2810.<br>2811.<br>2812.<br>2813.<br>2814.<br>2815.<br>2816.<br>2817.<br>2818.<br>2819.<br>2820.<br>2821.<br>2822.<br>2823.<br>2824.<br>2825.<br>2826.<br>2827.<br>2828.<br>2829.<br>2830.<br>2831.<br>2832.<br>2833.<br>2834.<br>2835.<br>2836.<br>2837.<br>2838.<br>2839.<br>2840.<br>2841.<br>2842.<br>2843.<br>2844.<br>2845.<br>2846.<br>2847.<br>2848.<br>2849.<br>2850.<br>2851.<br>2852.<br>2853.<br>2854.<br>2855.<br>2856.<br>2857.<br>2858.<br>2859.<br>2860.<br>2861.<br>2862.<br>2863.<br>2864.<br>2865.<br>2866.<br>2867.<br>2868.<br>2869.<br>2870.<br>2871.<br>2872.<br>2873.<br>2874.<br>2875.<br>2876.<br>2877.<br>2878.<br>2879.<br>2880.<br>2881.<br>2882.<br>2883.<br>2884.<br>2885.<br>2886.<br>2887.<br>2888.<br>2889.<br>2890.<br>2891.<br>2892.<br>2893.<br>2894.<br>2895.<br>2896.<br>2897.<br>2898.<br>2899.<br>2900.<br>2901.<br>2902.<br>2903.<br>2904.<br>2905.<br>2906.<br>2907.<br>2908.<br>2909.<br>2910.<br>2911.<br>2912.<br>2913.<br>2914.<br>2915.<br>2916.<br>2917.<br>2918.<br>2919.<br>2920.<br>2921.<br>2922.<br>2923.<br>2924.<br>2925.<br>2926.<br>2927.<br>2928.<br>2929.<br>2930.<br>2931.<br>2932.<br>2933.<br>2934.<br>2935.<br>2936.<br>2937.<br>2938.<br>2939.<br>2940.<br>2941.<br>2942.<br>2943.<br>2944.<br>2945.<br>2946.<br>2947.<br>2948.<br>2949.<br>2950.<br>2951.<br>2952.<br>2953.<br>2954.<br>2955.<br>2956.<br>2957.<br>2958.<br>2959.<br>2960.<br>2961.<br>2962.<br>2963.<br>2964.<br>2965.<br>2966.<br>2967.<br>2968.<br>2969.<br>2970.<br>2971.<br>2972.<br>2973.<br>2974.<br>2975.<br>2976.<br>2977.<br>2978.<br>2979.<br>2980.<br>2981.<br>2982.<br>2983.<br>2984.<br>2985.<br>2986.<br>2987.<br>2988.<br>2989.<br>2990.<br>2991.<br>2992.<br>2993.<br>2994.<br>2995.<br>2996.<br>2997.<br>2998.<br>2999.<br>3000.<br>3001.<br>3002.<br>3003.<br>3004.<br>3005.<br>3006.<br>3007.<br>3008.<br>3009.<br>3010.<br>3011.<br>3012.<br>3013.<br>3014.<br>3015.<br>3016.<br>3017.<br>3018.<br>3019.<br>3020.<br>3021.<br>3022.<br>3023.<br>3024.<br>3025.<br>3026.<br>3027.<br>3028.<br>3029.<br>3030.<br>3031.<br>3032.<br>3033.<br>3034.<br>3035.<br>3036.<br>3037.<br>3038.<br>3039.<br>3040.<br>3041.<br>3042.<br>3043.<br>3044.<br>3045.<br>3046.<br>3047.<br>3048.<br>3049.<br>3050.<br>3051.<br>3052.<br>3053.<br>3054.<br>3055.<br>3056.<br>3057.<br>3058.<br>3059.<br>3060.<br>3061.<br>3062.<br>3063.<br>3064.<br>3065.<br>3066.<br>3067.<br>3068.<br>3069.<br>3070.<br>3071.<br>3072.<br>3073.<br>3074.<br>3075.<br>3076.<br>3077.<br>3078.<br>3079.<br>3080.<br>3081.<br>3082.<br>3083.<br>3084.<br>3085.<br>3086.<br>3087.<br>3088.<br>3089.<br>3090.<br>3091.<br>3092.<br>3093.<br>3094.<br>3095.<br>3096.<br>3097.<br>3098.<br>3099.<br>3100.<br>3101.<br>3102.<br>3103.<br>3104.<br>3105.<br>3106.<br>3107.<br>3108.<br>3109.<br>3110.<br>3111.<br>3112.<br>3113.<br>3114.<br>3115.<br>3116.<br>3117.<br>3118.<br>3119.<br>3120.<br>3121.<br>3122.<br>3123.<br>3124.<br>3125.<br>3126.<br>3127.<br>3128.<br>3129.<br>3130.<br>3131.<br>3132.<br>3133.<br>3134.<br>3135.<br>3136.<br>3137.<br>3138.<br>3139.<br>3140.<br>3141.<br>3142.<br>3143.<br>3144.<br>3145.<br>3146.<br>3147.<br>3148.<br>3149.<br>3150.<br>3151.<br>3152.<br>3153.<br>3154.<br>3155.<br>3156.<br>3157.<br>3158.<br>3159.<br>3160.<br>3161.<br>3162.<br>3163.<br>3164.<br>3165.<br>3166.<br>3167.<br>3168.<br>3169.<br>3170.<br>3171.<br>3172.<br>3173.<br>3174.<br>3175.<br>3176.<br>3177.<br>3178.<br>3179.<br>3180.<br>3181.<br>3182.<br>3183.<br>3184.<br>3185.<br>3186.<br>3187.<br>3188.<br>3189.<br>3190.<br>3191.<br>3192.<br>3193.<br>3194.<br>3195.<br>3196.<br>3197.<br>3198.<br>3199.<br>3200.<br>3201.<br>3202.<br>3203.<br>3204.<br>3205.<br>3206.<br>3207.<br>3208.<br>3209.<br>3210.<br>3211.<br>3212.<br>3213.<br>3214.<br>3215.<br>3216.<br>3217.<br>3218.<br>3219.<br>3220.<br>3221.<br>3222.<br>3223.<br>3224.<br>3225.<br>3226.<br>3227.<br>3228.<br>3229.<br>3230.<br>3231.<br>3232.<br>3233.<br>3234.<br>3235.<br>3236.<br>3237.<br>3238.<br>3239.<br>3240.<br>3241.<br>3242.<br>3243.<br>3244.<br>3245.<br>3246.<br>3247.<br>3248.<br>3249.<br>3250.<br>3251.<br>3252.<br>3253.<br>3254.<br>3255.<br>3256.<br>3257.<br>3258.<br>3259.<br>3260.<br>3261.<br>3262.<br>3263.<br>3264.<br>3265.<br>3266.<br>3267.<br>3268.<br>3269.<br>3270.<br>3271.<br>3272.<br>3273.<br>3274.<br>3275.<br>3276.<br>3277.<br>3278.<br>3279.<br>3280.<br>3281.<br>3282.<br>3283.<br>3284.<br>3285.<br>3286.<br>3287.<br>3288.<br>3289.<br>3290.<br>3291.<br>3292.<br>3293.<br>3294.<br>3295.<br>3296.<br>3297.<br>3298.<br>3299.<br>3300.<br>3301.<br>3302.<br>3303.<br>3304.<br>3305.<br>3306.<br>3307.<br>3308.<br>3309.<br>3310.<br>3311.<br>3312.<br>3313.<br>3314.<br>3315.<br>3316.<br>3317.<br>3318.<br>3319.<br>3320.<br>3321.<br>3322.<br>3323.<br>3324.<br>3325.<br>3326.<br>3327.<br>3328.<br>3329.<br>3330.<br>3331.<br>3332.<br>3333.<br>3334.<br>3335.<br>3336.<br>3337.<br>3338.<br>3339.<br>3340.<br>3341.<br>3342.<br>3343.<br>3344.<br>3345.<br>3346.<br>3347.<br>3348.<br>3349.<br>3350.<br>3351.<br>3352.<br>3353.<br>3354.<br>3355.<br>3356.<br>3357.<br>3358.<br>3359.<br>3360.<br>3361.<br>3362.<br>3363.<br>3364.<br>3365.<br>3366.<br>3367.<br>3368.<br>3369.<br>3370.<br>3371.<br>3372.<br>3373.<br>3374.<br>3375.<br>3376.<br>3377.<br>3378.<br>3379.<br>3380.<br>3381.<br>3382.<br>3383.<br>3384.<br>3385.<br>3386.<br>3387.<br>3388.<br>3389.<br>3390.<br>3391.<br>3392.<br>3393.<br>3394.<br>3395.<br>3396.<br>3397.<br>3398.<br>3399.<br>3400.<br>3401.<br>3402.<br>3403.<br>3404.<br>3405.<br>3406.<br>3407.<br>3408.<br>3409.<br>3410.<br>3411.<br>3412.<br>3413.<br>3414.<br>3415.<br>3416.<br>3417.<br>3418.<br>3419.<br>3420.<br>3421.<br>3422.<br>3423.<br>3424.<br>3425.<br>3426.<br>3427.<br>3428.<br>3429.<br>3430.<br>3431.<br>3432.<br>3433.<br>3434.<br>3435.<br>3436.<br>3437.<br>3438.<br>3439.<br>3440.<br>3441.<br>3442.<br>3443.<br>3444.<br>3445.<br>3446.<br>3447.<br>3448.<br>3449.<br>3450.<br>3451.<br>3452.<br>3453.<br>3454.<br>3455.<br>3456.<br>3457.<br>3458.<br>3459.<br>3460.<br>3461.<br>3462.<br>3463.<br>3464.<br>3465.<br>3466.<br>3467.<br>3468.<br>3469.<br>3470.<br>3471.<br>3472.<br>3473.<br>3474.<br>3475.<br>3476.<br>3477.<br>3478.<br>3479.<br>3480.<br>3481.<br>3482.<br>3483.<br>3484.<br>3485.<br>3486.<br>3487.<br>3488.<br>3489.<br>3490.<br>3491.<br>3492.<br>3493.<br>3494.<br>3495.<br>3496.<br>3497.<br>3498.<br>3499.<br>3500.<br>3501.<br>3502.<br>3503.<br>3504.<br>3505.<br>3506.<br>3507.<br>3508.<br>3509.<br>3510.<br>3511.<br>3512.<br>3513.<br>3514.<br>3515.<br>3516.<br>3517.<br>3518.<br>3519.<br>3520.<br>3521.<br>3522.<br>3523.<br>3524.<br>3525.<br>3526.<br>3527.<br>3528.<br>3529.<br>3530.<br>3531.<br>3532.<br>3533.<br>3534.<br>3535.<br>3536.<br>3537.<br>3538.<br>3539.<br>3540.<br>3541.<br>3542.<br>3543.<br>3544.<br>3545.<br>3546.<br>3547.<br>3548.<br>3549.<br>3550.<br>3551.<br>3552.<br>3553.<br>3554.<br>3555.<br>3556.<br>3557.<br>3558.<br>3559.<br>3560.<br>3561.<br>3562.<br>3563.<br>3564.<br>3565.<br>3566.<br>3567.<br>3568.<br>3569.<br>3570.<br>3571.<br>3572.<br>3573.<br>3574.<br>3575.<br>3576.<br>3577.<br>3578.<br>3579.<br>3580.<br>3581.<br>3582.<br>3583.<br>3584.<br>3585.<br>3586.<br>3587.<br>3588.<br>3589.<br>3590.<br>3591.<br>3592.<br>3593.<br>3594.<br>3595.<br>3596.<br>3597.<br>3598.<br>3599.<br>3600.<br>3601.<br>3602.<br>3603.<br>3604.<br>3605.<br>3606.<br>3607.<br>3608.<br>3609.<br>3610.<br>3611.<br>3612.<br>3613.<br>3614.<br>3615.<br>3616.<br>3617.<br>3618.<br>3619.<br>3620.<br>3621.<br>3622.<br>3623.<br>3624.<br>3625.<br>3626.<br>3627.<br>3628.<br>3629.<br>3630.<br>3631.<br>3632.<br>3633.<br>3634.<br>3635.<br>3636.<br>3637.<br>3638.<br>3639.<br>3640.<br>3641.<br>3642.<br>3643.<br>3644.<br>3645.<br>3646.<br>3647.<br>3648.<br>3649.<br>3650.<br>3651.<br>3652.<br>3653.<br>3654.<br>3655.<br>3656.<br>3657.<br>3658.<br>3659.<br>3660.<br>3661.<br>3662.<br>3663.<br>3664.<br>3665.<br>3666.<br>3667.<br>3668.<br>3669.<br>3670.<br>3671.<br>3672.<br>3673.<br>3674.<br>3675.<br>3676.<br>3677.<br>3678.<br>3679.<br>3680.<br>3681.<br>3682.<br>3683.<br>3684.<br>3685.<br>3686.<br>3687.<br>3688.<br>3689.<br>3690.<br>3691.<br>3692.<br>3693.<br>3694.<br>3695.<br>3696.<br>3697.<br>3698.<br>3699.<br>3700.<br>3701.<br>3702.<br>3703.<br>3704.<br>3705.<br>3706.<br>3707.<br>3708.<br>3709.<br>3710.<br>3711.<br>3712.<br>3713.<br>3714.<br>3715.<br>3716.<br>3717.<br>3718.<br>3719.<br>3720.<br>3721.<br>3722.<br>3723.<br>3724.<br>3725.<br>3726.<br>3727.<br>3728.<br>3729.<br>3730.<br>3731.<br>3732.<br>3733.<br>3734.<br>3735.<br>3736.<br>3737.<br>3738.<br>3739.<br>3740.<br>3741.<br>3742.<br>3743.<br>3744.<br>3745.<br>3746.<br>3747.<br>3748.<br>3749.<br>3750.<br>3751.<br>3752.<br>3753.<br>3754.<br>3755.<br>3756.<br>3757.<br>3758.<br>3759.<br>3760.<br>3761.<br>3762.<br>3763.<br>3764.<br>3765.<br>3766.<br>3767.<br>3768.<br>3769.<br>3770.<br>3771.<br>3772.<br>3773.<br>3774.<br>3775.<br>3776.<br>3777.<br>3778.<br>3779.<br>3780.<br>3781.<br>3782.<br>3783.<br>3784.<br>3785.<br>3786.<br>3787.<br>3788.<br>3789.<br>3790.<br>3791.<br>3792.<br>3793.<br>3794.<br>3795.<br>3796.<br>3797.<br>3798.<br>3799.<br>3800.<br>3801.<br>3802.<br>3803.<br>3804.<br>3805.<br>3806.<br>3807.<br>3808.<br>3809.<br>3810.<br>3811.<br>3812.<br>3813.<br>3814.<br>3815.<br>3816.<br>3817.<br>3818.<br>3819.<br>3820.<br>3821.<br>3822.<br>3823.<br>3824.<br>3825.<br>3826.<br>3827.<br>3828.<br>3829.<br>3830.<br>3831.<br>3832.<br>3833.<br>3834.<br>3835.<br>3836.<br>3837.<br>3838.<br>3839.<br>3840.<br>3841.<br>3842.<br>3843.<br>3844.<br>3845.<br>3846.<br>3847.<br>3848.<br>3849.<br>3850.<br>3851.<br>3852.<br>3853.<br>3854.<br>3855.<br>3856.<br>3857.<br>3858.<br>3859.<br>3860.<br>3861.<br>3862.<br>3863.<br>3864.<br>3865.<br>3866.<br>3867.<br>3868.<br>3869.<br>3870.<br>3871.<br>3872.<br>3873.<br>3874.<br>3875.<br>3876.<br>3877.<br>3878.<br>3879.<br>3880.<br>3881.<br>3882.<br>3883.<br>3884.<br>3885.<br>3886.<br>3887.<br>3888.<br>3889.<br>3890.<br>3891.<br>3892.<br>3893.<br>3894.<br>3895.<br>3896.<br>3897.<br>3898.<br>3899.<br>3900.<br>3901.<br>3902.<br>3903.<br>3904.<br>3905.<br>3906.<br>3907.<br>3908.<br>3909.<br>3910.<br>3911.<br>3912.<br>3913.<br>3914.<br>3915.<br>3916.<br>3917.<br>3918.<br>3919.<br>3920.<br>3921.<br>3922.<br>3923.<br>3924.<br>3925.<br>3926.<br>3927.<br>3928.<br>3929.<br>3930.<br>3931.<br>3932.<br>3933.<br>3934.<br>3935.<br>3936.<br>3937.<br>3938.<br>3939.<br>3940.<br>3941.<br>3942.<br>3943.<br>3944.<br>3945.<br>3946.<br>3947.<br>3948.<br>3949.<br>3950.<br>3951.<br>3952.<br>3953.<br>3954.<br>3955.<br>3956.<br>3957.<br>3958.<br>3959.<br>3960.<br>3961.<br>3962.<br>3963.<br>3964.<br>3965.<br>3966.<br>3967.<br>3968.<br>3969.<br>3970.<br>3971.<br>3972.<br>3973.<br>3974.<br>3975.<br>3976.<br>3977.<br>3978.<br>3979.<br>3980.<br>3981.<br>3982.<br>3983.<br>3984.<br>3985.<br>3986.<br>3987.<br>3988.<br>3989.<br>3990.<br>3991.<br>3992.<br>3993.<br>3994.<br>3995.<br>3996.<br>3997.<br>3998.<br>3999.<br>4000.<br>4001.<br>4002.<br>4003.<br>4004.<br>4005.<br>4006.<br>4007.<br>4008.<br>4009.<br>4010.<br>4011.<br>4012.<br>4013.<br>4014.<br>4015.<br>4016.<br>4017.<br>4018.<br>4019.<br>4020.<br>4021.<br>4022.<br>4023.<br>4024.<br>4025.<br>4026.<br>4027.<br>4028.<br>4029.<br>4030.<br>4031.<br>4032.<br>4033.<br>4034.<br>4035.<br>4036.<br>4037.<br>4038.<br>4039.<br>4040.<br>4041.<br>4042.<br>4043.<br>4044.<br>4045.<br>4046.<br>4047.<br>4048.<br>4049.<br>4050.<br>4051.<br>4052.<br>4053.<br>4054.<br>4055.<br>4056.<br>4057.<br>4058.<br>4059.<br>4060.<br>4061.<br>4062.<br>4063.<br>4064.<br>4065.<br>4066.<br>4067.<br>4068.<br>4069.<br>4070.<br>4071.<br>4072.<br>4073.<br>4074.<br>4075.<br>4076.<br>4077.<br>4078.<br>4079.<br>4080.<br>4081.<br>4082.<br>4083.<br>4084.<br>4085.<br>4086.<br>4087.<br>4088.<br>4089.<br>4090.<br>4091.<br>4092.<br>4093.<br>4094.<br>4095.<br>4096.<br>4097.<br>4098.<br>4099.<br>4100.<br>4101.<br>4102.<br>4103.<br>4104.<br>4105.<br>4106.<br>4107.<br>4108.<br>4109.<br>4110.<br>4111.<br>4112.<br>4113.<br>4114.<br>4115.<br>4116.<br>4117.<br>4118.<br>4119.<br>4120.<br>4121.<br>4122.<br>4123.<br>4124.<br>4125.<br>4126.<br>4127.<br>4128.<br>4129.<br>4130.<br>4131.<br>4132.<br>4133.<br>4134.<br>4135.<br>4136.<br>4137.<br>4138.<br>4139.<br>4140.<br>4141.<br>4142.<br>4143.<br>4144.<br>4145.<br>4146.<br>4147.<br>4148.<br>4149.<br>4150.<br>4151.<br>4152.<br>4153.<br>4154.<br>4155.<br>4156.<br>4157.<br>4158.<br>4159.<br>4160.<br>4161.<br>4162.<br>4163.<br>4164.<br>4165.<br>4166.<br>4167.<br>4168.<br>4169.<br>4170.<br>4171.<br>4172.<br>4173.<br>4174.<br>4175.<br>4176.<br>4177.<br>4178.<br>4179.<br>4180.<br>4181.<br>4182.<br>4183.<br>4184.<br>4185.<br>4186.<br>4187.<br>4188.<br>4189.<br>4190.<br>4191.<br>4192.<br>4193.<br>4194.<br>4195.<br>4196.<br>4197.<br>4198.<br>4199.<br>4200.<br>4201.<br>4202.<br>4203.<br>4204.<br>4205.<br>4206.<br>4207.<br>4208.<br>4209.<br>4210.<br>4211.<br>4212.<br>4213.<br>4214.<br>4215.<br>4216.<br>4217.<br>4218.<br>4219.<br>4220.<br>4221.<br>4222.<br>4223.<br>4224.<br>4225.<br>4226.<br>4227.<br>4228.<br>4229.<br>4230.<br>4231.<br>4232.<br>4233.<br>4234.<br>4235.<br>4236.<br>4237.<br>4238.<br>4239.<br>4240.<br>4241.<br>4242.<br>4243.<br>4244.<br>4245.<br>4246.<br>4247.<br>4248.<br>4249.<br>4250.<br>4251.<br>4252.<br>4253.<br>4254.<br>4255.<br>4256.<br>4257.<br>4258.<br>4259.<br>4260.<br>4261.<br>4262.<br>4263.<br>4264.<br>4265.<br>4266.<br>4267.<br>4268.<br>4269.<br>4270.<br>4271.<br>4272.<br>4273.<br>4274.<br>4275.<br>4276.<br>4277.<br>4278.<br>4279.<br>4280.<br>4281.<br>4282.<br>4283.<br>4284.<br>4285.<br>4286.<br>4287.<br>4288.<br>4289.<br>4290.<br>4291.<br>4292.<br>4293.<br>4294.<br>4295.<br>4296.<br>4297.<br>4298.<br>4299.<br>4300.<br>4301.<br>4302.<br>4303.<br>4304.<br>4305.<br>4306.<br>4307.<br>4308.<br>4309.<br>4310.<br>4311.<br>4312.<br>4313.<br>4314.<br>4315.<br>4316.<br>4317.<br>4318.<br>4319.<br>4320.<br>4321.<br>4322.<br>4323.<br>4324.<br>4325.<br>4326.<br>4327.<br>4328.<br>4329.<br>4330.<br>4331.<br>4332.<br>4333.<br>4334.<br>4335.<br>4336.<br>4337.<br>4338.<br>4339.<br>4340.<br>4341.<br>4342.<br>4343.<br>4344.<br>4345.<br>4346.<br>4347.<br>4348.<br>4349.<br>4350.<br>4351.<br>4352.<br>4353.<br>4354.<br>4355.<br>4356.<br>4357.<br>4358.<br>4359.<br>4360.<br>4361.<br>4362.<br>4363.<br>4364.<br>4365.<br>4366.<br>4367.<br>4368.<br>4369.<br>4370.<br>4371.<br>4372.<br>4373.<br>4374.<br>4375.<br>4376.<br>4377.<br>4378.<br>4379.<br>4380.<br>4381.<br>4382.<br>4383.<br>4384.<br>4385.<br>4386.<br>4387.<br>4388.<br>4389.<br>4390.<br>4391.<br>4392.<br>4393.<br>4394.<br>4395.<br>4396.<br>4397.<br>4398.<br>4399.<br>4400.<br>4401.<br>4402.<br>4403.<br>4404.<br>4405.<br>4406.<br>4407.<br>4408.<br>4409.<br>4410.<br>4411.<br>4412.<br>4413.<br>4414.<br>4415.<br>4416.<br>4417.<br>4418.<br>4419.<br>4420.<br>4421.<br>4422.<br>4423.<br>4424.<br>4425.<br>4426.<br>4427.<br>4428.<br>4429.<br>4430.<br>4431.<br>4432.<br>4433.<br>4434.<br>4435.<br>4436.<br>4437.<br>4438.<br>4439.<br>4440.<br>4441.<br>4442.<br>4443.<br>4444.<br>4445.<br>4446.<br>4447.<br>4448.<br>4449.<br>4450.<br>4451.<br>4452.<br>4453.<br>4454.<br>4455.<br>4456.<br>4457.<br>4458.<br>4459.<br>4460.<br>4461.<br>4462.<br>4463.<br>4464.<br>4465.<br>4466.<br>4467.<br>4468.<br>4469.<br>4470.<br>4471.<br>4472.<br>4473.<br>4474.<br>4475.<br>4476.<br>4477.<br>4478.<br>4479.<br>4480.<br>4481.<br>4482.<br>4483.<br>4484.<br>4485.<br>4486.<br>4487.<br>4488.<br>4489.<br>4490.<br>4491.<br>4492.<br>4493.<br>4494.<br>4495.<br>4496.<br>4497.<br>4498.<br>4499.<br>4500.<br>4501.<br>4502.<br>4503.<br>4504.<br>4505.<br>4506.<br>4507.<br>4508.<br>4509.<br>4510.<br>4511.<br>4512.<br>4513.<br>4514.<br>4515.<br>4516.<br>4517.<br>4518.<br>4519.<br>4520.<br>4521.<br>4522.<br>4523.<br>4524.<br>4525.<br>4526.<br>4527.<br>4528.<br>4529.<br>4530.<br>4531.<br>4532.<br>4533.<br>4534.<br>4535.<br>4536.<br>4537.<br>4538.<br>4539.<br>4540.<br>4541.<br>4542.<br>4543.<br>4544.<br>4545.<br>4546.<br>4547.<br>4548.<br>4549.<br>4550.<br>4551.<br>4552.<br>4553.<br>4554.<br>4555.<br>4556.<br>4557.<br>4558.<br>4559.<br>4560.<br>4561.<br>4562.<br>4563.<br>4564.<br>4565.<br>4566.<br>4567.<br>4568.<br>4569.<br>4570.<br>4571.<br>4572.<br>4573.<br>4574.<br>4575.<br>4576.<br>4577.<br>4578.<br>4579.<br>4580.<br>4581.<br>4582.<br>4583.<br>4584.<br>4585.<br>4586.<br>4587.<br>4588.<br>4589.<br>4590.<br>4591.<br>4592.<br>4593.<br>4594.<br>4595.<br>4596.<br>4597.<br>4598.<br>4599.<br>4600.<br>4601.<br>4602.<br>4603.<br>4604.<br>4605.<br>4606.<br>4607.<br>4608.<br>4609.<br>4610.<br>4611.<br>4612.<br>4613.<br>4614.<br>4615.<br>4616.<br>4617.<br>4618.<br>4619.<br>4620.<br>4621.<br>4622.<br>4623.<br>4624.<br>4625.<br>4626.<br>4627.<br>4628.<br>4629.<br>4630.<br>4631.<br>4632.<br>4633.<br>4634.<br>4635.<br>4636.<br>4637.<br>4638.<br>4639.<br>4640.<br>4641.<br>4642.<br>4643.<br>4644.<br>4645.<br>4646.<br>4647.<br>4648.<br>4649.<br>4650.<br>4651.<br>4652.<br>4653.<br>4654.<br>4655.<br>4656.<br>4657.<br>4658.<br>4659.<br>4660.<br>4661.<br>4662.<br>4663.<br>4664.<br>4665.<br>4666.<br>4667.<br>4668.<br>4669.<br>4670.<br>4671.<br>4672.<br>4673.<br>4674.<br>4675.<br>4676.<br>4677.<br>4678.<br>4679.<br>4680.<br>4681.<br>4682.<br>4683.<br>4684.<br>4685.<br>4686.<br>4687.<br>4688.<br>4689.<br>4690.<br>4691.<br>4692.<br>4693.<br>4694.<br>4695.<br>4696.<br>4697.<br>4698.<br>4699.<br>4700.<br>4701.<br>4702.<br>4703.<br>4704.<br>4705.<br>4706.<br>4707.<br>4708.<br>4709.<br>4710.<br>4711.<br>4712.<br>4713.<br>4714.<br>4715.<br>4716.<br>4717.<br>4718.<br>4719.<br>4720.<br>4721.<br>4722.<br>4723.<br>4724.<br>4725.<br>4726.<br>4727.<br>4728.<br>4729.<br>4730.<br>4731.<br>4732.<br>4733.<br>4734.<br>4735.<br>4736.<br>4737.<br>4738.<br>4739.<br>4740.<br>4741.<br>4742.<br>4743.<br>4744.<br>4745.<br>4746.<br>4747.<br>4748.<br>4749.<br>4750.<br>4751.<br>4752.<br>4753.<br>4754.<br>4755.<br>4756.<br>4757.<br>4758.<br>4759.<br>4760.<br>4761.<br>4762.<br>4763.<br>4764.<br>4765.<br>4766.<br>4767.<br>4768.<br>4769.<br>4770.<br>4771.<br>4772.<br>4773.<br>4774.<br>4775.<br>4776.<br>4777.<br>4778.<br>4779.<br>4780.<br>4781.<br>4782.<br>4783.<br>4784.<br>4785.<br>4786.<br>4787.<br>4788.<br>4789.<br>4790.<br>4791.<br>4792.<br>4793.<br>4794.<br>4795.<br>4796.<br>4797.<br>4798.<br>4799.<br>4800.<br>4801.<br>4802.<br>4803.<br>4804.<br>4805.<br>4806.<br>4807.<br>4808.<br>4809.<br>4810.<br>4811.<br>4812.<br>4813.<br>4814.<br>4815.<br>4816.<br>4817.<br>4818.<br>4819.<br>4820.<br>4821.<br>4822.<br>4823.<br>4824.<br>4825.<br>4826.<br>4827.<br>4828.<br>4829.<br>4830.<br>4831.<br>4832.<br>4833.<br>4834.<br>4835.<br>4836.<br>4837.<br>4838.<br>4839.<br>4840.<br>4841.<br>4842.<br>4843.<br>4844.<br>4845.<br>4846.<br>4847.<br>4848.<br>4849.<br>4850.<br>4851.<br>4852.<br>4853.<br>4854.<br>4855.<br>4856.<br>4857.<br>4858.<br>4859.<br>4860.<br>4861.<br>4862.<br>4863.<br>4864.<br>4865.<br>4866.<br>4867.<br>4868.<br>4869.<br>4870.<br>4871.<br>4872.<br>4873.<br>4874.<br>4875.<br>4876.<br>4877.<br>4878.<br>4879.<br>4880.<br>4881.<br>4882.<br>4883.<br>4884.<br>4885.<br>4886.<br>4887.<br>4888.<br>4889.<br>4890.<br>4891.<br>4892.<br>4893.<br>4894.<br>4895.<br>4896.<br>4897.<br>4898.<br>4899.<br>4900.<br>4901.<br>4902.<br>4903.<br>4904.<br>4905.<br>4906.<br>4907.<br>4908.<br>4909.<br>4910.<br>4911.<br>4912.<br>4913.<br>4914.<br>4915.<br>4916.<br>4917.<br>4918.<br>4919.<br>4920.<br>4921.<br>4922.<br>4923.<br>4924.<br>4925.<br>4926.<br>4927.<br>4928.<br>4929.<br>4930.<br>4931.<br>4932.<br>4933.<br>4934.<br>4935.<br>4936.<br>4937.<br>4938.<br>4939.<br>4940.<br>4941.<br>4942.<br>4943.<br>4944.<br>4945.<br>4946.<br>4947.<br>4948.<br>4949.<br>4950.<br>4951.<br>4952.<br>4953.<br>4954.<br>4955.<br>4956.<br>4957.<br>4958.<br>4959.<br>4960.<br>4961.<br>4962.<br>4963.<br>4964.<br>4965.<br>4966.<br>4967.<br>4968.<br>4969.<br>4970.<br>4971.<br>4972.<br>4973.<br>4974.<br>4975.<br>4976.<br>4977.<br>4978.<br>4979.<br>4980.<br>4981.<br>4982.<br>4983.<br>4984.<br>4985.<br>4986.<br>4987.<br>4988.<br>4989.<br>4990.<br>4991.<br>4992.<br>4993.<br>4994.<br>4995.<br>4996.<br>4997.<br>4998.<br>4999.<br>5000.<br>5001.<br>5002.<br>5003.<br>5004.<br>5005.<br>5006.<br>5007.<br>5008.<br>5009.<br>5010.<br>5011.<br>5012.<br>5013.<br>5014.<br>5015.<br>5016.<br>5017.<br>5018.<br>5019.<br>5020.<br>5021.<br>5022.<br>5023.<br>5024.<br>5025.<br>5026.<br>5027.<br>5028.<br>5029.<br>5030.<br>5031.<br>5032.<br>5033.<br>5034.<br>5035.<br>5036.<br>5037.<br>5038.<br>5039.<br>5040.<br>5041.<br>5042.<br>5043.<br>5044.<br>5045.<br>5046.<br>5047.<br>5048.<br>5049.<br>5050.<br>5051.<br>5052.<br>5053.<br>5054.<br>5055.<br>5056.<br>5057.<br>5058.<br>5059.<br>5060.<br>5061.<br>5062.<br>5063.<br>5064.<br>5065.<br>5066.<br>5067.<br>5068.<br>5069.<br>5070.<br>5071.<br>5072.<br>5073.<br>5074.<br>5075.<br>5076.<br>5077.<br>5078.<br>5079.<br>5080.<br>5081.<br>5082.<br>5083.<br>5084.<br>5085.<br>5086.<br>5087.<br>5088.<br>5089.<br>5090.<br>5091.<br>5092.<br>5093.<br>5094.<br>5095.<br>5096.<br>5097.<br>5098.<br>5099.<br>5100.<br>5101.<br>5102.<br>5103.<br>5104.<br>5105.<br>5106.<br>5107.<br>5108.<br>5109.<br>5110.<br>5111.<br>5112.<br>5113.<br>5114.<br>5115.<br>5116.<br>5117.<br>5118.<br>5119.<br>5120.<br>5121.<br>5122.<br>5123.<br>5124.<br>5125.<br>5126.<br>5127.<br>5128.<br>5129.<br>5130.<br>5131.<br>5132.<br>5133.<br>5134.<br>5135.<br>5136.<br>5137.<br>5138.<br>5139.<br>5140.<br>5141.<br>5142.<br>5143.<br>5144.<br>5145.<br>5146.<br>5147.<br>5148.<br>5149.<br>5150.<br>5151.<br>5152.<br>5153.<br>5154.<br>5155.<br>5156.<br>5157.<br>5158.<br>5159.<br>5160.<br>5161.<br>5162.<br>5163.<br>5164.<br>5165.<br>5166.<br>5167.<br>5168.<br>5169.<br>5170.<br>5171.<br>5172.<br>5173.<br>5174.<br>5175.<br>5176.<br>5177.<br>5178.<br>5179.<br>5180.<br>5181.<br>5182.<br>5183.<br>5184.<br>5185.<br>5186.<br>5187.<br>5188.<br>5189.<br>5190.<br>5191.<br>5192.<br>5193.<br>5194.<br>5195.<br>5196.<br>5197.<br>5198.<br>5199.<br>5200.<br>5201.<br>5202.<br>5203.<br>5204.<br>5205.<br>5206.<br>5207.<br>5208.<br>5209.<br>5210.<br>5211.<br>5212.<br>5213.<br>5214.<br>5215.<br>5216.<br>5217.<br>5218.<br>5219.<br>5220.<br>5221.<br>5222.<br>5223.<br>5224.<br>5225.<br>5226.<br>5227.<br>5228.<br>5229.<br>5230.<br>5231.<br>5232.<br>5233.<br>5234.<br>5235.<br>5236.<br>5237.<br>5238.<br>5239.<br>5240.<br>5241.<br>5242.<br>5243.<br>5244.<br>5245.<br>5246.<br>5247.<br>5248.<br>5249.<br>5250.<br>5251.<br>5252.<br>5253.<br>5254.<br>5255.<br>5256.<br>5257.<br>5258.<br>5259.<br>5260.<br>5261.<br>5262.<br>5263.<br>5264.<br>5265.<br>5266.<br>5267.<br>5268.<br>5269.<br>5270.<br>5271.<br>5272.<br>5273.<br>5274.<br>5275.<br>5276.<br>5277.<br>5278.<br>5279.<br>5280.<br>5281.<br>5282.<br>5283.<br>5284.<br>5285.<br>5286.<br>5287.<br>5288.<br>5289.<br>5290.<br>5291.<br>5292.<br>5293.<br>5294.<br>5295.<br>5296.<br>5297.<br>5298.<br>5299.<br>5300.<br>5301.<br>5302.<br>5303.<br>5304.<br>5305.<br>5306.<br>5307.<br>5308.<br>5309.<br>5310.<br>5311.<br>5312.<br>5313.<br>5314.<br>5315.<br>5316.<br>5317.<br>5318.<br>5319.<br>5320.<br>5321.<br>5322.<br>5323.<br>5324.<br>5325.<br>5326.<br>5327.<br>5328.<br>5329.<br>5330.<br>5331.<br>5332.<br>5333.<br>5334.<br>5335.<br>5336.<br>5337.<br>5338.<br>5339.<br>5340.<br>5341.<br>5342.<br>5343.<br>5344.<br>5345.<br>5346.<br>5347.<br>5348.<br>5349.<br>5350.<br>5351.<br>5352.<br>5353.<br>5354.<br>5355.<br>5356.<br>5357.<br>5358.<br>5359.<br>5360.<br>5361.<br>5362.<br>5363.<br>5364.<br>5365.<br>5366.<br>5367.<br>5368.<br>5369.<br>5370.<br>5371.<br>5372.<br>5373.<br>5374.<br>5375.<br>5376.<br>5377.<br>5378.<br>5379.<br>5380.<br>5381.<br>5382.<br>5383.<br>5384.<br>5385.<br>5386.<br>5387.<br>5388.<br>5389.<br>5390.<br>5391.<br>5392.<br>5393.<br>5394.<br>5395.<br>5396.<br>5397.<br>5398.<br>5399.<br>5400.<br>5401.<br>5402.<br>5403.<br>5404.<br>5405.<br>5406.<br>5407.<br>5408.<br>5409.<br>5410.<br>5411.<br>5412.<br>5413.<br>5414.<br>5415.<br>5416.<br>5417.<br>5418.<br>5419.<br>5420.<br>5421.<br>5422.<br>5423.<br>5424.<br>5425.<br>5426.<br>5427.<br>5428.<br>5429.<br>5430.<br>5431.<br>5432.<br>5433.<br>5434.<br>5435.<br>5436.<br>5437.<br>5438.<br>5439.<br>5440.<br>5441.<br>5442.<br>5443.<br>5444.<br>5445.<br>5446.<br>5447.<br>5448.<br>5449.<br>5450.<br>5451.<br>5452.<br>5453.<br>5454.<br>5455.<br>5456.<br>5457.<br>5458.<br>5459.<br>5460.<br>5461.<br>5462.<br>5463.<br>5464.<br>5465.<br>5466.<br>5467.<br>5468.<br>5469.<br>5470.<br>5471.<br>5472.<br>5473.<br>5474.<br>5475.<br>5476.<br>5477.<br>5478.<br>5479.<br>5480.<br>5481.<br>5482.<br>5483.<br>5484.<br>5485.<br>5486.<br>5487.<br>5488.<br>5489.<br>5490.<br>5491.<br>5492.<br>5493.<br>5494.<br>5495.<br>5496.<br>5497.<br>5498.<br>5499.<br>5500.<br>5501.<br>5502.<br>5503.<br>5504.<br>5505.<br>5506.<br>5507.<br>5508.<br>5509.<br>5510.<br>5511.<br>5512.<br>5513.<br>5514.<br>5515.<br>5516.<br>5517.<br>5518.<br>5519.<br>5520.<br>5521.<br>5522.<br>5523.<br>5524.<br>5525.<br>5526.<br>5527.<br>5528.<br>5529.<br>5530.<br>5531.<br>5532.<br>5533.<br>5534.<br>5535.<br>5536.<br>5537.<br>5538.<br>5539.<br>5540.<br>5541.<br>5542.<br>5543.<br>5544.<br>5545.<br>5546.<br>5547.<br>5548.<br>5549.<br>5550.<br>5551.<br>5552.<br>5553.<br>5554.<br>5555.<br>5556.<br>5557.<br>5558.<br>5559.<br>5560.<br>5561.<br>5562.<br>5563.<br>5564.<br>5565.<br>5566.<br>5567.<br>5568.<br>5569.<br>5570.<br>5571.<br>5572.<br>5573.<br>5574.<br>5575.<br>5576.<br>5577.<br>5578.<br>5579.<br>5580.<br>5581.<br>5582.<br>5583.<br>5584.<br>5585.<br>5586.<br>5587.<br>5588.<br>5589.<br>5590.<br>5591.<br>5592.<br>5593.<br>5594.<br>5595.<br>5596.<br>5597.<br>5598.<br>5599.<br>5600.<br>5601.<br>5602.<br>5603.<br>5604.<br>5605.<br>5606.<br>5607.<br>5608.<br>5609.<br>5610.<br>5611.<br>5612.<br>5613.<br>5614.<br>5615.<br>5616.<br>5617.<br>5618.<br>5619.<br>5620.<br>5621.<br>5622.<br>5623.<br>5624.<br>5625.<br>5626.<br>5627.<br>5628.<br>5629.<br>5630.<br>5631.<br>5632.<br>5633.<br>5634.<br>5635.<br>5636.<br>5637.<br>5638.<br>5639.<br>5640.<br>5641.<br>5642.<br>5643.<br>5644.<br>5645.<br>5646.<br>5647.<br>5648.<br>5649.<br>5650.<br>5651.<br>5652.<br>5653.<br>5654.<br>5655.<br>5656.<br>5657.<br>5658.<br>5659.<br>5660.<br>5661.<br>5662.<br>5663.<br>5664.<br>5665.<br>5666.<br>5667.<br>5668.<br>5669.<br>5670.<br>5671.<br>5672.<br>5673.<br>5674.<br>5675.<br>5676.<br>5677.<br>5678.<br>5679.<br>5680.<br>5681.<br>5682.<br>5683.<br>5684.<br>5685.<br>5686.<br>5687.<br>5688.<br>5689.<br>5690.<br>5691.<br>5692.<br>5693.<br>5694.<br>5695.<br>5696.<br>5697.<br>5698.<br>5699.<br>5700.<br>5701.<br>5702.<br>5703.<br>5704.<br>5705.<br>5706.<br>5707.<br>5708.<br>5709.<br>5710.<br>5711.<br>5712.<br>5713.<br>5714.<br>5715.<br>5716.<br>5717.<br>5718.<br>5719.<br>5720.<br>5721.<br>5722.<br>5723.<br>5724.<br>5725.<br>5726.<br>5727.<br>5728.<br>5729.<br>5730.<br>5731.<br>5732.<br>5733.<br>5734.<br>5735.<br>5736.<br>5737.<br>5738.<br>5739.<br>5740.<br>5741.<br>5742.<br>5743.<br>5744.<br>5745.<br>5746.<br>5747.<br>5748.<br>5749.<br>5750.<br>5751.<br>5752.<br>5753.<br>5754.<br>5755.<br>5756.<br>5757.<br>5758.<br>5759.<br>5760.<br>5761.<br>5762.<br>5763.<br>5764.<br>5765.<br>5766.<br>5767.<br>5768.<br>5769.<br>5770.<br>5771.<br>5772.<br>5773.<br>5774.<br>5775.<br>5776.<br>5777.<br>5778.<br>5779.<br>5780.<br>5781.<br>5782.<br>5783.<br>5784.<br>5785.<br>5786.<br>5787.<br>5788.<br>5789.<br>5790.<br>5791.<br>5792.<br>5793.<br>5794.<br>5795.<br>5796.<br>5797.<br>5798.<br>5799.<br>5800.<br>5801.<br>5802.<br>5803.<br>5804.<br>5805.<br>5806.<br>5807.<br>5808.<br>5809.<br>5810.<br>5811.<br>5812.<br>5813.<br>5814.<br>5815.<br>5816.<br>5817.<br>5818.<br>5819.<br>5820.<br>5821.<br>5822.<br>5823.<br>5824.<br>5825.<br>5826.<br>5827.<br>5828.<br>5829.<br>5830.<br>5831.<br>5832.<br>5833.<br>5834.<br>5835.<br>5836.<br>5837.<br>5838.<br>5839.<br>5840.<br>5841.<br>5842.<br>5843.<br>5844.<br>5845.<br>5846.<br>5847.<br>5848.<br>5849.<br>5850.<br>5851.<br>5852.<br>5853.<br>5854.<br>5855.<br>5856.<br>5857.<br>5858.<br>5859.<br>5860.<br>5861.<br>5862.<br>5863.<br>5864.<br>5865.<br>5866.<br>5867.<br>5868.<br>5869.<br>5870.<br>5871.<br>5872.<br>5873.<br>5874.<br>5875.<br>5876.<br>5877.<br>5878.<br>5879.<br>5880.<br>5881.<br>5882.<br>5883.<br>5884.<br>5885.<br>5886.<br>5887.<br>5888.<br>5889.<br>5890.<br>5891.<br>5892.<br>5893.<br>5894.<br>5895.<br>5896.<br>5897.<br>5898.<br>5899.<br>5900.<br>5901.<br>5902.<br>5903.<br>5904.<br>5905.<br>5906.<br>5907.<br>5908.<br>5909.<br>5910.<br>5911.<br>5912.<br>5913.<br>5914.<br>5915.<br>5916.<br>5917.<br>5918.<br>5919.<br>5920.<br>5921.<br>5922.<br>5923.<br>5924.<br>5925.<br>5926.<br>5927.<br>5928.<br>5929.<br>5930.<br>5931.<br>5932.<br>5933.<br>5934.<br>5935.<br>5936.<br>5937.<br>5938.<br>5939.<br>5940.<br>5941.<br>5942.<br>5943.<br>5944.<br>5945.<br>5946.<br>5947.<br>5948.<br>5949.<br>5950.<br>5951.<br>5952.<br>5953.<br>5954.<br>5955.<br>5956.<br>5957.<br>5958.<br>5959.<br>5960.<br>5961.<br>5962.<br>5963.<br>5964.<br>5965.<br>5966.<br>5967.<br>5968.<br>5969.<br>5970.<br>5971.<br>5972.<br>5973.<br>5974.<br>5975.<br>5976.<br>5977.<br>5978.<br>5979.<br>5980.<br>5981.<br>5982.<br>5983.<br>5984.<br>5985.<br>5986.<br>5987.<br>5988.<br>5989.<br>5990.<br>5991.<br>5992.<br>5993.<br>5994.<br>5995.<br>5996.<br>5997.<br>5998.<br>5999.<br>6000.<br>6001.<br>6002.<br>6003.<br>6004.<br>6005.<br>6006.<br>6007.<br>6008.<br>6009.<br>6010.<br>6011.<br>6012.<br>6013.<br>6014.<br>6015.<br>6016.<br>6017.<br>6018.<br>6019.<br>6020.<br>6021.<br>6022.<br>6023.<br>6024.<br>6025.<br>6026.<br>6027.<br>6028.<br>6029.<br>6030.<br>6031.<br>6032.<br>6033.<br>6034.<br>6035.<br>6036.<br>6037.<br>6038.<br>6039.<br>6040.<br>6041.<br>6042.<br>6043.<br>6044.<br>6045.<br>6046.<br>6047.<br>6048.<br>6049.<br>6050.<br>6051.<br>6052.<br>6053.<br>6054.<br>6055.<br>6056.<br>6057.<br>6058.<br>6059.<br>6060.<br>6061.<br>6062.<br>6063.<br>6064.<br>6065.<br>6066.<br>6067.<br>6068.<br>6069.<br>6070.<br>6071.<br>6072.<br>6073.<br>6074.<br>6075.<br>6076.<br>6077.<br>6078.<br>6079.<br>6080.<br>6081.<br>6082.<br>6083.<br>6084.<br>6085.<br>6086.<br>6087.<br>6088.<br>6089.<br>6090.<br>6091.<br>6092.<br>6093.<br>6094.<br>6095.<br>6096.<br>6097.<br>6098.<br>6099.<br>6100.<br>6101.<br>6102.<br></code_line></pre></td>
<td class='lines'><pre><code class="prettyprint">// SPDX-License-Identifier: GPL-2.0-only
/*
 * Kernel-based Virtual Machine driver for Linux
 *
 * This module enables machines with Intel VT-x extensions to run virtual
 * machines without emulation or binary translation.
 *
 * Copyright (C) 2006 Qumranet, Inc.
 * Copyright 2010 Red Hat, Inc. and/or its affiliates.
 *
 * Authors:
 *   Avi Kivity   &lt;avi@qumranet.com&gt;
 *   Yaniv Kamay  &lt;yaniv@qumranet.com&gt;
 */

#include &lt;kvm/iodev.h&gt;

#include &lt;linux/kvm_host.h&gt;
#include &lt;linux/kvm.h&gt;
#include &lt;linux/module.h&gt;
#include &lt;linux/errno.h&gt;
#include &lt;linux/percpu.h&gt;
#include &lt;linux/mm.h&gt;
#include &lt;linux/miscdevice.h&gt;
#include &lt;linux/vmalloc.h&gt;
#include &lt;linux/reboot.h&gt;
#include &lt;linux/debugfs.h&gt;
#include &lt;linux/highmem.h&gt;
#include &lt;linux/file.h&gt;
#include &lt;linux/syscore_ops.h&gt;
#include &lt;linux/cpu.h&gt;
#include &lt;linux/sched/signal.h&gt;
#include &lt;linux/sched/mm.h&gt;
#include &lt;linux/sched/stat.h&gt;
#include &lt;linux/cpumask.h&gt;
#include &lt;linux/smp.h&gt;
#include &lt;linux/anon_inodes.h&gt;
#include &lt;linux/profile.h&gt;
#include &lt;linux/kvm_para.h&gt;
#include &lt;linux/pagemap.h&gt;
#include &lt;linux/mman.h&gt;
#include &lt;linux/swap.h&gt;
#include &lt;linux/bitops.h&gt;
#include &lt;linux/spinlock.h&gt;
#include &lt;linux/compat.h&gt;
#include &lt;linux/srcu.h&gt;
#include &lt;linux/hugetlb.h&gt;
#include &lt;linux/slab.h&gt;
#include &lt;linux/sort.h&gt;
#include &lt;linux/bsearch.h&gt;
#include &lt;linux/io.h&gt;
#include &lt;linux/lockdep.h&gt;
#include &lt;linux/kthread.h&gt;
#include &lt;linux/suspend.h&gt;

#include &lt;asm/processor.h&gt;
#include &lt;asm/ioctl.h&gt;
#include &lt;linux/uaccess.h&gt;

#include &quot;coalesced_mmio.h&quot;
#include &quot;async_pf.h&quot;
#include &quot;kvm_mm.h&quot;
#include &quot;vfio.h&quot;

#define CREATE_TRACE_POINTS
#include &lt;trace/events/kvm.h&gt;

#include &lt;linux/kvm_dirty_ring.h&gt;

/* Worst case buffer size needed for holding an integer. */
#define ITOA_MAX_LEN 12

MODULE_AUTHOR(&quot;Qumranet&quot;);
MODULE_LICENSE(&quot;GPL&quot;);

/* Architectures should define their poll value according to the halt latency */
unsigned int halt_poll_ns = KVM_HALT_POLL_NS_DEFAULT;
module_param(halt_poll_ns, uint, 0644);
EXPORT_SYMBOL_GPL(halt_poll_ns);

/* Default doubles per-vcpu halt_poll_ns. */
unsigned int halt_poll_ns_grow = 2;
module_param(halt_poll_ns_grow, uint, 0644);
EXPORT_SYMBOL_GPL(halt_poll_ns_grow);

/* The start value to grow halt_poll_ns from */
unsigned int halt_poll_ns_grow_start = 10000; /* 10us */
module_param(halt_poll_ns_grow_start, uint, 0644);
EXPORT_SYMBOL_GPL(halt_poll_ns_grow_start);

/* Default resets per-vcpu halt_poll_ns . */
unsigned int halt_poll_ns_shrink;
module_param(halt_poll_ns_shrink, uint, 0644);
EXPORT_SYMBOL_GPL(halt_poll_ns_shrink);

/*
 * Ordering of locks:
 *
 *	kvm-&gt;lock --&gt; kvm-&gt;slots_lock --&gt; kvm-&gt;irq_lock
 */

DEFINE_MUTEX(kvm_lock);
static DEFINE_RAW_SPINLOCK(kvm_count_lock);
LIST_HEAD(vm_list);

static cpumask_var_t cpus_hardware_enabled;
static int kvm_usage_count;
static atomic_t hardware_enable_failed;

static struct kmem_cache *kvm_vcpu_cache;

static __read_mostly struct preempt_ops kvm_preempt_ops;
static DEFINE_PER_CPU(struct kvm_vcpu *, kvm_running_vcpu);

struct dentry *kvm_debugfs_dir;
EXPORT_SYMBOL_GPL(kvm_debugfs_dir);

static const struct file_operations stat_fops_per_vm;

static struct file_operations kvm_chardev_ops;

static long kvm_vcpu_ioctl(struct file *file, unsigned int ioctl,
			   unsigned long arg);
#ifdef CONFIG_KVM_COMPAT
static long kvm_vcpu_compat_ioctl(struct file *file, unsigned int ioctl,
				  unsigned long arg);
#define KVM_COMPAT(c)	.compat_ioctl	= (c)
#else
/*
 * For architectures that don&#x27;t implement a compat infrastructure,
 * adopt a double line of defense:
 * - Prevent a compat task from opening /dev/kvm
 * - If the open has been done by a 64bit task, and the KVM fd
 *   passed to a compat task, let the ioctls fail.
 */
static long kvm_no_compat_ioctl(struct file *file, unsigned int ioctl,
				unsigned long arg) { return -EINVAL; }

static int kvm_no_compat_open(struct inode *inode, struct file *file)
{
	return is_compat_task() ? -ENODEV : 0;
}
#define KVM_COMPAT(c)	.compat_ioctl	= kvm_no_compat_ioctl,	\
			.open		= kvm_no_compat_open
#endif
static int hardware_enable_all(void);
static void hardware_disable_all(void);

static void kvm_io_bus_destroy(struct kvm_io_bus *bus);

__visible bool kvm_rebooting;
EXPORT_SYMBOL_GPL(kvm_rebooting);

#define KVM_EVENT_CREATE_VM 0
#define KVM_EVENT_DESTROY_VM 1
static void kvm_uevent_notify_change(unsigned int type, struct kvm *kvm);
static unsigned long long kvm_createvm_count;
static unsigned long long kvm_active_vms;

static DEFINE_PER_CPU(cpumask_var_t, cpu_kick_mask);

__weak void kvm_arch_mmu_notifier_invalidate_range(struct kvm *kvm,
						   unsigned long start, unsigned long end)
{
<yellow>}</yellow>

__weak void kvm_arch_guest_memory_reclaimed(struct kvm *kvm)
{
}

bool kvm_is_zone_device_page(struct page *page)
{
	/*
	 * The metadata used by is_zone_device_page() to determine whether or
	 * not a page is ZONE_DEVICE is guaranteed to be valid if and only if
	 * the device has been pinned, e.g. by get_user_pages().  WARN if the
	 * page_count() is zero to help detect bad usage of this helper.
	 */
<yellow>	if (WARN_ON_ONCE(!page_count(page)))</yellow>
		return false;

<yellow>	return is_zone_device_page(page);</yellow>
<yellow>}</yellow>

/*
 * Returns a &#x27;struct page&#x27; if the pfn is &quot;valid&quot; and backed by a refcounted
 * page, NULL otherwise.  Note, the list of refcounted PG_reserved page types
 * is likely incomplete, it has been compiled purely through people wanting to
 * back guest with a certain type of memory and encountering issues.
 */
struct page *kvm_pfn_to_refcounted_page(kvm_pfn_t pfn)
{
	struct page *page;

<blue>	if (!pfn_valid(pfn))</blue>
		return NULL;

<blue>	page = pfn_to_page(pfn);</blue>
	if (!PageReserved(page))
		return page;

	/* The ZERO_PAGE(s) is marked PG_reserved, but is refcounted. */
<yellow>	if (is_zero_pfn(pfn))</yellow>
		return page;

	/*
	 * ZONE_DEVICE pages currently set PG_reserved, but from a refcounting
	 * perspective they are &quot;normal&quot; pages, albeit with slightly different
	 * usage rules.
	 */
<yellow>	if (kvm_is_zone_device_page(page))</yellow>
		return page;

	return NULL;
<blue>}</blue>

/*
 * Switches to specified vcpu, until a matching vcpu_put()
 */
void vcpu_load(struct kvm_vcpu *vcpu)
{
<blue>	int cpu = get_cpu();</blue>

	__this_cpu_write(kvm_running_vcpu, vcpu);
	preempt_notifier_register(&amp;vcpu-&gt;preempt_notifier);
	kvm_arch_vcpu_load(vcpu, cpu);
<blue>	put_cpu();</blue>
<blue>}</blue>
EXPORT_SYMBOL_GPL(vcpu_load);

void vcpu_put(struct kvm_vcpu *vcpu)
{
<blue>	preempt_disable();</blue>
	kvm_arch_vcpu_put(vcpu);
	preempt_notifier_unregister(&amp;vcpu-&gt;preempt_notifier);
	__this_cpu_write(kvm_running_vcpu, NULL);
<blue>	preempt_enable();</blue>
<blue>}</blue>
EXPORT_SYMBOL_GPL(vcpu_put);

/* TODO: merge with kvm_arch_vcpu_should_kick */
static bool kvm_request_needs_ipi(struct kvm_vcpu *vcpu, unsigned req)
{
<blue>	int mode = kvm_vcpu_exiting_guest_mode(vcpu);</blue>

	/*
	 * We need to wait for the VCPU to reenable interrupts and get out of
	 * READING_SHADOW_PAGE_TABLES mode.
	 */
	if (req &amp; KVM_REQUEST_WAIT)
		return mode != OUTSIDE_GUEST_MODE;

	/*
	 * Need to kick a running VCPU, but otherwise there is nothing to do.
	 */
	return mode == IN_GUEST_MODE;
}

static void ack_kick(void *_completed)
{
<yellow>}</yellow>

<yellow>static inline bool kvm_kick_many_cpus(struct cpumask *cpus, bool wait)</yellow>
{
<blue>	if (cpumask_empty(cpus))</blue>
		return false;

<yellow>	smp_call_function_many(cpus, ack_kick, NULL, wait);</yellow>
	return true;
}

static void kvm_make_vcpu_request(struct kvm_vcpu *vcpu, unsigned int req,
				  struct cpumask *tmp, int current_cpu)
{
	int cpu;

<blue>	if (likely(!(req & KVM_REQUEST_NO_ACTION)))</blue>
<blue>		__kvm_make_request(req, vcpu);</blue>

<blue>	if (!(req & KVM_REQUEST_NO_WAKEUP) && kvm_vcpu_wake_up(vcpu))</blue>
		return;

	/*
	 * Note, the vCPU could get migrated to a different pCPU at any point
	 * after kvm_request_needs_ipi(), which could result in sending an IPI
	 * to the previous pCPU.  But, that&#x27;s OK because the purpose of the IPI
	 * is to ensure the vCPU returns to OUTSIDE_GUEST_MODE, which is
	 * satisfied if the vCPU migrates. Entering READING_SHADOW_PAGE_TABLES
	 * after this point is also OK, as the requirement is only that KVM wait
	 * for vCPUs that were reading SPTEs _before_ any changes were
	 * finalized. See kvm_vcpu_kick() for more details on handling requests.
	 */
<blue>	if (kvm_request_needs_ipi(vcpu, req)) {</blue>
<yellow>		cpu = READ_ONCE(vcpu->cpu);</yellow>
<yellow>		if (cpu != -1 && cpu != current_cpu)</yellow>
<yellow>			__cpumask_set_cpu(cpu, tmp);</yellow>
	}
<blue>}</blue>

bool kvm_make_vcpus_request_mask(struct kvm *kvm, unsigned int req,
				 unsigned long *vcpu_bitmap)
{
	struct kvm_vcpu *vcpu;
	struct cpumask *cpus;
	int i, me;
	bool called;

<yellow>	me = get_cpu();</yellow>

	cpus = this_cpu_cpumask_var_ptr(cpu_kick_mask);
	cpumask_clear(cpus);

<yellow>	for_each_set_bit(i, vcpu_bitmap, KVM_MAX_VCPUS) {</yellow>
<yellow>		vcpu = kvm_get_vcpu(kvm, i);</yellow>
		if (!vcpu)
			continue;
<yellow>		kvm_make_vcpu_request(vcpu, req, cpus, me);</yellow>
	}

<yellow>	called = kvm_kick_many_cpus(cpus, !!(req & KVM_REQUEST_WAIT));</yellow>
<yellow>	put_cpu();</yellow>

	return called;
<yellow>}</yellow>

bool kvm_make_all_cpus_request_except(struct kvm *kvm, unsigned int req,
				      struct kvm_vcpu *except)
<blue>{</blue>
	struct kvm_vcpu *vcpu;
	struct cpumask *cpus;
	unsigned long i;
	bool called;
	int me;

<blue>	me = get_cpu();</blue>

	cpus = this_cpu_cpumask_var_ptr(cpu_kick_mask);
	cpumask_clear(cpus);

<blue>	kvm_for_each_vcpu(i, vcpu, kvm) {</blue>
<blue>		if (vcpu == except)</blue>
			continue;
<blue>		kvm_make_vcpu_request(vcpu, req, cpus, me);</blue>
	}

<blue>	called = kvm_kick_many_cpus(cpus, !!(req & KVM_REQUEST_WAIT));</blue>
<blue>	put_cpu();</blue>

	return called;
}

bool kvm_make_all_cpus_request(struct kvm *kvm, unsigned int req)
{
<blue>	return kvm_make_all_cpus_request_except(kvm, req, NULL);</blue>
}
EXPORT_SYMBOL_GPL(kvm_make_all_cpus_request);

#ifndef CONFIG_HAVE_KVM_ARCH_TLB_FLUSH_ALL
void kvm_flush_remote_tlbs(struct kvm *kvm)
{
<blue>	++kvm->stat.generic.remote_tlb_flush_requests;</blue>

	/*
	 * We want to publish modifications to the page tables before reading
	 * mode. Pairs with a memory barrier in arch-specific code.
	 * - x86: smp_mb__after_srcu_read_unlock in vcpu_enter_guest
	 * and smp_mb in walk_shadow_page_lockless_begin/end.
	 * - powerpc: smp_mb in kvmppc_prepare_to_enter.
	 *
	 * There is already an smp_mb__after_atomic() before
	 * kvm_make_all_cpus_request() reads vcpu-&gt;mode. We reuse that
	 * barrier here.
	 */
<yellow>	if (!kvm_arch_flush_remote_tlb(kvm)</yellow>
<blue>	    || kvm_make_all_cpus_request(kvm, KVM_REQ_TLB_FLUSH))</blue>
<yellow>		++kvm->stat.generic.remote_tlb_flush;</yellow>
<blue>}</blue>
EXPORT_SYMBOL_GPL(kvm_flush_remote_tlbs);
#endif

static void kvm_flush_shadow_all(struct kvm *kvm)
{
	kvm_arch_flush_shadow_all(kvm);
	kvm_arch_guest_memory_reclaimed(kvm);
}

#ifdef KVM_ARCH_NR_OBJS_PER_MEMORY_CACHE
static inline void *mmu_memory_cache_alloc_obj(struct kvm_mmu_memory_cache *mc,
					       gfp_t gfp_flags)
{
	gfp_flags |= mc-&gt;gfp_zero;

	if (mc-&gt;kmem_cache)
<blue>		return kmem_cache_alloc(mc->kmem_cache, gfp_flags);</blue>
	else
<blue>		return (void *)__get_free_page(gfp_flags);</blue>
}

int __kvm_mmu_topup_memory_cache(struct kvm_mmu_memory_cache *mc, int capacity, int min)
{
<blue>	gfp_t gfp = mc->gfp_custom ? mc->gfp_custom : GFP_KERNEL_ACCOUNT;</blue>
	void *obj;

<blue>	if (mc->nobjs >= min)</blue>
		return 0;

<blue>	if (unlikely(!mc->objects)) {</blue>
<blue>		if (WARN_ON_ONCE(!capacity))</blue>
			return -EIO;

<blue>		mc->objects = kvmalloc_array(sizeof(void *), capacity, gfp);</blue>
		if (!mc-&gt;objects)
			return -ENOMEM;

<blue>		mc->capacity = capacity;</blue>
	}

	/* It is illegal to request a different capacity across topups. */
<blue>	if (WARN_ON_ONCE(mc->capacity != capacity))</blue>
		return -EIO;

<blue>	while (mc->nobjs < mc->capacity) {</blue>
<blue>		obj = mmu_memory_cache_alloc_obj(mc, gfp);</blue>
		if (!obj)
<blue>			return mc->nobjs >= min ? 0 : -ENOMEM;</blue>
<blue>		mc->objects[mc->nobjs++] = obj;</blue>
	}
	return 0;
<blue>}</blue>

int kvm_mmu_topup_memory_cache(struct kvm_mmu_memory_cache *mc, int min)
{
<blue>	return __kvm_mmu_topup_memory_cache(mc, KVM_ARCH_NR_OBJS_PER_MEMORY_CACHE, min);</blue>
}

int kvm_mmu_memory_cache_nr_free_objects(struct kvm_mmu_memory_cache *mc)
{
<yellow>	return mc->nobjs;</yellow>
}

void kvm_mmu_free_memory_cache(struct kvm_mmu_memory_cache *mc)
{
<yellow>	while (mc->nobjs) {</yellow>
<yellow>		if (mc->kmem_cache)</yellow>
<yellow>			kmem_cache_free(mc->kmem_cache, mc->objects[--mc->nobjs]);</yellow>
		else
<yellow>			free_page((unsigned long)mc->objects[--mc->nobjs]);</yellow>
	}

<yellow>	kvfree(mc->objects);</yellow>

	mc-&gt;objects = NULL;
	mc-&gt;capacity = 0;
}

void *kvm_mmu_memory_cache_alloc(struct kvm_mmu_memory_cache *mc)
{
	void *p;

<blue>	if (WARN_ON(!mc->nobjs))</blue>
<yellow>		p = mmu_memory_cache_alloc_obj(mc, GFP_ATOMIC | __GFP_ACCOUNT);</yellow>
	else
<blue>		p = mc->objects[--mc->nobjs];</blue>
<blue>	BUG_ON(!p);</blue>
	return p;
<blue>}</blue>
#endif

static void kvm_vcpu_init(struct kvm_vcpu *vcpu, struct kvm *kvm, unsigned id)
{
	mutex_init(&amp;vcpu-&gt;mutex);
	vcpu-&gt;cpu = -1;
	vcpu-&gt;kvm = kvm;
	vcpu-&gt;vcpu_id = id;
	vcpu-&gt;pid = NULL;
#ifndef __KVM_HAVE_ARCH_WQP
	rcuwait_init(&amp;vcpu-&gt;wait);
#endif
	kvm_async_pf_vcpu_init(vcpu);

	kvm_vcpu_set_in_spin_loop(vcpu, false);
	kvm_vcpu_set_dy_eligible(vcpu, false);
	vcpu-&gt;preempted = false;
	vcpu-&gt;ready = false;
	preempt_notifier_init(&amp;vcpu-&gt;preempt_notifier, &amp;kvm_preempt_ops);
	vcpu-&gt;last_used_slot = NULL;

	/* Fill the stats id string for the vcpu */
	snprintf(vcpu-&gt;stats_id, sizeof(vcpu-&gt;stats_id), &quot;kvm-%d/vcpu-%d&quot;,
		 task_pid_nr(current), id);
}

static void kvm_vcpu_destroy(struct kvm_vcpu *vcpu)
{
<yellow>	kvm_arch_vcpu_destroy(vcpu);</yellow>
	kvm_dirty_ring_free(&amp;vcpu-&gt;dirty_ring);

	/*
	 * No need for rcu_read_lock as VCPU_RUN is the only place that changes
	 * the vcpu-&gt;pid pointer, and at destruction time all file descriptors
	 * are already gone.
	 */
	put_pid(rcu_dereference_protected(vcpu-&gt;pid, 1));

	free_page((unsigned long)vcpu-&gt;run);
	kmem_cache_free(kvm_vcpu_cache, vcpu);
}

void kvm_destroy_vcpus(struct kvm *kvm)
{
	unsigned long i;
	struct kvm_vcpu *vcpu;

<yellow>	kvm_for_each_vcpu(i, vcpu, kvm) {</yellow>
<yellow>		kvm_vcpu_destroy(vcpu);</yellow>
		xa_erase(&amp;kvm-&gt;vcpu_array, i);
	}

<yellow>	atomic_set(&kvm->online_vcpus, 0);</yellow>
}
EXPORT_SYMBOL_GPL(kvm_destroy_vcpus);

#if defined(CONFIG_MMU_NOTIFIER) &amp;&amp; defined(KVM_ARCH_WANT_MMU_NOTIFIER)
static inline struct kvm *mmu_notifier_to_kvm(struct mmu_notifier *mn)
{
<blue>	return container_of(mn, struct kvm, mmu_notifier);</blue>
}

static void kvm_mmu_notifier_invalidate_range(struct mmu_notifier *mn,
					      struct mm_struct *mm,
					      unsigned long start, unsigned long end)
{
	struct kvm *kvm = mmu_notifier_to_kvm(mn);
	int idx;

<blue>	idx = srcu_read_lock(&kvm->srcu);</blue>
	kvm_arch_mmu_notifier_invalidate_range(kvm, start, end);
<blue>	srcu_read_unlock(&kvm->srcu, idx);</blue>
}

typedef bool (*hva_handler_t)(struct kvm *kvm, struct kvm_gfn_range *range);

typedef void (*on_lock_fn_t)(struct kvm *kvm, unsigned long start,
			     unsigned long end);

typedef void (*on_unlock_fn_t)(struct kvm *kvm);

struct kvm_hva_range {
	unsigned long start;
	unsigned long end;
	pte_t pte;
	hva_handler_t handler;
	on_lock_fn_t on_lock;
	on_unlock_fn_t on_unlock;
	bool flush_on_ret;
	bool may_block;
};

/*
 * Use a dedicated stub instead of NULL to indicate that there is no callback
 * function/handler.  The compiler technically can&#x27;t guarantee that a real
 * function will have a non-zero address, and so it will generate code to
 * check for !NULL, whereas comparing against a stub will be elided at compile
 * time (unless the compiler is getting long in the tooth, e.g. gcc 4.9).
 */
static void kvm_null_fn(void)
{

}
#define IS_KVM_NULL_FN(fn) ((fn) == (void *)kvm_null_fn)

/* Iterate over each memslot intersecting [start, last] (inclusive) range */
#define kvm_for_each_memslot_in_hva_range(node, slots, start, last)	     \
	for (node = interval_tree_iter_first(&amp;slots-&gt;hva_tree, start, last); \
	     node;							     \
	     node = interval_tree_iter_next(node, start, last))	     \

static __always_inline int __kvm_handle_hva_range(struct kvm *kvm,
						  const struct kvm_hva_range *range)
{
<blue>	bool ret = false, locked = false;</blue>
	struct kvm_gfn_range gfn_range;
	struct kvm_memory_slot *slot;
	struct kvm_memslots *slots;
	int i, idx;

<yellow>	if (WARN_ON_ONCE(range->end <= range->start))</yellow>
		return 0;

	/* A null handler is allowed if and only if on_lock() is provided. */
	if (WARN_ON_ONCE(IS_KVM_NULL_FN(range-&gt;on_lock) &amp;&amp;
			 IS_KVM_NULL_FN(range-&gt;handler)))
		return 0;

<blue>	idx = srcu_read_lock(&kvm->srcu);</blue>

<blue>	for (i = 0; i < KVM_ADDRESS_SPACE_NUM; i++) {</blue>
		struct interval_tree_node *node;

<blue>		slots = __kvm_memslots(kvm, i);</blue>
<blue>		kvm_for_each_memslot_in_hva_range(node, slots,</blue>
						  range-&gt;start, range-&gt;end - 1) {
			unsigned long hva_start, hva_end;

<blue>			slot = container_of(node, struct kvm_memory_slot, hva_node[slots->node_idx]);</blue>
			hva_start = max(range-&gt;start, slot-&gt;userspace_addr);
			hva_end = min(range-&gt;end, slot-&gt;userspace_addr +
						  (slot-&gt;npages &lt;&lt; PAGE_SHIFT));

			/*
			 * To optimize for the likely case where the address
			 * range is covered by zero or one memslots, don&#x27;t
			 * bother making these conditional (to avoid writes on
			 * the second or later invocation of the handler).
			 */
			gfn_range.pte = range-&gt;pte;
<blue>			gfn_range.may_block = range->may_block;</blue>

			/*
			 * {gfn(page) | page intersects with [hva_start, hva_end)} =
			 * {gfn_start, gfn_start+1, ..., gfn_end-1}.
			 */
			gfn_range.start = hva_to_gfn_memslot(hva_start, slot);
			gfn_range.end = hva_to_gfn_memslot(hva_end + PAGE_SIZE - 1, slot);
			gfn_range.slot = slot;

<blue>			if (!locked) {</blue>
				locked = true;
<blue>				KVM_MMU_LOCK(kvm);</blue>
				if (!IS_KVM_NULL_FN(range-&gt;on_lock))
<blue>					range->on_lock(kvm, range->start, range->end);</blue>
				if (IS_KVM_NULL_FN(range-&gt;handler))
					break;
			}
<blue>			ret |= range->handler(kvm, &gfn_range);</blue>
		}
	}

<blue>	if (range->flush_on_ret && ret)</blue>
<blue>		kvm_flush_remote_tlbs(kvm);</blue>

<blue>	if (locked) {</blue>
<blue>		KVM_MMU_UNLOCK(kvm);</blue>
		if (!IS_KVM_NULL_FN(range-&gt;on_unlock))
			range-&gt;on_unlock(kvm);
	}

<blue>	srcu_read_unlock(&kvm->srcu, idx);</blue>

	/* The notifiers are averse to booleans. :-( */
	return (int)ret;
}

static __always_inline int kvm_handle_hva_range(struct mmu_notifier *mn,
						unsigned long start,
						unsigned long end,
						pte_t pte,
						hva_handler_t handler)
{
	struct kvm *kvm = mmu_notifier_to_kvm(mn);
	const struct kvm_hva_range range = {
		.start		= start,
		.end		= end,
		.pte		= pte,
		.handler	= handler,
		.on_lock	= (void *)kvm_null_fn,
		.on_unlock	= (void *)kvm_null_fn,
		.flush_on_ret	= true,
		.may_block	= false,
	};

<blue>	return __kvm_handle_hva_range(kvm, &range);</blue>
}

static __always_inline int kvm_handle_hva_range_no_flush(struct mmu_notifier *mn,
							 unsigned long start,
							 unsigned long end,
							 hva_handler_t handler)
{
<yellow>	struct kvm *kvm = mmu_notifier_to_kvm(mn);</yellow>
	const struct kvm_hva_range range = {
		.start		= start,
		.end		= end,
		.pte		= __pte(0),
		.handler	= handler,
		.on_lock	= (void *)kvm_null_fn,
		.on_unlock	= (void *)kvm_null_fn,
		.flush_on_ret	= false,
		.may_block	= false,
	};

<yellow>	return __kvm_handle_hva_range(kvm, &range);</yellow>
}
static void kvm_mmu_notifier_change_pte(struct mmu_notifier *mn,
					struct mm_struct *mm,
					unsigned long address,
					pte_t pte)
<blue>{</blue>
	struct kvm *kvm = mmu_notifier_to_kvm(mn);

<blue>	trace_kvm_set_spte_hva(address);</blue>

	/*
	 * .change_pte() must be surrounded by .invalidate_range_{start,end}().
	 * If mmu_invalidate_in_progress is zero, then no in-progress
	 * invalidations, including this one, found a relevant memslot at
	 * start(); rechecking memslots here is unnecessary.  Note, a false
	 * positive (count elevated by a different invalidation) is sub-optimal
	 * but functionally ok.
	 */
<blue>	WARN_ON_ONCE(!READ_ONCE(kvm->mn_active_invalidate_count));</blue>
<blue>	if (!READ_ONCE(kvm->mmu_invalidate_in_progress))</blue>
		return;

<blue>	kvm_handle_hva_range(mn, address, address + 1, pte, kvm_set_spte_gfn);</blue>
}

<yellow>void kvm_mmu_invalidate_begin(struct kvm *kvm, unsigned long start,</yellow>
			      unsigned long end)
{
	/*
	 * The count increase must become visible at unlock time as no
	 * spte can be established without taking the mmu_lock and
	 * count is also read inside the mmu_lock critical section.
	 */
<yellow>	kvm->mmu_invalidate_in_progress++;</yellow>
	if (likely(kvm-&gt;mmu_invalidate_in_progress == 1)) {
<blue>		kvm->mmu_invalidate_range_start = start;</blue>
<yellow>		kvm->mmu_invalidate_range_end = end;</yellow>
	} else {
		/*
		 * Fully tracking multiple concurrent ranges has diminishing
		 * returns. Keep things simple and just find the minimal range
		 * which includes the current and new ranges. As there won&#x27;t be
		 * enough information to subtract a range after its invalidate
		 * completes, any ranges invalidated concurrently will
		 * accumulate and persist until all outstanding invalidates
		 * complete.
		 */
		kvm-&gt;mmu_invalidate_range_start =
<yellow>			min(kvm->mmu_invalidate_range_start, start);</yellow>
		kvm-&gt;mmu_invalidate_range_end =
			max(kvm-&gt;mmu_invalidate_range_end, end);
	}
}

static int kvm_mmu_notifier_invalidate_range_start(struct mmu_notifier *mn,
					const struct mmu_notifier_range *range)
<blue>{</blue>
<blue>	struct kvm *kvm = mmu_notifier_to_kvm(mn);</blue>
	const struct kvm_hva_range hva_range = {
		.start		= range-&gt;start,
		.end		= range-&gt;end,
		.pte		= __pte(0),
		.handler	= kvm_unmap_gfn_range,
		.on_lock	= kvm_mmu_invalidate_begin,
		.on_unlock	= kvm_arch_guest_memory_reclaimed,
		.flush_on_ret	= true,
		.may_block	= mmu_notifier_range_blockable(range),
	};

<yellow>	trace_kvm_unmap_hva_range(range->start, range->end);</yellow>

	/*
	 * Prevent memslot modification between range_start() and range_end()
	 * so that conditionally locking provides the same result in both
	 * functions.  Without that guarantee, the mmu_invalidate_in_progress
	 * adjustments will be imbalanced.
	 *
	 * Pairs with the decrement in range_end().
	 */
<blue>	spin_lock(&kvm->mn_invalidate_lock);</blue>
	kvm-&gt;mn_active_invalidate_count++;
	spin_unlock(&amp;kvm-&gt;mn_invalidate_lock);

	/*
	 * Invalidate pfn caches _before_ invalidating the secondary MMUs, i.e.
	 * before acquiring mmu_lock, to avoid holding mmu_lock while acquiring
	 * each cache&#x27;s lock.  There are relatively few caches in existence at
	 * any given time, and the caches themselves can check for hva overlap,
	 * i.e. don&#x27;t need to rely on memslot overlap checks for performance.
	 * Because this runs without holding mmu_lock, the pfn caches must use
	 * mn_active_invalidate_count (see above) instead of
	 * mmu_invalidate_in_progress.
	 */
	gfn_to_pfn_cache_invalidate_start(kvm, range-&gt;start, range-&gt;end,
<blue>					  hva_range.may_block);</blue>

<blue>	__kvm_handle_hva_range(kvm, &hva_range);</blue>

	return 0;
}

void kvm_mmu_invalidate_end(struct kvm *kvm, unsigned long start,
			    unsigned long end)
{
	/*
	 * This sequence increase will notify the kvm page fault that
	 * the page that is going to be mapped in the spte could have
	 * been freed.
	 */
<yellow>	kvm->mmu_invalidate_seq++;</yellow>
	smp_wmb();
	/*
	 * The above sequence increase must be visible before the
	 * below count decrease, which is ensured by the smp_wmb above
	 * in conjunction with the smp_rmb in mmu_invalidate_retry().
	 */
	kvm-&gt;mmu_invalidate_in_progress--;
}

static void kvm_mmu_notifier_invalidate_range_end(struct mmu_notifier *mn,
					const struct mmu_notifier_range *range)
{
	struct kvm *kvm = mmu_notifier_to_kvm(mn);
	const struct kvm_hva_range hva_range = {
<blue>		.start		= range->start,</blue>
		.end		= range-&gt;end,
		.pte		= __pte(0),
		.handler	= (void *)kvm_null_fn,
		.on_lock	= kvm_mmu_invalidate_end,
		.on_unlock	= (void *)kvm_null_fn,
		.flush_on_ret	= false,
		.may_block	= mmu_notifier_range_blockable(range),
	};
	bool wake;

<blue>	__kvm_handle_hva_range(kvm, &hva_range);</blue>

	/* Pairs with the increment in range_start(). */
<blue>	spin_lock(&kvm->mn_invalidate_lock);</blue>
	wake = (--kvm-&gt;mn_active_invalidate_count == 0);
	spin_unlock(&amp;kvm-&gt;mn_invalidate_lock);

	/*
	 * There can only be one waiter, since the wait happens under
	 * slots_lock.
	 */
	if (wake)
<blue>		rcuwait_wake_up(&kvm->mn_memslots_update_rcuwait);</blue>

<blue>	BUG_ON(kvm->mmu_invalidate_in_progress < 0);</blue>
<blue>}</blue>

static int kvm_mmu_notifier_clear_flush_young(struct mmu_notifier *mn,
					      struct mm_struct *mm,
					      unsigned long start,
					      unsigned long end)
<yellow>{</yellow>
<yellow>	trace_kvm_age_hva(start, end);</yellow>

<yellow>	return kvm_handle_hva_range(mn, start, end, __pte(0), kvm_age_gfn);</yellow>
}

static int kvm_mmu_notifier_clear_young(struct mmu_notifier *mn,
					struct mm_struct *mm,
					unsigned long start,
					unsigned long end)
<yellow>{</yellow>
<yellow>	trace_kvm_age_hva(start, end);</yellow>

	/*
	 * Even though we do not flush TLB, this will still adversely
	 * affect performance on pre-Haswell Intel EPT, where there is
	 * no EPT Access Bit to clear so that we have to tear down EPT
	 * tables instead. If we find this unacceptable, we can always
	 * add a parameter to kvm_age_hva so that it effectively doesn&#x27;t
	 * do anything on clear_young.
	 *
	 * Also note that currently we never issue secondary TLB flushes
	 * from clear_young, leaving this job up to the regular system
	 * cadence. If we find this inaccurate, we might come up with a
	 * more sophisticated heuristic later.
	 */
<yellow>	return kvm_handle_hva_range_no_flush(mn, start, end, kvm_age_gfn);</yellow>
}

static int kvm_mmu_notifier_test_young(struct mmu_notifier *mn,
				       struct mm_struct *mm,
				       unsigned long address)
<yellow>{</yellow>
<yellow>	trace_kvm_test_age_hva(address);</yellow>

<yellow>	return kvm_handle_hva_range_no_flush(mn, address, address + 1,</yellow>
					     kvm_test_age_gfn);
}

static void kvm_mmu_notifier_release(struct mmu_notifier *mn,
				     struct mm_struct *mm)
{
	struct kvm *kvm = mmu_notifier_to_kvm(mn);
	int idx;

<yellow>	idx = srcu_read_lock(&kvm->srcu);</yellow>
	kvm_flush_shadow_all(kvm);
<yellow>	srcu_read_unlock(&kvm->srcu, idx);</yellow>
}

static const struct mmu_notifier_ops kvm_mmu_notifier_ops = {
	.invalidate_range	= kvm_mmu_notifier_invalidate_range,
	.invalidate_range_start	= kvm_mmu_notifier_invalidate_range_start,
	.invalidate_range_end	= kvm_mmu_notifier_invalidate_range_end,
	.clear_flush_young	= kvm_mmu_notifier_clear_flush_young,
	.clear_young		= kvm_mmu_notifier_clear_young,
	.test_young		= kvm_mmu_notifier_test_young,
	.change_pte		= kvm_mmu_notifier_change_pte,
	.release		= kvm_mmu_notifier_release,
};

static int kvm_init_mmu_notifier(struct kvm *kvm)
{
	kvm-&gt;mmu_notifier.ops = &amp;kvm_mmu_notifier_ops;
	return mmu_notifier_register(&amp;kvm-&gt;mmu_notifier, current-&gt;mm);
}

#else  /* !(CONFIG_MMU_NOTIFIER &amp;&amp; KVM_ARCH_WANT_MMU_NOTIFIER) */

static int kvm_init_mmu_notifier(struct kvm *kvm)
{
	return 0;
}

#endif /* CONFIG_MMU_NOTIFIER &amp;&amp; KVM_ARCH_WANT_MMU_NOTIFIER */

#ifdef CONFIG_HAVE_KVM_PM_NOTIFIER
static int kvm_pm_notifier_call(struct notifier_block *bl,
				unsigned long state,
				void *unused)
{
<yellow>	struct kvm *kvm = container_of(bl, struct kvm, pm_notifier);</yellow>

	return kvm_arch_pm_notifier(kvm, state);
}

static void kvm_init_pm_notifier(struct kvm *kvm)
{
	kvm-&gt;pm_notifier.notifier_call = kvm_pm_notifier_call;
	/* Suspend KVM before we suspend ftrace, RCU, etc. */
	kvm-&gt;pm_notifier.priority = INT_MAX;
	register_pm_notifier(&amp;kvm-&gt;pm_notifier);
}

static void kvm_destroy_pm_notifier(struct kvm *kvm)
{
	unregister_pm_notifier(&amp;kvm-&gt;pm_notifier);
}
#else /* !CONFIG_HAVE_KVM_PM_NOTIFIER */
static void kvm_init_pm_notifier(struct kvm *kvm)
{
}

static void kvm_destroy_pm_notifier(struct kvm *kvm)
{
}
#endif /* CONFIG_HAVE_KVM_PM_NOTIFIER */

static void kvm_destroy_dirty_bitmap(struct kvm_memory_slot *memslot)
{
<yellow>	if (!memslot->dirty_bitmap)</yellow>
		return;

<yellow>	kvfree(memslot->dirty_bitmap);</yellow>
	memslot-&gt;dirty_bitmap = NULL;
}

/* This does not remove the slot from struct kvm_memslots data structures */
static void kvm_free_memslot(struct kvm *kvm, struct kvm_memory_slot *slot)
{
<yellow>	kvm_destroy_dirty_bitmap(slot);</yellow>

<yellow>	kvm_arch_free_memslot(kvm, slot);</yellow>

	kfree(slot);
}

static void kvm_free_memslots(struct kvm *kvm, struct kvm_memslots *slots)
{
	struct hlist_node *idnode;
	struct kvm_memory_slot *memslot;
	int bkt;

	/*
	 * The same memslot objects live in both active and inactive sets,
	 * arbitrarily free using index &#x27;1&#x27; so the second invocation of this
	 * function isn&#x27;t operating over a structure with dangling pointers
	 * (even though this function isn&#x27;t actually touching them).
	 */
<yellow>	if (!slots->node_idx)</yellow>
		return;

<yellow>	hash_for_each_safe(slots->id_hash, bkt, idnode, memslot, id_node[1])</yellow>
<yellow>		kvm_free_memslot(kvm, memslot);</yellow>
<yellow>}</yellow>

static umode_t kvm_stats_debugfs_mode(const struct _kvm_stats_desc *pdesc)
{
<yellow>	switch (pdesc->desc.flags & KVM_STATS_TYPE_MASK) {</yellow>
	case KVM_STATS_TYPE_INSTANT:
		return 0444;
	case KVM_STATS_TYPE_CUMULATIVE:
	case KVM_STATS_TYPE_PEAK:
	default:
		return 0644;
	}
}


static void kvm_destroy_vm_debugfs(struct kvm *kvm)
{
	int i;
<yellow>	int kvm_debugfs_num_entries = kvm_vm_stats_header.num_desc +</yellow>
				      kvm_vcpu_stats_header.num_desc;

	if (IS_ERR(kvm-&gt;debugfs_dentry))
		return;

<yellow>	debugfs_remove_recursive(kvm->debugfs_dentry);</yellow>

	if (kvm-&gt;debugfs_stat_data) {
		for (i = 0; i &lt; kvm_debugfs_num_entries; i++)
<yellow>			kfree(kvm->debugfs_stat_data[i]);</yellow>
<yellow>		kfree(kvm->debugfs_stat_data);</yellow>
	}
<yellow>}</yellow>

static int kvm_create_vm_debugfs(struct kvm *kvm, const char *fdname)
{
	static DEFINE_MUTEX(kvm_debugfs_lock);
	struct dentry *dent;
	char dir_name[ITOA_MAX_LEN * 2];
	struct kvm_stat_data *stat_data;
	const struct _kvm_stats_desc *pdesc;
	int i, ret = -ENOMEM;
<yellow>	int kvm_debugfs_num_entries = kvm_vm_stats_header.num_desc +</yellow>
				      kvm_vcpu_stats_header.num_desc;

	if (!debugfs_initialized())
		return 0;

<yellow>	snprintf(dir_name, sizeof(dir_name), "%d-%s", task_pid_nr(current), fdname);</yellow>
	mutex_lock(&amp;kvm_debugfs_lock);
	dent = debugfs_lookup(dir_name, kvm_debugfs_dir);
	if (dent) {
<yellow>		pr_warn_ratelimited("KVM: debugfs: duplicate directory %s\n", dir_name);</yellow>
<yellow>		dput(dent);</yellow>
		mutex_unlock(&amp;kvm_debugfs_lock);
		return 0;
	}
<yellow>	dent = debugfs_create_dir(dir_name, kvm_debugfs_dir);</yellow>
	mutex_unlock(&amp;kvm_debugfs_lock);
	if (IS_ERR(dent))
		return 0;

<yellow>	kvm->debugfs_dentry = dent;</yellow>
<yellow>	kvm->debugfs_stat_data = kcalloc(kvm_debugfs_num_entries,</yellow>
					 sizeof(*kvm-&gt;debugfs_stat_data),
					 GFP_KERNEL_ACCOUNT);
	if (!kvm-&gt;debugfs_stat_data)
		goto out_err;

<yellow>	for (i = 0; i < kvm_vm_stats_header.num_desc; ++i) {</yellow>
<yellow>		pdesc = &kvm_vm_stats_desc[i];</yellow>
		stat_data = kzalloc(sizeof(*stat_data), GFP_KERNEL_ACCOUNT);
		if (!stat_data)
			goto out_err;

<yellow>		stat_data->kvm = kvm;</yellow>
		stat_data-&gt;desc = pdesc;
		stat_data-&gt;kind = KVM_STAT_VM;
		kvm-&gt;debugfs_stat_data[i] = stat_data;
<yellow>		debugfs_create_file(pdesc->name, kvm_stats_debugfs_mode(pdesc),</yellow>
				    kvm-&gt;debugfs_dentry, stat_data,
				    &amp;stat_fops_per_vm);
	}

<yellow>	for (i = 0; i < kvm_vcpu_stats_header.num_desc; ++i) {</yellow>
<yellow>		pdesc = &kvm_vcpu_stats_desc[i];</yellow>
		stat_data = kzalloc(sizeof(*stat_data), GFP_KERNEL_ACCOUNT);
		if (!stat_data)
			goto out_err;

<yellow>		stat_data->kvm = kvm;</yellow>
		stat_data-&gt;desc = pdesc;
		stat_data-&gt;kind = KVM_STAT_VCPU;
		kvm-&gt;debugfs_stat_data[i + kvm_vm_stats_header.num_desc] = stat_data;
<yellow>		debugfs_create_file(pdesc->name, kvm_stats_debugfs_mode(pdesc),</yellow>
				    kvm-&gt;debugfs_dentry, stat_data,
				    &amp;stat_fops_per_vm);
	}

<yellow>	ret = kvm_arch_create_vm_debugfs(kvm);</yellow>
	if (ret)
		goto out_err;

	return 0;
out_err:
<yellow>	kvm_destroy_vm_debugfs(kvm);</yellow>
	return ret;
}

/*
 * Called after the VM is otherwise initialized, but just before adding it to
 * the vm_list.
 */
int __weak kvm_arch_post_init_vm(struct kvm *kvm)
{
	return 0;
<yellow>}</yellow>

/*
 * Called just after removing the VM from the vm_list, but before doing any
 * other destruction.
 */
void __weak kvm_arch_pre_destroy_vm(struct kvm *kvm)
{
<yellow>}</yellow>

/*
 * Called after per-vm debugfs created.  When called kvm-&gt;debugfs_dentry should
 * be setup already, so we can create arch-specific debugfs entries under it.
 * Cleanup should be automatic done in kvm_destroy_vm_debugfs() recursively, so
 * a per-arch destroy interface is not needed.
 */
int __weak kvm_arch_create_vm_debugfs(struct kvm *kvm)
{
	return 0;
}

static struct kvm *kvm_create_vm(unsigned long type, const char *fdname)
{
	struct kvm *kvm = kvm_arch_alloc_vm();
	struct kvm_memslots *slots;
	int r = -ENOMEM;
	int i, j;

	if (!kvm)
		return ERR_PTR(-ENOMEM);

	/* KVM is pinned via open(&quot;/dev/kvm&quot;), the fd passed to this ioctl(). */
<yellow>	__module_get(kvm_chardev_ops.owner);</yellow>

	KVM_MMU_LOCK_INIT(kvm);
	mmgrab(current-&gt;mm);
	kvm-&gt;mm = current-&gt;mm;
	kvm_eventfd_init(kvm);
	mutex_init(&amp;kvm-&gt;lock);
	mutex_init(&amp;kvm-&gt;irq_lock);
	mutex_init(&amp;kvm-&gt;slots_lock);
	mutex_init(&amp;kvm-&gt;slots_arch_lock);
	spin_lock_init(&amp;kvm-&gt;mn_invalidate_lock);
	rcuwait_init(&amp;kvm-&gt;mn_memslots_update_rcuwait);
	xa_init(&amp;kvm-&gt;vcpu_array);

	INIT_LIST_HEAD(&amp;kvm-&gt;gpc_list);
	spin_lock_init(&amp;kvm-&gt;gpc_lock);

	INIT_LIST_HEAD(&amp;kvm-&gt;devices);
	kvm-&gt;max_vcpus = KVM_MAX_VCPUS;

	BUILD_BUG_ON(KVM_MEM_SLOTS_NUM &gt; SHRT_MAX);

	/*
	 * Force subsequent debugfs file creations to fail if the VM directory
	 * is not created (by kvm_create_vm_debugfs()).
	 */
	kvm-&gt;debugfs_dentry = ERR_PTR(-ENOENT);

	snprintf(kvm-&gt;stats_id, sizeof(kvm-&gt;stats_id), &quot;kvm-%d&quot;,
		 task_pid_nr(current));

	if (init_srcu_struct(&amp;kvm-&gt;srcu))
		goto out_err_no_srcu;
<yellow>	if (init_srcu_struct(&kvm->irq_srcu))</yellow>
		goto out_err_no_irq_srcu;

<yellow>	refcount_set(&kvm->users_count, 1);</yellow>
	for (i = 0; i &lt; KVM_ADDRESS_SPACE_NUM; i++) {
<yellow>		for (j = 0; j < 2; j++) {</yellow>
<yellow>			slots = &kvm->__memslots[i][j];</yellow>

			atomic_long_set(&amp;slots-&gt;last_used_slot, (unsigned long)NULL);
			slots-&gt;hva_tree = RB_ROOT_CACHED;
			slots-&gt;gfn_tree = RB_ROOT;
<yellow>			hash_init(slots->id_hash);</yellow>
<yellow>			slots->node_idx = j;</yellow>

			/* Generations must be different for each address space. */
			slots-&gt;generation = i;
		}

<yellow>		rcu_assign_pointer(kvm->memslots[i], &kvm->__memslots[i][0]);</yellow>
	}

<yellow>	for (i = 0; i < KVM_NR_BUSES; i++) {</yellow>
<yellow>		rcu_assign_pointer(kvm->buses[i],</yellow>
			kzalloc(sizeof(struct kvm_io_bus), GFP_KERNEL_ACCOUNT));
		if (!kvm-&gt;buses[i])
			goto out_err_no_arch_destroy_vm;
	}

<yellow>	r = kvm_arch_init_vm(kvm, type);</yellow>
	if (r)
		goto out_err_no_arch_destroy_vm;

<yellow>	r = hardware_enable_all();</yellow>
	if (r)
		goto out_err_no_disable;

#ifdef CONFIG_HAVE_KVM_IRQFD
	INIT_HLIST_HEAD(&amp;kvm-&gt;irq_ack_notifier_list);
#endif

	r = kvm_init_mmu_notifier(kvm);
	if (r)
		goto out_err_no_mmu_notifier;

<yellow>	r = kvm_coalesced_mmio_init(kvm);</yellow>
	if (r &lt; 0)
		goto out_no_coalesced_mmio;

<yellow>	r = kvm_create_vm_debugfs(kvm, fdname);</yellow>
	if (r)
		goto out_err_no_debugfs;

<yellow>	r = kvm_arch_post_init_vm(kvm);</yellow>
	if (r)
		goto out_err;

<yellow>	mutex_lock(&kvm_lock);</yellow>
	list_add(&amp;kvm-&gt;vm_list, &amp;vm_list);
	mutex_unlock(&amp;kvm_lock);

	preempt_notifier_inc();
	kvm_init_pm_notifier(kvm);

	return kvm;

out_err:
	kvm_destroy_vm_debugfs(kvm);
out_err_no_debugfs:
<yellow>	kvm_coalesced_mmio_free(kvm);</yellow>
out_no_coalesced_mmio:
#if defined(CONFIG_MMU_NOTIFIER) &amp;&amp; defined(KVM_ARCH_WANT_MMU_NOTIFIER)
<yellow>	if (kvm->mmu_notifier.ops)</yellow>
<yellow>		mmu_notifier_unregister(&kvm->mmu_notifier, current->mm);</yellow>
#endif
out_err_no_mmu_notifier:
<yellow>	hardware_disable_all();</yellow>
out_err_no_disable:
<yellow>	kvm_arch_destroy_vm(kvm);</yellow>
out_err_no_arch_destroy_vm:
<yellow>	WARN_ON_ONCE(!refcount_dec_and_test(&kvm->users_count));</yellow>
	for (i = 0; i &lt; KVM_NR_BUSES; i++)
<yellow>		kfree(kvm_get_bus(kvm, i));</yellow>
<yellow>	cleanup_srcu_struct(&kvm->irq_srcu);</yellow>
out_err_no_irq_srcu:
<yellow>	cleanup_srcu_struct(&kvm->srcu);</yellow>
out_err_no_srcu:
<yellow>	kvm_arch_free_vm(kvm);</yellow>
<yellow>	mmdrop(current->mm);</yellow>
<yellow>	module_put(kvm_chardev_ops.owner);</yellow>
<yellow>	return ERR_PTR(r);</yellow>
}

static void kvm_destroy_devices(struct kvm *kvm)
{
	struct kvm_device *dev, *tmp;

	/*
	 * We do not need to take the kvm-&gt;lock here, because nobody else
	 * has a reference to the struct kvm at this point and therefore
	 * cannot access the devices list anyhow.
	 */
	list_for_each_entry_safe(dev, tmp, &amp;kvm-&gt;devices, vm_node) {
<yellow>		list_del(&dev->vm_node);</yellow>
		dev-&gt;ops-&gt;destroy(dev);
	}
}

static void kvm_destroy_vm(struct kvm *kvm)
{
	int i;
<yellow>	struct mm_struct *mm = kvm->mm;</yellow>

	kvm_destroy_pm_notifier(kvm);
<yellow>	kvm_uevent_notify_change(KVM_EVENT_DESTROY_VM, kvm);</yellow>
<yellow>	kvm_destroy_vm_debugfs(kvm);</yellow>
	kvm_arch_sync_events(kvm);
	mutex_lock(&amp;kvm_lock);
	list_del(&amp;kvm-&gt;vm_list);
	mutex_unlock(&amp;kvm_lock);
	kvm_arch_pre_destroy_vm(kvm);

	kvm_free_irq_routing(kvm);
	for (i = 0; i &lt; KVM_NR_BUSES; i++) {
<yellow>		struct kvm_io_bus *bus = kvm_get_bus(kvm, i);</yellow>

		if (bus)
<yellow>			kvm_io_bus_destroy(bus);</yellow>
<yellow>		kvm->buses[i] = NULL;</yellow>
	}
<yellow>	kvm_coalesced_mmio_free(kvm);</yellow>
#if defined(CONFIG_MMU_NOTIFIER) &amp;&amp; defined(KVM_ARCH_WANT_MMU_NOTIFIER)
	mmu_notifier_unregister(&amp;kvm-&gt;mmu_notifier, kvm-&gt;mm);
	/*
	 * At this point, pending calls to invalidate_range_start()
	 * have completed but no more MMU notifiers will run, so
	 * mn_active_invalidate_count may remain unbalanced.
	 * No threads can be waiting in install_new_memslots as the
	 * last reference on KVM has been dropped, but freeing
	 * memslots would deadlock without this manual intervention.
	 */
<yellow>	WARN_ON(rcuwait_active(&kvm->mn_memslots_update_rcuwait));</yellow>
<yellow>	kvm->mn_active_invalidate_count = 0;</yellow>
#else
	kvm_flush_shadow_all(kvm);
#endif
	kvm_arch_destroy_vm(kvm);
<yellow>	kvm_destroy_devices(kvm);</yellow>
<yellow>	for (i = 0; i < KVM_ADDRESS_SPACE_NUM; i++) {</yellow>
<yellow>		kvm_free_memslots(kvm, &kvm->__memslots[i][0]);</yellow>
<yellow>		kvm_free_memslots(kvm, &kvm->__memslots[i][1]);</yellow>
	}
<yellow>	cleanup_srcu_struct(&kvm->irq_srcu);</yellow>
	cleanup_srcu_struct(&amp;kvm-&gt;srcu);
	kvm_arch_free_vm(kvm);
	preempt_notifier_dec();
<yellow>	hardware_disable_all();</yellow>
<yellow>	mmdrop(mm);</yellow>
<yellow>	module_put(kvm_chardev_ops.owner);</yellow>
}

void kvm_get_kvm(struct kvm *kvm)
{
<blue>	refcount_inc(&kvm->users_count);</blue>
<yellow>}</yellow>
EXPORT_SYMBOL_GPL(kvm_get_kvm);

/*
 * Make sure the vm is not during destruction, which is a safe version of
 * kvm_get_kvm().  Return true if kvm referenced successfully, false otherwise.
 */
bool kvm_get_kvm_safe(struct kvm *kvm)
{
<yellow>	return refcount_inc_not_zero(&kvm->users_count);</yellow>
}
EXPORT_SYMBOL_GPL(kvm_get_kvm_safe);

void kvm_put_kvm(struct kvm *kvm)
{
<yellow>	if (refcount_dec_and_test(&kvm->users_count))</yellow>
<yellow>		kvm_destroy_vm(kvm);</yellow>
<yellow>}</yellow>
EXPORT_SYMBOL_GPL(kvm_put_kvm);

/*
 * Used to put a reference that was taken on behalf of an object associated
 * with a user-visible file descriptor, e.g. a vcpu or device, if installation
 * of the new file descriptor fails and the reference cannot be transferred to
 * its final owner.  In such cases, the caller is still actively using @kvm and
 * will fail miserably if the refcount unexpectedly hits zero.
 */
void kvm_put_kvm_no_destroy(struct kvm *kvm)
{
<yellow>	WARN_ON(refcount_dec_and_test(&kvm->users_count));</yellow>
<yellow>}</yellow>
EXPORT_SYMBOL_GPL(kvm_put_kvm_no_destroy);

static int kvm_vm_release(struct inode *inode, struct file *filp)
{
<yellow>	struct kvm *kvm = filp->private_data;</yellow>

	kvm_irqfd_release(kvm);

	kvm_put_kvm(kvm);
	return 0;
}

/*
 * Allocation size is twice as large as the actual dirty bitmap size.
 * See kvm_vm_ioctl_get_dirty_log() why this is needed.
 */
static int kvm_alloc_dirty_bitmap(struct kvm_memory_slot *memslot)
{
<yellow>	unsigned long dirty_bytes = kvm_dirty_bitmap_bytes(memslot);</yellow>

	memslot-&gt;dirty_bitmap = __vcalloc(2, dirty_bytes, GFP_KERNEL_ACCOUNT);
	if (!memslot-&gt;dirty_bitmap)
		return -ENOMEM;

	return 0;
}

static struct kvm_memslots *kvm_get_inactive_memslots(struct kvm *kvm, int as_id)
{
<blue>	struct kvm_memslots *active = __kvm_memslots(kvm, as_id);</blue>
	int node_idx_inactive = active-&gt;node_idx ^ 1;

	return &amp;kvm-&gt;__memslots[as_id][node_idx_inactive];
}

/*
 * Helper to get the address space ID when one of memslot pointers may be NULL.
 * This also serves as a sanity that at least one of the pointers is non-NULL,
 * and that their address space IDs don&#x27;t diverge.
 */
<yellow>static int kvm_memslots_get_as_id(struct kvm_memory_slot *a,</yellow>
				  struct kvm_memory_slot *b)
{
<blue>	if (WARN_ON_ONCE(!a && !b))</blue>
		return 0;

	if (!a)
<blue>		return b->as_id;</blue>
<yellow>	if (!b)</yellow>
<yellow>		return a->as_id;</yellow>

<yellow>	WARN_ON_ONCE(a->as_id != b->as_id);</yellow>
	return a-&gt;as_id;
}

static void kvm_insert_gfn_node(struct kvm_memslots *slots,
				struct kvm_memory_slot *slot)
{
	struct rb_root *gfn_tree = &amp;slots-&gt;gfn_tree;
	struct rb_node **node, *parent;
<blue>	int idx = slots->node_idx;</blue>

	parent = NULL;
<yellow>	for (node = &gfn_tree->rb_node; *node; ) {</yellow>
		struct kvm_memory_slot *tmp;

<yellow>		tmp = container_of(*node, struct kvm_memory_slot, gfn_node[idx]);</yellow>
		parent = *node;
<yellow>		if (slot->base_gfn < tmp->base_gfn)</yellow>
<yellow>			node = &(*node)->rb_left;</yellow>
<yellow>		else if (slot->base_gfn > tmp->base_gfn)</yellow>
<yellow>			node = &(*node)->rb_right;</yellow>
		else
<yellow>			BUG();</yellow>
	}

<blue>	rb_link_node(&slot->gfn_node[idx], parent, node);</blue>
	rb_insert_color(&amp;slot-&gt;gfn_node[idx], gfn_tree);
}

static void kvm_erase_gfn_node(struct kvm_memslots *slots,
			       struct kvm_memory_slot *slot)
{
<yellow>	rb_erase(&slot->gfn_node[slots->node_idx], &slots->gfn_tree);</yellow>
}

static void kvm_replace_gfn_node(struct kvm_memslots *slots,
				 struct kvm_memory_slot *old,
				 struct kvm_memory_slot *new)
{
	int idx = slots-&gt;node_idx;

	WARN_ON_ONCE(old-&gt;base_gfn != new-&gt;base_gfn);

<yellow>	rb_replace_node(&old->gfn_node[idx], &new->gfn_node[idx],</yellow>
			&amp;slots-&gt;gfn_tree);
}

/*
 * Replace @old with @new in the inactive memslots.
 *
 * With NULL @old this simply adds @new.
 * With NULL @new this simply removes @old.
 *
 * If @new is non-NULL its hva_node[slots_idx] range has to be set
 * appropriately.
 */
static void kvm_replace_memslot(struct kvm *kvm,
				struct kvm_memory_slot *old,
				struct kvm_memory_slot *new)
{
<blue>	int as_id = kvm_memslots_get_as_id(old, new);</blue>
<blue>	struct kvm_memslots *slots = kvm_get_inactive_memslots(kvm, as_id);</blue>
	int idx = slots-&gt;node_idx;

	if (old) {
<yellow>		hash_del(&old->id_node[idx]);</yellow>
<blue>		interval_tree_remove(&old->hva_node[idx], &slots->hva_tree);</blue>

		if ((long)old == atomic_long_read(&amp;slots-&gt;last_used_slot))
<yellow>			atomic_long_set(&slots->last_used_slot, (long)new);</yellow>

<yellow>		if (!new) {</yellow>
<yellow>			kvm_erase_gfn_node(slots, old);</yellow>
			return;
		}
	}

	/*
	 * Initialize @new&#x27;s hva range.  Do this even when replacing an @old
	 * slot, kvm_copy_memslot() deliberately does not touch node data.
	 */
<blue>	new->hva_node[idx].start = new->userspace_addr;</blue>
	new-&gt;hva_node[idx].last = new-&gt;userspace_addr +
				  (new-&gt;npages &lt;&lt; PAGE_SHIFT) - 1;

	/*
	 * (Re)Add the new memslot.  There is no O(1) interval_tree_replace(),
	 * hva_node needs to be swapped with remove+insert even though hva can&#x27;t
	 * change when replacing an existing slot.
	 */
<blue>	hash_add(slots->id_hash, &new->id_node[idx], new->id);</blue>
	interval_tree_insert(&amp;new-&gt;hva_node[idx], &amp;slots-&gt;hva_tree);

	/*
	 * If the memslot gfn is unchanged, rb_replace_node() can be used to
	 * switch the node in the gfn tree instead of removing the old and
	 * inserting the new as two separate operations. Replacement is a
	 * single O(1) operation versus two O(log(n)) operations for
	 * remove+insert.
	 */
<yellow>	if (old && old->base_gfn == new->base_gfn) {</yellow>
<yellow>		kvm_replace_gfn_node(slots, old, new);</yellow>
	} else {
		if (old)
<yellow>			kvm_erase_gfn_node(slots, old);</yellow>
<blue>		kvm_insert_gfn_node(slots, new);</blue>
	}
<blue>}</blue>

static int check_memory_region_flags(const struct kvm_userspace_memory_region *mem)
{
	u32 valid_flags = KVM_MEM_LOG_DIRTY_PAGES;

#ifdef __KVM_HAVE_READONLY_MEM
	valid_flags |= KVM_MEM_READONLY;
#endif

<blue>	if (mem->flags & ~valid_flags)</blue>
		return -EINVAL;

	return 0;
}

static void kvm_swap_active_memslots(struct kvm *kvm, int as_id)
{
<blue>	struct kvm_memslots *slots = kvm_get_inactive_memslots(kvm, as_id);</blue>

	/* Grab the generation from the activate memslots. */
	u64 gen = __kvm_memslots(kvm, as_id)-&gt;generation;

<yellow>	WARN_ON(gen & KVM_MEMSLOT_GEN_UPDATE_IN_PROGRESS);</yellow>
<blue>	slots->generation = gen | KVM_MEMSLOT_GEN_UPDATE_IN_PROGRESS;</blue>

	/*
	 * Do not store the new memslots while there are invalidations in
	 * progress, otherwise the locking in invalidate_range_start and
	 * invalidate_range_end will be unbalanced.
	 */
	spin_lock(&amp;kvm-&gt;mn_invalidate_lock);
	prepare_to_rcuwait(&amp;kvm-&gt;mn_memslots_update_rcuwait);
	while (kvm-&gt;mn_active_invalidate_count) {
<yellow>		set_current_state(TASK_UNINTERRUPTIBLE);</yellow>
		spin_unlock(&amp;kvm-&gt;mn_invalidate_lock);
		schedule();
		spin_lock(&amp;kvm-&gt;mn_invalidate_lock);
	}
<blue>	finish_rcuwait(&kvm->mn_memslots_update_rcuwait);</blue>
	rcu_assign_pointer(kvm-&gt;memslots[as_id], slots);
	spin_unlock(&amp;kvm-&gt;mn_invalidate_lock);

	/*
	 * Acquired in kvm_set_memslot. Must be released before synchronize
	 * SRCU below in order to avoid deadlock with another thread
	 * acquiring the slots_arch_lock in an srcu critical section.
	 */
	mutex_unlock(&amp;kvm-&gt;slots_arch_lock);

	synchronize_srcu_expedited(&amp;kvm-&gt;srcu);

	/*
	 * Increment the new memslot generation a second time, dropping the
	 * update in-progress flag and incrementing the generation based on
	 * the number of address spaces.  This provides a unique and easily
	 * identifiable generation number while the memslots are in flux.
	 */
	gen = slots-&gt;generation &amp; ~KVM_MEMSLOT_GEN_UPDATE_IN_PROGRESS;

	/*
	 * Generations must be unique even across address spaces.  We do not need
	 * a global counter for that, instead the generation space is evenly split
	 * across address spaces.  For example, with two address spaces, address
	 * space 0 will use generations 0, 2, 4, ... while address space 1 will
	 * use generations 1, 3, 5, ...
	 */
	gen += KVM_ADDRESS_SPACE_NUM;

	kvm_arch_memslots_updated(kvm, gen);

	slots-&gt;generation = gen;
}

static int kvm_prepare_memory_region(struct kvm *kvm,
				     const struct kvm_memory_slot *old,
				     struct kvm_memory_slot *new,
				     enum kvm_mr_change change)
{
	int r;

	/*
	 * If dirty logging is disabled, nullify the bitmap; the old bitmap
	 * will be freed on &quot;commit&quot;.  If logging is enabled in both old and
	 * new, reuse the existing bitmap.  If logging is enabled only in the
	 * new and KVM isn&#x27;t using a ring buffer, allocate and initialize a
	 * new bitmap.
	 */
<blue>	if (change != KVM_MR_DELETE) {</blue>
<blue>		if (!(new->flags & KVM_MEM_LOG_DIRTY_PAGES))</blue>
<blue>			new->dirty_bitmap = NULL;</blue>
<yellow>		else if (old && old->dirty_bitmap)</yellow>
<yellow>			new->dirty_bitmap = old->dirty_bitmap;</yellow>
<yellow>		else if (!kvm->dirty_ring_size) {</yellow>
<yellow>			r = kvm_alloc_dirty_bitmap(new);</yellow>
			if (r)
				return r;

<yellow>			if (kvm_dirty_log_manual_protect_and_init_set(kvm))</yellow>
<yellow>				bitmap_set(new->dirty_bitmap, 0, new->npages);</yellow>
		}
	}

<blue>	r = kvm_arch_prepare_memory_region(kvm, old, new, change);</blue>

	/* Free the bitmap on failure if it was allocated above. */
<yellow>	if (r && new && new->dirty_bitmap && (!old || !old->dirty_bitmap))</yellow>
<yellow>		kvm_destroy_dirty_bitmap(new);</yellow>

	return r;
}

static void kvm_commit_memory_region(struct kvm *kvm,
				     struct kvm_memory_slot *old,
				     const struct kvm_memory_slot *new,
				     enum kvm_mr_change change)
{
	/*
	 * Update the total number of memslot pages before calling the arch
	 * hook so that architectures can consume the result directly.
	 */
<yellow>	if (change == KVM_MR_DELETE)</yellow>
<yellow>		kvm->nr_memslot_pages -= old->npages;</yellow>
	else if (change == KVM_MR_CREATE)
		kvm-&gt;nr_memslot_pages += new-&gt;npages;

<yellow>	kvm_arch_commit_memory_region(kvm, old, new, change);</yellow>

	switch (change) {
	case KVM_MR_CREATE:
		/* Nothing more to do. */
		break;
	case KVM_MR_DELETE:
		/* Free the old memslot and all its metadata. */
<yellow>		kvm_free_memslot(kvm, old);</yellow>
		break;
	case KVM_MR_MOVE:
	case KVM_MR_FLAGS_ONLY:
		/*
		 * Free the dirty bitmap as needed; the below check encompasses
		 * both the flags and whether a ring buffer is being used)
		 */
<yellow>		if (old->dirty_bitmap && !new->dirty_bitmap)</yellow>
<yellow>			kvm_destroy_dirty_bitmap(old);</yellow>

		/*
		 * The final quirk.  Free the detached, old slot, but only its
		 * memory, not any metadata.  Metadata, including arch specific
		 * data, may be reused by @new.
		 */
<yellow>		kfree(old);</yellow>
		break;
	default:
		BUG();
	}
}

/*
 * Activate @new, which must be installed in the inactive slots by the caller,
 * by swapping the active slots and then propagating @new to @old once @old is
 * unreachable and can be safely modified.
 *
 * With NULL @old this simply adds @new to @active (while swapping the sets).
 * With NULL @new this simply removes @old from @active and frees it
 * (while also swapping the sets).
 */
static void kvm_activate_memslot(struct kvm *kvm,
				 struct kvm_memory_slot *old,
				 struct kvm_memory_slot *new)
{
<blue>	int as_id = kvm_memslots_get_as_id(old, new);</blue>

<blue>	kvm_swap_active_memslots(kvm, as_id);</blue>

	/* Propagate the new memslot to the now inactive memslots. */
	kvm_replace_memslot(kvm, old, new);
}

static void kvm_copy_memslot(struct kvm_memory_slot *dest,
			     const struct kvm_memory_slot *src)
{
<yellow>	dest->base_gfn = src->base_gfn;</yellow>
	dest-&gt;npages = src-&gt;npages;
	dest-&gt;dirty_bitmap = src-&gt;dirty_bitmap;
	dest-&gt;arch = src-&gt;arch;
	dest-&gt;userspace_addr = src-&gt;userspace_addr;
	dest-&gt;flags = src-&gt;flags;
	dest-&gt;id = src-&gt;id;
	dest-&gt;as_id = src-&gt;as_id;
}

static void kvm_invalidate_memslot(struct kvm *kvm,
				   struct kvm_memory_slot *old,
				   struct kvm_memory_slot *invalid_slot)
{
	/*
	 * Mark the current slot INVALID.  As with all memslot modifications,
	 * this must be done on an unreachable slot to avoid modifying the
	 * current slot in the active tree.
	 */
<yellow>	kvm_copy_memslot(invalid_slot, old);</yellow>
	invalid_slot-&gt;flags |= KVM_MEMSLOT_INVALID;
	kvm_replace_memslot(kvm, old, invalid_slot);

	/*
	 * Activate the slot that is now marked INVALID, but don&#x27;t propagate
	 * the slot to the now inactive slots. The slot is either going to be
	 * deleted or recreated as a new slot.
	 */
	kvm_swap_active_memslots(kvm, old-&gt;as_id);

	/*
	 * From this point no new shadow pages pointing to a deleted, or moved,
	 * memslot will be created.  Validation of sp-&gt;gfn happens in:
	 *	- gfn_to_hva (kvm_read_guest, gfn_to_pfn)
	 *	- kvm_is_visible_gfn (mmu_check_root)
	 */
	kvm_arch_flush_shadow_memslot(kvm, old);
	kvm_arch_guest_memory_reclaimed(kvm);

	/* Was released by kvm_swap_active_memslots, reacquire. */
	mutex_lock(&amp;kvm-&gt;slots_arch_lock);

	/*
	 * Copy the arch-specific field of the newly-installed slot back to the
	 * old slot as the arch data could have changed between releasing
	 * slots_arch_lock in install_new_memslots() and re-acquiring the lock
	 * above.  Writers are required to retrieve memslots *after* acquiring
	 * slots_arch_lock, thus the active slot&#x27;s data is guaranteed to be fresh.
	 */
	old-&gt;arch = invalid_slot-&gt;arch;
}

static void kvm_create_memslot(struct kvm *kvm,
			       struct kvm_memory_slot *new)
{
	/* Add the new memslot to the inactive set and activate. */
<blue>	kvm_replace_memslot(kvm, NULL, new);</blue>
<blue>	kvm_activate_memslot(kvm, NULL, new);</blue>
}

static void kvm_delete_memslot(struct kvm *kvm,
			       struct kvm_memory_slot *old,
			       struct kvm_memory_slot *invalid_slot)
{
	/*
	 * Remove the old memslot (in the inactive memslots) by passing NULL as
	 * the &quot;new&quot; slot, and for the invalid version in the active slots.
	 */
<yellow>	kvm_replace_memslot(kvm, old, NULL);</yellow>
	kvm_activate_memslot(kvm, invalid_slot, NULL);
}

static void kvm_move_memslot(struct kvm *kvm,
			     struct kvm_memory_slot *old,
			     struct kvm_memory_slot *new,
			     struct kvm_memory_slot *invalid_slot)
{
	/*
	 * Replace the old memslot in the inactive slots, and then swap slots
	 * and replace the current INVALID with the new as well.
	 */
<yellow>	kvm_replace_memslot(kvm, old, new);</yellow>
	kvm_activate_memslot(kvm, invalid_slot, new);
}

static void kvm_update_flags_memslot(struct kvm *kvm,
				     struct kvm_memory_slot *old,
				     struct kvm_memory_slot *new)
{
	/*
	 * Similar to the MOVE case, but the slot doesn&#x27;t need to be zapped as
	 * an intermediate step. Instead, the old memslot is simply replaced
	 * with a new, updated copy in both memslot sets.
	 */
<yellow>	kvm_replace_memslot(kvm, old, new);</yellow>
	kvm_activate_memslot(kvm, old, new);
}

static int kvm_set_memslot(struct kvm *kvm,
			   struct kvm_memory_slot *old,
			   struct kvm_memory_slot *new,
			   enum kvm_mr_change change)
{
	struct kvm_memory_slot *invalid_slot;
	int r;

	/*
	 * Released in kvm_swap_active_memslots.
	 *
	 * Must be held from before the current memslots are copied until
	 * after the new memslots are installed with rcu_assign_pointer,
	 * then released before the synchronize srcu in kvm_swap_active_memslots.
	 *
	 * When modifying memslots outside of the slots_lock, must be held
	 * before reading the pointer to the current memslots until after all
	 * changes to those memslots are complete.
	 *
	 * These rules ensure that installing new memslots does not lose
	 * changes made to the previous memslots.
	 */
<blue>	mutex_lock(&kvm->slots_arch_lock);</blue>

	/*
	 * Invalidate the old slot if it&#x27;s being deleted or moved.  This is
	 * done prior to actually deleting/moving the memslot to allow vCPUs to
	 * continue running by ensuring there are no mappings or shadow pages
	 * for the memslot when it is deleted/moved.  Without pre-invalidation
	 * (and without a lock), a window would exist between effecting the
	 * delete/move and committing the changes in arch code where KVM or a
	 * guest could access a non-existent memslot.
	 *
	 * Modifications are done on a temporary, unreachable slot.  The old
	 * slot needs to be preserved in case a later step fails and the
	 * invalidation needs to be reverted.
	 */
	if (change == KVM_MR_DELETE || change == KVM_MR_MOVE) {
<yellow>		invalid_slot = kzalloc(sizeof(*invalid_slot), GFP_KERNEL_ACCOUNT);</yellow>
		if (!invalid_slot) {
<yellow>			mutex_unlock(&kvm->slots_arch_lock);</yellow>
			return -ENOMEM;
		}
<yellow>		kvm_invalidate_memslot(kvm, old, invalid_slot);</yellow>
	}

<blue>	r = kvm_prepare_memory_region(kvm, old, new, change);</blue>
	if (r) {
		/*
		 * For DELETE/MOVE, revert the above INVALID change.  No
		 * modifications required since the original slot was preserved
		 * in the inactive slots.  Changing the active memslots also
		 * release slots_arch_lock.
		 */
<yellow>		if (change == KVM_MR_DELETE || change == KVM_MR_MOVE) {</yellow>
<yellow>			kvm_activate_memslot(kvm, invalid_slot, old);</yellow>
			kfree(invalid_slot);
		} else {
<yellow>			mutex_unlock(&kvm->slots_arch_lock);</yellow>
		}
		return r;
	}

	/*
	 * For DELETE and MOVE, the working slot is now active as the INVALID
	 * version of the old slot.  MOVE is particularly special as it reuses
	 * the old slot and returns a copy of the old slot (in working_slot).
	 * For CREATE, there is no old slot.  For DELETE and FLAGS_ONLY, the
	 * old slot is detached but otherwise preserved.
	 */
<blue>	if (change == KVM_MR_CREATE)</blue>
<blue>		kvm_create_memslot(kvm, new);</blue>
	else if (change == KVM_MR_DELETE)
<yellow>		kvm_delete_memslot(kvm, old, invalid_slot);</yellow>
<yellow>	else if (change == KVM_MR_MOVE)</yellow>
<yellow>		kvm_move_memslot(kvm, old, new, invalid_slot);</yellow>
	else if (change == KVM_MR_FLAGS_ONLY)
<yellow>		kvm_update_flags_memslot(kvm, old, new);</yellow>
	else
		BUG();

	/* Free the temporary INVALID slot used for DELETE and MOVE. */
	if (change == KVM_MR_DELETE || change == KVM_MR_MOVE)
<yellow>		kfree(invalid_slot);</yellow>

	/*
	 * No need to refresh new-&gt;arch, changes after dropping slots_arch_lock
	 * will directly hit the final, active memslot.  Architectures are
	 * responsible for knowing that new-&gt;arch may be stale.
	 */
<yellow>	kvm_commit_memory_region(kvm, old, new, change);</yellow>

	return 0;
<blue>}</blue>

static bool kvm_check_memslot_overlap(struct kvm_memslots *slots, int id,
				      gfn_t start, gfn_t end)
{
	struct kvm_memslot_iter iter;

<blue>	kvm_for_each_memslot_in_gfn_range(&iter, slots, start, end) {</blue>
<yellow>		if (iter.slot->id != id)</yellow>
			return true;
	}

	return false;
}

/*
 * Allocate some memory and give it an address in the guest physical address
 * space.
 *
 * Discontiguous memory is allowed, mostly for framebuffers.
 *
 * Must be called holding kvm-&gt;slots_lock for write.
 */
int __kvm_set_memory_region(struct kvm *kvm,
			    const struct kvm_userspace_memory_region *mem)
{
	struct kvm_memory_slot *old, *new;
	struct kvm_memslots *slots;
	enum kvm_mr_change change;
	unsigned long npages;
	gfn_t base_gfn;
	int as_id, id;
	int r;

<blue>	r = check_memory_region_flags(mem);</blue>
	if (r)
		return r;

<blue>	as_id = mem->slot >> 16;</blue>
	id = (u16)mem-&gt;slot;

	/* General sanity checks */
	if ((mem-&gt;memory_size &amp; (PAGE_SIZE - 1)) ||
	    (mem-&gt;memory_size != (unsigned long)mem-&gt;memory_size))
		return -EINVAL;
<blue>	if (mem->guest_phys_addr & (PAGE_SIZE - 1))</blue>
		return -EINVAL;
	/* We can read the guest memory with __xxx_user() later on. */
<blue>	if ((mem->userspace_addr & (PAGE_SIZE - 1)) ||</blue>
	    (mem-&gt;userspace_addr != untagged_addr(mem-&gt;userspace_addr)) ||
<blue>	     !access_ok((void __user *)(unsigned long)mem->userspace_addr,</blue>
			mem-&gt;memory_size))
		return -EINVAL;
<blue>	if (as_id >= KVM_ADDRESS_SPACE_NUM || id >= KVM_MEM_SLOTS_NUM)</blue>
		return -EINVAL;
<blue>	if (mem->guest_phys_addr + mem->memory_size < mem->guest_phys_addr)</blue>
		return -EINVAL;
<blue>	if ((mem->memory_size >> PAGE_SHIFT) > KVM_MEM_MAX_NR_PAGES)</blue>
		return -EINVAL;

<blue>	slots = __kvm_memslots(kvm, as_id);</blue>

	/*
	 * Note, the old memslot (and the pointer itself!) may be invalidated
	 * and/or destroyed by kvm_set_memslot().
	 */
<yellow>	old = id_to_memslot(slots, id);</yellow>

<blue>	if (!mem->memory_size) {</blue>
<yellow>		if (!old || !old->npages)</yellow>
			return -EINVAL;

<yellow>		if (WARN_ON_ONCE(kvm->nr_memslot_pages < old->npages))</yellow>
			return -EIO;

<yellow>		return kvm_set_memslot(kvm, old, NULL, KVM_MR_DELETE);</yellow>
	}

<blue>	base_gfn = (mem->guest_phys_addr >> PAGE_SHIFT);</blue>
	npages = (mem-&gt;memory_size &gt;&gt; PAGE_SHIFT);

<yellow>	if (!old || !old->npages) {</yellow>
		change = KVM_MR_CREATE;

		/*
		 * To simplify KVM internals, the total number of pages across
		 * all memslots must fit in an unsigned long.
		 */
<blue>		if ((kvm->nr_memslot_pages + npages) < kvm->nr_memslot_pages)</blue>
			return -EINVAL;
	} else { /* Modify an existing slot. */
<yellow>		if ((mem->userspace_addr != old->userspace_addr) ||</yellow>
		    (npages != old-&gt;npages) ||
<yellow>		    ((mem->flags ^ old->flags) & KVM_MEM_READONLY))</yellow>
			return -EINVAL;

<yellow>		if (base_gfn != old->base_gfn)</yellow>
			change = KVM_MR_MOVE;
<yellow>		else if (mem->flags != old->flags)</yellow>
			change = KVM_MR_FLAGS_ONLY;
		else /* Nothing to change. */
			return 0;
	}

	if ((change == KVM_MR_CREATE || change == KVM_MR_MOVE) &amp;&amp;
<blue>	    kvm_check_memslot_overlap(slots, id, base_gfn, base_gfn + npages))</blue>
<yellow>		return -EEXIST;</yellow>

	/* Allocate a slot that will persist in the memslot. */
<blue>	new = kzalloc(sizeof(*new), GFP_KERNEL_ACCOUNT);</blue>
	if (!new)
		return -ENOMEM;

<blue>	new->as_id = as_id;</blue>
	new-&gt;id = id;
	new-&gt;base_gfn = base_gfn;
	new-&gt;npages = npages;
	new-&gt;flags = mem-&gt;flags;
	new-&gt;userspace_addr = mem-&gt;userspace_addr;

	r = kvm_set_memslot(kvm, old, new, change);
	if (r)
<yellow>		kfree(new);</yellow>
	return r;
<blue>}</blue>
EXPORT_SYMBOL_GPL(__kvm_set_memory_region);

int kvm_set_memory_region(struct kvm *kvm,
			  const struct kvm_userspace_memory_region *mem)
{
	int r;

<yellow>	mutex_lock(&kvm->slots_lock);</yellow>
	r = __kvm_set_memory_region(kvm, mem);
	mutex_unlock(&amp;kvm-&gt;slots_lock);
	return r;
}
EXPORT_SYMBOL_GPL(kvm_set_memory_region);

static int kvm_vm_ioctl_set_memory_region(struct kvm *kvm,
					  struct kvm_userspace_memory_region *mem)
{
<yellow>	if ((u16)mem->slot >= KVM_USER_MEM_SLOTS)</yellow>
		return -EINVAL;

<yellow>	return kvm_set_memory_region(kvm, mem);</yellow>
}

#ifndef CONFIG_KVM_GENERIC_DIRTYLOG_READ_PROTECT
/**
 * kvm_get_dirty_log - get a snapshot of dirty pages
 * @kvm:	pointer to kvm instance
 * @log:	slot id and address to which we copy the log
 * @is_dirty:	set to &#x27;1&#x27; if any dirty pages were found
 * @memslot:	set to the associated memslot, always valid on success
 */
int kvm_get_dirty_log(struct kvm *kvm, struct kvm_dirty_log *log,
		      int *is_dirty, struct kvm_memory_slot **memslot)
{
	struct kvm_memslots *slots;
	int i, as_id, id;
	unsigned long n;
	unsigned long any = 0;

	/* Dirty ring tracking is exclusive to dirty log tracking */
	if (kvm-&gt;dirty_ring_size)
		return -ENXIO;

	*memslot = NULL;
	*is_dirty = 0;

	as_id = log-&gt;slot &gt;&gt; 16;
	id = (u16)log-&gt;slot;
	if (as_id &gt;= KVM_ADDRESS_SPACE_NUM || id &gt;= KVM_USER_MEM_SLOTS)
		return -EINVAL;

	slots = __kvm_memslots(kvm, as_id);
	*memslot = id_to_memslot(slots, id);
	if (!(*memslot) || !(*memslot)-&gt;dirty_bitmap)
		return -ENOENT;

	kvm_arch_sync_dirty_log(kvm, *memslot);

	n = kvm_dirty_bitmap_bytes(*memslot);

	for (i = 0; !any &amp;&amp; i &lt; n/sizeof(long); ++i)
		any = (*memslot)-&gt;dirty_bitmap[i];

	if (copy_to_user(log-&gt;dirty_bitmap, (*memslot)-&gt;dirty_bitmap, n))
		return -EFAULT;

	if (any)
		*is_dirty = 1;
	return 0;
}
EXPORT_SYMBOL_GPL(kvm_get_dirty_log);

#else /* CONFIG_KVM_GENERIC_DIRTYLOG_READ_PROTECT */
/**
 * kvm_get_dirty_log_protect - get a snapshot of dirty pages
 *	and reenable dirty page tracking for the corresponding pages.
 * @kvm:	pointer to kvm instance
 * @log:	slot id and address to which we copy the log
 *
 * We need to keep it in mind that VCPU threads can write to the bitmap
 * concurrently. So, to avoid losing track of dirty pages we keep the
 * following order:
 *
 *    1. Take a snapshot of the bit and clear it if needed.
 *    2. Write protect the corresponding page.
 *    3. Copy the snapshot to the userspace.
 *    4. Upon return caller flushes TLB&#x27;s if needed.
 *
 * Between 2 and 4, the guest may write to the page using the remaining TLB
 * entry.  This is not a problem because the page is reported dirty using
 * the snapshot taken before and step 4 ensures that writes done after
 * exiting to userspace will be logged for the next call.
 *
 */
static int kvm_get_dirty_log_protect(struct kvm *kvm, struct kvm_dirty_log *log)
{
	struct kvm_memslots *slots;
	struct kvm_memory_slot *memslot;
	int i, as_id, id;
	unsigned long n;
	unsigned long *dirty_bitmap;
	unsigned long *dirty_bitmap_buffer;
	bool flush;

	/* Dirty ring tracking is exclusive to dirty log tracking */
<yellow>	if (kvm->dirty_ring_size)</yellow>
		return -ENXIO;

<yellow>	as_id = log->slot >> 16;</yellow>
	id = (u16)log-&gt;slot;
<yellow>	if (as_id >= KVM_ADDRESS_SPACE_NUM || id >= KVM_USER_MEM_SLOTS)</yellow>
		return -EINVAL;

<yellow>	slots = __kvm_memslots(kvm, as_id);</yellow>
<yellow>	memslot = id_to_memslot(slots, id);</yellow>
<yellow>	if (!memslot || !memslot->dirty_bitmap)</yellow>
		return -ENOENT;

	dirty_bitmap = memslot-&gt;dirty_bitmap;

<yellow>	kvm_arch_sync_dirty_log(kvm, memslot);</yellow>

	n = kvm_dirty_bitmap_bytes(memslot);
	flush = false;
	if (kvm-&gt;manual_dirty_log_protect) {
		/*
		 * Unlike kvm_get_dirty_log, we always return false in *flush,
		 * because no flush is needed until KVM_CLEAR_DIRTY_LOG.  There
		 * is some code duplication between this function and
		 * kvm_get_dirty_log, but hopefully all architecture
		 * transition to kvm_get_dirty_log_protect and kvm_get_dirty_log
		 * can be eliminated.
		 */
		dirty_bitmap_buffer = dirty_bitmap;
	} else {
<yellow>		dirty_bitmap_buffer = kvm_second_dirty_bitmap(memslot);</yellow>
		memset(dirty_bitmap_buffer, 0, n);

		KVM_MMU_LOCK(kvm);
<yellow>		for (i = 0; i < n / sizeof(long); i++) {</yellow>
			unsigned long mask;
			gfn_t offset;

<yellow>			if (!dirty_bitmap[i])</yellow>
				continue;

			flush = true;
<yellow>			mask = xchg(&dirty_bitmap[i], 0);</yellow>
			dirty_bitmap_buffer[i] = mask;

			offset = i * BITS_PER_LONG;
			kvm_arch_mmu_enable_log_dirty_pt_masked(kvm, memslot,
								offset, mask);
		}
<yellow>		KVM_MMU_UNLOCK(kvm);</yellow>
	}

	if (flush)
<yellow>		kvm_arch_flush_remote_tlbs_memslot(kvm, memslot);</yellow>

<yellow>	if (copy_to_user(log->dirty_bitmap, dirty_bitmap_buffer, n))</yellow>
		return -EFAULT;
	return 0;
<yellow>}</yellow>


/**
 * kvm_vm_ioctl_get_dirty_log - get and clear the log of dirty pages in a slot
 * @kvm: kvm instance
 * @log: slot id and address to which we copy the log
 *
 * Steps 1-4 below provide general overview of dirty page logging. See
 * kvm_get_dirty_log_protect() function description for additional details.
 *
 * We call kvm_get_dirty_log_protect() to handle steps 1-3, upon return we
 * always flush the TLB (step 4) even if previous step failed  and the dirty
 * bitmap may be corrupt. Regardless of previous outcome the KVM logging API
 * does not preclude user space subsequent dirty log read. Flushing TLB ensures
 * writes will be marked dirty for next log read.
 *
 *   1. Take a snapshot of the bit and clear it if needed.
 *   2. Write protect the corresponding page.
 *   3. Copy the snapshot to the userspace.
 *   4. Flush TLB&#x27;s if needed.
 */
static int kvm_vm_ioctl_get_dirty_log(struct kvm *kvm,
				      struct kvm_dirty_log *log)
{
	int r;

<yellow>	mutex_lock(&kvm->slots_lock);</yellow>

	r = kvm_get_dirty_log_protect(kvm, log);

	mutex_unlock(&amp;kvm-&gt;slots_lock);
	return r;
}

/**
 * kvm_clear_dirty_log_protect - clear dirty bits in the bitmap
 *	and reenable dirty page tracking for the corresponding pages.
 * @kvm:	pointer to kvm instance
 * @log:	slot id and address from which to fetch the bitmap of dirty pages
 */
static int kvm_clear_dirty_log_protect(struct kvm *kvm,
				       struct kvm_clear_dirty_log *log)
{
	struct kvm_memslots *slots;
	struct kvm_memory_slot *memslot;
	int as_id, id;
	gfn_t offset;
	unsigned long i, n;
	unsigned long *dirty_bitmap;
	unsigned long *dirty_bitmap_buffer;
	bool flush;

	/* Dirty ring tracking is exclusive to dirty log tracking */
<yellow>	if (kvm->dirty_ring_size)</yellow>
		return -ENXIO;

<yellow>	as_id = log->slot >> 16;</yellow>
	id = (u16)log-&gt;slot;
<yellow>	if (as_id >= KVM_ADDRESS_SPACE_NUM || id >= KVM_USER_MEM_SLOTS)</yellow>
		return -EINVAL;

<yellow>	if (log->first_page & 63)</yellow>
		return -EINVAL;

<yellow>	slots = __kvm_memslots(kvm, as_id);</yellow>
<yellow>	memslot = id_to_memslot(slots, id);</yellow>
<yellow>	if (!memslot || !memslot->dirty_bitmap)</yellow>
		return -ENOENT;

	dirty_bitmap = memslot-&gt;dirty_bitmap;

<yellow>	n = ALIGN(log->num_pages, BITS_PER_LONG) / 8;</yellow>

	if (log-&gt;first_page &gt; memslot-&gt;npages ||
<yellow>	    log->num_pages > memslot->npages - log->first_page ||</yellow>
<yellow>	    (log->num_pages < memslot->npages - log->first_page && (log->num_pages & 63)))</yellow>
	    return -EINVAL;

<yellow>	kvm_arch_sync_dirty_log(kvm, memslot);</yellow>

	flush = false;
	dirty_bitmap_buffer = kvm_second_dirty_bitmap(memslot);
	if (copy_from_user(dirty_bitmap_buffer, log-&gt;dirty_bitmap, n))
		return -EFAULT;

<yellow>	KVM_MMU_LOCK(kvm);</yellow>
	for (offset = log-&gt;first_page, i = offset / BITS_PER_LONG,
<yellow>		 n = DIV_ROUND_UP(log->num_pages, BITS_PER_LONG); n--;</yellow>
	     i++, offset += BITS_PER_LONG) {
<yellow>		unsigned long mask = *dirty_bitmap_buffer++;</yellow>
		atomic_long_t *p = (atomic_long_t *) &amp;dirty_bitmap[i];
		if (!mask)
			continue;

<yellow>		mask &= atomic_long_fetch_andnot(mask, p);</yellow>

		/*
		 * mask contains the bits that really have been cleared.  This
		 * never includes any bits beyond the length of the memslot (if
		 * the length is not aligned to 64 pages), therefore it is not
		 * a problem if userspace sets them in log-&gt;dirty_bitmap.
		*/
		if (mask) {
			flush = true;
<yellow>			kvm_arch_mmu_enable_log_dirty_pt_masked(kvm, memslot,</yellow>
								offset, mask);
		}
	}
<yellow>	KVM_MMU_UNLOCK(kvm);</yellow>

	if (flush)
<yellow>		kvm_arch_flush_remote_tlbs_memslot(kvm, memslot);</yellow>

	return 0;
<yellow>}</yellow>

static int kvm_vm_ioctl_clear_dirty_log(struct kvm *kvm,
					struct kvm_clear_dirty_log *log)
{
	int r;

<yellow>	mutex_lock(&kvm->slots_lock);</yellow>

	r = kvm_clear_dirty_log_protect(kvm, log);

	mutex_unlock(&amp;kvm-&gt;slots_lock);
	return r;
}
#endif /* CONFIG_KVM_GENERIC_DIRTYLOG_READ_PROTECT */

struct kvm_memory_slot *gfn_to_memslot(struct kvm *kvm, gfn_t gfn)
{
<blue>	return __gfn_to_memslot(kvm_memslots(kvm), gfn);</blue>
<blue>}</blue>
EXPORT_SYMBOL_GPL(gfn_to_memslot);

struct kvm_memory_slot *kvm_vcpu_gfn_to_memslot(struct kvm_vcpu *vcpu, gfn_t gfn)
{
<blue>	struct kvm_memslots *slots = kvm_vcpu_memslots(vcpu);</blue>
	u64 gen = slots-&gt;generation;
	struct kvm_memory_slot *slot;

	/*
	 * This also protects against using a memslot from a different address space,
	 * since different address spaces have different generation numbers.
	 */
	if (unlikely(gen != vcpu-&gt;last_used_slot_gen)) {
<blue>		vcpu->last_used_slot = NULL;</blue>
		vcpu-&gt;last_used_slot_gen = gen;
	}

<blue>	slot = try_get_memslot(vcpu->last_used_slot, gfn);</blue>
	if (slot)
		return slot;

	/*
	 * Fall back to searching all memslots. We purposely use
	 * search_memslots() instead of __gfn_to_memslot() to avoid
	 * thrashing the VM-wide last_used_slot in kvm_memslots.
	 */
<blue>	slot = search_memslots(slots, gfn, false);</blue>
<blue>	if (slot) {</blue>
<blue>		vcpu->last_used_slot = slot;</blue>
		return slot;
	}

	return NULL;
<blue>}</blue>

bool kvm_is_visible_gfn(struct kvm *kvm, gfn_t gfn)
{
<yellow>	struct kvm_memory_slot *memslot = gfn_to_memslot(kvm, gfn);</yellow>

<yellow>	return kvm_is_visible_memslot(memslot);</yellow>
<yellow>}</yellow>
EXPORT_SYMBOL_GPL(kvm_is_visible_gfn);

bool kvm_vcpu_is_visible_gfn(struct kvm_vcpu *vcpu, gfn_t gfn)
{
<yellow>	struct kvm_memory_slot *memslot = kvm_vcpu_gfn_to_memslot(vcpu, gfn);</yellow>

<yellow>	return kvm_is_visible_memslot(memslot);</yellow>
<yellow>}</yellow>
EXPORT_SYMBOL_GPL(kvm_vcpu_is_visible_gfn);

unsigned long kvm_host_page_size(struct kvm_vcpu *vcpu, gfn_t gfn)
{
	struct vm_area_struct *vma;
	unsigned long addr, size;

	size = PAGE_SIZE;

<yellow>	addr = kvm_vcpu_gfn_to_hva_prot(vcpu, gfn, NULL);</yellow>
	if (kvm_is_error_hva(addr))
<yellow>		return PAGE_SIZE;</yellow>

<yellow>	mmap_read_lock(current->mm);</yellow>
<yellow>	vma = find_vma(current->mm, addr);</yellow>
	if (!vma)
		goto out;

<yellow>	size = vma_kernel_pagesize(vma);</yellow>

out:
<yellow>	mmap_read_unlock(current->mm);</yellow>

	return size;
<yellow>}</yellow>

static bool memslot_is_readonly(const struct kvm_memory_slot *slot)
{
<blue>	return slot->flags & KVM_MEM_READONLY;</blue>
}

<blue>static unsigned long __gfn_to_hva_many(const struct kvm_memory_slot *slot, gfn_t gfn,</blue>
				       gfn_t *nr_pages, bool write)
{
<blue>	if (!slot || slot->flags & KVM_MEMSLOT_INVALID)</blue>
<blue>		return KVM_HVA_ERR_BAD;</blue>

<blue>	if (memslot_is_readonly(slot) && write)</blue>
<blue>		return KVM_HVA_ERR_RO_BAD;</blue>

<blue>	if (nr_pages)</blue>
<blue>		*nr_pages = slot->npages - (gfn - slot->base_gfn);</blue>

<blue>	return __gfn_to_hva_memslot(slot, gfn);</blue>
<blue>}</blue>

static unsigned long gfn_to_hva_many(struct kvm_memory_slot *slot, gfn_t gfn,
				     gfn_t *nr_pages)
{
<blue>	return __gfn_to_hva_many(slot, gfn, nr_pages, true);</blue>
}

unsigned long gfn_to_hva_memslot(struct kvm_memory_slot *slot,
					gfn_t gfn)
{
<blue>	return gfn_to_hva_many(slot, gfn, NULL);</blue>
<yellow>}</yellow>
EXPORT_SYMBOL_GPL(gfn_to_hva_memslot);

unsigned long gfn_to_hva(struct kvm *kvm, gfn_t gfn)
{
<blue>	return gfn_to_hva_many(gfn_to_memslot(kvm, gfn), gfn, NULL);</blue>
<blue>}</blue>
EXPORT_SYMBOL_GPL(gfn_to_hva);

unsigned long kvm_vcpu_gfn_to_hva(struct kvm_vcpu *vcpu, gfn_t gfn)
{
<yellow>	return gfn_to_hva_many(kvm_vcpu_gfn_to_memslot(vcpu, gfn), gfn, NULL);</yellow>
<yellow>}</yellow>
EXPORT_SYMBOL_GPL(kvm_vcpu_gfn_to_hva);

/*
 * Return the hva of a @gfn and the R/W attribute if possible.
 *
 * @slot: the kvm_memory_slot which contains @gfn
 * @gfn: the gfn to be translated
 * @writable: used to return the read/write attribute of the @slot if the hva
 * is valid and @writable is not NULL
 */
<blue>unsigned long gfn_to_hva_memslot_prot(struct kvm_memory_slot *slot,</blue>
				      gfn_t gfn, bool *writable)
{
<blue>	unsigned long hva = __gfn_to_hva_many(slot, gfn, NULL, false);</blue>

<blue>	if (!kvm_is_error_hva(hva) && writable)</blue>
<blue>		*writable = !memslot_is_readonly(slot);</blue>

	return hva;
<yellow>}</yellow>

unsigned long gfn_to_hva_prot(struct kvm *kvm, gfn_t gfn, bool *writable)
{
<yellow>	struct kvm_memory_slot *slot = gfn_to_memslot(kvm, gfn);</yellow>

<yellow>	return gfn_to_hva_memslot_prot(slot, gfn, writable);</yellow>
<yellow>}</yellow>

unsigned long kvm_vcpu_gfn_to_hva_prot(struct kvm_vcpu *vcpu, gfn_t gfn, bool *writable)
{
<blue>	struct kvm_memory_slot *slot = kvm_vcpu_gfn_to_memslot(vcpu, gfn);</blue>

<blue>	return gfn_to_hva_memslot_prot(slot, gfn, writable);</blue>
<blue>}</blue>

static inline int check_user_page_hwpoison(unsigned long addr)
{
	int rc, flags = FOLL_HWPOISON | FOLL_WRITE;

<yellow>	rc = get_user_pages(addr, 1, flags, NULL, NULL);</yellow>
	return rc == -EHWPOISON;
}

/*
 * The fast path to get the writable pfn which will be stored in @pfn,
 * true indicates success, otherwise false is returned.  It&#x27;s also the
 * only part that runs if we can in atomic context.
 */
static bool hva_to_pfn_fast(unsigned long addr, bool write_fault,
			    bool *writable, kvm_pfn_t *pfn)
{
	struct page *page[1];

	/*
	 * Fast pin a writable pfn only if it is a write fault request
	 * or the caller allows to map a writable pfn for a read fault
	 * request.
	 */
<blue>	if (!(write_fault || writable))</blue>
		return false;

<blue>	if (get_user_page_fast_only(addr, FOLL_WRITE, page)) {</blue>
<blue>		*pfn = page_to_pfn(page[0]);</blue>

<blue>		if (writable)</blue>
<blue>			*writable = true;</blue>
		return true;
	}

	return false;
}

/*
 * The slow path to get the pfn of the specified host virtual address,
 * 1 indicates success, -errno is returned if error is detected.
 */
static int hva_to_pfn_slow(unsigned long addr, bool *async, bool write_fault,
			   bool *writable, kvm_pfn_t *pfn)
{
	unsigned int flags = FOLL_HWPOISON;
	struct page *page;
	int npages;

<blue>	might_sleep();</blue>

	if (writable)
<blue>		*writable = write_fault;</blue>

<blue>	if (write_fault)</blue>
		flags |= FOLL_WRITE;
	if (async)
<blue>		flags |= FOLL_NOWAIT;</blue>

<blue>	npages = get_user_pages_unlocked(addr, 1, &page, flags);</blue>
	if (npages != 1)
		return npages;

	/* map read fault as writable if possible */
<blue>	if (unlikely(!write_fault) && writable) {</blue>
		struct page *wpage;

<blue>		if (get_user_page_fast_only(addr, FOLL_WRITE, &wpage)) {</blue>
<blue>			*writable = true;</blue>
<blue>			put_page(page);</blue>
<blue>			page = wpage;</blue>
		}
	}
<blue>	*pfn = page_to_pfn(page);</blue>
	return npages;
}

static bool vma_is_valid(struct vm_area_struct *vma, bool write_fault)
{
<yellow>	if (unlikely(!(vma->vm_flags & VM_READ)))</yellow>
		return false;

<yellow>	if (write_fault && (unlikely(!(vma->vm_flags & VM_WRITE))))</yellow>
		return false;

	return true;
}

static int kvm_try_get_pfn(kvm_pfn_t pfn)
{
<yellow>	struct page *page = kvm_pfn_to_refcounted_page(pfn);</yellow>

	if (!page)
		return 1;

<yellow>	return get_page_unless_zero(page);</yellow>
}

static int hva_to_pfn_remapped(struct vm_area_struct *vma,
			       unsigned long addr, bool write_fault,
			       bool *writable, kvm_pfn_t *p_pfn)
{
	kvm_pfn_t pfn;
	pte_t *ptep;
	spinlock_t *ptl;
	int r;

<yellow>	r = follow_pte(vma->vm_mm, addr, &ptep, &ptl);</yellow>
	if (r) {
		/*
		 * get_user_pages fails for VM_IO and VM_PFNMAP vmas and does
		 * not call the fault handler, so do it here.
		 */
		bool unlocked = false;
<yellow>		r = fixup_user_fault(current->mm, addr,</yellow>
				     (write_fault ? FAULT_FLAG_WRITE : 0),
				     &amp;unlocked);
<yellow>		if (unlocked)</yellow>
			return -EAGAIN;
<yellow>		if (r)</yellow>
			return r;

<yellow>		r = follow_pte(vma->vm_mm, addr, &ptep, &ptl);</yellow>
<yellow>		if (r)</yellow>
			return r;
	}

<yellow>	if (write_fault && !pte_write(*ptep)) {</yellow>
		pfn = KVM_PFN_ERR_RO_FAULT;
		goto out;
	}

<yellow>	if (writable)</yellow>
<yellow>		*writable = pte_write(*ptep);</yellow>
<yellow>	pfn = pte_pfn(*ptep);</yellow>

	/*
	 * Get a reference here because callers of *hva_to_pfn* and
	 * *gfn_to_pfn* ultimately call kvm_release_pfn_clean on the
	 * returned pfn.  This is only needed if the VMA has VM_MIXEDMAP
	 * set, but the kvm_try_get_pfn/kvm_release_pfn_clean pair will
	 * simply do nothing for reserved pfns.
	 *
	 * Whoever called remap_pfn_range is also going to call e.g.
	 * unmap_mapping_range before the underlying pages are freed,
	 * causing a call to our MMU notifier.
	 *
	 * Certain IO or PFNMAP mappings can be backed with valid
	 * struct pages, but be allocated without refcounting e.g.,
	 * tail pages of non-compound higher order allocations, which
	 * would then underflow the refcount when the caller does the
	 * required put_page. Don&#x27;t allow those pages here.
	 */ 
<yellow>	if (!kvm_try_get_pfn(pfn))</yellow>
		r = -EFAULT;

out:
<yellow>	pte_unmap_unlock(ptep, ptl);</yellow>
	*p_pfn = pfn;

	return r;
}

/*
 * Pin guest page in memory and return its pfn.
 * @addr: host virtual address which maps memory to the guest
 * @atomic: whether this function can sleep
 * @async: whether this function need to wait IO complete if the
 *         host page is not in the memory
 * @write_fault: whether we should get a writable host page
 * @writable: whether it allows to map a writable host page for !@write_fault
 *
 * The function will map a writable host page for these two cases:
 * 1): @write_fault = true
 * 2): @write_fault = false &amp;&amp; @writable, @writable will tell the caller
 *     whether the mapping is writable.
 */
kvm_pfn_t hva_to_pfn(unsigned long addr, bool atomic, bool *async,
		     bool write_fault, bool *writable)
<blue>{</blue>
	struct vm_area_struct *vma;
	kvm_pfn_t pfn;
	int npages, r;

	/* we can do it either atomically or asynchronously, not both */
<blue>	BUG_ON(atomic && async);</blue>

<blue>	if (hva_to_pfn_fast(addr, write_fault, writable, &pfn))</blue>
		return pfn;

<blue>	if (atomic)</blue>
		return KVM_PFN_ERR_FAULT;

<blue>	npages = hva_to_pfn_slow(addr, async, write_fault, writable, &pfn);</blue>
	if (npages == 1)
		return pfn;

<yellow>	mmap_read_lock(current->mm);</yellow>
<yellow>	if (npages == -EHWPOISON ||</yellow>
<yellow>	      (!async && check_user_page_hwpoison(addr))) {</yellow>
		pfn = KVM_PFN_ERR_HWPOISON;
		goto exit;
	}

retry:
<yellow>	vma = vma_lookup(current->mm, addr);</yellow>

	if (vma == NULL)
		pfn = KVM_PFN_ERR_FAULT;
<yellow>	else if (vma->vm_flags & (VM_IO | VM_PFNMAP)) {</yellow>
<yellow>		r = hva_to_pfn_remapped(vma, addr, write_fault, writable, &pfn);</yellow>
<yellow>		if (r == -EAGAIN)</yellow>
			goto retry;
<yellow>		if (r < 0)</yellow>
			pfn = KVM_PFN_ERR_FAULT;
	} else {
<yellow>		if (async && vma_is_valid(vma, write_fault))</yellow>
<yellow>			*async = true;</yellow>
		pfn = KVM_PFN_ERR_FAULT;
	}
exit:
<yellow>	mmap_read_unlock(current->mm);</yellow>
	return pfn;
}

kvm_pfn_t __gfn_to_pfn_memslot(const struct kvm_memory_slot *slot, gfn_t gfn,
			       bool atomic, bool *async, bool write_fault,
			       bool *writable, hva_t *hva)
{
<blue>	unsigned long addr = __gfn_to_hva_many(slot, gfn, NULL, write_fault);</blue>

<blue>	if (hva)</blue>
<blue>		*hva = addr;</blue>

<blue>	if (addr == KVM_HVA_ERR_RO_BAD) {</blue>
<blue>		if (writable)</blue>
<blue>			*writable = false;</blue>
<yellow>		return KVM_PFN_ERR_RO_FAULT;</yellow>
	}

<blue>	if (kvm_is_error_hva(addr)) {</blue>
		if (writable)
<blue>			*writable = false;</blue>
<blue>		return KVM_PFN_NOSLOT;</blue>
	}

	/* Do not map writable pfn in the readonly memslot. */
<blue>	if (writable && memslot_is_readonly(slot)) {</blue>
<blue>		*writable = false;</blue>
		writable = NULL;
	}

<blue>	return hva_to_pfn(addr, atomic, async, write_fault,</blue>
			  writable);
<blue>}</blue>
EXPORT_SYMBOL_GPL(__gfn_to_pfn_memslot);

kvm_pfn_t gfn_to_pfn_prot(struct kvm *kvm, gfn_t gfn, bool write_fault,
		      bool *writable)
{
<yellow>	return __gfn_to_pfn_memslot(gfn_to_memslot(kvm, gfn), gfn, false, NULL,</yellow>
				    write_fault, writable, NULL);
<yellow>}</yellow>
EXPORT_SYMBOL_GPL(gfn_to_pfn_prot);

kvm_pfn_t gfn_to_pfn_memslot(const struct kvm_memory_slot *slot, gfn_t gfn)
{
<blue>	return __gfn_to_pfn_memslot(slot, gfn, false, NULL, true, NULL, NULL);</blue>
<yellow>}</yellow>
EXPORT_SYMBOL_GPL(gfn_to_pfn_memslot);

kvm_pfn_t gfn_to_pfn_memslot_atomic(const struct kvm_memory_slot *slot, gfn_t gfn)
{
<yellow>	return __gfn_to_pfn_memslot(slot, gfn, true, NULL, true, NULL, NULL);</yellow>
<yellow>}</yellow>
EXPORT_SYMBOL_GPL(gfn_to_pfn_memslot_atomic);

kvm_pfn_t kvm_vcpu_gfn_to_pfn_atomic(struct kvm_vcpu *vcpu, gfn_t gfn)
{
<yellow>	return gfn_to_pfn_memslot_atomic(kvm_vcpu_gfn_to_memslot(vcpu, gfn), gfn);</yellow>
<yellow>}</yellow>
EXPORT_SYMBOL_GPL(kvm_vcpu_gfn_to_pfn_atomic);

kvm_pfn_t gfn_to_pfn(struct kvm *kvm, gfn_t gfn)
{
<blue>	return gfn_to_pfn_memslot(gfn_to_memslot(kvm, gfn), gfn);</blue>
<yellow>}</yellow>
EXPORT_SYMBOL_GPL(gfn_to_pfn);

kvm_pfn_t kvm_vcpu_gfn_to_pfn(struct kvm_vcpu *vcpu, gfn_t gfn)
{
<yellow>	return gfn_to_pfn_memslot(kvm_vcpu_gfn_to_memslot(vcpu, gfn), gfn);</yellow>
<yellow>}</yellow>
EXPORT_SYMBOL_GPL(kvm_vcpu_gfn_to_pfn);

int gfn_to_page_many_atomic(struct kvm_memory_slot *slot, gfn_t gfn,
			    struct page **pages, int nr_pages)
{
	unsigned long addr;
	gfn_t entry = 0;

<yellow>	addr = gfn_to_hva_many(slot, gfn, &entry);</yellow>
<yellow>	if (kvm_is_error_hva(addr))</yellow>
		return -1;

<yellow>	if (entry < nr_pages)</yellow>
		return 0;

<yellow>	return get_user_pages_fast_only(addr, nr_pages, FOLL_WRITE, pages);</yellow>
<yellow>}</yellow>
EXPORT_SYMBOL_GPL(gfn_to_page_many_atomic);

/*
 * Do not use this helper unless you are absolutely certain the gfn _must_ be
 * backed by &#x27;struct page&#x27;.  A valid example is if the backing memslot is
 * controlled by KVM.  Note, if the returned page is valid, it&#x27;s refcount has
 * been elevated by gfn_to_pfn().
 */
struct page *gfn_to_page(struct kvm *kvm, gfn_t gfn)
{
	struct page *page;
	kvm_pfn_t pfn;

<blue>	pfn = gfn_to_pfn(kvm, gfn);</blue>

	if (is_error_noslot_pfn(pfn))
		return KVM_ERR_PTR_BAD_PAGE;

<blue>	page = kvm_pfn_to_refcounted_page(pfn);</blue>
	if (!page)
		return KVM_ERR_PTR_BAD_PAGE;

	return page;
<blue>}</blue>
EXPORT_SYMBOL_GPL(gfn_to_page);

<blue>void kvm_release_pfn(kvm_pfn_t pfn, bool dirty)</blue>
{
<blue>	if (dirty)</blue>
<blue>		kvm_release_pfn_dirty(pfn);</blue>
	else
<blue>		kvm_release_pfn_clean(pfn);</blue>
<blue>}</blue>

int kvm_vcpu_map(struct kvm_vcpu *vcpu, gfn_t gfn, struct kvm_host_map *map)
{
	kvm_pfn_t pfn;
	void *hva = NULL;
	struct page *page = KVM_UNMAPPED_PAGE;

<blue>	if (!map)</blue>
		return -EINVAL;

<blue>	pfn = gfn_to_pfn(vcpu->kvm, gfn);</blue>
	if (is_error_noslot_pfn(pfn))
		return -EINVAL;

<blue>	if (pfn_valid(pfn)) {</blue>
<blue>		page = pfn_to_page(pfn);</blue>
		hva = kmap(page);
#ifdef CONFIG_HAS_IOMEM
	} else {
<yellow>		hva = memremap(pfn_to_hpa(pfn), PAGE_SIZE, MEMREMAP_WB);</yellow>
#endif
	}

<blue>	if (!hva)</blue>
		return -EFAULT;

<blue>	map->page = page;</blue>
	map-&gt;hva = hva;
	map-&gt;pfn = pfn;
	map-&gt;gfn = gfn;

	return 0;
<blue>}</blue>
EXPORT_SYMBOL_GPL(kvm_vcpu_map);

<blue>void kvm_vcpu_unmap(struct kvm_vcpu *vcpu, struct kvm_host_map *map, bool dirty)</blue>
{
<blue>	if (!map)</blue>
		return;

<blue>	if (!map->hva)</blue>
		return;

<blue>	if (map->page != KVM_UNMAPPED_PAGE)</blue>
		kunmap(map-&gt;page);
#ifdef CONFIG_HAS_IOMEM
	else
<yellow>		memunmap(map->hva);</yellow>
#endif

<blue>	if (dirty)</blue>
<blue>		kvm_vcpu_mark_page_dirty(vcpu, map->gfn);</blue>

<blue>	kvm_release_pfn(map->pfn, dirty);</blue>

	map-&gt;hva = NULL;
	map-&gt;page = NULL;
<blue>}</blue>
EXPORT_SYMBOL_GPL(kvm_vcpu_unmap);

static bool kvm_is_ad_tracked_page(struct page *page)
{
	/*
	 * Per page-flags.h, pages tagged PG_reserved &quot;should in general not be
	 * touched (e.g. set dirty) except by its owner&quot;.
	 */
<blue>	return !PageReserved(page);</blue>
}

<blue>static void kvm_set_page_dirty(struct page *page)</blue>
{
<blue>	if (kvm_is_ad_tracked_page(page))</blue>
<blue>		SetPageDirty(page);</blue>
}

static void kvm_set_page_accessed(struct page *page)
{
<blue>	if (kvm_is_ad_tracked_page(page))</blue>
<blue>		mark_page_accessed(page);</blue>
}

void kvm_release_page_clean(struct page *page)
{
<blue>	WARN_ON(is_error_page(page));</blue>

<blue>	kvm_set_page_accessed(page);</blue>
<blue>	put_page(page);</blue>
<blue>}</blue>
EXPORT_SYMBOL_GPL(kvm_release_page_clean);

<blue>void kvm_release_pfn_clean(kvm_pfn_t pfn)</blue>
{
	struct page *page;

<blue>	if (is_error_noslot_pfn(pfn))</blue>
		return;

<blue>	page = kvm_pfn_to_refcounted_page(pfn);</blue>
	if (!page)
		return;

<blue>	kvm_release_page_clean(page);</blue>
<blue>}</blue>
EXPORT_SYMBOL_GPL(kvm_release_pfn_clean);

void kvm_release_page_dirty(struct page *page)
{
<blue>	WARN_ON(is_error_page(page));</blue>

<blue>	kvm_set_page_dirty(page);</blue>
<blue>	kvm_release_page_clean(page);</blue>
}
EXPORT_SYMBOL_GPL(kvm_release_page_dirty);

<blue>void kvm_release_pfn_dirty(kvm_pfn_t pfn)</blue>
{
	struct page *page;

<blue>	if (is_error_noslot_pfn(pfn))</blue>
		return;

<blue>	page = kvm_pfn_to_refcounted_page(pfn);</blue>
	if (!page)
		return;

<blue>	kvm_release_page_dirty(page);</blue>
<yellow>}</yellow>
EXPORT_SYMBOL_GPL(kvm_release_pfn_dirty);

/*
 * Note, checking for an error/noslot pfn is the caller&#x27;s responsibility when
 * directly marking a page dirty/accessed.  Unlike the &quot;release&quot; helpers, the
 * &quot;set&quot; helpers are not to be used when the pfn might point at garbage.
 */
<yellow>void kvm_set_pfn_dirty(kvm_pfn_t pfn)</yellow>
{
<yellow>	if (WARN_ON(is_error_noslot_pfn(pfn)))</yellow>
		return;

<yellow>	if (pfn_valid(pfn))</yellow>
<yellow>		kvm_set_page_dirty(pfn_to_page(pfn));</yellow>
<yellow>}</yellow>
EXPORT_SYMBOL_GPL(kvm_set_pfn_dirty);

<blue>void kvm_set_pfn_accessed(kvm_pfn_t pfn)</blue>
{
<blue>	if (WARN_ON(is_error_noslot_pfn(pfn)))</blue>
		return;

<blue>	if (pfn_valid(pfn))</blue>
<blue>		kvm_set_page_accessed(pfn_to_page(pfn));</blue>
<blue>}</blue>
EXPORT_SYMBOL_GPL(kvm_set_pfn_accessed);

static int next_segment(unsigned long len, int offset)
{
<blue>	if (len > PAGE_SIZE - offset)</blue>
<yellow>		return PAGE_SIZE - offset;</yellow>
	else
		return len;
}

static int __kvm_read_guest_page(struct kvm_memory_slot *slot, gfn_t gfn,
				 void *data, int offset, int len)
{
	int r;
	unsigned long addr;

<blue>	addr = gfn_to_hva_memslot_prot(slot, gfn, NULL);</blue>
	if (kvm_is_error_hva(addr))
		return -EFAULT;
<blue>	r = __copy_from_user(data, (void __user *)addr + offset, len);</blue>
	if (r)
		return -EFAULT;
	return 0;
}

int kvm_read_guest_page(struct kvm *kvm, gfn_t gfn, void *data, int offset,
			int len)
{
<blue>	struct kvm_memory_slot *slot = gfn_to_memslot(kvm, gfn);</blue>

<blue>	return __kvm_read_guest_page(slot, gfn, data, offset, len);</blue>
<yellow>}</yellow>
EXPORT_SYMBOL_GPL(kvm_read_guest_page);

int kvm_vcpu_read_guest_page(struct kvm_vcpu *vcpu, gfn_t gfn, void *data,
			     int offset, int len)
{
<blue>	struct kvm_memory_slot *slot = kvm_vcpu_gfn_to_memslot(vcpu, gfn);</blue>

<blue>	return __kvm_read_guest_page(slot, gfn, data, offset, len);</blue>
<blue>}</blue>
EXPORT_SYMBOL_GPL(kvm_vcpu_read_guest_page);

int kvm_read_guest(struct kvm *kvm, gpa_t gpa, void *data, unsigned long len)
{
<blue>	gfn_t gfn = gpa >> PAGE_SHIFT;</blue>
	int seg;
	int offset = offset_in_page(gpa);
	int ret;

<blue>	while ((seg = next_segment(len, offset)) != 0) {</blue>
<blue>		ret = kvm_read_guest_page(kvm, gfn, data, offset, seg);</blue>
		if (ret &lt; 0)
			return ret;
		offset = 0;
		len -= seg;
		data += seg;
<blue>		++gfn;</blue>
	}
	return 0;
<blue>}</blue>
EXPORT_SYMBOL_GPL(kvm_read_guest);

int kvm_vcpu_read_guest(struct kvm_vcpu *vcpu, gpa_t gpa, void *data, unsigned long len)
{
<blue>	gfn_t gfn = gpa >> PAGE_SHIFT;</blue>
	int seg;
	int offset = offset_in_page(gpa);
	int ret;

<blue>	while ((seg = next_segment(len, offset)) != 0) {</blue>
<blue>		ret = kvm_vcpu_read_guest_page(vcpu, gfn, data, offset, seg);</blue>
		if (ret &lt; 0)
			return ret;
		offset = 0;
		len -= seg;
		data += seg;
<blue>		++gfn;</blue>
	}
	return 0;
<blue>}</blue>
EXPORT_SYMBOL_GPL(kvm_vcpu_read_guest);

static int __kvm_read_guest_atomic(struct kvm_memory_slot *slot, gfn_t gfn,
			           void *data, int offset, unsigned long len)
{
	int r;
	unsigned long addr;

<yellow>	addr = gfn_to_hva_memslot_prot(slot, gfn, NULL);</yellow>
	if (kvm_is_error_hva(addr))
		return -EFAULT;
<yellow>	pagefault_disable();</yellow>
	r = __copy_from_user_inatomic(data, (void __user *)addr + offset, len);
	pagefault_enable();
	if (r)
		return -EFAULT;
	return 0;
}

int kvm_vcpu_read_guest_atomic(struct kvm_vcpu *vcpu, gpa_t gpa,
			       void *data, unsigned long len)
{
	gfn_t gfn = gpa &gt;&gt; PAGE_SHIFT;
<yellow>	struct kvm_memory_slot *slot = kvm_vcpu_gfn_to_memslot(vcpu, gfn);</yellow>
	int offset = offset_in_page(gpa);

<yellow>	return __kvm_read_guest_atomic(slot, gfn, data, offset, len);</yellow>
<yellow>}</yellow>
EXPORT_SYMBOL_GPL(kvm_vcpu_read_guest_atomic);

static int __kvm_write_guest_page(struct kvm *kvm,
				  struct kvm_memory_slot *memslot, gfn_t gfn,
			          const void *data, int offset, int len)
{
	int r;
	unsigned long addr;

<blue>	addr = gfn_to_hva_memslot(memslot, gfn);</blue>
<blue>	if (kvm_is_error_hva(addr))</blue>
		return -EFAULT;
<blue>	r = __copy_to_user((void __user *)addr + offset, data, len);</blue>
	if (r)
		return -EFAULT;
<blue>	mark_page_dirty_in_slot(kvm, memslot, gfn);</blue>
	return 0;
<blue>}</blue>

int kvm_write_guest_page(struct kvm *kvm, gfn_t gfn,
			 const void *data, int offset, int len)
{
<yellow>	struct kvm_memory_slot *slot = gfn_to_memslot(kvm, gfn);</yellow>

	return __kvm_write_guest_page(kvm, slot, gfn, data, offset, len);
}
EXPORT_SYMBOL_GPL(kvm_write_guest_page);

int kvm_vcpu_write_guest_page(struct kvm_vcpu *vcpu, gfn_t gfn,
			      const void *data, int offset, int len)
{
<blue>	struct kvm_memory_slot *slot = kvm_vcpu_gfn_to_memslot(vcpu, gfn);</blue>

<blue>	return __kvm_write_guest_page(vcpu->kvm, slot, gfn, data, offset, len);</blue>
}
EXPORT_SYMBOL_GPL(kvm_vcpu_write_guest_page);

int kvm_write_guest(struct kvm *kvm, gpa_t gpa, const void *data,
		    unsigned long len)
{
	gfn_t gfn = gpa &gt;&gt; PAGE_SHIFT;
	int seg;
	int offset = offset_in_page(gpa);
	int ret;

<yellow>	while ((seg = next_segment(len, offset)) != 0) {</yellow>
<yellow>		ret = kvm_write_guest_page(kvm, gfn, data, offset, seg);</yellow>
		if (ret &lt; 0)
			return ret;
		offset = 0;
<yellow>		len -= seg;</yellow>
		data += seg;
		++gfn;
	}
	return 0;
<yellow>}</yellow>
EXPORT_SYMBOL_GPL(kvm_write_guest);

int kvm_vcpu_write_guest(struct kvm_vcpu *vcpu, gpa_t gpa, const void *data,
		         unsigned long len)
{
	gfn_t gfn = gpa &gt;&gt; PAGE_SHIFT;
	int seg;
	int offset = offset_in_page(gpa);
	int ret;

<blue>	while ((seg = next_segment(len, offset)) != 0) {</blue>
<blue>		ret = kvm_vcpu_write_guest_page(vcpu, gfn, data, offset, seg);</blue>
		if (ret &lt; 0)
			return ret;
		offset = 0;
<blue>		len -= seg;</blue>
		data += seg;
		++gfn;
	}
	return 0;
<blue>}</blue>
EXPORT_SYMBOL_GPL(kvm_vcpu_write_guest);

static int __kvm_gfn_to_hva_cache_init(struct kvm_memslots *slots,
				       struct gfn_to_hva_cache *ghc,
				       gpa_t gpa, unsigned long len)
<blue>{</blue>
	int offset = offset_in_page(gpa);
<blue>	gfn_t start_gfn = gpa >> PAGE_SHIFT;</blue>
	gfn_t end_gfn = (gpa + len - 1) &gt;&gt; PAGE_SHIFT;
	gfn_t nr_pages_needed = end_gfn - start_gfn + 1;
	gfn_t nr_pages_avail;

	/* Update ghc-&gt;generation before performing any error checks. */
	ghc-&gt;generation = slots-&gt;generation;

	if (start_gfn &gt; end_gfn) {
<yellow>		ghc->hva = KVM_HVA_ERR_BAD;</yellow>
		return -EINVAL;
	}

	/*
	 * If the requested region crosses two memslots, we still
	 * verify that the entire region is valid here.
	 */
<blue>	for ( ; start_gfn <= end_gfn; start_gfn += nr_pages_avail) {</blue>
<blue>		ghc->memslot = __gfn_to_memslot(slots, start_gfn);</blue>
		ghc-&gt;hva = gfn_to_hva_many(ghc-&gt;memslot, start_gfn,
					   &amp;nr_pages_avail);
		if (kvm_is_error_hva(ghc-&gt;hva))
			return -EFAULT;
	}

	/* Use the slow path for cross page reads and writes. */
<blue>	if (nr_pages_needed == 1)</blue>
<blue>		ghc->hva += offset;</blue>
	else
<yellow>		ghc->memslot = NULL;</yellow>

<blue>	ghc->gpa = gpa;</blue>
	ghc-&gt;len = len;
	return 0;
}

int kvm_gfn_to_hva_cache_init(struct kvm *kvm, struct gfn_to_hva_cache *ghc,
			      gpa_t gpa, unsigned long len)
{
<blue>	struct kvm_memslots *slots = kvm_memslots(kvm);</blue>
	return __kvm_gfn_to_hva_cache_init(slots, ghc, gpa, len);
}
EXPORT_SYMBOL_GPL(kvm_gfn_to_hva_cache_init);

int kvm_write_guest_offset_cached(struct kvm *kvm, struct gfn_to_hva_cache *ghc,
				  void *data, unsigned int offset,
				  unsigned long len)
{
<blue>	struct kvm_memslots *slots = kvm_memslots(kvm);</blue>
	int r;
	gpa_t gpa = ghc-&gt;gpa + offset;

<yellow>	if (WARN_ON_ONCE(len + offset > ghc->len))</yellow>
		return -EINVAL;

<blue>	if (slots->generation != ghc->generation) {</blue>
<yellow>		if (__kvm_gfn_to_hva_cache_init(slots, ghc, ghc->gpa, ghc->len))</yellow>
			return -EFAULT;
	}

<blue>	if (kvm_is_error_hva(ghc->hva))</blue>
		return -EFAULT;

<blue>	if (unlikely(!ghc->memslot))</blue>
<yellow>		return kvm_write_guest(kvm, gpa, data, len);</yellow>

<blue>	r = __copy_to_user((void __user *)ghc->hva + offset, data, len);</blue>
	if (r)
		return -EFAULT;
<blue>	mark_page_dirty_in_slot(kvm, ghc->memslot, gpa >> PAGE_SHIFT);</blue>

	return 0;
<blue>}</blue>
EXPORT_SYMBOL_GPL(kvm_write_guest_offset_cached);

int kvm_write_guest_cached(struct kvm *kvm, struct gfn_to_hva_cache *ghc,
			   void *data, unsigned long len)
{
<blue>	return kvm_write_guest_offset_cached(kvm, ghc, data, 0, len);</blue>
}
EXPORT_SYMBOL_GPL(kvm_write_guest_cached);

int kvm_read_guest_offset_cached(struct kvm *kvm, struct gfn_to_hva_cache *ghc,
				 void *data, unsigned int offset,
				 unsigned long len)
{
<blue>	struct kvm_memslots *slots = kvm_memslots(kvm);</blue>
	int r;
	gpa_t gpa = ghc-&gt;gpa + offset;

<yellow>	if (WARN_ON_ONCE(len + offset > ghc->len))</yellow>
		return -EINVAL;

<blue>	if (slots->generation != ghc->generation) {</blue>
<yellow>		if (__kvm_gfn_to_hva_cache_init(slots, ghc, ghc->gpa, ghc->len))</yellow>
			return -EFAULT;
	}

<blue>	if (kvm_is_error_hva(ghc->hva))</blue>
		return -EFAULT;

<blue>	if (unlikely(!ghc->memslot))</blue>
<yellow>		return kvm_read_guest(kvm, gpa, data, len);</yellow>

<blue>	r = __copy_from_user(data, (void __user *)ghc->hva + offset, len);</blue>
	if (r)
		return -EFAULT;

	return 0;
<blue>}</blue>
EXPORT_SYMBOL_GPL(kvm_read_guest_offset_cached);

int kvm_read_guest_cached(struct kvm *kvm, struct gfn_to_hva_cache *ghc,
			  void *data, unsigned long len)
{
<blue>	return kvm_read_guest_offset_cached(kvm, ghc, data, 0, len);</blue>
}
EXPORT_SYMBOL_GPL(kvm_read_guest_cached);

int kvm_clear_guest(struct kvm *kvm, gpa_t gpa, unsigned long len)
{
<yellow>	const void *zero_page = (const void *) __va(page_to_phys(ZERO_PAGE(0)));</yellow>
	gfn_t gfn = gpa &gt;&gt; PAGE_SHIFT;
	int seg;
	int offset = offset_in_page(gpa);
	int ret;

<yellow>	while ((seg = next_segment(len, offset)) != 0) {</yellow>
<yellow>		ret = kvm_write_guest_page(kvm, gfn, zero_page, offset, len);</yellow>
		if (ret &lt; 0)
			return ret;
		offset = 0;
<yellow>		len -= seg;</yellow>
		++gfn;
	}
	return 0;
<yellow>}</yellow>
EXPORT_SYMBOL_GPL(kvm_clear_guest);

void mark_page_dirty_in_slot(struct kvm *kvm,
			     const struct kvm_memory_slot *memslot,
		 	     gfn_t gfn)
{
<blue>	struct kvm_vcpu *vcpu = kvm_get_running_vcpu();</blue>

#ifdef CONFIG_HAVE_KVM_DIRTY_RING
<blue>	if (WARN_ON_ONCE(!vcpu) || WARN_ON_ONCE(vcpu->kvm != kvm))</blue>
		return;
#endif

<blue>	if (memslot && kvm_slot_dirty_track_enabled(memslot)) {</blue>
<yellow>		unsigned long rel_gfn = gfn - memslot->base_gfn;</yellow>
<yellow>		u32 slot = (memslot->as_id << 16) | memslot->id;</yellow>

		if (kvm-&gt;dirty_ring_size)
			kvm_dirty_ring_push(&amp;vcpu-&gt;dirty_ring,
					    slot, rel_gfn);
		else
<yellow>			set_bit_le(rel_gfn, memslot->dirty_bitmap);</yellow>
	}
<blue>}</blue>
EXPORT_SYMBOL_GPL(mark_page_dirty_in_slot);

void mark_page_dirty(struct kvm *kvm, gfn_t gfn)
{
	struct kvm_memory_slot *memslot;

<yellow>	memslot = gfn_to_memslot(kvm, gfn);</yellow>
	mark_page_dirty_in_slot(kvm, memslot, gfn);
}
EXPORT_SYMBOL_GPL(mark_page_dirty);

void kvm_vcpu_mark_page_dirty(struct kvm_vcpu *vcpu, gfn_t gfn)
{
	struct kvm_memory_slot *memslot;

<blue>	memslot = kvm_vcpu_gfn_to_memslot(vcpu, gfn);</blue>
	mark_page_dirty_in_slot(vcpu-&gt;kvm, memslot, gfn);
}
EXPORT_SYMBOL_GPL(kvm_vcpu_mark_page_dirty);

void kvm_sigset_activate(struct kvm_vcpu *vcpu)
{
<blue>	if (!vcpu->sigset_active)</blue>
		return;

	/*
	 * This does a lockless modification of -&gt;real_blocked, which is fine
	 * because, only current can change -&gt;real_blocked and all readers of
	 * -&gt;real_blocked don&#x27;t care as long -&gt;real_blocked is always a subset
	 * of -&gt;blocked.
	 */
<yellow>	sigprocmask(SIG_SETMASK, &vcpu->sigset, &current->real_blocked);</yellow>
<blue>}</blue>

void kvm_sigset_deactivate(struct kvm_vcpu *vcpu)
{
<blue>	if (!vcpu->sigset_active)</blue>
		return;

<yellow>	sigprocmask(SIG_SETMASK, &current->real_blocked, NULL);</yellow>
	sigemptyset(&amp;current-&gt;real_blocked);
<blue>}</blue>

static void grow_halt_poll_ns(struct kvm_vcpu *vcpu)
{
	unsigned int old, val, grow, grow_start;

	old = val = vcpu-&gt;halt_poll_ns;
<yellow>	grow_start = READ_ONCE(halt_poll_ns_grow_start);</yellow>
	grow = READ_ONCE(halt_poll_ns_grow);
	if (!grow)
		goto out;

<yellow>	val *= grow;</yellow>
	if (val &lt; grow_start)
		val = grow_start;

	vcpu-&gt;halt_poll_ns = val;
out:
<yellow>	trace_kvm_halt_poll_ns_grow(vcpu->vcpu_id, val, old);</yellow>
}

static void shrink_halt_poll_ns(struct kvm_vcpu *vcpu)
{
	unsigned int old, val, shrink, grow_start;

	old = val = vcpu-&gt;halt_poll_ns;
<yellow>	shrink = READ_ONCE(halt_poll_ns_shrink);</yellow>
	grow_start = READ_ONCE(halt_poll_ns_grow_start);
	if (shrink == 0)
		val = 0;
	else
<yellow>		val /= shrink;</yellow>

<yellow>	if (val < grow_start)</yellow>
		val = 0;

	vcpu-&gt;halt_poll_ns = val;
<yellow>	trace_kvm_halt_poll_ns_shrink(vcpu->vcpu_id, val, old);</yellow>
}

static int kvm_vcpu_check_block(struct kvm_vcpu *vcpu)
{
	int ret = -EINTR;
<blue>	int idx = srcu_read_lock(&vcpu->kvm->srcu);</blue>

	if (kvm_arch_vcpu_runnable(vcpu))
		goto out;
<blue>	if (kvm_cpu_has_pending_timer(vcpu))</blue>
		goto out;
<blue>	if (signal_pending(current))</blue>
		goto out;
<blue>	if (kvm_check_request(KVM_REQ_UNBLOCK, vcpu))</blue>
		goto out;

	ret = 0;
out:
<blue>	srcu_read_unlock(&vcpu->kvm->srcu, idx);</blue>
	return ret;
}

/*
 * Block the vCPU until the vCPU is runnable, an event arrives, or a signal is
 * pending.  This is mostly used when halting a vCPU, but may also be used
 * directly for other vCPU non-runnable states, e.g. x86&#x27;s Wait-For-SIPI.
 */
bool kvm_vcpu_block(struct kvm_vcpu *vcpu)
{
	struct rcuwait *wait = kvm_arch_vcpu_get_wait(vcpu);
	bool waited = false;

<blue>	vcpu->stat.generic.blocking = 1;</blue>

	preempt_disable();
	kvm_arch_vcpu_blocking(vcpu);
	prepare_to_rcuwait(wait);
<yellow>	preempt_enable();</yellow>

	for (;;) {
<blue>		set_current_state(TASK_INTERRUPTIBLE);</blue>

		if (kvm_vcpu_check_block(vcpu) &lt; 0)
			break;

<blue>		waited = true;</blue>
		schedule();
	}

<blue>	preempt_disable();</blue>
	finish_rcuwait(wait);
	kvm_arch_vcpu_unblocking(vcpu);
<yellow>	preempt_enable();</yellow>

<blue>	vcpu->stat.generic.blocking = 0;</blue>

	return waited;
}

static inline void update_halt_poll_stats(struct kvm_vcpu *vcpu, ktime_t start,
					  ktime_t end, bool success)
{
	struct kvm_vcpu_stat_generic *stats = &amp;vcpu-&gt;stat.generic;
<yellow>	u64 poll_ns = ktime_to_ns(ktime_sub(end, start));</yellow>

<yellow>	++vcpu->stat.generic.halt_attempted_poll;</yellow>

	if (success) {
		++vcpu-&gt;stat.generic.halt_successful_poll;

		if (!vcpu_valid_wakeup(vcpu))
			++vcpu-&gt;stat.generic.halt_poll_invalid;

		stats-&gt;halt_poll_success_ns += poll_ns;
		KVM_STATS_LOG_HIST_UPDATE(stats-&gt;halt_poll_success_hist, poll_ns);
	} else {
		stats-&gt;halt_poll_fail_ns += poll_ns;
		KVM_STATS_LOG_HIST_UPDATE(stats-&gt;halt_poll_fail_hist, poll_ns);
	}
}

static unsigned int kvm_vcpu_max_halt_poll_ns(struct kvm_vcpu *vcpu)
{
	struct kvm *kvm = vcpu-&gt;kvm;

<blue>	if (kvm->override_halt_poll_ns) {</blue>
		/*
		 * Ensure kvm-&gt;max_halt_poll_ns is not read before
		 * kvm-&gt;override_halt_poll_ns.
		 *
		 * Pairs with the smp_wmb() when enabling KVM_CAP_HALT_POLL.
		 */
		smp_rmb();
<yellow>		return READ_ONCE(kvm->max_halt_poll_ns);</yellow>
	}

<blue>	return READ_ONCE(halt_poll_ns);</blue>
}

/*
 * Emulate a vCPU halt condition, e.g. HLT on x86, WFI on arm, etc...  If halt
 * polling is enabled, busy wait for a short time before blocking to avoid the
 * expensive block+unblock sequence if a wake event arrives soon after the vCPU
 * is halted.
 */
void kvm_vcpu_halt(struct kvm_vcpu *vcpu)
{
<blue>	unsigned int max_halt_poll_ns = kvm_vcpu_max_halt_poll_ns(vcpu);</blue>
<blue>	bool halt_poll_allowed = !kvm_arch_no_poll(vcpu);</blue>
	ktime_t start, cur, poll_end;
	bool waited = false;
	bool do_halt_poll;
	u64 halt_ns;

	if (vcpu-&gt;halt_poll_ns &gt; max_halt_poll_ns)
<yellow>		vcpu->halt_poll_ns = max_halt_poll_ns;</yellow>

<blue>	do_halt_poll = halt_poll_allowed && vcpu->halt_poll_ns;</blue>

<yellow>	start = cur = poll_end = ktime_get();</yellow>
	if (do_halt_poll) {
		ktime_t stop = ktime_add_ns(start, vcpu-&gt;halt_poll_ns);

		do {
			/*
			 * This sets KVM_REQ_UNHALT if an interrupt
			 * arrives.
			 */
<yellow>			if (kvm_vcpu_check_block(vcpu) < 0)</yellow>
				goto out;
<yellow>			cpu_relax();</yellow>
			poll_end = cur = ktime_get();
<yellow>		} while (kvm_vcpu_can_poll(cur, stop));</yellow>
	}

<blue>	waited = kvm_vcpu_block(vcpu);</blue>

	cur = ktime_get();
	if (waited) {
<blue>		vcpu->stat.generic.halt_wait_ns +=</blue>
			ktime_to_ns(cur) - ktime_to_ns(poll_end);
		KVM_STATS_LOG_HIST_UPDATE(vcpu-&gt;stat.generic.halt_wait_hist,
				ktime_to_ns(cur) - ktime_to_ns(poll_end));
	}
out:
	/* The total time the vCPU was &quot;halted&quot;, including polling time. */
<yellow>	halt_ns = ktime_to_ns(cur) - ktime_to_ns(start);</yellow>

	/*
	 * Note, halt-polling is considered successful so long as the vCPU was
	 * never actually scheduled out, i.e. even if the wake event arrived
	 * after of the halt-polling loop itself, but before the full wait.
	 */
<yellow>	if (do_halt_poll)</yellow>
<yellow>		update_halt_poll_stats(vcpu, start, poll_end, !waited);</yellow>

<blue>	if (halt_poll_allowed) {</blue>
		/* Recompute the max halt poll time in case it changed. */
<blue>		max_halt_poll_ns = kvm_vcpu_max_halt_poll_ns(vcpu);</blue>

		if (!vcpu_valid_wakeup(vcpu)) {
			shrink_halt_poll_ns(vcpu);
<blue>		} else if (max_halt_poll_ns) {</blue>
<blue>			if (halt_ns <= vcpu->halt_poll_ns)</blue>
				;
			/* we had a long block, shrink polling */
<yellow>			else if (vcpu->halt_poll_ns &&</yellow>
<blue>				 halt_ns > max_halt_poll_ns)</blue>
<yellow>				shrink_halt_poll_ns(vcpu);</yellow>
			/* we had a short halt and our poll time is too small */
<blue>			else if (vcpu->halt_poll_ns < max_halt_poll_ns &&</blue>
				 halt_ns &lt; max_halt_poll_ns)
<yellow>				grow_halt_poll_ns(vcpu);</yellow>
		} else {
<yellow>			vcpu->halt_poll_ns = 0;</yellow>
		}
	}

<blue>	trace_kvm_vcpu_wakeup(halt_ns, waited, vcpu_valid_wakeup(vcpu));</blue>
<blue>}</blue>
EXPORT_SYMBOL_GPL(kvm_vcpu_halt);

<yellow>bool kvm_vcpu_wake_up(struct kvm_vcpu *vcpu)</yellow>
{
<blue>	if (__kvm_vcpu_wake_up(vcpu)) {</blue>
<yellow>		WRITE_ONCE(vcpu->ready, true);</yellow>
		++vcpu-&gt;stat.generic.halt_wakeup;
		return true;
	}

	return false;
<yellow>}</yellow>
EXPORT_SYMBOL_GPL(kvm_vcpu_wake_up);

#ifndef CONFIG_S390
/*
 * Kick a sleeping VCPU, or a guest VCPU in guest mode, into host kernel mode.
 */
<blue>void kvm_vcpu_kick(struct kvm_vcpu *vcpu)</blue>
{
	int me, cpu;

<blue>	if (kvm_vcpu_wake_up(vcpu))</blue>
		return;

<blue>	me = get_cpu();</blue>
	/*
	 * The only state change done outside the vcpu mutex is IN_GUEST_MODE
	 * to EXITING_GUEST_MODE.  Therefore the moderately expensive &quot;should
	 * kick&quot; check does not need atomic operations if kvm_vcpu_kick is used
	 * within the vCPU thread itself.
	 */
	if (vcpu == __this_cpu_read(kvm_running_vcpu)) {
<blue>		if (vcpu->mode == IN_GUEST_MODE)</blue>
<yellow>			WRITE_ONCE(vcpu->mode, EXITING_GUEST_MODE);</yellow>
		goto out;
	}

	/*
	 * Note, the vCPU could get migrated to a different pCPU at any point
	 * after kvm_arch_vcpu_should_kick(), which could result in sending an
	 * IPI to the previous pCPU.  But, that&#x27;s ok because the purpose of the
	 * IPI is to force the vCPU to leave IN_GUEST_MODE, and migrating the
	 * vCPU also requires it to leave IN_GUEST_MODE.
	 */
<yellow>	if (kvm_arch_vcpu_should_kick(vcpu)) {</yellow>
<yellow>		cpu = READ_ONCE(vcpu->cpu);</yellow>
<yellow>		if (cpu != me && (unsigned)cpu < nr_cpu_ids && cpu_online(cpu))</yellow>
<yellow>			smp_send_reschedule(cpu);</yellow>
	}
out:
<blue>	put_cpu();</blue>
<blue>}</blue>
EXPORT_SYMBOL_GPL(kvm_vcpu_kick);
#endif /* !CONFIG_S390 */

int kvm_vcpu_yield_to(struct kvm_vcpu *target)
{
	struct pid *pid;
	struct task_struct *task = NULL;
	int ret = 0;

<yellow>	rcu_read_lock();</yellow>
	pid = rcu_dereference(target-&gt;pid);
	if (pid)
<yellow>		task = get_pid_task(pid, PIDTYPE_PID);</yellow>
	rcu_read_unlock();
	if (!task)
<yellow>		return ret;</yellow>
	ret = yield_to(task, 1);
<yellow>	put_task_struct(task);</yellow>

	return ret;
<yellow>}</yellow>
EXPORT_SYMBOL_GPL(kvm_vcpu_yield_to);

/*
 * Helper that checks whether a VCPU is eligible for directed yield.
 * Most eligible candidate to yield is decided by following heuristics:
 *
 *  (a) VCPU which has not done pl-exit or cpu relax intercepted recently
 *  (preempted lock holder), indicated by @in_spin_loop.
 *  Set at the beginning and cleared at the end of interception/PLE handler.
 *
 *  (b) VCPU which has done pl-exit/ cpu relax intercepted but did not get
 *  chance last time (mostly it has become eligible now since we have probably
 *  yielded to lockholder in last iteration. This is done by toggling
 *  @dy_eligible each time a VCPU checked for eligibility.)
 *
 *  Yielding to a recently pl-exited/cpu relax intercepted VCPU before yielding
 *  to preempted lock-holder could result in wrong VCPU selection and CPU
 *  burning. Giving priority for a potential lock-holder increases lock
 *  progress.
 *
 *  Since algorithm is based on heuristics, accessing another VCPU data without
 *  locking does not harm. It may result in trying to yield to  same VCPU, fail
 *  and continue with next VCPU and so on.
 */
static bool kvm_vcpu_eligible_for_directed_yield(struct kvm_vcpu *vcpu)
{
#ifdef CONFIG_HAVE_KVM_CPU_RELAX_INTERCEPT
	bool eligible;

<yellow>	eligible = !vcpu->spin_loop.in_spin_loop ||</yellow>
<yellow>		    vcpu->spin_loop.dy_eligible;</yellow>

<yellow>	if (vcpu->spin_loop.in_spin_loop)</yellow>
<yellow>		kvm_vcpu_set_dy_eligible(vcpu, !vcpu->spin_loop.dy_eligible);</yellow>

	return eligible;
#else
	return true;
#endif
}

/*
 * Unlike kvm_arch_vcpu_runnable, this function is called outside
 * a vcpu_load/vcpu_put pair.  However, for most architectures
 * kvm_arch_vcpu_runnable does not require vcpu_load.
 */
bool __weak kvm_arch_dy_runnable(struct kvm_vcpu *vcpu)
{
<yellow>	return kvm_arch_vcpu_runnable(vcpu);</yellow>
}

static bool vcpu_dy_runnable(struct kvm_vcpu *vcpu)
{
<yellow>	if (kvm_arch_dy_runnable(vcpu))</yellow>
		return true;

#ifdef CONFIG_KVM_ASYNC_PF
<yellow>	if (!list_empty_careful(&vcpu->async_pf.done))</yellow>
		return true;
#endif

	return false;
}

bool __weak kvm_arch_dy_has_pending_interrupt(struct kvm_vcpu *vcpu)
{
	return false;
<yellow>}</yellow>

void kvm_vcpu_on_spin(struct kvm_vcpu *me, bool yield_to_kernel_mode)
{
<yellow>	struct kvm *kvm = me->kvm;</yellow>
	struct kvm_vcpu *vcpu;
	int last_boosted_vcpu = me-&gt;kvm-&gt;last_boosted_vcpu;
	unsigned long i;
	int yielded = 0;
	int try = 3;
	int pass;

	kvm_vcpu_set_in_spin_loop(me, true);
	/*
	 * We boost the priority of a VCPU that is runnable but not
	 * currently running, because it got preempted by something
	 * else and called schedule in __vcpu_run.  Hopefully that
	 * VCPU is holding the lock that we need and will release it.
	 * We approximate round-robin by starting at the last boosted VCPU.
	 */
<yellow>	for (pass = 0; pass < 2 && !yielded && try; pass++) {</yellow>
<yellow>		kvm_for_each_vcpu(i, vcpu, kvm) {</yellow>
<yellow>			if (!pass && i <= last_boosted_vcpu) {</yellow>
<yellow>				i = last_boosted_vcpu;</yellow>
				continue;
<yellow>			} else if (pass && i > last_boosted_vcpu)</yellow>
				break;
<yellow>			if (!READ_ONCE(vcpu->ready))</yellow>
				continue;
<yellow>			if (vcpu == me)</yellow>
				continue;
<yellow>			if (kvm_vcpu_is_blocking(vcpu) && !vcpu_dy_runnable(vcpu))</yellow>
				continue;
<yellow>			if (READ_ONCE(vcpu->preempted) && yield_to_kernel_mode &&</yellow>
<yellow>			    !kvm_arch_dy_has_pending_interrupt(vcpu) &&</yellow>
<yellow>			    !kvm_arch_vcpu_in_kernel(vcpu))</yellow>
				continue;
<yellow>			if (!kvm_vcpu_eligible_for_directed_yield(vcpu))</yellow>
				continue;

<yellow>			yielded = kvm_vcpu_yield_to(vcpu);</yellow>
			if (yielded &gt; 0) {
<yellow>				kvm->last_boosted_vcpu = i;</yellow>
				break;
<yellow>			} else if (yielded < 0) {</yellow>
<yellow>				try--;</yellow>
				if (!try)
					break;
			}
		}
	}
<yellow>	kvm_vcpu_set_in_spin_loop(me, false);</yellow>

	/* Ensure vcpu is not eligible during next spinloop */
	kvm_vcpu_set_dy_eligible(me, false);
}
EXPORT_SYMBOL_GPL(kvm_vcpu_on_spin);

static bool kvm_page_in_dirty_ring(struct kvm *kvm, unsigned long pgoff)
{
#ifdef CONFIG_HAVE_KVM_DIRTY_RING
<yellow>	return (pgoff >= KVM_DIRTY_LOG_PAGE_OFFSET) &&</yellow>
	    (pgoff &lt; KVM_DIRTY_LOG_PAGE_OFFSET +
<yellow>	     kvm->dirty_ring_size / PAGE_SIZE);</yellow>
#else
	return false;
#endif
}

static vm_fault_t kvm_vcpu_fault(struct vm_fault *vmf)
{
<yellow>	struct kvm_vcpu *vcpu = vmf->vma->vm_file->private_data;</yellow>
	struct page *page;

	if (vmf-&gt;pgoff == 0)
<yellow>		page = virt_to_page(vcpu->run);</yellow>
#ifdef CONFIG_X86
<yellow>	else if (vmf->pgoff == KVM_PIO_PAGE_OFFSET)</yellow>
<yellow>		page = virt_to_page(vcpu->arch.pio_data);</yellow>
#endif
#ifdef CONFIG_KVM_MMIO
	else if (vmf-&gt;pgoff == KVM_COALESCED_MMIO_PAGE_OFFSET)
<yellow>		page = virt_to_page(vcpu->kvm->coalesced_mmio_ring);</yellow>
#endif
<yellow>	else if (kvm_page_in_dirty_ring(vcpu->kvm, vmf->pgoff))</yellow>
<yellow>		page = kvm_dirty_ring_get_page(</yellow>
		    &amp;vcpu-&gt;dirty_ring,
		    vmf-&gt;pgoff - KVM_DIRTY_LOG_PAGE_OFFSET);
	else
<yellow>		return kvm_arch_vcpu_fault(vcpu, vmf);</yellow>
<yellow>	get_page(page);</yellow>
	vmf-&gt;page = page;
	return 0;
<yellow>}</yellow>

static const struct vm_operations_struct kvm_vcpu_vm_ops = {
	.fault = kvm_vcpu_fault,
};

static int kvm_vcpu_mmap(struct file *file, struct vm_area_struct *vma)
<yellow>{</yellow>
<yellow>	struct kvm_vcpu *vcpu = file->private_data;</yellow>
<yellow>	unsigned long pages = vma_pages(vma);</yellow>

<yellow>	if ((kvm_page_in_dirty_ring(vcpu->kvm, vma->vm_pgoff) ||</yellow>
<yellow>	     kvm_page_in_dirty_ring(vcpu->kvm, vma->vm_pgoff + pages - 1)) &&</yellow>
<yellow>	    ((vma->vm_flags & VM_EXEC) || !(vma->vm_flags & VM_SHARED)))</yellow>
<yellow>		return -EINVAL;</yellow>

<yellow>	vma->vm_ops = &kvm_vcpu_vm_ops;</yellow>
	return 0;
<yellow>}</yellow>

static int kvm_vcpu_release(struct inode *inode, struct file *filp)
{
<yellow>	struct kvm_vcpu *vcpu = filp->private_data;</yellow>

	kvm_put_kvm(vcpu-&gt;kvm);
	return 0;
}

static const struct file_operations kvm_vcpu_fops = {
	.release        = kvm_vcpu_release,
	.unlocked_ioctl = kvm_vcpu_ioctl,
	.mmap           = kvm_vcpu_mmap,
	.llseek		= noop_llseek,
	KVM_COMPAT(kvm_vcpu_compat_ioctl),
};

/*
 * Allocates an inode for the vcpu.
 */
static int create_vcpu_fd(struct kvm_vcpu *vcpu)
{
	char name[8 + 1 + ITOA_MAX_LEN + 1];

<blue>	snprintf(name, sizeof(name), "kvm-vcpu:%d", vcpu->vcpu_id);</blue>
	return anon_inode_getfd(name, &amp;kvm_vcpu_fops, vcpu, O_RDWR | O_CLOEXEC);
}

#ifdef __KVM_HAVE_ARCH_VCPU_DEBUGFS
static int vcpu_get_pid(void *data, u64 *val)
<yellow>{</yellow>
	struct kvm_vcpu *vcpu = (struct kvm_vcpu *) data;
<yellow>	*val = pid_nr(rcu_access_pointer(vcpu->pid));</yellow>
	return 0;
}

<yellow>DEFINE_SIMPLE_ATTRIBUTE(vcpu_get_pid_fops, vcpu_get_pid, NULL, "%llu\n");</yellow>

static void kvm_create_vcpu_debugfs(struct kvm_vcpu *vcpu)
{
	struct dentry *debugfs_dentry;
	char dir_name[ITOA_MAX_LEN * 2];

	if (!debugfs_initialized())
		return;

<blue>	snprintf(dir_name, sizeof(dir_name), "vcpu%d", vcpu->vcpu_id);</blue>
	debugfs_dentry = debugfs_create_dir(dir_name,
					    vcpu-&gt;kvm-&gt;debugfs_dentry);
	debugfs_create_file(&quot;pid&quot;, 0444, debugfs_dentry, vcpu,
			    &amp;vcpu_get_pid_fops);

	kvm_arch_create_vcpu_debugfs(vcpu, debugfs_dentry);
}
#endif

/*
 * Creates some virtual cpus.  Good luck creating more than one.
 */
static int kvm_vm_ioctl_create_vcpu(struct kvm *kvm, u32 id)
{
	int r;
	struct kvm_vcpu *vcpu;
	struct page *page;

	if (id &gt;= KVM_MAX_VCPU_IDS)
		return -EINVAL;

<blue>	mutex_lock(&kvm->lock);</blue>
	if (kvm-&gt;created_vcpus &gt;= kvm-&gt;max_vcpus) {
<yellow>		mutex_unlock(&kvm->lock);</yellow>
		return -EINVAL;
	}

<blue>	r = kvm_arch_vcpu_precreate(kvm, id);</blue>
	if (r) {
<yellow>		mutex_unlock(&kvm->lock);</yellow>
		return r;
	}

<blue>	kvm->created_vcpus++;</blue>
	mutex_unlock(&amp;kvm-&gt;lock);

	vcpu = kmem_cache_zalloc(kvm_vcpu_cache, GFP_KERNEL_ACCOUNT);
	if (!vcpu) {
		r = -ENOMEM;
		goto vcpu_decrement;
	}

	BUILD_BUG_ON(sizeof(struct kvm_run) &gt; PAGE_SIZE);
<blue>	page = alloc_page(GFP_KERNEL_ACCOUNT | __GFP_ZERO);</blue>
	if (!page) {
		r = -ENOMEM;
		goto vcpu_free;
	}
<blue>	vcpu->run = page_address(page);</blue>

	kvm_vcpu_init(vcpu, kvm, id);

	r = kvm_arch_vcpu_create(vcpu);
	if (r)
		goto vcpu_free_run_page;

<blue>	if (kvm->dirty_ring_size) {</blue>
<yellow>		r = kvm_dirty_ring_alloc(&vcpu->dirty_ring,</yellow>
					 id, kvm-&gt;dirty_ring_size);
		if (r)
			goto arch_vcpu_destroy;
	}

<blue>	mutex_lock(&kvm->lock);</blue>
<blue>	if (kvm_get_vcpu_by_id(kvm, id)) {</blue>
		r = -EEXIST;
		goto unlock_vcpu_destroy;
	}

<blue>	vcpu->vcpu_idx = atomic_read(&kvm->online_vcpus);</blue>
	r = xa_insert(&amp;kvm-&gt;vcpu_array, vcpu-&gt;vcpu_idx, vcpu, GFP_KERNEL_ACCOUNT);
<yellow>	BUG_ON(r == -EBUSY);</yellow>
<blue>	if (r)</blue>
		goto unlock_vcpu_destroy;

	/* Now it&#x27;s all set up, let userspace reach it */
<blue>	kvm_get_kvm(kvm);</blue>
<blue>	r = create_vcpu_fd(vcpu);</blue>
	if (r &lt; 0) {
<yellow>		xa_erase(&kvm->vcpu_array, vcpu->vcpu_idx);</yellow>
		kvm_put_kvm_no_destroy(kvm);
		goto unlock_vcpu_destroy;
	}

	/*
	 * Pairs with smp_rmb() in kvm_get_vcpu.  Store the vcpu
	 * pointer before kvm-&gt;online_vcpu&#x27;s incremented value.
	 */
	smp_wmb();
<blue>	atomic_inc(&kvm->online_vcpus);</blue>

	mutex_unlock(&amp;kvm-&gt;lock);
	kvm_arch_vcpu_postcreate(vcpu);
<blue>	kvm_create_vcpu_debugfs(vcpu);</blue>
	return r;

unlock_vcpu_destroy:
<yellow>	mutex_unlock(&kvm->lock);</yellow>
	kvm_dirty_ring_free(&amp;vcpu-&gt;dirty_ring);
arch_vcpu_destroy:
<yellow>	kvm_arch_vcpu_destroy(vcpu);</yellow>
vcpu_free_run_page:
<yellow>	free_page((unsigned long)vcpu->run);</yellow>
vcpu_free:
<yellow>	kmem_cache_free(kvm_vcpu_cache, vcpu);</yellow>
vcpu_decrement:
<yellow>	mutex_lock(&kvm->lock);</yellow>
	kvm-&gt;created_vcpus--;
	mutex_unlock(&amp;kvm-&gt;lock);
	return r;
}

static int kvm_vcpu_ioctl_set_sigmask(struct kvm_vcpu *vcpu, sigset_t *sigset)
{
	if (sigset) {
		sigdelsetmask(sigset, sigmask(SIGKILL)|sigmask(SIGSTOP));
<yellow>		vcpu->sigset_active = 1;</yellow>
		vcpu-&gt;sigset = *sigset;
	} else
<yellow>		vcpu->sigset_active = 0;</yellow>
	return 0;
}

static ssize_t kvm_vcpu_stats_read(struct file *file, char __user *user_buffer,
			      size_t size, loff_t *offset)
{
<yellow>	struct kvm_vcpu *vcpu = file->private_data;</yellow>

	return kvm_stats_read(vcpu-&gt;stats_id, &amp;kvm_vcpu_stats_header,
			&amp;kvm_vcpu_stats_desc[0], &amp;vcpu-&gt;stat,
			sizeof(vcpu-&gt;stat), user_buffer, size, offset);
}

static const struct file_operations kvm_vcpu_stats_fops = {
	.read = kvm_vcpu_stats_read,
	.llseek = noop_llseek,
};

static int kvm_vcpu_ioctl_get_stats_fd(struct kvm_vcpu *vcpu)
{
	int fd;
	struct file *file;
	char name[15 + ITOA_MAX_LEN + 1];

<yellow>	snprintf(name, sizeof(name), "kvm-vcpu-stats:%d", vcpu->vcpu_id);</yellow>

	fd = get_unused_fd_flags(O_CLOEXEC);
	if (fd &lt; 0)
		return fd;

<yellow>	file = anon_inode_getfile(name, &kvm_vcpu_stats_fops, vcpu, O_RDONLY);</yellow>
	if (IS_ERR(file)) {
<yellow>		put_unused_fd(fd);</yellow>
		return PTR_ERR(file);
	}
<yellow>	file->f_mode |= FMODE_PREAD;</yellow>
	fd_install(fd, file);

	return fd;
}

static long kvm_vcpu_ioctl(struct file *filp,
			   unsigned int ioctl, unsigned long arg)
<blue>{</blue>
<blue>	struct kvm_vcpu *vcpu = filp->private_data;</blue>
	void __user *argp = (void __user *)arg;
	int r;
<yellow>	struct kvm_fpu *fpu = NULL;</yellow>
<yellow>	struct kvm_sregs *kvm_sregs = NULL;</yellow>

<blue>	if (vcpu->kvm->mm != current->mm || vcpu->kvm->vm_dead)</blue>
		return -EIO;

<blue>	if (unlikely(_IOC_TYPE(ioctl) != KVMIO))</blue>
		return -EINVAL;

	/*
	 * Some architectures have vcpu ioctls that are asynchronous to vcpu
	 * execution; mutex_lock() would break them.
	 */
	r = kvm_arch_vcpu_async_ioctl(filp, ioctl, arg);
	if (r != -ENOIOCTLCMD)
		return r;

<blue>	if (mutex_lock_killable(&vcpu->mutex))</blue>
		return -EINTR;
<blue>	switch (ioctl) {</blue>
	case KVM_RUN: {
		struct pid *oldpid;
		r = -EINVAL;
<blue>		if (arg)</blue>
			goto out;
<blue>		oldpid = rcu_access_pointer(vcpu->pid);</blue>
		if (unlikely(oldpid != task_pid(current))) {
			/* The thread running this VCPU changed. */
			struct pid *newpid;

			r = kvm_arch_vcpu_run_pid_change(vcpu);
			if (r)
				break;

<blue>			newpid = get_task_pid(current, PIDTYPE_PID);</blue>
			rcu_assign_pointer(vcpu-&gt;pid, newpid);
			if (oldpid)
<yellow>				synchronize_rcu();</yellow>
<blue>			put_pid(oldpid);</blue>
		}
<blue>		r = kvm_arch_vcpu_ioctl_run(vcpu);</blue>
<yellow>		trace_kvm_userspace_exit(vcpu->run->exit_reason, r);</yellow>
		break;
	}
	case KVM_GET_REGS: {
		struct kvm_regs *kvm_regs;

		r = -ENOMEM;
<yellow>		kvm_regs = kzalloc(sizeof(struct kvm_regs), GFP_KERNEL_ACCOUNT);</yellow>
		if (!kvm_regs)
			goto out;
<yellow>		r = kvm_arch_vcpu_ioctl_get_regs(vcpu, kvm_regs);</yellow>
		if (r)
			goto out_free1;
		r = -EFAULT;
<yellow>		if (copy_to_user(argp, kvm_regs, sizeof(struct kvm_regs)))</yellow>
			goto out_free1;
		r = 0;
out_free1:
<yellow>		kfree(kvm_regs);</yellow>
		break;
	}
	case KVM_SET_REGS: {
		struct kvm_regs *kvm_regs;

<yellow>		kvm_regs = memdup_user(argp, sizeof(*kvm_regs));</yellow>
		if (IS_ERR(kvm_regs)) {
			r = PTR_ERR(kvm_regs);
			goto out;
		}
<yellow>		r = kvm_arch_vcpu_ioctl_set_regs(vcpu, kvm_regs);</yellow>
		kfree(kvm_regs);
		break;
	}
	case KVM_GET_SREGS: {
<yellow>		kvm_sregs = kzalloc(sizeof(struct kvm_sregs),</yellow>
				    GFP_KERNEL_ACCOUNT);
		r = -ENOMEM;
		if (!kvm_sregs)
			goto out;
<yellow>		r = kvm_arch_vcpu_ioctl_get_sregs(vcpu, kvm_sregs);</yellow>
		if (r)
			goto out;
		r = -EFAULT;
<yellow>		if (copy_to_user(argp, kvm_sregs, sizeof(struct kvm_sregs)))</yellow>
			goto out;
		r = 0;
		break;
	}
	case KVM_SET_SREGS: {
<yellow>		kvm_sregs = memdup_user(argp, sizeof(*kvm_sregs));</yellow>
		if (IS_ERR(kvm_sregs)) {
			r = PTR_ERR(kvm_sregs);
			kvm_sregs = NULL;
			goto out;
		}
<yellow>		r = kvm_arch_vcpu_ioctl_set_sregs(vcpu, kvm_sregs);</yellow>
		break;
	}
	case KVM_GET_MP_STATE: {
		struct kvm_mp_state mp_state;

<yellow>		r = kvm_arch_vcpu_ioctl_get_mpstate(vcpu, &mp_state);</yellow>
		if (r)
			goto out;
		r = -EFAULT;
<yellow>		if (copy_to_user(argp, &mp_state, sizeof(mp_state)))</yellow>
			goto out;
		r = 0;
		break;
	}
	case KVM_SET_MP_STATE: {
		struct kvm_mp_state mp_state;

		r = -EFAULT;
<yellow>		if (copy_from_user(&mp_state, argp, sizeof(mp_state)))</yellow>
			goto out;
<yellow>		r = kvm_arch_vcpu_ioctl_set_mpstate(vcpu, &mp_state);</yellow>
		break;
	}
	case KVM_TRANSLATE: {
		struct kvm_translation tr;

		r = -EFAULT;
<yellow>		if (copy_from_user(&tr, argp, sizeof(tr)))</yellow>
			goto out;
<yellow>		r = kvm_arch_vcpu_ioctl_translate(vcpu, &tr);</yellow>
		if (r)
			goto out;
		r = -EFAULT;
<yellow>		if (copy_to_user(argp, &tr, sizeof(tr)))</yellow>
			goto out;
		r = 0;
<yellow>		break;</yellow>
	}
	case KVM_SET_GUEST_DEBUG: {
		struct kvm_guest_debug dbg;

		r = -EFAULT;
<yellow>		if (copy_from_user(&dbg, argp, sizeof(dbg)))</yellow>
<yellow>			goto out;</yellow>
<yellow>		r = kvm_arch_vcpu_ioctl_set_guest_debug(vcpu, &dbg);</yellow>
		break;
	}
	case KVM_SET_SIGNAL_MASK: {
		struct kvm_signal_mask __user *sigmask_arg = argp;
		struct kvm_signal_mask kvm_sigmask;
		sigset_t sigset, *p;

		p = NULL;
<yellow>		if (argp) {</yellow>
			r = -EFAULT;
<yellow>			if (copy_from_user(&kvm_sigmask, argp,</yellow>
					   sizeof(kvm_sigmask)))
				goto out;
			r = -EINVAL;
<yellow>			if (kvm_sigmask.len != sizeof(sigset))</yellow>
				goto out;
			r = -EFAULT;
<yellow>			if (copy_from_user(&sigset, sigmask_arg->sigset,</yellow>
					   sizeof(sigset)))
				goto out;
			p = &amp;sigset;
		}
<yellow>		r = kvm_vcpu_ioctl_set_sigmask(vcpu, p);</yellow>
<yellow>		break;</yellow>
	}
	case KVM_GET_FPU: {
<yellow>		fpu = kzalloc(sizeof(struct kvm_fpu), GFP_KERNEL_ACCOUNT);</yellow>
		r = -ENOMEM;
		if (!fpu)
			goto out;
<yellow>		r = kvm_arch_vcpu_ioctl_get_fpu(vcpu, fpu);</yellow>
		if (r)
			goto out;
		r = -EFAULT;
<yellow>		if (copy_to_user(argp, fpu, sizeof(struct kvm_fpu)))</yellow>
			goto out;
		r = 0;
		break;
	}
	case KVM_SET_FPU: {
<yellow>		fpu = memdup_user(argp, sizeof(*fpu));</yellow>
		if (IS_ERR(fpu)) {
			r = PTR_ERR(fpu);
			fpu = NULL;
			goto out;
		}
<yellow>		r = kvm_arch_vcpu_ioctl_set_fpu(vcpu, fpu);</yellow>
		break;
	}
	case KVM_GET_STATS_FD: {
<yellow>		r = kvm_vcpu_ioctl_get_stats_fd(vcpu);</yellow>
		break;
	}
	default:
<yellow>		r = kvm_arch_vcpu_ioctl(filp, ioctl, arg);</yellow>
	}
out:
<blue>	mutex_unlock(&vcpu->mutex);</blue>
	kfree(fpu);
	kfree(kvm_sregs);
<blue>	return r;</blue>
}

#ifdef CONFIG_KVM_COMPAT
static long kvm_vcpu_compat_ioctl(struct file *filp,
				  unsigned int ioctl, unsigned long arg)
<yellow>{</yellow>
<yellow>	struct kvm_vcpu *vcpu = filp->private_data;</yellow>
	void __user *argp = compat_ptr(arg);
	int r;

<yellow>	if (vcpu->kvm->mm != current->mm || vcpu->kvm->vm_dead)</yellow>
		return -EIO;

<yellow>	switch (ioctl) {</yellow>
	case KVM_SET_SIGNAL_MASK: {
		struct kvm_signal_mask __user *sigmask_arg = argp;
		struct kvm_signal_mask kvm_sigmask;
		sigset_t sigset;

		if (argp) {
			r = -EFAULT;
<yellow>			if (copy_from_user(&kvm_sigmask, argp,</yellow>
					   sizeof(kvm_sigmask)))
<yellow>				goto out;</yellow>
			r = -EINVAL;
<yellow>			if (kvm_sigmask.len != sizeof(compat_sigset_t))</yellow>
				goto out;
			r = -EFAULT;
			if (get_compat_sigset(&amp;sigset,
<yellow>					      (compat_sigset_t __user *)sigmask_arg->sigset))</yellow>
				goto out;
<yellow>			r = kvm_vcpu_ioctl_set_sigmask(vcpu, &sigset);</yellow>
		} else
<yellow>			r = kvm_vcpu_ioctl_set_sigmask(vcpu, NULL);</yellow>
<yellow>		break;</yellow>
	}
	default:
<yellow>		r = kvm_vcpu_ioctl(filp, ioctl, arg);</yellow>
	}

out:
	return r;
}
#endif

static int kvm_device_mmap(struct file *filp, struct vm_area_struct *vma)
{
<yellow>	struct kvm_device *dev = filp->private_data;</yellow>

<yellow>	if (dev->ops->mmap)</yellow>
<yellow>		return dev->ops->mmap(dev, vma);</yellow>

	return -ENODEV;
<yellow>}</yellow>

static int kvm_device_ioctl_attr(struct kvm_device *dev,
				 int (*accessor)(struct kvm_device *dev,
						 struct kvm_device_attr *attr),
				 unsigned long arg)
{
	struct kvm_device_attr attr;

	if (!accessor)
		return -EPERM;

<yellow>	if (copy_from_user(&attr, (void __user *)arg, sizeof(attr)))</yellow>
		return -EFAULT;

<yellow>	return accessor(dev, &attr);</yellow>
}

static long kvm_device_ioctl(struct file *filp, unsigned int ioctl,
			     unsigned long arg)
<yellow>{</yellow>
<yellow>	struct kvm_device *dev = filp->private_data;</yellow>

<yellow>	if (dev->kvm->mm != current->mm || dev->kvm->vm_dead)</yellow>
		return -EIO;

	switch (ioctl) {
	case KVM_SET_DEVICE_ATTR:
<yellow>		return kvm_device_ioctl_attr(dev, dev->ops->set_attr, arg);</yellow>
	case KVM_GET_DEVICE_ATTR:
<yellow>		return kvm_device_ioctl_attr(dev, dev->ops->get_attr, arg);</yellow>
	case KVM_HAS_DEVICE_ATTR:
<yellow>		return kvm_device_ioctl_attr(dev, dev->ops->has_attr, arg);</yellow>
	default:
<yellow>		if (dev->ops->ioctl)</yellow>
<yellow>			return dev->ops->ioctl(dev, ioctl, arg);</yellow>

		return -ENOTTY;
	}
}

static int kvm_device_release(struct inode *inode, struct file *filp)
{
<yellow>	struct kvm_device *dev = filp->private_data;</yellow>
	struct kvm *kvm = dev-&gt;kvm;

	if (dev-&gt;ops-&gt;release) {
<yellow>		mutex_lock(&kvm->lock);</yellow>
		list_del(&amp;dev-&gt;vm_node);
		dev-&gt;ops-&gt;release(dev);
		mutex_unlock(&amp;kvm-&gt;lock);
	}

<yellow>	kvm_put_kvm(kvm);</yellow>
	return 0;
}

static const struct file_operations kvm_device_fops = {
	.unlocked_ioctl = kvm_device_ioctl,
	.release = kvm_device_release,
	KVM_COMPAT(kvm_device_ioctl),
	.mmap = kvm_device_mmap,
};

struct kvm_device *kvm_device_from_filp(struct file *filp)
{
<yellow>	if (filp->f_op != &kvm_device_fops)</yellow>
		return NULL;

<yellow>	return filp->private_data;</yellow>
<yellow>}</yellow>

static const struct kvm_device_ops *kvm_device_ops_table[KVM_DEV_TYPE_MAX] = {
#ifdef CONFIG_KVM_MPIC
	[KVM_DEV_TYPE_FSL_MPIC_20]	= &amp;kvm_mpic_ops,
	[KVM_DEV_TYPE_FSL_MPIC_42]	= &amp;kvm_mpic_ops,
#endif
};

int kvm_register_device_ops(const struct kvm_device_ops *ops, u32 type)
{
<yellow>	if (type >= ARRAY_SIZE(kvm_device_ops_table))</yellow>
		return -ENOSPC;

<yellow>	if (kvm_device_ops_table[type] != NULL)</yellow>
		return -EEXIST;

<yellow>	kvm_device_ops_table[type] = ops;</yellow>
	return 0;
<yellow>}</yellow>

void kvm_unregister_device_ops(u32 type)
{
<yellow>	if (kvm_device_ops_table[type] != NULL)</yellow>
<yellow>		kvm_device_ops_table[type] = NULL;</yellow>
<yellow>}</yellow>

static int kvm_ioctl_create_device(struct kvm *kvm,
				   struct kvm_create_device *cd)
{
	const struct kvm_device_ops *ops;
	struct kvm_device *dev;
<yellow>	bool test = cd->flags & KVM_CREATE_DEVICE_TEST;</yellow>
	int type;
	int ret;

	if (cd-&gt;type &gt;= ARRAY_SIZE(kvm_device_ops_table))
		return -ENODEV;

<yellow>	type = array_index_nospec(cd->type, ARRAY_SIZE(kvm_device_ops_table));</yellow>
	ops = kvm_device_ops_table[type];
	if (ops == NULL)
		return -ENODEV;

<yellow>	if (test)</yellow>
		return 0;

<yellow>	dev = kzalloc(sizeof(*dev), GFP_KERNEL_ACCOUNT);</yellow>
	if (!dev)
		return -ENOMEM;

<yellow>	dev->ops = ops;</yellow>
	dev-&gt;kvm = kvm;

	mutex_lock(&amp;kvm-&gt;lock);
	ret = ops-&gt;create(dev, type);
	if (ret &lt; 0) {
<yellow>		mutex_unlock(&kvm->lock);</yellow>
		kfree(dev);
		return ret;
	}
<yellow>	list_add(&dev->vm_node, &kvm->devices);</yellow>
	mutex_unlock(&amp;kvm-&gt;lock);

	if (ops-&gt;init)
<yellow>		ops->init(dev);</yellow>

<yellow>	kvm_get_kvm(kvm);</yellow>
<yellow>	ret = anon_inode_getfd(ops->name, &kvm_device_fops, dev, O_RDWR | O_CLOEXEC);</yellow>
	if (ret &lt; 0) {
<yellow>		kvm_put_kvm_no_destroy(kvm);</yellow>
		mutex_lock(&amp;kvm-&gt;lock);
		list_del(&amp;dev-&gt;vm_node);
		if (ops-&gt;release)
<yellow>			ops->release(dev);</yellow>
<yellow>		mutex_unlock(&kvm->lock);</yellow>
		if (ops-&gt;destroy)
<yellow>			ops->destroy(dev);</yellow>
		return ret;
	}

<yellow>	cd->fd = ret;</yellow>
	return 0;
}

static long kvm_vm_ioctl_check_extension_generic(struct kvm *kvm, long arg)
{
<yellow>	switch (arg) {</yellow>
	case KVM_CAP_USER_MEMORY:
	case KVM_CAP_DESTROY_MEMORY_REGION_WORKS:
	case KVM_CAP_JOIN_MEMORY_REGIONS_WORKS:
	case KVM_CAP_INTERNAL_ERROR_DATA:
#ifdef CONFIG_HAVE_KVM_MSI
	case KVM_CAP_SIGNAL_MSI:
#endif
#ifdef CONFIG_HAVE_KVM_IRQFD
	case KVM_CAP_IRQFD:
	case KVM_CAP_IRQFD_RESAMPLE:
#endif
	case KVM_CAP_IOEVENTFD_ANY_LENGTH:
	case KVM_CAP_CHECK_EXTENSION_VM:
	case KVM_CAP_ENABLE_CAP_VM:
	case KVM_CAP_HALT_POLL:
		return 1;
#ifdef CONFIG_KVM_MMIO
	case KVM_CAP_COALESCED_MMIO:
		return KVM_COALESCED_MMIO_PAGE_OFFSET;
	case KVM_CAP_COALESCED_PIO:
		return 1;
#endif
#ifdef CONFIG_KVM_GENERIC_DIRTYLOG_READ_PROTECT
	case KVM_CAP_MANUAL_DIRTY_LOG_PROTECT2:
		return KVM_DIRTY_LOG_MANUAL_CAPS;
#endif
#ifdef CONFIG_HAVE_KVM_IRQ_ROUTING
	case KVM_CAP_IRQ_ROUTING:
		return KVM_MAX_IRQ_ROUTES;
#endif
#if KVM_ADDRESS_SPACE_NUM &gt; 1
	case KVM_CAP_MULTI_ADDRESS_SPACE:
		return KVM_ADDRESS_SPACE_NUM;
#endif
	case KVM_CAP_NR_MEMSLOTS:
<yellow>		return KVM_USER_MEM_SLOTS;</yellow>
	case KVM_CAP_DIRTY_LOG_RING:
#ifdef CONFIG_HAVE_KVM_DIRTY_RING_TSO
		return KVM_DIRTY_RING_MAX_ENTRIES * sizeof(struct kvm_dirty_gfn);
#else
		return 0;
#endif
	case KVM_CAP_DIRTY_LOG_RING_ACQ_REL:
#ifdef CONFIG_HAVE_KVM_DIRTY_RING_ACQ_REL
		return KVM_DIRTY_RING_MAX_ENTRIES * sizeof(struct kvm_dirty_gfn);
#else
		return 0;
#endif
	case KVM_CAP_BINARY_STATS_FD:
	case KVM_CAP_SYSTEM_EVENT_DATA:
		return 1;
	default:
		break;
	}
<yellow>	return kvm_vm_ioctl_check_extension(kvm, arg);</yellow>
<yellow>}</yellow>

static int kvm_vm_ioctl_enable_dirty_log_ring(struct kvm *kvm, u32 size)
{
	int r;

	if (!KVM_DIRTY_LOG_PAGE_OFFSET)
		return -EINVAL;

	/* the size should be power of 2 */
<yellow>	if (!size || (size & (size - 1)))</yellow>
		return -EINVAL;

	/* Should be bigger to keep the reserved entries, or a page */
<yellow>	if (size < kvm_dirty_ring_get_rsvd_entries() *</yellow>
<yellow>	    sizeof(struct kvm_dirty_gfn) || size < PAGE_SIZE)</yellow>
		return -EINVAL;

<yellow>	if (size > KVM_DIRTY_RING_MAX_ENTRIES *</yellow>
	    sizeof(struct kvm_dirty_gfn))
		return -E2BIG;

	/* We only allow it to set once */
<yellow>	if (kvm->dirty_ring_size)</yellow>
		return -EINVAL;

<yellow>	mutex_lock(&kvm->lock);</yellow>

	if (kvm-&gt;created_vcpus) {
		/* We don&#x27;t allow to change this value after vcpu created */
		r = -EINVAL;
	} else {
<yellow>		kvm->dirty_ring_size = size;</yellow>
		r = 0;
	}

<yellow>	mutex_unlock(&kvm->lock);</yellow>
	return r;
}

static int kvm_vm_ioctl_reset_dirty_pages(struct kvm *kvm)
{
	unsigned long i;
	struct kvm_vcpu *vcpu;
	int cleared = 0;

<yellow>	if (!kvm->dirty_ring_size)</yellow>
		return -EINVAL;

<yellow>	mutex_lock(&kvm->slots_lock);</yellow>

	kvm_for_each_vcpu(i, vcpu, kvm)
<yellow>		cleared += kvm_dirty_ring_reset(vcpu->kvm, &vcpu->dirty_ring);</yellow>

<yellow>	mutex_unlock(&kvm->slots_lock);</yellow>

	if (cleared)
<yellow>		kvm_flush_remote_tlbs(kvm);</yellow>

	return cleared;
}

int __attribute__((weak)) kvm_vm_ioctl_enable_cap(struct kvm *kvm,
						  struct kvm_enable_cap *cap)
{
	return -EINVAL;
<yellow>}</yellow>

static int kvm_vm_ioctl_enable_cap_generic(struct kvm *kvm,
					   struct kvm_enable_cap *cap)
{
<yellow>	switch (cap->cap) {</yellow>
#ifdef CONFIG_KVM_GENERIC_DIRTYLOG_READ_PROTECT
	case KVM_CAP_MANUAL_DIRTY_LOG_PROTECT2: {
		u64 allowed_options = KVM_DIRTY_LOG_MANUAL_PROTECT_ENABLE;

<yellow>		if (cap->args[0] & KVM_DIRTY_LOG_MANUAL_PROTECT_ENABLE)</yellow>
			allowed_options = KVM_DIRTY_LOG_MANUAL_CAPS;

<yellow>		if (cap->flags || (cap->args[0] & ~allowed_options))</yellow>
			return -EINVAL;
<yellow>		kvm->manual_dirty_log_protect = cap->args[0];</yellow>
		return 0;
	}
#endif
	case KVM_CAP_HALT_POLL: {
<yellow>		if (cap->flags || cap->args[0] != (unsigned int)cap->args[0])</yellow>
			return -EINVAL;

<yellow>		kvm->max_halt_poll_ns = cap->args[0];</yellow>

		/*
		 * Ensure kvm-&gt;override_halt_poll_ns does not become visible
		 * before kvm-&gt;max_halt_poll_ns.
		 *
		 * Pairs with the smp_rmb() in kvm_vcpu_max_halt_poll_ns().
		 */
		smp_wmb();
		kvm-&gt;override_halt_poll_ns = true;

		return 0;
	}
	case KVM_CAP_DIRTY_LOG_RING:
	case KVM_CAP_DIRTY_LOG_RING_ACQ_REL:
<yellow>		if (!kvm_vm_ioctl_check_extension_generic(kvm, cap->cap))</yellow>
			return -EINVAL;

<yellow>		return kvm_vm_ioctl_enable_dirty_log_ring(kvm, cap->args[0]);</yellow>
	default:
<yellow>		return kvm_vm_ioctl_enable_cap(kvm, cap);</yellow>
	}
}

static ssize_t kvm_vm_stats_read(struct file *file, char __user *user_buffer,
			      size_t size, loff_t *offset)
{
<yellow>	struct kvm *kvm = file->private_data;</yellow>

	return kvm_stats_read(kvm-&gt;stats_id, &amp;kvm_vm_stats_header,
				&amp;kvm_vm_stats_desc[0], &amp;kvm-&gt;stat,
				sizeof(kvm-&gt;stat), user_buffer, size, offset);
}

static const struct file_operations kvm_vm_stats_fops = {
	.read = kvm_vm_stats_read,
	.llseek = noop_llseek,
};

static int kvm_vm_ioctl_get_stats_fd(struct kvm *kvm)
{
	int fd;
	struct file *file;

<yellow>	fd = get_unused_fd_flags(O_CLOEXEC);</yellow>
	if (fd &lt; 0)
		return fd;

<yellow>	file = anon_inode_getfile("kvm-vm-stats",</yellow>
			&amp;kvm_vm_stats_fops, kvm, O_RDONLY);
	if (IS_ERR(file)) {
<yellow>		put_unused_fd(fd);</yellow>
		return PTR_ERR(file);
	}
<yellow>	file->f_mode |= FMODE_PREAD;</yellow>
	fd_install(fd, file);

	return fd;
}

static long kvm_vm_ioctl(struct file *filp,
			   unsigned int ioctl, unsigned long arg)
<blue>{</blue>
<blue>	struct kvm *kvm = filp->private_data;</blue>
	void __user *argp = (void __user *)arg;
	int r;

<blue>	if (kvm->mm != current->mm || kvm->vm_dead)</blue>
		return -EIO;
<blue>	switch (ioctl) {</blue>
	case KVM_CREATE_VCPU:
<blue>		r = kvm_vm_ioctl_create_vcpu(kvm, arg);</blue>
		break;
	case KVM_ENABLE_CAP: {
		struct kvm_enable_cap cap;

		r = -EFAULT;
<yellow>		if (copy_from_user(&cap, argp, sizeof(cap)))</yellow>
			goto out;
<yellow>		r = kvm_vm_ioctl_enable_cap_generic(kvm, &cap);</yellow>
		break;
	}
	case KVM_SET_USER_MEMORY_REGION: {
		struct kvm_userspace_memory_region kvm_userspace_mem;

		r = -EFAULT;
<yellow>		if (copy_from_user(&kvm_userspace_mem, argp,</yellow>
						sizeof(kvm_userspace_mem)))
			goto out;

<yellow>		r = kvm_vm_ioctl_set_memory_region(kvm, &kvm_userspace_mem);</yellow>
		break;
	}
	case KVM_GET_DIRTY_LOG: {
		struct kvm_dirty_log log;

		r = -EFAULT;
<yellow>		if (copy_from_user(&log, argp, sizeof(log)))</yellow>
			goto out;
<yellow>		r = kvm_vm_ioctl_get_dirty_log(kvm, &log);</yellow>
		break;
	}
#ifdef CONFIG_KVM_GENERIC_DIRTYLOG_READ_PROTECT
	case KVM_CLEAR_DIRTY_LOG: {
		struct kvm_clear_dirty_log log;

		r = -EFAULT;
<yellow>		if (copy_from_user(&log, argp, sizeof(log)))</yellow>
			goto out;
<yellow>		r = kvm_vm_ioctl_clear_dirty_log(kvm, &log);</yellow>
		break;
	}
#endif
#ifdef CONFIG_KVM_MMIO
	case KVM_REGISTER_COALESCED_MMIO: {
		struct kvm_coalesced_mmio_zone zone;

		r = -EFAULT;
<yellow>		if (copy_from_user(&zone, argp, sizeof(zone)))</yellow>
			goto out;
<yellow>		r = kvm_vm_ioctl_register_coalesced_mmio(kvm, &zone);</yellow>
		break;
	}
	case KVM_UNREGISTER_COALESCED_MMIO: {
		struct kvm_coalesced_mmio_zone zone;

		r = -EFAULT;
<yellow>		if (copy_from_user(&zone, argp, sizeof(zone)))</yellow>
			goto out;
<yellow>		r = kvm_vm_ioctl_unregister_coalesced_mmio(kvm, &zone);</yellow>
		break;
	}
#endif
	case KVM_IRQFD: {
		struct kvm_irqfd data;

		r = -EFAULT;
<yellow>		if (copy_from_user(&data, argp, sizeof(data)))</yellow>
			goto out;
<yellow>		r = kvm_irqfd(kvm, &data);</yellow>
		break;
	}
	case KVM_IOEVENTFD: {
		struct kvm_ioeventfd data;

		r = -EFAULT;
<yellow>		if (copy_from_user(&data, argp, sizeof(data)))</yellow>
			goto out;
<yellow>		r = kvm_ioeventfd(kvm, &data);</yellow>
		break;
	}
#ifdef CONFIG_HAVE_KVM_MSI
	case KVM_SIGNAL_MSI: {
		struct kvm_msi msi;

		r = -EFAULT;
<yellow>		if (copy_from_user(&msi, argp, sizeof(msi)))</yellow>
<yellow>			goto out;</yellow>
<yellow>		r = kvm_send_userspace_msi(kvm, &msi);</yellow>
		break;
	}
#endif
#ifdef __KVM_HAVE_IRQ_LINE
	case KVM_IRQ_LINE_STATUS:
	case KVM_IRQ_LINE: {
		struct kvm_irq_level irq_event;

		r = -EFAULT;
<yellow>		if (copy_from_user(&irq_event, argp, sizeof(irq_event)))</yellow>
			goto out;

<yellow>		r = kvm_vm_ioctl_irq_line(kvm, &irq_event,</yellow>
					ioctl == KVM_IRQ_LINE_STATUS);
		if (r)
			goto out;

		r = -EFAULT;
<yellow>		if (ioctl == KVM_IRQ_LINE_STATUS) {</yellow>
<yellow>			if (copy_to_user(argp, &irq_event, sizeof(irq_event)))</yellow>
				goto out;
		}

		r = 0;
		break;
	}
#endif
#ifdef CONFIG_HAVE_KVM_IRQ_ROUTING
	case KVM_SET_GSI_ROUTING: {
		struct kvm_irq_routing routing;
		struct kvm_irq_routing __user *urouting;
		struct kvm_irq_routing_entry *entries = NULL;

		r = -EFAULT;
<yellow>		if (copy_from_user(&routing, argp, sizeof(routing)))</yellow>
			goto out;
		r = -EINVAL;
<yellow>		if (!kvm_arch_can_set_irq_routing(kvm))</yellow>
			goto out;
<yellow>		if (routing.nr > KVM_MAX_IRQ_ROUTES)</yellow>
			goto out;
<yellow>		if (routing.flags)</yellow>
			goto out;
<yellow>		if (routing.nr) {</yellow>
			urouting = argp;
<yellow>			entries = vmemdup_user(urouting->entries,</yellow>
					       array_size(sizeof(*entries),
							  routing.nr));
			if (IS_ERR(entries)) {
				r = PTR_ERR(entries);
				goto out;
			}
		}
<yellow>		r = kvm_set_irq_routing(kvm, entries, routing.nr,</yellow>
					routing.flags);
		kvfree(entries);
		break;
	}
#endif /* CONFIG_HAVE_KVM_IRQ_ROUTING */
	case KVM_CREATE_DEVICE: {
		struct kvm_create_device cd;

		r = -EFAULT;
<yellow>		if (copy_from_user(&cd, argp, sizeof(cd)))</yellow>
			goto out;

<yellow>		r = kvm_ioctl_create_device(kvm, &cd);</yellow>
		if (r)
			goto out;

		r = -EFAULT;
<yellow>		if (copy_to_user(argp, &cd, sizeof(cd)))</yellow>
			goto out;

		r = 0;
<yellow>		break;</yellow>
	}
	case KVM_CHECK_EXTENSION:
<yellow>		r = kvm_vm_ioctl_check_extension_generic(kvm, arg);</yellow>
		break;
	case KVM_RESET_DIRTY_RINGS:
<yellow>		r = kvm_vm_ioctl_reset_dirty_pages(kvm);</yellow>
		break;
	case KVM_GET_STATS_FD:
<yellow>		r = kvm_vm_ioctl_get_stats_fd(kvm);</yellow>
		break;
	default:
<yellow>		r = kvm_arch_vm_ioctl(filp, ioctl, arg);</yellow>
	}
out:
<yellow>	return r;</yellow>
}

#ifdef CONFIG_KVM_COMPAT
struct compat_kvm_dirty_log {
	__u32 slot;
	__u32 padding1;
	union {
		compat_uptr_t dirty_bitmap; /* one bit per page */
		__u64 padding2;
	};
};

struct compat_kvm_clear_dirty_log {
	__u32 slot;
	__u32 num_pages;
	__u64 first_page;
	union {
		compat_uptr_t dirty_bitmap; /* one bit per page */
		__u64 padding2;
	};
};

long __weak kvm_arch_vm_compat_ioctl(struct file *filp, unsigned int ioctl,
				     unsigned long arg)
{
	return -ENOTTY;
<yellow>}</yellow>

static long kvm_vm_compat_ioctl(struct file *filp,
			   unsigned int ioctl, unsigned long arg)
<yellow>{</yellow>
<yellow>	struct kvm *kvm = filp->private_data;</yellow>
	int r;

<yellow>	if (kvm->mm != current->mm || kvm->vm_dead)</yellow>
		return -EIO;

<yellow>	r = kvm_arch_vm_compat_ioctl(filp, ioctl, arg);</yellow>
	if (r != -ENOTTY)
<yellow>		return r;</yellow>

<yellow>	switch (ioctl) {</yellow>
#ifdef CONFIG_KVM_GENERIC_DIRTYLOG_READ_PROTECT
	case KVM_CLEAR_DIRTY_LOG: {
		struct compat_kvm_clear_dirty_log compat_log;
		struct kvm_clear_dirty_log log;

<yellow>		if (copy_from_user(&compat_log, (void __user *)arg,</yellow>
				   sizeof(compat_log)))
			return -EFAULT;
		log.slot	 = compat_log.slot;
		log.num_pages	 = compat_log.num_pages;
<yellow>		log.first_page	 = compat_log.first_page;</yellow>
		log.padding2	 = compat_log.padding2;
		log.dirty_bitmap = compat_ptr(compat_log.dirty_bitmap);

		r = kvm_vm_ioctl_clear_dirty_log(kvm, &amp;log);
		break;
	}
#endif
	case KVM_GET_DIRTY_LOG: {
		struct compat_kvm_dirty_log compat_log;
		struct kvm_dirty_log log;

<yellow>		if (copy_from_user(&compat_log, (void __user *)arg,</yellow>
				   sizeof(compat_log)))
<yellow>			return -EFAULT;</yellow>
<yellow>		log.slot	 = compat_log.slot;</yellow>
		log.padding1	 = compat_log.padding1;
		log.padding2	 = compat_log.padding2;
		log.dirty_bitmap = compat_ptr(compat_log.dirty_bitmap);

		r = kvm_vm_ioctl_get_dirty_log(kvm, &amp;log);
		break;
	}
	default:
<yellow>		r = kvm_vm_ioctl(filp, ioctl, arg);</yellow>
	}
<yellow>	return r;</yellow>
}
#endif

static const struct file_operations kvm_vm_fops = {
	.release        = kvm_vm_release,
	.unlocked_ioctl = kvm_vm_ioctl,
	.llseek		= noop_llseek,
	KVM_COMPAT(kvm_vm_compat_ioctl),
};

bool file_is_kvm(struct file *file)
<yellow>{</yellow>
<yellow>	return file && file->f_op == &kvm_vm_fops;</yellow>
<yellow>}</yellow>
EXPORT_SYMBOL_GPL(file_is_kvm);

static int kvm_dev_ioctl_create_vm(unsigned long type)
{
	char fdname[ITOA_MAX_LEN + 1];
	int r, fd;
	struct kvm *kvm;
	struct file *file;

<yellow>	fd = get_unused_fd_flags(O_CLOEXEC);</yellow>
	if (fd &lt; 0)
		return fd;

<yellow>	snprintf(fdname, sizeof(fdname), "%d", fd);</yellow>

<yellow>	kvm = kvm_create_vm(type, fdname);</yellow>
<yellow>	if (IS_ERR(kvm)) {</yellow>
<yellow>		r = PTR_ERR(kvm);</yellow>
		goto put_fd;
	}

<yellow>	file = anon_inode_getfile("kvm-vm", &kvm_vm_fops, kvm, O_RDWR);</yellow>
	if (IS_ERR(file)) {
		r = PTR_ERR(file);
		goto put_kvm;
	}

	/*
	 * Don&#x27;t call kvm_put_kvm anymore at this point; file-&gt;f_op is
	 * already set, with -&gt;release() being kvm_vm_release().  In error
	 * cases it will be called by the final fput(file) and will take
	 * care of doing kvm_put_kvm(kvm).
	 */
<yellow>	kvm_uevent_notify_change(KVM_EVENT_CREATE_VM, kvm);</yellow>

<yellow>	fd_install(fd, file);</yellow>
	return fd;

put_kvm:
<yellow>	kvm_put_kvm(kvm);</yellow>
put_fd:
<yellow>	put_unused_fd(fd);</yellow>
	return r;
}

static long kvm_dev_ioctl(struct file *filp,
			  unsigned int ioctl, unsigned long arg)
<yellow>{</yellow>
	long r = -EINVAL;

<yellow>	switch (ioctl) {</yellow>
	case KVM_GET_API_VERSION:
<yellow>		if (arg)</yellow>
			goto out;
		r = KVM_API_VERSION;
		break;
	case KVM_CREATE_VM:
<yellow>		r = kvm_dev_ioctl_create_vm(arg);</yellow>
		break;
	case KVM_CHECK_EXTENSION:
<yellow>		r = kvm_vm_ioctl_check_extension_generic(NULL, arg);</yellow>
		break;
	case KVM_GET_VCPU_MMAP_SIZE:
<yellow>		if (arg)</yellow>
			goto out;
		r = PAGE_SIZE;     /* struct kvm_run */
#ifdef CONFIG_X86
		r += PAGE_SIZE;    /* pio data page */
#endif
#ifdef CONFIG_KVM_MMIO
		r += PAGE_SIZE;    /* coalesced mmio ring page */
#endif
		break;
	case KVM_TRACE_ENABLE:
	case KVM_TRACE_PAUSE:
	case KVM_TRACE_DISABLE:
		r = -EOPNOTSUPP;
		break;
	default:
<yellow>		return kvm_arch_dev_ioctl(filp, ioctl, arg);</yellow>
	}
out:
	return r;
}

static struct file_operations kvm_chardev_ops = {
	.unlocked_ioctl = kvm_dev_ioctl,
	.llseek		= noop_llseek,
	KVM_COMPAT(kvm_dev_ioctl),
};

static struct miscdevice kvm_dev = {
	KVM_MINOR,
	&quot;kvm&quot;,
	&amp;kvm_chardev_ops,
};

static void hardware_enable_nolock(void *junk)
{
<yellow>	int cpu = raw_smp_processor_id();</yellow>
	int r;

	if (cpumask_test_cpu(cpu, cpus_hardware_enabled))
		return;

<yellow>	cpumask_set_cpu(cpu, cpus_hardware_enabled);</yellow>

	r = kvm_arch_hardware_enable();

	if (r) {
<yellow>		cpumask_clear_cpu(cpu, cpus_hardware_enabled);</yellow>
		atomic_inc(&amp;hardware_enable_failed);
		pr_info(&quot;kvm: enabling virtualization on CPU%d failed\n&quot;, cpu);
	}
<yellow>}</yellow>

static int kvm_starting_cpu(unsigned int cpu)
{
<yellow>	raw_spin_lock(&kvm_count_lock);</yellow>
	if (kvm_usage_count)
<yellow>		hardware_enable_nolock(NULL);</yellow>
<yellow>	raw_spin_unlock(&kvm_count_lock);</yellow>
	return 0;
}

static void hardware_disable_nolock(void *junk)
{
<yellow>	int cpu = raw_smp_processor_id();</yellow>

	if (!cpumask_test_cpu(cpu, cpus_hardware_enabled))
		return;
<yellow>	cpumask_clear_cpu(cpu, cpus_hardware_enabled);</yellow>
	kvm_arch_hardware_disable();
<yellow>}</yellow>

static int kvm_dying_cpu(unsigned int cpu)
{
<yellow>	raw_spin_lock(&kvm_count_lock);</yellow>
	if (kvm_usage_count)
<yellow>		hardware_disable_nolock(NULL);</yellow>
<yellow>	raw_spin_unlock(&kvm_count_lock);</yellow>
	return 0;
}

<yellow>static void hardware_disable_all_nolock(void)</yellow>
{
<yellow>	BUG_ON(!kvm_usage_count);</yellow>

<yellow>	kvm_usage_count--;</yellow>
	if (!kvm_usage_count)
<yellow>		on_each_cpu(hardware_disable_nolock, NULL, 1);</yellow>
}

static void hardware_disable_all(void)
{
<yellow>	raw_spin_lock(&kvm_count_lock);</yellow>
<yellow>	hardware_disable_all_nolock();</yellow>
<yellow>	raw_spin_unlock(&kvm_count_lock);</yellow>
}

static int hardware_enable_all(void)
{
	int r = 0;

<yellow>	raw_spin_lock(&kvm_count_lock);</yellow>

	kvm_usage_count++;
	if (kvm_usage_count == 1) {
<yellow>		atomic_set(&hardware_enable_failed, 0);</yellow>
		on_each_cpu(hardware_enable_nolock, NULL, 1);

		if (atomic_read(&amp;hardware_enable_failed)) {
<yellow>			hardware_disable_all_nolock();</yellow>
			r = -EBUSY;
		}
	}

<yellow>	raw_spin_unlock(&kvm_count_lock);</yellow>

	return r;
}

static int kvm_reboot(struct notifier_block *notifier, unsigned long val,
		      void *v)
{
	/*
	 * Some (well, at least mine) BIOSes hang on reboot if
	 * in vmx root mode.
	 *
	 * And Intel TXT required VMX off for all cpu when system shutdown.
	 */
	pr_info(&quot;kvm: exiting hardware virtualization\n&quot;);
	kvm_rebooting = true;
	on_each_cpu(hardware_disable_nolock, NULL, 1);
	return NOTIFY_OK;
}

static struct notifier_block kvm_reboot_notifier = {
	.notifier_call = kvm_reboot,
	.priority = 0,
};

static void kvm_io_bus_destroy(struct kvm_io_bus *bus)
{
	int i;

<yellow>	for (i = 0; i < bus->dev_count; i++) {</yellow>
<yellow>		struct kvm_io_device *pos = bus->range[i].dev;</yellow>

<yellow>		kvm_iodevice_destructor(pos);</yellow>
	}
<yellow>	kfree(bus);</yellow>
}

static inline int kvm_io_bus_cmp(const struct kvm_io_range *r1,
				 const struct kvm_io_range *r2)
{
<blue>	gpa_t addr1 = r1->addr;</blue>
<blue>	gpa_t addr2 = r2->addr;</blue>

<yellow>	if (addr1 < addr2)</yellow>
		return -1;

	/* If r2-&gt;len == 0, match the exact address.  If r2-&gt;len != 0,
	 * accept any overlapping write.  Any order is acceptable for
	 * overlapping ranges, because kvm_io_bus_get_first_dev ensures
	 * we process all of them.
	 */
<blue>	if (r2->len) {</blue>
<blue>		addr1 += r1->len;</blue>
<blue>		addr2 += r2->len;</blue>
	}

<blue>	if (addr1 > addr2)</blue>
		return 1;

	return 0;
}

static int kvm_io_bus_sort_cmp(const void *p1, const void *p2)
<yellow>{</yellow>
<blue>	return kvm_io_bus_cmp(p1, p2);</blue>
<blue>}</blue>

static int kvm_io_bus_get_first_dev(struct kvm_io_bus *bus,
			     gpa_t addr, int len)
<blue>{</blue>
	struct kvm_io_range *range, key;
	int off;

	key = (struct kvm_io_range) {
		.addr = addr,
		.len = len,
	};

<blue>	range = bsearch(&key, bus->range, bus->dev_count,</blue>
			sizeof(struct kvm_io_range), kvm_io_bus_sort_cmp);
	if (range == NULL)
		return -ENOENT;

<blue>	off = range - bus->range;</blue>

<blue>	while (off > 0 && kvm_io_bus_cmp(&key, &bus->range[off-1]) == 0)</blue>
		off--;

	return off;
}

static int __kvm_io_bus_write(struct kvm_vcpu *vcpu, struct kvm_io_bus *bus,
			      struct kvm_io_range *range, const void *val)
{
	int idx;

<blue>	idx = kvm_io_bus_get_first_dev(bus, range->addr, range->len);</blue>
	if (idx &lt; 0)
		return -EOPNOTSUPP;

<blue>	while (idx < bus->dev_count &&</blue>
<blue>		kvm_io_bus_cmp(range, &bus->range[idx]) == 0) {</blue>
<blue>		if (!kvm_iodevice_write(vcpu, bus->range[idx].dev, range->addr,</blue>
					range-&gt;len, val))
			return idx;
<yellow>		idx++;</yellow>
	}

	return -EOPNOTSUPP;
<blue>}</blue>

/* kvm_io_bus_write - called under kvm-&gt;slots_lock */
int kvm_io_bus_write(struct kvm_vcpu *vcpu, enum kvm_bus bus_idx, gpa_t addr,
		     int len, const void *val)
<blue>{</blue>
	struct kvm_io_bus *bus;
	struct kvm_io_range range;
	int r;

<blue>	range = (struct kvm_io_range) {</blue>
		.addr = addr,
		.len = len,
	};

	bus = srcu_dereference(vcpu-&gt;kvm-&gt;buses[bus_idx], &amp;vcpu-&gt;kvm-&gt;srcu);
	if (!bus)
		return -ENOMEM;
<blue>	r = __kvm_io_bus_write(vcpu, bus, &range, val);</blue>
	return r &lt; 0 ? r : 0;
}
EXPORT_SYMBOL_GPL(kvm_io_bus_write);

/* kvm_io_bus_write_cookie - called under kvm-&gt;slots_lock */
int kvm_io_bus_write_cookie(struct kvm_vcpu *vcpu, enum kvm_bus bus_idx,
			    gpa_t addr, int len, const void *val, long cookie)
<yellow>{</yellow>
	struct kvm_io_bus *bus;
	struct kvm_io_range range;

<yellow>	range = (struct kvm_io_range) {</yellow>
		.addr = addr,
		.len = len,
	};

	bus = srcu_dereference(vcpu-&gt;kvm-&gt;buses[bus_idx], &amp;vcpu-&gt;kvm-&gt;srcu);
	if (!bus)
		return -ENOMEM;

	/* First try the device referenced by cookie. */
<yellow>	if ((cookie >= 0) && (cookie < bus->dev_count) &&</yellow>
<yellow>	    (kvm_io_bus_cmp(&range, &bus->range[cookie]) == 0))</yellow>
<yellow>		if (!kvm_iodevice_write(vcpu, bus->range[cookie].dev, addr, len,</yellow>
					val))
<yellow>			return cookie;</yellow>

	/*
	 * cookie contained garbage; fall back to search and return the
	 * correct cookie value.
	 */
<yellow>	return __kvm_io_bus_write(vcpu, bus, &range, val);</yellow>
}

static int __kvm_io_bus_read(struct kvm_vcpu *vcpu, struct kvm_io_bus *bus,
			     struct kvm_io_range *range, void *val)
{
	int idx;

<blue>	idx = kvm_io_bus_get_first_dev(bus, range->addr, range->len);</blue>
	if (idx &lt; 0)
		return -EOPNOTSUPP;

<blue>	while (idx < bus->dev_count &&</blue>
<blue>		kvm_io_bus_cmp(range, &bus->range[idx]) == 0) {</blue>
<blue>		if (!kvm_iodevice_read(vcpu, bus->range[idx].dev, range->addr,</blue>
				       range-&gt;len, val))
			return idx;
		idx++;
	}

	return -EOPNOTSUPP;
}

/* kvm_io_bus_read - called under kvm-&gt;slots_lock */
int kvm_io_bus_read(struct kvm_vcpu *vcpu, enum kvm_bus bus_idx, gpa_t addr,
		    int len, void *val)
{
	struct kvm_io_bus *bus;
	struct kvm_io_range range;
	int r;

	range = (struct kvm_io_range) {
		.addr = addr,
		.len = len,
	};

<blue>	bus = srcu_dereference(vcpu->kvm->buses[bus_idx], &vcpu->kvm->srcu);</blue>
	if (!bus)
		return -ENOMEM;
<blue>	r = __kvm_io_bus_read(vcpu, bus, &range, val);</blue>
<blue>	return r < 0 ? r : 0;</blue>
<blue>}</blue>

/* Caller must hold slots_lock. */
int kvm_io_bus_register_dev(struct kvm *kvm, enum kvm_bus bus_idx, gpa_t addr,
			    int len, struct kvm_io_device *dev)
{
	int i;
	struct kvm_io_bus *new_bus, *bus;
	struct kvm_io_range range;

<yellow>	bus = kvm_get_bus(kvm, bus_idx);</yellow>
	if (!bus)
		return -ENOMEM;

	/* exclude ioeventfd which is limited by maximum fd */
<yellow>	if (bus->dev_count - bus->ioeventfd_count > NR_IOBUS_DEVS - 1)</yellow>
		return -ENOSPC;

<yellow>	new_bus = kmalloc(struct_size(bus, range, bus->dev_count + 1),</yellow>
			  GFP_KERNEL_ACCOUNT);
	if (!new_bus)
		return -ENOMEM;

	range = (struct kvm_io_range) {
		.addr = addr,
		.len = len,
		.dev = dev,
	};

<yellow>	for (i = 0; i < bus->dev_count; i++)</yellow>
<yellow>		if (kvm_io_bus_cmp(&bus->range[i], &range) > 0)</yellow>
			break;

<yellow>	memcpy(new_bus, bus, sizeof(*bus) + i * sizeof(struct kvm_io_range));</yellow>
	new_bus-&gt;dev_count++;
	new_bus-&gt;range[i] = range;
	memcpy(new_bus-&gt;range + i + 1, bus-&gt;range + i,
		(bus-&gt;dev_count - i) * sizeof(struct kvm_io_range));
	rcu_assign_pointer(kvm-&gt;buses[bus_idx], new_bus);
	synchronize_srcu_expedited(&amp;kvm-&gt;srcu);
	kfree(bus);

	return 0;
<yellow>}</yellow>

int kvm_io_bus_unregister_dev(struct kvm *kvm, enum kvm_bus bus_idx,
			      struct kvm_io_device *dev)
{
	int i, j;
	struct kvm_io_bus *new_bus, *bus;

	lockdep_assert_held(&amp;kvm-&gt;slots_lock);

<yellow>	bus = kvm_get_bus(kvm, bus_idx);</yellow>
	if (!bus)
		return 0;

<yellow>	for (i = 0; i < bus->dev_count; i++) {</yellow>
<yellow>		if (bus->range[i].dev == dev) {</yellow>
			break;
		}
	}

<yellow>	if (i == bus->dev_count)</yellow>
		return 0;

<yellow>	new_bus = kmalloc(struct_size(bus, range, bus->dev_count - 1),</yellow>
			  GFP_KERNEL_ACCOUNT);
	if (new_bus) {
<yellow>		memcpy(new_bus, bus, struct_size(bus, range, i));</yellow>
		new_bus-&gt;dev_count--;
<yellow>		memcpy(new_bus->range + i, bus->range + i + 1,</yellow>
				flex_array_size(new_bus, range, new_bus-&gt;dev_count - i));
	}

	rcu_assign_pointer(kvm-&gt;buses[bus_idx], new_bus);
	synchronize_srcu_expedited(&amp;kvm-&gt;srcu);

	/* Destroy the old bus _after_ installing the (null) bus. */
	if (!new_bus) {
		pr_err(&quot;kvm: failed to shrink bus, removing it completely\n&quot;);
		for (j = 0; j &lt; bus-&gt;dev_count; j++) {
			if (j == i)
				continue;
			kvm_iodevice_destructor(bus-&gt;range[j].dev);
		}
	}

	kfree(bus);
	return new_bus ? 0 : -ENOMEM;
<yellow>}</yellow>

struct kvm_io_device *kvm_io_bus_get_dev(struct kvm *kvm, enum kvm_bus bus_idx,
					 gpa_t addr)
{
	struct kvm_io_bus *bus;
	int dev_idx, srcu_idx;
	struct kvm_io_device *iodev = NULL;

<yellow>	srcu_idx = srcu_read_lock(&kvm->srcu);</yellow>

	bus = srcu_dereference(kvm-&gt;buses[bus_idx], &amp;kvm-&gt;srcu);
	if (!bus)
		goto out_unlock;

<yellow>	dev_idx = kvm_io_bus_get_first_dev(bus, addr, 1);</yellow>
	if (dev_idx &lt; 0)
		goto out_unlock;

<yellow>	iodev = bus->range[dev_idx].dev;</yellow>

out_unlock:
<yellow>	srcu_read_unlock(&kvm->srcu, srcu_idx);</yellow>

	return iodev;
}
EXPORT_SYMBOL_GPL(kvm_io_bus_get_dev);

static int kvm_debugfs_open(struct inode *inode, struct file *file,
			   int (*get)(void *, u64 *), int (*set)(void *, u64),
			   const char *fmt)
{
	int ret;
<yellow>	struct kvm_stat_data *stat_data = (struct kvm_stat_data *)</yellow>
					  inode-&gt;i_private;

	/*
	 * The debugfs files are a reference to the kvm struct which
        * is still valid when kvm_destroy_vm is called.  kvm_get_kvm_safe
        * avoids the race between open and the removal of the debugfs directory.
	 */
<yellow>	if (!kvm_get_kvm_safe(stat_data->kvm))</yellow>
		return -ENOENT;

<yellow>	ret = simple_attr_open(inode, file, get,</yellow>
<yellow>			       kvm_stats_debugfs_mode(stat_data->desc) & 0222</yellow>
			       ? set : NULL, fmt);
	if (ret)
<yellow>		kvm_put_kvm(stat_data->kvm);</yellow>

	return ret;
}

static int kvm_debugfs_release(struct inode *inode, struct file *file)
{
<yellow>	struct kvm_stat_data *stat_data = (struct kvm_stat_data *)</yellow>
					  inode-&gt;i_private;

	simple_attr_release(inode, file);
	kvm_put_kvm(stat_data-&gt;kvm);

	return 0;
}

static int kvm_get_stat_per_vm(struct kvm *kvm, size_t offset, u64 *val)
{
<yellow>	*val = *(u64 *)((void *)(&kvm->stat) + offset);</yellow>

	return 0;
}

static int kvm_clear_stat_per_vm(struct kvm *kvm, size_t offset)
{
<yellow>	*(u64 *)((void *)(&kvm->stat) + offset) = 0;</yellow>

	return 0;
}

static int kvm_get_stat_per_vcpu(struct kvm *kvm, size_t offset, u64 *val)
<yellow>{</yellow>
	unsigned long i;
	struct kvm_vcpu *vcpu;

<yellow>	*val = 0;</yellow>

	kvm_for_each_vcpu(i, vcpu, kvm)
<yellow>		*val += *(u64 *)((void *)(&vcpu->stat) + offset);</yellow>

	return 0;
}

static int kvm_clear_stat_per_vcpu(struct kvm *kvm, size_t offset)
<yellow>{</yellow>
	unsigned long i;
	struct kvm_vcpu *vcpu;

<yellow>	kvm_for_each_vcpu(i, vcpu, kvm)</yellow>
<yellow>		*(u64 *)((void *)(&vcpu->stat) + offset) = 0;</yellow>

	return 0;
}

<yellow>static int kvm_stat_data_get(void *data, u64 *val)</yellow>
{
	int r = -EFAULT;
	struct kvm_stat_data *stat_data = (struct kvm_stat_data *)data;

<yellow>	switch (stat_data->kind) {</yellow>
	case KVM_STAT_VM:
		r = kvm_get_stat_per_vm(stat_data-&gt;kvm,
<yellow>					stat_data->desc->desc.offset, val);</yellow>
		break;
	case KVM_STAT_VCPU:
		r = kvm_get_stat_per_vcpu(stat_data-&gt;kvm,
<yellow>					  stat_data->desc->desc.offset, val);</yellow>
		break;
	}

	return r;
<yellow>}</yellow>

<yellow>static int kvm_stat_data_clear(void *data, u64 val)</yellow>
{
	int r = -EFAULT;
	struct kvm_stat_data *stat_data = (struct kvm_stat_data *)data;

<yellow>	if (val)</yellow>
		return -EINVAL;

<yellow>	switch (stat_data->kind) {</yellow>
	case KVM_STAT_VM:
		r = kvm_clear_stat_per_vm(stat_data-&gt;kvm,
<yellow>					  stat_data->desc->desc.offset);</yellow>
		break;
	case KVM_STAT_VCPU:
		r = kvm_clear_stat_per_vcpu(stat_data-&gt;kvm,
<yellow>					    stat_data->desc->desc.offset);</yellow>
		break;
	}

	return r;
<yellow>}</yellow>

static int kvm_stat_data_open(struct inode *inode, struct file *file)
<yellow>{</yellow>
	__simple_attr_check_format(&quot;%llu\n&quot;, 0ull);
<yellow>	return kvm_debugfs_open(inode, file, kvm_stat_data_get,</yellow>
				kvm_stat_data_clear, &quot;%llu\n&quot;);
}

static const struct file_operations stat_fops_per_vm = {
	.owner = THIS_MODULE,
	.open = kvm_stat_data_open,
	.release = kvm_debugfs_release,
	.read = simple_attr_read,
	.write = simple_attr_write,
	.llseek = no_llseek,
};

static int vm_stat_get(void *_offset, u64 *val)
{
	unsigned offset = (long)_offset;
	struct kvm *kvm;
	u64 tmp_val;

<yellow>	*val = 0;</yellow>
	mutex_lock(&amp;kvm_lock);
	list_for_each_entry(kvm, &amp;vm_list, vm_list) {
<yellow>		kvm_get_stat_per_vm(kvm, offset, &tmp_val);</yellow>
		*val += tmp_val;
	}
<yellow>	mutex_unlock(&kvm_lock);</yellow>
	return 0;
}

static int vm_stat_clear(void *_offset, u64 val)
{
	unsigned offset = (long)_offset;
	struct kvm *kvm;

<yellow>	if (val)</yellow>
		return -EINVAL;

<yellow>	mutex_lock(&kvm_lock);</yellow>
	list_for_each_entry(kvm, &amp;vm_list, vm_list) {
<yellow>		kvm_clear_stat_per_vm(kvm, offset);</yellow>
	}
<yellow>	mutex_unlock(&kvm_lock);</yellow>

	return 0;
<yellow>}</yellow>

<yellow>DEFINE_SIMPLE_ATTRIBUTE(vm_stat_fops, vm_stat_get, vm_stat_clear, "%llu\n");</yellow>
<yellow>DEFINE_SIMPLE_ATTRIBUTE(vm_stat_readonly_fops, vm_stat_get, NULL, "%llu\n");</yellow>

static int vcpu_stat_get(void *_offset, u64 *val)
{
	unsigned offset = (long)_offset;
	struct kvm *kvm;
	u64 tmp_val;

<yellow>	*val = 0;</yellow>
	mutex_lock(&amp;kvm_lock);
	list_for_each_entry(kvm, &amp;vm_list, vm_list) {
<yellow>		kvm_get_stat_per_vcpu(kvm, offset, &tmp_val);</yellow>
<yellow>		*val += tmp_val;</yellow>
	}
<yellow>	mutex_unlock(&kvm_lock);</yellow>
	return 0;
}

static int vcpu_stat_clear(void *_offset, u64 val)
{
	unsigned offset = (long)_offset;
	struct kvm *kvm;

<yellow>	if (val)</yellow>
		return -EINVAL;

<yellow>	mutex_lock(&kvm_lock);</yellow>
	list_for_each_entry(kvm, &amp;vm_list, vm_list) {
<yellow>		kvm_clear_stat_per_vcpu(kvm, offset);</yellow>
	}
<yellow>	mutex_unlock(&kvm_lock);</yellow>

	return 0;
<yellow>}</yellow>

<yellow>DEFINE_SIMPLE_ATTRIBUTE(vcpu_stat_fops, vcpu_stat_get, vcpu_stat_clear,</yellow>
			&quot;%llu\n&quot;);
<yellow>DEFINE_SIMPLE_ATTRIBUTE(vcpu_stat_readonly_fops, vcpu_stat_get, NULL, "%llu\n");</yellow>

static void kvm_uevent_notify_change(unsigned int type, struct kvm *kvm)
{
	struct kobj_uevent_env *env;
	unsigned long long created, active;

<yellow>	if (!kvm_dev.this_device || !kvm)</yellow>
		return;

<yellow>	mutex_lock(&kvm_lock);</yellow>
	if (type == KVM_EVENT_CREATE_VM) {
<yellow>		kvm_createvm_count++;</yellow>
		kvm_active_vms++;
	} else if (type == KVM_EVENT_DESTROY_VM) {
<yellow>		kvm_active_vms--;</yellow>
	}
	created = kvm_createvm_count;
	active = kvm_active_vms;
	mutex_unlock(&amp;kvm_lock);

	env = kzalloc(sizeof(*env), GFP_KERNEL_ACCOUNT);
	if (!env)
		return;

<yellow>	add_uevent_var(env, "CREATED=%llu", created);</yellow>
	add_uevent_var(env, &quot;COUNT=%llu&quot;, active);

	if (type == KVM_EVENT_CREATE_VM) {
		add_uevent_var(env, &quot;EVENT=create&quot;);
		kvm-&gt;userspace_pid = task_pid_nr(current);
	} else if (type == KVM_EVENT_DESTROY_VM) {
		add_uevent_var(env, &quot;EVENT=destroy&quot;);
	}
<yellow>	add_uevent_var(env, "PID=%d", kvm->userspace_pid);</yellow>

	if (!IS_ERR(kvm-&gt;debugfs_dentry)) {
<yellow>		char *tmp, *p = kmalloc(PATH_MAX, GFP_KERNEL_ACCOUNT);</yellow>

		if (p) {
<yellow>			tmp = dentry_path_raw(kvm->debugfs_dentry, p, PATH_MAX);</yellow>
			if (!IS_ERR(tmp))
<yellow>				add_uevent_var(env, "STATS_PATH=%s", tmp);</yellow>
<yellow>			kfree(p);</yellow>
		}
	}
	/* no need for checks, since we are adding at most only 5 keys */
<yellow>	env->envp[env->envp_idx++] = NULL;</yellow>
	kobject_uevent_env(&amp;kvm_dev.this_device-&gt;kobj, KOBJ_CHANGE, env-&gt;envp);
	kfree(env);
<yellow>}</yellow>

static void kvm_init_debug(void)
{
	const struct file_operations *fops;
	const struct _kvm_stats_desc *pdesc;
	int i;

	kvm_debugfs_dir = debugfs_create_dir(&quot;kvm&quot;, NULL);

	for (i = 0; i &lt; kvm_vm_stats_header.num_desc; ++i) {
		pdesc = &amp;kvm_vm_stats_desc[i];
<yellow>		if (kvm_stats_debugfs_mode(pdesc) & 0222)</yellow>
			fops = &amp;vm_stat_fops;
		else
			fops = &amp;vm_stat_readonly_fops;
<yellow>		debugfs_create_file(pdesc->name, kvm_stats_debugfs_mode(pdesc),</yellow>
				kvm_debugfs_dir,
<yellow>				(void *)(long)pdesc->desc.offset, fops);</yellow>
	}

<yellow>	for (i = 0; i < kvm_vcpu_stats_header.num_desc; ++i) {</yellow>
		pdesc = &amp;kvm_vcpu_stats_desc[i];
<yellow>		if (kvm_stats_debugfs_mode(pdesc) & 0222)</yellow>
			fops = &amp;vcpu_stat_fops;
		else
			fops = &amp;vcpu_stat_readonly_fops;
		debugfs_create_file(pdesc-&gt;name, kvm_stats_debugfs_mode(pdesc),
				kvm_debugfs_dir,
<yellow>				(void *)(long)pdesc->desc.offset, fops);</yellow>
	}
}

static int kvm_suspend(void)
{
<yellow>	if (kvm_usage_count)</yellow>
<yellow>		hardware_disable_nolock(NULL);</yellow>
	return 0;
<yellow>}</yellow>

static void kvm_resume(void)
{
<yellow>	if (kvm_usage_count) {</yellow>
		lockdep_assert_not_held(&amp;kvm_count_lock);
<yellow>		hardware_enable_nolock(NULL);</yellow>
	}
<yellow>}</yellow>

static struct syscore_ops kvm_syscore_ops = {
	.suspend = kvm_suspend,
	.resume = kvm_resume,
};

static inline
struct kvm_vcpu *preempt_notifier_to_vcpu(struct preempt_notifier *pn)
{
	return container_of(pn, struct kvm_vcpu, preempt_notifier);
}

static void kvm_sched_in(struct preempt_notifier *pn, int cpu)
{
	struct kvm_vcpu *vcpu = preempt_notifier_to_vcpu(pn);

<blue>	WRITE_ONCE(vcpu->preempted, false);</blue>
	WRITE_ONCE(vcpu-&gt;ready, false);

	__this_cpu_write(kvm_running_vcpu, vcpu);
	kvm_arch_sched_in(vcpu, cpu);
	kvm_arch_vcpu_load(vcpu, cpu);
}

static void kvm_sched_out(struct preempt_notifier *pn,
			  struct task_struct *next)
{
	struct kvm_vcpu *vcpu = preempt_notifier_to_vcpu(pn);

<yellow>	if (current->on_rq) {</yellow>
<yellow>		WRITE_ONCE(vcpu->preempted, true);</yellow>
		WRITE_ONCE(vcpu-&gt;ready, true);
	}
<yellow>	kvm_arch_vcpu_put(vcpu);</yellow>
	__this_cpu_write(kvm_running_vcpu, NULL);
}

/**
 * kvm_get_running_vcpu - get the vcpu running on the current CPU.
 *
 * We can disable preemption locally around accessing the per-CPU variable,
 * and use the resolved vcpu pointer after enabling preemption again,
 * because even if the current thread is migrated to another CPU, reading
 * the per-CPU value later will give us the same value as we update the
 * per-CPU variable in the preempt notifier handlers.
 */
struct kvm_vcpu *kvm_get_running_vcpu(void)
{
	struct kvm_vcpu *vcpu;

<blue>	preempt_disable();</blue>
	vcpu = __this_cpu_read(kvm_running_vcpu);
<blue>	preempt_enable();</blue>

	return vcpu;
<yellow>}</yellow>
EXPORT_SYMBOL_GPL(kvm_get_running_vcpu);

/**
 * kvm_get_running_vcpus - get the per-CPU array of currently running vcpus.
 */
struct kvm_vcpu * __percpu *kvm_get_running_vcpus(void)
{
        return &amp;kvm_running_vcpu;
<yellow>}</yellow>

#ifdef CONFIG_GUEST_PERF_EVENTS
static unsigned int kvm_guest_state(void)
{
<yellow>	struct kvm_vcpu *vcpu = kvm_get_running_vcpu();</yellow>
	unsigned int state;

<yellow>	if (!kvm_arch_pmi_in_guest(vcpu))</yellow>
<yellow>		return 0;</yellow>

	state = PERF_GUEST_ACTIVE;
<yellow>	if (!kvm_arch_vcpu_in_kernel(vcpu))</yellow>
<yellow>		state |= PERF_GUEST_USER;</yellow>

	return state;
}

static unsigned long kvm_guest_get_ip(void)
{
<yellow>	struct kvm_vcpu *vcpu = kvm_get_running_vcpu();</yellow>

	/* Retrieving the IP must be guarded by a call to kvm_guest_state(). */
<yellow>	if (WARN_ON_ONCE(!kvm_arch_pmi_in_guest(vcpu)))</yellow>
<yellow>		return 0;</yellow>

<yellow>	return kvm_arch_vcpu_get_ip(vcpu);</yellow>
<yellow>}</yellow>

static struct perf_guest_info_callbacks kvm_guest_cbs = {
	.state			= kvm_guest_state,
	.get_ip			= kvm_guest_get_ip,
	.handle_intel_pt_intr	= NULL,
};

void kvm_register_perf_callbacks(unsigned int (*pt_intr_handler)(void))
{
	kvm_guest_cbs.handle_intel_pt_intr = pt_intr_handler;
<yellow>	perf_register_guest_info_callbacks(&kvm_guest_cbs);</yellow>
}
void kvm_unregister_perf_callbacks(void)
{
<yellow>	perf_unregister_guest_info_callbacks(&kvm_guest_cbs);</yellow>
}
#endif

struct kvm_cpu_compat_check {
	void *opaque;
	int *ret;
};

static void check_processor_compat(void *data)
{
	struct kvm_cpu_compat_check *c = data;

<yellow>	*c->ret = kvm_arch_check_processor_compat(c->opaque);</yellow>
}

int kvm_init(void *opaque, unsigned vcpu_size, unsigned vcpu_align,
		  struct module *module)
<yellow>{</yellow>
	struct kvm_cpu_compat_check c;
	int r;
	int cpu;

<yellow>	r = kvm_arch_init(opaque);</yellow>
	if (r)
		goto out_fail;

	/*
	 * kvm_arch_init makes sure there&#x27;s at most one caller
	 * for architectures that support multiple implementations,
	 * like intel and amd on x86.
	 * kvm_arch_init must be called before kvm_irqfd_init to avoid creating
	 * conflicts in case kvm is already setup for another implementation.
	 */
<yellow>	r = kvm_irqfd_init();</yellow>
	if (r)
		goto out_irqfd;

<yellow>	if (!zalloc_cpumask_var(&cpus_hardware_enabled, GFP_KERNEL)) {</yellow>
<yellow>		r = -ENOMEM;</yellow>
		goto out_free_0;
	}

<yellow>	r = kvm_arch_hardware_setup(opaque);</yellow>
	if (r &lt; 0)
		goto out_free_1;

	c.ret = &amp;r;
<yellow>	c.opaque = opaque;</yellow>
<yellow>	for_each_online_cpu(cpu) {</yellow>
<yellow>		smp_call_function_single(cpu, check_processor_compat, &c, 1);</yellow>
		if (r &lt; 0)
			goto out_free_2;
	}

<yellow>	r = cpuhp_setup_state_nocalls(CPUHP_AP_KVM_STARTING, "kvm/cpu:starting",</yellow>
				      kvm_starting_cpu, kvm_dying_cpu);
	if (r)
		goto out_free_2;
<yellow>	register_reboot_notifier(&kvm_reboot_notifier);</yellow>

	/* A kmem cache lets us meet the alignment requirements of fx_save. */
	if (!vcpu_align)
		vcpu_align = __alignof__(struct kvm_vcpu);
	kvm_vcpu_cache =
<yellow>		kmem_cache_create_usercopy("kvm_vcpu", vcpu_size, vcpu_align,</yellow>
					   SLAB_ACCOUNT,
					   offsetof(struct kvm_vcpu, arch),
					   offsetofend(struct kvm_vcpu, stats_id)
					   - offsetof(struct kvm_vcpu, arch),
					   NULL);
	if (!kvm_vcpu_cache) {
<yellow>		r = -ENOMEM;</yellow>
		goto out_free_3;
	}

<yellow>	for_each_possible_cpu(cpu) {</yellow>
<yellow>		if (!alloc_cpumask_var_node(&per_cpu(cpu_kick_mask, cpu),</yellow>
					    GFP_KERNEL, cpu_to_node(cpu))) {
<yellow>			r = -ENOMEM;</yellow>
			goto out_free_4;
		}
	}

<yellow>	r = kvm_async_pf_init();</yellow>
	if (r)
		goto out_free_4;

<yellow>	kvm_chardev_ops.owner = module;</yellow>

	r = misc_register(&amp;kvm_dev);
	if (r) {
		pr_err(&quot;kvm: misc device register failed\n&quot;);
		goto out_unreg;
	}

<yellow>	register_syscore_ops(&kvm_syscore_ops);</yellow>

	kvm_preempt_ops.sched_in = kvm_sched_in;
	kvm_preempt_ops.sched_out = kvm_sched_out;

<yellow>	kvm_init_debug();</yellow>

<yellow>	r = kvm_vfio_ops_init();</yellow>
<yellow>	WARN_ON(r);</yellow>

	return 0;

out_unreg:
	kvm_async_pf_deinit();
out_free_4:
<yellow>	for_each_possible_cpu(cpu)</yellow>
<yellow>		free_cpumask_var(per_cpu(cpu_kick_mask, cpu));</yellow>
<yellow>	kmem_cache_destroy(kvm_vcpu_cache);</yellow>
out_free_3:
<yellow>	unregister_reboot_notifier(&kvm_reboot_notifier);</yellow>
	cpuhp_remove_state_nocalls(CPUHP_AP_KVM_STARTING);
out_free_2:
<yellow>	kvm_arch_hardware_unsetup();</yellow>
out_free_1:
<yellow>	free_cpumask_var(cpus_hardware_enabled);</yellow>
out_free_0:
<yellow>	kvm_irqfd_exit();</yellow>
out_irqfd:
<yellow>	kvm_arch_exit();</yellow>
out_fail:
	return r;
}
EXPORT_SYMBOL_GPL(kvm_init);

void kvm_exit(void)
{
	int cpu;

<yellow>	debugfs_remove_recursive(kvm_debugfs_dir);</yellow>
	misc_deregister(&amp;kvm_dev);
<yellow>	for_each_possible_cpu(cpu)</yellow>
<yellow>		free_cpumask_var(per_cpu(cpu_kick_mask, cpu));</yellow>
<yellow>	kmem_cache_destroy(kvm_vcpu_cache);</yellow>
	kvm_async_pf_deinit();
	unregister_syscore_ops(&amp;kvm_syscore_ops);
	unregister_reboot_notifier(&amp;kvm_reboot_notifier);
	cpuhp_remove_state_nocalls(CPUHP_AP_KVM_STARTING);
	on_each_cpu(hardware_disable_nolock, NULL, 1);
	kvm_arch_hardware_unsetup();
	kvm_arch_exit();
	kvm_irqfd_exit();
	free_cpumask_var(cpus_hardware_enabled);
	kvm_vfio_ops_exit();
}
EXPORT_SYMBOL_GPL(kvm_exit);

struct kvm_vm_worker_thread_context {
	struct kvm *kvm;
	struct task_struct *parent;
	struct completion init_done;
	kvm_vm_thread_fn_t thread_fn;
	uintptr_t data;
	int err;
};

static int kvm_vm_worker_thread(void *context)
{
	/*
	 * The init_context is allocated on the stack of the parent thread, so
	 * we have to locally copy anything that is needed beyond initialization
	 */
	struct kvm_vm_worker_thread_context *init_context = context;
	struct task_struct *parent;
<yellow>	struct kvm *kvm = init_context->kvm;</yellow>
	kvm_vm_thread_fn_t thread_fn = init_context-&gt;thread_fn;
	uintptr_t data = init_context-&gt;data;
	int err;

	err = kthread_park(current);
	/* kthread_park(current) is never supposed to return an error */
<yellow>	WARN_ON(err != 0);</yellow>
	if (err)
		goto init_complete;

<yellow>	err = cgroup_attach_task_all(init_context->parent, current);</yellow>
	if (err) {
		kvm_err(&quot;%s: cgroup_attach_task_all failed with err %d\n&quot;,
			__func__, err);
		goto init_complete;
	}

<yellow>	set_user_nice(current, task_nice(init_context->parent));</yellow>

init_complete:
<yellow>	init_context->err = err;</yellow>
	complete(&amp;init_context-&gt;init_done);
	init_context = NULL;

	if (err)
		goto out;

	/* Wait to be woken up by the spawner before proceeding. */
	kthread_parkme();

	if (!kthread_should_stop())
<yellow>		err = thread_fn(kvm, data);</yellow>

out:
	/*
	 * Move kthread back to its original cgroup to prevent it lingering in
	 * the cgroup of the VM process, after the latter finishes its
	 * execution.
	 *
	 * kthread_stop() waits on the &#x27;exited&#x27; completion condition which is
	 * set in exit_mm(), via mm_release(), in do_exit(). However, the
	 * kthread is removed from the cgroup in the cgroup_exit() which is
	 * called after the exit_mm(). This causes the kthread_stop() to return
	 * before the kthread actually quits the cgroup.
	 */
<yellow>	rcu_read_lock();</yellow>
	parent = rcu_dereference(current-&gt;real_parent);
<yellow>	get_task_struct(parent);</yellow>
	rcu_read_unlock();
	cgroup_attach_task_all(parent, current);
<yellow>	put_task_struct(parent);</yellow>

	return err;
<yellow>}</yellow>

int kvm_vm_create_worker_thread(struct kvm *kvm, kvm_vm_thread_fn_t thread_fn,
				uintptr_t data, const char *name,
				struct task_struct **thread_ptr)
<yellow>{</yellow>
<yellow>	struct kvm_vm_worker_thread_context init_context = {};</yellow>
	struct task_struct *thread;

	*thread_ptr = NULL;
	init_context.kvm = kvm;
	init_context.parent = current;
	init_context.thread_fn = thread_fn;
	init_context.data = data;
	init_completion(&amp;init_context.init_done);

<yellow>	thread = kthread_run(kvm_vm_worker_thread, &init_context,</yellow>
			     &quot;%s-%d&quot;, name, task_pid_nr(current));
	if (IS_ERR(thread))
<yellow>		return PTR_ERR(thread);</yellow>

	/* kthread_run is never supposed to return NULL */
<yellow>	WARN_ON(thread == NULL);</yellow>

<yellow>	wait_for_completion(&init_context.init_done);</yellow>

	if (!init_context.err)
<yellow>		*thread_ptr = thread;</yellow>

	return init_context.err;
}


</code></pre></td></tr></table>
</body>
</html>
