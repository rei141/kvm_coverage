<doctype html>
<html lang="ja">
<head>
<meta charset="utf-8">
<script src="https://cdn.rawgit.com/google/code-prettify/master/loader/run_prettify.js"></script>
<style>
    code{
        font-family:Monaco, Menlo, Consolas, 'Courier New', Courier, monospace, sans-serif;
        font-size: 14px;
        line-height: 18px;
        overflow: auto;
        resize: horizontal;
    }
    code_line{
        font-family: Monaco, Menlo, Consolas, 'Courier New', Courier, monospace, sans-serif;;
        font-size: 14px;
        line-height: 18px;
        overflow: auto;
        resize: horizontal;
        color:#303134;
    }
    blue{
        background-color:#BEEDE8;
    }
    yellow{
        background-color:#FFFF99;
    }
    red{
        background-color:#FF99AC;
    }
</style>

</head>
<body>
<table summary='blob content' class='blob' cellspacing="15">
<tr><td align="right"><pre><code_line>1.<br>2.<br>3.<br>4.<br>5.<br>6.<br>7.<br>8.<br>9.<br>10.<br>11.<br>12.<br>13.<br>14.<br>15.<br>16.<br>17.<br>18.<br>19.<br>20.<br>21.<br>22.<br>23.<br>24.<br>25.<br>26.<br>27.<br>28.<br>29.<br>30.<br>31.<br>32.<br>33.<br>34.<br>35.<br>36.<br>37.<br>38.<br>39.<br>40.<br>41.<br>42.<br>43.<br>44.<br>45.<br>46.<br>47.<br>48.<br>49.<br>50.<br>51.<br>52.<br>53.<br>54.<br>55.<br>56.<br>57.<br>58.<br>59.<br>60.<br>61.<br>62.<br>63.<br>64.<br>65.<br>66.<br>67.<br>68.<br>69.<br>70.<br>71.<br>72.<br>73.<br>74.<br>75.<br>76.<br>77.<br>78.<br>79.<br>80.<br>81.<br>82.<br>83.<br>84.<br>85.<br>86.<br>87.<br>88.<br>89.<br>90.<br>91.<br>92.<br>93.<br>94.<br>95.<br>96.<br>97.<br>98.<br>99.<br>100.<br>101.<br>102.<br>103.<br>104.<br>105.<br>106.<br>107.<br>108.<br>109.<br>110.<br>111.<br>112.<br>113.<br>114.<br>115.<br>116.<br>117.<br>118.<br>119.<br>120.<br>121.<br>122.<br>123.<br>124.<br>125.<br>126.<br>127.<br>128.<br>129.<br>130.<br>131.<br>132.<br>133.<br>134.<br>135.<br>136.<br>137.<br>138.<br>139.<br>140.<br>141.<br>142.<br>143.<br>144.<br>145.<br>146.<br>147.<br>148.<br>149.<br>150.<br>151.<br>152.<br>153.<br>154.<br>155.<br>156.<br>157.<br>158.<br>159.<br>160.<br>161.<br>162.<br>163.<br>164.<br>165.<br>166.<br>167.<br>168.<br>169.<br>170.<br>171.<br>172.<br>173.<br>174.<br>175.<br>176.<br>177.<br>178.<br>179.<br>180.<br>181.<br>182.<br>183.<br>184.<br>185.<br>186.<br>187.<br>188.<br>189.<br>190.<br>191.<br>192.<br>193.<br>194.<br>195.<br>196.<br>197.<br>198.<br>199.<br>200.<br>201.<br>202.<br>203.<br>204.<br>205.<br>206.<br>207.<br>208.<br>209.<br>210.<br>211.<br>212.<br>213.<br>214.<br>215.<br>216.<br>217.<br>218.<br>219.<br>220.<br>221.<br>222.<br>223.<br>224.<br>225.<br>226.<br>227.<br>228.<br>229.<br>230.<br>231.<br>232.<br>233.<br>234.<br>235.<br>236.<br>237.<br>238.<br>239.<br>240.<br>241.<br>242.<br>243.<br>244.<br>245.<br>246.<br>247.<br>248.<br>249.<br>250.<br>251.<br>252.<br>253.<br>254.<br>255.<br>256.<br>257.<br>258.<br>259.<br>260.<br>261.<br>262.<br>263.<br>264.<br>265.<br>266.<br>267.<br>268.<br>269.<br>270.<br>271.<br>272.<br>273.<br>274.<br>275.<br>276.<br>277.<br>278.<br>279.<br>280.<br>281.<br>282.<br>283.<br>284.<br>285.<br>286.<br>287.<br>288.<br>289.<br>290.<br>291.<br>292.<br>293.<br>294.<br>295.<br>296.<br>297.<br>298.<br>299.<br>300.<br>301.<br>302.<br>303.<br>304.<br>305.<br>306.<br>307.<br>308.<br>309.<br>310.<br>311.<br>312.<br>313.<br>314.<br>315.<br>316.<br>317.<br>318.<br>319.<br>320.<br>321.<br>322.<br>323.<br>324.<br>325.<br>326.<br>327.<br>328.<br>329.<br>330.<br>331.<br>332.<br>333.<br>334.<br>335.<br>336.<br>337.<br>338.<br>339.<br>340.<br>341.<br>342.<br>343.<br>344.<br>345.<br>346.<br>347.<br>348.<br>349.<br>350.<br>351.<br>352.<br>353.<br>354.<br>355.<br>356.<br>357.<br>358.<br>359.<br>360.<br>361.<br>362.<br>363.<br>364.<br>365.<br>366.<br>367.<br>368.<br>369.<br>370.<br>371.<br>372.<br>373.<br>374.<br>375.<br>376.<br>377.<br>378.<br>379.<br>380.<br>381.<br>382.<br>383.<br>384.<br>385.<br>386.<br>387.<br>388.<br>389.<br>390.<br>391.<br>392.<br>393.<br>394.<br>395.<br>396.<br>397.<br>398.<br>399.<br>400.<br>401.<br>402.<br>403.<br>404.<br>405.<br>406.<br>407.<br>408.<br>409.<br>410.<br>411.<br>412.<br>413.<br>414.<br>415.<br>416.<br>417.<br>418.<br>419.<br>420.<br>421.<br>422.<br>423.<br></code_line></pre></td>
<td class='lines'><pre><code class="prettyprint">// SPDX-License-Identifier: GPL-2.0-only
/*
 * Kernel-based Virtual Machine driver for Linux
 *
 * This module enables kernel and guest-mode vCPU access to guest physical
 * memory with suitable invalidation mechanisms.
 *
 * Copyright Â© 2021 Amazon.com, Inc. or its affiliates.
 *
 * Authors:
 *   David Woodhouse &lt;dwmw2@infradead.org&gt;
 */

#include &lt;linux/kvm_host.h&gt;
#include &lt;linux/kvm.h&gt;
#include &lt;linux/highmem.h&gt;
#include &lt;linux/module.h&gt;
#include &lt;linux/errno.h&gt;

#include &quot;kvm_mm.h&quot;

/*
 * MMU notifier &#x27;invalidate_range_start&#x27; hook.
 */
void gfn_to_pfn_cache_invalidate_start(struct kvm *kvm, unsigned long start,
				       unsigned long end, bool may_block)
<blue>{</blue>
	DECLARE_BITMAP(vcpu_bitmap, KVM_MAX_VCPUS);
	struct gfn_to_pfn_cache *gpc;
	bool evict_vcpus = false;

<blue>	spin_lock(&kvm->gpc_lock);</blue>
	list_for_each_entry(gpc, &amp;kvm-&gt;gpc_list, list) {
<yellow>		write_lock_irq(&gpc->lock);</yellow>

		/* Only a single page so no need to care about length */
<yellow>		if (gpc->valid && !is_error_noslot_pfn(gpc->pfn) &&</yellow>
<yellow>		    gpc->uhva >= start && gpc->uhva < end) {</yellow>
<yellow>			gpc->valid = false;</yellow>

			/*
			 * If a guest vCPU could be using the physical address,
			 * it needs to be forced out of guest mode.
			 */
			if (gpc-&gt;usage &amp; KVM_GUEST_USES_PFN) {
<yellow>				if (!evict_vcpus) {</yellow>
					evict_vcpus = true;
<yellow>					bitmap_zero(vcpu_bitmap, KVM_MAX_VCPUS);</yellow>
				}
<yellow>				__set_bit(gpc->vcpu->vcpu_idx, vcpu_bitmap);</yellow>
			}
		}
<yellow>		write_unlock_irq(&gpc->lock);</yellow>
	}
<blue>	spin_unlock(&kvm->gpc_lock);</blue>

	if (evict_vcpus) {
		/*
		 * KVM needs to ensure the vCPU is fully out of guest context
		 * before allowing the invalidation to continue.
		 */
		unsigned int req = KVM_REQ_OUTSIDE_GUEST_MODE;
		bool called;

		/*
		 * If the OOM reaper is active, then all vCPUs should have
		 * been stopped already, so perform the request without
		 * KVM_REQUEST_WAIT and be sad if any needed to be IPI&#x27;d.
		 */
<yellow>		if (!may_block)</yellow>
			req &amp;= ~KVM_REQUEST_WAIT;

<yellow>		called = kvm_make_vcpus_request_mask(kvm, req, vcpu_bitmap);</yellow>

<yellow>		WARN_ON_ONCE(called && !may_block);</yellow>
	}
}

bool kvm_gfn_to_pfn_cache_check(struct kvm *kvm, struct gfn_to_pfn_cache *gpc,
				gpa_t gpa, unsigned long len)
{
<yellow>	struct kvm_memslots *slots = kvm_memslots(kvm);</yellow>

<yellow>	if (!gpc->active)</yellow>
		return false;

<yellow>	if ((gpa & ~PAGE_MASK) + len > PAGE_SIZE)</yellow>
		return false;

<yellow>	if (gpc->gpa != gpa || gpc->generation != slots->generation ||</yellow>
<yellow>	    kvm_is_error_hva(gpc->uhva))</yellow>
		return false;

<yellow>	if (!gpc->valid)</yellow>
		return false;

	return true;
<yellow>}</yellow>
EXPORT_SYMBOL_GPL(kvm_gfn_to_pfn_cache_check);

<yellow>static void gpc_unmap_khva(struct kvm *kvm, kvm_pfn_t pfn, void *khva)</yellow>
{
	/* Unmap the old pfn/page if it was mapped before. */
<yellow>	if (!is_error_noslot_pfn(pfn) && khva) {</yellow>
<yellow>		if (pfn_valid(pfn))</yellow>
			kunmap(pfn_to_page(pfn));
#ifdef CONFIG_HAS_IOMEM
		else
<yellow>			memunmap(khva);</yellow>
#endif
	}
}

static inline bool mmu_notifier_retry_cache(struct kvm *kvm, unsigned long mmu_seq)
{
	/*
	 * mn_active_invalidate_count acts for all intents and purposes
	 * like mmu_invalidate_in_progress here; but the latter cannot
	 * be used here because the invalidation of caches in the
	 * mmu_notifier event occurs _before_ mmu_invalidate_in_progress
	 * is elevated.
	 *
	 * Note, it does not matter that mn_active_invalidate_count
	 * is not protected by gpc-&gt;lock.  It is guaranteed to
	 * be elevated before the mmu_notifier acquires gpc-&gt;lock, and
	 * isn&#x27;t dropped until after mmu_invalidate_seq is updated.
	 */
<yellow>	if (kvm->mn_active_invalidate_count)</yellow>
		return true;

	/*
	 * Ensure mn_active_invalidate_count is read before
	 * mmu_invalidate_seq.  This pairs with the smp_wmb() in
	 * mmu_notifier_invalidate_range_end() to guarantee either the
	 * old (non-zero) value of mn_active_invalidate_count or the
	 * new (incremented) value of mmu_invalidate_seq is observed.
	 */
	smp_rmb();
<yellow>	return kvm->mmu_invalidate_seq != mmu_seq;</yellow>
}

static kvm_pfn_t hva_to_pfn_retry(struct kvm *kvm, struct gfn_to_pfn_cache *gpc)
{
	/* Note, the new page offset may be different than the old! */
<yellow>	void *old_khva = gpc->khva - offset_in_page(gpc->khva);</yellow>
	kvm_pfn_t new_pfn = KVM_PFN_ERR_FAULT;
	void *new_khva = NULL;
	unsigned long mmu_seq;

	lockdep_assert_held(&amp;gpc-&gt;refresh_lock);

	lockdep_assert_held_write(&amp;gpc-&gt;lock);

	/*
	 * Invalidate the cache prior to dropping gpc-&gt;lock, the gpa=&gt;uhva
	 * assets have already been updated and so a concurrent check() from a
	 * different task may not fail the gpa/uhva/generation checks.
	 */
	gpc-&gt;valid = false;

	do {
<yellow>		mmu_seq = kvm->mmu_invalidate_seq;</yellow>
		smp_rmb();

		write_unlock_irq(&amp;gpc-&gt;lock);

		/*
		 * If the previous iteration &quot;failed&quot; due to an mmu_notifier
		 * event, release the pfn and unmap the kernel virtual address
		 * from the previous attempt.  Unmapping might sleep, so this
		 * needs to be done after dropping the lock.  Opportunistically
		 * check for resched while the lock isn&#x27;t held.
		 */
		if (new_pfn != KVM_PFN_ERR_FAULT) {
			/*
			 * Keep the mapping if the previous iteration reused
			 * the existing mapping and didn&#x27;t create a new one.
			 */
<yellow>			if (new_khva != old_khva)</yellow>
<yellow>				gpc_unmap_khva(kvm, new_pfn, new_khva);</yellow>

<yellow>			kvm_release_pfn_clean(new_pfn);</yellow>

			cond_resched();
		}

		/* We always request a writeable mapping */
<yellow>		new_pfn = hva_to_pfn(gpc->uhva, false, NULL, true, NULL);</yellow>
		if (is_error_noslot_pfn(new_pfn))
			goto out_error;

		/*
		 * Obtain a new kernel mapping if KVM itself will access the
		 * pfn.  Note, kmap() and memremap() can both sleep, so this
		 * too must be done outside of gpc-&gt;lock!
		 */
<yellow>		if (gpc->usage & KVM_HOST_USES_PFN) {</yellow>
<yellow>			if (new_pfn == gpc->pfn) {</yellow>
				new_khva = old_khva;
<yellow>			} else if (pfn_valid(new_pfn)) {</yellow>
<yellow>				new_khva = kmap(pfn_to_page(new_pfn));</yellow>
#ifdef CONFIG_HAS_IOMEM
			} else {
<yellow>				new_khva = memremap(pfn_to_hpa(new_pfn), PAGE_SIZE, MEMREMAP_WB);</yellow>
#endif
			}
<yellow>			if (!new_khva) {</yellow>
<yellow>				kvm_release_pfn_clean(new_pfn);</yellow>
				goto out_error;
			}
		}

<yellow>		write_lock_irq(&gpc->lock);</yellow>

		/*
		 * Other tasks must wait for _this_ refresh to complete before
		 * attempting to refresh.
		 */
<yellow>		WARN_ON_ONCE(gpc->valid);</yellow>
<yellow>	} while (mmu_notifier_retry_cache(kvm, mmu_seq));</yellow>

<yellow>	gpc->valid = true;</yellow>
	gpc-&gt;pfn = new_pfn;
	gpc-&gt;khva = new_khva + (gpc-&gt;gpa &amp; ~PAGE_MASK);

	/*
	 * Put the reference to the _new_ pfn.  The pfn is now tracked by the
	 * cache and can be safely migrated, swapped, etc... as the cache will
	 * invalidate any mappings in response to relevant mmu_notifier events.
	 */
	kvm_release_pfn_clean(new_pfn);

	return 0;

out_error:
<yellow>	write_lock_irq(&gpc->lock);</yellow>

	return -EFAULT;
}

int kvm_gfn_to_pfn_cache_refresh(struct kvm *kvm, struct gfn_to_pfn_cache *gpc,
				 gpa_t gpa, unsigned long len)
{
<yellow>	struct kvm_memslots *slots = kvm_memslots(kvm);</yellow>
	unsigned long page_offset = gpa &amp; ~PAGE_MASK;
	bool unmap_old = false;
	unsigned long old_uhva;
	kvm_pfn_t old_pfn;
	void *old_khva;
	int ret;

	/*
	 * If must fit within a single page. The &#x27;len&#x27; argument is
	 * only to enforce that.
	 */
	if (page_offset + len &gt; PAGE_SIZE)
		return -EINVAL;

	/*
	 * If another task is refreshing the cache, wait for it to complete.
	 * There is no guarantee that concurrent refreshes will see the same
	 * gpa, memslots generation, etc..., so they must be fully serialized.
	 */
<yellow>	mutex_lock(&gpc->refresh_lock);</yellow>

	write_lock_irq(&amp;gpc-&gt;lock);

<yellow>	if (!gpc->active) {</yellow>
		ret = -EINVAL;
		goto out_unlock;
	}

<yellow>	old_pfn = gpc->pfn;</yellow>
	old_khva = gpc-&gt;khva - offset_in_page(gpc-&gt;khva);
	old_uhva = gpc-&gt;uhva;

	/* If the userspace HVA is invalid, refresh that first */
<yellow>	if (gpc->gpa != gpa || gpc->generation != slots->generation ||</yellow>
<yellow>	    kvm_is_error_hva(gpc->uhva)) {</yellow>
		gfn_t gfn = gpa_to_gfn(gpa);

		gpc-&gt;gpa = gpa;
<yellow>		gpc->generation = slots->generation;</yellow>
<yellow>		gpc->memslot = __gfn_to_memslot(slots, gfn);</yellow>
		gpc-&gt;uhva = gfn_to_hva_memslot(gpc-&gt;memslot, gfn);

		if (kvm_is_error_hva(gpc-&gt;uhva)) {
			ret = -EFAULT;
			goto out;
		}
	}

	/*
	 * If the userspace HVA changed or the PFN was already invalid,
	 * drop the lock and do the HVA to PFN lookup again.
	 */
<yellow>	if (!gpc->valid || old_uhva != gpc->uhva) {</yellow>
<yellow>		ret = hva_to_pfn_retry(kvm, gpc);</yellow>
	} else {
		/*
		 * If the HVAâPFN mapping was already valid, don&#x27;t unmap it.
		 * But do update gpc-&gt;khva because the offset within the page
		 * may have changed.
		 */
<yellow>		gpc->khva = old_khva + page_offset;</yellow>
		old_pfn = KVM_PFN_ERR_FAULT;
		old_khva = NULL;
		ret = 0;
	}

 out:
	/*
	 * Invalidate the cache and purge the pfn/khva if the refresh failed.
	 * Some/all of the uhva, gpa, and memslot generation info may still be
	 * valid, leave it as is.
	 */
	if (ret) {
<yellow>		gpc->valid = false;</yellow>
		gpc-&gt;pfn = KVM_PFN_ERR_FAULT;
		gpc-&gt;khva = NULL;
	}

	/* Detect a pfn change before dropping the lock! */
	unmap_old = (old_pfn != gpc-&gt;pfn);

out_unlock:
<yellow>	write_unlock_irq(&gpc->lock);</yellow>

	mutex_unlock(&amp;gpc-&gt;refresh_lock);

	if (unmap_old)
<yellow>		gpc_unmap_khva(kvm, old_pfn, old_khva);</yellow>

	return ret;
<yellow>}</yellow>
EXPORT_SYMBOL_GPL(kvm_gfn_to_pfn_cache_refresh);

void kvm_gfn_to_pfn_cache_unmap(struct kvm *kvm, struct gfn_to_pfn_cache *gpc)
{
	void *old_khva;
	kvm_pfn_t old_pfn;

<yellow>	mutex_lock(&gpc->refresh_lock);</yellow>
	write_lock_irq(&amp;gpc-&gt;lock);

	gpc-&gt;valid = false;

	old_khva = gpc-&gt;khva - offset_in_page(gpc-&gt;khva);
	old_pfn = gpc-&gt;pfn;

	/*
	 * We can leave the GPA â uHVA map cache intact but the PFN
	 * lookup will need to be redone even for the same page.
	 */
	gpc-&gt;khva = NULL;
	gpc-&gt;pfn = KVM_PFN_ERR_FAULT;

	write_unlock_irq(&amp;gpc-&gt;lock);
	mutex_unlock(&amp;gpc-&gt;refresh_lock);

<yellow>	gpc_unmap_khva(kvm, old_pfn, old_khva);</yellow>
<yellow>}</yellow>
EXPORT_SYMBOL_GPL(kvm_gfn_to_pfn_cache_unmap);

void kvm_gpc_init(struct gfn_to_pfn_cache *gpc)
{
<blue>	rwlock_init(&gpc->lock);</blue>
	mutex_init(&amp;gpc-&gt;refresh_lock);
}
EXPORT_SYMBOL_GPL(kvm_gpc_init);

int kvm_gpc_activate(struct kvm *kvm, struct gfn_to_pfn_cache *gpc,
		     struct kvm_vcpu *vcpu, enum pfn_cache_usage usage,
		     gpa_t gpa, unsigned long len)
{
<yellow>	WARN_ON_ONCE(!usage || (usage & KVM_GUEST_AND_HOST_USE_PFN) != usage);</yellow>

<yellow>	if (!gpc->active) {</yellow>
<yellow>		gpc->khva = NULL;</yellow>
		gpc-&gt;pfn = KVM_PFN_ERR_FAULT;
		gpc-&gt;uhva = KVM_HVA_ERR_BAD;
		gpc-&gt;vcpu = vcpu;
		gpc-&gt;usage = usage;
		gpc-&gt;valid = false;

		spin_lock(&amp;kvm-&gt;gpc_lock);
		list_add(&amp;gpc-&gt;list, &amp;kvm-&gt;gpc_list);
		spin_unlock(&amp;kvm-&gt;gpc_lock);

		/*
		 * Activate the cache after adding it to the list, a concurrent
		 * refresh must not establish a mapping until the cache is
		 * reachable by mmu_notifier events.
		 */
		write_lock_irq(&amp;gpc-&gt;lock);
		gpc-&gt;active = true;
		write_unlock_irq(&amp;gpc-&gt;lock);
	}
<yellow>	return kvm_gfn_to_pfn_cache_refresh(kvm, gpc, gpa, len);</yellow>
}
EXPORT_SYMBOL_GPL(kvm_gpc_activate);

<yellow>void kvm_gpc_deactivate(struct kvm *kvm, struct gfn_to_pfn_cache *gpc)</yellow>
{
<blue>	if (gpc->active) {</blue>
		/*
		 * Deactivate the cache before removing it from the list, KVM
		 * must stall mmu_notifier events until all users go away, i.e.
		 * until gpc-&gt;lock is dropped and refresh is guaranteed to fail.
		 */
<yellow>		write_lock_irq(&gpc->lock);</yellow>
		gpc-&gt;active = false;
		write_unlock_irq(&amp;gpc-&gt;lock);

		spin_lock(&amp;kvm-&gt;gpc_lock);
		list_del(&amp;gpc-&gt;list);
		spin_unlock(&amp;kvm-&gt;gpc_lock);

		kvm_gfn_to_pfn_cache_unmap(kvm, gpc);
	}
<blue>}</blue>
EXPORT_SYMBOL_GPL(kvm_gpc_deactivate);


</code></pre></td></tr></table>
</body>
</html>
