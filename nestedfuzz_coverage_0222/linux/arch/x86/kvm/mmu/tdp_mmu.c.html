<doctype html>
<html lang="ja">
<head><title>tdp_mmu.c</title><meta charset="utf-8">
<script src="https://cdn.rawgit.com/google/code-prettify/master/loader/run_prettify.js"></script>
<style>
    code{
        font-family:Monaco, Menlo, Consolas, 'Courier New', Courier, monospace, sans-serif;
        font-size: 14px;
        line-height: 18px;
        overflow: auto;
        resize: horizontal;
    }
    code_line{
        font-family: Monaco, Menlo, Consolas, 'Courier New', Courier, monospace, sans-serif;;
        font-size: 14px;
        line-height: 18px;
        overflow: auto;
        resize: horizontal;
        color:#303134;
    }
    blue{
        background-color:#BEEDE8;
    }
    yellow{
        background-color:#FFFF99;
    }
    red{
        background-color:#FF99AC;
    }
      .split {
         height: 100%;
         position: fixed;
         z-index: 1;
         top: 0;
         overflow-x: hidden;
      }

      .tree {
         left: 0;
         width: 20%;
      }

      .right {
         border-left: 2px solid #444;
         right: 0;
         width: 80%;
         /* font-family: 'Courier New', Courier, monospace;
				color: rgb(80, 80, 80); */
      }
</style>

</head>
<body>
   <div class="split tree">
      <ul id="file_list">
      </ul>
   </div>
   <div class="split right">
<table summary='blob content' class='blob' cellspacing="15">
<tr><td align="right"><pre><code_line><script>for (let i = 1; i <= 1913; i++){
         document.write(i+".\n");
   }
         </script></code_line></pre></td>
<td class='lines'><pre><code class="prettyprint">// SPDX-License-Identifier: GPL-2.0

#include &quot;mmu.h&quot;
#include &quot;mmu_internal.h&quot;
#include &quot;mmutrace.h&quot;
#include &quot;tdp_iter.h&quot;
#include &quot;tdp_mmu.h&quot;
#include &quot;spte.h&quot;

#include &lt;asm/cmpxchg.h&gt;
#include &lt;trace/events/kvm.h&gt;

static bool __read_mostly tdp_mmu_enabled = true;
module_param_named(tdp_mmu, tdp_mmu_enabled, bool, 0644);

/* Initializes the TDP MMU for the VM, if enabled. */
int kvm_mmu_init_tdp_mmu(struct kvm *kvm)
{
	struct workqueue_struct *wq;

<yellow>	if (!tdp_enabled || !READ_ONCE(tdp_mmu_enabled))</yellow>
		return 0;

<yellow>	wq = alloc_workqueue("kvm", WQ_UNBOUND|WQ_MEM_RECLAIM|WQ_CPU_INTENSIVE, 0);</yellow>
	if (!wq)
		return -ENOMEM;

	/* This should not be changed for the lifetime of the VM. */
<yellow>	kvm->arch.tdp_mmu_enabled = true;</yellow>
	INIT_LIST_HEAD(&amp;kvm-&gt;arch.tdp_mmu_roots);
	spin_lock_init(&amp;kvm-&gt;arch.tdp_mmu_pages_lock);
	INIT_LIST_HEAD(&amp;kvm-&gt;arch.tdp_mmu_pages);
	kvm-&gt;arch.tdp_mmu_zap_wq = wq;
	return 1;
<yellow>}</yellow>

/* Arbitrarily returns true so that this may be used in if statements. */
static __always_inline bool kvm_lockdep_assert_mmu_lock_held(struct kvm *kvm,
							     bool shared)
{
	if (shared)
<yellow>		lockdep_assert_held_read(&kvm->mmu_lock);</yellow>
	else
<yellow>		lockdep_assert_held_write(&kvm->mmu_lock);</yellow>

	return true;
}

void kvm_mmu_uninit_tdp_mmu(struct kvm *kvm)
{
<yellow>	if (!kvm->arch.tdp_mmu_enabled)</yellow>
		return;

	/* Also waits for any queued work items.  */
<yellow>	destroy_workqueue(kvm->arch.tdp_mmu_zap_wq);</yellow>

<yellow>	WARN_ON(!list_empty(&kvm->arch.tdp_mmu_pages));</yellow>
<yellow>	WARN_ON(!list_empty(&kvm->arch.tdp_mmu_roots));</yellow>

	/*
	 * Ensure that all the outstanding RCU callbacks to free shadow pages
	 * can run before the VM is torn down.  Work items on tdp_mmu_zap_wq
	 * can call kvm_tdp_mmu_put_root and create new callbacks.
	 */
<yellow>	rcu_barrier();</yellow>
<yellow>}</yellow>

static void tdp_mmu_free_sp(struct kvm_mmu_page *sp)
{
<yellow>	free_page((unsigned long)sp->spt);</yellow>
	kmem_cache_free(mmu_page_header_cache, sp);
}

/*
 * This is called through call_rcu in order to free TDP page table memory
 * safely with respect to other kernel threads that may be operating on
 * the memory.
 * By only accessing TDP MMU page table memory in an RCU read critical
 * section, and freeing it after a grace period, lockless access to that
 * memory won&#x27;t use it after it is freed.
 */
static void tdp_mmu_free_sp_rcu_callback(struct rcu_head *head)
{
	struct kvm_mmu_page *sp = container_of(head, struct kvm_mmu_page,
					       rcu_head);

<yellow>	tdp_mmu_free_sp(sp);</yellow>
}

static void tdp_mmu_zap_root(struct kvm *kvm, struct kvm_mmu_page *root,
			     bool shared);

static void tdp_mmu_zap_root_work(struct work_struct *work)
{
	struct kvm_mmu_page *root = container_of(work, struct kvm_mmu_page,
						 tdp_mmu_async_work);
<yellow>	struct kvm *kvm = root->tdp_mmu_async_data;</yellow>

	read_lock(&amp;kvm-&gt;mmu_lock);

	/*
	 * A TLB flush is not necessary as KVM performs a local TLB flush when
	 * allocating a new root (see kvm_mmu_load()), and when migrating vCPU
	 * to a different pCPU.  Note, the local TLB flush on reuse also
	 * invalidates any paging-structure-cache entries, i.e. TLB entries for
	 * intermediate paging structures, that may be zapped, as such entries
	 * are associated with the ASID on both VMX and SVM.
	 */
	tdp_mmu_zap_root(kvm, root, true);

	/*
	 * Drop the refcount using kvm_tdp_mmu_put_root() to test its logic for
	 * avoiding an infinite loop.  By design, the root is reachable while
	 * it&#x27;s being asynchronously zapped, thus a different task can put its
	 * last reference, i.e. flowing through kvm_tdp_mmu_put_root() for an
	 * asynchronously zapped root is unavoidable.
	 */
	kvm_tdp_mmu_put_root(kvm, root, true);

	read_unlock(&amp;kvm-&gt;mmu_lock);
}

static void tdp_mmu_schedule_zap_root(struct kvm *kvm, struct kvm_mmu_page *root)
{
<blue>	root->tdp_mmu_async_data = kvm;</blue>
	INIT_WORK(&amp;root-&gt;tdp_mmu_async_work, tdp_mmu_zap_root_work);
	queue_work(kvm-&gt;arch.tdp_mmu_zap_wq, &amp;root-&gt;tdp_mmu_async_work);
}

static inline bool kvm_tdp_root_mark_invalid(struct kvm_mmu_page *page)
{
<yellow>	union kvm_mmu_page_role role = page->role;</yellow>
	role.invalid = true;

	/* No need to use cmpxchg, only the invalid bit can change.  */
	role.word = xchg(&amp;page-&gt;role.word, role.word);
	return role.invalid;
}

void kvm_tdp_mmu_put_root(struct kvm *kvm, struct kvm_mmu_page *root,
			  bool shared)
{
<yellow>	kvm_lockdep_assert_mmu_lock_held(kvm, shared);</yellow>

<yellow>	if (!refcount_dec_and_test(&root->tdp_mmu_root_count))</yellow>
		return;

<yellow>	WARN_ON(!root->tdp_mmu_page);</yellow>

	/*
	 * The root now has refcount=0.  It is valid, but readers already
	 * cannot acquire a reference to it because kvm_tdp_mmu_get_root()
	 * rejects it.  This remains true for the rest of the execution
	 * of this function, because readers visit valid roots only
	 * (except for tdp_mmu_zap_root_work(), which however
	 * does not acquire any reference itself).
	 *
	 * Even though there are flows that need to visit all roots for
	 * correctness, they all take mmu_lock for write, so they cannot yet
	 * run concurrently. The same is true after kvm_tdp_root_mark_invalid,
	 * since the root still has refcount=0.
	 *
	 * However, tdp_mmu_zap_root can yield, and writers do not expect to
	 * see refcount=0 (see for example kvm_tdp_mmu_invalidate_all_roots()).
	 * So the root temporarily gets an extra reference, going to refcount=1
	 * while staying invalid.  Readers still cannot acquire any reference;
	 * but writers are now allowed to run if tdp_mmu_zap_root yields and
	 * they might take an extra reference if they themselves yield.
	 * Therefore, when the reference is given back by the worker,
	 * there is no guarantee that the refcount is still 1.  If not, whoever
	 * puts the last reference will free the page, but they will not have to
	 * zap the root because a root cannot go from invalid to valid.
	 */
<yellow>	if (!kvm_tdp_root_mark_invalid(root)) {</yellow>
<yellow>		refcount_set(&root->tdp_mmu_root_count, 1);</yellow>

		/*
		 * Zapping the root in a worker is not just &quot;nice to have&quot;;
		 * it is required because kvm_tdp_mmu_invalidate_all_roots()
		 * skips already-invalid roots.  If kvm_tdp_mmu_put_root() did
		 * not add the root to the workqueue, kvm_tdp_mmu_zap_all_fast()
		 * might return with some roots not zapped yet.
		 */
		tdp_mmu_schedule_zap_root(kvm, root);
		return;
	}

<yellow>	spin_lock(&kvm->arch.tdp_mmu_pages_lock);</yellow>
<yellow>	list_del_rcu(&root->link);</yellow>
	spin_unlock(&amp;kvm-&gt;arch.tdp_mmu_pages_lock);
	call_rcu(&amp;root-&gt;rcu_head, tdp_mmu_free_sp_rcu_callback);
<yellow>}</yellow>

/*
 * Returns the next root after @prev_root (or the first root if @prev_root is
 * NULL).  A reference to the returned root is acquired, and the reference to
 * @prev_root is released (the caller obviously must hold a reference to
 * @prev_root if it&#x27;s non-NULL).
 *
 * If @only_valid is true, invalid roots are skipped.
 *
 * Returns NULL if the end of tdp_mmu_roots was reached.
 */
static struct kvm_mmu_page *tdp_mmu_next_root(struct kvm *kvm,
					      struct kvm_mmu_page *prev_root,
					      bool shared, bool only_valid)
<yellow>{</yellow>
	struct kvm_mmu_page *next_root;

<yellow>	rcu_read_lock();</yellow>

	if (prev_root)
<yellow>		next_root = list_next_or_null_rcu(&kvm->arch.tdp_mmu_roots,</yellow>
						  &amp;prev_root-&gt;link,
						  typeof(*prev_root), link);
	else
<yellow>		next_root = list_first_or_null_rcu(&kvm->arch.tdp_mmu_roots,</yellow>
						   typeof(*next_root), link);

<yellow>	while (next_root) {</yellow>
<yellow>		if ((!only_valid || !next_root->role.invalid) &&</yellow>
<yellow>		    kvm_tdp_mmu_get_root(next_root))</yellow>
			break;

<yellow>		next_root = list_next_or_null_rcu(&kvm->arch.tdp_mmu_roots,</yellow>
				&amp;next_root-&gt;link, typeof(*next_root), link);
	}

<yellow>	rcu_read_unlock();</yellow>

	if (prev_root)
<yellow>		kvm_tdp_mmu_put_root(kvm, prev_root, shared);</yellow>

	return next_root;
}

/*
 * Note: this iterator gets and puts references to the roots it iterates over.
 * This makes it safe to release the MMU lock and yield within the loop, but
 * if exiting the loop early, the caller must drop the reference to the most
 * recent root. (Unless keeping a live reference is desirable.)
 *
 * If shared is set, this function is operating under the MMU lock in read
 * mode. In the unlikely event that this thread must free a root, the lock
 * will be temporarily dropped and reacquired in write mode.
 */
#define __for_each_tdp_mmu_root_yield_safe(_kvm, _root, _as_id, _shared, _only_valid)\
	for (_root = tdp_mmu_next_root(_kvm, NULL, _shared, _only_valid);	\
	     _root;								\
	     _root = tdp_mmu_next_root(_kvm, _root, _shared, _only_valid))	\
		if (kvm_lockdep_assert_mmu_lock_held(_kvm, _shared) &amp;&amp;		\
		    kvm_mmu_page_as_id(_root) != _as_id) {			\
		} else

#define for_each_valid_tdp_mmu_root_yield_safe(_kvm, _root, _as_id, _shared)	\
	__for_each_tdp_mmu_root_yield_safe(_kvm, _root, _as_id, _shared, true)

#define for_each_tdp_mmu_root_yield_safe(_kvm, _root, _as_id)			\
	__for_each_tdp_mmu_root_yield_safe(_kvm, _root, _as_id, false, false)

/*
 * Iterate over all TDP MMU roots.  Requires that mmu_lock be held for write,
 * the implication being that any flow that holds mmu_lock for read is
 * inherently yield-friendly and should use the yield-safe variant above.
 * Holding mmu_lock for write obviates the need for RCU protection as the list
 * is guaranteed to be stable.
 */
#define for_each_tdp_mmu_root(_kvm, _root, _as_id)			\
	list_for_each_entry(_root, &amp;_kvm-&gt;arch.tdp_mmu_roots, link)	\
		if (kvm_lockdep_assert_mmu_lock_held(_kvm, false) &amp;&amp;	\
		    kvm_mmu_page_as_id(_root) != _as_id) {		\
		} else

static struct kvm_mmu_page *tdp_mmu_alloc_sp(struct kvm_vcpu *vcpu)
{
	struct kvm_mmu_page *sp;

<yellow>	sp = kvm_mmu_memory_cache_alloc(&vcpu->arch.mmu_page_header_cache);</yellow>
	sp-&gt;spt = kvm_mmu_memory_cache_alloc(&amp;vcpu-&gt;arch.mmu_shadow_page_cache);

	return sp;
}

static void tdp_mmu_init_sp(struct kvm_mmu_page *sp, tdp_ptep_t sptep,
			    gfn_t gfn, union kvm_mmu_page_role role)
{
	set_page_private(virt_to_page(sp-&gt;spt), (unsigned long)sp);

	sp-&gt;role = role;
	sp-&gt;gfn = gfn;
	sp-&gt;ptep = sptep;
	sp-&gt;tdp_mmu_page = true;

<blue>	trace_kvm_mmu_get_page(sp, true);</blue>
}

static void tdp_mmu_init_child_sp(struct kvm_mmu_page *child_sp,
				  struct tdp_iter *iter)
{
	struct kvm_mmu_page *parent_sp;
	union kvm_mmu_page_role role;

<blue>	parent_sp = sptep_to_sp(rcu_dereference(iter->sptep));</blue>

	role = parent_sp-&gt;role;
	role.level--;

<blue>	tdp_mmu_init_sp(child_sp, iter->sptep, iter->gfn, role);</blue>
<blue>}</blue>

hpa_t kvm_tdp_mmu_get_vcpu_root_hpa(struct kvm_vcpu *vcpu)
{
<yellow>	union kvm_mmu_page_role role = vcpu->arch.mmu->root_role;</yellow>
	struct kvm *kvm = vcpu-&gt;kvm;
	struct kvm_mmu_page *root;

<yellow>	lockdep_assert_held_write(&kvm->mmu_lock);</yellow>

	/*
	 * Check for an existing root before allocating a new one.  Note, the
	 * role check prevents consuming an invalid root.
	 */
<yellow>	for_each_tdp_mmu_root(kvm, root, kvm_mmu_role_as_id(role)) {</yellow>
<yellow>		if (root->role.word == role.word &&</yellow>
<yellow>		    kvm_tdp_mmu_get_root(root))</yellow>
			goto out;
	}

<yellow>	root = tdp_mmu_alloc_sp(vcpu);</yellow>
<yellow>	tdp_mmu_init_sp(root, NULL, 0, role);</yellow>

<yellow>	refcount_set(&root->tdp_mmu_root_count, 1);</yellow>

	spin_lock(&amp;kvm-&gt;arch.tdp_mmu_pages_lock);
<yellow>	list_add_rcu(&root->link, &kvm->arch.tdp_mmu_roots);</yellow>
<yellow>	spin_unlock(&kvm->arch.tdp_mmu_pages_lock);</yellow>

out:
<yellow>	return __pa(root->spt);</yellow>
}

static void handle_changed_spte(struct kvm *kvm, int as_id, gfn_t gfn,
				u64 old_spte, u64 new_spte, int level,
				bool shared);

<blue>static void handle_changed_spte_acc_track(u64 old_spte, u64 new_spte, int level)</blue>
{
<blue>	if (!is_shadow_present_pte(old_spte) || !is_last_spte(old_spte, level))</blue>
		return;

<blue>	if (is_accessed_spte(old_spte) &&</blue>
<blue>	    (!is_shadow_present_pte(new_spte) || !is_accessed_spte(new_spte) ||</blue>
<blue>	     spte_to_pfn(old_spte) != spte_to_pfn(new_spte)))</blue>
<blue>		kvm_set_pfn_accessed(spte_to_pfn(old_spte));</blue>
<blue>}</blue>

<yellow>static void handle_changed_spte_dirty_log(struct kvm *kvm, int as_id, gfn_t gfn,</yellow>
					  u64 old_spte, u64 new_spte, int level)
{
	bool pfn_changed;
	struct kvm_memory_slot *slot;

<yellow>	if (level > PG_LEVEL_4K)</yellow>
		return;

<yellow>	pfn_changed = spte_to_pfn(old_spte) != spte_to_pfn(new_spte);</yellow>

	if ((!is_writable_pte(old_spte) || pfn_changed) &amp;&amp;
<yellow>	    is_writable_pte(new_spte)) {</yellow>
<yellow>		slot = __gfn_to_memslot(__kvm_memslots(kvm, as_id), gfn);</yellow>
<yellow>		mark_page_dirty_in_slot(kvm, slot, gfn);</yellow>
	}
}

static void tdp_account_mmu_page(struct kvm *kvm, struct kvm_mmu_page *sp)
{
	kvm_account_pgtable_pages((void *)sp-&gt;spt, +1);
}

static void tdp_unaccount_mmu_page(struct kvm *kvm, struct kvm_mmu_page *sp)
{
<yellow>	kvm_account_pgtable_pages((void *)sp->spt, -1);</yellow>
}

/**
 * tdp_mmu_unlink_sp() - Remove a shadow page from the list of used pages
 *
 * @kvm: kvm instance
 * @sp: the page to be removed
 * @shared: This operation may not be running under the exclusive use of
 *	    the MMU lock and the operation must synchronize with other
 *	    threads that might be adding or removing pages.
 */
static void tdp_mmu_unlink_sp(struct kvm *kvm, struct kvm_mmu_page *sp,
			      bool shared)
{
<yellow>	tdp_unaccount_mmu_page(kvm, sp);</yellow>
	if (shared)
<yellow>		spin_lock(&kvm->arch.tdp_mmu_pages_lock);</yellow>
	else
<yellow>		lockdep_assert_held_write(&kvm->mmu_lock);</yellow>

<yellow>	list_del(&sp->link);</yellow>
<yellow>	if (sp->lpage_disallowed)</yellow>
<yellow>		unaccount_huge_nx_page(kvm, sp);</yellow>

<yellow>	if (shared)</yellow>
<yellow>		spin_unlock(&kvm->arch.tdp_mmu_pages_lock);</yellow>
}

/**
 * handle_removed_pt() - handle a page table removed from the TDP structure
 *
 * @kvm: kvm instance
 * @pt: the page removed from the paging structure
 * @shared: This operation may not be running under the exclusive use
 *	    of the MMU lock and the operation must synchronize with other
 *	    threads that might be modifying SPTEs.
 *
 * Given a page table that has been removed from the TDP paging structure,
 * iterates through the page table to clear SPTEs and free child page tables.
 *
 * Note that pt is passed in as a tdp_ptep_t, but it does not need RCU
 * protection. Since this thread removed it from the paging structure,
 * this thread will be responsible for ensuring the page is freed. Hence the
 * early rcu_dereferences in the function.
 */
static void handle_removed_pt(struct kvm *kvm, tdp_ptep_t pt, bool shared)
{
<yellow>	struct kvm_mmu_page *sp = sptep_to_sp(rcu_dereference(pt));</yellow>
	int level = sp-&gt;role.level;
	gfn_t base_gfn = sp-&gt;gfn;
	int i;

<yellow>	trace_kvm_mmu_prepare_zap_page(sp);</yellow>

<yellow>	tdp_mmu_unlink_sp(kvm, sp, shared);</yellow>

<yellow>	for (i = 0; i < SPTE_ENT_PER_PAGE; i++) {</yellow>
<yellow>		tdp_ptep_t sptep = pt + i;</yellow>
<yellow>		gfn_t gfn = base_gfn + i * KVM_PAGES_PER_HPAGE(level);</yellow>
		u64 old_spte;

<yellow>		if (shared) {</yellow>
			/*
			 * Set the SPTE to a nonpresent value that other
			 * threads will not overwrite. If the SPTE was
			 * already marked as removed then another thread
			 * handling a page fault could overwrite it, so
			 * set the SPTE until it is set from some other
			 * value to the removed SPTE value.
			 */
			for (;;) {
<yellow>				old_spte = kvm_tdp_mmu_write_spte_atomic(sptep, REMOVED_SPTE);</yellow>
				if (!is_removed_spte(old_spte))
					break;
<yellow>				cpu_relax();</yellow>
			}
		} else {
			/*
			 * If the SPTE is not MMU-present, there is no backing
			 * page associated with the SPTE and so no side effects
			 * that need to be recorded, and exclusive ownership of
			 * mmu_lock ensures the SPTE can&#x27;t be made present.
			 * Note, zapping MMIO SPTEs is also unnecessary as they
			 * are guarded by the memslots generation, not by being
			 * unreachable.
			 */
<yellow>			old_spte = kvm_tdp_mmu_read_spte(sptep);</yellow>
			if (!is_shadow_present_pte(old_spte))
				continue;

			/*
			 * Use the common helper instead of a raw WRITE_ONCE as
			 * the SPTE needs to be updated atomically if it can be
			 * modified by a different vCPU outside of mmu_lock.
			 * Even though the parent SPTE is !PRESENT, the TLB
			 * hasn&#x27;t yet been flushed, and both Intel and AMD
			 * document that A/D assists can use upper-level PxE
			 * entries that are cached in the TLB, i.e. the CPU can
			 * still access the page and mark it dirty.
			 *
			 * No retry is needed in the atomic update path as the
			 * sole concern is dropping a Dirty bit, i.e. no other
			 * task can zap/remove the SPTE as mmu_lock is held for
			 * write.  Marking the SPTE as a removed SPTE is not
			 * strictly necessary for the same reason, but using
			 * the remove SPTE value keeps the shared/exclusive
			 * paths consistent and allows the handle_changed_spte()
			 * call below to hardcode the new value to REMOVED_SPTE.
			 *
			 * Note, even though dropping a Dirty bit is the only
			 * scenario where a non-atomic update could result in a
			 * functional bug, simply checking the Dirty bit isn&#x27;t
			 * sufficient as a fast page fault could read the upper
			 * level SPTE before it is zapped, and then make this
			 * target SPTE writable, resume the guest, and set the
			 * Dirty bit between reading the SPTE above and writing
			 * it here.
			 */
<yellow>			old_spte = kvm_tdp_mmu_write_spte(sptep, old_spte,</yellow>
							  REMOVED_SPTE, level);
		}
<yellow>		handle_changed_spte(kvm, kvm_mmu_page_as_id(sp), gfn,</yellow>
				    old_spte, REMOVED_SPTE, level, shared);
	}

<yellow>	call_rcu(&sp->rcu_head, tdp_mmu_free_sp_rcu_callback);</yellow>
}

/**
 * __handle_changed_spte - handle bookkeeping associated with an SPTE change
 * @kvm: kvm instance
 * @as_id: the address space of the paging structure the SPTE was a part of
 * @gfn: the base GFN that was mapped by the SPTE
 * @old_spte: The value of the SPTE before the change
 * @new_spte: The value of the SPTE after the change
 * @level: the level of the PT the SPTE is part of in the paging structure
 * @shared: This operation may not be running under the exclusive use of
 *	    the MMU lock and the operation must synchronize with other
 *	    threads that might be modifying SPTEs.
 *
 * Handle bookkeeping that might result from the modification of a SPTE.
 * This function must be called for all TDP SPTE modifications.
 */
static void __handle_changed_spte(struct kvm *kvm, int as_id, gfn_t gfn,
				  u64 old_spte, u64 new_spte, int level,
				  bool shared)
{
<blue>	bool was_present = is_shadow_present_pte(old_spte);</blue>
	bool is_present = is_shadow_present_pte(new_spte);
<blue>	bool was_leaf = was_present && is_last_spte(old_spte, level);</blue>
<blue>	bool is_leaf = is_present && is_last_spte(new_spte, level);</blue>
<blue>	bool pfn_changed = spte_to_pfn(old_spte) != spte_to_pfn(new_spte);</blue>

<yellow>	WARN_ON(level > PT64_ROOT_MAX_LEVEL);</yellow>
<blue>	WARN_ON(level < PG_LEVEL_4K);</blue>
<blue>	WARN_ON(gfn & (KVM_PAGES_PER_HPAGE(level) - 1));</blue>

	/*
	 * If this warning were to trigger it would indicate that there was a
	 * missing MMU notifier or a race with some notifier handler.
	 * A present, leaf SPTE should never be directly replaced with another
	 * present leaf SPTE pointing to a different PFN. A notifier handler
	 * should be zapping the SPTE before the main MM&#x27;s page table is
	 * changed, or the SPTE should be zeroed, and the TLBs flushed by the
	 * thread before replacement.
	 */
<blue>	if (was_leaf && is_leaf && pfn_changed) {</blue>
		pr_err(&quot;Invalid SPTE change: cannot replace a present leaf\n&quot;
		       &quot;SPTE with another present leaf SPTE mapping a\n&quot;
		       &quot;different PFN!\n&quot;
		       &quot;as_id: %d gfn: %llx old_spte: %llx new_spte: %llx level: %d&quot;,
		       as_id, gfn, old_spte, new_spte, level);

		/*
		 * Crash the host to prevent error propagation and guest data
		 * corruption.
		 */
		BUG();
	}

<blue>	if (old_spte == new_spte)</blue>
		return;

<blue>	trace_kvm_tdp_mmu_spte_changed(as_id, gfn, level, old_spte, new_spte);</blue>

<blue>	if (is_leaf)</blue>
<yellow>		check_spte_writable_invariants(new_spte);</yellow>

	/*
	 * The only times a SPTE should be changed from a non-present to
	 * non-present state is when an MMIO entry is installed/modified/
	 * removed. In that case, there is nothing to do here.
	 */
<blue>	if (!was_present && !is_present) {</blue>
		/*
		 * If this change does not involve a MMIO SPTE or removed SPTE,
		 * it is unexpected. Log the change, though it should not
		 * impact the guest since both the former and current SPTEs
		 * are nonpresent.
		 */
<yellow>		if (WARN_ON(!is_mmio_spte(old_spte) &&</yellow>
			    !is_mmio_spte(new_spte) &amp;&amp;
			    !is_removed_spte(new_spte)))
			pr_err(&quot;Unexpected SPTE change! Nonpresent SPTEs\n&quot;
			       &quot;should not be replaced with another,\n&quot;
			       &quot;different nonpresent SPTE, unless one or both\n&quot;
			       &quot;are MMIO SPTEs, or the new SPTE is\n&quot;
			       &quot;a temporary removed SPTE.\n&quot;
			       &quot;as_id: %d gfn: %llx old_spte: %llx new_spte: %llx level: %d&quot;,
			       as_id, gfn, old_spte, new_spte, level);
		return;
	}

<blue>	if (is_leaf != was_leaf)</blue>
<blue>		kvm_update_page_stats(kvm, level, is_leaf ? 1 : -1);</blue>

<blue>	if (was_leaf && is_dirty_spte(old_spte) &&</blue>
<yellow>	    (!is_present || !is_dirty_spte(new_spte) || pfn_changed))</yellow>
<yellow>		kvm_set_pfn_dirty(spte_to_pfn(old_spte));</yellow>

	/*
	 * Recursively handle child PTs if the change removed a subtree from
	 * the paging structure.  Note the WARN on the PFN changing without the
	 * SPTE being converted to a hugepage (leaf) or being zapped.  Shadow
	 * pages are kernel allocations and should never be migrated.
	 */
<yellow>	if (was_present && !was_leaf &&</yellow>
<yellow>	    (is_leaf || !is_present || WARN_ON_ONCE(pfn_changed)))</yellow>
<yellow>		handle_removed_pt(kvm, spte_to_child_pt(old_spte, level), shared);</yellow>
<yellow>}</yellow>

static void handle_changed_spte(struct kvm *kvm, int as_id, gfn_t gfn,
				u64 old_spte, u64 new_spte, int level,
				bool shared)
{
	__handle_changed_spte(kvm, as_id, gfn, old_spte, new_spte, level,
			      shared);
	handle_changed_spte_acc_track(old_spte, new_spte, level);
	handle_changed_spte_dirty_log(kvm, as_id, gfn, old_spte,
				      new_spte, level);
}

/*
 * tdp_mmu_set_spte_atomic - Set a TDP MMU SPTE atomically
 * and handle the associated bookkeeping.  Do not mark the page dirty
 * in KVM&#x27;s dirty bitmaps.
 *
 * If setting the SPTE fails because it has changed, iter-&gt;old_spte will be
 * refreshed to the current value of the spte.
 *
 * @kvm: kvm instance
 * @iter: a tdp_iter instance currently on the SPTE that should be set
 * @new_spte: The value the SPTE should be set to
 * Return:
 * * 0      - If the SPTE was set.
 * * -EBUSY - If the SPTE cannot be set. In this case this function will have
 *            no side-effects other than setting iter-&gt;old_spte to the last
 *            known value of the spte.
 */
static inline int tdp_mmu_set_spte_atomic(struct kvm *kvm,
					  struct tdp_iter *iter,
					  u64 new_spte)
{
<yellow>	u64 *sptep = rcu_dereference(iter->sptep);</yellow>

	/*
	 * The caller is responsible for ensuring the old SPTE is not a REMOVED
	 * SPTE.  KVM should never attempt to zap or manipulate a REMOVED SPTE,
	 * and pre-checking before inserting a new SPTE is advantageous as it
	 * avoids unnecessary work.
	 */
<yellow>	WARN_ON_ONCE(iter->yielded || is_removed_spte(iter->old_spte));</yellow>

<yellow>	lockdep_assert_held_read(&kvm->mmu_lock);</yellow>

	/*
	 * Note, fast_pf_fix_direct_spte() can also modify TDP MMU SPTEs and
	 * does not hold the mmu_lock.
	 */
<yellow>	if (!try_cmpxchg64(sptep, &iter->old_spte, new_spte))</yellow>
		return -EBUSY;

<yellow>	__handle_changed_spte(kvm, iter->as_id, iter->gfn, iter->old_spte,</yellow>
			      new_spte, iter-&gt;level, true);
	handle_changed_spte_acc_track(iter-&gt;old_spte, new_spte, iter-&gt;level);

	return 0;
<yellow>}</yellow>

<yellow>static inline int tdp_mmu_zap_spte_atomic(struct kvm *kvm,</yellow>
					  struct tdp_iter *iter)
{
	int ret;

	/*
	 * Freeze the SPTE by setting it to a special,
	 * non-present value. This will stop other threads from
	 * immediately installing a present entry in its place
	 * before the TLBs are flushed.
	 */
<yellow>	ret = tdp_mmu_set_spte_atomic(kvm, iter, REMOVED_SPTE);</yellow>
	if (ret)
		return ret;

	kvm_flush_remote_tlbs_with_address(kvm, iter-&gt;gfn,
<yellow>					   KVM_PAGES_PER_HPAGE(iter->level));</yellow>

	/*
	 * No other thread can overwrite the removed SPTE as they must either
	 * wait on the MMU lock or use tdp_mmu_set_spte_atomic() which will not
	 * overwrite the special removed SPTE value. No bookkeeping is needed
	 * here since the SPTE is going from non-present to non-present.  Use
	 * the raw write helper to avoid an unnecessary check on volatile bits.
	 */
<yellow>	__kvm_tdp_mmu_write_spte(iter->sptep, 0);</yellow>

	return 0;
}


/*
 * __tdp_mmu_set_spte - Set a TDP MMU SPTE and handle the associated bookkeeping
 * @kvm:	      KVM instance
 * @as_id:	      Address space ID, i.e. regular vs. SMM
 * @sptep:	      Pointer to the SPTE
 * @old_spte:	      The current value of the SPTE
 * @new_spte:	      The new value that will be set for the SPTE
 * @gfn:	      The base GFN that was (or will be) mapped by the SPTE
 * @level:	      The level _containing_ the SPTE (its parent PT&#x27;s level)
 * @record_acc_track: Notify the MM subsystem of changes to the accessed state
 *		      of the page. Should be set unless handling an MMU
 *		      notifier for access tracking. Leaving record_acc_track
 *		      unset in that case prevents page accesses from being
 *		      double counted.
 * @record_dirty_log: Record the page as dirty in the dirty bitmap if
 *		      appropriate for the change being made. Should be set
 *		      unless performing certain dirty logging operations.
 *		      Leaving record_dirty_log unset in that case prevents page
 *		      writes from being double counted.
 *
 * Returns the old SPTE value, which _may_ be different than @old_spte if the
 * SPTE had voldatile bits.
 */
static u64 __tdp_mmu_set_spte(struct kvm *kvm, int as_id, tdp_ptep_t sptep,
			      u64 old_spte, u64 new_spte, gfn_t gfn, int level,
			      bool record_acc_track, bool record_dirty_log)
{
<yellow>	lockdep_assert_held_write(&kvm->mmu_lock);</yellow>

	/*
	 * No thread should be using this function to set SPTEs to or from the
	 * temporary removed SPTE value.
	 * If operating under the MMU lock in read mode, tdp_mmu_set_spte_atomic
	 * should be used. If operating under the MMU lock in write mode, the
	 * use of the removed SPTE should not be necessary.
	 */
<yellow>	WARN_ON(is_removed_spte(old_spte) || is_removed_spte(new_spte));</yellow>

<yellow>	old_spte = kvm_tdp_mmu_write_spte(sptep, old_spte, new_spte, level);</yellow>

<yellow>	__handle_changed_spte(kvm, as_id, gfn, old_spte, new_spte, level, false);</yellow>

	if (record_acc_track)
<yellow>		handle_changed_spte_acc_track(old_spte, new_spte, level);</yellow>
<yellow>	if (record_dirty_log)</yellow>
<yellow>		handle_changed_spte_dirty_log(kvm, as_id, gfn, old_spte,</yellow>
					      new_spte, level);
	return old_spte;
<yellow>}</yellow>

static inline void _tdp_mmu_set_spte(struct kvm *kvm, struct tdp_iter *iter,
				     u64 new_spte, bool record_acc_track,
				     bool record_dirty_log)
{
<yellow>	WARN_ON_ONCE(iter->yielded);</yellow>

<yellow>	iter->old_spte = __tdp_mmu_set_spte(kvm, iter->as_id, iter->sptep,</yellow>
					    iter-&gt;old_spte, new_spte,
					    iter-&gt;gfn, iter-&gt;level,
					    record_acc_track, record_dirty_log);
}

static inline void tdp_mmu_set_spte(struct kvm *kvm, struct tdp_iter *iter,
				    u64 new_spte)
{
<yellow>	_tdp_mmu_set_spte(kvm, iter, new_spte, true, true);</yellow>
}

static inline void tdp_mmu_set_spte_no_acc_track(struct kvm *kvm,
						 struct tdp_iter *iter,
						 u64 new_spte)
{
<yellow>	_tdp_mmu_set_spte(kvm, iter, new_spte, false, true);</yellow>
}

static inline void tdp_mmu_set_spte_no_dirty_log(struct kvm *kvm,
						 struct tdp_iter *iter,
						 u64 new_spte)
{
<yellow>	_tdp_mmu_set_spte(kvm, iter, new_spte, true, false);</yellow>
}

#define tdp_root_for_each_pte(_iter, _root, _start, _end) \
	for_each_tdp_pte(_iter, _root, _start, _end)

#define tdp_root_for_each_leaf_pte(_iter, _root, _start, _end)	\
	tdp_root_for_each_pte(_iter, _root, _start, _end)		\
		if (!is_shadow_present_pte(_iter.old_spte) ||		\
		    !is_last_spte(_iter.old_spte, _iter.level))		\
			continue;					\
		else

#define tdp_mmu_for_each_pte(_iter, _mmu, _start, _end)		\
	for_each_tdp_pte(_iter, to_shadow_page(_mmu-&gt;root.hpa), _start, _end)

/*
 * Yield if the MMU lock is contended or this thread needs to return control
 * to the scheduler.
 *
 * If this function should yield and flush is set, it will perform a remote
 * TLB flush before yielding.
 *
 * If this function yields, iter-&gt;yielded is set and the caller must skip to
 * the next iteration, where tdp_iter_next() will reset the tdp_iter&#x27;s walk
 * over the paging structures to allow the iterator to continue its traversal
 * from the paging structure root.
 *
 * Returns true if this function yielded.
 */
static inline bool __must_check tdp_mmu_iter_cond_resched(struct kvm *kvm,
							  struct tdp_iter *iter,
							  bool flush, bool shared)
{
<yellow>	WARN_ON(iter->yielded);</yellow>

	/* Ensure forward progress has been made before yielding. */
<yellow>	if (iter->next_last_level_gfn == iter->yielded_gfn)</yellow>
		return false;

<yellow>	if (need_resched() || rwlock_needbreak(&kvm->mmu_lock)) {</yellow>
<yellow>		if (flush)</yellow>
<yellow>			kvm_flush_remote_tlbs(kvm);</yellow>

<yellow>		rcu_read_unlock();</yellow>

		if (shared)
<yellow>			cond_resched_rwlock_read(&kvm->mmu_lock);</yellow>
		else
<yellow>			cond_resched_rwlock_write(&kvm->mmu_lock);</yellow>

<yellow>		rcu_read_lock();</yellow>

<yellow>		WARN_ON(iter->gfn > iter->next_last_level_gfn);</yellow>

<yellow>		iter->yielded = true;</yellow>
	}

<yellow>	return iter->yielded;</yellow>
<yellow>}</yellow>

static inline gfn_t tdp_mmu_max_gfn_exclusive(void)
{
	/*
	 * Bound TDP MMU walks at host.MAXPHYADDR.  KVM disallows memslots with
	 * a gpa range that would exceed the max gfn, and KVM does not create
	 * MMIO SPTEs for &quot;impossible&quot; gfns, instead sending such accesses down
	 * the slow emulation path every time.
	 */
<yellow>	return kvm_mmu_max_gfn() + 1;</yellow>
}

static void __tdp_mmu_zap_root(struct kvm *kvm, struct kvm_mmu_page *root,
			       bool shared, int zap_level)
<yellow>{</yellow>
	struct tdp_iter iter;

<yellow>	gfn_t end = tdp_mmu_max_gfn_exclusive();</yellow>
	gfn_t start = 0;

<yellow>	for_each_tdp_pte_min_level(iter, root, zap_level, start, end) {</yellow>
retry:
<yellow>		if (tdp_mmu_iter_cond_resched(kvm, &iter, false, shared))</yellow>
			continue;

<yellow>		if (!is_shadow_present_pte(iter.old_spte))</yellow>
			continue;

<yellow>		if (iter.level > zap_level)</yellow>
			continue;

<yellow>		if (!shared)</yellow>
<yellow>			tdp_mmu_set_spte(kvm, &iter, 0);</yellow>
<yellow>		else if (tdp_mmu_set_spte_atomic(kvm, &iter, 0))</yellow>
			goto retry;
	}
}

static void tdp_mmu_zap_root(struct kvm *kvm, struct kvm_mmu_page *root,
			     bool shared)
{

	/*
	 * The root must have an elevated refcount so that it&#x27;s reachable via
	 * mmu_notifier callbacks, which allows this path to yield and drop
	 * mmu_lock.  When handling an unmap/release mmu_notifier command, KVM
	 * must drop all references to relevant pages prior to completing the
	 * callback.  Dropping mmu_lock with an unreachable root would result
	 * in zapping SPTEs after a relevant mmu_notifier callback completes
	 * and lead to use-after-free as zapping a SPTE triggers &quot;writeback&quot; of
	 * dirty accessed bits to the SPTE&#x27;s associated struct page.
	 */
<yellow>	WARN_ON_ONCE(!refcount_read(&root->tdp_mmu_root_count));</yellow>

<yellow>	kvm_lockdep_assert_mmu_lock_held(kvm, shared);</yellow>

<yellow>	rcu_read_lock();</yellow>

	/*
	 * To avoid RCU stalls due to recursively removing huge swaths of SPs,
	 * split the zap into two passes.  On the first pass, zap at the 1gb
	 * level, and then zap top-level SPs on the second pass.  &quot;1gb&quot; is not
	 * arbitrary, as KVM must be able to zap a 1gb shadow page without
	 * inducing a stall to allow in-place replacement with a 1gb hugepage.
	 *
	 * Because zapping a SP recurses on its children, stepping down to
	 * PG_LEVEL_4K in the iterator itself is unnecessary.
	 */
<yellow>	__tdp_mmu_zap_root(kvm, root, shared, PG_LEVEL_1G);</yellow>
	__tdp_mmu_zap_root(kvm, root, shared, root-&gt;role.level);

<yellow>	rcu_read_unlock();</yellow>
}

bool kvm_tdp_mmu_zap_sp(struct kvm *kvm, struct kvm_mmu_page *sp)
{
	u64 old_spte;

	/*
	 * This helper intentionally doesn&#x27;t allow zapping a root shadow page,
	 * which doesn&#x27;t have a parent page table and thus no associated entry.
	 */
<yellow>	if (WARN_ON_ONCE(!sp->ptep))</yellow>
		return false;

<yellow>	old_spte = kvm_tdp_mmu_read_spte(sp->ptep);</yellow>
<yellow>	if (WARN_ON_ONCE(!is_shadow_present_pte(old_spte)))</yellow>
		return false;

	__tdp_mmu_set_spte(kvm, kvm_mmu_page_as_id(sp), sp-&gt;ptep, old_spte, 0,
<yellow>			   sp->gfn, sp->role.level + 1, true, true);</yellow>

	return true;
<yellow>}</yellow>

/*
 * If can_yield is true, will release the MMU lock and reschedule if the
 * scheduler needs the CPU or there is contention on the MMU lock. If this
 * function cannot yield, it will not release the MMU lock or reschedule and
 * the caller must ensure it does not supply too large a GFN range, or the
 * operation can cause a soft lockup.
 */
static bool tdp_mmu_zap_leafs(struct kvm *kvm, struct kvm_mmu_page *root,
			      gfn_t start, gfn_t end, bool can_yield, bool flush)
{
	struct tdp_iter iter;

<yellow>	end = min(end, tdp_mmu_max_gfn_exclusive());</yellow>

<yellow>	lockdep_assert_held_write(&kvm->mmu_lock);</yellow>

<yellow>	rcu_read_lock();</yellow>

<yellow>	for_each_tdp_pte_min_level(iter, root, PG_LEVEL_4K, start, end) {</yellow>
<yellow>		if (can_yield &&</yellow>
<yellow>		    tdp_mmu_iter_cond_resched(kvm, &iter, flush, false)) {</yellow>
			flush = false;
			continue;
		}

<yellow>		if (!is_shadow_present_pte(iter.old_spte) ||</yellow>
<yellow>		    !is_last_spte(iter.old_spte, iter.level))</yellow>
			continue;

<yellow>		tdp_mmu_set_spte(kvm, &iter, 0);</yellow>
		flush = true;
	}

<yellow>	rcu_read_unlock();</yellow>

	/*
	 * Because this flow zaps _only_ leaf SPTEs, the caller doesn&#x27;t need
	 * to provide RCU protection as no &#x27;struct kvm_mmu_page&#x27; will be freed.
	 */
	return flush;
}

/*
 * Zap leaf SPTEs for the range of gfns, [start, end), for all roots. Returns
 * true if a TLB flush is needed before releasing the MMU lock, i.e. if one or
 * more SPTEs were zapped since the MMU lock was last acquired.
 */
bool kvm_tdp_mmu_zap_leafs(struct kvm *kvm, int as_id, gfn_t start, gfn_t end,
			   bool can_yield, bool flush)
{
	struct kvm_mmu_page *root;

<yellow>	for_each_tdp_mmu_root_yield_safe(kvm, root, as_id)</yellow>
<yellow>		flush = tdp_mmu_zap_leafs(kvm, root, start, end, can_yield, flush);</yellow>

	return flush;
<yellow>}</yellow>

void kvm_tdp_mmu_zap_all(struct kvm *kvm)
{
	struct kvm_mmu_page *root;
	int i;

	/*
	 * Zap all roots, including invalid roots, as all SPTEs must be dropped
	 * before returning to the caller.  Zap directly even if the root is
	 * also being zapped by a worker.  Walking zapped top-level SPTEs isn&#x27;t
	 * all that expensive and mmu_lock is already held, which means the
	 * worker has yielded, i.e. flushing the work instead of zapping here
	 * isn&#x27;t guaranteed to be any faster.
	 *
	 * A TLB flush is unnecessary, KVM zaps everything if and only the VM
	 * is being destroyed or the userspace VMM has exited.  In both cases,
	 * KVM_RUN is unreachable, i.e. no vCPUs will ever service the request.
	 */
<yellow>	for (i = 0; i < KVM_ADDRESS_SPACE_NUM; i++) {</yellow>
<yellow>		for_each_tdp_mmu_root_yield_safe(kvm, root, i)</yellow>
<yellow>			tdp_mmu_zap_root(kvm, root, false);</yellow>
	}
<yellow>}</yellow>

/*
 * Zap all invalidated roots to ensure all SPTEs are dropped before the &quot;fast
 * zap&quot; completes.
 */
void kvm_tdp_mmu_zap_invalidated_roots(struct kvm *kvm)
{
<yellow>	flush_workqueue(kvm->arch.tdp_mmu_zap_wq);</yellow>
}

/*
 * Mark each TDP MMU root as invalid to prevent vCPUs from reusing a root that
 * is about to be zapped, e.g. in response to a memslots update.  The actual
 * zapping is performed asynchronously, so a reference is taken on all roots.
 * Using a separate workqueue makes it easy to ensure that the destruction is
 * performed before the &quot;fast zap&quot; completes, without keeping a separate list
 * of invalidated roots; the list is effectively the list of work items in
 * the workqueue.
 *
 * Get a reference even if the root is already invalid, the asynchronous worker
 * assumes it was gifted a reference to the root it processes.  Because mmu_lock
 * is held for write, it should be impossible to observe a root with zero refcount,
 * i.e. the list of roots cannot be stale.
 *
 * This has essentially the same effect for the TDP MMU
 * as updating mmu_valid_gen does for the shadow MMU.
 */
void kvm_tdp_mmu_invalidate_all_roots(struct kvm *kvm)
<yellow>{</yellow>
	struct kvm_mmu_page *root;

<yellow>	lockdep_assert_held_write(&kvm->mmu_lock);</yellow>
<yellow>	list_for_each_entry(root, &kvm->arch.tdp_mmu_roots, link) {</yellow>
<yellow>		if (!root->role.invalid &&</yellow>
<yellow>		    !WARN_ON_ONCE(!kvm_tdp_mmu_get_root(root))) {</yellow>
<yellow>			root->role.invalid = true;</yellow>
			tdp_mmu_schedule_zap_root(kvm, root);
		}
	}
}

/*
 * Installs a last-level SPTE to handle a TDP page fault.
 * (NPT/EPT violation/misconfiguration)
 */
static int tdp_mmu_map_handle_target_level(struct kvm_vcpu *vcpu,
					  struct kvm_page_fault *fault,
					  struct tdp_iter *iter)
{
<yellow>	struct kvm_mmu_page *sp = sptep_to_sp(rcu_dereference(iter->sptep));</yellow>
	u64 new_spte;
	int ret = RET_PF_FIXED;
	bool wrprot = false;

<yellow>	WARN_ON(sp->role.level != fault->goal_level);</yellow>
<yellow>	if (unlikely(!fault->slot))</yellow>
<yellow>		new_spte = make_mmio_spte(vcpu, iter->gfn, ACC_ALL);</yellow>
	else
<yellow>		wrprot = make_spte(vcpu, sp, fault->slot, ACC_ALL, iter->gfn,</yellow>
<yellow>					 fault->pfn, iter->old_spte, fault->prefetch, true,</yellow>
<yellow>					 fault->map_writable, &new_spte);</yellow>

	if (new_spte == iter-&gt;old_spte)
		ret = RET_PF_SPURIOUS;
<yellow>	else if (tdp_mmu_set_spte_atomic(vcpu->kvm, iter, new_spte))</yellow>
		return RET_PF_RETRY;
<yellow>	else if (is_shadow_present_pte(iter->old_spte) &&</yellow>
<yellow>		 !is_last_spte(iter->old_spte, iter->level))</yellow>
		kvm_flush_remote_tlbs_with_address(vcpu-&gt;kvm, sp-&gt;gfn,
<yellow>						   KVM_PAGES_PER_HPAGE(iter->level + 1));</yellow>

	/*
	 * If the page fault was caused by a write but the page is write
	 * protected, emulation is needed. If the emulation was skipped,
	 * the vCPU would have the same fault again.
	 */
<yellow>	if (wrprot) {</yellow>
<yellow>		if (fault->write)</yellow>
			ret = RET_PF_EMULATE;
	}

	/* If a MMIO SPTE is installed, the MMIO will need to be emulated. */
<yellow>	if (unlikely(is_mmio_spte(new_spte))) {</yellow>
<yellow>		vcpu->stat.pf_mmio_spte_created++;</yellow>
<yellow>		trace_mark_mmio_spte(rcu_dereference(iter->sptep), iter->gfn,</yellow>
				     new_spte);
		ret = RET_PF_EMULATE;
	} else {
<yellow>		trace_kvm_mmu_set_spte(iter->level, iter->gfn,</yellow>
<yellow>				       rcu_dereference(iter->sptep));</yellow>
	}

	return ret;
}

/*
 * tdp_mmu_link_sp - Replace the given spte with an spte pointing to the
 * provided page table.
 *
 * @kvm: kvm instance
 * @iter: a tdp_iter instance currently on the SPTE that should be set
 * @sp: The new TDP page table to install.
 * @account_nx: True if this page table is being installed to split a
 *              non-executable huge page.
 * @shared: This operation is running under the MMU lock in read mode.
 *
 * Returns: 0 if the new page table was installed. Non-0 if the page table
 *          could not be installed (e.g. the atomic compare-exchange failed).
 */
static int tdp_mmu_link_sp(struct kvm *kvm, struct tdp_iter *iter,
			   struct kvm_mmu_page *sp, bool account_nx,
			   bool shared)
{
<yellow>	u64 spte = make_nonleaf_spte(sp->spt, !kvm_ad_enabled());</yellow>
	int ret = 0;

	if (shared) {
<yellow>		ret = tdp_mmu_set_spte_atomic(kvm, iter, spte);</yellow>
		if (ret)
			return ret;
	} else {
<yellow>		tdp_mmu_set_spte(kvm, iter, spte);</yellow>
	}

<yellow>	spin_lock(&kvm->arch.tdp_mmu_pages_lock);</yellow>
<yellow>	list_add(&sp->link, &kvm->arch.tdp_mmu_pages);</yellow>
<yellow>	if (account_nx)</yellow>
<yellow>		account_huge_nx_page(kvm, sp);</yellow>
<yellow>	spin_unlock(&kvm->arch.tdp_mmu_pages_lock);</yellow>
	tdp_account_mmu_page(kvm, sp);

	return 0;
<yellow>}</yellow>

/*
 * Handle a TDP page fault (NPT/EPT violation/misconfiguration) by installing
 * page tables and SPTEs to translate the faulting guest physical address.
 */
int kvm_tdp_mmu_map(struct kvm_vcpu *vcpu, struct kvm_page_fault *fault)
<yellow>{</yellow>
<yellow>	struct kvm_mmu *mmu = vcpu->arch.mmu;</yellow>
	struct tdp_iter iter;
	struct kvm_mmu_page *sp;
	int ret;

	kvm_mmu_hugepage_adjust(vcpu, fault);

<yellow>	trace_kvm_mmu_spte_requested(fault);</yellow>

<yellow>	rcu_read_lock();</yellow>

<yellow>	tdp_mmu_for_each_pte(iter, mmu, fault->gfn, fault->gfn + 1) {</yellow>
<yellow>		if (fault->nx_huge_page_workaround_enabled)</yellow>
<yellow>			disallowed_hugepage_adjust(fault, iter.old_spte, iter.level);</yellow>

<yellow>		if (iter.level == fault->goal_level)</yellow>
			break;

		/*
		 * If there is an SPTE mapping a large page at a higher level
		 * than the target, that SPTE must be cleared and replaced
		 * with a non-leaf SPTE.
		 */
<yellow>		if (is_shadow_present_pte(iter.old_spte) &&</yellow>
		    is_large_pte(iter.old_spte)) {
<yellow>			if (tdp_mmu_zap_spte_atomic(vcpu->kvm, &iter))</yellow>
				break;

			/*
			 * The iter must explicitly re-read the spte here
			 * because the new value informs the !present
			 * path below.
			 */
<yellow>			iter.old_spte = kvm_tdp_mmu_read_spte(iter.sptep);</yellow>
		}

<yellow>		if (!is_shadow_present_pte(iter.old_spte)) {</yellow>
<yellow>			bool account_nx = fault->huge_page_disallowed &&</yellow>
<yellow>					  fault->req_level >= iter.level;</yellow>

			/*
			 * If SPTE has been frozen by another thread, just
			 * give up and retry, avoiding unnecessary page table
			 * allocation and free.
			 */
<yellow>			if (is_removed_spte(iter.old_spte))</yellow>
				break;

<yellow>			sp = tdp_mmu_alloc_sp(vcpu);</yellow>
			tdp_mmu_init_child_sp(sp, &amp;iter);

			if (tdp_mmu_link_sp(vcpu-&gt;kvm, &amp;iter, sp, account_nx, true)) {
<yellow>				tdp_mmu_free_sp(sp);</yellow>
				break;
			}
		}
	}

	/*
	 * Force the guest to retry the access if the upper level SPTEs aren&#x27;t
	 * in place, or if the target leaf SPTE is frozen by another CPU.
	 */
<yellow>	if (iter.level != fault->goal_level || is_removed_spte(iter.old_spte)) {</yellow>
<yellow>		rcu_read_unlock();</yellow>
<yellow>		return RET_PF_RETRY;</yellow>
	}

<yellow>	ret = tdp_mmu_map_handle_target_level(vcpu, fault, &iter);</yellow>
<yellow>	rcu_read_unlock();</yellow>

	return ret;
}

bool kvm_tdp_mmu_unmap_gfn_range(struct kvm *kvm, struct kvm_gfn_range *range,
				 bool flush)
{
<yellow>	return kvm_tdp_mmu_zap_leafs(kvm, range->slot->as_id, range->start,</yellow>
<yellow>				     range->end, range->may_block, flush);</yellow>
}

typedef bool (*tdp_handler_t)(struct kvm *kvm, struct tdp_iter *iter,
			      struct kvm_gfn_range *range);

static __always_inline bool kvm_tdp_mmu_handle_gfn(struct kvm *kvm,
						   struct kvm_gfn_range *range,
						   tdp_handler_t handler)
{
	struct kvm_mmu_page *root;
	struct tdp_iter iter;
	bool ret = false;

	/*
	 * Don&#x27;t support rescheduling, none of the MMU notifiers that funnel
	 * into this helper allow blocking; it&#x27;d be dead, wasteful code.
	 */
<yellow>	for_each_tdp_mmu_root(kvm, root, range->slot->as_id) {</yellow>
<yellow>		rcu_read_lock();</yellow>

<yellow>		tdp_root_for_each_leaf_pte(iter, root, range->start, range->end)</yellow>
<yellow>			ret |= handler(kvm, &iter, range);</yellow>

<yellow>		rcu_read_unlock();</yellow>
	}

	return ret;
}

/*
 * Mark the SPTEs range of GFNs [start, end) unaccessed and return non-zero
 * if any of the GFNs in the range have been accessed.
 */
static bool age_gfn_range(struct kvm *kvm, struct tdp_iter *iter,
			  struct kvm_gfn_range *range)
{
	u64 new_spte = 0;

	/* If we have a non-accessed entry we don&#x27;t need to change the pte. */
<yellow>	if (!is_accessed_spte(iter->old_spte))</yellow>
		return false;

	new_spte = iter-&gt;old_spte;

	if (spte_ad_enabled(new_spte)) {
<yellow>		new_spte &= ~shadow_accessed_mask;</yellow>
	} else {
		/*
		 * Capture the dirty status of the page, so that it doesn&#x27;t get
		 * lost when the SPTE is marked for access tracking.
		 */
<yellow>		if (is_writable_pte(new_spte))</yellow>
<yellow>			kvm_set_pfn_dirty(spte_to_pfn(new_spte));</yellow>

<yellow>		new_spte = mark_spte_for_access_track(new_spte);</yellow>
	}

<yellow>	tdp_mmu_set_spte_no_acc_track(kvm, iter, new_spte);</yellow>

	return true;
}

bool kvm_tdp_mmu_age_gfn_range(struct kvm *kvm, struct kvm_gfn_range *range)
<yellow>{</yellow>
<yellow>	return kvm_tdp_mmu_handle_gfn(kvm, range, age_gfn_range);</yellow>
}

static bool test_age_gfn(struct kvm *kvm, struct tdp_iter *iter,
			 struct kvm_gfn_range *range)
{
<yellow>	return is_accessed_spte(iter->old_spte);</yellow>
}

bool kvm_tdp_mmu_test_age_gfn(struct kvm *kvm, struct kvm_gfn_range *range)
<yellow>{</yellow>
<yellow>	return kvm_tdp_mmu_handle_gfn(kvm, range, test_age_gfn);</yellow>
}

static bool set_spte_gfn(struct kvm *kvm, struct tdp_iter *iter,
			 struct kvm_gfn_range *range)
{
	u64 new_spte;

	/* Huge pages aren&#x27;t expected to be modified without first being zapped. */
<yellow>	WARN_ON(pte_huge(range->pte) || range->start + 1 != range->end);</yellow>

<yellow>	if (iter->level != PG_LEVEL_4K ||</yellow>
	    !is_shadow_present_pte(iter-&gt;old_spte))
		return false;

	/*
	 * Note, when changing a read-only SPTE, it&#x27;s not strictly necessary to
	 * zero the SPTE before setting the new PFN, but doing so preserves the
	 * invariant that the PFN of a present * leaf SPTE can never change.
	 * See __handle_changed_spte().
	 */
<yellow>	tdp_mmu_set_spte(kvm, iter, 0);</yellow>

	if (!pte_write(range-&gt;pte)) {
		new_spte = kvm_mmu_changed_pte_notifier_make_spte(iter-&gt;old_spte,
<yellow>								  pte_pfn(range->pte));</yellow>

<yellow>		tdp_mmu_set_spte(kvm, iter, new_spte);</yellow>
	}

	return true;
}

/*
 * Handle the changed_pte MMU notifier for the TDP MMU.
 * data is a pointer to the new pte_t mapping the HVA specified by the MMU
 * notifier.
 * Returns non-zero if a flush is needed before releasing the MMU lock.
 */
bool kvm_tdp_mmu_set_spte_gfn(struct kvm *kvm, struct kvm_gfn_range *range)
<yellow>{</yellow>
	/*
	 * No need to handle the remote TLB flush under RCU protection, the
	 * target SPTE _must_ be a leaf SPTE, i.e. cannot result in freeing a
	 * shadow page.  See the WARN on pfn_changed in __handle_changed_spte().
	 */
<yellow>	return kvm_tdp_mmu_handle_gfn(kvm, range, set_spte_gfn);</yellow>
}

/*
 * Remove write access from all SPTEs at or above min_level that map GFNs
 * [start, end). Returns true if an SPTE has been changed and the TLBs need to
 * be flushed.
 */
static bool wrprot_gfn_range(struct kvm *kvm, struct kvm_mmu_page *root,
			     gfn_t start, gfn_t end, int min_level)
{
	struct tdp_iter iter;
	u64 new_spte;
	bool spte_set = false;

<yellow>	rcu_read_lock();</yellow>

<yellow>	BUG_ON(min_level > KVM_MAX_HUGEPAGE_LEVEL);</yellow>

<yellow>	for_each_tdp_pte_min_level(iter, root, min_level, start, end) {</yellow>
retry:
<yellow>		if (tdp_mmu_iter_cond_resched(kvm, &iter, false, true))</yellow>
			continue;

<yellow>		if (!is_shadow_present_pte(iter.old_spte) ||</yellow>
<yellow>		    !is_last_spte(iter.old_spte, iter.level) ||</yellow>
<yellow>		    !(iter.old_spte & PT_WRITABLE_MASK))</yellow>
			continue;

		new_spte = iter.old_spte &amp; ~PT_WRITABLE_MASK;

<yellow>		if (tdp_mmu_set_spte_atomic(kvm, &iter, new_spte))</yellow>
			goto retry;

		spte_set = true;
	}

<yellow>	rcu_read_unlock();</yellow>
	return spte_set;
}

/*
 * Remove write access from all the SPTEs mapping GFNs in the memslot. Will
 * only affect leaf SPTEs down to min_level.
 * Returns true if an SPTE has been changed and the TLBs need to be flushed.
 */
bool kvm_tdp_mmu_wrprot_slot(struct kvm *kvm,
			     const struct kvm_memory_slot *slot, int min_level)
{
	struct kvm_mmu_page *root;
	bool spte_set = false;

<yellow>	lockdep_assert_held_read(&kvm->mmu_lock);</yellow>

<yellow>	for_each_valid_tdp_mmu_root_yield_safe(kvm, root, slot->as_id, true)</yellow>
		spte_set |= wrprot_gfn_range(kvm, root, slot-&gt;base_gfn,
<yellow>			     slot->base_gfn + slot->npages, min_level);</yellow>

	return spte_set;
<yellow>}</yellow>

static struct kvm_mmu_page *__tdp_mmu_alloc_sp_for_split(gfp_t gfp)
{
	struct kvm_mmu_page *sp;

	gfp |= __GFP_ZERO;

<yellow>	sp = kmem_cache_alloc(mmu_page_header_cache, gfp);</yellow>
	if (!sp)
		return NULL;

<yellow>	sp->spt = (void *)__get_free_page(gfp);</yellow>
	if (!sp-&gt;spt) {
<yellow>		kmem_cache_free(mmu_page_header_cache, sp);</yellow>
		return NULL;
	}

	return sp;
<yellow>}</yellow>

static struct kvm_mmu_page *tdp_mmu_alloc_sp_for_split(struct kvm *kvm,
						       struct tdp_iter *iter,
						       bool shared)
{
	struct kvm_mmu_page *sp;

	/*
	 * Since we are allocating while under the MMU lock we have to be
	 * careful about GFP flags. Use GFP_NOWAIT to avoid blocking on direct
	 * reclaim and to avoid making any filesystem callbacks (which can end
	 * up invoking KVM MMU notifiers, resulting in a deadlock).
	 *
	 * If this allocation fails we drop the lock and retry with reclaim
	 * allowed.
	 */
<yellow>	sp = __tdp_mmu_alloc_sp_for_split(GFP_NOWAIT | __GFP_ACCOUNT);</yellow>
	if (sp)
		return sp;

<yellow>	rcu_read_unlock();</yellow>

	if (shared)
<yellow>		read_unlock(&kvm->mmu_lock);</yellow>
	else
<yellow>		write_unlock(&kvm->mmu_lock);</yellow>

	iter-&gt;yielded = true;
	sp = __tdp_mmu_alloc_sp_for_split(GFP_KERNEL_ACCOUNT);

	if (shared)
		read_lock(&amp;kvm-&gt;mmu_lock);
	else
		write_lock(&amp;kvm-&gt;mmu_lock);

<yellow>	rcu_read_lock();</yellow>

	return sp;
}

static int tdp_mmu_split_huge_page(struct kvm *kvm, struct tdp_iter *iter,
				   struct kvm_mmu_page *sp, bool shared)
{
<yellow>	const u64 huge_spte = iter->old_spte;</yellow>
<yellow>	const int level = iter->level;</yellow>
	int ret, i;

	tdp_mmu_init_child_sp(sp, iter);

	/*
	 * No need for atomics when writing to sp-&gt;spt since the page table has
	 * not been linked in yet and thus is not reachable from any other CPU.
	 */
	for (i = 0; i &lt; SPTE_ENT_PER_PAGE; i++)
<yellow>		sp->spt[i] = make_huge_page_split_spte(kvm, huge_spte, sp->role, i);</yellow>

	/*
	 * Replace the huge spte with a pointer to the populated lower level
	 * page table. Since we are making this change without a TLB flush vCPUs
	 * will see a mix of the split mappings and the original huge mapping,
	 * depending on what&#x27;s currently in their TLB. This is fine from a
	 * correctness standpoint since the translation will be the same either
	 * way.
	 */
<yellow>	ret = tdp_mmu_link_sp(kvm, iter, sp, false, shared);</yellow>
	if (ret)
		goto out;

	/*
	 * tdp_mmu_link_sp_atomic() will handle subtracting the huge page we
	 * are overwriting from the page stats. But we have to manually update
	 * the page stats with the new present child pages.
	 */
<yellow>	kvm_update_page_stats(kvm, level - 1, SPTE_ENT_PER_PAGE);</yellow>

out:
<yellow>	trace_kvm_mmu_split_huge_page(iter->gfn, huge_spte, level, ret);</yellow>
	return ret;
}

static int tdp_mmu_split_huge_pages_root(struct kvm *kvm,
					 struct kvm_mmu_page *root,
					 gfn_t start, gfn_t end,
					 int target_level, bool shared)
<yellow>{</yellow>
	struct kvm_mmu_page *sp = NULL;
	struct tdp_iter iter;
	int ret = 0;

<yellow>	rcu_read_lock();</yellow>

	/*
	 * Traverse the page table splitting all huge pages above the target
	 * level into one lower level. For example, if we encounter a 1GB page
	 * we split it into 512 2MB pages.
	 *
	 * Since the TDP iterator uses a pre-order traversal, we are guaranteed
	 * to visit an SPTE before ever visiting its children, which means we
	 * will correctly recursively split huge pages that are more than one
	 * level above the target level (e.g. splitting a 1GB to 512 2MB pages,
	 * and then splitting each of those to 512 4KB pages).
	 */
<yellow>	for_each_tdp_pte_min_level(iter, root, target_level + 1, start, end) {</yellow>
retry:
<yellow>		if (tdp_mmu_iter_cond_resched(kvm, &iter, false, shared))</yellow>
			continue;

<yellow>		if (!is_shadow_present_pte(iter.old_spte) || !is_large_pte(iter.old_spte))</yellow>
			continue;

<yellow>		if (!sp) {</yellow>
<yellow>			sp = tdp_mmu_alloc_sp_for_split(kvm, &iter, shared);</yellow>
<yellow>			if (!sp) {</yellow>
				ret = -ENOMEM;
<yellow>				trace_kvm_mmu_split_huge_page(iter.gfn,</yellow>
							      iter.old_spte,
							      iter.level, ret);
				break;
			}

<yellow>			if (iter.yielded)</yellow>
				continue;
		}

<yellow>		if (tdp_mmu_split_huge_page(kvm, &iter, sp, shared))</yellow>
			goto retry;

		sp = NULL;
	}

<yellow>	rcu_read_unlock();</yellow>

	/*
	 * It&#x27;s possible to exit the loop having never used the last sp if, for
	 * example, a vCPU doing HugePage NX splitting wins the race and
	 * installs its own sp in place of the last sp we tried to split.
	 */
	if (sp)
<yellow>		tdp_mmu_free_sp(sp);</yellow>

	return ret;
}


/*
 * Try to split all huge pages mapped by the TDP MMU down to the target level.
 */
void kvm_tdp_mmu_try_split_huge_pages(struct kvm *kvm,
				      const struct kvm_memory_slot *slot,
				      gfn_t start, gfn_t end,
				      int target_level, bool shared)
{
	struct kvm_mmu_page *root;
	int r = 0;

<yellow>	kvm_lockdep_assert_mmu_lock_held(kvm, shared);</yellow>

<yellow>	for_each_valid_tdp_mmu_root_yield_safe(kvm, root, slot->as_id, shared) {</yellow>
<yellow>		r = tdp_mmu_split_huge_pages_root(kvm, root, start, end, target_level, shared);</yellow>
		if (r) {
<yellow>			kvm_tdp_mmu_put_root(kvm, root, shared);</yellow>
			break;
		}
	}
<yellow>}</yellow>

/*
 * Clear the dirty status of all the SPTEs mapping GFNs in the memslot. If
 * AD bits are enabled, this will involve clearing the dirty bit on each SPTE.
 * If AD bits are not enabled, this will require clearing the writable bit on
 * each SPTE. Returns true if an SPTE has been changed and the TLBs need to
 * be flushed.
 */
static bool clear_dirty_gfn_range(struct kvm *kvm, struct kvm_mmu_page *root,
			   gfn_t start, gfn_t end)
{
	struct tdp_iter iter;
	u64 new_spte;
	bool spte_set = false;

<yellow>	rcu_read_lock();</yellow>

<yellow>	tdp_root_for_each_leaf_pte(iter, root, start, end) {</yellow>
retry:
<yellow>		if (tdp_mmu_iter_cond_resched(kvm, &iter, false, true))</yellow>
			continue;

<yellow>		if (!is_shadow_present_pte(iter.old_spte))</yellow>
			continue;

<yellow>		if (spte_ad_need_write_protect(iter.old_spte)) {</yellow>
<yellow>			if (is_writable_pte(iter.old_spte))</yellow>
<yellow>				new_spte = iter.old_spte & ~PT_WRITABLE_MASK;</yellow>
			else
				continue;
		} else {
<yellow>			if (iter.old_spte & shadow_dirty_mask)</yellow>
<yellow>				new_spte = iter.old_spte & ~shadow_dirty_mask;</yellow>
			else
				continue;
		}

<yellow>		if (tdp_mmu_set_spte_atomic(kvm, &iter, new_spte))</yellow>
			goto retry;

		spte_set = true;
	}

<yellow>	rcu_read_unlock();</yellow>
	return spte_set;
}

/*
 * Clear the dirty status of all the SPTEs mapping GFNs in the memslot. If
 * AD bits are enabled, this will involve clearing the dirty bit on each SPTE.
 * If AD bits are not enabled, this will require clearing the writable bit on
 * each SPTE. Returns true if an SPTE has been changed and the TLBs need to
 * be flushed.
 */
bool kvm_tdp_mmu_clear_dirty_slot(struct kvm *kvm,
				  const struct kvm_memory_slot *slot)
{
	struct kvm_mmu_page *root;
	bool spte_set = false;

<yellow>	lockdep_assert_held_read(&kvm->mmu_lock);</yellow>

<yellow>	for_each_valid_tdp_mmu_root_yield_safe(kvm, root, slot->as_id, true)</yellow>
		spte_set |= clear_dirty_gfn_range(kvm, root, slot-&gt;base_gfn,
<yellow>				slot->base_gfn + slot->npages);</yellow>

	return spte_set;
<yellow>}</yellow>

/*
 * Clears the dirty status of all the 4k SPTEs mapping GFNs for which a bit is
 * set in mask, starting at gfn. The given memslot is expected to contain all
 * the GFNs represented by set bits in the mask. If AD bits are enabled,
 * clearing the dirty status will involve clearing the dirty bit on each SPTE
 * or, if AD bits are not enabled, clearing the writable bit on each SPTE.
 */
static void clear_dirty_pt_masked(struct kvm *kvm, struct kvm_mmu_page *root,
				  gfn_t gfn, unsigned long mask, bool wrprot)
{
	struct tdp_iter iter;
	u64 new_spte;

<yellow>	rcu_read_lock();</yellow>

<yellow>	tdp_root_for_each_leaf_pte(iter, root, gfn + __ffs(mask),</yellow>
				    gfn + BITS_PER_LONG) {
<yellow>		if (!mask)</yellow>
			break;

<yellow>		if (iter.level > PG_LEVEL_4K ||</yellow>
<yellow>		    !(mask & (1UL << (iter.gfn - gfn))))</yellow>
			continue;

		mask &amp;= ~(1UL &lt;&lt; (iter.gfn - gfn));

<yellow>		if (wrprot || spte_ad_need_write_protect(iter.old_spte)) {</yellow>
<yellow>			if (is_writable_pte(iter.old_spte))</yellow>
<yellow>				new_spte = iter.old_spte & ~PT_WRITABLE_MASK;</yellow>
			else
				continue;
		} else {
<yellow>			if (iter.old_spte & shadow_dirty_mask)</yellow>
<yellow>				new_spte = iter.old_spte & ~shadow_dirty_mask;</yellow>
			else
				continue;
		}

<yellow>		tdp_mmu_set_spte_no_dirty_log(kvm, &iter, new_spte);</yellow>
	}

<yellow>	rcu_read_unlock();</yellow>
}

/*
 * Clears the dirty status of all the 4k SPTEs mapping GFNs for which a bit is
 * set in mask, starting at gfn. The given memslot is expected to contain all
 * the GFNs represented by set bits in the mask. If AD bits are enabled,
 * clearing the dirty status will involve clearing the dirty bit on each SPTE
 * or, if AD bits are not enabled, clearing the writable bit on each SPTE.
 */
void kvm_tdp_mmu_clear_dirty_pt_masked(struct kvm *kvm,
				       struct kvm_memory_slot *slot,
				       gfn_t gfn, unsigned long mask,
				       bool wrprot)
{
	struct kvm_mmu_page *root;

<yellow>	lockdep_assert_held_write(&kvm->mmu_lock);</yellow>
<yellow>	for_each_tdp_mmu_root(kvm, root, slot->as_id)</yellow>
<yellow>		clear_dirty_pt_masked(kvm, root, gfn, mask, wrprot);</yellow>
<yellow>}</yellow>

static void zap_collapsible_spte_range(struct kvm *kvm,
				       struct kvm_mmu_page *root,
				       const struct kvm_memory_slot *slot)
{
<yellow>	gfn_t start = slot->base_gfn;</yellow>
	gfn_t end = start + slot-&gt;npages;
	struct tdp_iter iter;
	int max_mapping_level;

<yellow>	rcu_read_lock();</yellow>

<yellow>	for_each_tdp_pte_min_level(iter, root, PG_LEVEL_2M, start, end) {</yellow>
retry:
<yellow>		if (tdp_mmu_iter_cond_resched(kvm, &iter, false, true))</yellow>
			continue;

<yellow>		if (iter.level > KVM_MAX_HUGEPAGE_LEVEL ||</yellow>
<yellow>		    !is_shadow_present_pte(iter.old_spte))</yellow>
			continue;

		/*
		 * Don&#x27;t zap leaf SPTEs, if a leaf SPTE could be replaced with
		 * a large page size, then its parent would have been zapped
		 * instead of stepping down.
		 */
<yellow>		if (is_last_spte(iter.old_spte, iter.level))</yellow>
			continue;

		/*
		 * If iter.gfn resides outside of the slot, i.e. the page for
		 * the current level overlaps but is not contained by the slot,
		 * then the SPTE can&#x27;t be made huge.  More importantly, trying
		 * to query that info from slot-&gt;arch.lpage_info will cause an
		 * out-of-bounds access.
		 */
<yellow>		if (iter.gfn < start || iter.gfn >= end)</yellow>
			continue;

<yellow>		max_mapping_level = kvm_mmu_max_mapping_level(kvm, slot,</yellow>
							      iter.gfn, PG_LEVEL_NUM);
		if (max_mapping_level &lt; iter.level)
			continue;

		/* Note, a successful atomic zap also does a remote TLB flush. */
<yellow>		if (tdp_mmu_zap_spte_atomic(kvm, &iter))</yellow>
			goto retry;
	}

<yellow>	rcu_read_unlock();</yellow>
}

/*
 * Zap non-leaf SPTEs (and free their associated page tables) which could
 * be replaced by huge pages, for GFNs within the slot.
 */
void kvm_tdp_mmu_zap_collapsible_sptes(struct kvm *kvm,
				       const struct kvm_memory_slot *slot)
{
	struct kvm_mmu_page *root;

<yellow>	lockdep_assert_held_read(&kvm->mmu_lock);</yellow>

<yellow>	for_each_valid_tdp_mmu_root_yield_safe(kvm, root, slot->as_id, true)</yellow>
<yellow>		zap_collapsible_spte_range(kvm, root, slot);</yellow>
<yellow>}</yellow>

/*
 * Removes write access on the last level SPTE mapping this GFN and unsets the
 * MMU-writable bit to ensure future writes continue to be intercepted.
 * Returns true if an SPTE was set and a TLB flush is needed.
 */
static bool write_protect_gfn(struct kvm *kvm, struct kvm_mmu_page *root,
			      gfn_t gfn, int min_level)
{
	struct tdp_iter iter;
	u64 new_spte;
	bool spte_set = false;

<yellow>	BUG_ON(min_level > KVM_MAX_HUGEPAGE_LEVEL);</yellow>

<yellow>	rcu_read_lock();</yellow>

<yellow>	for_each_tdp_pte_min_level(iter, root, min_level, gfn, gfn + 1) {</yellow>
<yellow>		if (!is_shadow_present_pte(iter.old_spte) ||</yellow>
<yellow>		    !is_last_spte(iter.old_spte, iter.level))</yellow>
			continue;

		new_spte = iter.old_spte &amp;
<yellow>			~(PT_WRITABLE_MASK | shadow_mmu_writable_mask);</yellow>

		if (new_spte == iter.old_spte)
			break;

<yellow>		tdp_mmu_set_spte(kvm, &iter, new_spte);</yellow>
		spte_set = true;
	}

<yellow>	rcu_read_unlock();</yellow>

	return spte_set;
}

/*
 * Removes write access on the last level SPTE mapping this GFN and unsets the
 * MMU-writable bit to ensure future writes continue to be intercepted.
 * Returns true if an SPTE was set and a TLB flush is needed.
 */
bool kvm_tdp_mmu_write_protect_gfn(struct kvm *kvm,
				   struct kvm_memory_slot *slot, gfn_t gfn,
				   int min_level)
{
	struct kvm_mmu_page *root;
	bool spte_set = false;

<yellow>	lockdep_assert_held_write(&kvm->mmu_lock);</yellow>
<yellow>	for_each_tdp_mmu_root(kvm, root, slot->as_id)</yellow>
<yellow>		spte_set |= write_protect_gfn(kvm, root, gfn, min_level);</yellow>

	return spte_set;
<yellow>}</yellow>

/*
 * Return the level of the lowest level SPTE added to sptes.
 * That SPTE may be non-present.
 *
 * Must be called between kvm_tdp_mmu_walk_lockless_{begin,end}.
 */
int kvm_tdp_mmu_get_walk(struct kvm_vcpu *vcpu, u64 addr, u64 *sptes,
			 int *root_level)
<yellow>{</yellow>
	struct tdp_iter iter;
<yellow>	struct kvm_mmu *mmu = vcpu->arch.mmu;</yellow>
	gfn_t gfn = addr &gt;&gt; PAGE_SHIFT;
	int leaf = -1;

	*root_level = vcpu-&gt;arch.mmu-&gt;root_role.level;

<yellow>	tdp_mmu_for_each_pte(iter, mmu, gfn, gfn + 1) {</yellow>
<yellow>		leaf = iter.level;</yellow>
		sptes[leaf] = iter.old_spte;
	}

	return leaf;
}

/*
 * Returns the last level spte pointer of the shadow page walk for the given
 * gpa, and sets *spte to the spte value. This spte may be non-preset. If no
 * walk could be performed, returns NULL and *spte does not contain valid data.
 *
 * Contract:
 *  - Must be called between kvm_tdp_mmu_walk_lockless_{begin,end}.
 *  - The returned sptep must not be used after kvm_tdp_mmu_walk_lockless_end.
 *
 * WARNING: This function is only intended to be called during fast_page_fault.
 */
u64 *kvm_tdp_mmu_fast_pf_get_last_sptep(struct kvm_vcpu *vcpu, u64 addr,
					u64 *spte)
<yellow>{</yellow>
	struct tdp_iter iter;
<yellow>	struct kvm_mmu *mmu = vcpu->arch.mmu;</yellow>
	gfn_t gfn = addr &gt;&gt; PAGE_SHIFT;
	tdp_ptep_t sptep = NULL;

<yellow>	tdp_mmu_for_each_pte(iter, mmu, gfn, gfn + 1) {</yellow>
<yellow>		*spte = iter.old_spte;</yellow>
		sptep = iter.sptep;
	}

	/*
	 * Perform the rcu_dereference to get the raw spte pointer value since
	 * we are passing it up to fast_page_fault, which is shared with the
	 * legacy MMU and thus does not retain the TDP MMU-specific __rcu
	 * annotation.
	 *
	 * This is safe since fast_page_fault obeys the contracts of this
	 * function as well as all TDP MMU contracts around modifying SPTEs
	 * outside of mmu_lock.
	 */
<yellow>	return rcu_dereference(sptep);</yellow>
}


</code></pre></td></tr></table>
</div><script>const fileList = document.getElementById('file_list')
fileList.innerHTML+=`<li><a href="/kvm_coverage/coverage/linux/arch/x86/kvm/mmu/mmu.c.html">mmu.c 56.4%</li>`
fileList.innerHTML+=`<li><a href="/kvm_coverage/coverage/linux/arch/x86/kvm/vmx/nested.c.html">nested.c 79.9%</li>`
fileList.innerHTML+=`<li><a href="/kvm_coverage/coverage/linux/arch/x86/kvm/vmx/vmx.c.html">vmx.c 58.2%</li>`
fileList.innerHTML+=`<li><a href="/kvm_coverage/coverage/linux/arch/x86/kvm/x86.c.html">x86.c 50.6%</li>`
</script></body></html>