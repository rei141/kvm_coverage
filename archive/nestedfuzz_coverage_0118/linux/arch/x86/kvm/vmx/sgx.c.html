<doctype html>
<html lang="ja">
<head>
<meta charset="utf-8">
<script src="https://cdn.rawgit.com/google/code-prettify/master/loader/run_prettify.js"></script>
<style>
    code{
        font-family:Monaco, Menlo, Consolas, 'Courier New', Courier, monospace, sans-serif;
        font-size: 14px;
        line-height: 18px;
        overflow: auto;
        resize: horizontal;
    }
    code_line{
        font-family: Monaco, Menlo, Consolas, 'Courier New', Courier, monospace, sans-serif;;
        font-size: 14px;
        line-height: 18px;
        overflow: auto;
        resize: horizontal;
        color:#303134;
    }
    blue{
        background-color:#BEEDE8;
    }
    yellow{
        background-color:#FFFF99;
    }
    red{
        background-color:#FF99AC;
    }
</style>

</head>
<body>
<table summary='blob content' class='blob' cellspacing="15">
<tr><td align="right"><pre><code_line>1.<br>2.<br>3.<br>4.<br>5.<br>6.<br>7.<br>8.<br>9.<br>10.<br>11.<br>12.<br>13.<br>14.<br>15.<br>16.<br>17.<br>18.<br>19.<br>20.<br>21.<br>22.<br>23.<br>24.<br>25.<br>26.<br>27.<br>28.<br>29.<br>30.<br>31.<br>32.<br>33.<br>34.<br>35.<br>36.<br>37.<br>38.<br>39.<br>40.<br>41.<br>42.<br>43.<br>44.<br>45.<br>46.<br>47.<br>48.<br>49.<br>50.<br>51.<br>52.<br>53.<br>54.<br>55.<br>56.<br>57.<br>58.<br>59.<br>60.<br>61.<br>62.<br>63.<br>64.<br>65.<br>66.<br>67.<br>68.<br>69.<br>70.<br>71.<br>72.<br>73.<br>74.<br>75.<br>76.<br>77.<br>78.<br>79.<br>80.<br>81.<br>82.<br>83.<br>84.<br>85.<br>86.<br>87.<br>88.<br>89.<br>90.<br>91.<br>92.<br>93.<br>94.<br>95.<br>96.<br>97.<br>98.<br>99.<br>100.<br>101.<br>102.<br>103.<br>104.<br>105.<br>106.<br>107.<br>108.<br>109.<br>110.<br>111.<br>112.<br>113.<br>114.<br>115.<br>116.<br>117.<br>118.<br>119.<br>120.<br>121.<br>122.<br>123.<br>124.<br>125.<br>126.<br>127.<br>128.<br>129.<br>130.<br>131.<br>132.<br>133.<br>134.<br>135.<br>136.<br>137.<br>138.<br>139.<br>140.<br>141.<br>142.<br>143.<br>144.<br>145.<br>146.<br>147.<br>148.<br>149.<br>150.<br>151.<br>152.<br>153.<br>154.<br>155.<br>156.<br>157.<br>158.<br>159.<br>160.<br>161.<br>162.<br>163.<br>164.<br>165.<br>166.<br>167.<br>168.<br>169.<br>170.<br>171.<br>172.<br>173.<br>174.<br>175.<br>176.<br>177.<br>178.<br>179.<br>180.<br>181.<br>182.<br>183.<br>184.<br>185.<br>186.<br>187.<br>188.<br>189.<br>190.<br>191.<br>192.<br>193.<br>194.<br>195.<br>196.<br>197.<br>198.<br>199.<br>200.<br>201.<br>202.<br>203.<br>204.<br>205.<br>206.<br>207.<br>208.<br>209.<br>210.<br>211.<br>212.<br>213.<br>214.<br>215.<br>216.<br>217.<br>218.<br>219.<br>220.<br>221.<br>222.<br>223.<br>224.<br>225.<br>226.<br>227.<br>228.<br>229.<br>230.<br>231.<br>232.<br>233.<br>234.<br>235.<br>236.<br>237.<br>238.<br>239.<br>240.<br>241.<br>242.<br>243.<br>244.<br>245.<br>246.<br>247.<br>248.<br>249.<br>250.<br>251.<br>252.<br>253.<br>254.<br>255.<br>256.<br>257.<br>258.<br>259.<br>260.<br>261.<br>262.<br>263.<br>264.<br>265.<br>266.<br>267.<br>268.<br>269.<br>270.<br>271.<br>272.<br>273.<br>274.<br>275.<br>276.<br>277.<br>278.<br>279.<br>280.<br>281.<br>282.<br>283.<br>284.<br>285.<br>286.<br>287.<br>288.<br>289.<br>290.<br>291.<br>292.<br>293.<br>294.<br>295.<br>296.<br>297.<br>298.<br>299.<br>300.<br>301.<br>302.<br>303.<br>304.<br>305.<br>306.<br>307.<br>308.<br>309.<br>310.<br>311.<br>312.<br>313.<br>314.<br>315.<br>316.<br>317.<br>318.<br>319.<br>320.<br>321.<br>322.<br>323.<br>324.<br>325.<br>326.<br>327.<br>328.<br>329.<br>330.<br>331.<br>332.<br>333.<br>334.<br>335.<br>336.<br>337.<br>338.<br>339.<br>340.<br>341.<br>342.<br>343.<br>344.<br>345.<br>346.<br>347.<br>348.<br>349.<br>350.<br>351.<br>352.<br>353.<br>354.<br>355.<br>356.<br>357.<br>358.<br>359.<br>360.<br>361.<br>362.<br>363.<br>364.<br>365.<br>366.<br>367.<br>368.<br>369.<br>370.<br>371.<br>372.<br>373.<br>374.<br>375.<br>376.<br>377.<br>378.<br>379.<br>380.<br>381.<br>382.<br>383.<br>384.<br>385.<br>386.<br>387.<br>388.<br>389.<br>390.<br>391.<br>392.<br>393.<br>394.<br>395.<br>396.<br>397.<br>398.<br>399.<br>400.<br>401.<br>402.<br>403.<br>404.<br>405.<br>406.<br>407.<br>408.<br>409.<br>410.<br>411.<br>412.<br>413.<br>414.<br>415.<br>416.<br>417.<br>418.<br>419.<br>420.<br>421.<br>422.<br>423.<br>424.<br>425.<br>426.<br>427.<br>428.<br>429.<br>430.<br>431.<br>432.<br>433.<br>434.<br>435.<br>436.<br>437.<br>438.<br>439.<br>440.<br>441.<br>442.<br>443.<br>444.<br>445.<br>446.<br>447.<br>448.<br>449.<br>450.<br>451.<br>452.<br>453.<br>454.<br>455.<br>456.<br>457.<br>458.<br>459.<br>460.<br>461.<br>462.<br>463.<br>464.<br>465.<br>466.<br>467.<br>468.<br>469.<br>470.<br>471.<br>472.<br>473.<br>474.<br>475.<br>476.<br>477.<br>478.<br>479.<br>480.<br>481.<br>482.<br>483.<br>484.<br>485.<br>486.<br>487.<br>488.<br>489.<br>490.<br>491.<br>492.<br>493.<br>494.<br>495.<br>496.<br>497.<br></code_line></pre></td>
<td class='lines'><pre><code class="prettyprint">// SPDX-License-Identifier: GPL-2.0
/*  Copyright(c) 2021 Intel Corporation. */

#include &lt;asm/sgx.h&gt;

#include &quot;cpuid.h&quot;
#include &quot;kvm_cache_regs.h&quot;
#include &quot;nested.h&quot;
#include &quot;sgx.h&quot;
#include &quot;vmx.h&quot;
#include &quot;x86.h&quot;

bool __read_mostly enable_sgx = 1;
module_param_named(sgx, enable_sgx, bool, 0444);

/* Initial value of guest&#x27;s virtual SGX_LEPUBKEYHASHn MSRs */
static u64 sgx_pubkey_hash[4] __ro_after_init;

/*
 * ENCLS&#x27;s memory operands use a fixed segment (DS) and a fixed
 * address size based on the mode.  Related prefixes are ignored.
 */
static int sgx_get_encls_gva(struct kvm_vcpu *vcpu, unsigned long offset,
			     int size, int alignment, gva_t *gva)
<yellow>{</yellow>
	struct kvm_segment s;
	bool fault;

	/* Skip vmcs.GUEST_DS retrieval for 64-bit mode to avoid VMREADs. */
<yellow>	*gva = offset;</yellow>
	if (!is_long_mode(vcpu)) {
<yellow>		vmx_get_segment(vcpu, &s, VCPU_SREG_DS);</yellow>
		*gva += s.base;
	}

<yellow>	if (!IS_ALIGNED(*gva, alignment)) {</yellow>
		fault = true;
<yellow>	} else if (likely(is_long_mode(vcpu))) {</yellow>
<yellow>		fault = is_noncanonical_address(*gva, vcpu);</yellow>
	} else {
<yellow>		*gva &= 0xffffffff;</yellow>
		fault = (s.unusable) ||
<yellow>			(s.type != 2 && s.type != 3) ||</yellow>
<yellow>			(*gva > s.limit) ||</yellow>
<yellow>			((s.base != 0 || s.limit != 0xffffffff) &&</yellow>
<yellow>			(((u64)*gva + size - 1) > s.limit + 1));</yellow>
	}
	if (fault)
<yellow>		kvm_inject_gp(vcpu, 0);</yellow>
	return fault ? -EINVAL : 0;
}

static void sgx_handle_emulation_failure(struct kvm_vcpu *vcpu, u64 addr,
					 unsigned int size)
{
<yellow>	uint64_t data[2] = { addr, size };</yellow>

<yellow>	__kvm_prepare_emulation_failure_exit(vcpu, data, ARRAY_SIZE(data));</yellow>
}

static int sgx_read_hva(struct kvm_vcpu *vcpu, unsigned long hva, void *data,
			unsigned int size)
{
	if (__copy_from_user(data, (void __user *)hva, size)) {
<yellow>		sgx_handle_emulation_failure(vcpu, hva, size);</yellow>
		return -EFAULT;
	}

	return 0;
}

static int sgx_gva_to_gpa(struct kvm_vcpu *vcpu, gva_t gva, bool write,
			  gpa_t *gpa)
{
	struct x86_exception ex;

	if (write)
		*gpa = kvm_mmu_gva_to_gpa_write(vcpu, gva, &amp;ex);
	else
<yellow>		*gpa = kvm_mmu_gva_to_gpa_read(vcpu, gva, &ex);</yellow>

	if (*gpa == INVALID_GPA) {
<yellow>		kvm_inject_emulated_page_fault(vcpu, &ex);</yellow>
		return -EFAULT;
	}

	return 0;
}

<yellow>static int sgx_gpa_to_hva(struct kvm_vcpu *vcpu, gpa_t gpa, unsigned long *hva)</yellow>
{
<yellow>	*hva = kvm_vcpu_gfn_to_hva(vcpu, PFN_DOWN(gpa));</yellow>
	if (kvm_is_error_hva(*hva)) {
<yellow>		sgx_handle_emulation_failure(vcpu, gpa, 1);</yellow>
		return -EFAULT;
	}

<yellow>	*hva |= gpa & ~PAGE_MASK;</yellow>

	return 0;
}

static int sgx_inject_fault(struct kvm_vcpu *vcpu, gva_t gva, int trapnr)
<yellow>{</yellow>
	struct x86_exception ex;

	/*
	 * A non-EPCM #PF indicates a bad userspace HVA.  This *should* check
	 * for PFEC.SGX and not assume any #PF on SGX2 originated in the EPC,
	 * but the error code isn&#x27;t (yet) plumbed through the ENCLS helpers.
	 */
<yellow>	if (trapnr == PF_VECTOR && !boot_cpu_has(X86_FEATURE_SGX2)) {</yellow>
<yellow>		kvm_prepare_emulation_failure_exit(vcpu);</yellow>
		return 0;
	}

	/*
	 * If the guest thinks it&#x27;s running on SGX2 hardware, inject an SGX
	 * #PF if the fault matches an EPCM fault signature (#GP on SGX1,
	 * #PF on SGX2).  The assumption is that EPCM faults are much more
	 * likely than a bad userspace address.
	 */
<yellow>	if ((trapnr == PF_VECTOR || !boot_cpu_has(X86_FEATURE_SGX2)) &&</yellow>
<yellow>	    guest_cpuid_has(vcpu, X86_FEATURE_SGX2)) {</yellow>
<yellow>		memset(&ex, 0, sizeof(ex));</yellow>
		ex.vector = PF_VECTOR;
		ex.error_code = PFERR_PRESENT_MASK | PFERR_WRITE_MASK |
				PFERR_SGX_MASK;
		ex.address = gva;
		ex.error_code_valid = true;
		ex.nested_page_fault = false;
		kvm_inject_emulated_page_fault(vcpu, &amp;ex);
	} else {
<yellow>		kvm_inject_gp(vcpu, 0);</yellow>
	}
	return 1;
}

static int __handle_encls_ecreate(struct kvm_vcpu *vcpu,
				  struct sgx_pageinfo *pageinfo,
				  unsigned long secs_hva,
				  gva_t secs_gva)
{
	struct sgx_secs *contents = (struct sgx_secs *)pageinfo-&gt;contents;
	struct kvm_cpuid_entry2 *sgx_12_0, *sgx_12_1;
	u64 attributes, xfrm, size;
	u32 miscselect;
	u8 max_size_log2;
	int trapnr, ret;

	sgx_12_0 = kvm_find_cpuid_entry_index(vcpu, 0x12, 0);
	sgx_12_1 = kvm_find_cpuid_entry_index(vcpu, 0x12, 1);
<yellow>	if (!sgx_12_0 || !sgx_12_1) {</yellow>
<yellow>		kvm_prepare_emulation_failure_exit(vcpu);</yellow>
		return 0;
	}

<yellow>	miscselect = contents->miscselect;</yellow>
	attributes = contents-&gt;attributes;
	xfrm = contents-&gt;xfrm;
	size = contents-&gt;size;

	/* Enforce restriction of access to the PROVISIONKEY. */
<yellow>	if (!vcpu->kvm->arch.sgx_provisioning_allowed &&</yellow>
<yellow>	    (attributes & SGX_ATTR_PROVISIONKEY)) {</yellow>
<yellow>		if (sgx_12_1->eax & SGX_ATTR_PROVISIONKEY)</yellow>
<yellow>			pr_warn_once("KVM: SGX PROVISIONKEY advertised but not allowed\n");</yellow>
<yellow>		kvm_inject_gp(vcpu, 0);</yellow>
		return 1;
	}

	/* Enforce CPUID restrictions on MISCSELECT, ATTRIBUTES and XFRM. */
<yellow>	if ((u32)miscselect & ~sgx_12_0->ebx ||</yellow>
<yellow>	    (u32)attributes & ~sgx_12_1->eax ||</yellow>
<yellow>	    (u32)(attributes >> 32) & ~sgx_12_1->ebx ||</yellow>
<yellow>	    (u32)xfrm & ~sgx_12_1->ecx ||</yellow>
<yellow>	    (u32)(xfrm >> 32) & ~sgx_12_1->edx) {</yellow>
		kvm_inject_gp(vcpu, 0);
		return 1;
	}

	/* Enforce CPUID restriction on max enclave size. */
<yellow>	max_size_log2 = (attributes & SGX_ATTR_MODE64BIT) ? sgx_12_0->edx >> 8 :</yellow>
							    sgx_12_0-&gt;edx;
<yellow>	if (size >= BIT_ULL(max_size_log2))</yellow>
<yellow>		kvm_inject_gp(vcpu, 0);</yellow>

	/*
	 * sgx_virt_ecreate() returns:
	 *  1) 0:	ECREATE was successful
	 *  2) -EFAULT:	ECREATE was run but faulted, and trapnr was set to the
	 *		exception number.
	 *  3) -EINVAL:	access_ok() on @secs_hva failed. This should never
	 *		happen as KVM checks host addresses at memslot creation.
	 *		sgx_virt_ecreate() has already warned in this case.
	 */
	ret = sgx_virt_ecreate(pageinfo, (void __user *)secs_hva, &amp;trapnr);
	if (!ret)
<yellow>		return kvm_skip_emulated_instruction(vcpu);</yellow>
<yellow>	if (ret == -EFAULT)</yellow>
<yellow>		return sgx_inject_fault(vcpu, secs_gva, trapnr);</yellow>

	return ret;
}

static int handle_encls_ecreate(struct kvm_vcpu *vcpu)
<yellow>{</yellow>
	gva_t pageinfo_gva, secs_gva;
	gva_t metadata_gva, contents_gva;
	gpa_t metadata_gpa, contents_gpa, secs_gpa;
	unsigned long metadata_hva, contents_hva, secs_hva;
	struct sgx_pageinfo pageinfo;
	struct sgx_secs *contents;
	struct x86_exception ex;
	int r;

<yellow>	if (sgx_get_encls_gva(vcpu, kvm_rbx_read(vcpu), 32, 32, &pageinfo_gva) ||</yellow>
<yellow>	    sgx_get_encls_gva(vcpu, kvm_rcx_read(vcpu), 4096, 4096, &secs_gva))</yellow>
		return 1;

	/*
	 * Copy the PAGEINFO to local memory, its pointers need to be
	 * translated, i.e. we need to do a deep copy/translate.
	 */
<yellow>	r = kvm_read_guest_virt(vcpu, pageinfo_gva, &pageinfo,</yellow>
				sizeof(pageinfo), &amp;ex);
	if (r == X86EMUL_PROPAGATE_FAULT) {
<yellow>		kvm_inject_emulated_page_fault(vcpu, &ex);</yellow>
		return 1;
<yellow>	} else if (r != X86EMUL_CONTINUE) {</yellow>
<yellow>		sgx_handle_emulation_failure(vcpu, pageinfo_gva,</yellow>
					     sizeof(pageinfo));
		return 0;
	}

<yellow>	if (sgx_get_encls_gva(vcpu, pageinfo.metadata, 64, 64, &metadata_gva) ||</yellow>
<yellow>	    sgx_get_encls_gva(vcpu, pageinfo.contents, 4096, 4096,</yellow>
			      &amp;contents_gva))
		return 1;

	/*
	 * Translate the SECINFO, SOURCE and SECS pointers from GVA to GPA.
	 * Resume the guest on failure to inject a #PF.
	 */
<yellow>	if (sgx_gva_to_gpa(vcpu, metadata_gva, false, &metadata_gpa) ||</yellow>
<yellow>	    sgx_gva_to_gpa(vcpu, contents_gva, false, &contents_gpa) ||</yellow>
<yellow>	    sgx_gva_to_gpa(vcpu, secs_gva, true, &secs_gpa))</yellow>
		return 1;

	/*
	 * ...and then to HVA.  The order of accesses isn&#x27;t architectural, i.e.
	 * KVM doesn&#x27;t have to fully process one address at a time.  Exit to
	 * userspace if a GPA is invalid.
	 */
<yellow>	if (sgx_gpa_to_hva(vcpu, metadata_gpa, &metadata_hva) ||</yellow>
<yellow>	    sgx_gpa_to_hva(vcpu, contents_gpa, &contents_hva) ||</yellow>
<yellow>	    sgx_gpa_to_hva(vcpu, secs_gpa, &secs_hva))</yellow>
		return 0;

	/*
	 * Copy contents into kernel memory to prevent TOCTOU attack. E.g. the
	 * guest could do ECREATE w/ SECS.SGX_ATTR_PROVISIONKEY=0, and
	 * simultaneously set SGX_ATTR_PROVISIONKEY to bypass the check to
	 * enforce restriction of access to the PROVISIONKEY.
	 */
<yellow>	contents = (struct sgx_secs *)__get_free_page(GFP_KERNEL_ACCOUNT);</yellow>
	if (!contents)
		return -ENOMEM;

	/* Exit to userspace if copying from a host userspace address fails. */
<yellow>	if (sgx_read_hva(vcpu, contents_hva, (void *)contents, PAGE_SIZE)) {</yellow>
		free_page((unsigned long)contents);
		return 0;
	}

	pageinfo.metadata = metadata_hva;
	pageinfo.contents = (u64)contents;

<yellow>	r = __handle_encls_ecreate(vcpu, &pageinfo, secs_hva, secs_gva);</yellow>

<yellow>	free_page((unsigned long)contents);</yellow>

	return r;
}

static int handle_encls_einit(struct kvm_vcpu *vcpu)
{
	unsigned long sig_hva, secs_hva, token_hva, rflags;
	struct vcpu_vmx *vmx = to_vmx(vcpu);
	gva_t sig_gva, secs_gva, token_gva;
	gpa_t sig_gpa, secs_gpa, token_gpa;
	int ret, trapnr;

<yellow>	if (sgx_get_encls_gva(vcpu, kvm_rbx_read(vcpu), 1808, 4096, &sig_gva) ||</yellow>
<yellow>	    sgx_get_encls_gva(vcpu, kvm_rcx_read(vcpu), 4096, 4096, &secs_gva) ||</yellow>
<yellow>	    sgx_get_encls_gva(vcpu, kvm_rdx_read(vcpu), 304, 512, &token_gva))</yellow>
		return 1;

	/*
	 * Translate the SIGSTRUCT, SECS and TOKEN pointers from GVA to GPA.
	 * Resume the guest on failure to inject a #PF.
	 */
<yellow>	if (sgx_gva_to_gpa(vcpu, sig_gva, false, &sig_gpa) ||</yellow>
<yellow>	    sgx_gva_to_gpa(vcpu, secs_gva, true, &secs_gpa) ||</yellow>
<yellow>	    sgx_gva_to_gpa(vcpu, token_gva, false, &token_gpa))</yellow>
		return 1;

	/*
	 * ...and then to HVA.  The order of accesses isn&#x27;t architectural, i.e.
	 * KVM doesn&#x27;t have to fully process one address at a time.  Exit to
	 * userspace if a GPA is invalid.  Note, all structures are aligned and
	 * cannot split pages.
	 */
<yellow>	if (sgx_gpa_to_hva(vcpu, sig_gpa, &sig_hva) ||</yellow>
<yellow>	    sgx_gpa_to_hva(vcpu, secs_gpa, &secs_hva) ||</yellow>
<yellow>	    sgx_gpa_to_hva(vcpu, token_gpa, &token_hva))</yellow>
		return 0;

	ret = sgx_virt_einit((void __user *)sig_hva, (void __user *)token_hva,
			     (void __user *)secs_hva,
			     vmx-&gt;msr_ia32_sgxlepubkeyhash, &amp;trapnr);

	if (ret == -EFAULT)
<yellow>		return sgx_inject_fault(vcpu, secs_gva, trapnr);</yellow>

	/*
	 * sgx_virt_einit() returns -EINVAL when access_ok() fails on @sig_hva,
	 * @token_hva or @secs_hva. This should never happen as KVM checks host
	 * addresses at memslot creation. sgx_virt_einit() has already warned
	 * in this case, so just return.
	 */
<yellow>	if (ret < 0)</yellow>
		return ret;

<yellow>	rflags = vmx_get_rflags(vcpu) & ~(X86_EFLAGS_CF | X86_EFLAGS_PF |</yellow>
					  X86_EFLAGS_AF | X86_EFLAGS_SF |
					  X86_EFLAGS_OF);
	if (ret)
		rflags |= X86_EFLAGS_ZF;
	else
<yellow>		rflags &= ~X86_EFLAGS_ZF;</yellow>
<yellow>	vmx_set_rflags(vcpu, rflags);</yellow>

	kvm_rax_write(vcpu, ret);
	return kvm_skip_emulated_instruction(vcpu);
}

static inline bool encls_leaf_enabled_in_guest(struct kvm_vcpu *vcpu, u32 leaf)
{
<yellow>	if (!enable_sgx || !guest_cpuid_has(vcpu, X86_FEATURE_SGX))</yellow>
		return false;

<yellow>	if (leaf >= ECREATE && leaf <= ETRACK)</yellow>
<yellow>		return guest_cpuid_has(vcpu, X86_FEATURE_SGX1);</yellow>

<yellow>	if (leaf >= EAUG && leaf <= EMODT)</yellow>
<yellow>		return guest_cpuid_has(vcpu, X86_FEATURE_SGX2);</yellow>

	return false;
}

static inline bool sgx_enabled_in_guest_bios(struct kvm_vcpu *vcpu)
{
	const u64 bits = FEAT_CTL_SGX_ENABLED | FEAT_CTL_LOCKED;

<yellow>	return (to_vmx(vcpu)->msr_ia32_feature_control & bits) == bits;</yellow>
}

int handle_encls(struct kvm_vcpu *vcpu)
<yellow>{</yellow>
<yellow>	u32 leaf = (u32)kvm_rax_read(vcpu);</yellow>

<yellow>	if (!encls_leaf_enabled_in_guest(vcpu, leaf)) {</yellow>
<yellow>		kvm_queue_exception(vcpu, UD_VECTOR);</yellow>
<yellow>	} else if (!sgx_enabled_in_guest_bios(vcpu)) {</yellow>
<yellow>		kvm_inject_gp(vcpu, 0);</yellow>
	} else {
<yellow>		if (leaf == ECREATE)</yellow>
<yellow>			return handle_encls_ecreate(vcpu);</yellow>
<yellow>		if (leaf == EINIT)</yellow>
<yellow>			return handle_encls_einit(vcpu);</yellow>
<yellow>		WARN(1, "KVM: unexpected exit on ENCLS[%u]", leaf);</yellow>
		vcpu-&gt;run-&gt;exit_reason = KVM_EXIT_UNKNOWN;
		vcpu-&gt;run-&gt;hw.hardware_exit_reason = EXIT_REASON_ENCLS;
		return 0;
	}
	return 1;
}

void setup_default_sgx_lepubkeyhash(void)
{
	/*
	 * Use Intel&#x27;s default value for Skylake hardware if Launch Control is
	 * not supported, i.e. Intel&#x27;s hash is hardcoded into silicon, or if
	 * Launch Control is supported and enabled, i.e. mimic the reset value
	 * and let the guest write the MSRs at will.  If Launch Control is
	 * supported but disabled, then use the current MSR values as the hash
	 * MSRs exist but are read-only (locked and not writable).
	 */
<yellow>	if (!enable_sgx || boot_cpu_has(X86_FEATURE_SGX_LC) ||</yellow>
<yellow>	    rdmsrl_safe(MSR_IA32_SGXLEPUBKEYHASH0, &sgx_pubkey_hash[0])) {</yellow>
<yellow>		sgx_pubkey_hash[0] = 0xa6053e051270b7acULL;</yellow>
		sgx_pubkey_hash[1] = 0x6cfbe8ba8b3b413dULL;
		sgx_pubkey_hash[2] = 0xc4916d99f2b3735dULL;
<yellow>		sgx_pubkey_hash[3] = 0xd4f8c05909f9bb3bULL;</yellow>
	} else {
		/* MSR_IA32_SGXLEPUBKEYHASH0 is read above */
<yellow>		rdmsrl(MSR_IA32_SGXLEPUBKEYHASH1, sgx_pubkey_hash[1]);</yellow>
		rdmsrl(MSR_IA32_SGXLEPUBKEYHASH2, sgx_pubkey_hash[2]);
		rdmsrl(MSR_IA32_SGXLEPUBKEYHASH3, sgx_pubkey_hash[3]);
	}
}

void vcpu_setup_sgx_lepubkeyhash(struct kvm_vcpu *vcpu)
{
	struct vcpu_vmx *vmx = to_vmx(vcpu);

<blue>	memcpy(vmx->msr_ia32_sgxlepubkeyhash, sgx_pubkey_hash,</blue>
	       sizeof(sgx_pubkey_hash));
}

/*
 * ECREATE must be intercepted to enforce MISCSELECT, ATTRIBUTES and XFRM
 * restrictions if the guest&#x27;s allowed-1 settings diverge from hardware.
 */
static bool sgx_intercept_encls_ecreate(struct kvm_vcpu *vcpu)
{
	struct kvm_cpuid_entry2 *guest_cpuid;
	u32 eax, ebx, ecx, edx;

<yellow>	if (!vcpu->kvm->arch.sgx_provisioning_allowed)</yellow>
		return true;

<yellow>	guest_cpuid = kvm_find_cpuid_entry_index(vcpu, 0x12, 0);</yellow>
	if (!guest_cpuid)
		return true;

<yellow>	cpuid_count(0x12, 0, &eax, &ebx, &ecx, &edx);</yellow>
<yellow>	if (guest_cpuid->ebx != ebx || guest_cpuid->edx != edx)</yellow>
		return true;

<yellow>	guest_cpuid = kvm_find_cpuid_entry_index(vcpu, 0x12, 1);</yellow>
	if (!guest_cpuid)
		return true;

<yellow>	cpuid_count(0x12, 1, &eax, &ebx, &ecx, &edx);</yellow>
<yellow>	if (guest_cpuid->eax != eax || guest_cpuid->ebx != ebx ||</yellow>
<yellow>	    guest_cpuid->ecx != ecx || guest_cpuid->edx != edx)</yellow>
		return true;

	return false;
}

void vmx_write_encls_bitmap(struct kvm_vcpu *vcpu, struct vmcs12 *vmcs12)
<blue>{</blue>
	/*
	 * There is no software enable bit for SGX that is virtualized by
	 * hardware, e.g. there&#x27;s no CR4.SGXE, so when SGX is disabled in the
	 * guest (either by the host or by the guest&#x27;s BIOS) but enabled in the
	 * host, trap all ENCLS leafs and inject #UD/#GP as needed to emulate
	 * the expected system behavior for ENCLS.
	 */
	u64 bitmap = -1ull;

	/* Nothing to do if hardware doesn&#x27;t support SGX */
<blue>	if (!cpu_has_vmx_encls_vmexit())</blue>
		return;

<yellow>	if (guest_cpuid_has(vcpu, X86_FEATURE_SGX) &&</yellow>
<yellow>	    sgx_enabled_in_guest_bios(vcpu)) {</yellow>
<yellow>		if (guest_cpuid_has(vcpu, X86_FEATURE_SGX1)) {</yellow>
<yellow>			bitmap &= ~GENMASK_ULL(ETRACK, ECREATE);</yellow>
<yellow>			if (sgx_intercept_encls_ecreate(vcpu))</yellow>
<yellow>				bitmap |= (1 << ECREATE);</yellow>
		}

<yellow>		if (guest_cpuid_has(vcpu, X86_FEATURE_SGX2))</yellow>
<yellow>			bitmap &= ~GENMASK_ULL(EMODT, EAUG);</yellow>

		/*
		 * Trap and execute EINIT if launch control is enabled in the
		 * host using the guest&#x27;s values for launch control MSRs, even
		 * if the guest&#x27;s values are fixed to hardware default values.
		 * The MSRs are not loaded/saved on VM-Enter/VM-Exit as writing
		 * the MSRs is extraordinarily expensive.
		 */
<yellow>		if (boot_cpu_has(X86_FEATURE_SGX_LC))</yellow>
<yellow>			bitmap |= (1 << EINIT);</yellow>

<yellow>		if (!vmcs12 && is_guest_mode(vcpu))</yellow>
<yellow>			vmcs12 = get_vmcs12(vcpu);</yellow>
<yellow>		if (vmcs12 && nested_cpu_has_encls_exit(vmcs12))</yellow>
<yellow>			bitmap |= vmcs12->encls_exiting_bitmap;</yellow>
	}
<yellow>	vmcs_write64(ENCLS_EXITING_BITMAP, bitmap);</yellow>
}


</code></pre></td></tr></table>
</body>
</html>
