<doctype html>
<html lang="ja">
<head><title>eventfd.c</title><meta charset="utf-8">
<script src="https://cdn.rawgit.com/google/code-prettify/master/loader/run_prettify.js"></script>
<style>
    code{
        font-family:Monaco, Menlo, Consolas, 'Courier New', Courier, monospace, sans-serif;
        font-size: 14px;
        line-height: 18px;
        overflow: auto;
        resize: horizontal;
    }
    code_line{
        font-family: Monaco, Menlo, Consolas, 'Courier New', Courier, monospace, sans-serif;;
        font-size: 14px;
        line-height: 18px;
        overflow: auto;
        resize: horizontal;
        color:#303134;
    }
    blue{
        background-color:#BEEDE8;
    }
    yellow{
        background-color:#FFFF99;
    }
    red{
        background-color:#FF99AC;
    }
      .split {
         height: 100%;
         position: fixed;
         z-index: 1;
         top: 0;
         overflow-x: hidden;
      }

      .tree {
         left: 0;
         width: 20%;
      }

      .right {
         border-left: 2px solid #444;
         right: 0;
         width: 80%;
         /* font-family: 'Courier New', Courier, monospace;
				color: rgb(80, 80, 80); */
      }
</style>

</head>
<body>
   <div class="split tree">
      <ul id="file_list">
      </ul>
   </div>
   <div class="split right">
<table summary='blob content' class='blob' cellspacing="15">
<tr><td align="right"><pre><code_line><script>for (let i = 1; i <= 984; i++){
         document.write(i+".\n");
   }
         </script></code_line></pre></td>
<td class='lines'><pre><code class="prettyprint">// SPDX-License-Identifier: GPL-2.0-only
/*
 * kvm eventfd support - use eventfd objects to signal various KVM events
 *
 * Copyright 2009 Novell.  All Rights Reserved.
 * Copyright 2010 Red Hat, Inc. and/or its affiliates.
 *
 * Author:
 *	Gregory Haskins &lt;ghaskins@novell.com&gt;
 */

#include &lt;linux/kvm_host.h&gt;
#include &lt;linux/kvm.h&gt;
#include &lt;linux/kvm_irqfd.h&gt;
#include &lt;linux/workqueue.h&gt;
#include &lt;linux/syscalls.h&gt;
#include &lt;linux/wait.h&gt;
#include &lt;linux/poll.h&gt;
#include &lt;linux/file.h&gt;
#include &lt;linux/list.h&gt;
#include &lt;linux/eventfd.h&gt;
#include &lt;linux/kernel.h&gt;
#include &lt;linux/srcu.h&gt;
#include &lt;linux/slab.h&gt;
#include &lt;linux/seqlock.h&gt;
#include &lt;linux/irqbypass.h&gt;
#include &lt;trace/events/kvm.h&gt;

#include &lt;kvm/iodev.h&gt;

#ifdef CONFIG_HAVE_KVM_IRQFD

static struct workqueue_struct *irqfd_cleanup_wq;

bool __attribute__((weak))
kvm_arch_irqfd_allowed(struct kvm *kvm, struct kvm_irqfd *args)
{
	return true;
}

static void
irqfd_inject(struct work_struct *work)
{
	struct kvm_kernel_irqfd *irqfd =
		container_of(work, struct kvm_kernel_irqfd, inject);
	struct kvm *kvm = irqfd-&gt;kvm;

	if (!irqfd-&gt;resampler) {
		kvm_set_irq(kvm, KVM_USERSPACE_IRQ_SOURCE_ID, irqfd-&gt;gsi, 1,
				false);
		kvm_set_irq(kvm, KVM_USERSPACE_IRQ_SOURCE_ID, irqfd-&gt;gsi, 0,
				false);
	} else
		kvm_set_irq(kvm, KVM_IRQFD_RESAMPLE_IRQ_SOURCE_ID,
			    irqfd-&gt;gsi, 1, false);
}

/*
 * Since resampler irqfds share an IRQ source ID, we de-assert once
 * then notify all of the resampler irqfds using this GSI.  We can&#x27;t
 * do multiple de-asserts or we risk racing with incoming re-asserts.
 */
static void
irqfd_resampler_ack(struct kvm_irq_ack_notifier *kian)
{
	struct kvm_kernel_irqfd_resampler *resampler;
	struct kvm *kvm;
	struct kvm_kernel_irqfd *irqfd;
	int idx;

	resampler = container_of(kian,
			struct kvm_kernel_irqfd_resampler, notifier);
	kvm = resampler-&gt;kvm;

	kvm_set_irq(kvm, KVM_IRQFD_RESAMPLE_IRQ_SOURCE_ID,
		    resampler-&gt;notifier.gsi, 0, false);

	idx = srcu_read_lock(&amp;kvm-&gt;irq_srcu);

	list_for_each_entry_srcu(irqfd, &amp;resampler-&gt;list, resampler_link,
	    srcu_read_lock_held(&amp;kvm-&gt;irq_srcu))
		eventfd_signal(irqfd-&gt;resamplefd, 1);

	srcu_read_unlock(&amp;kvm-&gt;irq_srcu, idx);
}

static void
irqfd_resampler_shutdown(struct kvm_kernel_irqfd *irqfd)
{
	struct kvm_kernel_irqfd_resampler *resampler = irqfd-&gt;resampler;
	struct kvm *kvm = resampler-&gt;kvm;

	mutex_lock(&amp;kvm-&gt;irqfds.resampler_lock);

	list_del_rcu(&amp;irqfd-&gt;resampler_link);
	synchronize_srcu(&amp;kvm-&gt;irq_srcu);

	if (list_empty(&amp;resampler-&gt;list)) {
		list_del(&amp;resampler-&gt;link);
		kvm_unregister_irq_ack_notifier(kvm, &amp;resampler-&gt;notifier);
		kvm_set_irq(kvm, KVM_IRQFD_RESAMPLE_IRQ_SOURCE_ID,
			    resampler-&gt;notifier.gsi, 0, false);
		kfree(resampler);
	}

	mutex_unlock(&amp;kvm-&gt;irqfds.resampler_lock);
}

/*
 * Race-free decouple logic (ordering is critical)
 */
static void
irqfd_shutdown(struct work_struct *work)
{
	struct kvm_kernel_irqfd *irqfd =
		container_of(work, struct kvm_kernel_irqfd, shutdown);
	struct kvm *kvm = irqfd-&gt;kvm;
	u64 cnt;

	/* Make sure irqfd has been initialized in assign path. */
	synchronize_srcu(&amp;kvm-&gt;irq_srcu);

	/*
	 * Synchronize with the wait-queue and unhook ourselves to prevent
	 * further events.
	 */
	eventfd_ctx_remove_wait_queue(irqfd-&gt;eventfd, &amp;irqfd-&gt;wait, &amp;cnt);

	/*
	 * We know no new events will be scheduled at this point, so block
	 * until all previously outstanding events have completed
	 */
	flush_work(&amp;irqfd-&gt;inject);

	if (irqfd-&gt;resampler) {
		irqfd_resampler_shutdown(irqfd);
		eventfd_ctx_put(irqfd-&gt;resamplefd);
	}

	/*
	 * It is now safe to release the object&#x27;s resources
	 */
#ifdef CONFIG_HAVE_KVM_IRQ_BYPASS
	irq_bypass_unregister_consumer(&amp;irqfd-&gt;consumer);
#endif
	eventfd_ctx_put(irqfd-&gt;eventfd);
	kfree(irqfd);
}


/* assumes kvm-&gt;irqfds.lock is held */
static bool
irqfd_is_active(struct kvm_kernel_irqfd *irqfd)
{
	return list_empty(&amp;irqfd-&gt;list) ? false : true;
}

/*
 * Mark the irqfd as inactive and schedule it for removal
 *
 * assumes kvm-&gt;irqfds.lock is held
 */
static void
irqfd_deactivate(struct kvm_kernel_irqfd *irqfd)
{
	BUG_ON(!irqfd_is_active(irqfd));

	list_del_init(&amp;irqfd-&gt;list);

	queue_work(irqfd_cleanup_wq, &amp;irqfd-&gt;shutdown);
}

int __attribute__((weak)) kvm_arch_set_irq_inatomic(
				struct kvm_kernel_irq_routing_entry *irq,
				struct kvm *kvm, int irq_source_id,
				int level,
				bool line_status)
{
	return -EWOULDBLOCK;
}

/*
 * Called with wqh-&gt;lock held and interrupts disabled
 */
static int
irqfd_wakeup(wait_queue_entry_t *wait, unsigned mode, int sync, void *key)
{
	struct kvm_kernel_irqfd *irqfd =
		container_of(wait, struct kvm_kernel_irqfd, wait);
	__poll_t flags = key_to_poll(key);
	struct kvm_kernel_irq_routing_entry irq;
	struct kvm *kvm = irqfd-&gt;kvm;
	unsigned seq;
	int idx;
	int ret = 0;

	if (flags &amp; EPOLLIN) {
		u64 cnt;
		eventfd_ctx_do_read(irqfd-&gt;eventfd, &amp;cnt);

		idx = srcu_read_lock(&amp;kvm-&gt;irq_srcu);
		do {
			seq = read_seqcount_begin(&amp;irqfd-&gt;irq_entry_sc);
			irq = irqfd-&gt;irq_entry;
		} while (read_seqcount_retry(&amp;irqfd-&gt;irq_entry_sc, seq));
		/* An event has been signaled, inject an interrupt */
		if (kvm_arch_set_irq_inatomic(&amp;irq, kvm,
					      KVM_USERSPACE_IRQ_SOURCE_ID, 1,
					      false) == -EWOULDBLOCK)
			schedule_work(&amp;irqfd-&gt;inject);
		srcu_read_unlock(&amp;kvm-&gt;irq_srcu, idx);
		ret = 1;
	}

	if (flags &amp; EPOLLHUP) {
		/* The eventfd is closing, detach from KVM */
		unsigned long iflags;

		spin_lock_irqsave(&amp;kvm-&gt;irqfds.lock, iflags);

		/*
		 * We must check if someone deactivated the irqfd before
		 * we could acquire the irqfds.lock since the item is
		 * deactivated from the KVM side before it is unhooked from
		 * the wait-queue.  If it is already deactivated, we can
		 * simply return knowing the other side will cleanup for us.
		 * We cannot race against the irqfd going away since the
		 * other side is required to acquire wqh-&gt;lock, which we hold
		 */
		if (irqfd_is_active(irqfd))
			irqfd_deactivate(irqfd);

		spin_unlock_irqrestore(&amp;kvm-&gt;irqfds.lock, iflags);
	}

	return ret;
}

static void
irqfd_ptable_queue_proc(struct file *file, wait_queue_head_t *wqh,
			poll_table *pt)
{
	struct kvm_kernel_irqfd *irqfd =
		container_of(pt, struct kvm_kernel_irqfd, pt);
	add_wait_queue_priority(wqh, &amp;irqfd-&gt;wait);
}

/* Must be called under irqfds.lock */
static void irqfd_update(struct kvm *kvm, struct kvm_kernel_irqfd *irqfd)
{
	struct kvm_kernel_irq_routing_entry *e;
	struct kvm_kernel_irq_routing_entry entries[KVM_NR_IRQCHIPS];
	int n_entries;

	n_entries = kvm_irq_map_gsi(kvm, entries, irqfd-&gt;gsi);

	write_seqcount_begin(&amp;irqfd-&gt;irq_entry_sc);

	e = entries;
	if (n_entries == 1)
		irqfd-&gt;irq_entry = *e;
	else
		irqfd-&gt;irq_entry.type = 0;

	write_seqcount_end(&amp;irqfd-&gt;irq_entry_sc);
}

#ifdef CONFIG_HAVE_KVM_IRQ_BYPASS
void __attribute__((weak)) kvm_arch_irq_bypass_stop(
				struct irq_bypass_consumer *cons)
{
}

void __attribute__((weak)) kvm_arch_irq_bypass_start(
				struct irq_bypass_consumer *cons)
{
}

int  __attribute__((weak)) kvm_arch_update_irqfd_routing(
				struct kvm *kvm, unsigned int host_irq,
				uint32_t guest_irq, bool set)
{
	return 0;
}

bool __attribute__((weak)) kvm_arch_irqfd_route_changed(
				struct kvm_kernel_irq_routing_entry *old,
				struct kvm_kernel_irq_routing_entry *new)
{
	return true;
}
#endif

static int
kvm_irqfd_assign(struct kvm *kvm, struct kvm_irqfd *args)
{
	struct kvm_kernel_irqfd *irqfd, *tmp;
	struct fd f;
	struct eventfd_ctx *eventfd = NULL, *resamplefd = NULL;
	int ret;
	__poll_t events;
	int idx;

	if (!kvm_arch_intc_initialized(kvm))
		return -EAGAIN;

	if (!kvm_arch_irqfd_allowed(kvm, args))
		return -EINVAL;

	irqfd = kzalloc(sizeof(*irqfd), GFP_KERNEL_ACCOUNT);
	if (!irqfd)
		return -ENOMEM;

	irqfd-&gt;kvm = kvm;
	irqfd-&gt;gsi = args-&gt;gsi;
	INIT_LIST_HEAD(&amp;irqfd-&gt;list);
	INIT_WORK(&amp;irqfd-&gt;inject, irqfd_inject);
	INIT_WORK(&amp;irqfd-&gt;shutdown, irqfd_shutdown);
	seqcount_spinlock_init(&amp;irqfd-&gt;irq_entry_sc, &amp;kvm-&gt;irqfds.lock);

	f = fdget(args-&gt;fd);
	if (!f.file) {
		ret = -EBADF;
		goto out;
	}

	eventfd = eventfd_ctx_fileget(f.file);
	if (IS_ERR(eventfd)) {
		ret = PTR_ERR(eventfd);
		goto fail;
	}

	irqfd-&gt;eventfd = eventfd;

	if (args-&gt;flags &amp; KVM_IRQFD_FLAG_RESAMPLE) {
		struct kvm_kernel_irqfd_resampler *resampler;

		resamplefd = eventfd_ctx_fdget(args-&gt;resamplefd);
		if (IS_ERR(resamplefd)) {
			ret = PTR_ERR(resamplefd);
			goto fail;
		}

		irqfd-&gt;resamplefd = resamplefd;
		INIT_LIST_HEAD(&amp;irqfd-&gt;resampler_link);

		mutex_lock(&amp;kvm-&gt;irqfds.resampler_lock);

		list_for_each_entry(resampler,
				    &amp;kvm-&gt;irqfds.resampler_list, link) {
			if (resampler-&gt;notifier.gsi == irqfd-&gt;gsi) {
				irqfd-&gt;resampler = resampler;
				break;
			}
		}

		if (!irqfd-&gt;resampler) {
			resampler = kzalloc(sizeof(*resampler),
					    GFP_KERNEL_ACCOUNT);
			if (!resampler) {
				ret = -ENOMEM;
				mutex_unlock(&amp;kvm-&gt;irqfds.resampler_lock);
				goto fail;
			}

			resampler-&gt;kvm = kvm;
			INIT_LIST_HEAD(&amp;resampler-&gt;list);
			resampler-&gt;notifier.gsi = irqfd-&gt;gsi;
			resampler-&gt;notifier.irq_acked = irqfd_resampler_ack;
			INIT_LIST_HEAD(&amp;resampler-&gt;link);

			list_add(&amp;resampler-&gt;link, &amp;kvm-&gt;irqfds.resampler_list);
			kvm_register_irq_ack_notifier(kvm,
						      &amp;resampler-&gt;notifier);
			irqfd-&gt;resampler = resampler;
		}

		list_add_rcu(&amp;irqfd-&gt;resampler_link, &amp;irqfd-&gt;resampler-&gt;list);
		synchronize_srcu(&amp;kvm-&gt;irq_srcu);

		mutex_unlock(&amp;kvm-&gt;irqfds.resampler_lock);
	}

	/*
	 * Install our own custom wake-up handling so we are notified via
	 * a callback whenever someone signals the underlying eventfd
	 */
	init_waitqueue_func_entry(&amp;irqfd-&gt;wait, irqfd_wakeup);
	init_poll_funcptr(&amp;irqfd-&gt;pt, irqfd_ptable_queue_proc);

	spin_lock_irq(&amp;kvm-&gt;irqfds.lock);

	ret = 0;
	list_for_each_entry(tmp, &amp;kvm-&gt;irqfds.items, list) {
		if (irqfd-&gt;eventfd != tmp-&gt;eventfd)
			continue;
		/* This fd is used for another irq already. */
		ret = -EBUSY;
		spin_unlock_irq(&amp;kvm-&gt;irqfds.lock);
		goto fail;
	}

	idx = srcu_read_lock(&amp;kvm-&gt;irq_srcu);
	irqfd_update(kvm, irqfd);

	list_add_tail(&amp;irqfd-&gt;list, &amp;kvm-&gt;irqfds.items);

	spin_unlock_irq(&amp;kvm-&gt;irqfds.lock);

	/*
	 * Check if there was an event already pending on the eventfd
	 * before we registered, and trigger it as if we didn&#x27;t miss it.
	 */
	events = vfs_poll(f.file, &amp;irqfd-&gt;pt);

	if (events &amp; EPOLLIN)
		schedule_work(&amp;irqfd-&gt;inject);

#ifdef CONFIG_HAVE_KVM_IRQ_BYPASS
	if (kvm_arch_has_irq_bypass()) {
		irqfd-&gt;consumer.token = (void *)irqfd-&gt;eventfd;
		irqfd-&gt;consumer.add_producer = kvm_arch_irq_bypass_add_producer;
		irqfd-&gt;consumer.del_producer = kvm_arch_irq_bypass_del_producer;
		irqfd-&gt;consumer.stop = kvm_arch_irq_bypass_stop;
		irqfd-&gt;consumer.start = kvm_arch_irq_bypass_start;
		ret = irq_bypass_register_consumer(&amp;irqfd-&gt;consumer);
		if (ret)
			pr_info(&quot;irq bypass consumer (token %p) registration fails: %d\n&quot;,
				irqfd-&gt;consumer.token, ret);
	}
#endif

	srcu_read_unlock(&amp;kvm-&gt;irq_srcu, idx);

	/*
	 * do not drop the file until the irqfd is fully initialized, otherwise
	 * we might race against the EPOLLHUP
	 */
	fdput(f);
	return 0;

fail:
	if (irqfd-&gt;resampler)
		irqfd_resampler_shutdown(irqfd);

	if (resamplefd &amp;&amp; !IS_ERR(resamplefd))
		eventfd_ctx_put(resamplefd);

	if (eventfd &amp;&amp; !IS_ERR(eventfd))
		eventfd_ctx_put(eventfd);

	fdput(f);

out:
	kfree(irqfd);
	return ret;
}

bool kvm_irq_has_notifier(struct kvm *kvm, unsigned irqchip, unsigned pin)
{
	struct kvm_irq_ack_notifier *kian;
	int gsi, idx;

<blue>	idx = srcu_read_lock(&kvm->irq_srcu);</blue>
	gsi = kvm_irq_map_chip_pin(kvm, irqchip, pin);
	if (gsi != -1)
<blue>		hlist_for_each_entry_srcu(kian, &kvm->irq_ack_notifier_list,</blue>
					  link, srcu_read_lock_held(&amp;kvm-&gt;irq_srcu))
<blue>			if (kian->gsi == gsi) {</blue>
<blue>				srcu_read_unlock(&kvm->irq_srcu, idx);</blue>
				return true;
			}

<blue>	srcu_read_unlock(&kvm->irq_srcu, idx);</blue>

	return false;
<blue>}</blue>
EXPORT_SYMBOL_GPL(kvm_irq_has_notifier);

void kvm_notify_acked_gsi(struct kvm *kvm, int gsi)
{
	struct kvm_irq_ack_notifier *kian;

<blue>	hlist_for_each_entry_srcu(kian, &kvm->irq_ack_notifier_list,</blue>
				  link, srcu_read_lock_held(&amp;kvm-&gt;irq_srcu))
<blue>		if (kian->gsi == gsi)</blue>
<blue>			kian->irq_acked(kian);</blue>
}

void kvm_notify_acked_irq(struct kvm *kvm, unsigned irqchip, unsigned pin)
{
	int gsi, idx;

<blue>	trace_kvm_ack_irq(irqchip, pin);</blue>

<blue>	idx = srcu_read_lock(&kvm->irq_srcu);</blue>
	gsi = kvm_irq_map_chip_pin(kvm, irqchip, pin);
	if (gsi != -1)
<blue>		kvm_notify_acked_gsi(kvm, gsi);</blue>
<blue>	srcu_read_unlock(&kvm->irq_srcu, idx);</blue>
}

void kvm_register_irq_ack_notifier(struct kvm *kvm,
				   struct kvm_irq_ack_notifier *kian)
{
	mutex_lock(&amp;kvm-&gt;irq_lock);
	hlist_add_head_rcu(&amp;kian-&gt;link, &amp;kvm-&gt;irq_ack_notifier_list);
	mutex_unlock(&amp;kvm-&gt;irq_lock);
	kvm_arch_post_irq_ack_notifier_list_update(kvm);
}

void kvm_unregister_irq_ack_notifier(struct kvm *kvm,
				    struct kvm_irq_ack_notifier *kian)
{
	mutex_lock(&amp;kvm-&gt;irq_lock);
	hlist_del_init_rcu(&amp;kian-&gt;link);
	mutex_unlock(&amp;kvm-&gt;irq_lock);
	synchronize_srcu(&amp;kvm-&gt;irq_srcu);
	kvm_arch_post_irq_ack_notifier_list_update(kvm);
}
#endif

void
kvm_eventfd_init(struct kvm *kvm)
{
#ifdef CONFIG_HAVE_KVM_IRQFD
<blue>	spin_lock_init(&kvm->irqfds.lock);</blue>
	INIT_LIST_HEAD(&amp;kvm-&gt;irqfds.items);
	INIT_LIST_HEAD(&amp;kvm-&gt;irqfds.resampler_list);
	mutex_init(&amp;kvm-&gt;irqfds.resampler_lock);
#endif
	INIT_LIST_HEAD(&amp;kvm-&gt;ioeventfds);
}

#ifdef CONFIG_HAVE_KVM_IRQFD
/*
 * shutdown any irqfd&#x27;s that match fd+gsi
 */
static int
kvm_irqfd_deassign(struct kvm *kvm, struct kvm_irqfd *args)
{
	struct kvm_kernel_irqfd *irqfd, *tmp;
	struct eventfd_ctx *eventfd;

	eventfd = eventfd_ctx_fdget(args-&gt;fd);
	if (IS_ERR(eventfd))
		return PTR_ERR(eventfd);

	spin_lock_irq(&amp;kvm-&gt;irqfds.lock);

	list_for_each_entry_safe(irqfd, tmp, &amp;kvm-&gt;irqfds.items, list) {
		if (irqfd-&gt;eventfd == eventfd &amp;&amp; irqfd-&gt;gsi == args-&gt;gsi) {
			/*
			 * This clearing of irq_entry.type is needed for when
			 * another thread calls kvm_irq_routing_update before
			 * we flush workqueue below (we synchronize with
			 * kvm_irq_routing_update using irqfds.lock).
			 */
			write_seqcount_begin(&amp;irqfd-&gt;irq_entry_sc);
			irqfd-&gt;irq_entry.type = 0;
			write_seqcount_end(&amp;irqfd-&gt;irq_entry_sc);
			irqfd_deactivate(irqfd);
		}
	}

	spin_unlock_irq(&amp;kvm-&gt;irqfds.lock);
	eventfd_ctx_put(eventfd);

	/*
	 * Block until we know all outstanding shutdown jobs have completed
	 * so that we guarantee there will not be any more interrupts on this
	 * gsi once this deassign function returns.
	 */
	flush_workqueue(irqfd_cleanup_wq);

	return 0;
}

int
kvm_irqfd(struct kvm *kvm, struct kvm_irqfd *args)
{
	if (args-&gt;flags &amp; ~(KVM_IRQFD_FLAG_DEASSIGN | KVM_IRQFD_FLAG_RESAMPLE))
		return -EINVAL;

	if (args-&gt;flags &amp; KVM_IRQFD_FLAG_DEASSIGN)
		return kvm_irqfd_deassign(kvm, args);

	return kvm_irqfd_assign(kvm, args);
}

/*
 * This function is called as the kvm VM fd is being released. Shutdown all
 * irqfds that still remain open
 */
void
kvm_irqfd_release(struct kvm *kvm)
{
	struct kvm_kernel_irqfd *irqfd, *tmp;

	spin_lock_irq(&amp;kvm-&gt;irqfds.lock);

	list_for_each_entry_safe(irqfd, tmp, &amp;kvm-&gt;irqfds.items, list)
		irqfd_deactivate(irqfd);

	spin_unlock_irq(&amp;kvm-&gt;irqfds.lock);

	/*
	 * Block until we know all outstanding shutdown jobs have completed
	 * since we do not take a kvm* reference.
	 */
	flush_workqueue(irqfd_cleanup_wq);

}

/*
 * Take note of a change in irq routing.
 * Caller must invoke synchronize_srcu(&amp;kvm-&gt;irq_srcu) afterwards.
 */
void kvm_irq_routing_update(struct kvm *kvm)
{
	struct kvm_kernel_irqfd *irqfd;

<blue>	spin_lock_irq(&kvm->irqfds.lock);</blue>

	list_for_each_entry(irqfd, &amp;kvm-&gt;irqfds.items, list) {
#ifdef CONFIG_HAVE_KVM_IRQ_BYPASS
		/* Under irqfds.lock, so can read irq_entry safely */
		struct kvm_kernel_irq_routing_entry old = irqfd-&gt;irq_entry;
#endif

		irqfd_update(kvm, irqfd);

#ifdef CONFIG_HAVE_KVM_IRQ_BYPASS
		if (irqfd-&gt;producer &amp;&amp;
		    kvm_arch_irqfd_route_changed(&amp;old, &amp;irqfd-&gt;irq_entry)) {
			int ret = kvm_arch_update_irqfd_routing(
					irqfd-&gt;kvm, irqfd-&gt;producer-&gt;irq,
					irqfd-&gt;gsi, 1);
			WARN_ON(ret);
		}
#endif
	}

<blue>	spin_unlock_irq(&kvm->irqfds.lock);</blue>
}

/*
 * create a host-wide workqueue for issuing deferred shutdown requests
 * aggregated from all vm* instances. We need our own isolated
 * queue to ease flushing work items when a VM exits.
 */
int kvm_irqfd_init(void)
{
	irqfd_cleanup_wq = alloc_workqueue(&quot;kvm-irqfd-cleanup&quot;, 0, 0);
	if (!irqfd_cleanup_wq)
		return -ENOMEM;

	return 0;
}

void kvm_irqfd_exit(void)
{
	destroy_workqueue(irqfd_cleanup_wq);
}
#endif

/*
 * --------------------------------------------------------------------
 * ioeventfd: translate a PIO/MMIO memory write to an eventfd signal.
 *
 * userspace can register a PIO/MMIO address with an eventfd for receiving
 * notification when the memory has been touched.
 * --------------------------------------------------------------------
 */

struct _ioeventfd {
	struct list_head     list;
	u64                  addr;
	int                  length;
	struct eventfd_ctx  *eventfd;
	u64                  datamatch;
	struct kvm_io_device dev;
	u8                   bus_idx;
	bool                 wildcard;
};

static inline struct _ioeventfd *
to_ioeventfd(struct kvm_io_device *dev)
{
	return container_of(dev, struct _ioeventfd, dev);
}

static void
ioeventfd_release(struct _ioeventfd *p)
{
<blue>	eventfd_ctx_put(p->eventfd);</blue>
<blue>	list_del(&p->list);</blue>
	kfree(p);
}

static bool
ioeventfd_in_range(struct _ioeventfd *p, gpa_t addr, int len, const void *val)
{
	u64 _val;

	if (addr != p-&gt;addr)
		/* address must be precise for a hit */
		return false;

	if (!p-&gt;length)
		/* length = 0 means only look at the address, so always a hit */
		return true;

	if (len != p-&gt;length)
		/* address-range must be precise for a hit */
		return false;

	if (p-&gt;wildcard)
		/* all else equal, wildcard is always a hit */
		return true;

	/* otherwise, we have to actually compare the data */

	BUG_ON(!IS_ALIGNED((unsigned long)val, len));

	switch (len) {
	case 1:
		_val = *(u8 *)val;
		break;
	case 2:
		_val = *(u16 *)val;
		break;
	case 4:
		_val = *(u32 *)val;
		break;
	case 8:
		_val = *(u64 *)val;
		break;
	default:
		return false;
	}

	return _val == p-&gt;datamatch;
}

/* MMIO/PIO writes trigger an event if the addr/val match */
static int
ioeventfd_write(struct kvm_vcpu *vcpu, struct kvm_io_device *this, gpa_t addr,
		int len, const void *val)
{
	struct _ioeventfd *p = to_ioeventfd(this);

	if (!ioeventfd_in_range(p, addr, len, val))
		return -EOPNOTSUPP;

	eventfd_signal(p-&gt;eventfd, 1);
	return 0;
}

/*
 * This function is called as KVM is completely shutting down.  We do not
 * need to worry about locking just nuke anything we have as quickly as possible
 */
static void
ioeventfd_destructor(struct kvm_io_device *this)
{
	struct _ioeventfd *p = to_ioeventfd(this);

	ioeventfd_release(p);
}

static const struct kvm_io_device_ops ioeventfd_ops = {
	.write      = ioeventfd_write,
	.destructor = ioeventfd_destructor,
};

/* assumes kvm-&gt;slots_lock held */
static bool
ioeventfd_check_collision(struct kvm *kvm, struct _ioeventfd *p)
{
	struct _ioeventfd *_p;

<blue>	list_for_each_entry(_p, &kvm->ioeventfds, list)</blue>
<blue>		if (_p->bus_idx == p->bus_idx &&</blue>
<blue>		    _p->addr == p->addr &&</blue>
<blue>		    (!_p->length || !p->length ||</blue>
<blue>		     (_p->length == p->length &&</blue>
<blue>		      (_p->wildcard || p->wildcard ||</blue>
<blue>		       _p->datamatch == p->datamatch))))</blue>
			return true;

	return false;
}

static enum kvm_bus ioeventfd_bus_from_flags(__u32 flags)
{
<blue>	if (flags & KVM_IOEVENTFD_FLAG_PIO)</blue>
		return KVM_PIO_BUS;
	if (flags &amp; KVM_IOEVENTFD_FLAG_VIRTIO_CCW_NOTIFY)
		return KVM_VIRTIO_CCW_NOTIFY_BUS;
	return KVM_MMIO_BUS;
}

static int kvm_assign_ioeventfd_idx(struct kvm *kvm,
				enum kvm_bus bus_idx,
				struct kvm_ioeventfd *args)
{

	struct eventfd_ctx *eventfd;
	struct _ioeventfd *p;
	int ret;

<blue>	eventfd = eventfd_ctx_fdget(args->fd);</blue>
	if (IS_ERR(eventfd))
		return PTR_ERR(eventfd);

<blue>	p = kzalloc(sizeof(*p), GFP_KERNEL_ACCOUNT);</blue>
	if (!p) {
		ret = -ENOMEM;
		goto fail;
	}

<blue>	INIT_LIST_HEAD(&p->list);</blue>
	p-&gt;addr    = args-&gt;addr;
	p-&gt;bus_idx = bus_idx;
	p-&gt;length  = args-&gt;len;
	p-&gt;eventfd = eventfd;

	/* The datamatch feature is optional, otherwise this is a wildcard */
	if (args-&gt;flags &amp; KVM_IOEVENTFD_FLAG_DATAMATCH)
<blue>		p->datamatch = args->datamatch;</blue>
	else
		p-&gt;wildcard = true;

<blue>	mutex_lock(&kvm->slots_lock);</blue>

	/* Verify that there isn&#x27;t a match already */
<blue>	if (ioeventfd_check_collision(kvm, p)) {</blue>
		ret = -EEXIST;
		goto unlock_fail;
	}

<blue>	kvm_iodevice_init(&p->dev, &ioeventfd_ops);</blue>

<blue>	ret = kvm_io_bus_register_dev(kvm, bus_idx, p->addr, p->length,</blue>
				      &amp;p-&gt;dev);
	if (ret &lt; 0)
		goto unlock_fail;

<blue>	kvm_get_bus(kvm, bus_idx)->ioeventfd_count++;</blue>
<blue>	list_add_tail(&p->list, &kvm->ioeventfds);</blue>

<blue>	mutex_unlock(&kvm->slots_lock);</blue>

	return 0;

unlock_fail:
	mutex_unlock(&amp;kvm-&gt;slots_lock);

fail:
	kfree(p);
	eventfd_ctx_put(eventfd);

	return ret;
<blue>}</blue>

static int
kvm_deassign_ioeventfd_idx(struct kvm *kvm, enum kvm_bus bus_idx,
			   struct kvm_ioeventfd *args)
{
	struct _ioeventfd        *p, *tmp;
	struct eventfd_ctx       *eventfd;
	struct kvm_io_bus	 *bus;
	int                       ret = -ENOENT;
	bool                      wildcard;

<blue>	eventfd = eventfd_ctx_fdget(args->fd);</blue>
	if (IS_ERR(eventfd))
		return PTR_ERR(eventfd);

<blue>	wildcard = !(args->flags & KVM_IOEVENTFD_FLAG_DATAMATCH);</blue>

	mutex_lock(&amp;kvm-&gt;slots_lock);

<blue>	list_for_each_entry_safe(p, tmp, &kvm->ioeventfds, list) {</blue>

<blue>		if (p->bus_idx != bus_idx ||</blue>
<blue>		    p->eventfd != eventfd  ||</blue>
<blue>		    p->addr != args->addr  ||</blue>
<blue>		    p->length != args->len ||</blue>
<blue>		    p->wildcard != wildcard)</blue>
			continue;

<blue>		if (!p->wildcard && p->datamatch != args->datamatch)</blue>
			continue;

<blue>		kvm_io_bus_unregister_dev(kvm, bus_idx, &p->dev);</blue>
		bus = kvm_get_bus(kvm, bus_idx);
<blue>		if (bus)</blue>
<blue>			bus->ioeventfd_count--;</blue>
<blue>		ioeventfd_release(p);</blue>
		ret = 0;
		break;
	}

<blue>	mutex_unlock(&kvm->slots_lock);</blue>

	eventfd_ctx_put(eventfd);

	return ret;
<blue>}</blue>

static int kvm_deassign_ioeventfd(struct kvm *kvm, struct kvm_ioeventfd *args)
{
<blue>	enum kvm_bus bus_idx = ioeventfd_bus_from_flags(args->flags);</blue>
<blue>	int ret = kvm_deassign_ioeventfd_idx(kvm, bus_idx, args);</blue>

	if (!args-&gt;len &amp;&amp; bus_idx == KVM_MMIO_BUS)
		kvm_deassign_ioeventfd_idx(kvm, KVM_FAST_MMIO_BUS, args);

	return ret;
}

static int
kvm_assign_ioeventfd(struct kvm *kvm, struct kvm_ioeventfd *args)
{
	enum kvm_bus              bus_idx;
	int ret;

<blue>	bus_idx = ioeventfd_bus_from_flags(args->flags);</blue>
	/* must be natural-word sized, or 0 to ignore length */
<blue>	switch (args->len) {</blue>
	case 0:
	case 1:
	case 2:
	case 4:
	case 8:
		break;
	default:
		return -EINVAL;
	}

	/* check for range overflow */
<blue>	if (args->addr + args->len < args->addr)</blue>
		return -EINVAL;

	/* check for extra flags that we don&#x27;t understand */
<blue>	if (args->flags & ~KVM_IOEVENTFD_VALID_FLAG_MASK)</blue>
		return -EINVAL;

	/* ioeventfd with no length can&#x27;t be combined with DATAMATCH */
<blue>	if (!args->len && (args->flags & KVM_IOEVENTFD_FLAG_DATAMATCH))</blue>
		return -EINVAL;

<blue>	ret = kvm_assign_ioeventfd_idx(kvm, bus_idx, args);</blue>
	if (ret)
		goto fail;

	/* When length is ignored, MMIO is also put on a separate bus, for
	 * faster lookups.
	 */
<blue>	if (!args->len && bus_idx == KVM_MMIO_BUS) {</blue>
		ret = kvm_assign_ioeventfd_idx(kvm, KVM_FAST_MMIO_BUS, args);
		if (ret &lt; 0)
			goto fast_fail;
	}

	return 0;

fast_fail:
	kvm_deassign_ioeventfd_idx(kvm, bus_idx, args);
fail:
	return ret;
}

int
kvm_ioeventfd(struct kvm *kvm, struct kvm_ioeventfd *args)
{
<blue>	if (args->flags & KVM_IOEVENTFD_FLAG_DEASSIGN)</blue>
<blue>		return kvm_deassign_ioeventfd(kvm, args);</blue>

<blue>	return kvm_assign_ioeventfd(kvm, args);</blue>
<blue>}</blue>


</code></pre></td></tr></table>
</div><script>const fileList = document.getElementById('file_list')
fileList.innerHTML+=`<li><a href="/kvm_coverage/coverage/linux/arch/x86/kvm/mmu/mmu.c.html">mmu.c 45.7%</li>`
fileList.innerHTML+=`<li><a href="/kvm_coverage/coverage/linux/arch/x86/kvm/vmx/nested.c.html">nested.c 75.0%</li>`
fileList.innerHTML+=`<li><a href="/kvm_coverage/coverage/linux/arch/x86/kvm/vmx/vmx.c.html">vmx.c 50.3%</li>`
fileList.innerHTML+=`<li><a href="/kvm_coverage/coverage/linux/arch/x86/kvm/x86.c.html">x86.c 47.6%</li>`
</script></body></html>