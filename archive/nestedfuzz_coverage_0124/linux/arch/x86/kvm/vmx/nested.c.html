<doctype html>
<html lang="ja">
<head>
<meta charset="utf-8">
<script src="https://cdn.rawgit.com/google/code-prettify/master/loader/run_prettify.js"></script>
<style>
    code{
        font-family:Monaco, Menlo, Consolas, 'Courier New', Courier, monospace, sans-serif;
        font-size: 14px;
        line-height: 18px;
        overflow: auto;
        resize: horizontal;
    }
    code_line{
        font-family: Monaco, Menlo, Consolas, 'Courier New', Courier, monospace, sans-serif;;
        font-size: 14px;
        line-height: 18px;
        overflow: auto;
        resize: horizontal;
        color:#303134;
    }
    blue{
        background-color:#BEEDE8;
    }
    yellow{
        background-color:#FFFF99;
    }
    red{
        background-color:#FF99AC;
    }
</style>

</head>
<body>
<table summary='blob content' class='blob' cellspacing="15">
<tr><td align="right"><pre><code_line>1.<br>2.<br>3.<br>4.<br>5.<br>6.<br>7.<br>8.<br>9.<br>10.<br>11.<br>12.<br>13.<br>14.<br>15.<br>16.<br>17.<br>18.<br>19.<br>20.<br>21.<br>22.<br>23.<br>24.<br>25.<br>26.<br>27.<br>28.<br>29.<br>30.<br>31.<br>32.<br>33.<br>34.<br>35.<br>36.<br>37.<br>38.<br>39.<br>40.<br>41.<br>42.<br>43.<br>44.<br>45.<br>46.<br>47.<br>48.<br>49.<br>50.<br>51.<br>52.<br>53.<br>54.<br>55.<br>56.<br>57.<br>58.<br>59.<br>60.<br>61.<br>62.<br>63.<br>64.<br>65.<br>66.<br>67.<br>68.<br>69.<br>70.<br>71.<br>72.<br>73.<br>74.<br>75.<br>76.<br>77.<br>78.<br>79.<br>80.<br>81.<br>82.<br>83.<br>84.<br>85.<br>86.<br>87.<br>88.<br>89.<br>90.<br>91.<br>92.<br>93.<br>94.<br>95.<br>96.<br>97.<br>98.<br>99.<br>100.<br>101.<br>102.<br>103.<br>104.<br>105.<br>106.<br>107.<br>108.<br>109.<br>110.<br>111.<br>112.<br>113.<br>114.<br>115.<br>116.<br>117.<br>118.<br>119.<br>120.<br>121.<br>122.<br>123.<br>124.<br>125.<br>126.<br>127.<br>128.<br>129.<br>130.<br>131.<br>132.<br>133.<br>134.<br>135.<br>136.<br>137.<br>138.<br>139.<br>140.<br>141.<br>142.<br>143.<br>144.<br>145.<br>146.<br>147.<br>148.<br>149.<br>150.<br>151.<br>152.<br>153.<br>154.<br>155.<br>156.<br>157.<br>158.<br>159.<br>160.<br>161.<br>162.<br>163.<br>164.<br>165.<br>166.<br>167.<br>168.<br>169.<br>170.<br>171.<br>172.<br>173.<br>174.<br>175.<br>176.<br>177.<br>178.<br>179.<br>180.<br>181.<br>182.<br>183.<br>184.<br>185.<br>186.<br>187.<br>188.<br>189.<br>190.<br>191.<br>192.<br>193.<br>194.<br>195.<br>196.<br>197.<br>198.<br>199.<br>200.<br>201.<br>202.<br>203.<br>204.<br>205.<br>206.<br>207.<br>208.<br>209.<br>210.<br>211.<br>212.<br>213.<br>214.<br>215.<br>216.<br>217.<br>218.<br>219.<br>220.<br>221.<br>222.<br>223.<br>224.<br>225.<br>226.<br>227.<br>228.<br>229.<br>230.<br>231.<br>232.<br>233.<br>234.<br>235.<br>236.<br>237.<br>238.<br>239.<br>240.<br>241.<br>242.<br>243.<br>244.<br>245.<br>246.<br>247.<br>248.<br>249.<br>250.<br>251.<br>252.<br>253.<br>254.<br>255.<br>256.<br>257.<br>258.<br>259.<br>260.<br>261.<br>262.<br>263.<br>264.<br>265.<br>266.<br>267.<br>268.<br>269.<br>270.<br>271.<br>272.<br>273.<br>274.<br>275.<br>276.<br>277.<br>278.<br>279.<br>280.<br>281.<br>282.<br>283.<br>284.<br>285.<br>286.<br>287.<br>288.<br>289.<br>290.<br>291.<br>292.<br>293.<br>294.<br>295.<br>296.<br>297.<br>298.<br>299.<br>300.<br>301.<br>302.<br>303.<br>304.<br>305.<br>306.<br>307.<br>308.<br>309.<br>310.<br>311.<br>312.<br>313.<br>314.<br>315.<br>316.<br>317.<br>318.<br>319.<br>320.<br>321.<br>322.<br>323.<br>324.<br>325.<br>326.<br>327.<br>328.<br>329.<br>330.<br>331.<br>332.<br>333.<br>334.<br>335.<br>336.<br>337.<br>338.<br>339.<br>340.<br>341.<br>342.<br>343.<br>344.<br>345.<br>346.<br>347.<br>348.<br>349.<br>350.<br>351.<br>352.<br>353.<br>354.<br>355.<br>356.<br>357.<br>358.<br>359.<br>360.<br>361.<br>362.<br>363.<br>364.<br>365.<br>366.<br>367.<br>368.<br>369.<br>370.<br>371.<br>372.<br>373.<br>374.<br>375.<br>376.<br>377.<br>378.<br>379.<br>380.<br>381.<br>382.<br>383.<br>384.<br>385.<br>386.<br>387.<br>388.<br>389.<br>390.<br>391.<br>392.<br>393.<br>394.<br>395.<br>396.<br>397.<br>398.<br>399.<br>400.<br>401.<br>402.<br>403.<br>404.<br>405.<br>406.<br>407.<br>408.<br>409.<br>410.<br>411.<br>412.<br>413.<br>414.<br>415.<br>416.<br>417.<br>418.<br>419.<br>420.<br>421.<br>422.<br>423.<br>424.<br>425.<br>426.<br>427.<br>428.<br>429.<br>430.<br>431.<br>432.<br>433.<br>434.<br>435.<br>436.<br>437.<br>438.<br>439.<br>440.<br>441.<br>442.<br>443.<br>444.<br>445.<br>446.<br>447.<br>448.<br>449.<br>450.<br>451.<br>452.<br>453.<br>454.<br>455.<br>456.<br>457.<br>458.<br>459.<br>460.<br>461.<br>462.<br>463.<br>464.<br>465.<br>466.<br>467.<br>468.<br>469.<br>470.<br>471.<br>472.<br>473.<br>474.<br>475.<br>476.<br>477.<br>478.<br>479.<br>480.<br>481.<br>482.<br>483.<br>484.<br>485.<br>486.<br>487.<br>488.<br>489.<br>490.<br>491.<br>492.<br>493.<br>494.<br>495.<br>496.<br>497.<br>498.<br>499.<br>500.<br>501.<br>502.<br>503.<br>504.<br>505.<br>506.<br>507.<br>508.<br>509.<br>510.<br>511.<br>512.<br>513.<br>514.<br>515.<br>516.<br>517.<br>518.<br>519.<br>520.<br>521.<br>522.<br>523.<br>524.<br>525.<br>526.<br>527.<br>528.<br>529.<br>530.<br>531.<br>532.<br>533.<br>534.<br>535.<br>536.<br>537.<br>538.<br>539.<br>540.<br>541.<br>542.<br>543.<br>544.<br>545.<br>546.<br>547.<br>548.<br>549.<br>550.<br>551.<br>552.<br>553.<br>554.<br>555.<br>556.<br>557.<br>558.<br>559.<br>560.<br>561.<br>562.<br>563.<br>564.<br>565.<br>566.<br>567.<br>568.<br>569.<br>570.<br>571.<br>572.<br>573.<br>574.<br>575.<br>576.<br>577.<br>578.<br>579.<br>580.<br>581.<br>582.<br>583.<br>584.<br>585.<br>586.<br>587.<br>588.<br>589.<br>590.<br>591.<br>592.<br>593.<br>594.<br>595.<br>596.<br>597.<br>598.<br>599.<br>600.<br>601.<br>602.<br>603.<br>604.<br>605.<br>606.<br>607.<br>608.<br>609.<br>610.<br>611.<br>612.<br>613.<br>614.<br>615.<br>616.<br>617.<br>618.<br>619.<br>620.<br>621.<br>622.<br>623.<br>624.<br>625.<br>626.<br>627.<br>628.<br>629.<br>630.<br>631.<br>632.<br>633.<br>634.<br>635.<br>636.<br>637.<br>638.<br>639.<br>640.<br>641.<br>642.<br>643.<br>644.<br>645.<br>646.<br>647.<br>648.<br>649.<br>650.<br>651.<br>652.<br>653.<br>654.<br>655.<br>656.<br>657.<br>658.<br>659.<br>660.<br>661.<br>662.<br>663.<br>664.<br>665.<br>666.<br>667.<br>668.<br>669.<br>670.<br>671.<br>672.<br>673.<br>674.<br>675.<br>676.<br>677.<br>678.<br>679.<br>680.<br>681.<br>682.<br>683.<br>684.<br>685.<br>686.<br>687.<br>688.<br>689.<br>690.<br>691.<br>692.<br>693.<br>694.<br>695.<br>696.<br>697.<br>698.<br>699.<br>700.<br>701.<br>702.<br>703.<br>704.<br>705.<br>706.<br>707.<br>708.<br>709.<br>710.<br>711.<br>712.<br>713.<br>714.<br>715.<br>716.<br>717.<br>718.<br>719.<br>720.<br>721.<br>722.<br>723.<br>724.<br>725.<br>726.<br>727.<br>728.<br>729.<br>730.<br>731.<br>732.<br>733.<br>734.<br>735.<br>736.<br>737.<br>738.<br>739.<br>740.<br>741.<br>742.<br>743.<br>744.<br>745.<br>746.<br>747.<br>748.<br>749.<br>750.<br>751.<br>752.<br>753.<br>754.<br>755.<br>756.<br>757.<br>758.<br>759.<br>760.<br>761.<br>762.<br>763.<br>764.<br>765.<br>766.<br>767.<br>768.<br>769.<br>770.<br>771.<br>772.<br>773.<br>774.<br>775.<br>776.<br>777.<br>778.<br>779.<br>780.<br>781.<br>782.<br>783.<br>784.<br>785.<br>786.<br>787.<br>788.<br>789.<br>790.<br>791.<br>792.<br>793.<br>794.<br>795.<br>796.<br>797.<br>798.<br>799.<br>800.<br>801.<br>802.<br>803.<br>804.<br>805.<br>806.<br>807.<br>808.<br>809.<br>810.<br>811.<br>812.<br>813.<br>814.<br>815.<br>816.<br>817.<br>818.<br>819.<br>820.<br>821.<br>822.<br>823.<br>824.<br>825.<br>826.<br>827.<br>828.<br>829.<br>830.<br>831.<br>832.<br>833.<br>834.<br>835.<br>836.<br>837.<br>838.<br>839.<br>840.<br>841.<br>842.<br>843.<br>844.<br>845.<br>846.<br>847.<br>848.<br>849.<br>850.<br>851.<br>852.<br>853.<br>854.<br>855.<br>856.<br>857.<br>858.<br>859.<br>860.<br>861.<br>862.<br>863.<br>864.<br>865.<br>866.<br>867.<br>868.<br>869.<br>870.<br>871.<br>872.<br>873.<br>874.<br>875.<br>876.<br>877.<br>878.<br>879.<br>880.<br>881.<br>882.<br>883.<br>884.<br>885.<br>886.<br>887.<br>888.<br>889.<br>890.<br>891.<br>892.<br>893.<br>894.<br>895.<br>896.<br>897.<br>898.<br>899.<br>900.<br>901.<br>902.<br>903.<br>904.<br>905.<br>906.<br>907.<br>908.<br>909.<br>910.<br>911.<br>912.<br>913.<br>914.<br>915.<br>916.<br>917.<br>918.<br>919.<br>920.<br>921.<br>922.<br>923.<br>924.<br>925.<br>926.<br>927.<br>928.<br>929.<br>930.<br>931.<br>932.<br>933.<br>934.<br>935.<br>936.<br>937.<br>938.<br>939.<br>940.<br>941.<br>942.<br>943.<br>944.<br>945.<br>946.<br>947.<br>948.<br>949.<br>950.<br>951.<br>952.<br>953.<br>954.<br>955.<br>956.<br>957.<br>958.<br>959.<br>960.<br>961.<br>962.<br>963.<br>964.<br>965.<br>966.<br>967.<br>968.<br>969.<br>970.<br>971.<br>972.<br>973.<br>974.<br>975.<br>976.<br>977.<br>978.<br>979.<br>980.<br>981.<br>982.<br>983.<br>984.<br>985.<br>986.<br>987.<br>988.<br>989.<br>990.<br>991.<br>992.<br>993.<br>994.<br>995.<br>996.<br>997.<br>998.<br>999.<br>1000.<br>1001.<br>1002.<br>1003.<br>1004.<br>1005.<br>1006.<br>1007.<br>1008.<br>1009.<br>1010.<br>1011.<br>1012.<br>1013.<br>1014.<br>1015.<br>1016.<br>1017.<br>1018.<br>1019.<br>1020.<br>1021.<br>1022.<br>1023.<br>1024.<br>1025.<br>1026.<br>1027.<br>1028.<br>1029.<br>1030.<br>1031.<br>1032.<br>1033.<br>1034.<br>1035.<br>1036.<br>1037.<br>1038.<br>1039.<br>1040.<br>1041.<br>1042.<br>1043.<br>1044.<br>1045.<br>1046.<br>1047.<br>1048.<br>1049.<br>1050.<br>1051.<br>1052.<br>1053.<br>1054.<br>1055.<br>1056.<br>1057.<br>1058.<br>1059.<br>1060.<br>1061.<br>1062.<br>1063.<br>1064.<br>1065.<br>1066.<br>1067.<br>1068.<br>1069.<br>1070.<br>1071.<br>1072.<br>1073.<br>1074.<br>1075.<br>1076.<br>1077.<br>1078.<br>1079.<br>1080.<br>1081.<br>1082.<br>1083.<br>1084.<br>1085.<br>1086.<br>1087.<br>1088.<br>1089.<br>1090.<br>1091.<br>1092.<br>1093.<br>1094.<br>1095.<br>1096.<br>1097.<br>1098.<br>1099.<br>1100.<br>1101.<br>1102.<br>1103.<br>1104.<br>1105.<br>1106.<br>1107.<br>1108.<br>1109.<br>1110.<br>1111.<br>1112.<br>1113.<br>1114.<br>1115.<br>1116.<br>1117.<br>1118.<br>1119.<br>1120.<br>1121.<br>1122.<br>1123.<br>1124.<br>1125.<br>1126.<br>1127.<br>1128.<br>1129.<br>1130.<br>1131.<br>1132.<br>1133.<br>1134.<br>1135.<br>1136.<br>1137.<br>1138.<br>1139.<br>1140.<br>1141.<br>1142.<br>1143.<br>1144.<br>1145.<br>1146.<br>1147.<br>1148.<br>1149.<br>1150.<br>1151.<br>1152.<br>1153.<br>1154.<br>1155.<br>1156.<br>1157.<br>1158.<br>1159.<br>1160.<br>1161.<br>1162.<br>1163.<br>1164.<br>1165.<br>1166.<br>1167.<br>1168.<br>1169.<br>1170.<br>1171.<br>1172.<br>1173.<br>1174.<br>1175.<br>1176.<br>1177.<br>1178.<br>1179.<br>1180.<br>1181.<br>1182.<br>1183.<br>1184.<br>1185.<br>1186.<br>1187.<br>1188.<br>1189.<br>1190.<br>1191.<br>1192.<br>1193.<br>1194.<br>1195.<br>1196.<br>1197.<br>1198.<br>1199.<br>1200.<br>1201.<br>1202.<br>1203.<br>1204.<br>1205.<br>1206.<br>1207.<br>1208.<br>1209.<br>1210.<br>1211.<br>1212.<br>1213.<br>1214.<br>1215.<br>1216.<br>1217.<br>1218.<br>1219.<br>1220.<br>1221.<br>1222.<br>1223.<br>1224.<br>1225.<br>1226.<br>1227.<br>1228.<br>1229.<br>1230.<br>1231.<br>1232.<br>1233.<br>1234.<br>1235.<br>1236.<br>1237.<br>1238.<br>1239.<br>1240.<br>1241.<br>1242.<br>1243.<br>1244.<br>1245.<br>1246.<br>1247.<br>1248.<br>1249.<br>1250.<br>1251.<br>1252.<br>1253.<br>1254.<br>1255.<br>1256.<br>1257.<br>1258.<br>1259.<br>1260.<br>1261.<br>1262.<br>1263.<br>1264.<br>1265.<br>1266.<br>1267.<br>1268.<br>1269.<br>1270.<br>1271.<br>1272.<br>1273.<br>1274.<br>1275.<br>1276.<br>1277.<br>1278.<br>1279.<br>1280.<br>1281.<br>1282.<br>1283.<br>1284.<br>1285.<br>1286.<br>1287.<br>1288.<br>1289.<br>1290.<br>1291.<br>1292.<br>1293.<br>1294.<br>1295.<br>1296.<br>1297.<br>1298.<br>1299.<br>1300.<br>1301.<br>1302.<br>1303.<br>1304.<br>1305.<br>1306.<br>1307.<br>1308.<br>1309.<br>1310.<br>1311.<br>1312.<br>1313.<br>1314.<br>1315.<br>1316.<br>1317.<br>1318.<br>1319.<br>1320.<br>1321.<br>1322.<br>1323.<br>1324.<br>1325.<br>1326.<br>1327.<br>1328.<br>1329.<br>1330.<br>1331.<br>1332.<br>1333.<br>1334.<br>1335.<br>1336.<br>1337.<br>1338.<br>1339.<br>1340.<br>1341.<br>1342.<br>1343.<br>1344.<br>1345.<br>1346.<br>1347.<br>1348.<br>1349.<br>1350.<br>1351.<br>1352.<br>1353.<br>1354.<br>1355.<br>1356.<br>1357.<br>1358.<br>1359.<br>1360.<br>1361.<br>1362.<br>1363.<br>1364.<br>1365.<br>1366.<br>1367.<br>1368.<br>1369.<br>1370.<br>1371.<br>1372.<br>1373.<br>1374.<br>1375.<br>1376.<br>1377.<br>1378.<br>1379.<br>1380.<br>1381.<br>1382.<br>1383.<br>1384.<br>1385.<br>1386.<br>1387.<br>1388.<br>1389.<br>1390.<br>1391.<br>1392.<br>1393.<br>1394.<br>1395.<br>1396.<br>1397.<br>1398.<br>1399.<br>1400.<br>1401.<br>1402.<br>1403.<br>1404.<br>1405.<br>1406.<br>1407.<br>1408.<br>1409.<br>1410.<br>1411.<br>1412.<br>1413.<br>1414.<br>1415.<br>1416.<br>1417.<br>1418.<br>1419.<br>1420.<br>1421.<br>1422.<br>1423.<br>1424.<br>1425.<br>1426.<br>1427.<br>1428.<br>1429.<br>1430.<br>1431.<br>1432.<br>1433.<br>1434.<br>1435.<br>1436.<br>1437.<br>1438.<br>1439.<br>1440.<br>1441.<br>1442.<br>1443.<br>1444.<br>1445.<br>1446.<br>1447.<br>1448.<br>1449.<br>1450.<br>1451.<br>1452.<br>1453.<br>1454.<br>1455.<br>1456.<br>1457.<br>1458.<br>1459.<br>1460.<br>1461.<br>1462.<br>1463.<br>1464.<br>1465.<br>1466.<br>1467.<br>1468.<br>1469.<br>1470.<br>1471.<br>1472.<br>1473.<br>1474.<br>1475.<br>1476.<br>1477.<br>1478.<br>1479.<br>1480.<br>1481.<br>1482.<br>1483.<br>1484.<br>1485.<br>1486.<br>1487.<br>1488.<br>1489.<br>1490.<br>1491.<br>1492.<br>1493.<br>1494.<br>1495.<br>1496.<br>1497.<br>1498.<br>1499.<br>1500.<br>1501.<br>1502.<br>1503.<br>1504.<br>1505.<br>1506.<br>1507.<br>1508.<br>1509.<br>1510.<br>1511.<br>1512.<br>1513.<br>1514.<br>1515.<br>1516.<br>1517.<br>1518.<br>1519.<br>1520.<br>1521.<br>1522.<br>1523.<br>1524.<br>1525.<br>1526.<br>1527.<br>1528.<br>1529.<br>1530.<br>1531.<br>1532.<br>1533.<br>1534.<br>1535.<br>1536.<br>1537.<br>1538.<br>1539.<br>1540.<br>1541.<br>1542.<br>1543.<br>1544.<br>1545.<br>1546.<br>1547.<br>1548.<br>1549.<br>1550.<br>1551.<br>1552.<br>1553.<br>1554.<br>1555.<br>1556.<br>1557.<br>1558.<br>1559.<br>1560.<br>1561.<br>1562.<br>1563.<br>1564.<br>1565.<br>1566.<br>1567.<br>1568.<br>1569.<br>1570.<br>1571.<br>1572.<br>1573.<br>1574.<br>1575.<br>1576.<br>1577.<br>1578.<br>1579.<br>1580.<br>1581.<br>1582.<br>1583.<br>1584.<br>1585.<br>1586.<br>1587.<br>1588.<br>1589.<br>1590.<br>1591.<br>1592.<br>1593.<br>1594.<br>1595.<br>1596.<br>1597.<br>1598.<br>1599.<br>1600.<br>1601.<br>1602.<br>1603.<br>1604.<br>1605.<br>1606.<br>1607.<br>1608.<br>1609.<br>1610.<br>1611.<br>1612.<br>1613.<br>1614.<br>1615.<br>1616.<br>1617.<br>1618.<br>1619.<br>1620.<br>1621.<br>1622.<br>1623.<br>1624.<br>1625.<br>1626.<br>1627.<br>1628.<br>1629.<br>1630.<br>1631.<br>1632.<br>1633.<br>1634.<br>1635.<br>1636.<br>1637.<br>1638.<br>1639.<br>1640.<br>1641.<br>1642.<br>1643.<br>1644.<br>1645.<br>1646.<br>1647.<br>1648.<br>1649.<br>1650.<br>1651.<br>1652.<br>1653.<br>1654.<br>1655.<br>1656.<br>1657.<br>1658.<br>1659.<br>1660.<br>1661.<br>1662.<br>1663.<br>1664.<br>1665.<br>1666.<br>1667.<br>1668.<br>1669.<br>1670.<br>1671.<br>1672.<br>1673.<br>1674.<br>1675.<br>1676.<br>1677.<br>1678.<br>1679.<br>1680.<br>1681.<br>1682.<br>1683.<br>1684.<br>1685.<br>1686.<br>1687.<br>1688.<br>1689.<br>1690.<br>1691.<br>1692.<br>1693.<br>1694.<br>1695.<br>1696.<br>1697.<br>1698.<br>1699.<br>1700.<br>1701.<br>1702.<br>1703.<br>1704.<br>1705.<br>1706.<br>1707.<br>1708.<br>1709.<br>1710.<br>1711.<br>1712.<br>1713.<br>1714.<br>1715.<br>1716.<br>1717.<br>1718.<br>1719.<br>1720.<br>1721.<br>1722.<br>1723.<br>1724.<br>1725.<br>1726.<br>1727.<br>1728.<br>1729.<br>1730.<br>1731.<br>1732.<br>1733.<br>1734.<br>1735.<br>1736.<br>1737.<br>1738.<br>1739.<br>1740.<br>1741.<br>1742.<br>1743.<br>1744.<br>1745.<br>1746.<br>1747.<br>1748.<br>1749.<br>1750.<br>1751.<br>1752.<br>1753.<br>1754.<br>1755.<br>1756.<br>1757.<br>1758.<br>1759.<br>1760.<br>1761.<br>1762.<br>1763.<br>1764.<br>1765.<br>1766.<br>1767.<br>1768.<br>1769.<br>1770.<br>1771.<br>1772.<br>1773.<br>1774.<br>1775.<br>1776.<br>1777.<br>1778.<br>1779.<br>1780.<br>1781.<br>1782.<br>1783.<br>1784.<br>1785.<br>1786.<br>1787.<br>1788.<br>1789.<br>1790.<br>1791.<br>1792.<br>1793.<br>1794.<br>1795.<br>1796.<br>1797.<br>1798.<br>1799.<br>1800.<br>1801.<br>1802.<br>1803.<br>1804.<br>1805.<br>1806.<br>1807.<br>1808.<br>1809.<br>1810.<br>1811.<br>1812.<br>1813.<br>1814.<br>1815.<br>1816.<br>1817.<br>1818.<br>1819.<br>1820.<br>1821.<br>1822.<br>1823.<br>1824.<br>1825.<br>1826.<br>1827.<br>1828.<br>1829.<br>1830.<br>1831.<br>1832.<br>1833.<br>1834.<br>1835.<br>1836.<br>1837.<br>1838.<br>1839.<br>1840.<br>1841.<br>1842.<br>1843.<br>1844.<br>1845.<br>1846.<br>1847.<br>1848.<br>1849.<br>1850.<br>1851.<br>1852.<br>1853.<br>1854.<br>1855.<br>1856.<br>1857.<br>1858.<br>1859.<br>1860.<br>1861.<br>1862.<br>1863.<br>1864.<br>1865.<br>1866.<br>1867.<br>1868.<br>1869.<br>1870.<br>1871.<br>1872.<br>1873.<br>1874.<br>1875.<br>1876.<br>1877.<br>1878.<br>1879.<br>1880.<br>1881.<br>1882.<br>1883.<br>1884.<br>1885.<br>1886.<br>1887.<br>1888.<br>1889.<br>1890.<br>1891.<br>1892.<br>1893.<br>1894.<br>1895.<br>1896.<br>1897.<br>1898.<br>1899.<br>1900.<br>1901.<br>1902.<br>1903.<br>1904.<br>1905.<br>1906.<br>1907.<br>1908.<br>1909.<br>1910.<br>1911.<br>1912.<br>1913.<br>1914.<br>1915.<br>1916.<br>1917.<br>1918.<br>1919.<br>1920.<br>1921.<br>1922.<br>1923.<br>1924.<br>1925.<br>1926.<br>1927.<br>1928.<br>1929.<br>1930.<br>1931.<br>1932.<br>1933.<br>1934.<br>1935.<br>1936.<br>1937.<br>1938.<br>1939.<br>1940.<br>1941.<br>1942.<br>1943.<br>1944.<br>1945.<br>1946.<br>1947.<br>1948.<br>1949.<br>1950.<br>1951.<br>1952.<br>1953.<br>1954.<br>1955.<br>1956.<br>1957.<br>1958.<br>1959.<br>1960.<br>1961.<br>1962.<br>1963.<br>1964.<br>1965.<br>1966.<br>1967.<br>1968.<br>1969.<br>1970.<br>1971.<br>1972.<br>1973.<br>1974.<br>1975.<br>1976.<br>1977.<br>1978.<br>1979.<br>1980.<br>1981.<br>1982.<br>1983.<br>1984.<br>1985.<br>1986.<br>1987.<br>1988.<br>1989.<br>1990.<br>1991.<br>1992.<br>1993.<br>1994.<br>1995.<br>1996.<br>1997.<br>1998.<br>1999.<br>2000.<br>2001.<br>2002.<br>2003.<br>2004.<br>2005.<br>2006.<br>2007.<br>2008.<br>2009.<br>2010.<br>2011.<br>2012.<br>2013.<br>2014.<br>2015.<br>2016.<br>2017.<br>2018.<br>2019.<br>2020.<br>2021.<br>2022.<br>2023.<br>2024.<br>2025.<br>2026.<br>2027.<br>2028.<br>2029.<br>2030.<br>2031.<br>2032.<br>2033.<br>2034.<br>2035.<br>2036.<br>2037.<br>2038.<br>2039.<br>2040.<br>2041.<br>2042.<br>2043.<br>2044.<br>2045.<br>2046.<br>2047.<br>2048.<br>2049.<br>2050.<br>2051.<br>2052.<br>2053.<br>2054.<br>2055.<br>2056.<br>2057.<br>2058.<br>2059.<br>2060.<br>2061.<br>2062.<br>2063.<br>2064.<br>2065.<br>2066.<br>2067.<br>2068.<br>2069.<br>2070.<br>2071.<br>2072.<br>2073.<br>2074.<br>2075.<br>2076.<br>2077.<br>2078.<br>2079.<br>2080.<br>2081.<br>2082.<br>2083.<br>2084.<br>2085.<br>2086.<br>2087.<br>2088.<br>2089.<br>2090.<br>2091.<br>2092.<br>2093.<br>2094.<br>2095.<br>2096.<br>2097.<br>2098.<br>2099.<br>2100.<br>2101.<br>2102.<br>2103.<br>2104.<br>2105.<br>2106.<br>2107.<br>2108.<br>2109.<br>2110.<br>2111.<br>2112.<br>2113.<br>2114.<br>2115.<br>2116.<br>2117.<br>2118.<br>2119.<br>2120.<br>2121.<br>2122.<br>2123.<br>2124.<br>2125.<br>2126.<br>2127.<br>2128.<br>2129.<br>2130.<br>2131.<br>2132.<br>2133.<br>2134.<br>2135.<br>2136.<br>2137.<br>2138.<br>2139.<br>2140.<br>2141.<br>2142.<br>2143.<br>2144.<br>2145.<br>2146.<br>2147.<br>2148.<br>2149.<br>2150.<br>2151.<br>2152.<br>2153.<br>2154.<br>2155.<br>2156.<br>2157.<br>2158.<br>2159.<br>2160.<br>2161.<br>2162.<br>2163.<br>2164.<br>2165.<br>2166.<br>2167.<br>2168.<br>2169.<br>2170.<br>2171.<br>2172.<br>2173.<br>2174.<br>2175.<br>2176.<br>2177.<br>2178.<br>2179.<br>2180.<br>2181.<br>2182.<br>2183.<br>2184.<br>2185.<br>2186.<br>2187.<br>2188.<br>2189.<br>2190.<br>2191.<br>2192.<br>2193.<br>2194.<br>2195.<br>2196.<br>2197.<br>2198.<br>2199.<br>2200.<br>2201.<br>2202.<br>2203.<br>2204.<br>2205.<br>2206.<br>2207.<br>2208.<br>2209.<br>2210.<br>2211.<br>2212.<br>2213.<br>2214.<br>2215.<br>2216.<br>2217.<br>2218.<br>2219.<br>2220.<br>2221.<br>2222.<br>2223.<br>2224.<br>2225.<br>2226.<br>2227.<br>2228.<br>2229.<br>2230.<br>2231.<br>2232.<br>2233.<br>2234.<br>2235.<br>2236.<br>2237.<br>2238.<br>2239.<br>2240.<br>2241.<br>2242.<br>2243.<br>2244.<br>2245.<br>2246.<br>2247.<br>2248.<br>2249.<br>2250.<br>2251.<br>2252.<br>2253.<br>2254.<br>2255.<br>2256.<br>2257.<br>2258.<br>2259.<br>2260.<br>2261.<br>2262.<br>2263.<br>2264.<br>2265.<br>2266.<br>2267.<br>2268.<br>2269.<br>2270.<br>2271.<br>2272.<br>2273.<br>2274.<br>2275.<br>2276.<br>2277.<br>2278.<br>2279.<br>2280.<br>2281.<br>2282.<br>2283.<br>2284.<br>2285.<br>2286.<br>2287.<br>2288.<br>2289.<br>2290.<br>2291.<br>2292.<br>2293.<br>2294.<br>2295.<br>2296.<br>2297.<br>2298.<br>2299.<br>2300.<br>2301.<br>2302.<br>2303.<br>2304.<br>2305.<br>2306.<br>2307.<br>2308.<br>2309.<br>2310.<br>2311.<br>2312.<br>2313.<br>2314.<br>2315.<br>2316.<br>2317.<br>2318.<br>2319.<br>2320.<br>2321.<br>2322.<br>2323.<br>2324.<br>2325.<br>2326.<br>2327.<br>2328.<br>2329.<br>2330.<br>2331.<br>2332.<br>2333.<br>2334.<br>2335.<br>2336.<br>2337.<br>2338.<br>2339.<br>2340.<br>2341.<br>2342.<br>2343.<br>2344.<br>2345.<br>2346.<br>2347.<br>2348.<br>2349.<br>2350.<br>2351.<br>2352.<br>2353.<br>2354.<br>2355.<br>2356.<br>2357.<br>2358.<br>2359.<br>2360.<br>2361.<br>2362.<br>2363.<br>2364.<br>2365.<br>2366.<br>2367.<br>2368.<br>2369.<br>2370.<br>2371.<br>2372.<br>2373.<br>2374.<br>2375.<br>2376.<br>2377.<br>2378.<br>2379.<br>2380.<br>2381.<br>2382.<br>2383.<br>2384.<br>2385.<br>2386.<br>2387.<br>2388.<br>2389.<br>2390.<br>2391.<br>2392.<br>2393.<br>2394.<br>2395.<br>2396.<br>2397.<br>2398.<br>2399.<br>2400.<br>2401.<br>2402.<br>2403.<br>2404.<br>2405.<br>2406.<br>2407.<br>2408.<br>2409.<br>2410.<br>2411.<br>2412.<br>2413.<br>2414.<br>2415.<br>2416.<br>2417.<br>2418.<br>2419.<br>2420.<br>2421.<br>2422.<br>2423.<br>2424.<br>2425.<br>2426.<br>2427.<br>2428.<br>2429.<br>2430.<br>2431.<br>2432.<br>2433.<br>2434.<br>2435.<br>2436.<br>2437.<br>2438.<br>2439.<br>2440.<br>2441.<br>2442.<br>2443.<br>2444.<br>2445.<br>2446.<br>2447.<br>2448.<br>2449.<br>2450.<br>2451.<br>2452.<br>2453.<br>2454.<br>2455.<br>2456.<br>2457.<br>2458.<br>2459.<br>2460.<br>2461.<br>2462.<br>2463.<br>2464.<br>2465.<br>2466.<br>2467.<br>2468.<br>2469.<br>2470.<br>2471.<br>2472.<br>2473.<br>2474.<br>2475.<br>2476.<br>2477.<br>2478.<br>2479.<br>2480.<br>2481.<br>2482.<br>2483.<br>2484.<br>2485.<br>2486.<br>2487.<br>2488.<br>2489.<br>2490.<br>2491.<br>2492.<br>2493.<br>2494.<br>2495.<br>2496.<br>2497.<br>2498.<br>2499.<br>2500.<br>2501.<br>2502.<br>2503.<br>2504.<br>2505.<br>2506.<br>2507.<br>2508.<br>2509.<br>2510.<br>2511.<br>2512.<br>2513.<br>2514.<br>2515.<br>2516.<br>2517.<br>2518.<br>2519.<br>2520.<br>2521.<br>2522.<br>2523.<br>2524.<br>2525.<br>2526.<br>2527.<br>2528.<br>2529.<br>2530.<br>2531.<br>2532.<br>2533.<br>2534.<br>2535.<br>2536.<br>2537.<br>2538.<br>2539.<br>2540.<br>2541.<br>2542.<br>2543.<br>2544.<br>2545.<br>2546.<br>2547.<br>2548.<br>2549.<br>2550.<br>2551.<br>2552.<br>2553.<br>2554.<br>2555.<br>2556.<br>2557.<br>2558.<br>2559.<br>2560.<br>2561.<br>2562.<br>2563.<br>2564.<br>2565.<br>2566.<br>2567.<br>2568.<br>2569.<br>2570.<br>2571.<br>2572.<br>2573.<br>2574.<br>2575.<br>2576.<br>2577.<br>2578.<br>2579.<br>2580.<br>2581.<br>2582.<br>2583.<br>2584.<br>2585.<br>2586.<br>2587.<br>2588.<br>2589.<br>2590.<br>2591.<br>2592.<br>2593.<br>2594.<br>2595.<br>2596.<br>2597.<br>2598.<br>2599.<br>2600.<br>2601.<br>2602.<br>2603.<br>2604.<br>2605.<br>2606.<br>2607.<br>2608.<br>2609.<br>2610.<br>2611.<br>2612.<br>2613.<br>2614.<br>2615.<br>2616.<br>2617.<br>2618.<br>2619.<br>2620.<br>2621.<br>2622.<br>2623.<br>2624.<br>2625.<br>2626.<br>2627.<br>2628.<br>2629.<br>2630.<br>2631.<br>2632.<br>2633.<br>2634.<br>2635.<br>2636.<br>2637.<br>2638.<br>2639.<br>2640.<br>2641.<br>2642.<br>2643.<br>2644.<br>2645.<br>2646.<br>2647.<br>2648.<br>2649.<br>2650.<br>2651.<br>2652.<br>2653.<br>2654.<br>2655.<br>2656.<br>2657.<br>2658.<br>2659.<br>2660.<br>2661.<br>2662.<br>2663.<br>2664.<br>2665.<br>2666.<br>2667.<br>2668.<br>2669.<br>2670.<br>2671.<br>2672.<br>2673.<br>2674.<br>2675.<br>2676.<br>2677.<br>2678.<br>2679.<br>2680.<br>2681.<br>2682.<br>2683.<br>2684.<br>2685.<br>2686.<br>2687.<br>2688.<br>2689.<br>2690.<br>2691.<br>2692.<br>2693.<br>2694.<br>2695.<br>2696.<br>2697.<br>2698.<br>2699.<br>2700.<br>2701.<br>2702.<br>2703.<br>2704.<br>2705.<br>2706.<br>2707.<br>2708.<br>2709.<br>2710.<br>2711.<br>2712.<br>2713.<br>2714.<br>2715.<br>2716.<br>2717.<br>2718.<br>2719.<br>2720.<br>2721.<br>2722.<br>2723.<br>2724.<br>2725.<br>2726.<br>2727.<br>2728.<br>2729.<br>2730.<br>2731.<br>2732.<br>2733.<br>2734.<br>2735.<br>2736.<br>2737.<br>2738.<br>2739.<br>2740.<br>2741.<br>2742.<br>2743.<br>2744.<br>2745.<br>2746.<br>2747.<br>2748.<br>2749.<br>2750.<br>2751.<br>2752.<br>2753.<br>2754.<br>2755.<br>2756.<br>2757.<br>2758.<br>2759.<br>2760.<br>2761.<br>2762.<br>2763.<br>2764.<br>2765.<br>2766.<br>2767.<br>2768.<br>2769.<br>2770.<br>2771.<br>2772.<br>2773.<br>2774.<br>2775.<br>2776.<br>2777.<br>2778.<br>2779.<br>2780.<br>2781.<br>2782.<br>2783.<br>2784.<br>2785.<br>2786.<br>2787.<br>2788.<br>2789.<br>2790.<br>2791.<br>2792.<br>2793.<br>2794.<br>2795.<br>2796.<br>2797.<br>2798.<br>2799.<br>2800.<br>2801.<br>2802.<br>2803.<br>2804.<br>2805.<br>2806.<br>2807.<br>2808.<br>2809.<br>2810.<br>2811.<br>2812.<br>2813.<br>2814.<br>2815.<br>2816.<br>2817.<br>2818.<br>2819.<br>2820.<br>2821.<br>2822.<br>2823.<br>2824.<br>2825.<br>2826.<br>2827.<br>2828.<br>2829.<br>2830.<br>2831.<br>2832.<br>2833.<br>2834.<br>2835.<br>2836.<br>2837.<br>2838.<br>2839.<br>2840.<br>2841.<br>2842.<br>2843.<br>2844.<br>2845.<br>2846.<br>2847.<br>2848.<br>2849.<br>2850.<br>2851.<br>2852.<br>2853.<br>2854.<br>2855.<br>2856.<br>2857.<br>2858.<br>2859.<br>2860.<br>2861.<br>2862.<br>2863.<br>2864.<br>2865.<br>2866.<br>2867.<br>2868.<br>2869.<br>2870.<br>2871.<br>2872.<br>2873.<br>2874.<br>2875.<br>2876.<br>2877.<br>2878.<br>2879.<br>2880.<br>2881.<br>2882.<br>2883.<br>2884.<br>2885.<br>2886.<br>2887.<br>2888.<br>2889.<br>2890.<br>2891.<br>2892.<br>2893.<br>2894.<br>2895.<br>2896.<br>2897.<br>2898.<br>2899.<br>2900.<br>2901.<br>2902.<br>2903.<br>2904.<br>2905.<br>2906.<br>2907.<br>2908.<br>2909.<br>2910.<br>2911.<br>2912.<br>2913.<br>2914.<br>2915.<br>2916.<br>2917.<br>2918.<br>2919.<br>2920.<br>2921.<br>2922.<br>2923.<br>2924.<br>2925.<br>2926.<br>2927.<br>2928.<br>2929.<br>2930.<br>2931.<br>2932.<br>2933.<br>2934.<br>2935.<br>2936.<br>2937.<br>2938.<br>2939.<br>2940.<br>2941.<br>2942.<br>2943.<br>2944.<br>2945.<br>2946.<br>2947.<br>2948.<br>2949.<br>2950.<br>2951.<br>2952.<br>2953.<br>2954.<br>2955.<br>2956.<br>2957.<br>2958.<br>2959.<br>2960.<br>2961.<br>2962.<br>2963.<br>2964.<br>2965.<br>2966.<br>2967.<br>2968.<br>2969.<br>2970.<br>2971.<br>2972.<br>2973.<br>2974.<br>2975.<br>2976.<br>2977.<br>2978.<br>2979.<br>2980.<br>2981.<br>2982.<br>2983.<br>2984.<br>2985.<br>2986.<br>2987.<br>2988.<br>2989.<br>2990.<br>2991.<br>2992.<br>2993.<br>2994.<br>2995.<br>2996.<br>2997.<br>2998.<br>2999.<br>3000.<br>3001.<br>3002.<br>3003.<br>3004.<br>3005.<br>3006.<br>3007.<br>3008.<br>3009.<br>3010.<br>3011.<br>3012.<br>3013.<br>3014.<br>3015.<br>3016.<br>3017.<br>3018.<br>3019.<br>3020.<br>3021.<br>3022.<br>3023.<br>3024.<br>3025.<br>3026.<br>3027.<br>3028.<br>3029.<br>3030.<br>3031.<br>3032.<br>3033.<br>3034.<br>3035.<br>3036.<br>3037.<br>3038.<br>3039.<br>3040.<br>3041.<br>3042.<br>3043.<br>3044.<br>3045.<br>3046.<br>3047.<br>3048.<br>3049.<br>3050.<br>3051.<br>3052.<br>3053.<br>3054.<br>3055.<br>3056.<br>3057.<br>3058.<br>3059.<br>3060.<br>3061.<br>3062.<br>3063.<br>3064.<br>3065.<br>3066.<br>3067.<br>3068.<br>3069.<br>3070.<br>3071.<br>3072.<br>3073.<br>3074.<br>3075.<br>3076.<br>3077.<br>3078.<br>3079.<br>3080.<br>3081.<br>3082.<br>3083.<br>3084.<br>3085.<br>3086.<br>3087.<br>3088.<br>3089.<br>3090.<br>3091.<br>3092.<br>3093.<br>3094.<br>3095.<br>3096.<br>3097.<br>3098.<br>3099.<br>3100.<br>3101.<br>3102.<br>3103.<br>3104.<br>3105.<br>3106.<br>3107.<br>3108.<br>3109.<br>3110.<br>3111.<br>3112.<br>3113.<br>3114.<br>3115.<br>3116.<br>3117.<br>3118.<br>3119.<br>3120.<br>3121.<br>3122.<br>3123.<br>3124.<br>3125.<br>3126.<br>3127.<br>3128.<br>3129.<br>3130.<br>3131.<br>3132.<br>3133.<br>3134.<br>3135.<br>3136.<br>3137.<br>3138.<br>3139.<br>3140.<br>3141.<br>3142.<br>3143.<br>3144.<br>3145.<br>3146.<br>3147.<br>3148.<br>3149.<br>3150.<br>3151.<br>3152.<br>3153.<br>3154.<br>3155.<br>3156.<br>3157.<br>3158.<br>3159.<br>3160.<br>3161.<br>3162.<br>3163.<br>3164.<br>3165.<br>3166.<br>3167.<br>3168.<br>3169.<br>3170.<br>3171.<br>3172.<br>3173.<br>3174.<br>3175.<br>3176.<br>3177.<br>3178.<br>3179.<br>3180.<br>3181.<br>3182.<br>3183.<br>3184.<br>3185.<br>3186.<br>3187.<br>3188.<br>3189.<br>3190.<br>3191.<br>3192.<br>3193.<br>3194.<br>3195.<br>3196.<br>3197.<br>3198.<br>3199.<br>3200.<br>3201.<br>3202.<br>3203.<br>3204.<br>3205.<br>3206.<br>3207.<br>3208.<br>3209.<br>3210.<br>3211.<br>3212.<br>3213.<br>3214.<br>3215.<br>3216.<br>3217.<br>3218.<br>3219.<br>3220.<br>3221.<br>3222.<br>3223.<br>3224.<br>3225.<br>3226.<br>3227.<br>3228.<br>3229.<br>3230.<br>3231.<br>3232.<br>3233.<br>3234.<br>3235.<br>3236.<br>3237.<br>3238.<br>3239.<br>3240.<br>3241.<br>3242.<br>3243.<br>3244.<br>3245.<br>3246.<br>3247.<br>3248.<br>3249.<br>3250.<br>3251.<br>3252.<br>3253.<br>3254.<br>3255.<br>3256.<br>3257.<br>3258.<br>3259.<br>3260.<br>3261.<br>3262.<br>3263.<br>3264.<br>3265.<br>3266.<br>3267.<br>3268.<br>3269.<br>3270.<br>3271.<br>3272.<br>3273.<br>3274.<br>3275.<br>3276.<br>3277.<br>3278.<br>3279.<br>3280.<br>3281.<br>3282.<br>3283.<br>3284.<br>3285.<br>3286.<br>3287.<br>3288.<br>3289.<br>3290.<br>3291.<br>3292.<br>3293.<br>3294.<br>3295.<br>3296.<br>3297.<br>3298.<br>3299.<br>3300.<br>3301.<br>3302.<br>3303.<br>3304.<br>3305.<br>3306.<br>3307.<br>3308.<br>3309.<br>3310.<br>3311.<br>3312.<br>3313.<br>3314.<br>3315.<br>3316.<br>3317.<br>3318.<br>3319.<br>3320.<br>3321.<br>3322.<br>3323.<br>3324.<br>3325.<br>3326.<br>3327.<br>3328.<br>3329.<br>3330.<br>3331.<br>3332.<br>3333.<br>3334.<br>3335.<br>3336.<br>3337.<br>3338.<br>3339.<br>3340.<br>3341.<br>3342.<br>3343.<br>3344.<br>3345.<br>3346.<br>3347.<br>3348.<br>3349.<br>3350.<br>3351.<br>3352.<br>3353.<br>3354.<br>3355.<br>3356.<br>3357.<br>3358.<br>3359.<br>3360.<br>3361.<br>3362.<br>3363.<br>3364.<br>3365.<br>3366.<br>3367.<br>3368.<br>3369.<br>3370.<br>3371.<br>3372.<br>3373.<br>3374.<br>3375.<br>3376.<br>3377.<br>3378.<br>3379.<br>3380.<br>3381.<br>3382.<br>3383.<br>3384.<br>3385.<br>3386.<br>3387.<br>3388.<br>3389.<br>3390.<br>3391.<br>3392.<br>3393.<br>3394.<br>3395.<br>3396.<br>3397.<br>3398.<br>3399.<br>3400.<br>3401.<br>3402.<br>3403.<br>3404.<br>3405.<br>3406.<br>3407.<br>3408.<br>3409.<br>3410.<br>3411.<br>3412.<br>3413.<br>3414.<br>3415.<br>3416.<br>3417.<br>3418.<br>3419.<br>3420.<br>3421.<br>3422.<br>3423.<br>3424.<br>3425.<br>3426.<br>3427.<br>3428.<br>3429.<br>3430.<br>3431.<br>3432.<br>3433.<br>3434.<br>3435.<br>3436.<br>3437.<br>3438.<br>3439.<br>3440.<br>3441.<br>3442.<br>3443.<br>3444.<br>3445.<br>3446.<br>3447.<br>3448.<br>3449.<br>3450.<br>3451.<br>3452.<br>3453.<br>3454.<br>3455.<br>3456.<br>3457.<br>3458.<br>3459.<br>3460.<br>3461.<br>3462.<br>3463.<br>3464.<br>3465.<br>3466.<br>3467.<br>3468.<br>3469.<br>3470.<br>3471.<br>3472.<br>3473.<br>3474.<br>3475.<br>3476.<br>3477.<br>3478.<br>3479.<br>3480.<br>3481.<br>3482.<br>3483.<br>3484.<br>3485.<br>3486.<br>3487.<br>3488.<br>3489.<br>3490.<br>3491.<br>3492.<br>3493.<br>3494.<br>3495.<br>3496.<br>3497.<br>3498.<br>3499.<br>3500.<br>3501.<br>3502.<br>3503.<br>3504.<br>3505.<br>3506.<br>3507.<br>3508.<br>3509.<br>3510.<br>3511.<br>3512.<br>3513.<br>3514.<br>3515.<br>3516.<br>3517.<br>3518.<br>3519.<br>3520.<br>3521.<br>3522.<br>3523.<br>3524.<br>3525.<br>3526.<br>3527.<br>3528.<br>3529.<br>3530.<br>3531.<br>3532.<br>3533.<br>3534.<br>3535.<br>3536.<br>3537.<br>3538.<br>3539.<br>3540.<br>3541.<br>3542.<br>3543.<br>3544.<br>3545.<br>3546.<br>3547.<br>3548.<br>3549.<br>3550.<br>3551.<br>3552.<br>3553.<br>3554.<br>3555.<br>3556.<br>3557.<br>3558.<br>3559.<br>3560.<br>3561.<br>3562.<br>3563.<br>3564.<br>3565.<br>3566.<br>3567.<br>3568.<br>3569.<br>3570.<br>3571.<br>3572.<br>3573.<br>3574.<br>3575.<br>3576.<br>3577.<br>3578.<br>3579.<br>3580.<br>3581.<br>3582.<br>3583.<br>3584.<br>3585.<br>3586.<br>3587.<br>3588.<br>3589.<br>3590.<br>3591.<br>3592.<br>3593.<br>3594.<br>3595.<br>3596.<br>3597.<br>3598.<br>3599.<br>3600.<br>3601.<br>3602.<br>3603.<br>3604.<br>3605.<br>3606.<br>3607.<br>3608.<br>3609.<br>3610.<br>3611.<br>3612.<br>3613.<br>3614.<br>3615.<br>3616.<br>3617.<br>3618.<br>3619.<br>3620.<br>3621.<br>3622.<br>3623.<br>3624.<br>3625.<br>3626.<br>3627.<br>3628.<br>3629.<br>3630.<br>3631.<br>3632.<br>3633.<br>3634.<br>3635.<br>3636.<br>3637.<br>3638.<br>3639.<br>3640.<br>3641.<br>3642.<br>3643.<br>3644.<br>3645.<br>3646.<br>3647.<br>3648.<br>3649.<br>3650.<br>3651.<br>3652.<br>3653.<br>3654.<br>3655.<br>3656.<br>3657.<br>3658.<br>3659.<br>3660.<br>3661.<br>3662.<br>3663.<br>3664.<br>3665.<br>3666.<br>3667.<br>3668.<br>3669.<br>3670.<br>3671.<br>3672.<br>3673.<br>3674.<br>3675.<br>3676.<br>3677.<br>3678.<br>3679.<br>3680.<br>3681.<br>3682.<br>3683.<br>3684.<br>3685.<br>3686.<br>3687.<br>3688.<br>3689.<br>3690.<br>3691.<br>3692.<br>3693.<br>3694.<br>3695.<br>3696.<br>3697.<br>3698.<br>3699.<br>3700.<br>3701.<br>3702.<br>3703.<br>3704.<br>3705.<br>3706.<br>3707.<br>3708.<br>3709.<br>3710.<br>3711.<br>3712.<br>3713.<br>3714.<br>3715.<br>3716.<br>3717.<br>3718.<br>3719.<br>3720.<br>3721.<br>3722.<br>3723.<br>3724.<br>3725.<br>3726.<br>3727.<br>3728.<br>3729.<br>3730.<br>3731.<br>3732.<br>3733.<br>3734.<br>3735.<br>3736.<br>3737.<br>3738.<br>3739.<br>3740.<br>3741.<br>3742.<br>3743.<br>3744.<br>3745.<br>3746.<br>3747.<br>3748.<br>3749.<br>3750.<br>3751.<br>3752.<br>3753.<br>3754.<br>3755.<br>3756.<br>3757.<br>3758.<br>3759.<br>3760.<br>3761.<br>3762.<br>3763.<br>3764.<br>3765.<br>3766.<br>3767.<br>3768.<br>3769.<br>3770.<br>3771.<br>3772.<br>3773.<br>3774.<br>3775.<br>3776.<br>3777.<br>3778.<br>3779.<br>3780.<br>3781.<br>3782.<br>3783.<br>3784.<br>3785.<br>3786.<br>3787.<br>3788.<br>3789.<br>3790.<br>3791.<br>3792.<br>3793.<br>3794.<br>3795.<br>3796.<br>3797.<br>3798.<br>3799.<br>3800.<br>3801.<br>3802.<br>3803.<br>3804.<br>3805.<br>3806.<br>3807.<br>3808.<br>3809.<br>3810.<br>3811.<br>3812.<br>3813.<br>3814.<br>3815.<br>3816.<br>3817.<br>3818.<br>3819.<br>3820.<br>3821.<br>3822.<br>3823.<br>3824.<br>3825.<br>3826.<br>3827.<br>3828.<br>3829.<br>3830.<br>3831.<br>3832.<br>3833.<br>3834.<br>3835.<br>3836.<br>3837.<br>3838.<br>3839.<br>3840.<br>3841.<br>3842.<br>3843.<br>3844.<br>3845.<br>3846.<br>3847.<br>3848.<br>3849.<br>3850.<br>3851.<br>3852.<br>3853.<br>3854.<br>3855.<br>3856.<br>3857.<br>3858.<br>3859.<br>3860.<br>3861.<br>3862.<br>3863.<br>3864.<br>3865.<br>3866.<br>3867.<br>3868.<br>3869.<br>3870.<br>3871.<br>3872.<br>3873.<br>3874.<br>3875.<br>3876.<br>3877.<br>3878.<br>3879.<br>3880.<br>3881.<br>3882.<br>3883.<br>3884.<br>3885.<br>3886.<br>3887.<br>3888.<br>3889.<br>3890.<br>3891.<br>3892.<br>3893.<br>3894.<br>3895.<br>3896.<br>3897.<br>3898.<br>3899.<br>3900.<br>3901.<br>3902.<br>3903.<br>3904.<br>3905.<br>3906.<br>3907.<br>3908.<br>3909.<br>3910.<br>3911.<br>3912.<br>3913.<br>3914.<br>3915.<br>3916.<br>3917.<br>3918.<br>3919.<br>3920.<br>3921.<br>3922.<br>3923.<br>3924.<br>3925.<br>3926.<br>3927.<br>3928.<br>3929.<br>3930.<br>3931.<br>3932.<br>3933.<br>3934.<br>3935.<br>3936.<br>3937.<br>3938.<br>3939.<br>3940.<br>3941.<br>3942.<br>3943.<br>3944.<br>3945.<br>3946.<br>3947.<br>3948.<br>3949.<br>3950.<br>3951.<br>3952.<br>3953.<br>3954.<br>3955.<br>3956.<br>3957.<br>3958.<br>3959.<br>3960.<br>3961.<br>3962.<br>3963.<br>3964.<br>3965.<br>3966.<br>3967.<br>3968.<br>3969.<br>3970.<br>3971.<br>3972.<br>3973.<br>3974.<br>3975.<br>3976.<br>3977.<br>3978.<br>3979.<br>3980.<br>3981.<br>3982.<br>3983.<br>3984.<br>3985.<br>3986.<br>3987.<br>3988.<br>3989.<br>3990.<br>3991.<br>3992.<br>3993.<br>3994.<br>3995.<br>3996.<br>3997.<br>3998.<br>3999.<br>4000.<br>4001.<br>4002.<br>4003.<br>4004.<br>4005.<br>4006.<br>4007.<br>4008.<br>4009.<br>4010.<br>4011.<br>4012.<br>4013.<br>4014.<br>4015.<br>4016.<br>4017.<br>4018.<br>4019.<br>4020.<br>4021.<br>4022.<br>4023.<br>4024.<br>4025.<br>4026.<br>4027.<br>4028.<br>4029.<br>4030.<br>4031.<br>4032.<br>4033.<br>4034.<br>4035.<br>4036.<br>4037.<br>4038.<br>4039.<br>4040.<br>4041.<br>4042.<br>4043.<br>4044.<br>4045.<br>4046.<br>4047.<br>4048.<br>4049.<br>4050.<br>4051.<br>4052.<br>4053.<br>4054.<br>4055.<br>4056.<br>4057.<br>4058.<br>4059.<br>4060.<br>4061.<br>4062.<br>4063.<br>4064.<br>4065.<br>4066.<br>4067.<br>4068.<br>4069.<br>4070.<br>4071.<br>4072.<br>4073.<br>4074.<br>4075.<br>4076.<br>4077.<br>4078.<br>4079.<br>4080.<br>4081.<br>4082.<br>4083.<br>4084.<br>4085.<br>4086.<br>4087.<br>4088.<br>4089.<br>4090.<br>4091.<br>4092.<br>4093.<br>4094.<br>4095.<br>4096.<br>4097.<br>4098.<br>4099.<br>4100.<br>4101.<br>4102.<br>4103.<br>4104.<br>4105.<br>4106.<br>4107.<br>4108.<br>4109.<br>4110.<br>4111.<br>4112.<br>4113.<br>4114.<br>4115.<br>4116.<br>4117.<br>4118.<br>4119.<br>4120.<br>4121.<br>4122.<br>4123.<br>4124.<br>4125.<br>4126.<br>4127.<br>4128.<br>4129.<br>4130.<br>4131.<br>4132.<br>4133.<br>4134.<br>4135.<br>4136.<br>4137.<br>4138.<br>4139.<br>4140.<br>4141.<br>4142.<br>4143.<br>4144.<br>4145.<br>4146.<br>4147.<br>4148.<br>4149.<br>4150.<br>4151.<br>4152.<br>4153.<br>4154.<br>4155.<br>4156.<br>4157.<br>4158.<br>4159.<br>4160.<br>4161.<br>4162.<br>4163.<br>4164.<br>4165.<br>4166.<br>4167.<br>4168.<br>4169.<br>4170.<br>4171.<br>4172.<br>4173.<br>4174.<br>4175.<br>4176.<br>4177.<br>4178.<br>4179.<br>4180.<br>4181.<br>4182.<br>4183.<br>4184.<br>4185.<br>4186.<br>4187.<br>4188.<br>4189.<br>4190.<br>4191.<br>4192.<br>4193.<br>4194.<br>4195.<br>4196.<br>4197.<br>4198.<br>4199.<br>4200.<br>4201.<br>4202.<br>4203.<br>4204.<br>4205.<br>4206.<br>4207.<br>4208.<br>4209.<br>4210.<br>4211.<br>4212.<br>4213.<br>4214.<br>4215.<br>4216.<br>4217.<br>4218.<br>4219.<br>4220.<br>4221.<br>4222.<br>4223.<br>4224.<br>4225.<br>4226.<br>4227.<br>4228.<br>4229.<br>4230.<br>4231.<br>4232.<br>4233.<br>4234.<br>4235.<br>4236.<br>4237.<br>4238.<br>4239.<br>4240.<br>4241.<br>4242.<br>4243.<br>4244.<br>4245.<br>4246.<br>4247.<br>4248.<br>4249.<br>4250.<br>4251.<br>4252.<br>4253.<br>4254.<br>4255.<br>4256.<br>4257.<br>4258.<br>4259.<br>4260.<br>4261.<br>4262.<br>4263.<br>4264.<br>4265.<br>4266.<br>4267.<br>4268.<br>4269.<br>4270.<br>4271.<br>4272.<br>4273.<br>4274.<br>4275.<br>4276.<br>4277.<br>4278.<br>4279.<br>4280.<br>4281.<br>4282.<br>4283.<br>4284.<br>4285.<br>4286.<br>4287.<br>4288.<br>4289.<br>4290.<br>4291.<br>4292.<br>4293.<br>4294.<br>4295.<br>4296.<br>4297.<br>4298.<br>4299.<br>4300.<br>4301.<br>4302.<br>4303.<br>4304.<br>4305.<br>4306.<br>4307.<br>4308.<br>4309.<br>4310.<br>4311.<br>4312.<br>4313.<br>4314.<br>4315.<br>4316.<br>4317.<br>4318.<br>4319.<br>4320.<br>4321.<br>4322.<br>4323.<br>4324.<br>4325.<br>4326.<br>4327.<br>4328.<br>4329.<br>4330.<br>4331.<br>4332.<br>4333.<br>4334.<br>4335.<br>4336.<br>4337.<br>4338.<br>4339.<br>4340.<br>4341.<br>4342.<br>4343.<br>4344.<br>4345.<br>4346.<br>4347.<br>4348.<br>4349.<br>4350.<br>4351.<br>4352.<br>4353.<br>4354.<br>4355.<br>4356.<br>4357.<br>4358.<br>4359.<br>4360.<br>4361.<br>4362.<br>4363.<br>4364.<br>4365.<br>4366.<br>4367.<br>4368.<br>4369.<br>4370.<br>4371.<br>4372.<br>4373.<br>4374.<br>4375.<br>4376.<br>4377.<br>4378.<br>4379.<br>4380.<br>4381.<br>4382.<br>4383.<br>4384.<br>4385.<br>4386.<br>4387.<br>4388.<br>4389.<br>4390.<br>4391.<br>4392.<br>4393.<br>4394.<br>4395.<br>4396.<br>4397.<br>4398.<br>4399.<br>4400.<br>4401.<br>4402.<br>4403.<br>4404.<br>4405.<br>4406.<br>4407.<br>4408.<br>4409.<br>4410.<br>4411.<br>4412.<br>4413.<br>4414.<br>4415.<br>4416.<br>4417.<br>4418.<br>4419.<br>4420.<br>4421.<br>4422.<br>4423.<br>4424.<br>4425.<br>4426.<br>4427.<br>4428.<br>4429.<br>4430.<br>4431.<br>4432.<br>4433.<br>4434.<br>4435.<br>4436.<br>4437.<br>4438.<br>4439.<br>4440.<br>4441.<br>4442.<br>4443.<br>4444.<br>4445.<br>4446.<br>4447.<br>4448.<br>4449.<br>4450.<br>4451.<br>4452.<br>4453.<br>4454.<br>4455.<br>4456.<br>4457.<br>4458.<br>4459.<br>4460.<br>4461.<br>4462.<br>4463.<br>4464.<br>4465.<br>4466.<br>4467.<br>4468.<br>4469.<br>4470.<br>4471.<br>4472.<br>4473.<br>4474.<br>4475.<br>4476.<br>4477.<br>4478.<br>4479.<br>4480.<br>4481.<br>4482.<br>4483.<br>4484.<br>4485.<br>4486.<br>4487.<br>4488.<br>4489.<br>4490.<br>4491.<br>4492.<br>4493.<br>4494.<br>4495.<br>4496.<br>4497.<br>4498.<br>4499.<br>4500.<br>4501.<br>4502.<br>4503.<br>4504.<br>4505.<br>4506.<br>4507.<br>4508.<br>4509.<br>4510.<br>4511.<br>4512.<br>4513.<br>4514.<br>4515.<br>4516.<br>4517.<br>4518.<br>4519.<br>4520.<br>4521.<br>4522.<br>4523.<br>4524.<br>4525.<br>4526.<br>4527.<br>4528.<br>4529.<br>4530.<br>4531.<br>4532.<br>4533.<br>4534.<br>4535.<br>4536.<br>4537.<br>4538.<br>4539.<br>4540.<br>4541.<br>4542.<br>4543.<br>4544.<br>4545.<br>4546.<br>4547.<br>4548.<br>4549.<br>4550.<br>4551.<br>4552.<br>4553.<br>4554.<br>4555.<br>4556.<br>4557.<br>4558.<br>4559.<br>4560.<br>4561.<br>4562.<br>4563.<br>4564.<br>4565.<br>4566.<br>4567.<br>4568.<br>4569.<br>4570.<br>4571.<br>4572.<br>4573.<br>4574.<br>4575.<br>4576.<br>4577.<br>4578.<br>4579.<br>4580.<br>4581.<br>4582.<br>4583.<br>4584.<br>4585.<br>4586.<br>4587.<br>4588.<br>4589.<br>4590.<br>4591.<br>4592.<br>4593.<br>4594.<br>4595.<br>4596.<br>4597.<br>4598.<br>4599.<br>4600.<br>4601.<br>4602.<br>4603.<br>4604.<br>4605.<br>4606.<br>4607.<br>4608.<br>4609.<br>4610.<br>4611.<br>4612.<br>4613.<br>4614.<br>4615.<br>4616.<br>4617.<br>4618.<br>4619.<br>4620.<br>4621.<br>4622.<br>4623.<br>4624.<br>4625.<br>4626.<br>4627.<br>4628.<br>4629.<br>4630.<br>4631.<br>4632.<br>4633.<br>4634.<br>4635.<br>4636.<br>4637.<br>4638.<br>4639.<br>4640.<br>4641.<br>4642.<br>4643.<br>4644.<br>4645.<br>4646.<br>4647.<br>4648.<br>4649.<br>4650.<br>4651.<br>4652.<br>4653.<br>4654.<br>4655.<br>4656.<br>4657.<br>4658.<br>4659.<br>4660.<br>4661.<br>4662.<br>4663.<br>4664.<br>4665.<br>4666.<br>4667.<br>4668.<br>4669.<br>4670.<br>4671.<br>4672.<br>4673.<br>4674.<br>4675.<br>4676.<br>4677.<br>4678.<br>4679.<br>4680.<br>4681.<br>4682.<br>4683.<br>4684.<br>4685.<br>4686.<br>4687.<br>4688.<br>4689.<br>4690.<br>4691.<br>4692.<br>4693.<br>4694.<br>4695.<br>4696.<br>4697.<br>4698.<br>4699.<br>4700.<br>4701.<br>4702.<br>4703.<br>4704.<br>4705.<br>4706.<br>4707.<br>4708.<br>4709.<br>4710.<br>4711.<br>4712.<br>4713.<br>4714.<br>4715.<br>4716.<br>4717.<br>4718.<br>4719.<br>4720.<br>4721.<br>4722.<br>4723.<br>4724.<br>4725.<br>4726.<br>4727.<br>4728.<br>4729.<br>4730.<br>4731.<br>4732.<br>4733.<br>4734.<br>4735.<br>4736.<br>4737.<br>4738.<br>4739.<br>4740.<br>4741.<br>4742.<br>4743.<br>4744.<br>4745.<br>4746.<br>4747.<br>4748.<br>4749.<br>4750.<br>4751.<br>4752.<br>4753.<br>4754.<br>4755.<br>4756.<br>4757.<br>4758.<br>4759.<br>4760.<br>4761.<br>4762.<br>4763.<br>4764.<br>4765.<br>4766.<br>4767.<br>4768.<br>4769.<br>4770.<br>4771.<br>4772.<br>4773.<br>4774.<br>4775.<br>4776.<br>4777.<br>4778.<br>4779.<br>4780.<br>4781.<br>4782.<br>4783.<br>4784.<br>4785.<br>4786.<br>4787.<br>4788.<br>4789.<br>4790.<br>4791.<br>4792.<br>4793.<br>4794.<br>4795.<br>4796.<br>4797.<br>4798.<br>4799.<br>4800.<br>4801.<br>4802.<br>4803.<br>4804.<br>4805.<br>4806.<br>4807.<br>4808.<br>4809.<br>4810.<br>4811.<br>4812.<br>4813.<br>4814.<br>4815.<br>4816.<br>4817.<br>4818.<br>4819.<br>4820.<br>4821.<br>4822.<br>4823.<br>4824.<br>4825.<br>4826.<br>4827.<br>4828.<br>4829.<br>4830.<br>4831.<br>4832.<br>4833.<br>4834.<br>4835.<br>4836.<br>4837.<br>4838.<br>4839.<br>4840.<br>4841.<br>4842.<br>4843.<br>4844.<br>4845.<br>4846.<br>4847.<br>4848.<br>4849.<br>4850.<br>4851.<br>4852.<br>4853.<br>4854.<br>4855.<br>4856.<br>4857.<br>4858.<br>4859.<br>4860.<br>4861.<br>4862.<br>4863.<br>4864.<br>4865.<br>4866.<br>4867.<br>4868.<br>4869.<br>4870.<br>4871.<br>4872.<br>4873.<br>4874.<br>4875.<br>4876.<br>4877.<br>4878.<br>4879.<br>4880.<br>4881.<br>4882.<br>4883.<br>4884.<br>4885.<br>4886.<br>4887.<br>4888.<br>4889.<br>4890.<br>4891.<br>4892.<br>4893.<br>4894.<br>4895.<br>4896.<br>4897.<br>4898.<br>4899.<br>4900.<br>4901.<br>4902.<br>4903.<br>4904.<br>4905.<br>4906.<br>4907.<br>4908.<br>4909.<br>4910.<br>4911.<br>4912.<br>4913.<br>4914.<br>4915.<br>4916.<br>4917.<br>4918.<br>4919.<br>4920.<br>4921.<br>4922.<br>4923.<br>4924.<br>4925.<br>4926.<br>4927.<br>4928.<br>4929.<br>4930.<br>4931.<br>4932.<br>4933.<br>4934.<br>4935.<br>4936.<br>4937.<br>4938.<br>4939.<br>4940.<br>4941.<br>4942.<br>4943.<br>4944.<br>4945.<br>4946.<br>4947.<br>4948.<br>4949.<br>4950.<br>4951.<br>4952.<br>4953.<br>4954.<br>4955.<br>4956.<br>4957.<br>4958.<br>4959.<br>4960.<br>4961.<br>4962.<br>4963.<br>4964.<br>4965.<br>4966.<br>4967.<br>4968.<br>4969.<br>4970.<br>4971.<br>4972.<br>4973.<br>4974.<br>4975.<br>4976.<br>4977.<br>4978.<br>4979.<br>4980.<br>4981.<br>4982.<br>4983.<br>4984.<br>4985.<br>4986.<br>4987.<br>4988.<br>4989.<br>4990.<br>4991.<br>4992.<br>4993.<br>4994.<br>4995.<br>4996.<br>4997.<br>4998.<br>4999.<br>5000.<br>5001.<br>5002.<br>5003.<br>5004.<br>5005.<br>5006.<br>5007.<br>5008.<br>5009.<br>5010.<br>5011.<br>5012.<br>5013.<br>5014.<br>5015.<br>5016.<br>5017.<br>5018.<br>5019.<br>5020.<br>5021.<br>5022.<br>5023.<br>5024.<br>5025.<br>5026.<br>5027.<br>5028.<br>5029.<br>5030.<br>5031.<br>5032.<br>5033.<br>5034.<br>5035.<br>5036.<br>5037.<br>5038.<br>5039.<br>5040.<br>5041.<br>5042.<br>5043.<br>5044.<br>5045.<br>5046.<br>5047.<br>5048.<br>5049.<br>5050.<br>5051.<br>5052.<br>5053.<br>5054.<br>5055.<br>5056.<br>5057.<br>5058.<br>5059.<br>5060.<br>5061.<br>5062.<br>5063.<br>5064.<br>5065.<br>5066.<br>5067.<br>5068.<br>5069.<br>5070.<br>5071.<br>5072.<br>5073.<br>5074.<br>5075.<br>5076.<br>5077.<br>5078.<br>5079.<br>5080.<br>5081.<br>5082.<br>5083.<br>5084.<br>5085.<br>5086.<br>5087.<br>5088.<br>5089.<br>5090.<br>5091.<br>5092.<br>5093.<br>5094.<br>5095.<br>5096.<br>5097.<br>5098.<br>5099.<br>5100.<br>5101.<br>5102.<br>5103.<br>5104.<br>5105.<br>5106.<br>5107.<br>5108.<br>5109.<br>5110.<br>5111.<br>5112.<br>5113.<br>5114.<br>5115.<br>5116.<br>5117.<br>5118.<br>5119.<br>5120.<br>5121.<br>5122.<br>5123.<br>5124.<br>5125.<br>5126.<br>5127.<br>5128.<br>5129.<br>5130.<br>5131.<br>5132.<br>5133.<br>5134.<br>5135.<br>5136.<br>5137.<br>5138.<br>5139.<br>5140.<br>5141.<br>5142.<br>5143.<br>5144.<br>5145.<br>5146.<br>5147.<br>5148.<br>5149.<br>5150.<br>5151.<br>5152.<br>5153.<br>5154.<br>5155.<br>5156.<br>5157.<br>5158.<br>5159.<br>5160.<br>5161.<br>5162.<br>5163.<br>5164.<br>5165.<br>5166.<br>5167.<br>5168.<br>5169.<br>5170.<br>5171.<br>5172.<br>5173.<br>5174.<br>5175.<br>5176.<br>5177.<br>5178.<br>5179.<br>5180.<br>5181.<br>5182.<br>5183.<br>5184.<br>5185.<br>5186.<br>5187.<br>5188.<br>5189.<br>5190.<br>5191.<br>5192.<br>5193.<br>5194.<br>5195.<br>5196.<br>5197.<br>5198.<br>5199.<br>5200.<br>5201.<br>5202.<br>5203.<br>5204.<br>5205.<br>5206.<br>5207.<br>5208.<br>5209.<br>5210.<br>5211.<br>5212.<br>5213.<br>5214.<br>5215.<br>5216.<br>5217.<br>5218.<br>5219.<br>5220.<br>5221.<br>5222.<br>5223.<br>5224.<br>5225.<br>5226.<br>5227.<br>5228.<br>5229.<br>5230.<br>5231.<br>5232.<br>5233.<br>5234.<br>5235.<br>5236.<br>5237.<br>5238.<br>5239.<br>5240.<br>5241.<br>5242.<br>5243.<br>5244.<br>5245.<br>5246.<br>5247.<br>5248.<br>5249.<br>5250.<br>5251.<br>5252.<br>5253.<br>5254.<br>5255.<br>5256.<br>5257.<br>5258.<br>5259.<br>5260.<br>5261.<br>5262.<br>5263.<br>5264.<br>5265.<br>5266.<br>5267.<br>5268.<br>5269.<br>5270.<br>5271.<br>5272.<br>5273.<br>5274.<br>5275.<br>5276.<br>5277.<br>5278.<br>5279.<br>5280.<br>5281.<br>5282.<br>5283.<br>5284.<br>5285.<br>5286.<br>5287.<br>5288.<br>5289.<br>5290.<br>5291.<br>5292.<br>5293.<br>5294.<br>5295.<br>5296.<br>5297.<br>5298.<br>5299.<br>5300.<br>5301.<br>5302.<br>5303.<br>5304.<br>5305.<br>5306.<br>5307.<br>5308.<br>5309.<br>5310.<br>5311.<br>5312.<br>5313.<br>5314.<br>5315.<br>5316.<br>5317.<br>5318.<br>5319.<br>5320.<br>5321.<br>5322.<br>5323.<br>5324.<br>5325.<br>5326.<br>5327.<br>5328.<br>5329.<br>5330.<br>5331.<br>5332.<br>5333.<br>5334.<br>5335.<br>5336.<br>5337.<br>5338.<br>5339.<br>5340.<br>5341.<br>5342.<br>5343.<br>5344.<br>5345.<br>5346.<br>5347.<br>5348.<br>5349.<br>5350.<br>5351.<br>5352.<br>5353.<br>5354.<br>5355.<br>5356.<br>5357.<br>5358.<br>5359.<br>5360.<br>5361.<br>5362.<br>5363.<br>5364.<br>5365.<br>5366.<br>5367.<br>5368.<br>5369.<br>5370.<br>5371.<br>5372.<br>5373.<br>5374.<br>5375.<br>5376.<br>5377.<br>5378.<br>5379.<br>5380.<br>5381.<br>5382.<br>5383.<br>5384.<br>5385.<br>5386.<br>5387.<br>5388.<br>5389.<br>5390.<br>5391.<br>5392.<br>5393.<br>5394.<br>5395.<br>5396.<br>5397.<br>5398.<br>5399.<br>5400.<br>5401.<br>5402.<br>5403.<br>5404.<br>5405.<br>5406.<br>5407.<br>5408.<br>5409.<br>5410.<br>5411.<br>5412.<br>5413.<br>5414.<br>5415.<br>5416.<br>5417.<br>5418.<br>5419.<br>5420.<br>5421.<br>5422.<br>5423.<br>5424.<br>5425.<br>5426.<br>5427.<br>5428.<br>5429.<br>5430.<br>5431.<br>5432.<br>5433.<br>5434.<br>5435.<br>5436.<br>5437.<br>5438.<br>5439.<br>5440.<br>5441.<br>5442.<br>5443.<br>5444.<br>5445.<br>5446.<br>5447.<br>5448.<br>5449.<br>5450.<br>5451.<br>5452.<br>5453.<br>5454.<br>5455.<br>5456.<br>5457.<br>5458.<br>5459.<br>5460.<br>5461.<br>5462.<br>5463.<br>5464.<br>5465.<br>5466.<br>5467.<br>5468.<br>5469.<br>5470.<br>5471.<br>5472.<br>5473.<br>5474.<br>5475.<br>5476.<br>5477.<br>5478.<br>5479.<br>5480.<br>5481.<br>5482.<br>5483.<br>5484.<br>5485.<br>5486.<br>5487.<br>5488.<br>5489.<br>5490.<br>5491.<br>5492.<br>5493.<br>5494.<br>5495.<br>5496.<br>5497.<br>5498.<br>5499.<br>5500.<br>5501.<br>5502.<br>5503.<br>5504.<br>5505.<br>5506.<br>5507.<br>5508.<br>5509.<br>5510.<br>5511.<br>5512.<br>5513.<br>5514.<br>5515.<br>5516.<br>5517.<br>5518.<br>5519.<br>5520.<br>5521.<br>5522.<br>5523.<br>5524.<br>5525.<br>5526.<br>5527.<br>5528.<br>5529.<br>5530.<br>5531.<br>5532.<br>5533.<br>5534.<br>5535.<br>5536.<br>5537.<br>5538.<br>5539.<br>5540.<br>5541.<br>5542.<br>5543.<br>5544.<br>5545.<br>5546.<br>5547.<br>5548.<br>5549.<br>5550.<br>5551.<br>5552.<br>5553.<br>5554.<br>5555.<br>5556.<br>5557.<br>5558.<br>5559.<br>5560.<br>5561.<br>5562.<br>5563.<br>5564.<br>5565.<br>5566.<br>5567.<br>5568.<br>5569.<br>5570.<br>5571.<br>5572.<br>5573.<br>5574.<br>5575.<br>5576.<br>5577.<br>5578.<br>5579.<br>5580.<br>5581.<br>5582.<br>5583.<br>5584.<br>5585.<br>5586.<br>5587.<br>5588.<br>5589.<br>5590.<br>5591.<br>5592.<br>5593.<br>5594.<br>5595.<br>5596.<br>5597.<br>5598.<br>5599.<br>5600.<br>5601.<br>5602.<br>5603.<br>5604.<br>5605.<br>5606.<br>5607.<br>5608.<br>5609.<br>5610.<br>5611.<br>5612.<br>5613.<br>5614.<br>5615.<br>5616.<br>5617.<br>5618.<br>5619.<br>5620.<br>5621.<br>5622.<br>5623.<br>5624.<br>5625.<br>5626.<br>5627.<br>5628.<br>5629.<br>5630.<br>5631.<br>5632.<br>5633.<br>5634.<br>5635.<br>5636.<br>5637.<br>5638.<br>5639.<br>5640.<br>5641.<br>5642.<br>5643.<br>5644.<br>5645.<br>5646.<br>5647.<br>5648.<br>5649.<br>5650.<br>5651.<br>5652.<br>5653.<br>5654.<br>5655.<br>5656.<br>5657.<br>5658.<br>5659.<br>5660.<br>5661.<br>5662.<br>5663.<br>5664.<br>5665.<br>5666.<br>5667.<br>5668.<br>5669.<br>5670.<br>5671.<br>5672.<br>5673.<br>5674.<br>5675.<br>5676.<br>5677.<br>5678.<br>5679.<br>5680.<br>5681.<br>5682.<br>5683.<br>5684.<br>5685.<br>5686.<br>5687.<br>5688.<br>5689.<br>5690.<br>5691.<br>5692.<br>5693.<br>5694.<br>5695.<br>5696.<br>5697.<br>5698.<br>5699.<br>5700.<br>5701.<br>5702.<br>5703.<br>5704.<br>5705.<br>5706.<br>5707.<br>5708.<br>5709.<br>5710.<br>5711.<br>5712.<br>5713.<br>5714.<br>5715.<br>5716.<br>5717.<br>5718.<br>5719.<br>5720.<br>5721.<br>5722.<br>5723.<br>5724.<br>5725.<br>5726.<br>5727.<br>5728.<br>5729.<br>5730.<br>5731.<br>5732.<br>5733.<br>5734.<br>5735.<br>5736.<br>5737.<br>5738.<br>5739.<br>5740.<br>5741.<br>5742.<br>5743.<br>5744.<br>5745.<br>5746.<br>5747.<br>5748.<br>5749.<br>5750.<br>5751.<br>5752.<br>5753.<br>5754.<br>5755.<br>5756.<br>5757.<br>5758.<br>5759.<br>5760.<br>5761.<br>5762.<br>5763.<br>5764.<br>5765.<br>5766.<br>5767.<br>5768.<br>5769.<br>5770.<br>5771.<br>5772.<br>5773.<br>5774.<br>5775.<br>5776.<br>5777.<br>5778.<br>5779.<br>5780.<br>5781.<br>5782.<br>5783.<br>5784.<br>5785.<br>5786.<br>5787.<br>5788.<br>5789.<br>5790.<br>5791.<br>5792.<br>5793.<br>5794.<br>5795.<br>5796.<br>5797.<br>5798.<br>5799.<br>5800.<br>5801.<br>5802.<br>5803.<br>5804.<br>5805.<br>5806.<br>5807.<br>5808.<br>5809.<br>5810.<br>5811.<br>5812.<br>5813.<br>5814.<br>5815.<br>5816.<br>5817.<br>5818.<br>5819.<br>5820.<br>5821.<br>5822.<br>5823.<br>5824.<br>5825.<br>5826.<br>5827.<br>5828.<br>5829.<br>5830.<br>5831.<br>5832.<br>5833.<br>5834.<br>5835.<br>5836.<br>5837.<br>5838.<br>5839.<br>5840.<br>5841.<br>5842.<br>5843.<br>5844.<br>5845.<br>5846.<br>5847.<br>5848.<br>5849.<br>5850.<br>5851.<br>5852.<br>5853.<br>5854.<br>5855.<br>5856.<br>5857.<br>5858.<br>5859.<br>5860.<br>5861.<br>5862.<br>5863.<br>5864.<br>5865.<br>5866.<br>5867.<br>5868.<br>5869.<br>5870.<br>5871.<br>5872.<br>5873.<br>5874.<br>5875.<br>5876.<br>5877.<br>5878.<br>5879.<br>5880.<br>5881.<br>5882.<br>5883.<br>5884.<br>5885.<br>5886.<br>5887.<br>5888.<br>5889.<br>5890.<br>5891.<br>5892.<br>5893.<br>5894.<br>5895.<br>5896.<br>5897.<br>5898.<br>5899.<br>5900.<br>5901.<br>5902.<br>5903.<br>5904.<br>5905.<br>5906.<br>5907.<br>5908.<br>5909.<br>5910.<br>5911.<br>5912.<br>5913.<br>5914.<br>5915.<br>5916.<br>5917.<br>5918.<br>5919.<br>5920.<br>5921.<br>5922.<br>5923.<br>5924.<br>5925.<br>5926.<br>5927.<br>5928.<br>5929.<br>5930.<br>5931.<br>5932.<br>5933.<br>5934.<br>5935.<br>5936.<br>5937.<br>5938.<br>5939.<br>5940.<br>5941.<br>5942.<br>5943.<br>5944.<br>5945.<br>5946.<br>5947.<br>5948.<br>5949.<br>5950.<br>5951.<br>5952.<br>5953.<br>5954.<br>5955.<br>5956.<br>5957.<br>5958.<br>5959.<br>5960.<br>5961.<br>5962.<br>5963.<br>5964.<br>5965.<br>5966.<br>5967.<br>5968.<br>5969.<br>5970.<br>5971.<br>5972.<br>5973.<br>5974.<br>5975.<br>5976.<br>5977.<br>5978.<br>5979.<br>5980.<br>5981.<br>5982.<br>5983.<br>5984.<br>5985.<br>5986.<br>5987.<br>5988.<br>5989.<br>5990.<br>5991.<br>5992.<br>5993.<br>5994.<br>5995.<br>5996.<br>5997.<br>5998.<br>5999.<br>6000.<br>6001.<br>6002.<br>6003.<br>6004.<br>6005.<br>6006.<br>6007.<br>6008.<br>6009.<br>6010.<br>6011.<br>6012.<br>6013.<br>6014.<br>6015.<br>6016.<br>6017.<br>6018.<br>6019.<br>6020.<br>6021.<br>6022.<br>6023.<br>6024.<br>6025.<br>6026.<br>6027.<br>6028.<br>6029.<br>6030.<br>6031.<br>6032.<br>6033.<br>6034.<br>6035.<br>6036.<br>6037.<br>6038.<br>6039.<br>6040.<br>6041.<br>6042.<br>6043.<br>6044.<br>6045.<br>6046.<br>6047.<br>6048.<br>6049.<br>6050.<br>6051.<br>6052.<br>6053.<br>6054.<br>6055.<br>6056.<br>6057.<br>6058.<br>6059.<br>6060.<br>6061.<br>6062.<br>6063.<br>6064.<br>6065.<br>6066.<br>6067.<br>6068.<br>6069.<br>6070.<br>6071.<br>6072.<br>6073.<br>6074.<br>6075.<br>6076.<br>6077.<br>6078.<br>6079.<br>6080.<br>6081.<br>6082.<br>6083.<br>6084.<br>6085.<br>6086.<br>6087.<br>6088.<br>6089.<br>6090.<br>6091.<br>6092.<br>6093.<br>6094.<br>6095.<br>6096.<br>6097.<br>6098.<br>6099.<br>6100.<br>6101.<br>6102.<br>6103.<br>6104.<br>6105.<br>6106.<br>6107.<br>6108.<br>6109.<br>6110.<br>6111.<br>6112.<br>6113.<br>6114.<br>6115.<br>6116.<br>6117.<br>6118.<br>6119.<br>6120.<br>6121.<br>6122.<br>6123.<br>6124.<br>6125.<br>6126.<br>6127.<br>6128.<br>6129.<br>6130.<br>6131.<br>6132.<br>6133.<br>6134.<br>6135.<br>6136.<br>6137.<br>6138.<br>6139.<br>6140.<br>6141.<br>6142.<br>6143.<br>6144.<br>6145.<br>6146.<br>6147.<br>6148.<br>6149.<br>6150.<br>6151.<br>6152.<br>6153.<br>6154.<br>6155.<br>6156.<br>6157.<br>6158.<br>6159.<br>6160.<br>6161.<br>6162.<br>6163.<br>6164.<br>6165.<br>6166.<br>6167.<br>6168.<br>6169.<br>6170.<br>6171.<br>6172.<br>6173.<br>6174.<br>6175.<br>6176.<br>6177.<br>6178.<br>6179.<br>6180.<br>6181.<br>6182.<br>6183.<br>6184.<br>6185.<br>6186.<br>6187.<br>6188.<br>6189.<br>6190.<br>6191.<br>6192.<br>6193.<br>6194.<br>6195.<br>6196.<br>6197.<br>6198.<br>6199.<br>6200.<br>6201.<br>6202.<br>6203.<br>6204.<br>6205.<br>6206.<br>6207.<br>6208.<br>6209.<br>6210.<br>6211.<br>6212.<br>6213.<br>6214.<br>6215.<br>6216.<br>6217.<br>6218.<br>6219.<br>6220.<br>6221.<br>6222.<br>6223.<br>6224.<br>6225.<br>6226.<br>6227.<br>6228.<br>6229.<br>6230.<br>6231.<br>6232.<br>6233.<br>6234.<br>6235.<br>6236.<br>6237.<br>6238.<br>6239.<br>6240.<br>6241.<br>6242.<br>6243.<br>6244.<br>6245.<br>6246.<br>6247.<br>6248.<br>6249.<br>6250.<br>6251.<br>6252.<br>6253.<br>6254.<br>6255.<br>6256.<br>6257.<br>6258.<br>6259.<br>6260.<br>6261.<br>6262.<br>6263.<br>6264.<br>6265.<br>6266.<br>6267.<br>6268.<br>6269.<br>6270.<br>6271.<br>6272.<br>6273.<br>6274.<br>6275.<br>6276.<br>6277.<br>6278.<br>6279.<br>6280.<br>6281.<br>6282.<br>6283.<br>6284.<br>6285.<br>6286.<br>6287.<br>6288.<br>6289.<br>6290.<br>6291.<br>6292.<br>6293.<br>6294.<br>6295.<br>6296.<br>6297.<br>6298.<br>6299.<br>6300.<br>6301.<br>6302.<br>6303.<br>6304.<br>6305.<br>6306.<br>6307.<br>6308.<br>6309.<br>6310.<br>6311.<br>6312.<br>6313.<br>6314.<br>6315.<br>6316.<br>6317.<br>6318.<br>6319.<br>6320.<br>6321.<br>6322.<br>6323.<br>6324.<br>6325.<br>6326.<br>6327.<br>6328.<br>6329.<br>6330.<br>6331.<br>6332.<br>6333.<br>6334.<br>6335.<br>6336.<br>6337.<br>6338.<br>6339.<br>6340.<br>6341.<br>6342.<br>6343.<br>6344.<br>6345.<br>6346.<br>6347.<br>6348.<br>6349.<br>6350.<br>6351.<br>6352.<br>6353.<br>6354.<br>6355.<br>6356.<br>6357.<br>6358.<br>6359.<br>6360.<br>6361.<br>6362.<br>6363.<br>6364.<br>6365.<br>6366.<br>6367.<br>6368.<br>6369.<br>6370.<br>6371.<br>6372.<br>6373.<br>6374.<br>6375.<br>6376.<br>6377.<br>6378.<br>6379.<br>6380.<br>6381.<br>6382.<br>6383.<br>6384.<br>6385.<br>6386.<br>6387.<br>6388.<br>6389.<br>6390.<br>6391.<br>6392.<br>6393.<br>6394.<br>6395.<br>6396.<br>6397.<br>6398.<br>6399.<br>6400.<br>6401.<br>6402.<br>6403.<br>6404.<br>6405.<br>6406.<br>6407.<br>6408.<br>6409.<br>6410.<br>6411.<br>6412.<br>6413.<br>6414.<br>6415.<br>6416.<br>6417.<br>6418.<br>6419.<br>6420.<br>6421.<br>6422.<br>6423.<br>6424.<br>6425.<br>6426.<br>6427.<br>6428.<br>6429.<br>6430.<br>6431.<br>6432.<br>6433.<br>6434.<br>6435.<br>6436.<br>6437.<br>6438.<br>6439.<br>6440.<br>6441.<br>6442.<br>6443.<br>6444.<br>6445.<br>6446.<br>6447.<br>6448.<br>6449.<br>6450.<br>6451.<br>6452.<br>6453.<br>6454.<br>6455.<br>6456.<br>6457.<br>6458.<br>6459.<br>6460.<br>6461.<br>6462.<br>6463.<br>6464.<br>6465.<br>6466.<br>6467.<br>6468.<br>6469.<br>6470.<br>6471.<br>6472.<br>6473.<br>6474.<br>6475.<br>6476.<br>6477.<br>6478.<br>6479.<br>6480.<br>6481.<br>6482.<br>6483.<br>6484.<br>6485.<br>6486.<br>6487.<br>6488.<br>6489.<br>6490.<br>6491.<br>6492.<br>6493.<br>6494.<br>6495.<br>6496.<br>6497.<br>6498.<br>6499.<br>6500.<br>6501.<br>6502.<br>6503.<br>6504.<br>6505.<br>6506.<br>6507.<br>6508.<br>6509.<br>6510.<br>6511.<br>6512.<br>6513.<br>6514.<br>6515.<br>6516.<br>6517.<br>6518.<br>6519.<br>6520.<br>6521.<br>6522.<br>6523.<br>6524.<br>6525.<br>6526.<br>6527.<br>6528.<br>6529.<br>6530.<br>6531.<br>6532.<br>6533.<br>6534.<br>6535.<br>6536.<br>6537.<br>6538.<br>6539.<br>6540.<br>6541.<br>6542.<br>6543.<br>6544.<br>6545.<br>6546.<br>6547.<br>6548.<br>6549.<br>6550.<br>6551.<br>6552.<br>6553.<br>6554.<br>6555.<br>6556.<br>6557.<br>6558.<br>6559.<br>6560.<br>6561.<br>6562.<br>6563.<br>6564.<br>6565.<br>6566.<br>6567.<br>6568.<br>6569.<br>6570.<br>6571.<br>6572.<br>6573.<br>6574.<br>6575.<br>6576.<br>6577.<br>6578.<br>6579.<br>6580.<br>6581.<br>6582.<br>6583.<br>6584.<br>6585.<br>6586.<br>6587.<br>6588.<br>6589.<br>6590.<br>6591.<br>6592.<br>6593.<br>6594.<br>6595.<br>6596.<br>6597.<br>6598.<br>6599.<br>6600.<br>6601.<br>6602.<br>6603.<br>6604.<br>6605.<br>6606.<br>6607.<br>6608.<br>6609.<br>6610.<br>6611.<br>6612.<br>6613.<br>6614.<br>6615.<br>6616.<br>6617.<br>6618.<br>6619.<br>6620.<br>6621.<br>6622.<br>6623.<br>6624.<br>6625.<br>6626.<br>6627.<br>6628.<br>6629.<br>6630.<br>6631.<br>6632.<br>6633.<br>6634.<br>6635.<br>6636.<br>6637.<br>6638.<br>6639.<br>6640.<br>6641.<br>6642.<br>6643.<br>6644.<br>6645.<br>6646.<br>6647.<br>6648.<br>6649.<br>6650.<br>6651.<br>6652.<br>6653.<br>6654.<br>6655.<br>6656.<br>6657.<br>6658.<br>6659.<br>6660.<br>6661.<br>6662.<br>6663.<br>6664.<br>6665.<br>6666.<br>6667.<br>6668.<br>6669.<br>6670.<br>6671.<br>6672.<br>6673.<br>6674.<br>6675.<br>6676.<br>6677.<br>6678.<br>6679.<br>6680.<br>6681.<br>6682.<br>6683.<br>6684.<br>6685.<br>6686.<br>6687.<br>6688.<br>6689.<br>6690.<br>6691.<br>6692.<br>6693.<br>6694.<br>6695.<br>6696.<br>6697.<br>6698.<br>6699.<br>6700.<br>6701.<br>6702.<br>6703.<br>6704.<br>6705.<br>6706.<br>6707.<br>6708.<br>6709.<br>6710.<br>6711.<br>6712.<br>6713.<br>6714.<br>6715.<br>6716.<br>6717.<br>6718.<br>6719.<br>6720.<br>6721.<br>6722.<br>6723.<br>6724.<br>6725.<br>6726.<br>6727.<br>6728.<br>6729.<br>6730.<br>6731.<br>6732.<br>6733.<br>6734.<br>6735.<br>6736.<br>6737.<br>6738.<br>6739.<br>6740.<br>6741.<br>6742.<br>6743.<br>6744.<br>6745.<br>6746.<br>6747.<br>6748.<br>6749.<br>6750.<br>6751.<br>6752.<br>6753.<br>6754.<br>6755.<br>6756.<br>6757.<br>6758.<br>6759.<br>6760.<br>6761.<br>6762.<br>6763.<br>6764.<br>6765.<br>6766.<br>6767.<br>6768.<br>6769.<br>6770.<br>6771.<br>6772.<br>6773.<br>6774.<br>6775.<br>6776.<br>6777.<br>6778.<br>6779.<br>6780.<br>6781.<br>6782.<br>6783.<br>6784.<br>6785.<br>6786.<br>6787.<br>6788.<br>6789.<br>6790.<br>6791.<br>6792.<br>6793.<br>6794.<br>6795.<br>6796.<br>6797.<br>6798.<br>6799.<br>6800.<br>6801.<br>6802.<br>6803.<br>6804.<br>6805.<br>6806.<br>6807.<br>6808.<br>6809.<br>6810.<br>6811.<br>6812.<br>6813.<br>6814.<br>6815.<br>6816.<br>6817.<br>6818.<br>6819.<br>6820.<br>6821.<br>6822.<br>6823.<br>6824.<br>6825.<br>6826.<br>6827.<br>6828.<br>6829.<br>6830.<br>6831.<br>6832.<br>6833.<br>6834.<br>6835.<br>6836.<br>6837.<br>6838.<br>6839.<br>6840.<br>6841.<br>6842.<br>6843.<br>6844.<br>6845.<br>6846.<br>6847.<br>6848.<br>6849.<br>6850.<br>6851.<br>6852.<br>6853.<br>6854.<br>6855.<br>6856.<br>6857.<br>6858.<br>6859.<br>6860.<br>6861.<br>6862.<br>6863.<br>6864.<br>6865.<br>6866.<br>6867.<br>6868.<br>6869.<br>6870.<br>6871.<br>6872.<br>6873.<br>6874.<br>6875.<br>6876.<br>6877.<br>6878.<br>6879.<br>6880.<br>6881.<br>6882.<br>6883.<br>6884.<br>6885.<br>6886.<br>6887.<br>6888.<br>6889.<br>6890.<br>6891.<br>6892.<br>6893.<br>6894.<br>6895.<br>6896.<br>6897.<br>6898.<br>6899.<br>6900.<br>6901.<br>6902.<br>6903.<br>6904.<br>6905.<br>6906.<br>6907.<br>6908.<br>6909.<br>6910.<br>6911.<br>6912.<br>6913.<br>6914.<br>6915.<br>6916.<br>6917.<br>6918.<br>6919.<br>6920.<br>6921.<br>6922.<br>6923.<br>6924.<br>6925.<br>6926.<br>6927.<br>6928.<br>6929.<br>6930.<br>6931.<br>6932.<br>6933.<br>6934.<br>6935.<br>6936.<br>6937.<br>6938.<br>6939.<br>6940.<br>6941.<br>6942.<br>6943.<br>6944.<br>6945.<br>6946.<br>6947.<br>6948.<br>6949.<br>6950.<br>6951.<br>6952.<br>6953.<br>6954.<br>6955.<br>6956.<br>6957.<br>6958.<br>6959.<br>6960.<br>6961.<br>6962.<br>6963.<br>6964.<br>6965.<br>6966.<br>6967.<br>6968.<br>6969.<br>6970.<br>6971.<br>6972.<br>6973.<br>6974.<br>6975.<br>6976.<br>6977.<br>6978.<br>6979.<br>6980.<br>6981.<br>6982.<br>6983.<br>6984.<br></code_line></pre></td>
<td class='lines'><pre><code class="prettyprint">// SPDX-License-Identifier: GPL-2.0

#include &lt;linux/objtool.h&gt;
#include &lt;linux/percpu.h&gt;

#include &lt;asm/debugreg.h&gt;
#include &lt;asm/mmu_context.h&gt;

#include &quot;cpuid.h&quot;
#include &quot;evmcs.h&quot;
#include &quot;hyperv.h&quot;
#include &quot;mmu.h&quot;
#include &quot;nested.h&quot;
#include &quot;pmu.h&quot;
#include &quot;sgx.h&quot;
#include &quot;trace.h&quot;
#include &quot;vmx.h&quot;
#include &quot;x86.h&quot;

static bool __read_mostly enable_shadow_vmcs = 1;
module_param_named(enable_shadow_vmcs, enable_shadow_vmcs, bool, S_IRUGO);

static bool __read_mostly nested_early_check = 0;
module_param(nested_early_check, bool, S_IRUGO);

#define CC KVM_NESTED_VMENTER_CONSISTENCY_CHECK

/*
 * Hyper-V requires all of these, so mark them as supported even though
 * they are just treated the same as all-context.
 */
#define VMX_VPID_EXTENT_SUPPORTED_MASK		\
	(VMX_VPID_EXTENT_INDIVIDUAL_ADDR_BIT |	\
	VMX_VPID_EXTENT_SINGLE_CONTEXT_BIT |	\
	VMX_VPID_EXTENT_GLOBAL_CONTEXT_BIT |	\
	VMX_VPID_EXTENT_SINGLE_NON_GLOBAL_BIT)

#define VMX_MISC_EMULATED_PREEMPTION_TIMER_RATE 5

enum {
	VMX_VMREAD_BITMAP,
	VMX_VMWRITE_BITMAP,
	VMX_BITMAP_NR
};
static unsigned long *vmx_bitmap[VMX_BITMAP_NR];

#define vmx_vmread_bitmap                    (vmx_bitmap[VMX_VMREAD_BITMAP])
#define vmx_vmwrite_bitmap                   (vmx_bitmap[VMX_VMWRITE_BITMAP])

struct shadow_vmcs_field {
	u16	encoding;
	u16	offset;
};
static struct shadow_vmcs_field shadow_read_only_fields[] = {
#define SHADOW_FIELD_RO(x, y) { x, offsetof(struct vmcs12, y) },
#include &quot;vmcs_shadow_fields.h&quot;
};
static int max_shadow_read_only_fields =
	ARRAY_SIZE(shadow_read_only_fields);

static struct shadow_vmcs_field shadow_read_write_fields[] = {
#define SHADOW_FIELD_RW(x, y) { x, offsetof(struct vmcs12, y) },
#include &quot;vmcs_shadow_fields.h&quot;
};
static int max_shadow_read_write_fields =
	ARRAY_SIZE(shadow_read_write_fields);

static void init_vmcs_shadow_fields(void)
{
	int i, j;

	memset(vmx_vmread_bitmap, 0xff, PAGE_SIZE);
	memset(vmx_vmwrite_bitmap, 0xff, PAGE_SIZE);

	for (i = j = 0; i &lt; max_shadow_read_only_fields; i++) {
		struct shadow_vmcs_field entry = shadow_read_only_fields[i];
		u16 field = entry.encoding;

		if (vmcs_field_width(field) == VMCS_FIELD_WIDTH_U64 &amp;&amp;
		    (i + 1 == max_shadow_read_only_fields ||
		     shadow_read_only_fields[i + 1].encoding != field + 1))
			pr_err(&quot;Missing field from shadow_read_only_field %x\n&quot;,
			       field + 1);

		clear_bit(field, vmx_vmread_bitmap);
		if (field &amp; 1)
#ifdef CONFIG_X86_64
			continue;
#else
			entry.offset += sizeof(u32);
#endif
		shadow_read_only_fields[j++] = entry;
	}
	max_shadow_read_only_fields = j;

	for (i = j = 0; i &lt; max_shadow_read_write_fields; i++) {
		struct shadow_vmcs_field entry = shadow_read_write_fields[i];
		u16 field = entry.encoding;

		if (vmcs_field_width(field) == VMCS_FIELD_WIDTH_U64 &amp;&amp;
		    (i + 1 == max_shadow_read_write_fields ||
		     shadow_read_write_fields[i + 1].encoding != field + 1))
			pr_err(&quot;Missing field from shadow_read_write_field %x\n&quot;,
			       field + 1);

		WARN_ONCE(field &gt;= GUEST_ES_AR_BYTES &amp;&amp;
			  field &lt;= GUEST_TR_AR_BYTES,
			  &quot;Update vmcs12_write_any() to drop reserved bits from AR_BYTES&quot;);

		/*
		 * PML and the preemption timer can be emulated, but the
		 * processor cannot vmwrite to fields that don&#x27;t exist
		 * on bare metal.
		 */
		switch (field) {
		case GUEST_PML_INDEX:
			if (!cpu_has_vmx_pml())
				continue;
			break;
		case VMX_PREEMPTION_TIMER_VALUE:
			if (!cpu_has_vmx_preemption_timer())
				continue;
			break;
		case GUEST_INTR_STATUS:
			if (!cpu_has_vmx_apicv())
				continue;
			break;
		default:
			break;
		}

		clear_bit(field, vmx_vmwrite_bitmap);
		clear_bit(field, vmx_vmread_bitmap);
		if (field &amp; 1)
#ifdef CONFIG_X86_64
			continue;
#else
			entry.offset += sizeof(u32);
#endif
		shadow_read_write_fields[j++] = entry;
	}
	max_shadow_read_write_fields = j;
}

/*
 * The following 3 functions, nested_vmx_succeed()/failValid()/failInvalid(),
 * set the success or error code of an emulated VMX instruction (as specified
 * by Vol 2B, VMX Instruction Reference, &quot;Conventions&quot;), and skip the emulated
 * instruction.
 */
static int nested_vmx_succeed(struct kvm_vcpu *vcpu)
{
<blue>	vmx_set_rflags(vcpu, vmx_get_rflags(vcpu)</blue>
			&amp; ~(X86_EFLAGS_CF | X86_EFLAGS_PF | X86_EFLAGS_AF |
			    X86_EFLAGS_ZF | X86_EFLAGS_SF | X86_EFLAGS_OF));
	return kvm_skip_emulated_instruction(vcpu);
}

static int nested_vmx_failInvalid(struct kvm_vcpu *vcpu)
{
<blue>	vmx_set_rflags(vcpu, (vmx_get_rflags(vcpu)</blue>
			&amp; ~(X86_EFLAGS_PF | X86_EFLAGS_AF | X86_EFLAGS_ZF |
			    X86_EFLAGS_SF | X86_EFLAGS_OF))
			| X86_EFLAGS_CF);
	return kvm_skip_emulated_instruction(vcpu);
}

static int nested_vmx_failValid(struct kvm_vcpu *vcpu,
				u32 vm_instruction_error)
{
<blue>	vmx_set_rflags(vcpu, (vmx_get_rflags(vcpu)</blue>
			&amp; ~(X86_EFLAGS_CF | X86_EFLAGS_PF | X86_EFLAGS_AF |
			    X86_EFLAGS_SF | X86_EFLAGS_OF))
			| X86_EFLAGS_ZF);
	get_vmcs12(vcpu)-&gt;vm_instruction_error = vm_instruction_error;
	/*
	 * We don&#x27;t need to force sync to shadow VMCS because
	 * VM_INSTRUCTION_ERROR is not shadowed. Enlightened VMCS &#x27;shadows&#x27; all
	 * fields and thus must be synced.
	 */
	if (to_vmx(vcpu)-&gt;nested.hv_evmcs_vmptr != EVMPTR_INVALID)
<yellow>		to_vmx(vcpu)->nested.need_vmcs12_to_shadow_sync = true;</yellow>

<blue>	return kvm_skip_emulated_instruction(vcpu);</blue>
}

static int nested_vmx_fail(struct kvm_vcpu *vcpu, u32 vm_instruction_error)
{
	struct vcpu_vmx *vmx = to_vmx(vcpu);

	/*
	 * failValid writes the error number to the current VMCS, which
	 * can&#x27;t be done if there isn&#x27;t a current VMCS.
	 */
<blue>	if (vmx->nested.current_vmptr == INVALID_GPA &&</blue>
<yellow>	    !evmptr_is_valid(vmx->nested.hv_evmcs_vmptr))</yellow>
<yellow>		return nested_vmx_failInvalid(vcpu);</yellow>

<blue>	return nested_vmx_failValid(vcpu, vm_instruction_error);</blue>
<blue>}</blue>

<yellow>static void nested_vmx_abort(struct kvm_vcpu *vcpu, u32 indicator)</yellow>
{
	/* TODO: not to reset guest simply here. */
<blue>	kvm_make_request(KVM_REQ_TRIPLE_FAULT, vcpu);</blue>
<yellow>	pr_debug_ratelimited("kvm: nested vmx abort, indicator %d\n", indicator);</yellow>
<blue>}</blue>

static inline bool vmx_control_verify(u32 control, u32 low, u32 high)
{
	return fixed_bits_valid(control, low, high);
}

static inline u64 vmx_control_msr(u32 low, u32 high)
{
<blue>	return low | ((u64)high << 32);</blue>
}

static void vmx_disable_shadow_vmcs(struct vcpu_vmx *vmx)
{
<blue>	secondary_exec_controls_clearbit(vmx, SECONDARY_EXEC_SHADOW_VMCS);</blue>
<blue>	vmcs_write64(VMCS_LINK_POINTER, INVALID_GPA);</blue>
<blue>	vmx->nested.need_vmcs12_to_shadow_sync = false;</blue>
}

static inline void nested_release_evmcs(struct kvm_vcpu *vcpu)
{
	struct vcpu_vmx *vmx = to_vmx(vcpu);

<blue>	if (evmptr_is_valid(vmx->nested.hv_evmcs_vmptr)) {</blue>
<yellow>		kvm_vcpu_unmap(vcpu, &vmx->nested.hv_evmcs_map, true);</yellow>
		vmx-&gt;nested.hv_evmcs = NULL;
	}

<blue>	vmx->nested.hv_evmcs_vmptr = EVMPTR_INVALID;</blue>
}

static void vmx_sync_vmcs_host_state(struct vcpu_vmx *vmx,
				     struct loaded_vmcs *prev)
{
	struct vmcs_host_state *dest, *src;

<blue>	if (unlikely(!vmx->guest_state_loaded))</blue>
		return;

	src = &amp;prev-&gt;host_state;
<blue>	dest = &vmx->loaded_vmcs->host_state;</blue>

	vmx_set_host_fs_gs(dest, src-&gt;fs_sel, src-&gt;gs_sel, src-&gt;fs_base, src-&gt;gs_base);
	dest-&gt;ldt_sel = src-&gt;ldt_sel;
#ifdef CONFIG_X86_64
	dest-&gt;ds_sel = src-&gt;ds_sel;
	dest-&gt;es_sel = src-&gt;es_sel;
#endif
}

static void vmx_switch_vmcs(struct kvm_vcpu *vcpu, struct loaded_vmcs *vmcs)
{
	struct vcpu_vmx *vmx = to_vmx(vcpu);
	struct loaded_vmcs *prev;
	int cpu;

<blue>	if (WARN_ON_ONCE(vmx->loaded_vmcs == vmcs))</blue>
		return;

<blue>	cpu = get_cpu();</blue>
	prev = vmx-&gt;loaded_vmcs;
	vmx-&gt;loaded_vmcs = vmcs;
	vmx_vcpu_load_vmcs(vcpu, cpu, prev);
<blue>	vmx_sync_vmcs_host_state(vmx, prev);</blue>
<blue>	put_cpu();</blue>

<blue>	vcpu->arch.regs_avail = ~VMX_REGS_LAZY_LOAD_SET;</blue>

	/*
	 * All lazily updated registers will be reloaded from VMCS12 on both
	 * vmentry and vmexit.
	 */
	vcpu-&gt;arch.regs_dirty = 0;
<blue>}</blue>

/*
 * Free whatever needs to be freed from vmx-&gt;nested when L1 goes down, or
 * just stops using VMX.
 */
static void free_nested(struct kvm_vcpu *vcpu)
<blue>{</blue>
	struct vcpu_vmx *vmx = to_vmx(vcpu);

<blue>	if (WARN_ON_ONCE(vmx->loaded_vmcs != &vmx->vmcs01))</blue>
		vmx_switch_vmcs(vcpu, &amp;vmx-&gt;vmcs01);

<blue>	if (!vmx->nested.vmxon && !vmx->nested.smm.vmxon)</blue>
		return;

<blue>	kvm_clear_request(KVM_REQ_GET_NESTED_STATE_PAGES, vcpu);</blue>

	vmx-&gt;nested.vmxon = false;
	vmx-&gt;nested.smm.vmxon = false;
	vmx-&gt;nested.vmxon_ptr = INVALID_GPA;
	free_vpid(vmx-&gt;nested.vpid02);
	vmx-&gt;nested.posted_intr_nv = -1;
	vmx-&gt;nested.current_vmptr = INVALID_GPA;
<blue>	if (enable_shadow_vmcs) {</blue>
		vmx_disable_shadow_vmcs(vmx);
<blue>		vmcs_clear(vmx->vmcs01.shadow_vmcs);</blue>
<blue>		free_vmcs(vmx->vmcs01.shadow_vmcs);</blue>
		vmx-&gt;vmcs01.shadow_vmcs = NULL;
	}
<blue>	kfree(vmx->nested.cached_vmcs12);</blue>
	vmx-&gt;nested.cached_vmcs12 = NULL;
	kfree(vmx-&gt;nested.cached_shadow_vmcs12);
	vmx-&gt;nested.cached_shadow_vmcs12 = NULL;
	/*
	 * Unpin physical memory we referred to in the vmcs02.  The APIC access
	 * page&#x27;s backing page (yeah, confusing) shouldn&#x27;t actually be accessed,
	 * and if it is written, the contents are irrelevant.
	 */
	kvm_vcpu_unmap(vcpu, &amp;vmx-&gt;nested.apic_access_page_map, false);
	kvm_vcpu_unmap(vcpu, &amp;vmx-&gt;nested.virtual_apic_map, true);
	kvm_vcpu_unmap(vcpu, &amp;vmx-&gt;nested.pi_desc_map, true);
	vmx-&gt;nested.pi_desc = NULL;

	kvm_mmu_free_roots(vcpu-&gt;kvm, &amp;vcpu-&gt;arch.guest_mmu, KVM_MMU_ROOTS_ALL);

<blue>	nested_release_evmcs(vcpu);</blue>

	free_loaded_vmcs(&amp;vmx-&gt;nested.vmcs02);
}

/*
 * Ensure that the current vmcs of the logical processor is the
 * vmcs01 of the vcpu before calling free_nested().
 */
void nested_vmx_free_vcpu(struct kvm_vcpu *vcpu)
{
<yellow>	vcpu_load(vcpu);</yellow>
<yellow>	vmx_leave_nested(vcpu);</yellow>
	vcpu_put(vcpu);
}

#define EPTP_PA_MASK   GENMASK_ULL(51, 12)

static bool nested_ept_root_matches(hpa_t root_hpa, u64 root_eptp, u64 eptp)
{
	return VALID_PAGE(root_hpa) &amp;&amp;
<yellow>	       ((root_eptp & EPTP_PA_MASK) == (eptp & EPTP_PA_MASK));</yellow>
}

static void nested_ept_invalidate_addr(struct kvm_vcpu *vcpu, gpa_t eptp,
				       gpa_t addr)
{
	uint i;
	struct kvm_mmu_root_info *cached_root;

<yellow>	WARN_ON_ONCE(!mmu_is_nested(vcpu));</yellow>

<blue>	for (i = 0; i < KVM_MMU_NUM_PREV_ROOTS; i++) {</blue>
<blue>		cached_root = &vcpu->arch.mmu->prev_roots[i];</blue>

<blue>		if (nested_ept_root_matches(cached_root->hpa, cached_root->pgd,</blue>
					    eptp))
<yellow>			vcpu->arch.mmu->invlpg(vcpu, addr, cached_root->hpa);</yellow>
	}
}

static void nested_ept_inject_page_fault(struct kvm_vcpu *vcpu,
		struct x86_exception *fault)
{
<blue>	struct vmcs12 *vmcs12 = get_vmcs12(vcpu);</blue>
	struct vcpu_vmx *vmx = to_vmx(vcpu);
	u32 vm_exit_reason;
	unsigned long exit_qualification = vcpu-&gt;arch.exit_qualification;

<blue>	if (vmx->nested.pml_full) {</blue>
		vm_exit_reason = EXIT_REASON_PML_FULL;
<blue>		vmx->nested.pml_full = false;</blue>
		exit_qualification &amp;= INTR_INFO_UNBLOCK_NMI;
	} else {
<blue>		if (fault->error_code & PFERR_RSVD_MASK)</blue>
			vm_exit_reason = EXIT_REASON_EPT_MISCONFIG;
		else
			vm_exit_reason = EXIT_REASON_EPT_VIOLATION;

		/*
		 * Although the caller (kvm_inject_emulated_page_fault) would
		 * have already synced the faulting address in the shadow EPT
		 * tables for the current EPTP12, we also need to sync it for
		 * any other cached EPTP02s based on the same EP4TA, since the
		 * TLB associates mappings to the EP4TA rather than the full EPTP.
		 */
<blue>		nested_ept_invalidate_addr(vcpu, vmcs12->ept_pointer,</blue>
					   fault-&gt;address);
	}

<blue>	nested_vmx_vmexit(vcpu, vm_exit_reason, 0, exit_qualification);</blue>
	vmcs12-&gt;guest_physical_address = fault-&gt;address;
}

static void nested_ept_new_eptp(struct kvm_vcpu *vcpu)
{
	struct vcpu_vmx *vmx = to_vmx(vcpu);
<blue>	bool execonly = vmx->nested.msrs.ept_caps & VMX_EPT_EXECUTE_ONLY_BIT;</blue>
<yellow>	int ept_lpage_level = ept_caps_to_lpage_level(vmx->nested.msrs.ept_caps);</yellow>

	kvm_init_shadow_ept_mmu(vcpu, execonly, ept_lpage_level,
				nested_ept_ad_enabled(vcpu),
<blue>				nested_ept_get_eptp(vcpu));</blue>
}

static void nested_ept_init_mmu_context(struct kvm_vcpu *vcpu)
{
<blue>	WARN_ON(mmu_is_nested(vcpu));</blue>

<blue>	vcpu->arch.mmu = &vcpu->arch.guest_mmu;</blue>
	nested_ept_new_eptp(vcpu);
	vcpu-&gt;arch.mmu-&gt;get_guest_pgd     = nested_ept_get_eptp;
	vcpu-&gt;arch.mmu-&gt;inject_page_fault = nested_ept_inject_page_fault;
	vcpu-&gt;arch.mmu-&gt;get_pdptr         = kvm_pdptr_read;

	vcpu-&gt;arch.walk_mmu              = &amp;vcpu-&gt;arch.nested_mmu;
}

static void nested_ept_uninit_mmu_context(struct kvm_vcpu *vcpu)
{
	vcpu-&gt;arch.mmu = &amp;vcpu-&gt;arch.root_mmu;
	vcpu-&gt;arch.walk_mmu = &amp;vcpu-&gt;arch.root_mmu;
}

static bool nested_vmx_is_page_fault_vmexit(struct vmcs12 *vmcs12,
					    u16 error_code)
{
	bool inequality, bit;

<blue>	bit = (vmcs12->exception_bitmap & (1u << PF_VECTOR)) != 0;</blue>
	inequality =
		(error_code &amp; vmcs12-&gt;page_fault_error_code_mask) !=
		 vmcs12-&gt;page_fault_error_code_match;
	return inequality ^ bit;
}

static bool nested_vmx_is_exception_vmexit(struct kvm_vcpu *vcpu, u8 vector,
					   u32 error_code)
{
<blue>	struct vmcs12 *vmcs12 = get_vmcs12(vcpu);</blue>

	/*
	 * Drop bits 31:16 of the error code when performing the #PF mask+match
	 * check.  All VMCS fields involved are 32 bits, but Intel CPUs never
	 * set bits 31:16 and VMX disallows setting bits 31:16 in the injected
	 * error code.  Including the to-be-dropped bits in the check might
	 * result in an &quot;impossible&quot; or missed exit from L1&#x27;s perspective.
	 */
	if (vector == PF_VECTOR)
<blue>		return nested_vmx_is_page_fault_vmexit(vmcs12, (u16)error_code);</blue>

<blue>	return (vmcs12->exception_bitmap & (1u << vector));</blue>
<blue>}</blue>

static int nested_vmx_check_io_bitmap_controls(struct kvm_vcpu *vcpu,
					       struct vmcs12 *vmcs12)
{
<blue>	if (!nested_cpu_has(vmcs12, CPU_BASED_USE_IO_BITMAPS))</blue>
		return 0;

<blue>	if (CC(!page_address_valid(vcpu, vmcs12->io_bitmap_a)) ||</blue>
<blue>	    CC(!page_address_valid(vcpu, vmcs12->io_bitmap_b)))</blue>
		return -EINVAL;

	return 0;
}

static int nested_vmx_check_msr_bitmap_controls(struct kvm_vcpu *vcpu,
						struct vmcs12 *vmcs12)
{
<blue>	if (!nested_cpu_has(vmcs12, CPU_BASED_USE_MSR_BITMAPS))</blue>
		return 0;

<blue>	if (CC(!page_address_valid(vcpu, vmcs12->msr_bitmap)))</blue>
		return -EINVAL;

	return 0;
}

static int nested_vmx_check_tpr_shadow_controls(struct kvm_vcpu *vcpu,
						struct vmcs12 *vmcs12)
{
<blue>	if (!nested_cpu_has(vmcs12, CPU_BASED_TPR_SHADOW))</blue>
		return 0;

<blue>	if (CC(!page_address_valid(vcpu, vmcs12->virtual_apic_page_addr)))</blue>
		return -EINVAL;

	return 0;
}

/*
 * For x2APIC MSRs, ignore the vmcs01 bitmap.  L1 can enable x2APIC without L1
 * itself utilizing x2APIC.  All MSRs were previously set to be intercepted,
 * only the &quot;disable intercept&quot; case needs to be handled.
 */
<blue>static void nested_vmx_disable_intercept_for_x2apic_msr(unsigned long *msr_bitmap_l1,</blue>
							unsigned long *msr_bitmap_l0,
							u32 msr, int type)
{
<blue>	if (type & MSR_TYPE_R && !vmx_test_msr_bitmap_read(msr_bitmap_l1, msr))</blue>
<blue>		vmx_clear_msr_bitmap_read(msr_bitmap_l0, msr);</blue>

<blue>	if (type & MSR_TYPE_W && !vmx_test_msr_bitmap_write(msr_bitmap_l1, msr))</blue>
<blue>		vmx_clear_msr_bitmap_write(msr_bitmap_l0, msr);</blue>
}

static inline void enable_x2apic_msr_intercepts(unsigned long *msr_bitmap)
{
	int msr;

	for (msr = 0x800; msr &lt;= 0x8ff; msr += BITS_PER_LONG) {
<blue>		unsigned word = msr / BITS_PER_LONG;</blue>

		msr_bitmap[word] = ~0;
		msr_bitmap[word + (0x800 / sizeof(long))] = ~0;
	}
}

#define BUILD_NVMX_MSR_INTERCEPT_HELPER(rw)					\
static inline									\
void nested_vmx_set_msr_##rw##_intercept(struct vcpu_vmx *vmx,			\
					 unsigned long *msr_bitmap_l1,		\
					 unsigned long *msr_bitmap_l0, u32 msr)	\
{										\
	if (vmx_test_msr_bitmap_##rw(vmx-&gt;vmcs01.msr_bitmap, msr) ||		\
	    vmx_test_msr_bitmap_##rw(msr_bitmap_l1, msr))			\
		vmx_set_msr_bitmap_##rw(msr_bitmap_l0, msr);			\
	else									\
		vmx_clear_msr_bitmap_##rw(msr_bitmap_l0, msr);			\
}
<blue>BUILD_NVMX_MSR_INTERCEPT_HELPER(read)</blue>
<blue>BUILD_NVMX_MSR_INTERCEPT_HELPER(write)</blue>

static inline void nested_vmx_set_intercept_for_msr(struct vcpu_vmx *vmx,
						    unsigned long *msr_bitmap_l1,
						    unsigned long *msr_bitmap_l0,
						    u32 msr, int types)
{
	if (types &amp; MSR_TYPE_R)
<blue>		nested_vmx_set_msr_read_intercept(vmx, msr_bitmap_l1,</blue>
						  msr_bitmap_l0, msr);
	if (types &amp; MSR_TYPE_W)
<blue>		nested_vmx_set_msr_write_intercept(vmx, msr_bitmap_l1,</blue>
						   msr_bitmap_l0, msr);
}

/*
 * Merge L0&#x27;s and L1&#x27;s MSR bitmap, return false to indicate that
 * we do not use the hardware.
 */
static inline bool nested_vmx_prepare_msr_bitmap(struct kvm_vcpu *vcpu,
						 struct vmcs12 *vmcs12)
{
	struct vcpu_vmx *vmx = to_vmx(vcpu);
	int msr;
	unsigned long *msr_bitmap_l1;
<blue>	unsigned long *msr_bitmap_l0 = vmx->nested.vmcs02.msr_bitmap;</blue>
	struct hv_enlightened_vmcs *evmcs = vmx-&gt;nested.hv_evmcs;
<blue>	struct kvm_host_map *map = &vmx->nested.msr_bitmap_map;</blue>

	/* Nothing to do if the MSR bitmap is not in use.  */
	if (!cpu_has_vmx_msr_bitmap() ||
<blue>	    !nested_cpu_has(vmcs12, CPU_BASED_USE_MSR_BITMAPS))</blue>
		return false;

	/*
	 * MSR bitmap update can be skipped when:
	 * - MSR bitmap for L1 hasn&#x27;t changed.
	 * - Nested hypervisor (L1) is attempting to launch the same L2 as
	 *   before.
	 * - Nested hypervisor (L1) has enabled &#x27;Enlightened MSR Bitmap&#x27; feature
	 *   and tells KVM (L0) there were no changes in MSR bitmap for L2.
	 */
<blue>	if (!vmx->nested.force_msr_bitmap_recalc && evmcs &&</blue>
	    evmcs-&gt;hv_enlightenments_control.msr_bitmap &amp;&amp;
<yellow>	    evmcs->hv_clean_fields & HV_VMX_ENLIGHTENED_CLEAN_FIELD_MSR_BITMAP)</yellow>
		return true;

	if (kvm_vcpu_map(vcpu, gpa_to_gfn(vmcs12-&gt;msr_bitmap), map))
		return false;

<blue>	msr_bitmap_l1 = (unsigned long *)map->hva;</blue>

	/*
	 * To keep the control flow simple, pay eight 8-byte writes (sixteen
	 * 4-byte writes on 32-bit systems) up front to enable intercepts for
	 * the x2APIC MSR range and selectively toggle those relevant to L2.
	 */
<blue>	enable_x2apic_msr_intercepts(msr_bitmap_l0);</blue>

<blue>	if (nested_cpu_has_virt_x2apic_mode(vmcs12)) {</blue>
<blue>		if (nested_cpu_has_apic_reg_virt(vmcs12)) {</blue>
			/*
			 * L0 need not intercept reads for MSRs between 0x800
			 * and 0x8ff, it just lets the processor take the value
			 * from the virtual-APIC page; take those 256 bits
			 * directly from the L1 bitmap.
			 */
			for (msr = 0x800; msr &lt;= 0x8ff; msr += BITS_PER_LONG) {
<blue>				unsigned word = msr / BITS_PER_LONG;</blue>

				msr_bitmap_l0[word] = msr_bitmap_l1[word];
			}
		}

<blue>		nested_vmx_disable_intercept_for_x2apic_msr(</blue>
			msr_bitmap_l1, msr_bitmap_l0,
			X2APIC_MSR(APIC_TASKPRI),
			MSR_TYPE_R | MSR_TYPE_W);

<blue>		if (nested_cpu_has_vid(vmcs12)) {</blue>
<blue>			nested_vmx_disable_intercept_for_x2apic_msr(</blue>
				msr_bitmap_l1, msr_bitmap_l0,
				X2APIC_MSR(APIC_EOI),
				MSR_TYPE_W);
<blue>			nested_vmx_disable_intercept_for_x2apic_msr(</blue>
				msr_bitmap_l1, msr_bitmap_l0,
				X2APIC_MSR(APIC_SELF_IPI),
				MSR_TYPE_W);
		}
	}

	/*
	 * Always check vmcs01&#x27;s bitmap to honor userspace MSR filters and any
	 * other runtime changes to vmcs01&#x27;s bitmap, e.g. dynamic pass-through.
	 */
#ifdef CONFIG_X86_64
<blue>	nested_vmx_set_intercept_for_msr(vmx, msr_bitmap_l1, msr_bitmap_l0,</blue>
					 MSR_FS_BASE, MSR_TYPE_RW);

<blue>	nested_vmx_set_intercept_for_msr(vmx, msr_bitmap_l1, msr_bitmap_l0,</blue>
					 MSR_GS_BASE, MSR_TYPE_RW);

<blue>	nested_vmx_set_intercept_for_msr(vmx, msr_bitmap_l1, msr_bitmap_l0,</blue>
					 MSR_KERNEL_GS_BASE, MSR_TYPE_RW);
#endif
<blue>	nested_vmx_set_intercept_for_msr(vmx, msr_bitmap_l1, msr_bitmap_l0,</blue>
					 MSR_IA32_SPEC_CTRL, MSR_TYPE_RW);

<blue>	nested_vmx_set_intercept_for_msr(vmx, msr_bitmap_l1, msr_bitmap_l0,</blue>
					 MSR_IA32_PRED_CMD, MSR_TYPE_W);

<blue>	kvm_vcpu_unmap(vcpu, &vmx->nested.msr_bitmap_map, false);</blue>

	vmx-&gt;nested.force_msr_bitmap_recalc = false;

	return true;
}

static void nested_cache_shadow_vmcs12(struct kvm_vcpu *vcpu,
				       struct vmcs12 *vmcs12)
{
	struct vcpu_vmx *vmx = to_vmx(vcpu);
	struct gfn_to_hva_cache *ghc = &amp;vmx-&gt;nested.shadow_vmcs12_cache;

<blue>	if (!nested_cpu_has_shadow_vmcs(vmcs12) ||</blue>
<blue>	    vmcs12->vmcs_link_pointer == INVALID_GPA)</blue>
		return;

<blue>	if (ghc->gpa != vmcs12->vmcs_link_pointer &&</blue>
<yellow>	    kvm_gfn_to_hva_cache_init(vcpu->kvm, ghc,</yellow>
				      vmcs12-&gt;vmcs_link_pointer, VMCS12_SIZE))
		return;

<blue>	kvm_read_guest_cached(vmx->vcpu.kvm, ghc, get_shadow_vmcs12(vcpu),</blue>
			      VMCS12_SIZE);
}

static void nested_flush_cached_shadow_vmcs12(struct kvm_vcpu *vcpu,
					      struct vmcs12 *vmcs12)
{
	struct vcpu_vmx *vmx = to_vmx(vcpu);
	struct gfn_to_hva_cache *ghc = &amp;vmx-&gt;nested.shadow_vmcs12_cache;

<blue>	if (!nested_cpu_has_shadow_vmcs(vmcs12) ||</blue>
<blue>	    vmcs12->vmcs_link_pointer == INVALID_GPA)</blue>
		return;

<blue>	if (ghc->gpa != vmcs12->vmcs_link_pointer &&</blue>
<yellow>	    kvm_gfn_to_hva_cache_init(vcpu->kvm, ghc,</yellow>
				      vmcs12-&gt;vmcs_link_pointer, VMCS12_SIZE))
		return;

<blue>	kvm_write_guest_cached(vmx->vcpu.kvm, ghc, get_shadow_vmcs12(vcpu),</blue>
			       VMCS12_SIZE);
}

/*
 * In nested virtualization, check if L1 has set
 * VM_EXIT_ACK_INTR_ON_EXIT
 */
static bool nested_exit_intr_ack_set(struct kvm_vcpu *vcpu)
{
<blue>	return get_vmcs12(vcpu)->vm_exit_controls &</blue>
		VM_EXIT_ACK_INTR_ON_EXIT;
}

static int nested_vmx_check_apic_access_controls(struct kvm_vcpu *vcpu,
					  struct vmcs12 *vmcs12)
{
<blue>	if (nested_cpu_has2(vmcs12, SECONDARY_EXEC_VIRTUALIZE_APIC_ACCESSES) &&</blue>
<blue>	    CC(!page_address_valid(vcpu, vmcs12->apic_access_addr)))</blue>
		return -EINVAL;
	else
		return 0;
}

static int nested_vmx_check_apicv_controls(struct kvm_vcpu *vcpu,
					   struct vmcs12 *vmcs12)
{
<blue>	if (!nested_cpu_has_virt_x2apic_mode(vmcs12) &&</blue>
<blue>	    !nested_cpu_has_apic_reg_virt(vmcs12) &&</blue>
<blue>	    !nested_cpu_has_vid(vmcs12) &&</blue>
	    !nested_cpu_has_posted_intr(vmcs12))
		return 0;

	/*
	 * If virtualize x2apic mode is enabled,
	 * virtualize apic access must be disabled.
	 */
<blue>	if (CC(nested_cpu_has_virt_x2apic_mode(vmcs12) &&</blue>
	       nested_cpu_has2(vmcs12, SECONDARY_EXEC_VIRTUALIZE_APIC_ACCESSES)))
		return -EINVAL;

	/*
	 * If virtual interrupt delivery is enabled,
	 * we must exit on external interrupts.
	 */
<blue>	if (CC(nested_cpu_has_vid(vmcs12) && !nested_exit_on_intr(vcpu)))</blue>
		return -EINVAL;

	/*
	 * bits 15:8 should be zero in posted_intr_nv,
	 * the descriptor address has been already checked
	 * in nested_get_vmcs12_pages.
	 *
	 * bits 5:0 of posted_intr_desc_addr should be zero.
	 */
<blue>	if (nested_cpu_has_posted_intr(vmcs12) &&</blue>
<blue>	   (CC(!nested_cpu_has_vid(vmcs12)) ||</blue>
<blue>	    CC(!nested_exit_intr_ack_set(vcpu)) ||</blue>
<blue>	    CC((vmcs12->posted_intr_nv & 0xff00)) ||</blue>
<blue>	    CC(!kvm_vcpu_is_legal_aligned_gpa(vcpu, vmcs12->posted_intr_desc_addr, 64))))</blue>
		return -EINVAL;

	/* tpr shadow is needed by all apicv features. */
<blue>	if (CC(!nested_cpu_has(vmcs12, CPU_BASED_TPR_SHADOW)))</blue>
		return -EINVAL;

	return 0;
}

<blue>static int nested_vmx_check_msr_switch(struct kvm_vcpu *vcpu,</blue>
				       u32 count, u64 addr)
{
	if (count == 0)
		return 0;

<blue>	if (!kvm_vcpu_is_legal_aligned_gpa(vcpu, addr, 16) ||</blue>
	    !kvm_vcpu_is_legal_gpa(vcpu, (addr + count * sizeof(struct vmx_msr_entry) - 1)))
		return -EINVAL;

	return 0;
}

static int nested_vmx_check_exit_msr_switch_controls(struct kvm_vcpu *vcpu,
						     struct vmcs12 *vmcs12)
{
<blue>	if (CC(nested_vmx_check_msr_switch(vcpu,</blue>
					   vmcs12-&gt;vm_exit_msr_load_count,
					   vmcs12-&gt;vm_exit_msr_load_addr)) ||
<blue>	    CC(nested_vmx_check_msr_switch(vcpu,</blue>
					   vmcs12-&gt;vm_exit_msr_store_count,
					   vmcs12-&gt;vm_exit_msr_store_addr)))
		return -EINVAL;

	return 0;
}

static int nested_vmx_check_entry_msr_switch_controls(struct kvm_vcpu *vcpu,
                                                      struct vmcs12 *vmcs12)
{
<blue>	if (CC(nested_vmx_check_msr_switch(vcpu,</blue>
					   vmcs12-&gt;vm_entry_msr_load_count,
					   vmcs12-&gt;vm_entry_msr_load_addr)))
                return -EINVAL;

	return 0;
}

static int nested_vmx_check_pml_controls(struct kvm_vcpu *vcpu,
					 struct vmcs12 *vmcs12)
{
<blue>	if (!nested_cpu_has_pml(vmcs12))</blue>
		return 0;

<blue>	if (CC(!nested_cpu_has_ept(vmcs12)) ||</blue>
<blue>	    CC(!page_address_valid(vcpu, vmcs12->pml_address)))</blue>
		return -EINVAL;

	return 0;
}

static int nested_vmx_check_unrestricted_guest_controls(struct kvm_vcpu *vcpu,
							struct vmcs12 *vmcs12)
{
<blue>	if (CC(nested_cpu_has2(vmcs12, SECONDARY_EXEC_UNRESTRICTED_GUEST) &&</blue>
	       !nested_cpu_has_ept(vmcs12)))
		return -EINVAL;
	return 0;
}

static int nested_vmx_check_mode_based_ept_exec_controls(struct kvm_vcpu *vcpu,
							 struct vmcs12 *vmcs12)
{
<blue>	if (CC(nested_cpu_has2(vmcs12, SECONDARY_EXEC_MODE_BASED_EPT_EXEC) &&</blue>
	       !nested_cpu_has_ept(vmcs12)))
		return -EINVAL;
	return 0;
}

static int nested_vmx_check_shadow_vmcs_controls(struct kvm_vcpu *vcpu,
						 struct vmcs12 *vmcs12)
{
<blue>	if (!nested_cpu_has_shadow_vmcs(vmcs12))</blue>
		return 0;

<blue>	if (CC(!page_address_valid(vcpu, vmcs12->vmread_bitmap)) ||</blue>
<blue>	    CC(!page_address_valid(vcpu, vmcs12->vmwrite_bitmap)))</blue>
		return -EINVAL;

	return 0;
}

static int nested_vmx_msr_check_common(struct kvm_vcpu *vcpu,
				       struct vmx_msr_entry *e)
{
	/* x2APIC MSR accesses are not allowed */
<blue>	if (CC(vcpu->arch.apic_base & X2APIC_ENABLE && e->index >> 8 == 0x8))</blue>
		return -EINVAL;
<blue>	if (CC(e->index == MSR_IA32_UCODE_WRITE) || /* SDM Table 35-2 */</blue>
<blue>	    CC(e->index == MSR_IA32_UCODE_REV))</blue>
		return -EINVAL;
<blue>	if (CC(e->reserved != 0))</blue>
		return -EINVAL;
	return 0;
<blue>}</blue>

static int nested_vmx_load_msr_check(struct kvm_vcpu *vcpu,
				     struct vmx_msr_entry *e)
{
<blue>	if (CC(e->index == MSR_FS_BASE) ||</blue>
<blue>	    CC(e->index == MSR_GS_BASE) ||</blue>
<blue>	    CC(e->index == MSR_IA32_SMM_MONITOR_CTL) || /* SMM is not supported */</blue>
<blue>	    nested_vmx_msr_check_common(vcpu, e))</blue>
		return -EINVAL;
	return 0;
<blue>}</blue>

static int nested_vmx_store_msr_check(struct kvm_vcpu *vcpu,
				      struct vmx_msr_entry *e)
{
<blue>	if (CC(e->index == MSR_IA32_SMBASE) || /* SMM is not supported */</blue>
<blue>	    nested_vmx_msr_check_common(vcpu, e))</blue>
		return -EINVAL;
	return 0;
}

static u32 nested_vmx_max_atomic_switch_msrs(struct kvm_vcpu *vcpu)
{
	struct vcpu_vmx *vmx = to_vmx(vcpu);
<blue>	u64 vmx_misc = vmx_control_msr(vmx->nested.msrs.misc_low,</blue>
				       vmx-&gt;nested.msrs.misc_high);

	return (vmx_misc_max_msr(vmx_misc) + 1) * VMX_MISC_MSR_LIST_MULTIPLIER;
}

/*
 * Load guest&#x27;s/host&#x27;s msr at nested entry/exit.
 * return 0 for success, entry index for failure.
 *
 * One of the failure modes for MSR load/store is when a list exceeds the
 * virtual hardware&#x27;s capacity. To maintain compatibility with hardware inasmuch
 * as possible, process all valid entries before failing rather than precheck
 * for a capacity violation.
 */
static u32 nested_vmx_load_msr(struct kvm_vcpu *vcpu, u64 gpa, u32 count)
<blue>{</blue>
	u32 i;
	struct vmx_msr_entry e;
<blue>	u32 max_msr_list_size = nested_vmx_max_atomic_switch_msrs(vcpu);</blue>

<blue>	for (i = 0; i < count; i++) {</blue>
<blue>		if (unlikely(i >= max_msr_list_size))</blue>
			goto fail;

<blue>		if (kvm_vcpu_read_guest(vcpu, gpa + i * sizeof(e),</blue>
					&amp;e, sizeof(e))) {
<blue>			pr_debug_ratelimited(</blue>
				&quot;%s cannot read MSR entry (%u, 0x%08llx)\n&quot;,
				__func__, i, gpa + i * sizeof(e));
			goto fail;
		}
<blue>		if (nested_vmx_load_msr_check(vcpu, &e)) {</blue>
<blue>			pr_debug_ratelimited(</blue>
				&quot;%s check failed (%u, 0x%x, 0x%x)\n&quot;,
				__func__, i, e.index, e.reserved);
			goto fail;
		}
<blue>		if (kvm_set_msr(vcpu, e.index, e.value)) {</blue>
<blue>			pr_debug_ratelimited(</blue>
				&quot;%s cannot write MSR (%u, 0x%x, 0x%llx)\n&quot;,
				__func__, i, e.index, e.value);
			goto fail;
		}
	}
	return 0;
fail:
	/* Note, max_msr_list_size is at most 4096, i.e. this can&#x27;t wrap. */
<blue>	return i + 1;</blue>
}

static bool nested_vmx_get_vmexit_msr_value(struct kvm_vcpu *vcpu,
					    u32 msr_index,
					    u64 *data)
{
	struct vcpu_vmx *vmx = to_vmx(vcpu);

	/*
	 * If the L0 hypervisor stored a more accurate value for the TSC that
	 * does not include the time taken for emulation of the L2-&gt;L1
	 * VM-exit in L0, use the more accurate value.
	 */
	if (msr_index == MSR_IA32_TSC) {
<blue>		int i = vmx_find_loadstore_msr_slot(&vmx->msr_autostore.guest,</blue>
						    MSR_IA32_TSC);

		if (i &gt;= 0) {
<blue>			u64 val = vmx->msr_autostore.guest.val[i].value;</blue>

			*data = kvm_read_l1_tsc(vcpu, val);
			return true;
		}
	}

<blue>	if (kvm_get_msr(vcpu, msr_index, data)) {</blue>
<yellow>		pr_debug_ratelimited("%s cannot read MSR (0x%x)\n", __func__,</yellow>
			msr_index);
		return false;
	}
	return true;
}

static bool read_and_check_msr_entry(struct kvm_vcpu *vcpu, u64 gpa, int i,
				     struct vmx_msr_entry *e)
{
<blue>	if (kvm_vcpu_read_guest(vcpu,</blue>
				gpa + i * sizeof(*e),
				e, 2 * sizeof(u32))) {
<blue>		pr_debug_ratelimited(</blue>
			&quot;%s cannot read MSR entry (%u, 0x%08llx)\n&quot;,
			__func__, i, gpa + i * sizeof(*e));
		return false;
	}
<blue>	if (nested_vmx_store_msr_check(vcpu, e)) {</blue>
<blue>		pr_debug_ratelimited(</blue>
			&quot;%s check failed (%u, 0x%x, 0x%x)\n&quot;,
			__func__, i, e-&gt;index, e-&gt;reserved);
		return false;
	}
	return true;
<blue>}</blue>

static int nested_vmx_store_msr(struct kvm_vcpu *vcpu, u64 gpa, u32 count)
{
	u64 data;
	u32 i;
	struct vmx_msr_entry e;
	u32 max_msr_list_size = nested_vmx_max_atomic_switch_msrs(vcpu);

<blue>	for (i = 0; i < count; i++) {</blue>
<blue>		if (unlikely(i >= max_msr_list_size))</blue>
			return -EINVAL;

<blue>		if (!read_and_check_msr_entry(vcpu, gpa, i, &e))</blue>
			return -EINVAL;

<blue>		if (!nested_vmx_get_vmexit_msr_value(vcpu, e.index, &data))</blue>
			return -EINVAL;

<blue>		if (kvm_vcpu_write_guest(vcpu,</blue>
					 gpa + i * sizeof(e) +
					     offsetof(struct vmx_msr_entry, value),
					 &amp;data, sizeof(data))) {
<yellow>			pr_debug_ratelimited(</yellow>
				&quot;%s cannot write MSR (%u, 0x%x, 0x%llx)\n&quot;,
				__func__, i, e.index, data);
			return -EINVAL;
		}
	}
	return 0;
}

static bool nested_msr_store_list_has_msr(struct kvm_vcpu *vcpu, u32 msr_index)
{
	struct vmcs12 *vmcs12 = get_vmcs12(vcpu);
	u32 count = vmcs12-&gt;vm_exit_msr_store_count;
	u64 gpa = vmcs12-&gt;vm_exit_msr_store_addr;
	struct vmx_msr_entry e;
	u32 i;

<blue>	for (i = 0; i < count; i++) {</blue>
<blue>		if (!read_and_check_msr_entry(vcpu, gpa, i, &e))</blue>
			return false;

<blue>		if (e.index == msr_index)</blue>
			return true;
	}
	return false;
}

static void prepare_vmx_msr_autostore_list(struct kvm_vcpu *vcpu,
					   u32 msr_index)
{
	struct vcpu_vmx *vmx = to_vmx(vcpu);
<blue>	struct vmx_msrs *autostore = &vmx->msr_autostore.guest;</blue>
	bool in_vmcs12_store_list;
	int msr_autostore_slot;
	bool in_autostore_list;
	int last;

	msr_autostore_slot = vmx_find_loadstore_msr_slot(autostore, msr_index);
	in_autostore_list = msr_autostore_slot &gt;= 0;
<blue>	in_vmcs12_store_list = nested_msr_store_list_has_msr(vcpu, msr_index);</blue>

	if (in_vmcs12_store_list &amp;&amp; !in_autostore_list) {
<blue>		if (autostore->nr == MAX_NR_LOADSTORE_MSRS) {</blue>
			/*
			 * Emulated VMEntry does not fail here.  Instead a less
			 * accurate value will be returned by
			 * nested_vmx_get_vmexit_msr_value() using kvm_get_msr()
			 * instead of reading the value from the vmcs02 VMExit
			 * MSR-store area.
			 */
<yellow>			pr_warn_ratelimited(</yellow>
				&quot;Not enough msr entries in msr_autostore.  Can&#x27;t add msr %x\n&quot;,
				msr_index);
			return;
		}
		last = autostore-&gt;nr++;
<blue>		autostore->val[last].index = msr_index;</blue>
	} else if (!in_vmcs12_store_list &amp;&amp; in_autostore_list) {
<blue>		last = --autostore->nr;</blue>
<blue>		autostore->val[msr_autostore_slot] = autostore->val[last];</blue>
	}
}

/*
 * Load guest&#x27;s/host&#x27;s cr3 at nested entry/exit.  @nested_ept is true if we are
 * emulating VM-Entry into a guest with EPT enabled.  On failure, the expected
 * Exit Qualification (for a VM-Entry consistency check VM-Exit) is assigned to
 * @entry_failure_code.
 */
static int nested_vmx_load_cr3(struct kvm_vcpu *vcpu, unsigned long cr3,
			       bool nested_ept, bool reload_pdptrs,
			       enum vm_entry_failure_code *entry_failure_code)
{
<blue>	if (CC(kvm_vcpu_is_illegal_gpa(vcpu, cr3))) {</blue>
<blue>		*entry_failure_code = ENTRY_FAIL_DEFAULT;</blue>
		return -EINVAL;
	}

	/*
	 * If PAE paging and EPT are both on, CR3 is not used by the CPU and
	 * must not be dereferenced.
	 */
<blue>	if (reload_pdptrs && !nested_ept && is_pae_paging(vcpu) &&</blue>
<blue>	    CC(!load_pdptrs(vcpu, cr3))) {</blue>
<blue>		*entry_failure_code = ENTRY_FAIL_PDPTE;</blue>
		return -EINVAL;
	}

<blue>	vcpu->arch.cr3 = cr3;</blue>
	kvm_register_mark_dirty(vcpu, VCPU_EXREG_CR3);

	/* Re-initialize the MMU, e.g. to pick up CR4 MMU role changes. */
	kvm_init_mmu(vcpu);

	if (!nested_ept)
<blue>		kvm_mmu_new_pgd(vcpu, cr3);</blue>

	return 0;
<blue>}</blue>

/*
 * Returns if KVM is able to config CPU to tag TLB entries
 * populated by L2 differently than TLB entries populated
 * by L1.
 *
 * If L0 uses EPT, L1 and L2 run with different EPTP because
 * guest_mode is part of kvm_mmu_page_role. Thus, TLB entries
 * are tagged with different EPTP.
 *
 * If L1 uses VPID and we allocated a vpid02, TLB entries are tagged
 * with different VPID (L1 entries are tagged with vmx-&gt;vpid
 * while L2 entries are tagged with vmx-&gt;nested.vpid02).
 */
static bool nested_has_guest_tlb_tag(struct kvm_vcpu *vcpu)
{
<blue>	struct vmcs12 *vmcs12 = get_vmcs12(vcpu);</blue>

<blue>	return enable_ept ||</blue>
<yellow>	       (nested_cpu_has_vpid(vmcs12) && to_vmx(vcpu)->nested.vpid02);</yellow>
}

static void nested_vmx_transition_tlb_flush(struct kvm_vcpu *vcpu,
					    struct vmcs12 *vmcs12,
					    bool is_vmenter)
{
	struct vcpu_vmx *vmx = to_vmx(vcpu);

	/*
	 * If vmcs12 doesn&#x27;t use VPID, L1 expects linear and combined mappings
	 * for *all* contexts to be flushed on VM-Enter/VM-Exit, i.e. it&#x27;s a
	 * full TLB flush from the guest&#x27;s perspective.  This is required even
	 * if VPID is disabled in the host as KVM may need to synchronize the
	 * MMU in response to the guest TLB flush.
	 *
	 * Note, using TLB_FLUSH_GUEST is correct even if nested EPT is in use.
	 * EPT is a special snowflake, as guest-physical mappings aren&#x27;t
	 * flushed on VPID invalidations, including VM-Enter or VM-Exit with
	 * VPID disabled.  As a result, KVM _never_ needs to sync nEPT
	 * entries on VM-Enter because L1 can&#x27;t rely on VM-Enter to flush
	 * those mappings.
	 */
<blue>	if (!nested_cpu_has_vpid(vmcs12)) {</blue>
<blue>		kvm_make_request(KVM_REQ_TLB_FLUSH_GUEST, vcpu);</blue>
		return;
	}

	/* L2 should never have a VPID if VPID is disabled. */
<blue>	WARN_ON(!enable_vpid);</blue>

	/*
	 * VPID is enabled and in use by vmcs12.  If vpid12 is changing, then
	 * emulate a guest TLB flush as KVM does not track vpid12 history nor
	 * is the VPID incorporated into the MMU context.  I.e. KVM must assume
	 * that the new vpid12 has never been used and thus represents a new
	 * guest ASID that cannot have entries in the TLB.
	 */
<blue>	if (is_vmenter && vmcs12->virtual_processor_id != vmx->nested.last_vpid) {</blue>
<blue>		vmx->nested.last_vpid = vmcs12->virtual_processor_id;</blue>
		kvm_make_request(KVM_REQ_TLB_FLUSH_GUEST, vcpu);
		return;
	}

	/*
	 * If VPID is enabled, used by vmc12, and vpid12 is not changing but
	 * does not have a unique TLB tag (ASID), i.e. EPT is disabled and
	 * KVM was unable to allocate a VPID for L2, flush the current context
	 * as the effective ASID is common to both L1 and L2.
	 */
<blue>	if (!nested_has_guest_tlb_tag(vcpu))</blue>
<yellow>		kvm_make_request(KVM_REQ_TLB_FLUSH_CURRENT, vcpu);</yellow>
<blue>}</blue>

static bool is_bitwise_subset(u64 superset, u64 subset, u64 mask)
{
	superset &amp;= mask;
	subset &amp;= mask;

	return (superset | subset) == superset;
}

static int vmx_restore_vmx_basic(struct vcpu_vmx *vmx, u64 data)
{
	const u64 feature_and_reserved =
		/* feature (except bit 48; see below) */
		BIT_ULL(49) | BIT_ULL(54) | BIT_ULL(55) |
		/* reserved */
		BIT_ULL(31) | GENMASK_ULL(47, 45) | GENMASK_ULL(63, 56);
<blue>	u64 vmx_basic = vmcs_config.nested.basic;</blue>

	if (!is_bitwise_subset(vmx_basic, data, feature_and_reserved))
		return -EINVAL;

	/*
	 * KVM does not emulate a version of VMX that constrains physical
	 * addresses of VMX structures (e.g. VMCS) to 32-bits.
	 */
	if (data &amp; BIT_ULL(48))
		return -EINVAL;

	if (vmx_basic_vmcs_revision_id(vmx_basic) !=
<blue>	    vmx_basic_vmcs_revision_id(data))</blue>
		return -EINVAL;

<blue>	if (vmx_basic_vmcs_size(vmx_basic) > vmx_basic_vmcs_size(data))</blue>
		return -EINVAL;

<blue>	vmx->nested.msrs.basic = data;</blue>
	return 0;
}

static void vmx_get_control_msr(struct nested_vmx_msrs *msrs, u32 msr_index,
				u32 **low, u32 **high)
{
<blue>	switch (msr_index) {</blue>
	case MSR_IA32_VMX_TRUE_PINBASED_CTLS:
<blue>		*low = &msrs->pinbased_ctls_low;</blue>
		*high = &amp;msrs-&gt;pinbased_ctls_high;
		break;
	case MSR_IA32_VMX_TRUE_PROCBASED_CTLS:
<blue>		*low = &msrs->procbased_ctls_low;</blue>
		*high = &amp;msrs-&gt;procbased_ctls_high;
		break;
	case MSR_IA32_VMX_TRUE_EXIT_CTLS:
<blue>		*low = &msrs->exit_ctls_low;</blue>
		*high = &amp;msrs-&gt;exit_ctls_high;
		break;
	case MSR_IA32_VMX_TRUE_ENTRY_CTLS:
<blue>		*low = &msrs->entry_ctls_low;</blue>
		*high = &amp;msrs-&gt;entry_ctls_high;
		break;
	case MSR_IA32_VMX_PROCBASED_CTLS2:
<blue>		*low = &msrs->secondary_ctls_low;</blue>
		*high = &amp;msrs-&gt;secondary_ctls_high;
		break;
	default:
<yellow>		BUG();</yellow>
	}
}

static int
vmx_restore_control_msr(struct vcpu_vmx *vmx, u32 msr_index, u64 data)
{
	u32 *lowp, *highp;
	u64 supported;

<blue>	vmx_get_control_msr(&vmcs_config.nested, msr_index, &lowp, &highp);</blue>

<blue>	supported = vmx_control_msr(*lowp, *highp);</blue>

	/* Check must-be-1 bits are still 1. */
	if (!is_bitwise_subset(data, supported, GENMASK_ULL(31, 0)))
		return -EINVAL;

	/* Check must-be-0 bits are still 0. */
	if (!is_bitwise_subset(supported, data, GENMASK_ULL(63, 32)))
		return -EINVAL;

<blue>	vmx_get_control_msr(&vmx->nested.msrs, msr_index, &lowp, &highp);</blue>
<blue>	*lowp = data;</blue>
	*highp = data &gt;&gt; 32;
	return 0;
}

static int vmx_restore_vmx_misc(struct vcpu_vmx *vmx, u64 data)
{
	const u64 feature_and_reserved_bits =
		/* feature */
		BIT_ULL(5) | GENMASK_ULL(8, 6) | BIT_ULL(14) | BIT_ULL(15) |
		BIT_ULL(28) | BIT_ULL(29) | BIT_ULL(30) |
		/* reserved */
		GENMASK_ULL(13, 9) | BIT_ULL(31);
<blue>	u64 vmx_misc = vmx_control_msr(vmcs_config.nested.misc_low,</blue>
				       vmcs_config.nested.misc_high);

	if (!is_bitwise_subset(vmx_misc, data, feature_and_reserved_bits))
		return -EINVAL;

<blue>	if ((vmx->nested.msrs.pinbased_ctls_high &</blue>
	     PIN_BASED_VMX_PREEMPTION_TIMER) &amp;&amp;
	    vmx_misc_preemption_timer_rate(data) !=
<blue>	    vmx_misc_preemption_timer_rate(vmx_misc))</blue>
		return -EINVAL;

<blue>	if (vmx_misc_cr3_count(data) > vmx_misc_cr3_count(vmx_misc))</blue>
		return -EINVAL;

<blue>	if (vmx_misc_max_msr(data) > vmx_misc_max_msr(vmx_misc))</blue>
		return -EINVAL;

<blue>	if (vmx_misc_mseg_revid(data) != vmx_misc_mseg_revid(vmx_misc))</blue>
		return -EINVAL;

<blue>	vmx->nested.msrs.misc_low = data;</blue>
	vmx-&gt;nested.msrs.misc_high = data &gt;&gt; 32;

	return 0;
}

static int vmx_restore_vmx_ept_vpid_cap(struct vcpu_vmx *vmx, u64 data)
{
<blue>	u64 vmx_ept_vpid_cap = vmx_control_msr(vmcs_config.nested.ept_caps,</blue>
					       vmcs_config.nested.vpid_caps);

	/* Every bit is either reserved or a feature bit. */
	if (!is_bitwise_subset(vmx_ept_vpid_cap, data, -1ULL))
		return -EINVAL;

<blue>	vmx->nested.msrs.ept_caps = data;</blue>
	vmx-&gt;nested.msrs.vpid_caps = data &gt;&gt; 32;
	return 0;
}

static u64 *vmx_get_fixed0_msr(struct nested_vmx_msrs *msrs, u32 msr_index)
{
<blue>	switch (msr_index) {</blue>
	case MSR_IA32_VMX_CR0_FIXED0:
<blue>		return &msrs->cr0_fixed0;</blue>
	case MSR_IA32_VMX_CR4_FIXED0:
<blue>		return &msrs->cr4_fixed0;</blue>
	default:
<yellow>		BUG();</yellow>
	}
}

static int vmx_restore_fixed0_msr(struct vcpu_vmx *vmx, u32 msr_index, u64 data)
{
<blue>	const u64 *msr = vmx_get_fixed0_msr(&vmcs_config.nested, msr_index);</blue>

	/*
	 * 1 bits (which indicates bits which &quot;must-be-1&quot; during VMX operation)
	 * must be 1 in the restored value.
	 */
	if (!is_bitwise_subset(data, *msr, -1ULL))
		return -EINVAL;

<blue>	*vmx_get_fixed0_msr(&vmx->nested.msrs, msr_index) = data;</blue>
	return 0;
}

/*
 * Called when userspace is restoring VMX MSRs.
 *
 * Returns 0 on success, non-0 otherwise.
 */
int vmx_set_vmx_msr(struct kvm_vcpu *vcpu, u32 msr_index, u64 data)
{
	struct vcpu_vmx *vmx = to_vmx(vcpu);

	/*
	 * Don&#x27;t allow changes to the VMX capability MSRs while the vCPU
	 * is in VMX operation.
	 */
<blue>	if (vmx->nested.vmxon)</blue>
		return -EBUSY;

<blue>	switch (msr_index) {</blue>
	case MSR_IA32_VMX_BASIC:
<blue>		return vmx_restore_vmx_basic(vmx, data);</blue>
	case MSR_IA32_VMX_PINBASED_CTLS:
	case MSR_IA32_VMX_PROCBASED_CTLS:
	case MSR_IA32_VMX_EXIT_CTLS:
	case MSR_IA32_VMX_ENTRY_CTLS:
		/*
		 * The &quot;non-true&quot; VMX capability MSRs are generated from the
		 * &quot;true&quot; MSRs, so we do not support restoring them directly.
		 *
		 * If userspace wants to emulate VMX_BASIC[55]=0, userspace
		 * should restore the &quot;true&quot; MSRs with the must-be-1 bits
		 * set according to the SDM Vol 3. A.2 &quot;RESERVED CONTROLS AND
		 * DEFAULT SETTINGS&quot;.
		 */
		return -EINVAL;
	case MSR_IA32_VMX_TRUE_PINBASED_CTLS:
	case MSR_IA32_VMX_TRUE_PROCBASED_CTLS:
	case MSR_IA32_VMX_TRUE_EXIT_CTLS:
	case MSR_IA32_VMX_TRUE_ENTRY_CTLS:
	case MSR_IA32_VMX_PROCBASED_CTLS2:
<blue>		return vmx_restore_control_msr(vmx, msr_index, data);</blue>
	case MSR_IA32_VMX_MISC:
<blue>		return vmx_restore_vmx_misc(vmx, data);</blue>
	case MSR_IA32_VMX_CR0_FIXED0:
	case MSR_IA32_VMX_CR4_FIXED0:
<blue>		return vmx_restore_fixed0_msr(vmx, msr_index, data);</blue>
	case MSR_IA32_VMX_CR0_FIXED1:
	case MSR_IA32_VMX_CR4_FIXED1:
		/*
		 * These MSRs are generated based on the vCPU&#x27;s CPUID, so we
		 * do not support restoring them directly.
		 */
		return -EINVAL;
	case MSR_IA32_VMX_EPT_VPID_CAP:
<blue>		return vmx_restore_vmx_ept_vpid_cap(vmx, data);</blue>
	case MSR_IA32_VMX_VMCS_ENUM:
<blue>		vmx->nested.msrs.vmcs_enum = data;</blue>
		return 0;
	case MSR_IA32_VMX_VMFUNC:
<blue>		if (data & ~vmcs_config.nested.vmfunc_controls)</blue>
			return -EINVAL;
<blue>		vmx->nested.msrs.vmfunc_controls = data;</blue>
		return 0;
	default:
		/*
		 * The rest of the VMX capability MSRs do not support restore.
		 */
		return -EINVAL;
	}
<blue>}</blue>

/* Returns 0 on success, non-0 otherwise. */
int vmx_get_vmx_msr(struct nested_vmx_msrs *msrs, u32 msr_index, u64 *pdata)
{
<blue>	switch (msr_index) {</blue>
	case MSR_IA32_VMX_BASIC:
<blue>		*pdata = msrs->basic;</blue>
		break;
	case MSR_IA32_VMX_TRUE_PINBASED_CTLS:
	case MSR_IA32_VMX_PINBASED_CTLS:
<blue>		*pdata = vmx_control_msr(</blue>
			msrs-&gt;pinbased_ctls_low,
			msrs-&gt;pinbased_ctls_high);
		if (msr_index == MSR_IA32_VMX_PINBASED_CTLS)
<blue>			*pdata |= PIN_BASED_ALWAYSON_WITHOUT_TRUE_MSR;</blue>
		break;
	case MSR_IA32_VMX_TRUE_PROCBASED_CTLS:
	case MSR_IA32_VMX_PROCBASED_CTLS:
<blue>		*pdata = vmx_control_msr(</blue>
			msrs-&gt;procbased_ctls_low,
			msrs-&gt;procbased_ctls_high);
		if (msr_index == MSR_IA32_VMX_PROCBASED_CTLS)
<blue>			*pdata |= CPU_BASED_ALWAYSON_WITHOUT_TRUE_MSR;</blue>
		break;
	case MSR_IA32_VMX_TRUE_EXIT_CTLS:
	case MSR_IA32_VMX_EXIT_CTLS:
<blue>		*pdata = vmx_control_msr(</blue>
			msrs-&gt;exit_ctls_low,
			msrs-&gt;exit_ctls_high);
		if (msr_index == MSR_IA32_VMX_EXIT_CTLS)
<blue>			*pdata |= VM_EXIT_ALWAYSON_WITHOUT_TRUE_MSR;</blue>
		break;
	case MSR_IA32_VMX_TRUE_ENTRY_CTLS:
	case MSR_IA32_VMX_ENTRY_CTLS:
<blue>		*pdata = vmx_control_msr(</blue>
			msrs-&gt;entry_ctls_low,
			msrs-&gt;entry_ctls_high);
		if (msr_index == MSR_IA32_VMX_ENTRY_CTLS)
<blue>			*pdata |= VM_ENTRY_ALWAYSON_WITHOUT_TRUE_MSR;</blue>
		break;
	case MSR_IA32_VMX_MISC:
<blue>		*pdata = vmx_control_msr(</blue>
			msrs-&gt;misc_low,
			msrs-&gt;misc_high);
		break;
	case MSR_IA32_VMX_CR0_FIXED0:
<blue>		*pdata = msrs->cr0_fixed0;</blue>
		break;
	case MSR_IA32_VMX_CR0_FIXED1:
<blue>		*pdata = msrs->cr0_fixed1;</blue>
		break;
	case MSR_IA32_VMX_CR4_FIXED0:
<blue>		*pdata = msrs->cr4_fixed0;</blue>
		break;
	case MSR_IA32_VMX_CR4_FIXED1:
<blue>		*pdata = msrs->cr4_fixed1;</blue>
		break;
	case MSR_IA32_VMX_VMCS_ENUM:
<yellow>		*pdata = msrs->vmcs_enum;</yellow>
		break;
	case MSR_IA32_VMX_PROCBASED_CTLS2:
<blue>		*pdata = vmx_control_msr(</blue>
			msrs-&gt;secondary_ctls_low,
			msrs-&gt;secondary_ctls_high);
		break;
	case MSR_IA32_VMX_EPT_VPID_CAP:
<blue>		*pdata = msrs->ept_caps |</blue>
			((u64)msrs-&gt;vpid_caps &lt;&lt; 32);
		break;
	case MSR_IA32_VMX_VMFUNC:
<blue>		*pdata = msrs->vmfunc_controls;</blue>
		break;
	default:
		return 1;
	}

	return 0;
<blue>}</blue>

/*
 * Copy the writable VMCS shadow fields back to the VMCS12, in case they have
 * been modified by the L1 guest.  Note, &quot;writable&quot; in this context means
 * &quot;writable by the guest&quot;, i.e. tagged SHADOW_FIELD_RW; the set of
 * fields tagged SHADOW_FIELD_RO may or may not align with the &quot;read-only&quot;
 * VM-exit information fields (which are actually writable if the vCPU is
 * configured to support &quot;VMWRITE to any supported field in the VMCS&quot;).
 */
static void copy_shadow_to_vmcs12(struct vcpu_vmx *vmx)
<blue>{</blue>
<blue>	struct vmcs *shadow_vmcs = vmx->vmcs01.shadow_vmcs;</blue>
	struct vmcs12 *vmcs12 = get_vmcs12(&amp;vmx-&gt;vcpu);
	struct shadow_vmcs_field field;
	unsigned long val;
	int i;

<yellow>	if (WARN_ON(!shadow_vmcs))</yellow>
		return;

<blue>	preempt_disable();</blue>

<blue>	vmcs_load(shadow_vmcs);</blue>

<blue>	for (i = 0; i < max_shadow_read_write_fields; i++) {</blue>
<blue>		field = shadow_read_write_fields[i];</blue>
<yellow>		val = __vmcs_readl(field.encoding);</yellow>
<blue>		vmcs12_write_any(vmcs12, field.encoding, field.offset, val);</blue>
	}

<blue>	vmcs_clear(shadow_vmcs);</blue>
<blue>	vmcs_load(vmx->loaded_vmcs->vmcs);</blue>

<blue>	preempt_enable();</blue>
}

static void copy_vmcs12_to_shadow(struct vcpu_vmx *vmx)
{
	const struct shadow_vmcs_field *fields[] = {
		shadow_read_write_fields,
		shadow_read_only_fields
	};
<blue>	const int max_fields[] = {</blue>
		max_shadow_read_write_fields,
		max_shadow_read_only_fields
	};
	struct vmcs *shadow_vmcs = vmx-&gt;vmcs01.shadow_vmcs;
	struct vmcs12 *vmcs12 = get_vmcs12(&amp;vmx-&gt;vcpu);
	struct shadow_vmcs_field field;
	unsigned long val;
	int i, q;

<yellow>	if (WARN_ON(!shadow_vmcs))</yellow>
		return;

<blue>	vmcs_load(shadow_vmcs);</blue>

<blue>	for (q = 0; q < ARRAY_SIZE(fields); q++) {</blue>
<blue>		for (i = 0; i < max_fields[q]; i++) {</blue>
<blue>			field = fields[q][i];</blue>
<blue>			val = vmcs12_read_any(vmcs12, field.encoding,</blue>
					      field.offset);
<blue>			__vmcs_writel(field.encoding, val);</blue>
		}
	}

<blue>	vmcs_clear(shadow_vmcs);</blue>
<blue>	vmcs_load(vmx->loaded_vmcs->vmcs);</blue>
}

static void copy_enlightened_to_vmcs12(struct vcpu_vmx *vmx, u32 hv_clean_fields)
{
	struct vmcs12 *vmcs12 = vmx-&gt;nested.cached_vmcs12;
	struct hv_enlightened_vmcs *evmcs = vmx-&gt;nested.hv_evmcs;

	/* HV_VMX_ENLIGHTENED_CLEAN_FIELD_NONE */
<yellow>	vmcs12->tpr_threshold = evmcs->tpr_threshold;</yellow>
	vmcs12-&gt;guest_rip = evmcs-&gt;guest_rip;

	if (unlikely(!(hv_clean_fields &amp;
		       HV_VMX_ENLIGHTENED_CLEAN_FIELD_GUEST_BASIC))) {
<yellow>		vmcs12->guest_rsp = evmcs->guest_rsp;</yellow>
		vmcs12-&gt;guest_rflags = evmcs-&gt;guest_rflags;
		vmcs12-&gt;guest_interruptibility_info =
			evmcs-&gt;guest_interruptibility_info;
		/*
		 * Not present in struct vmcs12:
		 * vmcs12-&gt;guest_ssp = evmcs-&gt;guest_ssp;
		 */
	}

<yellow>	if (unlikely(!(hv_clean_fields &</yellow>
		       HV_VMX_ENLIGHTENED_CLEAN_FIELD_CONTROL_PROC))) {
		vmcs12-&gt;cpu_based_vm_exec_control =
<yellow>			evmcs->cpu_based_vm_exec_control;</yellow>
	}

<yellow>	if (unlikely(!(hv_clean_fields &</yellow>
		       HV_VMX_ENLIGHTENED_CLEAN_FIELD_CONTROL_EXCPN))) {
<yellow>		vmcs12->exception_bitmap = evmcs->exception_bitmap;</yellow>
	}

<yellow>	if (unlikely(!(hv_clean_fields &</yellow>
		       HV_VMX_ENLIGHTENED_CLEAN_FIELD_CONTROL_ENTRY))) {
<yellow>		vmcs12->vm_entry_controls = evmcs->vm_entry_controls;</yellow>
	}

<yellow>	if (unlikely(!(hv_clean_fields &</yellow>
		       HV_VMX_ENLIGHTENED_CLEAN_FIELD_CONTROL_EVENT))) {
		vmcs12-&gt;vm_entry_intr_info_field =
<yellow>			evmcs->vm_entry_intr_info_field;</yellow>
		vmcs12-&gt;vm_entry_exception_error_code =
			evmcs-&gt;vm_entry_exception_error_code;
		vmcs12-&gt;vm_entry_instruction_len =
			evmcs-&gt;vm_entry_instruction_len;
	}

<yellow>	if (unlikely(!(hv_clean_fields &</yellow>
		       HV_VMX_ENLIGHTENED_CLEAN_FIELD_HOST_GRP1))) {
<yellow>		vmcs12->host_ia32_pat = evmcs->host_ia32_pat;</yellow>
		vmcs12-&gt;host_ia32_efer = evmcs-&gt;host_ia32_efer;
		vmcs12-&gt;host_cr0 = evmcs-&gt;host_cr0;
		vmcs12-&gt;host_cr3 = evmcs-&gt;host_cr3;
		vmcs12-&gt;host_cr4 = evmcs-&gt;host_cr4;
		vmcs12-&gt;host_ia32_sysenter_esp = evmcs-&gt;host_ia32_sysenter_esp;
		vmcs12-&gt;host_ia32_sysenter_eip = evmcs-&gt;host_ia32_sysenter_eip;
		vmcs12-&gt;host_rip = evmcs-&gt;host_rip;
		vmcs12-&gt;host_ia32_sysenter_cs = evmcs-&gt;host_ia32_sysenter_cs;
		vmcs12-&gt;host_es_selector = evmcs-&gt;host_es_selector;
		vmcs12-&gt;host_cs_selector = evmcs-&gt;host_cs_selector;
		vmcs12-&gt;host_ss_selector = evmcs-&gt;host_ss_selector;
		vmcs12-&gt;host_ds_selector = evmcs-&gt;host_ds_selector;
		vmcs12-&gt;host_fs_selector = evmcs-&gt;host_fs_selector;
		vmcs12-&gt;host_gs_selector = evmcs-&gt;host_gs_selector;
		vmcs12-&gt;host_tr_selector = evmcs-&gt;host_tr_selector;
		vmcs12-&gt;host_ia32_perf_global_ctrl = evmcs-&gt;host_ia32_perf_global_ctrl;
		/*
		 * Not present in struct vmcs12:
		 * vmcs12-&gt;host_ia32_s_cet = evmcs-&gt;host_ia32_s_cet;
		 * vmcs12-&gt;host_ssp = evmcs-&gt;host_ssp;
		 * vmcs12-&gt;host_ia32_int_ssp_table_addr = evmcs-&gt;host_ia32_int_ssp_table_addr;
		 */
	}

<yellow>	if (unlikely(!(hv_clean_fields &</yellow>
		       HV_VMX_ENLIGHTENED_CLEAN_FIELD_CONTROL_GRP1))) {
		vmcs12-&gt;pin_based_vm_exec_control =
<yellow>			evmcs->pin_based_vm_exec_control;</yellow>
		vmcs12-&gt;vm_exit_controls = evmcs-&gt;vm_exit_controls;
		vmcs12-&gt;secondary_vm_exec_control =
			evmcs-&gt;secondary_vm_exec_control;
	}

<yellow>	if (unlikely(!(hv_clean_fields &</yellow>
		       HV_VMX_ENLIGHTENED_CLEAN_FIELD_IO_BITMAP))) {
<yellow>		vmcs12->io_bitmap_a = evmcs->io_bitmap_a;</yellow>
		vmcs12-&gt;io_bitmap_b = evmcs-&gt;io_bitmap_b;
	}

<yellow>	if (unlikely(!(hv_clean_fields &</yellow>
		       HV_VMX_ENLIGHTENED_CLEAN_FIELD_MSR_BITMAP))) {
<yellow>		vmcs12->msr_bitmap = evmcs->msr_bitmap;</yellow>
	}

<yellow>	if (unlikely(!(hv_clean_fields &</yellow>
		       HV_VMX_ENLIGHTENED_CLEAN_FIELD_GUEST_GRP2))) {
<yellow>		vmcs12->guest_es_base = evmcs->guest_es_base;</yellow>
		vmcs12-&gt;guest_cs_base = evmcs-&gt;guest_cs_base;
		vmcs12-&gt;guest_ss_base = evmcs-&gt;guest_ss_base;
		vmcs12-&gt;guest_ds_base = evmcs-&gt;guest_ds_base;
		vmcs12-&gt;guest_fs_base = evmcs-&gt;guest_fs_base;
		vmcs12-&gt;guest_gs_base = evmcs-&gt;guest_gs_base;
		vmcs12-&gt;guest_ldtr_base = evmcs-&gt;guest_ldtr_base;
		vmcs12-&gt;guest_tr_base = evmcs-&gt;guest_tr_base;
		vmcs12-&gt;guest_gdtr_base = evmcs-&gt;guest_gdtr_base;
		vmcs12-&gt;guest_idtr_base = evmcs-&gt;guest_idtr_base;
		vmcs12-&gt;guest_es_limit = evmcs-&gt;guest_es_limit;
		vmcs12-&gt;guest_cs_limit = evmcs-&gt;guest_cs_limit;
		vmcs12-&gt;guest_ss_limit = evmcs-&gt;guest_ss_limit;
		vmcs12-&gt;guest_ds_limit = evmcs-&gt;guest_ds_limit;
		vmcs12-&gt;guest_fs_limit = evmcs-&gt;guest_fs_limit;
		vmcs12-&gt;guest_gs_limit = evmcs-&gt;guest_gs_limit;
		vmcs12-&gt;guest_ldtr_limit = evmcs-&gt;guest_ldtr_limit;
		vmcs12-&gt;guest_tr_limit = evmcs-&gt;guest_tr_limit;
		vmcs12-&gt;guest_gdtr_limit = evmcs-&gt;guest_gdtr_limit;
		vmcs12-&gt;guest_idtr_limit = evmcs-&gt;guest_idtr_limit;
		vmcs12-&gt;guest_es_ar_bytes = evmcs-&gt;guest_es_ar_bytes;
		vmcs12-&gt;guest_cs_ar_bytes = evmcs-&gt;guest_cs_ar_bytes;
		vmcs12-&gt;guest_ss_ar_bytes = evmcs-&gt;guest_ss_ar_bytes;
		vmcs12-&gt;guest_ds_ar_bytes = evmcs-&gt;guest_ds_ar_bytes;
		vmcs12-&gt;guest_fs_ar_bytes = evmcs-&gt;guest_fs_ar_bytes;
		vmcs12-&gt;guest_gs_ar_bytes = evmcs-&gt;guest_gs_ar_bytes;
		vmcs12-&gt;guest_ldtr_ar_bytes = evmcs-&gt;guest_ldtr_ar_bytes;
		vmcs12-&gt;guest_tr_ar_bytes = evmcs-&gt;guest_tr_ar_bytes;
		vmcs12-&gt;guest_es_selector = evmcs-&gt;guest_es_selector;
		vmcs12-&gt;guest_cs_selector = evmcs-&gt;guest_cs_selector;
		vmcs12-&gt;guest_ss_selector = evmcs-&gt;guest_ss_selector;
		vmcs12-&gt;guest_ds_selector = evmcs-&gt;guest_ds_selector;
		vmcs12-&gt;guest_fs_selector = evmcs-&gt;guest_fs_selector;
		vmcs12-&gt;guest_gs_selector = evmcs-&gt;guest_gs_selector;
		vmcs12-&gt;guest_ldtr_selector = evmcs-&gt;guest_ldtr_selector;
		vmcs12-&gt;guest_tr_selector = evmcs-&gt;guest_tr_selector;
	}

<yellow>	if (unlikely(!(hv_clean_fields &</yellow>
		       HV_VMX_ENLIGHTENED_CLEAN_FIELD_CONTROL_GRP2))) {
<yellow>		vmcs12->tsc_offset = evmcs->tsc_offset;</yellow>
		vmcs12-&gt;virtual_apic_page_addr = evmcs-&gt;virtual_apic_page_addr;
		vmcs12-&gt;xss_exit_bitmap = evmcs-&gt;xss_exit_bitmap;
		vmcs12-&gt;encls_exiting_bitmap = evmcs-&gt;encls_exiting_bitmap;
		vmcs12-&gt;tsc_multiplier = evmcs-&gt;tsc_multiplier;
	}

<yellow>	if (unlikely(!(hv_clean_fields &</yellow>
		       HV_VMX_ENLIGHTENED_CLEAN_FIELD_CRDR))) {
<yellow>		vmcs12->cr0_guest_host_mask = evmcs->cr0_guest_host_mask;</yellow>
		vmcs12-&gt;cr4_guest_host_mask = evmcs-&gt;cr4_guest_host_mask;
		vmcs12-&gt;cr0_read_shadow = evmcs-&gt;cr0_read_shadow;
		vmcs12-&gt;cr4_read_shadow = evmcs-&gt;cr4_read_shadow;
		vmcs12-&gt;guest_cr0 = evmcs-&gt;guest_cr0;
		vmcs12-&gt;guest_cr3 = evmcs-&gt;guest_cr3;
		vmcs12-&gt;guest_cr4 = evmcs-&gt;guest_cr4;
		vmcs12-&gt;guest_dr7 = evmcs-&gt;guest_dr7;
	}

<yellow>	if (unlikely(!(hv_clean_fields &</yellow>
		       HV_VMX_ENLIGHTENED_CLEAN_FIELD_HOST_POINTER))) {
<yellow>		vmcs12->host_fs_base = evmcs->host_fs_base;</yellow>
		vmcs12-&gt;host_gs_base = evmcs-&gt;host_gs_base;
		vmcs12-&gt;host_tr_base = evmcs-&gt;host_tr_base;
		vmcs12-&gt;host_gdtr_base = evmcs-&gt;host_gdtr_base;
		vmcs12-&gt;host_idtr_base = evmcs-&gt;host_idtr_base;
		vmcs12-&gt;host_rsp = evmcs-&gt;host_rsp;
	}

<yellow>	if (unlikely(!(hv_clean_fields &</yellow>
		       HV_VMX_ENLIGHTENED_CLEAN_FIELD_CONTROL_XLAT))) {
<yellow>		vmcs12->ept_pointer = evmcs->ept_pointer;</yellow>
		vmcs12-&gt;virtual_processor_id = evmcs-&gt;virtual_processor_id;
	}

<yellow>	if (unlikely(!(hv_clean_fields &</yellow>
		       HV_VMX_ENLIGHTENED_CLEAN_FIELD_GUEST_GRP1))) {
<yellow>		vmcs12->vmcs_link_pointer = evmcs->vmcs_link_pointer;</yellow>
		vmcs12-&gt;guest_ia32_debugctl = evmcs-&gt;guest_ia32_debugctl;
		vmcs12-&gt;guest_ia32_pat = evmcs-&gt;guest_ia32_pat;
		vmcs12-&gt;guest_ia32_efer = evmcs-&gt;guest_ia32_efer;
		vmcs12-&gt;guest_pdptr0 = evmcs-&gt;guest_pdptr0;
		vmcs12-&gt;guest_pdptr1 = evmcs-&gt;guest_pdptr1;
		vmcs12-&gt;guest_pdptr2 = evmcs-&gt;guest_pdptr2;
		vmcs12-&gt;guest_pdptr3 = evmcs-&gt;guest_pdptr3;
		vmcs12-&gt;guest_pending_dbg_exceptions =
			evmcs-&gt;guest_pending_dbg_exceptions;
		vmcs12-&gt;guest_sysenter_esp = evmcs-&gt;guest_sysenter_esp;
		vmcs12-&gt;guest_sysenter_eip = evmcs-&gt;guest_sysenter_eip;
		vmcs12-&gt;guest_bndcfgs = evmcs-&gt;guest_bndcfgs;
		vmcs12-&gt;guest_activity_state = evmcs-&gt;guest_activity_state;
		vmcs12-&gt;guest_sysenter_cs = evmcs-&gt;guest_sysenter_cs;
		vmcs12-&gt;guest_ia32_perf_global_ctrl = evmcs-&gt;guest_ia32_perf_global_ctrl;
		/*
		 * Not present in struct vmcs12:
		 * vmcs12-&gt;guest_ia32_s_cet = evmcs-&gt;guest_ia32_s_cet;
		 * vmcs12-&gt;guest_ia32_lbr_ctl = evmcs-&gt;guest_ia32_lbr_ctl;
		 * vmcs12-&gt;guest_ia32_int_ssp_table_addr = evmcs-&gt;guest_ia32_int_ssp_table_addr;
		 */
	}

	/*
	 * Not used?
	 * vmcs12-&gt;vm_exit_msr_store_addr = evmcs-&gt;vm_exit_msr_store_addr;
	 * vmcs12-&gt;vm_exit_msr_load_addr = evmcs-&gt;vm_exit_msr_load_addr;
	 * vmcs12-&gt;vm_entry_msr_load_addr = evmcs-&gt;vm_entry_msr_load_addr;
	 * vmcs12-&gt;page_fault_error_code_mask =
	 *		evmcs-&gt;page_fault_error_code_mask;
	 * vmcs12-&gt;page_fault_error_code_match =
	 *		evmcs-&gt;page_fault_error_code_match;
	 * vmcs12-&gt;cr3_target_count = evmcs-&gt;cr3_target_count;
	 * vmcs12-&gt;vm_exit_msr_store_count = evmcs-&gt;vm_exit_msr_store_count;
	 * vmcs12-&gt;vm_exit_msr_load_count = evmcs-&gt;vm_exit_msr_load_count;
	 * vmcs12-&gt;vm_entry_msr_load_count = evmcs-&gt;vm_entry_msr_load_count;
	 */

	/*
	 * Read only fields:
	 * vmcs12-&gt;guest_physical_address = evmcs-&gt;guest_physical_address;
	 * vmcs12-&gt;vm_instruction_error = evmcs-&gt;vm_instruction_error;
	 * vmcs12-&gt;vm_exit_reason = evmcs-&gt;vm_exit_reason;
	 * vmcs12-&gt;vm_exit_intr_info = evmcs-&gt;vm_exit_intr_info;
	 * vmcs12-&gt;vm_exit_intr_error_code = evmcs-&gt;vm_exit_intr_error_code;
	 * vmcs12-&gt;idt_vectoring_info_field = evmcs-&gt;idt_vectoring_info_field;
	 * vmcs12-&gt;idt_vectoring_error_code = evmcs-&gt;idt_vectoring_error_code;
	 * vmcs12-&gt;vm_exit_instruction_len = evmcs-&gt;vm_exit_instruction_len;
	 * vmcs12-&gt;vmx_instruction_info = evmcs-&gt;vmx_instruction_info;
	 * vmcs12-&gt;exit_qualification = evmcs-&gt;exit_qualification;
	 * vmcs12-&gt;guest_linear_address = evmcs-&gt;guest_linear_address;
	 *
	 * Not present in struct vmcs12:
	 * vmcs12-&gt;exit_io_instruction_ecx = evmcs-&gt;exit_io_instruction_ecx;
	 * vmcs12-&gt;exit_io_instruction_esi = evmcs-&gt;exit_io_instruction_esi;
	 * vmcs12-&gt;exit_io_instruction_edi = evmcs-&gt;exit_io_instruction_edi;
	 * vmcs12-&gt;exit_io_instruction_eip = evmcs-&gt;exit_io_instruction_eip;
	 */

	return;
<yellow>}</yellow>

static void copy_vmcs12_to_enlightened(struct vcpu_vmx *vmx)
{
	struct vmcs12 *vmcs12 = vmx-&gt;nested.cached_vmcs12;
	struct hv_enlightened_vmcs *evmcs = vmx-&gt;nested.hv_evmcs;

	/*
	 * Should not be changed by KVM:
	 *
	 * evmcs-&gt;host_es_selector = vmcs12-&gt;host_es_selector;
	 * evmcs-&gt;host_cs_selector = vmcs12-&gt;host_cs_selector;
	 * evmcs-&gt;host_ss_selector = vmcs12-&gt;host_ss_selector;
	 * evmcs-&gt;host_ds_selector = vmcs12-&gt;host_ds_selector;
	 * evmcs-&gt;host_fs_selector = vmcs12-&gt;host_fs_selector;
	 * evmcs-&gt;host_gs_selector = vmcs12-&gt;host_gs_selector;
	 * evmcs-&gt;host_tr_selector = vmcs12-&gt;host_tr_selector;
	 * evmcs-&gt;host_ia32_pat = vmcs12-&gt;host_ia32_pat;
	 * evmcs-&gt;host_ia32_efer = vmcs12-&gt;host_ia32_efer;
	 * evmcs-&gt;host_cr0 = vmcs12-&gt;host_cr0;
	 * evmcs-&gt;host_cr3 = vmcs12-&gt;host_cr3;
	 * evmcs-&gt;host_cr4 = vmcs12-&gt;host_cr4;
	 * evmcs-&gt;host_ia32_sysenter_esp = vmcs12-&gt;host_ia32_sysenter_esp;
	 * evmcs-&gt;host_ia32_sysenter_eip = vmcs12-&gt;host_ia32_sysenter_eip;
	 * evmcs-&gt;host_rip = vmcs12-&gt;host_rip;
	 * evmcs-&gt;host_ia32_sysenter_cs = vmcs12-&gt;host_ia32_sysenter_cs;
	 * evmcs-&gt;host_fs_base = vmcs12-&gt;host_fs_base;
	 * evmcs-&gt;host_gs_base = vmcs12-&gt;host_gs_base;
	 * evmcs-&gt;host_tr_base = vmcs12-&gt;host_tr_base;
	 * evmcs-&gt;host_gdtr_base = vmcs12-&gt;host_gdtr_base;
	 * evmcs-&gt;host_idtr_base = vmcs12-&gt;host_idtr_base;
	 * evmcs-&gt;host_rsp = vmcs12-&gt;host_rsp;
	 * sync_vmcs02_to_vmcs12() doesn&#x27;t read these:
	 * evmcs-&gt;io_bitmap_a = vmcs12-&gt;io_bitmap_a;
	 * evmcs-&gt;io_bitmap_b = vmcs12-&gt;io_bitmap_b;
	 * evmcs-&gt;msr_bitmap = vmcs12-&gt;msr_bitmap;
	 * evmcs-&gt;ept_pointer = vmcs12-&gt;ept_pointer;
	 * evmcs-&gt;xss_exit_bitmap = vmcs12-&gt;xss_exit_bitmap;
	 * evmcs-&gt;vm_exit_msr_store_addr = vmcs12-&gt;vm_exit_msr_store_addr;
	 * evmcs-&gt;vm_exit_msr_load_addr = vmcs12-&gt;vm_exit_msr_load_addr;
	 * evmcs-&gt;vm_entry_msr_load_addr = vmcs12-&gt;vm_entry_msr_load_addr;
	 * evmcs-&gt;tpr_threshold = vmcs12-&gt;tpr_threshold;
	 * evmcs-&gt;virtual_processor_id = vmcs12-&gt;virtual_processor_id;
	 * evmcs-&gt;exception_bitmap = vmcs12-&gt;exception_bitmap;
	 * evmcs-&gt;vmcs_link_pointer = vmcs12-&gt;vmcs_link_pointer;
	 * evmcs-&gt;pin_based_vm_exec_control = vmcs12-&gt;pin_based_vm_exec_control;
	 * evmcs-&gt;vm_exit_controls = vmcs12-&gt;vm_exit_controls;
	 * evmcs-&gt;secondary_vm_exec_control = vmcs12-&gt;secondary_vm_exec_control;
	 * evmcs-&gt;page_fault_error_code_mask =
	 *		vmcs12-&gt;page_fault_error_code_mask;
	 * evmcs-&gt;page_fault_error_code_match =
	 *		vmcs12-&gt;page_fault_error_code_match;
	 * evmcs-&gt;cr3_target_count = vmcs12-&gt;cr3_target_count;
	 * evmcs-&gt;virtual_apic_page_addr = vmcs12-&gt;virtual_apic_page_addr;
	 * evmcs-&gt;tsc_offset = vmcs12-&gt;tsc_offset;
	 * evmcs-&gt;guest_ia32_debugctl = vmcs12-&gt;guest_ia32_debugctl;
	 * evmcs-&gt;cr0_guest_host_mask = vmcs12-&gt;cr0_guest_host_mask;
	 * evmcs-&gt;cr4_guest_host_mask = vmcs12-&gt;cr4_guest_host_mask;
	 * evmcs-&gt;cr0_read_shadow = vmcs12-&gt;cr0_read_shadow;
	 * evmcs-&gt;cr4_read_shadow = vmcs12-&gt;cr4_read_shadow;
	 * evmcs-&gt;vm_exit_msr_store_count = vmcs12-&gt;vm_exit_msr_store_count;
	 * evmcs-&gt;vm_exit_msr_load_count = vmcs12-&gt;vm_exit_msr_load_count;
	 * evmcs-&gt;vm_entry_msr_load_count = vmcs12-&gt;vm_entry_msr_load_count;
	 * evmcs-&gt;guest_ia32_perf_global_ctrl = vmcs12-&gt;guest_ia32_perf_global_ctrl;
	 * evmcs-&gt;host_ia32_perf_global_ctrl = vmcs12-&gt;host_ia32_perf_global_ctrl;
	 * evmcs-&gt;encls_exiting_bitmap = vmcs12-&gt;encls_exiting_bitmap;
	 * evmcs-&gt;tsc_multiplier = vmcs12-&gt;tsc_multiplier;
	 *
	 * Not present in struct vmcs12:
	 * evmcs-&gt;exit_io_instruction_ecx = vmcs12-&gt;exit_io_instruction_ecx;
	 * evmcs-&gt;exit_io_instruction_esi = vmcs12-&gt;exit_io_instruction_esi;
	 * evmcs-&gt;exit_io_instruction_edi = vmcs12-&gt;exit_io_instruction_edi;
	 * evmcs-&gt;exit_io_instruction_eip = vmcs12-&gt;exit_io_instruction_eip;
	 * evmcs-&gt;host_ia32_s_cet = vmcs12-&gt;host_ia32_s_cet;
	 * evmcs-&gt;host_ssp = vmcs12-&gt;host_ssp;
	 * evmcs-&gt;host_ia32_int_ssp_table_addr = vmcs12-&gt;host_ia32_int_ssp_table_addr;
	 * evmcs-&gt;guest_ia32_s_cet = vmcs12-&gt;guest_ia32_s_cet;
	 * evmcs-&gt;guest_ia32_lbr_ctl = vmcs12-&gt;guest_ia32_lbr_ctl;
	 * evmcs-&gt;guest_ia32_int_ssp_table_addr = vmcs12-&gt;guest_ia32_int_ssp_table_addr;
	 * evmcs-&gt;guest_ssp = vmcs12-&gt;guest_ssp;
	 */

	evmcs-&gt;guest_es_selector = vmcs12-&gt;guest_es_selector;
	evmcs-&gt;guest_cs_selector = vmcs12-&gt;guest_cs_selector;
	evmcs-&gt;guest_ss_selector = vmcs12-&gt;guest_ss_selector;
	evmcs-&gt;guest_ds_selector = vmcs12-&gt;guest_ds_selector;
	evmcs-&gt;guest_fs_selector = vmcs12-&gt;guest_fs_selector;
	evmcs-&gt;guest_gs_selector = vmcs12-&gt;guest_gs_selector;
	evmcs-&gt;guest_ldtr_selector = vmcs12-&gt;guest_ldtr_selector;
	evmcs-&gt;guest_tr_selector = vmcs12-&gt;guest_tr_selector;

	evmcs-&gt;guest_es_limit = vmcs12-&gt;guest_es_limit;
	evmcs-&gt;guest_cs_limit = vmcs12-&gt;guest_cs_limit;
	evmcs-&gt;guest_ss_limit = vmcs12-&gt;guest_ss_limit;
	evmcs-&gt;guest_ds_limit = vmcs12-&gt;guest_ds_limit;
	evmcs-&gt;guest_fs_limit = vmcs12-&gt;guest_fs_limit;
	evmcs-&gt;guest_gs_limit = vmcs12-&gt;guest_gs_limit;
	evmcs-&gt;guest_ldtr_limit = vmcs12-&gt;guest_ldtr_limit;
	evmcs-&gt;guest_tr_limit = vmcs12-&gt;guest_tr_limit;
	evmcs-&gt;guest_gdtr_limit = vmcs12-&gt;guest_gdtr_limit;
	evmcs-&gt;guest_idtr_limit = vmcs12-&gt;guest_idtr_limit;

	evmcs-&gt;guest_es_ar_bytes = vmcs12-&gt;guest_es_ar_bytes;
	evmcs-&gt;guest_cs_ar_bytes = vmcs12-&gt;guest_cs_ar_bytes;
	evmcs-&gt;guest_ss_ar_bytes = vmcs12-&gt;guest_ss_ar_bytes;
	evmcs-&gt;guest_ds_ar_bytes = vmcs12-&gt;guest_ds_ar_bytes;
	evmcs-&gt;guest_fs_ar_bytes = vmcs12-&gt;guest_fs_ar_bytes;
	evmcs-&gt;guest_gs_ar_bytes = vmcs12-&gt;guest_gs_ar_bytes;
	evmcs-&gt;guest_ldtr_ar_bytes = vmcs12-&gt;guest_ldtr_ar_bytes;
	evmcs-&gt;guest_tr_ar_bytes = vmcs12-&gt;guest_tr_ar_bytes;

	evmcs-&gt;guest_es_base = vmcs12-&gt;guest_es_base;
	evmcs-&gt;guest_cs_base = vmcs12-&gt;guest_cs_base;
	evmcs-&gt;guest_ss_base = vmcs12-&gt;guest_ss_base;
	evmcs-&gt;guest_ds_base = vmcs12-&gt;guest_ds_base;
	evmcs-&gt;guest_fs_base = vmcs12-&gt;guest_fs_base;
	evmcs-&gt;guest_gs_base = vmcs12-&gt;guest_gs_base;
	evmcs-&gt;guest_ldtr_base = vmcs12-&gt;guest_ldtr_base;
	evmcs-&gt;guest_tr_base = vmcs12-&gt;guest_tr_base;
	evmcs-&gt;guest_gdtr_base = vmcs12-&gt;guest_gdtr_base;
	evmcs-&gt;guest_idtr_base = vmcs12-&gt;guest_idtr_base;

	evmcs-&gt;guest_ia32_pat = vmcs12-&gt;guest_ia32_pat;
	evmcs-&gt;guest_ia32_efer = vmcs12-&gt;guest_ia32_efer;

	evmcs-&gt;guest_pdptr0 = vmcs12-&gt;guest_pdptr0;
	evmcs-&gt;guest_pdptr1 = vmcs12-&gt;guest_pdptr1;
	evmcs-&gt;guest_pdptr2 = vmcs12-&gt;guest_pdptr2;
	evmcs-&gt;guest_pdptr3 = vmcs12-&gt;guest_pdptr3;

	evmcs-&gt;guest_pending_dbg_exceptions =
		vmcs12-&gt;guest_pending_dbg_exceptions;
	evmcs-&gt;guest_sysenter_esp = vmcs12-&gt;guest_sysenter_esp;
	evmcs-&gt;guest_sysenter_eip = vmcs12-&gt;guest_sysenter_eip;

	evmcs-&gt;guest_activity_state = vmcs12-&gt;guest_activity_state;
	evmcs-&gt;guest_sysenter_cs = vmcs12-&gt;guest_sysenter_cs;

	evmcs-&gt;guest_cr0 = vmcs12-&gt;guest_cr0;
	evmcs-&gt;guest_cr3 = vmcs12-&gt;guest_cr3;
	evmcs-&gt;guest_cr4 = vmcs12-&gt;guest_cr4;
	evmcs-&gt;guest_dr7 = vmcs12-&gt;guest_dr7;

	evmcs-&gt;guest_physical_address = vmcs12-&gt;guest_physical_address;

	evmcs-&gt;vm_instruction_error = vmcs12-&gt;vm_instruction_error;
	evmcs-&gt;vm_exit_reason = vmcs12-&gt;vm_exit_reason;
	evmcs-&gt;vm_exit_intr_info = vmcs12-&gt;vm_exit_intr_info;
	evmcs-&gt;vm_exit_intr_error_code = vmcs12-&gt;vm_exit_intr_error_code;
	evmcs-&gt;idt_vectoring_info_field = vmcs12-&gt;idt_vectoring_info_field;
	evmcs-&gt;idt_vectoring_error_code = vmcs12-&gt;idt_vectoring_error_code;
	evmcs-&gt;vm_exit_instruction_len = vmcs12-&gt;vm_exit_instruction_len;
	evmcs-&gt;vmx_instruction_info = vmcs12-&gt;vmx_instruction_info;

	evmcs-&gt;exit_qualification = vmcs12-&gt;exit_qualification;

	evmcs-&gt;guest_linear_address = vmcs12-&gt;guest_linear_address;
	evmcs-&gt;guest_rsp = vmcs12-&gt;guest_rsp;
	evmcs-&gt;guest_rflags = vmcs12-&gt;guest_rflags;

	evmcs-&gt;guest_interruptibility_info =
		vmcs12-&gt;guest_interruptibility_info;
	evmcs-&gt;cpu_based_vm_exec_control = vmcs12-&gt;cpu_based_vm_exec_control;
	evmcs-&gt;vm_entry_controls = vmcs12-&gt;vm_entry_controls;
	evmcs-&gt;vm_entry_intr_info_field = vmcs12-&gt;vm_entry_intr_info_field;
	evmcs-&gt;vm_entry_exception_error_code =
		vmcs12-&gt;vm_entry_exception_error_code;
	evmcs-&gt;vm_entry_instruction_len = vmcs12-&gt;vm_entry_instruction_len;

	evmcs-&gt;guest_rip = vmcs12-&gt;guest_rip;

	evmcs-&gt;guest_bndcfgs = vmcs12-&gt;guest_bndcfgs;

	return;
}

/*
 * This is an equivalent of the nested hypervisor executing the vmptrld
 * instruction.
 */
<blue>static enum nested_evmptrld_status nested_vmx_handle_enlightened_vmptrld(</blue>
	struct kvm_vcpu *vcpu, bool from_launch)
{
	struct vcpu_vmx *vmx = to_vmx(vcpu);
	bool evmcs_gpa_changed = false;
	u64 evmcs_gpa;

<blue>	if (likely(!guest_cpuid_has_evmcs(vcpu)))</blue>
		return EVMPTRLD_DISABLED;

<blue>	if (!nested_enlightened_vmentry(vcpu, &evmcs_gpa)) {</blue>
<blue>		nested_release_evmcs(vcpu);</blue>
		return EVMPTRLD_DISABLED;
	}

<yellow>	if (unlikely(evmcs_gpa != vmx->nested.hv_evmcs_vmptr)) {</yellow>
<yellow>		vmx->nested.current_vmptr = INVALID_GPA;</yellow>

<yellow>		nested_release_evmcs(vcpu);</yellow>

		if (kvm_vcpu_map(vcpu, gpa_to_gfn(evmcs_gpa),
				 &amp;vmx-&gt;nested.hv_evmcs_map))
			return EVMPTRLD_ERROR;

<yellow>		vmx->nested.hv_evmcs = vmx->nested.hv_evmcs_map.hva;</yellow>

		/*
		 * Currently, KVM only supports eVMCS version 1
		 * (== KVM_EVMCS_VERSION) and thus we expect guest to set this
		 * value to first u32 field of eVMCS which should specify eVMCS
		 * VersionNumber.
		 *
		 * Guest should be aware of supported eVMCS versions by host by
		 * examining CPUID.0x4000000A.EAX[0:15]. Host userspace VMM is
		 * expected to set this CPUID leaf according to the value
		 * returned in vmcs_version from nested_enable_evmcs().
		 *
		 * However, it turns out that Microsoft Hyper-V fails to comply
		 * to their own invented interface: When Hyper-V use eVMCS, it
		 * just sets first u32 field of eVMCS to revision_id specified
		 * in MSR_IA32_VMX_BASIC. Instead of used eVMCS version number
		 * which is one of the supported versions specified in
		 * CPUID.0x4000000A.EAX[0:15].
		 *
		 * To overcome Hyper-V bug, we accept here either a supported
		 * eVMCS version or VMCS12 revision_id as valid values for first
		 * u32 field of eVMCS.
		 */
<yellow>		if ((vmx->nested.hv_evmcs->revision_id != KVM_EVMCS_VERSION) &&</yellow>
		    (vmx-&gt;nested.hv_evmcs-&gt;revision_id != VMCS12_REVISION)) {
<yellow>			nested_release_evmcs(vcpu);</yellow>
			return EVMPTRLD_VMFAIL;
		}

<yellow>		vmx->nested.hv_evmcs_vmptr = evmcs_gpa;</yellow>

		evmcs_gpa_changed = true;
		/*
		 * Unlike normal vmcs12, enlightened vmcs12 is not fully
		 * reloaded from guest&#x27;s memory (read only fields, fields not
		 * present in struct hv_enlightened_vmcs, ...). Make sure there
		 * are no leftovers.
		 */
		if (from_launch) {
<yellow>			struct vmcs12 *vmcs12 = get_vmcs12(vcpu);</yellow>
			memset(vmcs12, 0, sizeof(*vmcs12));
			vmcs12-&gt;hdr.revision_id = VMCS12_REVISION;
		}

	}

	/*
	 * Clean fields data can&#x27;t be used on VMLAUNCH and when we switch
	 * between different L2 guests as KVM keeps a single VMCS12 per L1.
	 */
<yellow>	if (from_launch || evmcs_gpa_changed) {</yellow>
<yellow>		vmx->nested.hv_evmcs->hv_clean_fields &=</yellow>
			~HV_VMX_ENLIGHTENED_CLEAN_FIELD_ALL;

		vmx-&gt;nested.force_msr_bitmap_recalc = true;
	}

	return EVMPTRLD_SUCCEEDED;
}

void nested_sync_vmcs12_to_shadow(struct kvm_vcpu *vcpu)
{
	struct vcpu_vmx *vmx = to_vmx(vcpu);

<blue>	if (evmptr_is_valid(vmx->nested.hv_evmcs_vmptr))</blue>
<yellow>		copy_vmcs12_to_enlightened(vmx);</yellow>
	else
<blue>		copy_vmcs12_to_shadow(vmx);</blue>

<blue>	vmx->nested.need_vmcs12_to_shadow_sync = false;</blue>
}

static enum hrtimer_restart vmx_preemption_timer_fn(struct hrtimer *timer)
{
	struct vcpu_vmx *vmx =
		container_of(timer, struct vcpu_vmx, nested.preemption_timer);

<blue>	vmx->nested.preemption_timer_expired = true;</blue>
	kvm_make_request(KVM_REQ_EVENT, &amp;vmx-&gt;vcpu);
	kvm_vcpu_kick(&amp;vmx-&gt;vcpu);

	return HRTIMER_NORESTART;
}

static u64 vmx_calc_preemption_timer_value(struct kvm_vcpu *vcpu)
{
	struct vcpu_vmx *vmx = to_vmx(vcpu);
<blue>	struct vmcs12 *vmcs12 = get_vmcs12(vcpu);</blue>

	u64 l1_scaled_tsc = kvm_read_l1_tsc(vcpu, rdtsc()) &gt;&gt;
			    VMX_MISC_EMULATED_PREEMPTION_TIMER_RATE;

<blue>	if (!vmx->nested.has_preemption_timer_deadline) {</blue>
		vmx-&gt;nested.preemption_timer_deadline =
<blue>			vmcs12->vmx_preemption_timer_value + l1_scaled_tsc;</blue>
		vmx-&gt;nested.has_preemption_timer_deadline = true;
	}
<yellow>	return vmx->nested.preemption_timer_deadline - l1_scaled_tsc;</yellow>
}

static void vmx_start_preemption_timer(struct kvm_vcpu *vcpu,
					u64 preemption_timeout)
{
	struct vcpu_vmx *vmx = to_vmx(vcpu);

	/*
	 * A timer value of zero is architecturally guaranteed to cause
	 * a VMExit prior to executing any instructions in the guest.
	 */
<blue>	if (preemption_timeout == 0) {</blue>
<blue>		vmx_preemption_timer_fn(&vmx->nested.preemption_timer);</blue>
		return;
	}

<blue>	if (vcpu->arch.virtual_tsc_khz == 0)</blue>
		return;

<blue>	preemption_timeout <<= VMX_MISC_EMULATED_PREEMPTION_TIMER_RATE;</blue>
	preemption_timeout *= 1000000;
	do_div(preemption_timeout, vcpu-&gt;arch.virtual_tsc_khz);
	hrtimer_start(&amp;vmx-&gt;nested.preemption_timer,
		      ktime_add_ns(ktime_get(), preemption_timeout),
		      HRTIMER_MODE_ABS_PINNED);
}

static u64 nested_vmx_calc_efer(struct vcpu_vmx *vmx, struct vmcs12 *vmcs12)
{
<blue>	if (vmx->nested.nested_run_pending &&</blue>
<blue>	    (vmcs12->vm_entry_controls & VM_ENTRY_LOAD_IA32_EFER))</blue>
<blue>		return vmcs12->guest_ia32_efer;</blue>
	else if (vmcs12-&gt;vm_entry_controls &amp; VM_ENTRY_IA32E_MODE)
<blue>		return vmx->vcpu.arch.efer | (EFER_LMA | EFER_LME);</blue>
	else
<blue>		return vmx->vcpu.arch.efer & ~(EFER_LMA | EFER_LME);</blue>
}

static void prepare_vmcs02_constant_state(struct vcpu_vmx *vmx)
{
<blue>	struct kvm *kvm = vmx->vcpu.kvm;</blue>

	/*
	 * If vmcs02 hasn&#x27;t been initialized, set the constant vmcs02 state
	 * according to L0&#x27;s settings (vmcs12 is irrelevant here).  Host
	 * fields that come from L0 and are not constant, e.g. HOST_CR3,
	 * will be set as needed prior to VMLAUNCH/VMRESUME.
	 */
<blue>	if (vmx->nested.vmcs02_initialized)</blue>
		return;
<blue>	vmx->nested.vmcs02_initialized = true;</blue>

	/*
	 * We don&#x27;t care what the EPTP value is we just need to guarantee
	 * it&#x27;s valid so we don&#x27;t get a false positive when doing early
	 * consistency checks.
	 */
<blue>	if (enable_ept && nested_early_check)</blue>
<blue>		vmcs_write64(EPT_POINTER,</blue>
			     construct_eptp(&amp;vmx-&gt;vcpu, 0, PT64_ROOT_4LEVEL));

	/* All VMFUNCs are currently emulated through L0 vmexits.  */
<blue>	if (cpu_has_vmx_vmfunc())</blue>
<blue>		vmcs_write64(VM_FUNCTION_CONTROL, 0);</blue>

<blue>	if (cpu_has_vmx_posted_intr())</blue>
<blue>		vmcs_write16(POSTED_INTR_NV, POSTED_INTR_NESTED_VECTOR);</blue>

<blue>	if (cpu_has_vmx_msr_bitmap())</blue>
<blue>		vmcs_write64(MSR_BITMAP, __pa(vmx->nested.vmcs02.msr_bitmap));</blue>

	/*
	 * PML is emulated for L2, but never enabled in hardware as the MMU
	 * handles A/D emulation.  Disabling PML for L2 also avoids having to
	 * deal with filtering out L2 GPAs from the buffer.
	 */
<blue>	if (enable_pml) {</blue>
<yellow>		vmcs_write64(PML_ADDRESS, 0);</yellow>
<yellow>		vmcs_write16(GUEST_PML_INDEX, -1);</yellow>
	}

<blue>	if (cpu_has_vmx_encls_vmexit())</blue>
<yellow>		vmcs_write64(ENCLS_EXITING_BITMAP, INVALID_GPA);</yellow>

<blue>	if (kvm_notify_vmexit_enabled(kvm))</blue>
<yellow>		vmcs_write32(NOTIFY_WINDOW, kvm->arch.notify_window);</yellow>

	/*
	 * Set the MSR load/store lists to match L0&#x27;s settings.  Only the
	 * addresses are constant (for vmcs02), the counts can change based
	 * on L2&#x27;s behavior, e.g. switching to/from long mode.
	 */
<blue>	vmcs_write64(VM_EXIT_MSR_STORE_ADDR, __pa(vmx->msr_autostore.guest.val));</blue>
<blue>	vmcs_write64(VM_EXIT_MSR_LOAD_ADDR, __pa(vmx->msr_autoload.host.val));</blue>
<blue>	vmcs_write64(VM_ENTRY_MSR_LOAD_ADDR, __pa(vmx->msr_autoload.guest.val));</blue>

<blue>	vmx_set_constant_host_state(vmx);</blue>
}

static void prepare_vmcs02_early_rare(struct vcpu_vmx *vmx,
				      struct vmcs12 *vmcs12)
{
<blue>	prepare_vmcs02_constant_state(vmx);</blue>

<blue>	vmcs_write64(VMCS_LINK_POINTER, INVALID_GPA);</blue>

<blue>	if (enable_vpid) {</blue>
<blue>		if (nested_cpu_has_vpid(vmcs12) && vmx->nested.vpid02)</blue>
<blue>			vmcs_write16(VIRTUAL_PROCESSOR_ID, vmx->nested.vpid02);</blue>
		else
<blue>			vmcs_write16(VIRTUAL_PROCESSOR_ID, vmx->vpid);</blue>
	}
}

static void prepare_vmcs02_early(struct vcpu_vmx *vmx, struct loaded_vmcs *vmcs01,
				 struct vmcs12 *vmcs12)
{
	u32 exec_control;
<blue>	u64 guest_efer = nested_vmx_calc_efer(vmx, vmcs12);</blue>

<blue>	if (vmx->nested.dirty_vmcs12 || evmptr_is_valid(vmx->nested.hv_evmcs_vmptr))</blue>
<blue>		prepare_vmcs02_early_rare(vmx, vmcs12);</blue>

	/*
	 * PIN CONTROLS
	 */
<blue>	exec_control = __pin_controls_get(vmcs01);</blue>
	exec_control |= (vmcs12-&gt;pin_based_vm_exec_control &amp;
			 ~PIN_BASED_VMX_PREEMPTION_TIMER);

	/* Posted interrupts setting is only taken from vmcs12.  */
	vmx-&gt;nested.pi_pending = false;
	if (nested_cpu_has_posted_intr(vmcs12))
<blue>		vmx->nested.posted_intr_nv = vmcs12->posted_intr_nv;</blue>
	else
<blue>		exec_control &= ~PIN_BASED_POSTED_INTR;</blue>
<blue>	pin_controls_set(vmx, exec_control);</blue>

	/*
	 * EXEC CONTROLS
	 */
<blue>	exec_control = __exec_controls_get(vmcs01); /* L0's desires */</blue>
	exec_control &amp;= ~CPU_BASED_INTR_WINDOW_EXITING;
	exec_control &amp;= ~CPU_BASED_NMI_WINDOW_EXITING;
	exec_control &amp;= ~CPU_BASED_TPR_SHADOW;
	exec_control |= vmcs12-&gt;cpu_based_vm_exec_control;

	vmx-&gt;nested.l1_tpr_threshold = -1;
	if (exec_control &amp; CPU_BASED_TPR_SHADOW)
<blue>		vmcs_write32(TPR_THRESHOLD, vmcs12->tpr_threshold);</blue>
#ifdef CONFIG_X86_64
	else
<blue>		exec_control |= CPU_BASED_CR8_LOAD_EXITING |</blue>
				CPU_BASED_CR8_STORE_EXITING;
#endif

	/*
	 * A vmexit (to either L1 hypervisor or L0 userspace) is always needed
	 * for I/O port accesses.
	 */
	exec_control |= CPU_BASED_UNCOND_IO_EXITING;
	exec_control &amp;= ~CPU_BASED_USE_IO_BITMAPS;

	/*
	 * This bit will be computed in nested_get_vmcs12_pages, because
	 * we do not have access to L1&#x27;s MSR bitmap yet.  For now, keep
	 * the same bit as before, hoping to avoid multiple VMWRITEs that
	 * only set/clear this bit.
	 */
	exec_control &amp;= ~CPU_BASED_USE_MSR_BITMAPS;
<blue>	exec_control |= exec_controls_get(vmx) & CPU_BASED_USE_MSR_BITMAPS;</blue>

<blue>	exec_controls_set(vmx, exec_control);</blue>

	/*
	 * SECONDARY EXEC CONTROLS
	 */
<blue>	if (cpu_has_secondary_exec_ctrls()) {</blue>
<blue>		exec_control = __secondary_exec_controls_get(vmcs01);</blue>

		/* Take the following fields only from vmcs12 */
		exec_control &amp;= ~(SECONDARY_EXEC_VIRTUALIZE_APIC_ACCESSES |
				  SECONDARY_EXEC_VIRTUALIZE_X2APIC_MODE |
				  SECONDARY_EXEC_ENABLE_INVPCID |
				  SECONDARY_EXEC_ENABLE_RDTSCP |
				  SECONDARY_EXEC_XSAVES |
				  SECONDARY_EXEC_ENABLE_USR_WAIT_PAUSE |
				  SECONDARY_EXEC_VIRTUAL_INTR_DELIVERY |
				  SECONDARY_EXEC_APIC_REGISTER_VIRT |
				  SECONDARY_EXEC_ENABLE_VMFUNC |
				  SECONDARY_EXEC_DESC);

		if (nested_cpu_has(vmcs12,
				   CPU_BASED_ACTIVATE_SECONDARY_CONTROLS))
<blue>			exec_control |= vmcs12->secondary_vm_exec_control;</blue>

		/* PML is emulated and never enabled in hardware for L2. */
		exec_control &amp;= ~SECONDARY_EXEC_ENABLE_PML;

		/* VMCS shadowing for L2 is emulated for now */
		exec_control &amp;= ~SECONDARY_EXEC_SHADOW_VMCS;

		/*
		 * Preset *DT exiting when emulating UMIP, so that vmx_set_cr4()
		 * will not have to rewrite the controls just for this bit.
		 */
<blue>		if (!boot_cpu_has(X86_FEATURE_UMIP) && vmx_umip_emulated() &&</blue>
<yellow>		    (vmcs12->guest_cr4 & X86_CR4_UMIP))</yellow>
<yellow>			exec_control |= SECONDARY_EXEC_DESC;</yellow>

<blue>		if (exec_control & SECONDARY_EXEC_VIRTUAL_INTR_DELIVERY)</blue>
<blue>			vmcs_write16(GUEST_INTR_STATUS,</blue>
<blue>				vmcs12->guest_intr_status);</blue>

<blue>		if (!nested_cpu_has2(vmcs12, SECONDARY_EXEC_UNRESTRICTED_GUEST))</blue>
<blue>		    exec_control &= ~SECONDARY_EXEC_UNRESTRICTED_GUEST;</blue>

<blue>		if (exec_control & SECONDARY_EXEC_ENCLS_EXITING)</blue>
<yellow>			vmx_write_encls_bitmap(&vmx->vcpu, vmcs12);</yellow>

<blue>		secondary_exec_controls_set(vmx, exec_control);</blue>
	}

	/*
	 * ENTRY CONTROLS
	 *
	 * vmcs12&#x27;s VM_{ENTRY,EXIT}_LOAD_IA32_EFER and VM_ENTRY_IA32E_MODE
	 * are emulated by vmx_set_efer() in prepare_vmcs02(), but speculate
	 * on the related bits (if supported by the CPU) in the hope that
	 * we can avoid VMWrites during vmx_set_efer().
	 *
	 * Similarly, take vmcs01&#x27;s PERF_GLOBAL_CTRL in the hope that if KVM is
	 * loading PERF_GLOBAL_CTRL via the VMCS for L1, then KVM will want to
	 * do the same for L2.
	 */
<blue>	exec_control = __vm_entry_controls_get(vmcs01);</blue>
	exec_control |= (vmcs12-&gt;vm_entry_controls &amp;
			 ~VM_ENTRY_LOAD_IA32_PERF_GLOBAL_CTRL);
	exec_control &amp;= ~(VM_ENTRY_IA32E_MODE | VM_ENTRY_LOAD_IA32_EFER);
	if (cpu_has_load_ia32_efer()) {
<blue>		if (guest_efer & EFER_LMA)</blue>
<blue>			exec_control |= VM_ENTRY_IA32E_MODE;</blue>
<blue>		if (guest_efer != host_efer)</blue>
<blue>			exec_control |= VM_ENTRY_LOAD_IA32_EFER;</blue>
	}
<blue>	vm_entry_controls_set(vmx, exec_control);</blue>

	/*
	 * EXIT CONTROLS
	 *
	 * L2-&gt;L1 exit controls are emulated - the hardware exit is to L0 so
	 * we should use its exit controls. Note that VM_EXIT_LOAD_IA32_EFER
	 * bits may be modified by vmx_set_efer() in prepare_vmcs02().
	 */
<blue>	exec_control = __vm_exit_controls_get(vmcs01);</blue>
<blue>	if (cpu_has_load_ia32_efer() && guest_efer != host_efer)</blue>
<blue>		exec_control |= VM_EXIT_LOAD_IA32_EFER;</blue>
	else
<yellow>		exec_control &= ~VM_EXIT_LOAD_IA32_EFER;</yellow>
<blue>	vm_exit_controls_set(vmx, exec_control);</blue>

	/*
	 * Interrupt/Exception Fields
	 */
<blue>	if (vmx->nested.nested_run_pending) {</blue>
<blue>		vmcs_write32(VM_ENTRY_INTR_INFO_FIELD,</blue>
			     vmcs12-&gt;vm_entry_intr_info_field);
<blue>		vmcs_write32(VM_ENTRY_EXCEPTION_ERROR_CODE,</blue>
			     vmcs12-&gt;vm_entry_exception_error_code);
<blue>		vmcs_write32(VM_ENTRY_INSTRUCTION_LEN,</blue>
			     vmcs12-&gt;vm_entry_instruction_len);
<blue>		vmcs_write32(GUEST_INTERRUPTIBILITY_INFO,</blue>
			     vmcs12-&gt;guest_interruptibility_info);
<blue>		vmx->loaded_vmcs->nmi_known_unmasked =</blue>
<yellow>			!(vmcs12->guest_interruptibility_info & GUEST_INTR_STATE_NMI);</yellow>
	} else {
<yellow>		vmcs_write32(VM_ENTRY_INTR_INFO_FIELD, 0);</yellow>
	}
<blue>}</blue>

static void prepare_vmcs02_rare(struct vcpu_vmx *vmx, struct vmcs12 *vmcs12)
{
<blue>	struct hv_enlightened_vmcs *hv_evmcs = vmx->nested.hv_evmcs;</blue>

<yellow>	if (!hv_evmcs || !(hv_evmcs->hv_clean_fields &</yellow>
			   HV_VMX_ENLIGHTENED_CLEAN_FIELD_GUEST_GRP2)) {
<blue>		vmcs_write16(GUEST_ES_SELECTOR, vmcs12->guest_es_selector);</blue>
<blue>		vmcs_write16(GUEST_CS_SELECTOR, vmcs12->guest_cs_selector);</blue>
<blue>		vmcs_write16(GUEST_SS_SELECTOR, vmcs12->guest_ss_selector);</blue>
<blue>		vmcs_write16(GUEST_DS_SELECTOR, vmcs12->guest_ds_selector);</blue>
<blue>		vmcs_write16(GUEST_FS_SELECTOR, vmcs12->guest_fs_selector);</blue>
<blue>		vmcs_write16(GUEST_GS_SELECTOR, vmcs12->guest_gs_selector);</blue>
<blue>		vmcs_write16(GUEST_LDTR_SELECTOR, vmcs12->guest_ldtr_selector);</blue>
<blue>		vmcs_write16(GUEST_TR_SELECTOR, vmcs12->guest_tr_selector);</blue>
<blue>		vmcs_write32(GUEST_ES_LIMIT, vmcs12->guest_es_limit);</blue>
<blue>		vmcs_write32(GUEST_CS_LIMIT, vmcs12->guest_cs_limit);</blue>
<blue>		vmcs_write32(GUEST_SS_LIMIT, vmcs12->guest_ss_limit);</blue>
<blue>		vmcs_write32(GUEST_DS_LIMIT, vmcs12->guest_ds_limit);</blue>
<blue>		vmcs_write32(GUEST_FS_LIMIT, vmcs12->guest_fs_limit);</blue>
<blue>		vmcs_write32(GUEST_GS_LIMIT, vmcs12->guest_gs_limit);</blue>
<blue>		vmcs_write32(GUEST_LDTR_LIMIT, vmcs12->guest_ldtr_limit);</blue>
<blue>		vmcs_write32(GUEST_TR_LIMIT, vmcs12->guest_tr_limit);</blue>
<blue>		vmcs_write32(GUEST_GDTR_LIMIT, vmcs12->guest_gdtr_limit);</blue>
<blue>		vmcs_write32(GUEST_IDTR_LIMIT, vmcs12->guest_idtr_limit);</blue>
<blue>		vmcs_write32(GUEST_CS_AR_BYTES, vmcs12->guest_cs_ar_bytes);</blue>
<blue>		vmcs_write32(GUEST_SS_AR_BYTES, vmcs12->guest_ss_ar_bytes);</blue>
<blue>		vmcs_write32(GUEST_ES_AR_BYTES, vmcs12->guest_es_ar_bytes);</blue>
<blue>		vmcs_write32(GUEST_DS_AR_BYTES, vmcs12->guest_ds_ar_bytes);</blue>
<blue>		vmcs_write32(GUEST_FS_AR_BYTES, vmcs12->guest_fs_ar_bytes);</blue>
<blue>		vmcs_write32(GUEST_GS_AR_BYTES, vmcs12->guest_gs_ar_bytes);</blue>
<blue>		vmcs_write32(GUEST_LDTR_AR_BYTES, vmcs12->guest_ldtr_ar_bytes);</blue>
<blue>		vmcs_write32(GUEST_TR_AR_BYTES, vmcs12->guest_tr_ar_bytes);</blue>
<blue>		vmcs_writel(GUEST_ES_BASE, vmcs12->guest_es_base);</blue>
<blue>		vmcs_writel(GUEST_CS_BASE, vmcs12->guest_cs_base);</blue>
<blue>		vmcs_writel(GUEST_SS_BASE, vmcs12->guest_ss_base);</blue>
<blue>		vmcs_writel(GUEST_DS_BASE, vmcs12->guest_ds_base);</blue>
<blue>		vmcs_writel(GUEST_FS_BASE, vmcs12->guest_fs_base);</blue>
<blue>		vmcs_writel(GUEST_GS_BASE, vmcs12->guest_gs_base);</blue>
<blue>		vmcs_writel(GUEST_LDTR_BASE, vmcs12->guest_ldtr_base);</blue>
<blue>		vmcs_writel(GUEST_TR_BASE, vmcs12->guest_tr_base);</blue>
<blue>		vmcs_writel(GUEST_GDTR_BASE, vmcs12->guest_gdtr_base);</blue>
<blue>		vmcs_writel(GUEST_IDTR_BASE, vmcs12->guest_idtr_base);</blue>

<blue>		vmx->segment_cache.bitmask = 0;</blue>
	}

<yellow>	if (!hv_evmcs || !(hv_evmcs->hv_clean_fields &</yellow>
			   HV_VMX_ENLIGHTENED_CLEAN_FIELD_GUEST_GRP1)) {
<blue>		vmcs_write32(GUEST_SYSENTER_CS, vmcs12->guest_sysenter_cs);</blue>
<blue>		vmcs_writel(GUEST_PENDING_DBG_EXCEPTIONS,</blue>
<blue>			    vmcs12->guest_pending_dbg_exceptions);</blue>
<blue>		vmcs_writel(GUEST_SYSENTER_ESP, vmcs12->guest_sysenter_esp);</blue>
<blue>		vmcs_writel(GUEST_SYSENTER_EIP, vmcs12->guest_sysenter_eip);</blue>

		/*
		 * L1 may access the L2&#x27;s PDPTR, so save them to construct
		 * vmcs12
		 */
<blue>		if (enable_ept) {</blue>
<blue>			vmcs_write64(GUEST_PDPTR0, vmcs12->guest_pdptr0);</blue>
<blue>			vmcs_write64(GUEST_PDPTR1, vmcs12->guest_pdptr1);</blue>
<blue>			vmcs_write64(GUEST_PDPTR2, vmcs12->guest_pdptr2);</blue>
<blue>			vmcs_write64(GUEST_PDPTR3, vmcs12->guest_pdptr3);</blue>
		}

<blue>		if (kvm_mpx_supported() && vmx->nested.nested_run_pending &&</blue>
<yellow>		    (vmcs12->vm_entry_controls & VM_ENTRY_LOAD_BNDCFGS))</yellow>
<yellow>			vmcs_write64(GUEST_BNDCFGS, vmcs12->guest_bndcfgs);</yellow>
	}

<blue>	if (nested_cpu_has_xsaves(vmcs12))</blue>
<blue>		vmcs_write64(XSS_EXIT_BITMAP, vmcs12->xss_exit_bitmap);</blue>

	/*
	 * Whether page-faults are trapped is determined by a combination of
	 * 3 settings: PFEC_MASK, PFEC_MATCH and EXCEPTION_BITMAP.PF.  If L0
	 * doesn&#x27;t care about page faults then we should set all of these to
	 * L1&#x27;s desires. However, if L0 does care about (some) page faults, it
	 * is not easy (if at all possible?) to merge L0 and L1&#x27;s desires, we
	 * simply ask to exit on each and every L2 page fault. This is done by
	 * setting MASK=MATCH=0 and (see below) EB.PF=1.
	 * Note that below we don&#x27;t need special code to set EB.PF beyond the
	 * &quot;or&quot;ing of the EB of vmcs01 and vmcs12, because when enable_ept,
	 * vmcs01&#x27;s EB.PF is 0 so the &quot;or&quot; will take vmcs12&#x27;s value, and when
	 * !enable_ept, EB.PF is 1, so the &quot;or&quot; will always be 1.
	 */
<blue>	if (vmx_need_pf_intercept(&vmx->vcpu)) {</blue>
		/*
		 * TODO: if both L0 and L1 need the same MASK and MATCH,
		 * go ahead and use it?
		 */
<yellow>		vmcs_write32(PAGE_FAULT_ERROR_CODE_MASK, 0);</yellow>
<yellow>		vmcs_write32(PAGE_FAULT_ERROR_CODE_MATCH, 0);</yellow>
	} else {
<blue>		vmcs_write32(PAGE_FAULT_ERROR_CODE_MASK, vmcs12->page_fault_error_code_mask);</blue>
<blue>		vmcs_write32(PAGE_FAULT_ERROR_CODE_MATCH, vmcs12->page_fault_error_code_match);</blue>
	}

<blue>	if (cpu_has_vmx_apicv()) {</blue>
<blue>		vmcs_write64(EOI_EXIT_BITMAP0, vmcs12->eoi_exit_bitmap0);</blue>
<blue>		vmcs_write64(EOI_EXIT_BITMAP1, vmcs12->eoi_exit_bitmap1);</blue>
<blue>		vmcs_write64(EOI_EXIT_BITMAP2, vmcs12->eoi_exit_bitmap2);</blue>
<blue>		vmcs_write64(EOI_EXIT_BITMAP3, vmcs12->eoi_exit_bitmap3);</blue>
	}

	/*
	 * Make sure the msr_autostore list is up to date before we set the
	 * count in the vmcs02.
	 */
<blue>	prepare_vmx_msr_autostore_list(&vmx->vcpu, MSR_IA32_TSC);</blue>

<blue>	vmcs_write32(VM_EXIT_MSR_STORE_COUNT, vmx->msr_autostore.guest.nr);</blue>
<blue>	vmcs_write32(VM_EXIT_MSR_LOAD_COUNT, vmx->msr_autoload.host.nr);</blue>
<blue>	vmcs_write32(VM_ENTRY_MSR_LOAD_COUNT, vmx->msr_autoload.guest.nr);</blue>

<blue>	set_cr4_guest_host_mask(vmx);</blue>
}

/*
 * prepare_vmcs02 is called when the L1 guest hypervisor runs its nested
 * L2 guest. L1 has a vmcs for L2 (vmcs12), and this function &quot;merges&quot; it
 * with L0&#x27;s requirements for its guest (a.k.a. vmcs01), so we can run the L2
 * guest in a way that will both be appropriate to L1&#x27;s requests, and our
 * needs. In addition to modifying the active vmcs (which is vmcs02), this
 * function also has additional necessary side-effects, like setting various
 * vcpu-&gt;arch fields.
 * Returns 0 on success, 1 on failure. Invalid state exit qualification code
 * is assigned to entry_failure_code on failure.
 */
static int prepare_vmcs02(struct kvm_vcpu *vcpu, struct vmcs12 *vmcs12,
			  bool from_vmentry,
			  enum vm_entry_failure_code *entry_failure_code)
{
	struct vcpu_vmx *vmx = to_vmx(vcpu);
	bool load_guest_pdptrs_vmcs12 = false;

<blue>	if (vmx->nested.dirty_vmcs12 || evmptr_is_valid(vmx->nested.hv_evmcs_vmptr)) {</blue>
<blue>		prepare_vmcs02_rare(vmx, vmcs12);</blue>
		vmx-&gt;nested.dirty_vmcs12 = false;

		load_guest_pdptrs_vmcs12 = !evmptr_is_valid(vmx-&gt;nested.hv_evmcs_vmptr) ||
<yellow>			!(vmx->nested.hv_evmcs->hv_clean_fields &</yellow>
			  HV_VMX_ENLIGHTENED_CLEAN_FIELD_GUEST_GRP1);
	}

<blue>	if (vmx->nested.nested_run_pending &&</blue>
<blue>	    (vmcs12->vm_entry_controls & VM_ENTRY_LOAD_DEBUG_CONTROLS)) {</blue>
<blue>		kvm_set_dr(vcpu, 7, vmcs12->guest_dr7);</blue>
<yellow>		vmcs_write64(GUEST_IA32_DEBUGCTL, vmcs12->guest_ia32_debugctl);</yellow>
	} else {
<blue>		kvm_set_dr(vcpu, 7, vcpu->arch.dr7);</blue>
<blue>		vmcs_write64(GUEST_IA32_DEBUGCTL, vmx->nested.pre_vmenter_debugctl);</blue>
	}
<blue>	if (kvm_mpx_supported() && (!vmx->nested.nested_run_pending ||</blue>
<yellow>	    !(vmcs12->vm_entry_controls & VM_ENTRY_LOAD_BNDCFGS)))</yellow>
<yellow>		vmcs_write64(GUEST_BNDCFGS, vmx->nested.pre_vmenter_bndcfgs);</yellow>
<blue>	vmx_set_rflags(vcpu, vmcs12->guest_rflags);</blue>

	/* EXCEPTION_BITMAP and CR0_GUEST_HOST_MASK should basically be the
	 * bitwise-or of what L1 wants to trap for L2, and what we want to
	 * trap. Note that CR0.TS also needs updating - we do this later.
	 */
	vmx_update_exception_bitmap(vcpu);
	vcpu-&gt;arch.cr0_guest_owned_bits &amp;= ~vmcs12-&gt;cr0_guest_host_mask;
<blue>	vmcs_writel(CR0_GUEST_HOST_MASK, ~vcpu->arch.cr0_guest_owned_bits);</blue>

<blue>	if (vmx->nested.nested_run_pending &&</blue>
<blue>	    (vmcs12->vm_entry_controls & VM_ENTRY_LOAD_IA32_PAT)) {</blue>
<blue>		vmcs_write64(GUEST_IA32_PAT, vmcs12->guest_ia32_pat);</blue>
<blue>		vcpu->arch.pat = vmcs12->guest_ia32_pat;</blue>
<blue>	} else if (vmcs_config.vmentry_ctrl & VM_ENTRY_LOAD_IA32_PAT) {</blue>
<blue>		vmcs_write64(GUEST_IA32_PAT, vmx->vcpu.arch.pat);</blue>
	}

<blue>	vcpu->arch.tsc_offset = kvm_calc_nested_tsc_offset(</blue>
			vcpu-&gt;arch.l1_tsc_offset,
			vmx_get_l2_tsc_offset(vcpu),
			vmx_get_l2_tsc_multiplier(vcpu));

	vcpu-&gt;arch.tsc_scaling_ratio = kvm_calc_nested_tsc_multiplier(
			vcpu-&gt;arch.l1_tsc_scaling_ratio,
			vmx_get_l2_tsc_multiplier(vcpu));

<blue>	vmcs_write64(TSC_OFFSET, vcpu->arch.tsc_offset);</blue>
<blue>	if (kvm_caps.has_tsc_control)</blue>
<blue>		vmcs_write64(TSC_MULTIPLIER, vcpu->arch.tsc_scaling_ratio);</blue>

<blue>	nested_vmx_transition_tlb_flush(vcpu, vmcs12, true);</blue>

<blue>	if (nested_cpu_has_ept(vmcs12))</blue>
<blue>		nested_ept_init_mmu_context(vcpu);</blue>

	/*
	 * This sets GUEST_CR0 to vmcs12-&gt;guest_cr0, possibly modifying those
	 * bits which we consider mandatory enabled.
	 * The CR0_READ_SHADOW is what L2 should have expected to read given
	 * the specifications by L1; It&#x27;s not enough to take
	 * vmcs12-&gt;cr0_read_shadow because on our cr0_guest_host_mask we
	 * have more bits than L1 expected.
	 */
<blue>	vmx_set_cr0(vcpu, vmcs12->guest_cr0);</blue>
<blue>	vmcs_writel(CR0_READ_SHADOW, nested_read_cr0(vmcs12));</blue>

<blue>	vmx_set_cr4(vcpu, vmcs12->guest_cr4);</blue>
<blue>	vmcs_writel(CR4_READ_SHADOW, nested_read_cr4(vmcs12));</blue>

<blue>	vcpu->arch.efer = nested_vmx_calc_efer(vmx, vmcs12);</blue>
	/* Note: may modify VM_ENTRY/EXIT_CONTROLS and GUEST/HOST_IA32_EFER */
	vmx_set_efer(vcpu, vcpu-&gt;arch.efer);

	/*
	 * Guest state is invalid and unrestricted guest is disabled,
	 * which means L1 attempted VMEntry to L2 with invalid state.
	 * Fail the VMEntry.
	 *
	 * However when force loading the guest state (SMM exit or
	 * loading nested state after migration, it is possible to
	 * have invalid guest state now, which will be later fixed by
	 * restoring L2 register state
	 */
<blue>	if (CC(from_vmentry && !vmx_guest_state_valid(vcpu))) {</blue>
<blue>		*entry_failure_code = ENTRY_FAIL_DEFAULT;</blue>
		return -EINVAL;
	}

	/* Shadow page tables on either EPT or shadow page tables. */
<blue>	if (nested_vmx_load_cr3(vcpu, vmcs12->guest_cr3, nested_cpu_has_ept(vmcs12),</blue>
				from_vmentry, entry_failure_code))
		return -EINVAL;

	/*
	 * Immediately write vmcs02.GUEST_CR3.  It will be propagated to vmcs12
	 * on nested VM-Exit, which can occur without actually running L2 and
	 * thus without hitting vmx_load_mmu_pgd(), e.g. if L1 is entering L2 with
	 * vmcs12.GUEST_ACTIVITYSTATE=HLT, in which case KVM will intercept the
	 * transition to HLT instead of running L2.
	 */
<blue>	if (enable_ept)</blue>
<blue>		vmcs_writel(GUEST_CR3, vmcs12->guest_cr3);</blue>

	/* Late preparation of GUEST_PDPTRs now that EFER and CRs are set. */
<blue>	if (load_guest_pdptrs_vmcs12 && nested_cpu_has_ept(vmcs12) &&</blue>
<blue>	    is_pae_paging(vcpu)) {</blue>
<yellow>		vmcs_write64(GUEST_PDPTR0, vmcs12->guest_pdptr0);</yellow>
<yellow>		vmcs_write64(GUEST_PDPTR1, vmcs12->guest_pdptr1);</yellow>
<yellow>		vmcs_write64(GUEST_PDPTR2, vmcs12->guest_pdptr2);</yellow>
<yellow>		vmcs_write64(GUEST_PDPTR3, vmcs12->guest_pdptr3);</yellow>
	}

<blue>	if ((vmcs12->vm_entry_controls & VM_ENTRY_LOAD_IA32_PERF_GLOBAL_CTRL) &&</blue>
<blue>	    intel_pmu_has_perf_global_ctrl(vcpu_to_pmu(vcpu)) &&</blue>
<blue>	    WARN_ON_ONCE(kvm_set_msr(vcpu, MSR_CORE_PERF_GLOBAL_CTRL,</blue>
				     vmcs12-&gt;guest_ia32_perf_global_ctrl))) {
		*entry_failure_code = ENTRY_FAIL_DEFAULT;
		return -EINVAL;
	}

<blue>	kvm_rsp_write(vcpu, vmcs12->guest_rsp);</blue>
	kvm_rip_write(vcpu, vmcs12-&gt;guest_rip);

	/*
	 * It was observed that genuine Hyper-V running in L1 doesn&#x27;t reset
	 * &#x27;hv_clean_fields&#x27; by itself, it only sets the corresponding dirty
	 * bits when it changes a field in eVMCS. Mark all fields as clean
	 * here.
	 */
	if (evmptr_is_valid(vmx-&gt;nested.hv_evmcs_vmptr))
<yellow>		vmx->nested.hv_evmcs->hv_clean_fields |=</yellow>
			HV_VMX_ENLIGHTENED_CLEAN_FIELD_ALL;

	return 0;
}

static int nested_vmx_check_nmi_controls(struct vmcs12 *vmcs12)
{
<blue>	if (CC(!nested_cpu_has_nmi_exiting(vmcs12) &&</blue>
	       nested_cpu_has_virtual_nmis(vmcs12)))
		return -EINVAL;

<blue>	if (CC(!nested_cpu_has_virtual_nmis(vmcs12) &&</blue>
	       nested_cpu_has(vmcs12, CPU_BASED_NMI_WINDOW_EXITING)))
		return -EINVAL;

	return 0;
}

static bool nested_vmx_check_eptp(struct kvm_vcpu *vcpu, u64 new_eptp)
{
	struct vcpu_vmx *vmx = to_vmx(vcpu);

	/* Check for memory type validity */
<blue>	switch (new_eptp & VMX_EPTP_MT_MASK) {</blue>
	case VMX_EPTP_MT_UC:
<blue>		if (CC(!(vmx->nested.msrs.ept_caps & VMX_EPTP_UC_BIT)))</blue>
			return false;
		break;
	case VMX_EPTP_MT_WB:
<blue>		if (CC(!(vmx->nested.msrs.ept_caps & VMX_EPTP_WB_BIT)))</blue>
			return false;
		break;
	default:
		return false;
	}

	/* Page-walk levels validity. */
<blue>	switch (new_eptp & VMX_EPTP_PWL_MASK) {</blue>
	case VMX_EPTP_PWL_5:
<blue>		if (CC(!(vmx->nested.msrs.ept_caps & VMX_EPT_PAGE_WALK_5_BIT)))</blue>
			return false;
		break;
	case VMX_EPTP_PWL_4:
<blue>		if (CC(!(vmx->nested.msrs.ept_caps & VMX_EPT_PAGE_WALK_4_BIT)))</blue>
			return false;
		break;
	default:
		return false;
	}

	/* Reserved bits should not be set */
<blue>	if (CC(kvm_vcpu_is_illegal_gpa(vcpu, new_eptp) || ((new_eptp >> 7) & 0x1f)))</blue>
		return false;

	/* AD, if set, should be supported */
<blue>	if (new_eptp & VMX_EPTP_AD_ENABLE_BIT) {</blue>
<blue>		if (CC(!(vmx->nested.msrs.ept_caps & VMX_EPT_AD_BIT)))</blue>
			return false;
	}

	return true;
<blue>}</blue>

/*
 * Checks related to VM-Execution Control Fields
 */
static int nested_check_vm_execution_controls(struct kvm_vcpu *vcpu,
                                              struct vmcs12 *vmcs12)
{
	struct vcpu_vmx *vmx = to_vmx(vcpu);

<blue>	if (CC(!vmx_control_verify(vmcs12->pin_based_vm_exec_control,</blue>
				   vmx-&gt;nested.msrs.pinbased_ctls_low,
				   vmx-&gt;nested.msrs.pinbased_ctls_high)) ||
<blue>	    CC(!vmx_control_verify(vmcs12->cpu_based_vm_exec_control,</blue>
				   vmx-&gt;nested.msrs.procbased_ctls_low,
				   vmx-&gt;nested.msrs.procbased_ctls_high)))
		return -EINVAL;

<blue>	if (nested_cpu_has(vmcs12, CPU_BASED_ACTIVATE_SECONDARY_CONTROLS) &&</blue>
<blue>	    CC(!vmx_control_verify(vmcs12->secondary_vm_exec_control,</blue>
				   vmx-&gt;nested.msrs.secondary_ctls_low,
				   vmx-&gt;nested.msrs.secondary_ctls_high)))
		return -EINVAL;

<blue>	if (CC(vmcs12->cr3_target_count > nested_cpu_vmx_misc_cr3_count(vcpu)) ||</blue>
<blue>	    nested_vmx_check_io_bitmap_controls(vcpu, vmcs12) ||</blue>
<blue>	    nested_vmx_check_msr_bitmap_controls(vcpu, vmcs12) ||</blue>
<blue>	    nested_vmx_check_tpr_shadow_controls(vcpu, vmcs12) ||</blue>
<blue>	    nested_vmx_check_apic_access_controls(vcpu, vmcs12) ||</blue>
<blue>	    nested_vmx_check_apicv_controls(vcpu, vmcs12) ||</blue>
<blue>	    nested_vmx_check_nmi_controls(vmcs12) ||</blue>
<blue>	    nested_vmx_check_pml_controls(vcpu, vmcs12) ||</blue>
<blue>	    nested_vmx_check_unrestricted_guest_controls(vcpu, vmcs12) ||</blue>
<blue>	    nested_vmx_check_mode_based_ept_exec_controls(vcpu, vmcs12) ||</blue>
<blue>	    nested_vmx_check_shadow_vmcs_controls(vcpu, vmcs12) ||</blue>
<blue>	    CC(nested_cpu_has_vpid(vmcs12) && !vmcs12->virtual_processor_id))</blue>
		return -EINVAL;

<blue>	if (!nested_cpu_has_preemption_timer(vmcs12) &&</blue>
<blue>	    nested_cpu_has_save_preemption_timer(vmcs12))</blue>
		return -EINVAL;

<blue>	if (nested_cpu_has_ept(vmcs12) &&</blue>
<blue>	    CC(!nested_vmx_check_eptp(vcpu, vmcs12->ept_pointer)))</blue>
		return -EINVAL;

<blue>	if (nested_cpu_has_vmfunc(vmcs12)) {</blue>
<blue>		if (CC(vmcs12->vm_function_control &</blue>
		       ~vmx-&gt;nested.msrs.vmfunc_controls))
			return -EINVAL;

<blue>		if (nested_cpu_has_eptp_switching(vmcs12)) {</blue>
<blue>			if (CC(!nested_cpu_has_ept(vmcs12)) ||</blue>
<blue>			    CC(!page_address_valid(vcpu, vmcs12->eptp_list_address)))</blue>
				return -EINVAL;
		}
	}

	return 0;
}

/*
 * Checks related to VM-Exit Control Fields
 */
static int nested_check_vm_exit_controls(struct kvm_vcpu *vcpu,
                                         struct vmcs12 *vmcs12)
{
	struct vcpu_vmx *vmx = to_vmx(vcpu);

<blue>	if (CC(!vmx_control_verify(vmcs12->vm_exit_controls,</blue>
				    vmx-&gt;nested.msrs.exit_ctls_low,
				    vmx-&gt;nested.msrs.exit_ctls_high)) ||
<blue>	    CC(nested_vmx_check_exit_msr_switch_controls(vcpu, vmcs12)))</blue>
		return -EINVAL;

	return 0;
}

/*
 * Checks related to VM-Entry Control Fields
 */
static int nested_check_vm_entry_controls(struct kvm_vcpu *vcpu,
					  struct vmcs12 *vmcs12)
{
	struct vcpu_vmx *vmx = to_vmx(vcpu);

<blue>	if (CC(!vmx_control_verify(vmcs12->vm_entry_controls,</blue>
				    vmx-&gt;nested.msrs.entry_ctls_low,
				    vmx-&gt;nested.msrs.entry_ctls_high)))
		return -EINVAL;

	/*
	 * From the Intel SDM, volume 3:
	 * Fields relevant to VM-entry event injection must be set properly.
	 * These fields are the VM-entry interruption-information field, the
	 * VM-entry exception error code, and the VM-entry instruction length.
	 */
<blue>	if (vmcs12->vm_entry_intr_info_field & INTR_INFO_VALID_MASK) {</blue>
		u32 intr_info = vmcs12-&gt;vm_entry_intr_info_field;
		u8 vector = intr_info &amp; INTR_INFO_VECTOR_MASK;
		u32 intr_type = intr_info &amp; INTR_INFO_INTR_TYPE_MASK;
		bool has_error_code = intr_info &amp; INTR_INFO_DELIVER_CODE_MASK;
		bool should_have_error_code;
<blue>		bool urg = nested_cpu_has2(vmcs12,</blue>
					   SECONDARY_EXEC_UNRESTRICTED_GUEST);
<blue>		bool prot_mode = !urg || vmcs12->guest_cr0 & X86_CR0_PE;</blue>

		/* VM-entry interruption-info field: interruption type */
<blue>		if (CC(intr_type == INTR_TYPE_RESERVED) ||</blue>
<blue>		    CC(intr_type == INTR_TYPE_OTHER_EVENT &&</blue>
		       !nested_cpu_supports_monitor_trap_flag(vcpu)))
			return -EINVAL;

		/* VM-entry interruption-info field: vector */
<blue>		if (CC(intr_type == INTR_TYPE_NMI_INTR && vector != NMI_VECTOR) ||</blue>
<blue>		    CC(intr_type == INTR_TYPE_HARD_EXCEPTION && vector > 31) ||</blue>
<blue>		    CC(intr_type == INTR_TYPE_OTHER_EVENT && vector != 0))</blue>
			return -EINVAL;

		/* VM-entry interruption-info field: deliver error code */
		should_have_error_code =
<blue>			intr_type == INTR_TYPE_HARD_EXCEPTION && prot_mode &&</blue>
<blue>			x86_exception_has_error_code(vector);</blue>
<blue>		if (CC(has_error_code != should_have_error_code))</blue>
			return -EINVAL;

		/* VM-entry exception error code */
<blue>		if (CC(has_error_code &&</blue>
		       vmcs12-&gt;vm_entry_exception_error_code &amp; GENMASK(31, 16)))
			return -EINVAL;

		/* VM-entry interruption-info field: reserved bits */
<blue>		if (CC(intr_info & INTR_INFO_RESVD_BITS_MASK))</blue>
			return -EINVAL;

		/* VM-entry instruction length */
<blue>		switch (intr_type) {</blue>
		case INTR_TYPE_SOFT_EXCEPTION:
		case INTR_TYPE_SOFT_INTR:
		case INTR_TYPE_PRIV_SW_EXCEPTION:
<blue>			if (CC(vmcs12->vm_entry_instruction_len > 15) ||</blue>
<blue>			    CC(vmcs12->vm_entry_instruction_len == 0 &&</blue>
			    CC(!nested_cpu_has_zero_length_injection(vcpu))))
				return -EINVAL;
		}
	}

<blue>	if (nested_vmx_check_entry_msr_switch_controls(vcpu, vmcs12))</blue>
		return -EINVAL;

	return 0;
}

static int nested_vmx_check_controls(struct kvm_vcpu *vcpu,
				     struct vmcs12 *vmcs12)
{
<blue>	if (nested_check_vm_execution_controls(vcpu, vmcs12) ||</blue>
<blue>	    nested_check_vm_exit_controls(vcpu, vmcs12) ||</blue>
<blue>	    nested_check_vm_entry_controls(vcpu, vmcs12))</blue>
		return -EINVAL;

<blue>	if (guest_cpuid_has_evmcs(vcpu))</blue>
<blue>		return nested_evmcs_check_controls(vmcs12);</blue>

	return 0;
<blue>}</blue>

static int nested_vmx_check_address_space_size(struct kvm_vcpu *vcpu,
				       struct vmcs12 *vmcs12)
{
#ifdef CONFIG_X86_64
<blue>	if (CC(!!(vmcs12->vm_exit_controls & VM_EXIT_HOST_ADDR_SPACE_SIZE) !=</blue>
		!!(vcpu-&gt;arch.efer &amp; EFER_LMA)))
		return -EINVAL;
#endif
	return 0;
}

static int nested_vmx_check_host_state(struct kvm_vcpu *vcpu,
				       struct vmcs12 *vmcs12)
{
	bool ia32e;

<blue>	if (CC(!nested_host_cr0_valid(vcpu, vmcs12->host_cr0)) ||</blue>
<blue>	    CC(!nested_host_cr4_valid(vcpu, vmcs12->host_cr4)) ||</blue>
<blue>	    CC(kvm_vcpu_is_illegal_gpa(vcpu, vmcs12->host_cr3)))</blue>
		return -EINVAL;

<blue>	if (CC(is_noncanonical_address(vmcs12->host_ia32_sysenter_esp, vcpu)) ||</blue>
<blue>	    CC(is_noncanonical_address(vmcs12->host_ia32_sysenter_eip, vcpu)))</blue>
		return -EINVAL;

<blue>	if ((vmcs12->vm_exit_controls & VM_EXIT_LOAD_IA32_PAT) &&</blue>
<blue>	    CC(!kvm_pat_valid(vmcs12->host_ia32_pat)))</blue>
		return -EINVAL;

<blue>	if ((vmcs12->vm_exit_controls & VM_EXIT_LOAD_IA32_PERF_GLOBAL_CTRL) &&</blue>
<blue>	    CC(!kvm_valid_perf_global_ctrl(vcpu_to_pmu(vcpu),</blue>
					   vmcs12-&gt;host_ia32_perf_global_ctrl)))
		return -EINVAL;

#ifdef CONFIG_X86_64
<blue>	ia32e = !!(vmcs12->vm_exit_controls & VM_EXIT_HOST_ADDR_SPACE_SIZE);</blue>
#else
	ia32e = false;
#endif

	if (ia32e) {
<blue>		if (CC(!(vmcs12->host_cr4 & X86_CR4_PAE)))</blue>
			return -EINVAL;
	} else {
<yellow>		if (CC(vmcs12->vm_entry_controls & VM_ENTRY_IA32E_MODE) ||</yellow>
<yellow>		    CC(vmcs12->host_cr4 & X86_CR4_PCIDE) ||</yellow>
<yellow>		    CC((vmcs12->host_rip) >> 32))</yellow>
			return -EINVAL;
	}

<blue>	if (CC(vmcs12->host_cs_selector & (SEGMENT_RPL_MASK | SEGMENT_TI_MASK)) ||</blue>
<blue>	    CC(vmcs12->host_ss_selector & (SEGMENT_RPL_MASK | SEGMENT_TI_MASK)) ||</blue>
<blue>	    CC(vmcs12->host_ds_selector & (SEGMENT_RPL_MASK | SEGMENT_TI_MASK)) ||</blue>
<blue>	    CC(vmcs12->host_es_selector & (SEGMENT_RPL_MASK | SEGMENT_TI_MASK)) ||</blue>
<blue>	    CC(vmcs12->host_fs_selector & (SEGMENT_RPL_MASK | SEGMENT_TI_MASK)) ||</blue>
<blue>	    CC(vmcs12->host_gs_selector & (SEGMENT_RPL_MASK | SEGMENT_TI_MASK)) ||</blue>
<blue>	    CC(vmcs12->host_tr_selector & (SEGMENT_RPL_MASK | SEGMENT_TI_MASK)) ||</blue>
<blue>	    CC(vmcs12->host_cs_selector == 0) ||</blue>
<blue>	    CC(vmcs12->host_tr_selector == 0) ||</blue>
<blue>	    CC(vmcs12->host_ss_selector == 0 && !ia32e))</blue>
		return -EINVAL;

<blue>	if (CC(is_noncanonical_address(vmcs12->host_fs_base, vcpu)) ||</blue>
<blue>	    CC(is_noncanonical_address(vmcs12->host_gs_base, vcpu)) ||</blue>
<blue>	    CC(is_noncanonical_address(vmcs12->host_gdtr_base, vcpu)) ||</blue>
<blue>	    CC(is_noncanonical_address(vmcs12->host_idtr_base, vcpu)) ||</blue>
<blue>	    CC(is_noncanonical_address(vmcs12->host_tr_base, vcpu)) ||</blue>
<blue>	    CC(is_noncanonical_address(vmcs12->host_rip, vcpu)))</blue>
		return -EINVAL;

	/*
	 * If the load IA32_EFER VM-exit control is 1, bits reserved in the
	 * IA32_EFER MSR must be 0 in the field for that register. In addition,
	 * the values of the LMA and LME bits in the field must each be that of
	 * the host address-space size VM-exit control.
	 */
<blue>	if (vmcs12->vm_exit_controls & VM_EXIT_LOAD_IA32_EFER) {</blue>
<blue>		if (CC(!kvm_valid_efer(vcpu, vmcs12->host_ia32_efer)) ||</blue>
<yellow>		    CC(ia32e != !!(vmcs12->host_ia32_efer & EFER_LMA)) ||</yellow>
<blue>		    CC(ia32e != !!(vmcs12->host_ia32_efer & EFER_LME)))</blue>
			return -EINVAL;
	}

	return 0;
<blue>}</blue>

static int nested_vmx_check_vmcs_link_ptr(struct kvm_vcpu *vcpu,
					  struct vmcs12 *vmcs12)
{
	struct vcpu_vmx *vmx = to_vmx(vcpu);
	struct gfn_to_hva_cache *ghc = &amp;vmx-&gt;nested.shadow_vmcs12_cache;
	struct vmcs_hdr hdr;

<blue>	if (vmcs12->vmcs_link_pointer == INVALID_GPA)</blue>
		return 0;

<blue>	if (CC(!page_address_valid(vcpu, vmcs12->vmcs_link_pointer)))</blue>
		return -EINVAL;

<blue>	if (ghc->gpa != vmcs12->vmcs_link_pointer &&</blue>
<blue>	    CC(kvm_gfn_to_hva_cache_init(vcpu->kvm, ghc,</blue>
					 vmcs12-&gt;vmcs_link_pointer, VMCS12_SIZE)))
                return -EINVAL;

<blue>	if (CC(kvm_read_guest_offset_cached(vcpu->kvm, ghc, &hdr,</blue>
					    offsetof(struct vmcs12, hdr),
					    sizeof(hdr))))
		return -EINVAL;

<blue>	if (CC(hdr.revision_id != VMCS12_REVISION) ||</blue>
<blue>	    CC(hdr.shadow_vmcs != nested_cpu_has_shadow_vmcs(vmcs12)))</blue>
		return -EINVAL;

	return 0;
}

/*
 * Checks related to Guest Non-register State
 */
static int nested_check_guest_non_reg_state(struct vmcs12 *vmcs12)
{
<blue>	if (CC(vmcs12->guest_activity_state != GUEST_ACTIVITY_ACTIVE &&</blue>
	       vmcs12-&gt;guest_activity_state != GUEST_ACTIVITY_HLT &amp;&amp;
	       vmcs12-&gt;guest_activity_state != GUEST_ACTIVITY_WAIT_SIPI))
		return -EINVAL;

	return 0;
}

static int nested_vmx_check_guest_state(struct kvm_vcpu *vcpu,
					struct vmcs12 *vmcs12,
					enum vm_entry_failure_code *entry_failure_code)
<blue>{</blue>
	bool ia32e;

<blue>	*entry_failure_code = ENTRY_FAIL_DEFAULT;</blue>

<blue>	if (CC(!nested_guest_cr0_valid(vcpu, vmcs12->guest_cr0)) ||</blue>
<blue>	    CC(!nested_guest_cr4_valid(vcpu, vmcs12->guest_cr4)))</blue>
		return -EINVAL;

<blue>	if ((vmcs12->vm_entry_controls & VM_ENTRY_LOAD_DEBUG_CONTROLS) &&</blue>
<blue>	    CC(!kvm_dr7_valid(vmcs12->guest_dr7)))</blue>
		return -EINVAL;

<blue>	if ((vmcs12->vm_entry_controls & VM_ENTRY_LOAD_IA32_PAT) &&</blue>
<blue>	    CC(!kvm_pat_valid(vmcs12->guest_ia32_pat)))</blue>
		return -EINVAL;

<blue>	if (nested_vmx_check_vmcs_link_ptr(vcpu, vmcs12)) {</blue>
<blue>		*entry_failure_code = ENTRY_FAIL_VMCS_LINK_PTR;</blue>
		return -EINVAL;
	}

<blue>	if ((vmcs12->vm_entry_controls & VM_ENTRY_LOAD_IA32_PERF_GLOBAL_CTRL) &&</blue>
<blue>	    CC(!kvm_valid_perf_global_ctrl(vcpu_to_pmu(vcpu),</blue>
					   vmcs12-&gt;guest_ia32_perf_global_ctrl)))
		return -EINVAL;

	/*
	 * If the load IA32_EFER VM-entry control is 1, the following checks
	 * are performed on the field for the IA32_EFER MSR:
	 * - Bits reserved in the IA32_EFER MSR must be 0.
	 * - Bit 10 (corresponding to IA32_EFER.LMA) must equal the value of
	 *   the IA-32e mode guest VM-exit control. It must also be identical
	 *   to bit 8 (LME) if bit 31 in the CR0 field (corresponding to
	 *   CR0.PG) is 1.
	 */
<blue>	if (to_vmx(vcpu)->nested.nested_run_pending &&</blue>
<blue>	    (vmcs12->vm_entry_controls & VM_ENTRY_LOAD_IA32_EFER)) {</blue>
<blue>		ia32e = (vmcs12->vm_entry_controls & VM_ENTRY_IA32E_MODE) != 0;</blue>
<blue>		if (CC(!kvm_valid_efer(vcpu, vmcs12->guest_ia32_efer)) ||</blue>
<blue>		    CC(ia32e != !!(vmcs12->guest_ia32_efer & EFER_LMA)) ||</blue>
<blue>		    CC(((vmcs12->guest_cr0 & X86_CR0_PG) &&</blue>
		     ia32e != !!(vmcs12-&gt;guest_ia32_efer &amp; EFER_LME))))
			return -EINVAL;
	}

<blue>	if ((vmcs12->vm_entry_controls & VM_ENTRY_LOAD_BNDCFGS) &&</blue>
<yellow>	    (CC(is_noncanonical_address(vmcs12->guest_bndcfgs & PAGE_MASK, vcpu)) ||</yellow>
<yellow>	     CC((vmcs12->guest_bndcfgs & MSR_IA32_BNDCFGS_RSVD))))</yellow>
		return -EINVAL;

<blue>	if (nested_check_guest_non_reg_state(vmcs12))</blue>
		return -EINVAL;

	return 0;
}

static int nested_vmx_check_vmentry_hw(struct kvm_vcpu *vcpu)
{
	struct vcpu_vmx *vmx = to_vmx(vcpu);
	unsigned long cr3, cr4;
	bool vm_fail;

<blue>	if (!nested_early_check)</blue>
		return 0;

<blue>	if (vmx->msr_autoload.host.nr)</blue>
<yellow>		vmcs_write32(VM_EXIT_MSR_LOAD_COUNT, 0);</yellow>
<blue>	if (vmx->msr_autoload.guest.nr)</blue>
<yellow>		vmcs_write32(VM_ENTRY_MSR_LOAD_COUNT, 0);</yellow>

<blue>	preempt_disable();</blue>

	vmx_prepare_switch_to_guest(vcpu);

	/*
	 * Induce a consistency check VMExit by clearing bit 1 in GUEST_RFLAGS,
	 * which is reserved to &#x27;1&#x27; by hardware.  GUEST_RFLAGS is guaranteed to
	 * be written (by prepare_vmcs02()) before the &quot;real&quot; VMEnter, i.e.
	 * there is no need to preserve other bits or save/restore the field.
	 */
<blue>	vmcs_writel(GUEST_RFLAGS, 0);</blue>

<blue>	cr3 = __get_current_cr3_fast();</blue>
	if (unlikely(cr3 != vmx-&gt;loaded_vmcs-&gt;host_state.cr3)) {
<yellow>		vmcs_writel(HOST_CR3, cr3);</yellow>
<yellow>		vmx->loaded_vmcs->host_state.cr3 = cr3;</yellow>
	}

<blue>	cr4 = cr4_read_shadow();</blue>
	if (unlikely(cr4 != vmx-&gt;loaded_vmcs-&gt;host_state.cr4)) {
<yellow>		vmcs_writel(HOST_CR4, cr4);</yellow>
<yellow>		vmx->loaded_vmcs->host_state.cr4 = cr4;</yellow>
	}

<blue>	vm_fail = __vmx_vcpu_run(vmx, (unsigned long *)&vcpu->arch.regs,</blue>
				 __vmx_vcpu_run_flags(vmx));

	if (vmx-&gt;msr_autoload.host.nr)
<yellow>		vmcs_write32(VM_EXIT_MSR_LOAD_COUNT, vmx->msr_autoload.host.nr);</yellow>
<blue>	if (vmx->msr_autoload.guest.nr)</blue>
<yellow>		vmcs_write32(VM_ENTRY_MSR_LOAD_COUNT, vmx->msr_autoload.guest.nr);</yellow>

<blue>	if (vm_fail) {</blue>
<blue>		u32 error = vmcs_read32(VM_INSTRUCTION_ERROR);</blue>

<blue>		preempt_enable();</blue>

<blue>		trace_kvm_nested_vmenter_failed(</blue>
			&quot;early hardware check VM-instruction error: &quot;, error);
<blue>		WARN_ON_ONCE(error != VMXERR_ENTRY_INVALID_CONTROL_FIELD);</blue>
		return 1;
	}

	/*
	 * VMExit clears RFLAGS.IF and DR7, even on a consistency check.
	 */
<yellow>	if (hw_breakpoint_active())</yellow>
<yellow>		set_debugreg(__this_cpu_read(cpu_dr7), 7);</yellow>
<yellow>	local_irq_enable();</yellow>
<yellow>	preempt_enable();</yellow>

	/*
	 * A non-failing VMEntry means we somehow entered guest mode with
	 * an illegal RIP, and that&#x27;s just the tip of the iceberg.  There
	 * is no telling what memory has been modified or what state has
	 * been exposed to unknown code.  Hitting this all but guarantees
	 * a (very critical) hardware issue.
	 */
<yellow>	WARN_ON(!(vmcs_read32(VM_EXIT_REASON) &</yellow>
		VMX_EXIT_REASONS_FAILED_VMENTRY));

	return 0;
}

<yellow>static bool nested_get_evmcs_page(struct kvm_vcpu *vcpu)</yellow>
{
	struct vcpu_vmx *vmx = to_vmx(vcpu);

	/*
	 * hv_evmcs may end up being not mapped after migration (when
	 * L2 was running), map it here to make sure vmcs12 changes are
	 * properly reflected.
	 */
<yellow>	if (guest_cpuid_has_evmcs(vcpu) &&</yellow>
<yellow>	    vmx->nested.hv_evmcs_vmptr == EVMPTR_MAP_PENDING) {</yellow>
		enum nested_evmptrld_status evmptrld_status =
<yellow>			nested_vmx_handle_enlightened_vmptrld(vcpu, false);</yellow>

		if (evmptrld_status == EVMPTRLD_VMFAIL ||
		    evmptrld_status == EVMPTRLD_ERROR)
			return false;

		/*
		 * Post migration VMCS12 always provides the most actual
		 * information, copy it to eVMCS upon entry.
		 */
<yellow>		vmx->nested.need_vmcs12_to_shadow_sync = true;</yellow>
	}

	return true;
}

static bool nested_get_vmcs12_pages(struct kvm_vcpu *vcpu)
{
<blue>	struct vmcs12 *vmcs12 = get_vmcs12(vcpu);</blue>
	struct vcpu_vmx *vmx = to_vmx(vcpu);
	struct kvm_host_map *map;

	if (!vcpu-&gt;arch.pdptrs_from_userspace &amp;&amp;
<blue>	    !nested_cpu_has_ept(vmcs12) && is_pae_paging(vcpu)) {</blue>
		/*
		 * Reload the guest&#x27;s PDPTRs since after a migration
		 * the guest CR3 might be restored prior to setting the nested
		 * state which can lead to a load of wrong PDPTRs.
		 */
<yellow>		if (CC(!load_pdptrs(vcpu, vcpu->arch.cr3)))</yellow>
			return false;
	}


<blue>	if (nested_cpu_has2(vmcs12, SECONDARY_EXEC_VIRTUALIZE_APIC_ACCESSES)) {</blue>
		map = &amp;vmx-&gt;nested.apic_access_page_map;

<blue>		if (!kvm_vcpu_map(vcpu, gpa_to_gfn(vmcs12->apic_access_addr), map)) {</blue>
<blue>			vmcs_write64(APIC_ACCESS_ADDR, pfn_to_hpa(map->pfn));</blue>
		} else {
<blue>			pr_debug_ratelimited("%s: no backing for APIC-access address in vmcs12\n",</blue>
					     __func__);
<blue>			vcpu->run->exit_reason = KVM_EXIT_INTERNAL_ERROR;</blue>
			vcpu-&gt;run-&gt;internal.suberror =
				KVM_INTERNAL_ERROR_EMULATION;
			vcpu-&gt;run-&gt;internal.ndata = 0;
			return false;
		}
	}

<blue>	if (nested_cpu_has(vmcs12, CPU_BASED_TPR_SHADOW)) {</blue>
		map = &amp;vmx-&gt;nested.virtual_apic_map;

<blue>		if (!kvm_vcpu_map(vcpu, gpa_to_gfn(vmcs12->virtual_apic_page_addr), map)) {</blue>
<blue>			vmcs_write64(VIRTUAL_APIC_PAGE_ADDR, pfn_to_hpa(map->pfn));</blue>
<blue>		} else if (nested_cpu_has(vmcs12, CPU_BASED_CR8_LOAD_EXITING) &&</blue>
		           nested_cpu_has(vmcs12, CPU_BASED_CR8_STORE_EXITING) &amp;&amp;
<blue>			   !nested_cpu_has2(vmcs12, SECONDARY_EXEC_VIRTUALIZE_APIC_ACCESSES)) {</blue>
			/*
			 * The processor will never use the TPR shadow, simply
			 * clear the bit from the execution control.  Such a
			 * configuration is useless, but it happens in tests.
			 * For any other configuration, failing the vm entry is
			 * _not_ what the processor does but it&#x27;s basically the
			 * only possibility we have.
			 */
<blue>			exec_controls_clearbit(vmx, CPU_BASED_TPR_SHADOW);</blue>
		} else {
			/*
			 * Write an illegal value to VIRTUAL_APIC_PAGE_ADDR to
			 * force VM-Entry to fail.
			 */
<blue>			vmcs_write64(VIRTUAL_APIC_PAGE_ADDR, INVALID_GPA);</blue>
		}
	}

<blue>	if (nested_cpu_has_posted_intr(vmcs12)) {</blue>
		map = &amp;vmx-&gt;nested.pi_desc_map;

<blue>		if (!kvm_vcpu_map(vcpu, gpa_to_gfn(vmcs12->posted_intr_desc_addr), map)) {</blue>
			vmx-&gt;nested.pi_desc =
<blue>				(struct pi_desc *)(((void *)map->hva) +</blue>
				offset_in_page(vmcs12-&gt;posted_intr_desc_addr));
<blue>			vmcs_write64(POSTED_INTR_DESC_ADDR,</blue>
				     pfn_to_hpa(map-&gt;pfn) + offset_in_page(vmcs12-&gt;posted_intr_desc_addr));
		} else {
			/*
			 * Defer the KVM_INTERNAL_EXIT until KVM tries to
			 * access the contents of the VMCS12 posted interrupt
			 * descriptor. (Note that KVM may do this when it
			 * should not, per the architectural specification.)
			 */
<blue>			vmx->nested.pi_desc = NULL;</blue>
<blue>			pin_controls_clearbit(vmx, PIN_BASED_POSTED_INTR);</blue>
		}
	}
<blue>	if (nested_vmx_prepare_msr_bitmap(vcpu, vmcs12))</blue>
<blue>		exec_controls_setbit(vmx, CPU_BASED_USE_MSR_BITMAPS);</blue>
	else
<blue>		exec_controls_clearbit(vmx, CPU_BASED_USE_MSR_BITMAPS);</blue>

	return true;
<blue>}</blue>

<yellow>static bool vmx_get_nested_state_pages(struct kvm_vcpu *vcpu)</yellow>
{
<yellow>	if (!nested_get_evmcs_page(vcpu)) {</yellow>
<yellow>		pr_debug_ratelimited("%s: enlightened vmptrld failed\n",</yellow>
				     __func__);
<yellow>		vcpu->run->exit_reason = KVM_EXIT_INTERNAL_ERROR;</yellow>
		vcpu-&gt;run-&gt;internal.suberror =
			KVM_INTERNAL_ERROR_EMULATION;
		vcpu-&gt;run-&gt;internal.ndata = 0;

		return false;
	}

<yellow>	if (is_guest_mode(vcpu) && !nested_get_vmcs12_pages(vcpu))</yellow>
		return false;

	return true;
<yellow>}</yellow>

static int nested_vmx_write_pml_buffer(struct kvm_vcpu *vcpu, gpa_t gpa)
<blue>{</blue>
	struct vmcs12 *vmcs12;
	struct vcpu_vmx *vmx = to_vmx(vcpu);
	gpa_t dst;

<blue>	if (WARN_ON_ONCE(!is_guest_mode(vcpu)))</blue>
		return 0;

<blue>	if (WARN_ON_ONCE(vmx->nested.pml_full))</blue>
		return 1;

	/*
	 * Check if PML is enabled for the nested guest. Whether eptp bit 6 is
	 * set is already checked as part of A/D emulation.
	 */
<blue>	vmcs12 = get_vmcs12(vcpu);</blue>
<blue>	if (!nested_cpu_has_pml(vmcs12))</blue>
		return 0;

<blue>	if (vmcs12->guest_pml_index >= PML_ENTITY_NUM) {</blue>
<blue>		vmx->nested.pml_full = true;</blue>
		return 1;
	}

	gpa &amp;= ~0xFFFull;
<blue>	dst = vmcs12->pml_address + sizeof(u64) * vmcs12->guest_pml_index;</blue>

	if (kvm_write_guest_page(vcpu-&gt;kvm, gpa_to_gfn(dst), &amp;gpa,
				 offset_in_page(dst), sizeof(gpa)))
		return 0;

<blue>	vmcs12->guest_pml_index--;</blue>

	return 0;
}

/*
 * Intel&#x27;s VMX Instruction Reference specifies a common set of prerequisites
 * for running VMX instructions (except VMXON, whose prerequisites are
 * slightly different). It also specifies what exception to inject otherwise.
 * Note that many of these exceptions have priority over VM exits, so they
 * don&#x27;t have to be checked again here.
 */
<yellow>static int nested_vmx_check_permission(struct kvm_vcpu *vcpu)</yellow>
{
<blue>	if (!to_vmx(vcpu)->nested.vmxon) {</blue>
<blue>		kvm_queue_exception(vcpu, UD_VECTOR);</blue>
		return 0;
	}

<blue>	if (vmx_get_cpl(vcpu)) {</blue>
<yellow>		kvm_inject_gp(vcpu, 0);</yellow>
		return 0;
	}

	return 1;
<blue>}</blue>

static u8 vmx_has_apicv_interrupt(struct kvm_vcpu *vcpu)
{
<blue>	u8 rvi = vmx_get_rvi();</blue>
<blue>	u8 vppr = kvm_lapic_get_reg(vcpu->arch.apic, APIC_PROCPRI);</blue>

<blue>	return ((rvi & 0xf0) > (vppr & 0xf0));</blue>
}

static void load_vmcs12_host_state(struct kvm_vcpu *vcpu,
				   struct vmcs12 *vmcs12);

/*
 * If from_vmentry is false, this is being called from state restore (either RSM
 * or KVM_SET_NESTED_STATE).  Otherwise it&#x27;s called from vmlaunch/vmresume.
 *
 * Returns:
 *	NVMX_VMENTRY_SUCCESS: Entered VMX non-root mode
 *	NVMX_VMENTRY_VMFAIL:  Consistency check VMFail
 *	NVMX_VMENTRY_VMEXIT:  Consistency check VMExit
 *	NVMX_VMENTRY_KVM_INTERNAL_ERROR: KVM internal error
 */
enum nvmx_vmentry_status nested_vmx_enter_non_root_mode(struct kvm_vcpu *vcpu,
							bool from_vmentry)
<blue>{</blue>
	struct vcpu_vmx *vmx = to_vmx(vcpu);
<blue>	struct vmcs12 *vmcs12 = get_vmcs12(vcpu);</blue>
	enum vm_entry_failure_code entry_failure_code;
	bool evaluate_pending_interrupts;
	union vmx_exit_reason exit_reason = {
		.basic = EXIT_REASON_INVALID_STATE,
		.failed_vmentry = 1,
	};
	u32 failed_index;

<blue>	trace_kvm_nested_vmenter(kvm_rip_read(vcpu),</blue>
				 vmx-&gt;nested.current_vmptr,
				 vmcs12-&gt;guest_rip,
				 vmcs12-&gt;guest_intr_status,
				 vmcs12-&gt;vm_entry_intr_info_field,
				 vmcs12-&gt;secondary_vm_exec_control &amp; SECONDARY_EXEC_ENABLE_EPT,
				 vmcs12-&gt;ept_pointer,
				 vmcs12-&gt;guest_cr3,
				 KVM_ISA_VMX);

<blue>	kvm_service_local_tlb_flush_requests(vcpu);</blue>

	evaluate_pending_interrupts = exec_controls_get(vmx) &amp;
		(CPU_BASED_INTR_WINDOW_EXITING | CPU_BASED_NMI_WINDOW_EXITING);
<blue>	if (likely(!evaluate_pending_interrupts) && kvm_vcpu_apicv_active(vcpu))</blue>
<blue>		evaluate_pending_interrupts |= vmx_has_apicv_interrupt(vcpu);</blue>
	if (!evaluate_pending_interrupts)
<blue>		evaluate_pending_interrupts |= kvm_apic_has_pending_init_or_sipi(vcpu);</blue>

<blue>	if (!vmx->nested.nested_run_pending ||</blue>
<blue>	    !(vmcs12->vm_entry_controls & VM_ENTRY_LOAD_DEBUG_CONTROLS))</blue>
<blue>		vmx->nested.pre_vmenter_debugctl = vmcs_read64(GUEST_IA32_DEBUGCTL);</blue>
<blue>	if (kvm_mpx_supported() &&</blue>
<yellow>	    (!vmx->nested.nested_run_pending ||</yellow>
<yellow>	     !(vmcs12->vm_entry_controls & VM_ENTRY_LOAD_BNDCFGS)))</yellow>
<yellow>		vmx->nested.pre_vmenter_bndcfgs = vmcs_read64(GUEST_BNDCFGS);</yellow>

	/*
	 * Overwrite vmcs01.GUEST_CR3 with L1&#x27;s CR3 if EPT is disabled *and*
	 * nested early checks are disabled.  In the event of a &quot;late&quot; VM-Fail,
	 * i.e. a VM-Fail detected by hardware but not KVM, KVM must unwind its
	 * software model to the pre-VMEntry host state.  When EPT is disabled,
	 * GUEST_CR3 holds KVM&#x27;s shadow CR3, not L1&#x27;s &quot;real&quot; CR3, which causes
	 * nested_vmx_restore_host_state() to corrupt vcpu-&gt;arch.cr3.  Stuffing
	 * vmcs01.GUEST_CR3 results in the unwind naturally setting arch.cr3 to
	 * the correct value.  Smashing vmcs01.GUEST_CR3 is safe because nested
	 * VM-Exits, and the unwind, reset KVM&#x27;s MMU, i.e. vmcs01.GUEST_CR3 is
	 * guaranteed to be overwritten with a shadow CR3 prior to re-entering
	 * L1.  Don&#x27;t stuff vmcs01.GUEST_CR3 when using nested early checks as
	 * KVM modifies vcpu-&gt;arch.cr3 if and only if the early hardware checks
	 * pass, and early VM-Fails do not reset KVM&#x27;s MMU, i.e. the VM-Fail
	 * path would need to manually save/restore vmcs01.GUEST_CR3.
	 */
<blue>	if (!enable_ept && !nested_early_check)</blue>
<yellow>		vmcs_writel(GUEST_CR3, vcpu->arch.cr3);</yellow>

<blue>	vmx_switch_vmcs(vcpu, &vmx->nested.vmcs02);</blue>

	prepare_vmcs02_early(vmx, &amp;vmx-&gt;vmcs01, vmcs12);

	if (from_vmentry) {
<blue>		if (unlikely(!nested_get_vmcs12_pages(vcpu))) {</blue>
<blue>			vmx_switch_vmcs(vcpu, &vmx->vmcs01);</blue>
			return NVMX_VMENTRY_KVM_INTERNAL_ERROR;
		}

<blue>		if (nested_vmx_check_vmentry_hw(vcpu)) {</blue>
<blue>			vmx_switch_vmcs(vcpu, &vmx->vmcs01);</blue>
			return NVMX_VMENTRY_VMFAIL;
		}

<blue>		if (nested_vmx_check_guest_state(vcpu, vmcs12,</blue>
						 &amp;entry_failure_code)) {
			exit_reason.basic = EXIT_REASON_INVALID_STATE;
<blue>			vmcs12->exit_qualification = entry_failure_code;</blue>
			goto vmentry_fail_vmexit;
		}
	}

<blue>	enter_guest_mode(vcpu);</blue>

<blue>	if (prepare_vmcs02(vcpu, vmcs12, from_vmentry, &entry_failure_code)) {</blue>
		exit_reason.basic = EXIT_REASON_INVALID_STATE;
<blue>		vmcs12->exit_qualification = entry_failure_code;</blue>
		goto vmentry_fail_vmexit_guest_mode;
	}

<blue>	if (from_vmentry) {</blue>
<blue>		failed_index = nested_vmx_load_msr(vcpu,</blue>
						   vmcs12-&gt;vm_entry_msr_load_addr,
						   vmcs12-&gt;vm_entry_msr_load_count);
		if (failed_index) {
<blue>			exit_reason.basic = EXIT_REASON_MSR_LOAD_FAIL;</blue>
			vmcs12-&gt;exit_qualification = failed_index;
			goto vmentry_fail_vmexit_guest_mode;
		}
	} else {
		/*
		 * The MMU is not initialized to point at the right entities yet and
		 * &quot;get pages&quot; would need to read data from the guest (i.e. we will
		 * need to perform gpa to hpa translation). Request a call
		 * to nested_get_vmcs12_pages before the next VM-entry.  The MSRs
		 * have already been set at vmentry time and should not be reset.
		 */
<yellow>		kvm_make_request(KVM_REQ_GET_NESTED_STATE_PAGES, vcpu);</yellow>
	}

	/*
	 * Re-evaluate pending events if L1 had a pending IRQ/NMI/INIT/SIPI
	 * when it executed VMLAUNCH/VMRESUME, as entering non-root mode can
	 * effectively unblock various events, e.g. INIT/SIPI cause VM-Exit
	 * unconditionally.
	 */
<blue>	if (unlikely(evaluate_pending_interrupts))</blue>
<yellow>		kvm_make_request(KVM_REQ_EVENT, vcpu);</yellow>

	/*
	 * Do not start the preemption timer hrtimer until after we know
	 * we are successful, so that only nested_vmx_vmexit needs to cancel
	 * the timer.
	 */
<blue>	vmx->nested.preemption_timer_expired = false;</blue>
	if (nested_cpu_has_preemption_timer(vmcs12)) {
<blue>		u64 timer_value = vmx_calc_preemption_timer_value(vcpu);</blue>
<blue>		vmx_start_preemption_timer(vcpu, timer_value);</blue>
	}

	/*
	 * Note no nested_vmx_succeed or nested_vmx_fail here. At this point
	 * we are no longer running L1, and VMLAUNCH/VMRESUME has not yet
	 * returned as far as L1 is concerned. It will only return (and set
	 * the success flag) when L2 exits (see nested_vmx_vmexit()).
	 */
	return NVMX_VMENTRY_SUCCESS;

	/*
	 * A failed consistency check that leads to a VMExit during L1&#x27;s
	 * VMEnter to L2 is a variation of a normal VMexit, as explained in
	 * 26.7 &quot;VM-entry failures during or after loading guest state&quot;.
	 */
vmentry_fail_vmexit_guest_mode:
	if (vmcs12-&gt;cpu_based_vm_exec_control &amp; CPU_BASED_USE_TSC_OFFSETTING)
<blue>		vcpu->arch.tsc_offset -= vmcs12->tsc_offset;</blue>
<blue>	leave_guest_mode(vcpu);</blue>

vmentry_fail_vmexit:
	vmx_switch_vmcs(vcpu, &amp;vmx-&gt;vmcs01);

	if (!from_vmentry)
		return NVMX_VMENTRY_VMEXIT;

<blue>	load_vmcs12_host_state(vcpu, vmcs12);</blue>
	vmcs12-&gt;vm_exit_reason = exit_reason.full;
<blue>	if (enable_shadow_vmcs || evmptr_is_valid(vmx->nested.hv_evmcs_vmptr))</blue>
<blue>		vmx->nested.need_vmcs12_to_shadow_sync = true;</blue>
	return NVMX_VMENTRY_VMEXIT;
}

/*
 * nested_vmx_run() handles a nested entry, i.e., a VMLAUNCH or VMRESUME on L1
 * for running an L2 nested guest.
 */
static int nested_vmx_run(struct kvm_vcpu *vcpu, bool launch)
{
	struct vmcs12 *vmcs12;
	enum nvmx_vmentry_status status;
	struct vcpu_vmx *vmx = to_vmx(vcpu);
<blue>	u32 interrupt_shadow = vmx_get_interrupt_shadow(vcpu);</blue>
	enum nested_evmptrld_status evmptrld_status;

	if (!nested_vmx_check_permission(vcpu))
		return 1;

<blue>	evmptrld_status = nested_vmx_handle_enlightened_vmptrld(vcpu, launch);</blue>
	if (evmptrld_status == EVMPTRLD_ERROR) {
<yellow>		kvm_queue_exception(vcpu, UD_VECTOR);</yellow>
		return 1;
	}

<blue>	kvm_pmu_trigger_event(vcpu, PERF_COUNT_HW_BRANCH_INSTRUCTIONS);</blue>

<yellow>	if (CC(evmptrld_status == EVMPTRLD_VMFAIL))</yellow>
		return nested_vmx_failInvalid(vcpu);

<blue>	if (CC(!evmptr_is_valid(vmx->nested.hv_evmcs_vmptr) &&</blue>
	       vmx-&gt;nested.current_vmptr == INVALID_GPA))
		return nested_vmx_failInvalid(vcpu);

<blue>	vmcs12 = get_vmcs12(vcpu);</blue>

	/*
	 * Can&#x27;t VMLAUNCH or VMRESUME a shadow VMCS. Despite the fact
	 * that there *is* a valid VMCS pointer, RFLAGS.CF is set
	 * rather than RFLAGS.ZF, and no error number is stored to the
	 * VM-instruction error field.
	 */
<yellow>	if (CC(vmcs12->hdr.shadow_vmcs))</yellow>
<blue>		return nested_vmx_failInvalid(vcpu);</blue>

	if (evmptr_is_valid(vmx-&gt;nested.hv_evmcs_vmptr)) {
<yellow>		copy_enlightened_to_vmcs12(vmx, vmx->nested.hv_evmcs->hv_clean_fields);</yellow>
		/* Enlightened VMCS doesn&#x27;t have launch state */
		vmcs12-&gt;launch_state = !launch;
<blue>	} else if (enable_shadow_vmcs) {</blue>
<blue>		copy_shadow_to_vmcs12(vmx);</blue>
	}

	/*
	 * The nested entry process starts with enforcing various prerequisites
	 * on vmcs12 as required by the Intel SDM, and act appropriately when
	 * they fail: As the SDM explains, some conditions should cause the
	 * instruction to fail, while others will cause the instruction to seem
	 * to succeed, but return an EXIT_REASON_INVALID_STATE.
	 * To speed up the normal (success) code path, we should avoid checking
	 * for misconfigurations which will anyway be caught by the processor
	 * when using the merged vmcs02.
	 */
<blue>	if (CC(interrupt_shadow & KVM_X86_SHADOW_INT_MOV_SS))</blue>
<yellow>		return nested_vmx_fail(vcpu, VMXERR_ENTRY_EVENTS_BLOCKED_BY_MOV_SS);</yellow>

<blue>	if (CC(vmcs12->launch_state == launch))</blue>
		return nested_vmx_fail(vcpu,
			launch ? VMXERR_VMLAUNCH_NONCLEAR_VMCS
			       : VMXERR_VMRESUME_NONLAUNCHED_VMCS);

<blue>	if (nested_vmx_check_controls(vcpu, vmcs12))</blue>
		return nested_vmx_fail(vcpu, VMXERR_ENTRY_INVALID_CONTROL_FIELD);

<blue>	if (nested_vmx_check_address_space_size(vcpu, vmcs12))</blue>
		return nested_vmx_fail(vcpu, VMXERR_ENTRY_INVALID_HOST_STATE_FIELD);

<blue>	if (nested_vmx_check_host_state(vcpu, vmcs12))</blue>
<blue>		return nested_vmx_fail(vcpu, VMXERR_ENTRY_INVALID_HOST_STATE_FIELD);</blue>

	/*
	 * We&#x27;re finally done with prerequisite checking, and can start with
	 * the nested entry.
	 */
<blue>	vmx->nested.nested_run_pending = 1;</blue>
	vmx-&gt;nested.has_preemption_timer_deadline = false;
	status = nested_vmx_enter_non_root_mode(vcpu, true);
	if (unlikely(status != NVMX_VMENTRY_SUCCESS))
		goto vmentry_failed;

	/* Emulate processing of posted interrupts on VM-Enter. */
<blue>	if (nested_cpu_has_posted_intr(vmcs12) &&</blue>
<blue>	    kvm_apic_has_interrupt(vcpu) == vmx->nested.posted_intr_nv) {</blue>
<yellow>		vmx->nested.pi_pending = true;</yellow>
		kvm_make_request(KVM_REQ_EVENT, vcpu);
		kvm_apic_clear_irr(vcpu, vmx-&gt;nested.posted_intr_nv);
	}

	/* Hide L1D cache contents from the nested guest.  */
<blue>	vmx->vcpu.arch.l1tf_flush_l1d = true;</blue>

	/*
	 * Must happen outside of nested_vmx_enter_non_root_mode() as it will
	 * also be used as part of restoring nVMX state for
	 * snapshot restore (migration).
	 *
	 * In this flow, it is assumed that vmcs12 cache was
	 * transferred as part of captured nVMX state and should
	 * therefore not be read from guest memory (which may not
	 * exist on destination host yet).
	 */
<blue>	nested_cache_shadow_vmcs12(vcpu, vmcs12);</blue>

<blue>	switch (vmcs12->guest_activity_state) {</blue>
	case GUEST_ACTIVITY_HLT:
		/*
		 * If we&#x27;re entering a halted L2 vcpu and the L2 vcpu won&#x27;t be
		 * awakened by event injection or by an NMI-window VM-exit or
		 * by an interrupt-window VM-exit, halt the vcpu.
		 */
<blue>		if (!(vmcs12->vm_entry_intr_info_field & INTR_INFO_VALID_MASK) &&</blue>
<blue>		    !nested_cpu_has(vmcs12, CPU_BASED_NMI_WINDOW_EXITING) &&</blue>
<blue>		    !(nested_cpu_has(vmcs12, CPU_BASED_INTR_WINDOW_EXITING) &&</blue>
<blue>		      (vmcs12->guest_rflags & X86_EFLAGS_IF))) {</blue>
<blue>			vmx->nested.nested_run_pending = 0;</blue>
			return kvm_emulate_halt_noskip(vcpu);
		}
		break;
	case GUEST_ACTIVITY_WAIT_SIPI:
<blue>		vmx->nested.nested_run_pending = 0;</blue>
		vcpu-&gt;arch.mp_state = KVM_MP_STATE_INIT_RECEIVED;
		break;
	default:
		break;
	}

	return 1;

vmentry_failed:
<blue>	vmx->nested.nested_run_pending = 0;</blue>
	if (status == NVMX_VMENTRY_KVM_INTERNAL_ERROR)
		return 0;
<blue>	if (status == NVMX_VMENTRY_VMEXIT)</blue>
		return 1;
<blue>	WARN_ON_ONCE(status != NVMX_VMENTRY_VMFAIL);</blue>
<blue>	return nested_vmx_fail(vcpu, VMXERR_ENTRY_INVALID_CONTROL_FIELD);</blue>
<blue>}</blue>

/*
 * On a nested exit from L2 to L1, vmcs12.guest_cr0 might not be up-to-date
 * because L2 may have changed some cr0 bits directly (CR0_GUEST_HOST_MASK).
 * This function returns the new value we should put in vmcs12.guest_cr0.
 * It&#x27;s not enough to just return the vmcs02 GUEST_CR0. Rather,
 *  1. Bits that neither L0 nor L1 trapped, were set directly by L2 and are now
 *     available in vmcs02 GUEST_CR0. (Note: It&#x27;s enough to check that L0
 *     didn&#x27;t trap the bit, because if L1 did, so would L0).
 *  2. Bits that L1 asked to trap (and therefore L0 also did) could not have
 *     been modified by L2, and L1 knows it. So just leave the old value of
 *     the bit from vmcs12.guest_cr0. Note that the bit from vmcs02 GUEST_CR0
 *     isn&#x27;t relevant, because if L0 traps this bit it can set it to anything.
 *  3. Bits that L1 didn&#x27;t trap, but L0 did. L1 believes the guest could have
 *     changed these bits, and therefore they need to be updated, but L0
 *     didn&#x27;t necessarily allow them to be changed in GUEST_CR0 - and rather
 *     put them in vmcs02 CR0_READ_SHADOW. So take these bits from there.
 */
static inline unsigned long
vmcs12_guest_cr0(struct kvm_vcpu *vcpu, struct vmcs12 *vmcs12)
{
	return
<blue>	/*1*/	(vmcs_readl(GUEST_CR0) & vcpu->arch.cr0_guest_owned_bits) |</blue>
	/*2*/	(vmcs12-&gt;guest_cr0 &amp; vmcs12-&gt;cr0_guest_host_mask) |
<blue>	/*3*/	(vmcs_readl(CR0_READ_SHADOW) & ~(vmcs12->cr0_guest_host_mask |</blue>
			vcpu-&gt;arch.cr0_guest_owned_bits));
}

static inline unsigned long
vmcs12_guest_cr4(struct kvm_vcpu *vcpu, struct vmcs12 *vmcs12)
{
	return
<blue>	/*1*/	(vmcs_readl(GUEST_CR4) & vcpu->arch.cr4_guest_owned_bits) |</blue>
	/*2*/	(vmcs12-&gt;guest_cr4 &amp; vmcs12-&gt;cr4_guest_host_mask) |
<blue>	/*3*/	(vmcs_readl(CR4_READ_SHADOW) & ~(vmcs12->cr4_guest_host_mask |</blue>
			vcpu-&gt;arch.cr4_guest_owned_bits));
}

static void vmcs12_save_pending_event(struct kvm_vcpu *vcpu,
				      struct vmcs12 *vmcs12,
				      u32 vm_exit_reason, u32 exit_intr_info)
{
	u32 idt_vectoring;
	unsigned int nr;

	/*
	 * Per the SDM, VM-Exits due to double and triple faults are never
	 * considered to occur during event delivery, even if the double/triple
	 * fault is the result of an escalating vectoring issue.
	 *
	 * Note, the SDM qualifies the double fault behavior with &quot;The original
	 * event results in a double-fault exception&quot;.  It&#x27;s unclear why the
	 * qualification exists since exits due to double fault can occur only
	 * while vectoring a different exception (injected events are never
	 * subject to interception), i.e. there&#x27;s _always_ an original event.
	 *
	 * The SDM also uses NMI as a confusing example for the &quot;original event
	 * causes the VM exit directly&quot; clause.  NMI isn&#x27;t special in any way,
	 * the same rule applies to all events that cause an exit directly.
	 * NMI is an odd choice for the example because NMIs can only occur on
	 * instruction boundaries, i.e. they _can&#x27;t_ occur during vectoring.
	 */
<blue>	if ((u16)vm_exit_reason == EXIT_REASON_TRIPLE_FAULT ||</blue>
	    ((u16)vm_exit_reason == EXIT_REASON_EXCEPTION_NMI &amp;&amp;
<blue>	     is_double_fault(exit_intr_info))) {</blue>
<blue>		vmcs12->idt_vectoring_info_field = 0;</blue>
<blue>	} else if (vcpu->arch.exception.injected) {</blue>
<blue>		nr = vcpu->arch.exception.vector;</blue>
		idt_vectoring = nr | VECTORING_INFO_VALID_MASK;

		if (kvm_exception_is_soft(nr)) {
			vmcs12-&gt;vm_exit_instruction_len =
<blue>				vcpu->arch.event_exit_inst_len;</blue>
			idt_vectoring |= INTR_TYPE_SOFT_EXCEPTION;
		} else
<blue>			idt_vectoring |= INTR_TYPE_HARD_EXCEPTION;</blue>

<blue>		if (vcpu->arch.exception.has_error_code) {</blue>
			idt_vectoring |= VECTORING_INFO_DELIVER_CODE_MASK;
			vmcs12-&gt;idt_vectoring_error_code =
<blue>				vcpu->arch.exception.error_code;</blue>
		}

		vmcs12-&gt;idt_vectoring_info_field = idt_vectoring;
<blue>	} else if (vcpu->arch.nmi_injected) {</blue>
		vmcs12-&gt;idt_vectoring_info_field =
			INTR_TYPE_NMI_INTR | INTR_INFO_VALID_MASK | NMI_VECTOR;
<blue>	} else if (vcpu->arch.interrupt.injected) {</blue>
<blue>		nr = vcpu->arch.interrupt.nr;</blue>
<blue>		idt_vectoring = nr | VECTORING_INFO_VALID_MASK;</blue>

<blue>		if (vcpu->arch.interrupt.soft) {</blue>
			idt_vectoring |= INTR_TYPE_SOFT_INTR;
			vmcs12-&gt;vm_entry_instruction_len =
<blue>				vcpu->arch.event_exit_inst_len;</blue>
		} else
			idt_vectoring |= INTR_TYPE_EXT_INTR;

		vmcs12-&gt;idt_vectoring_info_field = idt_vectoring;
	} else {
		vmcs12-&gt;idt_vectoring_info_field = 0;
	}
}


void nested_mark_vmcs12_pages_dirty(struct kvm_vcpu *vcpu)
{
<blue>	struct vmcs12 *vmcs12 = get_vmcs12(vcpu);</blue>
	gfn_t gfn;

	/*
	 * Don&#x27;t need to mark the APIC access page dirty; it is never
	 * written to by the CPU during APIC virtualization.
	 */

	if (nested_cpu_has(vmcs12, CPU_BASED_TPR_SHADOW)) {
<blue>		gfn = vmcs12->virtual_apic_page_addr >> PAGE_SHIFT;</blue>
		kvm_vcpu_mark_page_dirty(vcpu, gfn);
	}

<blue>	if (nested_cpu_has_posted_intr(vmcs12)) {</blue>
<blue>		gfn = vmcs12->posted_intr_desc_addr >> PAGE_SHIFT;</blue>
		kvm_vcpu_mark_page_dirty(vcpu, gfn);
	}
<blue>}</blue>

static int vmx_complete_nested_posted_interrupt(struct kvm_vcpu *vcpu)
{
	struct vcpu_vmx *vmx = to_vmx(vcpu);
	int max_irr;
	void *vapic_page;
	u16 status;

<blue>	if (!vmx->nested.pi_pending)</blue>
		return 0;

<yellow>	if (!vmx->nested.pi_desc)</yellow>
		goto mmio_needed;

<yellow>	vmx->nested.pi_pending = false;</yellow>

	if (!pi_test_and_clear_on(vmx-&gt;nested.pi_desc))
		return 0;

<yellow>	max_irr = find_last_bit((unsigned long *)vmx->nested.pi_desc->pir, 256);</yellow>
	if (max_irr != 256) {
<yellow>		vapic_page = vmx->nested.virtual_apic_map.hva;</yellow>
		if (!vapic_page)
			goto mmio_needed;

<yellow>		__kvm_apic_update_irr(vmx->nested.pi_desc->pir,</yellow>
			vapic_page, &amp;max_irr);
<yellow>		status = vmcs_read16(GUEST_INTR_STATUS);</yellow>
<yellow>		if ((u8)max_irr > ((u8)status & 0xff)) {</yellow>
<yellow>			status &= ~0xff;</yellow>
			status |= (u8)max_irr;
<yellow>			vmcs_write16(GUEST_INTR_STATUS, status);</yellow>
		}
	}

<yellow>	nested_mark_vmcs12_pages_dirty(vcpu);</yellow>
	return 0;

mmio_needed:
<yellow>	kvm_handle_memory_failure(vcpu, X86EMUL_IO_NEEDED, NULL);</yellow>
	return -ENXIO;
}

static void nested_vmx_inject_exception_vmexit(struct kvm_vcpu *vcpu)
{
	struct kvm_queued_exception *ex = &amp;vcpu-&gt;arch.exception_vmexit;
<blue>	u32 intr_info = ex->vector | INTR_INFO_VALID_MASK;</blue>
	struct vmcs12 *vmcs12 = get_vmcs12(vcpu);
	unsigned long exit_qual;

<blue>	if (ex->has_payload) {</blue>
<blue>		exit_qual = ex->payload;</blue>
<blue>	} else if (ex->vector == PF_VECTOR) {</blue>
<yellow>		exit_qual = vcpu->arch.cr2;</yellow>
<blue>	} else if (ex->vector == DB_VECTOR) {</blue>
<yellow>		exit_qual = vcpu->arch.dr6;</yellow>
		exit_qual &amp;= ~DR6_BT;
		exit_qual ^= DR6_ACTIVE_LOW;
	} else {
		exit_qual = 0;
	}

<blue>	if (ex->has_error_code) {</blue>
		/*
		 * Intel CPUs do not generate error codes with bits 31:16 set,
		 * and more importantly VMX disallows setting bits 31:16 in the
		 * injected error code for VM-Entry.  Drop the bits to mimic
		 * hardware and avoid inducing failure on nested VM-Entry if L1
		 * chooses to inject the exception back to L2.  AMD CPUs _do_
		 * generate &quot;full&quot; 32-bit error codes, so KVM allows userspace
		 * to inject exception error codes with bits 31:16 set.
		 */
<blue>		vmcs12->vm_exit_intr_error_code = (u16)ex->error_code;</blue>
		intr_info |= INTR_INFO_DELIVER_CODE_MASK;
	}

<blue>	if (kvm_exception_is_soft(ex->vector))</blue>
<yellow>		intr_info |= INTR_TYPE_SOFT_EXCEPTION;</yellow>
	else
<blue>		intr_info |= INTR_TYPE_HARD_EXCEPTION;</blue>

<blue>	if (!(vmcs12->idt_vectoring_info_field & VECTORING_INFO_VALID_MASK) &&</blue>
<blue>	    vmx_get_nmi_mask(vcpu))</blue>
<blue>		intr_info |= INTR_INFO_UNBLOCK_NMI;</blue>

<blue>	nested_vmx_vmexit(vcpu, EXIT_REASON_EXCEPTION_NMI, intr_info, exit_qual);</blue>
}

/*
 * Returns true if a debug trap is (likely) pending delivery.  Infer the class
 * of a #DB (trap-like vs. fault-like) from the exception payload (to-be-DR6).
 * Using the payload is flawed because code breakpoints (fault-like) and data
 * breakpoints (trap-like) set the same bits in DR6 (breakpoint detected), i.e.
 * this will return false positives if a to-be-injected code breakpoint #DB is
 * pending (from KVM&#x27;s perspective, but not &quot;pending&quot; across an instruction
 * boundary).  ICEBP, a.k.a. INT1, is also not reflected here even though it
 * too is trap-like.
 *
 * KVM &quot;works&quot; despite these flaws as ICEBP isn&#x27;t currently supported by the
 * emulator, Monitor Trap Flag is not marked pending on intercepted #DBs (the
 * #DB has already happened), and MTF isn&#x27;t marked pending on code breakpoints
 * from the emulator (because such #DBs are fault-like and thus don&#x27;t trigger
 * actions that fire on instruction retire).
 */
static unsigned long vmx_get_pending_dbg_trap(struct kvm_queued_exception *ex)
{
<blue>	if (!ex->pending || ex->vector != DB_VECTOR)</blue>
		return 0;

	/* General Detect #DBs are always fault-like. */
<blue>	return ex->payload & ~DR6_BD;</blue>
}

/*
 * Returns true if there&#x27;s a pending #DB exception that is lower priority than
 * a pending Monitor Trap Flag VM-Exit.  TSS T-flag #DBs are not emulated by
 * KVM, but could theoretically be injected by userspace.  Note, this code is
 * imperfect, see above.
 */
static bool vmx_is_low_priority_db_trap(struct kvm_queued_exception *ex)
{
<blue>	return vmx_get_pending_dbg_trap(ex) & ~DR6_BT;</blue>
}

/*
 * Certain VM-exits set the &#x27;pending debug exceptions&#x27; field to indicate a
 * recognized #DB (data or single-step) that has yet to be delivered. Since KVM
 * represents these debug traps with a payload that is said to be compatible
 * with the &#x27;pending debug exceptions&#x27; field, write the payload to the VMCS
 * field if a VM-exit is delivered before the debug trap.
 */
static void nested_vmx_update_pending_dbg(struct kvm_vcpu *vcpu)
{
	unsigned long pending_dbg;

<yellow>	pending_dbg = vmx_get_pending_dbg_trap(&vcpu->arch.exception);</yellow>
	if (pending_dbg)
<yellow>		vmcs_writel(GUEST_PENDING_DBG_EXCEPTIONS, pending_dbg);</yellow>
<yellow>}</yellow>

static bool nested_vmx_preemption_timer_pending(struct kvm_vcpu *vcpu)
{
<blue>	return nested_cpu_has_preemption_timer(get_vmcs12(vcpu)) &&</blue>
<blue>	       to_vmx(vcpu)->nested.preemption_timer_expired;</blue>
}

static bool vmx_has_nested_events(struct kvm_vcpu *vcpu)
{
<blue>	return nested_vmx_preemption_timer_pending(vcpu) ||</blue>
<blue>	       to_vmx(vcpu)->nested.mtf_pending;</blue>
<blue>}</blue>

/*
 * Per the Intel SDM&#x27;s table &quot;Priority Among Concurrent Events&quot;, with minor
 * edits to fill in missing examples, e.g. #DB due to split-lock accesses,
 * and less minor edits to splice in the priority of VMX Non-Root specific
 * events, e.g. MTF and NMI/INTR-window exiting.
 *
 * 1 Hardware Reset and Machine Checks
 *	- RESET
 *	- Machine Check
 *
 * 2 Trap on Task Switch
 *	- T flag in TSS is set (on task switch)
 *
 * 3 External Hardware Interventions
 *	- FLUSH
 *	- STOPCLK
 *	- SMI
 *	- INIT
 *
 * 3.5 Monitor Trap Flag (MTF) VM-exit[1]
 *
 * 4 Traps on Previous Instruction
 *	- Breakpoints
 *	- Trap-class Debug Exceptions (#DB due to TF flag set, data/I-O
 *	  breakpoint, or #DB due to a split-lock access)
 *
 * 4.3	VMX-preemption timer expired VM-exit
 *
 * 4.6	NMI-window exiting VM-exit[2]
 *
 * 5 Nonmaskable Interrupts (NMI)
 *
 * 5.5 Interrupt-window exiting VM-exit and Virtual-interrupt delivery
 *
 * 6 Maskable Hardware Interrupts
 *
 * 7 Code Breakpoint Fault
 *
 * 8 Faults from Fetching Next Instruction
 *	- Code-Segment Limit Violation
 *	- Code Page Fault
 *	- Control protection exception (missing ENDBRANCH at target of indirect
 *					call or jump)
 *
 * 9 Faults from Decoding Next Instruction
 *	- Instruction length &gt; 15 bytes
 *	- Invalid Opcode
 *	- Coprocessor Not Available
 *
 *10 Faults on Executing Instruction
 *	- Overflow
 *	- Bound error
 *	- Invalid TSS
 *	- Segment Not Present
 *	- Stack fault
 *	- General Protection
 *	- Data Page Fault
 *	- Alignment Check
 *	- x86 FPU Floating-point exception
 *	- SIMD floating-point exception
 *	- Virtualization exception
 *	- Control protection exception
 *
 * [1] Per the &quot;Monitor Trap Flag&quot; section: System-management interrupts (SMIs),
 *     INIT signals, and higher priority events take priority over MTF VM exits.
 *     MTF VM exits take priority over debug-trap exceptions and lower priority
 *     events.
 *
 * [2] Debug-trap exceptions and higher priority events take priority over VM exits
 *     caused by the VMX-preemption timer.  VM exits caused by the VMX-preemption
 *     timer take priority over VM exits caused by the &quot;NMI-window exiting&quot;
 *     VM-execution control and lower priority events.
 *
 * [3] Debug-trap exceptions and higher priority events take priority over VM exits
 *     caused by &quot;NMI-window exiting&quot;.  VM exits caused by this control take
 *     priority over non-maskable interrupts (NMIs) and lower priority events.
 *
 * [4] Virtual-interrupt delivery has the same priority as that of VM exits due to
 *     the 1-setting of the &quot;interrupt-window exiting&quot; VM-execution control.  Thus,
 *     non-maskable interrupts (NMIs) and higher priority events take priority over
 *     delivery of a virtual interrupt; delivery of a virtual interrupt takes
 *     priority over external interrupts and lower priority events.
 */
static int vmx_check_nested_events(struct kvm_vcpu *vcpu)
<blue>{</blue>
<blue>	struct kvm_lapic *apic = vcpu->arch.apic;</blue>
	struct vcpu_vmx *vmx = to_vmx(vcpu);
	/*
	 * Only a pending nested run blocks a pending exception.  If there is a
	 * previously injected event, the pending exception occurred while said
	 * event was being delivered and thus needs to be handled.
	 */
<blue>	bool block_nested_exceptions = vmx->nested.nested_run_pending;</blue>
	/*
	 * New events (not exceptions) are only recognized at instruction
	 * boundaries.  If an event needs reinjection, then KVM is handling a
	 * VM-Exit that occurred _during_ instruction execution; new events are
	 * blocked until the instruction completes.
	 */
<blue>	bool block_nested_events = block_nested_exceptions ||</blue>
<blue>				   kvm_event_needs_reinjection(vcpu);</blue>

<blue>	if (lapic_in_kernel(vcpu) &&</blue>
<blue>		test_bit(KVM_APIC_INIT, &apic->pending_events)) {</blue>
<yellow>		if (block_nested_events)</yellow>
			return -EBUSY;
<yellow>		nested_vmx_update_pending_dbg(vcpu);</yellow>
		clear_bit(KVM_APIC_INIT, &amp;apic-&gt;pending_events);
		if (vcpu-&gt;arch.mp_state != KVM_MP_STATE_INIT_RECEIVED)
<yellow>			nested_vmx_vmexit(vcpu, EXIT_REASON_INIT_SIGNAL, 0, 0);</yellow>

		/* MTF is discarded if the vCPU is in WFS. */
<yellow>		vmx->nested.mtf_pending = false;</yellow>
		return 0;
	}

<blue>	if (lapic_in_kernel(vcpu) &&</blue>
<blue>	    test_bit(KVM_APIC_SIPI, &apic->pending_events)) {</blue>
<yellow>		if (block_nested_events)</yellow>
			return -EBUSY;

<yellow>		clear_bit(KVM_APIC_SIPI, &apic->pending_events);</yellow>
		if (vcpu-&gt;arch.mp_state == KVM_MP_STATE_INIT_RECEIVED) {
			nested_vmx_vmexit(vcpu, EXIT_REASON_SIPI_SIGNAL, 0,
<yellow>						apic->sipi_vector & 0xFFUL);</yellow>
			return 0;
		}
		/* Fallthrough, the SIPI is completely ignored. */
	}

	/*
	 * Process exceptions that are higher priority than Monitor Trap Flag:
	 * fault-like exceptions, TSS T flag #DB (not emulated by KVM, but
	 * could theoretically come in from userspace), and ICEBP (INT1).
	 *
	 * TODO: SMIs have higher priority than MTF and trap-like #DBs (except
	 * for TSS T flag #DBs).  KVM also doesn&#x27;t save/restore pending MTF
	 * across SMI/RSM as it should; that needs to be addressed in order to
	 * prioritize SMI over MTF and trap-like #DBs.
	 */
<blue>	if (vcpu->arch.exception_vmexit.pending &&</blue>
<blue>	    !vmx_is_low_priority_db_trap(&vcpu->arch.exception_vmexit)) {</blue>
		if (block_nested_exceptions)
			return -EBUSY;

<blue>		nested_vmx_inject_exception_vmexit(vcpu);</blue>
		return 0;
	}

<blue>	if (vcpu->arch.exception.pending &&</blue>
<blue>	    !vmx_is_low_priority_db_trap(&vcpu->arch.exception)) {</blue>
		if (block_nested_exceptions)
			return -EBUSY;
		goto no_vmexit;
	}

<blue>	if (vmx->nested.mtf_pending) {</blue>
<yellow>		if (block_nested_events)</yellow>
			return -EBUSY;
<yellow>		nested_vmx_update_pending_dbg(vcpu);</yellow>
		nested_vmx_vmexit(vcpu, EXIT_REASON_MONITOR_TRAP_FLAG, 0, 0);
		return 0;
	}

<blue>	if (vcpu->arch.exception_vmexit.pending) {</blue>
<blue>		if (block_nested_exceptions)</blue>
			return -EBUSY;

		nested_vmx_inject_exception_vmexit(vcpu);
		return 0;
	}

<blue>	if (vcpu->arch.exception.pending) {</blue>
<blue>		if (block_nested_exceptions)</blue>
			return -EBUSY;
		goto no_vmexit;
	}

<blue>	if (nested_vmx_preemption_timer_pending(vcpu)) {</blue>
<blue>		if (block_nested_events)</blue>
			return -EBUSY;
<blue>		nested_vmx_vmexit(vcpu, EXIT_REASON_PREEMPTION_TIMER, 0, 0);</blue>
		return 0;
	}

<blue>	if (vcpu->arch.smi_pending && !is_smm(vcpu)) {</blue>
<yellow>		if (block_nested_events)</yellow>
			return -EBUSY;
		goto no_vmexit;
	}

<blue>	if (vcpu->arch.nmi_pending && !vmx_nmi_blocked(vcpu)) {</blue>
<yellow>		if (block_nested_events)</yellow>
			return -EBUSY;
<yellow>		if (!nested_exit_on_nmi(vcpu))</yellow>
			goto no_vmexit;

<yellow>		nested_vmx_vmexit(vcpu, EXIT_REASON_EXCEPTION_NMI,</yellow>
				  NMI_VECTOR | INTR_TYPE_NMI_INTR |
				  INTR_INFO_VALID_MASK, 0);
		/*
		 * The NMI-triggered VM exit counts as injection:
		 * clear this one and block further NMIs.
		 */
		vcpu-&gt;arch.nmi_pending = 0;
		vmx_set_nmi_mask(vcpu, true);
		return 0;
	}

<blue>	if (kvm_cpu_has_interrupt(vcpu) && !vmx_interrupt_blocked(vcpu)) {</blue>
<blue>		if (block_nested_events)</blue>
			return -EBUSY;
<blue>		if (!nested_exit_on_intr(vcpu))</blue>
			goto no_vmexit;
<blue>		nested_vmx_vmexit(vcpu, EXIT_REASON_EXTERNAL_INTERRUPT, 0, 0);</blue>
		return 0;
	}

no_vmexit:
<blue>	return vmx_complete_nested_posted_interrupt(vcpu);</blue>
}

static u32 vmx_get_preemption_timer_value(struct kvm_vcpu *vcpu)
{
	ktime_t remaining =
<blue>		hrtimer_get_remaining(&to_vmx(vcpu)->nested.preemption_timer);</blue>
	u64 value;

	if (ktime_to_ns(remaining) &lt;= 0)
		return 0;

<blue>	value = ktime_to_ns(remaining) * vcpu->arch.virtual_tsc_khz;</blue>
	do_div(value, 1000000);
	return value &gt;&gt; VMX_MISC_EMULATED_PREEMPTION_TIMER_RATE;
}

static bool is_vmcs12_ext_field(unsigned long field)
{
<blue>	switch (field) {</blue>
	case GUEST_ES_SELECTOR:
	case GUEST_CS_SELECTOR:
	case GUEST_SS_SELECTOR:
	case GUEST_DS_SELECTOR:
	case GUEST_FS_SELECTOR:
	case GUEST_GS_SELECTOR:
	case GUEST_LDTR_SELECTOR:
	case GUEST_TR_SELECTOR:
	case GUEST_ES_LIMIT:
	case GUEST_CS_LIMIT:
	case GUEST_SS_LIMIT:
	case GUEST_DS_LIMIT:
	case GUEST_FS_LIMIT:
	case GUEST_GS_LIMIT:
	case GUEST_LDTR_LIMIT:
	case GUEST_TR_LIMIT:
	case GUEST_GDTR_LIMIT:
	case GUEST_IDTR_LIMIT:
	case GUEST_ES_AR_BYTES:
	case GUEST_DS_AR_BYTES:
	case GUEST_FS_AR_BYTES:
	case GUEST_GS_AR_BYTES:
	case GUEST_LDTR_AR_BYTES:
	case GUEST_TR_AR_BYTES:
	case GUEST_ES_BASE:
	case GUEST_CS_BASE:
	case GUEST_SS_BASE:
	case GUEST_DS_BASE:
	case GUEST_FS_BASE:
	case GUEST_GS_BASE:
	case GUEST_LDTR_BASE:
	case GUEST_TR_BASE:
	case GUEST_GDTR_BASE:
	case GUEST_IDTR_BASE:
	case GUEST_PENDING_DBG_EXCEPTIONS:
	case GUEST_BNDCFGS:
		return true;
	default:
		break;
	}

	return false;
}

static void sync_vmcs02_to_vmcs12_rare(struct kvm_vcpu *vcpu,
				       struct vmcs12 *vmcs12)
{
	struct vcpu_vmx *vmx = to_vmx(vcpu);

<blue>	vmcs12->guest_es_selector = vmcs_read16(GUEST_ES_SELECTOR);</blue>
<blue>	vmcs12->guest_cs_selector = vmcs_read16(GUEST_CS_SELECTOR);</blue>
<blue>	vmcs12->guest_ss_selector = vmcs_read16(GUEST_SS_SELECTOR);</blue>
<blue>	vmcs12->guest_ds_selector = vmcs_read16(GUEST_DS_SELECTOR);</blue>
<blue>	vmcs12->guest_fs_selector = vmcs_read16(GUEST_FS_SELECTOR);</blue>
<blue>	vmcs12->guest_gs_selector = vmcs_read16(GUEST_GS_SELECTOR);</blue>
<blue>	vmcs12->guest_ldtr_selector = vmcs_read16(GUEST_LDTR_SELECTOR);</blue>
<blue>	vmcs12->guest_tr_selector = vmcs_read16(GUEST_TR_SELECTOR);</blue>
<blue>	vmcs12->guest_es_limit = vmcs_read32(GUEST_ES_LIMIT);</blue>
<blue>	vmcs12->guest_cs_limit = vmcs_read32(GUEST_CS_LIMIT);</blue>
<blue>	vmcs12->guest_ss_limit = vmcs_read32(GUEST_SS_LIMIT);</blue>
<blue>	vmcs12->guest_ds_limit = vmcs_read32(GUEST_DS_LIMIT);</blue>
<blue>	vmcs12->guest_fs_limit = vmcs_read32(GUEST_FS_LIMIT);</blue>
<blue>	vmcs12->guest_gs_limit = vmcs_read32(GUEST_GS_LIMIT);</blue>
<blue>	vmcs12->guest_ldtr_limit = vmcs_read32(GUEST_LDTR_LIMIT);</blue>
<blue>	vmcs12->guest_tr_limit = vmcs_read32(GUEST_TR_LIMIT);</blue>
<blue>	vmcs12->guest_gdtr_limit = vmcs_read32(GUEST_GDTR_LIMIT);</blue>
<blue>	vmcs12->guest_idtr_limit = vmcs_read32(GUEST_IDTR_LIMIT);</blue>
<blue>	vmcs12->guest_es_ar_bytes = vmcs_read32(GUEST_ES_AR_BYTES);</blue>
<blue>	vmcs12->guest_ds_ar_bytes = vmcs_read32(GUEST_DS_AR_BYTES);</blue>
<blue>	vmcs12->guest_fs_ar_bytes = vmcs_read32(GUEST_FS_AR_BYTES);</blue>
<blue>	vmcs12->guest_gs_ar_bytes = vmcs_read32(GUEST_GS_AR_BYTES);</blue>
<blue>	vmcs12->guest_ldtr_ar_bytes = vmcs_read32(GUEST_LDTR_AR_BYTES);</blue>
<blue>	vmcs12->guest_tr_ar_bytes = vmcs_read32(GUEST_TR_AR_BYTES);</blue>
<blue>	vmcs12->guest_es_base = vmcs_readl(GUEST_ES_BASE);</blue>
<blue>	vmcs12->guest_cs_base = vmcs_readl(GUEST_CS_BASE);</blue>
<blue>	vmcs12->guest_ss_base = vmcs_readl(GUEST_SS_BASE);</blue>
<blue>	vmcs12->guest_ds_base = vmcs_readl(GUEST_DS_BASE);</blue>
<blue>	vmcs12->guest_fs_base = vmcs_readl(GUEST_FS_BASE);</blue>
<blue>	vmcs12->guest_gs_base = vmcs_readl(GUEST_GS_BASE);</blue>
<blue>	vmcs12->guest_ldtr_base = vmcs_readl(GUEST_LDTR_BASE);</blue>
<blue>	vmcs12->guest_tr_base = vmcs_readl(GUEST_TR_BASE);</blue>
<blue>	vmcs12->guest_gdtr_base = vmcs_readl(GUEST_GDTR_BASE);</blue>
<blue>	vmcs12->guest_idtr_base = vmcs_readl(GUEST_IDTR_BASE);</blue>
<blue>	vmcs12->guest_pending_dbg_exceptions =</blue>
<blue>		vmcs_readl(GUEST_PENDING_DBG_EXCEPTIONS);</blue>

	vmx-&gt;nested.need_sync_vmcs02_to_vmcs12_rare = false;
}

static void copy_vmcs02_to_vmcs12_rare(struct kvm_vcpu *vcpu,
				       struct vmcs12 *vmcs12)
{
	struct vcpu_vmx *vmx = to_vmx(vcpu);
	int cpu;

<blue>	if (!vmx->nested.need_sync_vmcs02_to_vmcs12_rare)</blue>
		return;


<blue>	WARN_ON_ONCE(vmx->loaded_vmcs != &vmx->vmcs01);</blue>

<blue>	cpu = get_cpu();</blue>
	vmx-&gt;loaded_vmcs = &amp;vmx-&gt;nested.vmcs02;
	vmx_vcpu_load_vmcs(vcpu, cpu, &amp;vmx-&gt;vmcs01);

	sync_vmcs02_to_vmcs12_rare(vcpu, vmcs12);

	vmx-&gt;loaded_vmcs = &amp;vmx-&gt;vmcs01;
	vmx_vcpu_load_vmcs(vcpu, cpu, &amp;vmx-&gt;nested.vmcs02);
<blue>	put_cpu();</blue>
<blue>}</blue>

/*
 * Update the guest state fields of vmcs12 to reflect changes that
 * occurred while L2 was running. (The &quot;IA-32e mode guest&quot; bit of the
 * VM-entry controls is also updated, since this is really a guest
 * state bit.)
 */
static void sync_vmcs02_to_vmcs12(struct kvm_vcpu *vcpu, struct vmcs12 *vmcs12)
{
	struct vcpu_vmx *vmx = to_vmx(vcpu);

<blue>	if (evmptr_is_valid(vmx->nested.hv_evmcs_vmptr))</blue>
<yellow>		sync_vmcs02_to_vmcs12_rare(vcpu, vmcs12);</yellow>

	vmx-&gt;nested.need_sync_vmcs02_to_vmcs12_rare =
<blue>		!evmptr_is_valid(vmx->nested.hv_evmcs_vmptr);</blue>

<blue>	vmcs12->guest_cr0 = vmcs12_guest_cr0(vcpu, vmcs12);</blue>
<blue>	vmcs12->guest_cr4 = vmcs12_guest_cr4(vcpu, vmcs12);</blue>

<blue>	vmcs12->guest_rsp = kvm_rsp_read(vcpu);</blue>
<blue>	vmcs12->guest_rip = kvm_rip_read(vcpu);</blue>
<blue>	vmcs12->guest_rflags = vmcs_readl(GUEST_RFLAGS);</blue>

<blue>	vmcs12->guest_cs_ar_bytes = vmcs_read32(GUEST_CS_AR_BYTES);</blue>
<blue>	vmcs12->guest_ss_ar_bytes = vmcs_read32(GUEST_SS_AR_BYTES);</blue>

<blue>	vmcs12->guest_interruptibility_info =</blue>
<blue>		vmcs_read32(GUEST_INTERRUPTIBILITY_INFO);</blue>

	if (vcpu-&gt;arch.mp_state == KVM_MP_STATE_HALTED)
<blue>		vmcs12->guest_activity_state = GUEST_ACTIVITY_HLT;</blue>
<blue>	else if (vcpu->arch.mp_state == KVM_MP_STATE_INIT_RECEIVED)</blue>
		vmcs12-&gt;guest_activity_state = GUEST_ACTIVITY_WAIT_SIPI;
	else
		vmcs12-&gt;guest_activity_state = GUEST_ACTIVITY_ACTIVE;

	if (nested_cpu_has_preemption_timer(vmcs12) &amp;&amp;
<blue>	    vmcs12->vm_exit_controls & VM_EXIT_SAVE_VMX_PREEMPTION_TIMER &&</blue>
<blue>	    !vmx->nested.nested_run_pending)</blue>
<blue>		vmcs12->vmx_preemption_timer_value =</blue>
<blue>			vmx_get_preemption_timer_value(vcpu);</blue>

	/*
	 * In some cases (usually, nested EPT), L2 is allowed to change its
	 * own CR3 without exiting. If it has changed it, we must keep it.
	 * Of course, if L0 is using shadow page tables, GUEST_CR3 was defined
	 * by L0, not L1 or L2, so we mustn&#x27;t unconditionally copy it to vmcs12.
	 *
	 * Additionally, restore L2&#x27;s PDPTR to vmcs12.
	 */
<blue>	if (enable_ept) {</blue>
<blue>		vmcs12->guest_cr3 = vmcs_readl(GUEST_CR3);</blue>
<blue>		if (nested_cpu_has_ept(vmcs12) && is_pae_paging(vcpu)) {</blue>
<yellow>			vmcs12->guest_pdptr0 = vmcs_read64(GUEST_PDPTR0);</yellow>
<yellow>			vmcs12->guest_pdptr1 = vmcs_read64(GUEST_PDPTR1);</yellow>
<yellow>			vmcs12->guest_pdptr2 = vmcs_read64(GUEST_PDPTR2);</yellow>
<yellow>			vmcs12->guest_pdptr3 = vmcs_read64(GUEST_PDPTR3);</yellow>
		}
	}

<blue>	vmcs12->guest_linear_address = vmcs_readl(GUEST_LINEAR_ADDRESS);</blue>

<blue>	if (nested_cpu_has_vid(vmcs12))</blue>
<blue>		vmcs12->guest_intr_status = vmcs_read16(GUEST_INTR_STATUS);</blue>

	vmcs12-&gt;vm_entry_controls =
<blue>		(vmcs12->vm_entry_controls & ~VM_ENTRY_IA32E_MODE) |</blue>
		(vm_entry_controls_get(to_vmx(vcpu)) &amp; VM_ENTRY_IA32E_MODE);

	if (vmcs12-&gt;vm_exit_controls &amp; VM_EXIT_SAVE_DEBUG_CONTROLS)
<blue>		kvm_get_dr(vcpu, 7, (unsigned long *)&vmcs12->guest_dr7);</blue>

<blue>	if (vmcs12->vm_exit_controls & VM_EXIT_SAVE_IA32_EFER)</blue>
<blue>		vmcs12->guest_ia32_efer = vcpu->arch.efer;</blue>
<blue>}</blue>

/*
 * prepare_vmcs12 is part of what we need to do when the nested L2 guest exits
 * and we want to prepare to run its L1 parent. L1 keeps a vmcs for L2 (vmcs12),
 * and this function updates it to reflect the changes to the guest state while
 * L2 was running (and perhaps made some exits which were handled directly by L0
 * without going back to L1), and to reflect the exit reason.
 * Note that we do not have to copy here all VMCS fields, just those that
 * could have changed by the L2 guest or the exit - i.e., the guest-state and
 * exit-information fields only. Other fields are modified by L1 with VMWRITE,
 * which already writes to vmcs12 directly.
 */
static void prepare_vmcs12(struct kvm_vcpu *vcpu, struct vmcs12 *vmcs12,
			   u32 vm_exit_reason, u32 exit_intr_info,
			   unsigned long exit_qualification)
{
	/* update exit information fields: */
<blue>	vmcs12->vm_exit_reason = vm_exit_reason;</blue>
	if (to_vmx(vcpu)-&gt;exit_reason.enclave_mode)
<yellow>		vmcs12->vm_exit_reason |= VMX_EXIT_REASONS_SGX_ENCLAVE_MODE;</yellow>
<blue>	vmcs12->exit_qualification = exit_qualification;</blue>

	/*
	 * On VM-Exit due to a failed VM-Entry, the VMCS isn&#x27;t marked launched
	 * and only EXIT_REASON and EXIT_QUALIFICATION are updated, all other
	 * exit info fields are unmodified.
	 */
	if (!(vmcs12-&gt;vm_exit_reason &amp; VMX_EXIT_REASONS_FAILED_VMENTRY)) {
<blue>		vmcs12->launch_state = 1;</blue>

		/* vm_entry_intr_info_field is cleared on exit. Emulate this
		 * instead of reading the real value. */
		vmcs12-&gt;vm_entry_intr_info_field &amp;= ~INTR_INFO_VALID_MASK;

		/*
		 * Transfer the event that L0 or L1 may wanted to inject into
		 * L2 to IDT_VECTORING_INFO_FIELD.
		 */
<blue>		vmcs12_save_pending_event(vcpu, vmcs12,</blue>
					  vm_exit_reason, exit_intr_info);

		vmcs12-&gt;vm_exit_intr_info = exit_intr_info;
<blue>		vmcs12->vm_exit_instruction_len = vmcs_read32(VM_EXIT_INSTRUCTION_LEN);</blue>
<blue>		vmcs12->vmx_instruction_info = vmcs_read32(VMX_INSTRUCTION_INFO);</blue>

		/*
		 * According to spec, there&#x27;s no need to store the guest&#x27;s
		 * MSRs if the exit is due to a VM-entry failure that occurs
		 * during or after loading the guest state. Since this exit
		 * does not fall in that category, we need to save the MSRs.
		 */
<blue>		if (nested_vmx_store_msr(vcpu,</blue>
					 vmcs12-&gt;vm_exit_msr_store_addr,
					 vmcs12-&gt;vm_exit_msr_store_count))
<blue>			nested_vmx_abort(vcpu,</blue>
					 VMX_ABORT_SAVE_GUEST_MSR_FAIL);
	}
}

/*
 * A part of what we need to when the nested L2 guest exits and we want to
 * run its L1 parent, is to reset L1&#x27;s guest state to the host state specified
 * in vmcs12.
 * This function is to be called not only on normal nested exit, but also on
 * a nested entry failure, as explained in Intel&#x27;s spec, 3B.23.7 (&quot;VM-Entry
 * Failures During or After Loading Guest State&quot;).
 * This function should be called when the active VMCS is L1&#x27;s (vmcs01).
 */
static void load_vmcs12_host_state(struct kvm_vcpu *vcpu,
				   struct vmcs12 *vmcs12)
{
	enum vm_entry_failure_code ignored;
	struct kvm_segment seg;

<blue>	if (vmcs12->vm_exit_controls & VM_EXIT_LOAD_IA32_EFER)</blue>
<blue>		vcpu->arch.efer = vmcs12->host_ia32_efer;</blue>
<blue>	else if (vmcs12->vm_exit_controls & VM_EXIT_HOST_ADDR_SPACE_SIZE)</blue>
<blue>		vcpu->arch.efer |= (EFER_LMA | EFER_LME);</blue>
	else
<blue>		vcpu->arch.efer &= ~(EFER_LMA | EFER_LME);</blue>
	vmx_set_efer(vcpu, vcpu-&gt;arch.efer);

	kvm_rsp_write(vcpu, vmcs12-&gt;host_rsp);
	kvm_rip_write(vcpu, vmcs12-&gt;host_rip);
	vmx_set_rflags(vcpu, X86_EFLAGS_FIXED);
	vmx_set_interrupt_shadow(vcpu, 0);

	/*
	 * Note that calling vmx_set_cr0 is important, even if cr0 hasn&#x27;t
	 * actually changed, because vmx_set_cr0 refers to efer set above.
	 *
	 * CR0_GUEST_HOST_MASK is already set in the original vmcs01
	 * (KVM doesn&#x27;t change it);
	 */
	vcpu-&gt;arch.cr0_guest_owned_bits = KVM_POSSIBLE_CR0_GUEST_BITS;
	vmx_set_cr0(vcpu, vmcs12-&gt;host_cr0);

	/* Same as above - no reason to call set_cr4_guest_host_mask().  */
<blue>	vcpu->arch.cr4_guest_owned_bits = ~vmcs_readl(CR4_GUEST_HOST_MASK);</blue>
	vmx_set_cr4(vcpu, vmcs12-&gt;host_cr4);

	nested_ept_uninit_mmu_context(vcpu);

	/*
	 * Only PDPTE load can fail as the value of cr3 was checked on entry and
	 * couldn&#x27;t have changed.
	 */
	if (nested_vmx_load_cr3(vcpu, vmcs12-&gt;host_cr3, false, true, &amp;ignored))
<yellow>		nested_vmx_abort(vcpu, VMX_ABORT_LOAD_HOST_PDPTE_FAIL);</yellow>

<blue>	nested_vmx_transition_tlb_flush(vcpu, vmcs12, false);</blue>

<blue>	vmcs_write32(GUEST_SYSENTER_CS, vmcs12->host_ia32_sysenter_cs);</blue>
<blue>	vmcs_writel(GUEST_SYSENTER_ESP, vmcs12->host_ia32_sysenter_esp);</blue>
<blue>	vmcs_writel(GUEST_SYSENTER_EIP, vmcs12->host_ia32_sysenter_eip);</blue>
<blue>	vmcs_writel(GUEST_IDTR_BASE, vmcs12->host_idtr_base);</blue>
<blue>	vmcs_writel(GUEST_GDTR_BASE, vmcs12->host_gdtr_base);</blue>
<blue>	vmcs_write32(GUEST_IDTR_LIMIT, 0xFFFF);</blue>
<blue>	vmcs_write32(GUEST_GDTR_LIMIT, 0xFFFF);</blue>

	/* If not VM_EXIT_CLEAR_BNDCFGS, the L2 value propagates to L1.  */
<blue>	if (vmcs12->vm_exit_controls & VM_EXIT_CLEAR_BNDCFGS)</blue>
<yellow>		vmcs_write64(GUEST_BNDCFGS, 0);</yellow>

<blue>	if (vmcs12->vm_exit_controls & VM_EXIT_LOAD_IA32_PAT) {</blue>
<blue>		vmcs_write64(GUEST_IA32_PAT, vmcs12->host_ia32_pat);</blue>
<blue>		vcpu->arch.pat = vmcs12->host_ia32_pat;</blue>
	}
<blue>	if ((vmcs12->vm_exit_controls & VM_EXIT_LOAD_IA32_PERF_GLOBAL_CTRL) &&</blue>
<blue>	    intel_pmu_has_perf_global_ctrl(vcpu_to_pmu(vcpu)))</blue>
<blue>		WARN_ON_ONCE(kvm_set_msr(vcpu, MSR_CORE_PERF_GLOBAL_CTRL,</blue>
					 vmcs12-&gt;host_ia32_perf_global_ctrl));

	/* Set L1 segment info according to Intel SDM
	    27.5.2 Loading Host Segment and Descriptor-Table Registers */
	seg = (struct kvm_segment) {
		.base = 0,
		.limit = 0xFFFFFFFF,
<blue>		.selector = vmcs12->host_cs_selector,</blue>
		.type = 11,
		.present = 1,
		.s = 1,
		.g = 1
	};
<blue>	if (vmcs12->vm_exit_controls & VM_EXIT_HOST_ADDR_SPACE_SIZE)</blue>
<blue>		seg.l = 1;</blue>
	else
<yellow>		seg.db = 1;</yellow>
<blue>	__vmx_set_segment(vcpu, &seg, VCPU_SREG_CS);</blue>
	seg = (struct kvm_segment) {
		.base = 0,
		.limit = 0xFFFFFFFF,
		.type = 3,
		.present = 1,
		.s = 1,
		.db = 1,
		.g = 1
	};
	seg.selector = vmcs12-&gt;host_ds_selector;
	__vmx_set_segment(vcpu, &amp;seg, VCPU_SREG_DS);
	seg.selector = vmcs12-&gt;host_es_selector;
	__vmx_set_segment(vcpu, &amp;seg, VCPU_SREG_ES);
	seg.selector = vmcs12-&gt;host_ss_selector;
	__vmx_set_segment(vcpu, &amp;seg, VCPU_SREG_SS);
	seg.selector = vmcs12-&gt;host_fs_selector;
	seg.base = vmcs12-&gt;host_fs_base;
	__vmx_set_segment(vcpu, &amp;seg, VCPU_SREG_FS);
	seg.selector = vmcs12-&gt;host_gs_selector;
	seg.base = vmcs12-&gt;host_gs_base;
	__vmx_set_segment(vcpu, &amp;seg, VCPU_SREG_GS);
	seg = (struct kvm_segment) {
		.base = vmcs12-&gt;host_tr_base,
		.limit = 0x67,
		.selector = vmcs12-&gt;host_tr_selector,
		.type = 11,
		.present = 1
	};
	__vmx_set_segment(vcpu, &amp;seg, VCPU_SREG_TR);

	memset(&amp;seg, 0, sizeof(seg));
	seg.unusable = 1;
	__vmx_set_segment(vcpu, &amp;seg, VCPU_SREG_LDTR);

	kvm_set_dr(vcpu, 7, 0x400);
<blue>	vmcs_write64(GUEST_IA32_DEBUGCTL, 0);</blue>

<blue>	if (nested_vmx_load_msr(vcpu, vmcs12->vm_exit_msr_load_addr,</blue>
				vmcs12-&gt;vm_exit_msr_load_count))
<blue>		nested_vmx_abort(vcpu, VMX_ABORT_LOAD_HOST_MSR_FAIL);</blue>

<blue>	to_vmx(vcpu)->emulation_required = vmx_emulation_required(vcpu);</blue>
}

static inline u64 nested_vmx_get_vmcs01_guest_efer(struct vcpu_vmx *vmx)
{
	struct vmx_uret_msr *efer_msr;
	unsigned int i;

<blue>	if (vm_entry_controls_get(vmx) & VM_ENTRY_LOAD_IA32_EFER)</blue>
<blue>		return vmcs_read64(GUEST_IA32_EFER);</blue>

<yellow>	if (cpu_has_load_ia32_efer())</yellow>
<yellow>		return host_efer;</yellow>

<yellow>	for (i = 0; i < vmx->msr_autoload.guest.nr; ++i) {</yellow>
<yellow>		if (vmx->msr_autoload.guest.val[i].index == MSR_EFER)</yellow>
<yellow>			return vmx->msr_autoload.guest.val[i].value;</yellow>
	}

<yellow>	efer_msr = vmx_find_uret_msr(vmx, MSR_EFER);</yellow>
	if (efer_msr)
<yellow>		return efer_msr->data;</yellow>

<yellow>	return host_efer;</yellow>
}

static void nested_vmx_restore_host_state(struct kvm_vcpu *vcpu)
{
	struct vmcs12 *vmcs12 = get_vmcs12(vcpu);
	struct vcpu_vmx *vmx = to_vmx(vcpu);
	struct vmx_msr_entry g, h;
	gpa_t gpa;
	u32 i, j;

<blue>	vcpu->arch.pat = vmcs_read64(GUEST_IA32_PAT);</blue>

	if (vmcs12-&gt;vm_entry_controls &amp; VM_ENTRY_LOAD_DEBUG_CONTROLS) {
		/*
		 * L1&#x27;s host DR7 is lost if KVM_GUESTDBG_USE_HW_BP is set
		 * as vmcs01.GUEST_DR7 contains a userspace defined value
		 * and vcpu-&gt;arch.dr7 is not squirreled away before the
		 * nested VMENTER (not worth adding a variable in nested_vmx).
		 */
<blue>		if (vcpu->guest_debug & KVM_GUESTDBG_USE_HW_BP)</blue>
<yellow>			kvm_set_dr(vcpu, 7, DR7_FIXED_1);</yellow>
		else
<blue>			WARN_ON(kvm_set_dr(vcpu, 7, vmcs_readl(GUEST_DR7)));</blue>
	}

	/*
	 * Note that calling vmx_set_{efer,cr0,cr4} is important as they
	 * handle a variety of side effects to KVM&#x27;s software model.
	 */
<blue>	vmx_set_efer(vcpu, nested_vmx_get_vmcs01_guest_efer(vmx));</blue>

	vcpu-&gt;arch.cr0_guest_owned_bits = KVM_POSSIBLE_CR0_GUEST_BITS;
<blue>	vmx_set_cr0(vcpu, vmcs_readl(CR0_READ_SHADOW));</blue>

<blue>	vcpu->arch.cr4_guest_owned_bits = ~vmcs_readl(CR4_GUEST_HOST_MASK);</blue>
<blue>	vmx_set_cr4(vcpu, vmcs_readl(CR4_READ_SHADOW));</blue>

	nested_ept_uninit_mmu_context(vcpu);
<blue>	vcpu->arch.cr3 = vmcs_readl(GUEST_CR3);</blue>
<blue>	kvm_register_mark_available(vcpu, VCPU_EXREG_CR3);</blue>

	/*
	 * Use ept_save_pdptrs(vcpu) to load the MMU&#x27;s cached PDPTRs
	 * from vmcs01 (if necessary).  The PDPTRs are not loaded on
	 * VMFail, like everything else we just need to ensure our
	 * software model is up-to-date.
	 */
<blue>	if (enable_ept && is_pae_paging(vcpu))</blue>
<yellow>		ept_save_pdptrs(vcpu);</yellow>

	kvm_mmu_reset_context(vcpu);

	/*
	 * This nasty bit of open coding is a compromise between blindly
	 * loading L1&#x27;s MSRs using the exit load lists (incorrect emulation
	 * of VMFail), leaving the nested VM&#x27;s MSRs in the software model
	 * (incorrect behavior) and snapshotting the modified MSRs (too
	 * expensive since the lists are unbound by hardware).  For each
	 * MSR that was (prematurely) loaded from the nested VMEntry load
	 * list, reload it from the exit load list if it exists and differs
	 * from the guest value.  The intent is to stuff host state as
	 * silently as possible, not to fully process the exit load list.
	 */
<blue>	for (i = 0; i < vmcs12->vm_entry_msr_load_count; i++) {</blue>
<blue>		gpa = vmcs12->vm_entry_msr_load_addr + (i * sizeof(g));</blue>
		if (kvm_vcpu_read_guest(vcpu, gpa, &amp;g, sizeof(g))) {
<yellow>			pr_debug_ratelimited(</yellow>
				&quot;%s read MSR index failed (%u, 0x%08llx)\n&quot;,
				__func__, i, gpa);
			goto vmabort;
		}

<blue>		for (j = 0; j < vmcs12->vm_exit_msr_load_count; j++) {</blue>
<blue>			gpa = vmcs12->vm_exit_msr_load_addr + (j * sizeof(h));</blue>
			if (kvm_vcpu_read_guest(vcpu, gpa, &amp;h, sizeof(h))) {
<yellow>				pr_debug_ratelimited(</yellow>
					&quot;%s read MSR failed (%u, 0x%08llx)\n&quot;,
					__func__, j, gpa);
				goto vmabort;
			}
<blue>			if (h.index != g.index)</blue>
				continue;
<blue>			if (h.value == g.value)</blue>
				break;

<yellow>			if (nested_vmx_load_msr_check(vcpu, &h)) {</yellow>
<blue>				pr_debug_ratelimited(</blue>
					&quot;%s check failed (%u, 0x%x, 0x%x)\n&quot;,
					__func__, j, h.index, h.reserved);
				goto vmabort;
			}

<yellow>			if (kvm_set_msr(vcpu, h.index, h.value)) {</yellow>
<yellow>				pr_debug_ratelimited(</yellow>
					&quot;%s WRMSR failed (%u, 0x%x, 0x%llx)\n&quot;,
					__func__, j, h.index, h.value);
				goto vmabort;
			}
		}
	}

	return;

vmabort:
<yellow>	nested_vmx_abort(vcpu, VMX_ABORT_LOAD_HOST_MSR_FAIL);</yellow>
}

/*
 * Emulate an exit from nested guest (L2) to L1, i.e., prepare to run L1
 * and modify vmcs12 to make it see what it would expect to see there if
 * L2 was its real guest. Must only be called when in L2 (is_guest_mode())
 */
void nested_vmx_vmexit(struct kvm_vcpu *vcpu, u32 vm_exit_reason,
		       u32 exit_intr_info, unsigned long exit_qualification)
<blue>{</blue>
	struct vcpu_vmx *vmx = to_vmx(vcpu);
<blue>	struct vmcs12 *vmcs12 = get_vmcs12(vcpu);</blue>

	/* Pending MTF traps are discarded on VM-Exit. */
	vmx-&gt;nested.mtf_pending = false;

	/* trying to cancel vmlaunch/vmresume is a bug */
<blue>	WARN_ON_ONCE(vmx->nested.nested_run_pending);</blue>

<blue>	if (kvm_check_request(KVM_REQ_GET_NESTED_STATE_PAGES, vcpu)) {</blue>
		/*
		 * KVM_REQ_GET_NESTED_STATE_PAGES is also used to map
		 * Enlightened VMCS after migration and we still need to
		 * do that when something is forcing L2-&gt;L1 exit prior to
		 * the first L2 run.
		 */
<yellow>		(void)nested_get_evmcs_page(vcpu);</yellow>
	}

	/* Service pending TLB flush requests for L2 before switching to L1. */
<blue>	kvm_service_local_tlb_flush_requests(vcpu);</blue>

	/*
	 * VCPU_EXREG_PDPTR will be clobbered in arch/x86/kvm/vmx/vmx.h between
	 * now and the new vmentry.  Ensure that the VMCS02 PDPTR fields are
	 * up-to-date before switching to L1.
	 */
<blue>	if (enable_ept && is_pae_paging(vcpu))</blue>
<yellow>		vmx_ept_load_pdptrs(vcpu);</yellow>

<blue>	leave_guest_mode(vcpu);</blue>

	if (nested_cpu_has_preemption_timer(vmcs12))
<blue>		hrtimer_cancel(&to_vmx(vcpu)->nested.preemption_timer);</blue>

<blue>	if (nested_cpu_has(vmcs12, CPU_BASED_USE_TSC_OFFSETTING)) {</blue>
<blue>		vcpu->arch.tsc_offset = vcpu->arch.l1_tsc_offset;</blue>
<blue>		if (nested_cpu_has2(vmcs12, SECONDARY_EXEC_TSC_SCALING))</blue>
<blue>			vcpu->arch.tsc_scaling_ratio = vcpu->arch.l1_tsc_scaling_ratio;</blue>
	}

<blue>	if (likely(!vmx->fail)) {</blue>
<blue>		sync_vmcs02_to_vmcs12(vcpu, vmcs12);</blue>

		if (vm_exit_reason != -1)
<blue>			prepare_vmcs12(vcpu, vmcs12, vm_exit_reason,</blue>
				       exit_intr_info, exit_qualification);

		/*
		 * Must happen outside of sync_vmcs02_to_vmcs12() as it will
		 * also be used to capture vmcs12 cache as part of
		 * capturing nVMX state for snapshot (migration).
		 *
		 * Otherwise, this flush will dirty guest memory at a
		 * point it is already assumed by user-space to be
		 * immutable.
		 */
<blue>		nested_flush_cached_shadow_vmcs12(vcpu, vmcs12);</blue>
	} else {
		/*
		 * The only expected VM-instruction error is &quot;VM entry with
		 * invalid control field(s).&quot; Anything else indicates a
		 * problem with L0.  And we should never get here with a
		 * VMFail of any type if early consistency checks are enabled.
		 */
<blue>		WARN_ON_ONCE(vmcs_read32(VM_INSTRUCTION_ERROR) !=</blue>
			     VMXERR_ENTRY_INVALID_CONTROL_FIELD);
<blue>		WARN_ON_ONCE(nested_early_check);</blue>
	}

	/*
	 * Drop events/exceptions that were queued for re-injection to L2
	 * (picked up via vmx_complete_interrupts()), as well as exceptions
	 * that were pending for L2.  Note, this must NOT be hoisted above
	 * prepare_vmcs12(), events/exceptions queued for re-injection need to
	 * be captured in vmcs12 (see vmcs12_save_pending_event()).
	 */
<blue>	vcpu->arch.nmi_injected = false;</blue>
	kvm_clear_exception_queue(vcpu);
	kvm_clear_interrupt_queue(vcpu);

	vmx_switch_vmcs(vcpu, &amp;vmx-&gt;vmcs01);

	/* Update any VMCS fields that might have changed while L2 ran */
<blue>	vmcs_write32(VM_EXIT_MSR_LOAD_COUNT, vmx->msr_autoload.host.nr);</blue>
<blue>	vmcs_write32(VM_ENTRY_MSR_LOAD_COUNT, vmx->msr_autoload.guest.nr);</blue>
<blue>	vmcs_write64(TSC_OFFSET, vcpu->arch.tsc_offset);</blue>
<blue>	if (kvm_caps.has_tsc_control)</blue>
<blue>		vmcs_write64(TSC_MULTIPLIER, vcpu->arch.tsc_scaling_ratio);</blue>

<blue>	if (vmx->nested.l1_tpr_threshold != -1)</blue>
<yellow>		vmcs_write32(TPR_THRESHOLD, vmx->nested.l1_tpr_threshold);</yellow>

<blue>	if (vmx->nested.change_vmcs01_virtual_apic_mode) {</blue>
<yellow>		vmx->nested.change_vmcs01_virtual_apic_mode = false;</yellow>
		vmx_set_virtual_apic_mode(vcpu);
	}

<blue>	if (vmx->nested.update_vmcs01_cpu_dirty_logging) {</blue>
<yellow>		vmx->nested.update_vmcs01_cpu_dirty_logging = false;</yellow>
		vmx_update_cpu_dirty_logging(vcpu);
	}

	/* Unpin physical memory we referred to in vmcs02 */
<blue>	kvm_vcpu_unmap(vcpu, &vmx->nested.apic_access_page_map, false);</blue>
	kvm_vcpu_unmap(vcpu, &amp;vmx-&gt;nested.virtual_apic_map, true);
	kvm_vcpu_unmap(vcpu, &amp;vmx-&gt;nested.pi_desc_map, true);
	vmx-&gt;nested.pi_desc = NULL;

<blue>	if (vmx->nested.reload_vmcs01_apic_access_page) {</blue>
<blue>		vmx->nested.reload_vmcs01_apic_access_page = false;</blue>
		kvm_make_request(KVM_REQ_APIC_PAGE_RELOAD, vcpu);
	}

<blue>	if (vmx->nested.update_vmcs01_apicv_status) {</blue>
<yellow>		vmx->nested.update_vmcs01_apicv_status = false;</yellow>
		kvm_make_request(KVM_REQ_APICV_UPDATE, vcpu);
	}

<blue>	if ((vm_exit_reason != -1) &&</blue>
<blue>	    (enable_shadow_vmcs || evmptr_is_valid(vmx->nested.hv_evmcs_vmptr)))</blue>
<blue>		vmx->nested.need_vmcs12_to_shadow_sync = true;</blue>

	/* in case we halted in L2 */
<blue>	vcpu->arch.mp_state = KVM_MP_STATE_RUNNABLE;</blue>

	if (likely(!vmx-&gt;fail)) {
<blue>		if ((u16)vm_exit_reason == EXIT_REASON_EXTERNAL_INTERRUPT &&</blue>
<blue>		    nested_exit_intr_ack_set(vcpu)) {</blue>
<blue>			int irq = kvm_cpu_get_interrupt(vcpu);</blue>
<yellow>			WARN_ON(irq < 0);</yellow>
<blue>			vmcs12->vm_exit_intr_info = irq |</blue>
				INTR_INFO_VALID_MASK | INTR_TYPE_EXT_INTR;
		}

		if (vm_exit_reason != -1)
<blue>			trace_kvm_nested_vmexit_inject(vmcs12->vm_exit_reason,</blue>
						       vmcs12-&gt;exit_qualification,
						       vmcs12-&gt;idt_vectoring_info_field,
						       vmcs12-&gt;vm_exit_intr_info,
						       vmcs12-&gt;vm_exit_intr_error_code,
						       KVM_ISA_VMX);

<blue>		load_vmcs12_host_state(vcpu, vmcs12);</blue>

		return;
	}

	/*
	 * After an early L2 VM-entry failure, we&#x27;re now back
	 * in L1 which thinks it just finished a VMLAUNCH or
	 * VMRESUME instruction, so we need to set the failure
	 * flag and the VM-instruction error field of the VMCS
	 * accordingly, and skip the emulated instruction.
	 */
<blue>	(void)nested_vmx_fail(vcpu, VMXERR_ENTRY_INVALID_CONTROL_FIELD);</blue>

	/*
	 * Restore L1&#x27;s host state to KVM&#x27;s software model.  We&#x27;re here
	 * because a consistency check was caught by hardware, which
	 * means some amount of guest state has been propagated to KVM&#x27;s
	 * model and needs to be unwound to the host&#x27;s state.
	 */
<blue>	nested_vmx_restore_host_state(vcpu);</blue>

<blue>	vmx->fail = 0;</blue>
}

static void nested_vmx_triple_fault(struct kvm_vcpu *vcpu)
{
<yellow>	kvm_clear_request(KVM_REQ_TRIPLE_FAULT, vcpu);</yellow>
	nested_vmx_vmexit(vcpu, EXIT_REASON_TRIPLE_FAULT, 0, 0);
}

/*
 * Decode the memory-address operand of a vmx instruction, as recorded on an
 * exit caused by such an instruction (run by a guest hypervisor).
 * On success, returns 0. When the operand is invalid, returns 1 and throws
 * #UD, #GP, or #SS.
 */
int get_vmx_mem_address(struct kvm_vcpu *vcpu, unsigned long exit_qualification,
			u32 vmx_instruction_info, bool wr, int len, gva_t *ret)
<blue>{</blue>
	gva_t off;
	bool exn;
	struct kvm_segment s;

	/*
	 * According to Vol. 3B, &quot;Information for VM Exits Due to Instruction
	 * Execution&quot;, on an exit, vmx_instruction_info holds most of the
	 * addressing components of the operand. Only the displacement part
	 * is put in exit_qualification (see 3B, &quot;Basic VM-Exit Information&quot;).
	 * For how an actual address is calculated from all these components,
	 * refer to Vol. 1, &quot;Operand Addressing&quot;.
	 */
<yellow>	int  scaling = vmx_instruction_info & 3;</yellow>
	int  addr_size = (vmx_instruction_info &gt;&gt; 7) &amp; 7;
	bool is_reg = vmx_instruction_info &amp; (1u &lt;&lt; 10);
<blue>	int  seg_reg = (vmx_instruction_info >> 15) & 7;</blue>
<yellow>	int  index_reg = (vmx_instruction_info >> 18) & 0xf;</yellow>
	bool index_is_valid = !(vmx_instruction_info &amp; (1u &lt;&lt; 22));
<blue>	int  base_reg       = (vmx_instruction_info >> 23) & 0xf;</blue>
	bool base_is_valid  = !(vmx_instruction_info &amp; (1u &lt;&lt; 27));

	if (is_reg) {
<yellow>		kvm_queue_exception(vcpu, UD_VECTOR);</yellow>
		return 1;
	}

	/* Addr = segment_base + offset */
	/* offset = base + [index * scale] + displacement */
	off = exit_qualification; /* holds the displacement */
<blue>	if (addr_size == 1)</blue>
<yellow>		off = (gva_t)sign_extend64(off, 31);</yellow>
<blue>	else if (addr_size == 0)</blue>
<yellow>		off = (gva_t)sign_extend64(off, 15);</yellow>
<blue>	if (base_is_valid)</blue>
<blue>		off += kvm_register_read(vcpu, base_reg);</blue>
<blue>	if (index_is_valid)</blue>
<yellow>		off += kvm_register_read(vcpu, index_reg) << scaling;</yellow>
<blue>	vmx_get_segment(vcpu, &s, seg_reg);</blue>

	/*
	 * The effective address, i.e. @off, of a memory operand is truncated
	 * based on the address size of the instruction.  Note that this is
	 * the *effective address*, i.e. the address prior to accounting for
	 * the segment&#x27;s base.
	 */
	if (addr_size == 1) /* 32 bit */
<yellow>		off &= 0xffffffff;</yellow>
<blue>	else if (addr_size == 0) /* 16 bit */</blue>
<yellow>		off &= 0xffff;</yellow>

	/* Checks for #GP/#SS exceptions. */
	exn = false;
<blue>	if (is_long_mode(vcpu)) {</blue>
		/*
		 * The virtual/linear address is never truncated in 64-bit
		 * mode, e.g. a 32-bit address size can yield a 64-bit virtual
		 * address when using FS/GS with a non-zero base.
		 */
<blue>		if (seg_reg == VCPU_SREG_FS || seg_reg == VCPU_SREG_GS)</blue>
<blue>			*ret = s.base + off;</blue>
		else
			*ret = off;

		/* Long mode: #GP(0)/#SS(0) if the memory address is in a
		 * non-canonical form. This is the only check on the memory
		 * destination for long mode!
		 */
<blue>		exn = is_noncanonical_address(*ret, vcpu);</blue>
	} else {
		/*
		 * When not in long mode, the virtual/linear address is
		 * unconditionally truncated to 32 bits regardless of the
		 * address size.
		 */
<yellow>		*ret = (s.base + off) & 0xffffffff;</yellow>

		/* Protected mode: apply checks for segment validity in the
		 * following order:
		 * - segment type check (#GP(0) may be thrown)
		 * - usability check (#GP(0)/#SS(0))
		 * - limit check (#GP(0)/#SS(0))
		 */
		if (wr)
			/* #GP(0) if the destination operand is located in a
			 * read-only data segment or any code segment.
			 */
<yellow>			exn = ((s.type & 0xa) == 0 || (s.type & 8));</yellow>
		else
			/* #GP(0) if the source operand is located in an
			 * execute-only code segment
			 */
			exn = ((s.type &amp; 0xa) == 8);
<yellow>		if (exn) {</yellow>
<yellow>			kvm_queue_exception_e(vcpu, GP_VECTOR, 0);</yellow>
			return 1;
		}
		/* Protected mode: #GP(0)/#SS(0) if the segment is unusable.
		 */
		exn = (s.unusable != 0);

		/*
		 * Protected mode: #GP(0)/#SS(0) if the memory operand is
		 * outside the segment limit.  All CPUs that support VMX ignore
		 * limit checks for flat segments, i.e. segments with base==0,
		 * limit==0xffffffff and of type expand-up data or code.
		 */
<yellow>		if (!(s.base == 0 && s.limit == 0xffffffff &&</yellow>
		     ((s.type &amp; 8) || !(s.type &amp; 4))))
<yellow>			exn = exn || ((u64)off + len - 1 > s.limit);</yellow>
	}
<yellow>	if (exn) {</yellow>
<yellow>		kvm_queue_exception_e(vcpu,</yellow>
				      seg_reg == VCPU_SREG_SS ?
						SS_VECTOR : GP_VECTOR,
				      0);
		return 1;
	}

	return 0;
}

static int nested_vmx_get_vmptr(struct kvm_vcpu *vcpu, gpa_t *vmpointer,
				int *ret)
<blue>{</blue>
	gva_t gva;
	struct x86_exception e;
	int r;

<blue>	if (get_vmx_mem_address(vcpu, vmx_get_exit_qual(vcpu),</blue>
				vmcs_read32(VMX_INSTRUCTION_INFO), false,
				sizeof(*vmpointer), &amp;gva)) {
<yellow>		*ret = 1;</yellow>
		return -EINVAL;
	}

<blue>	r = kvm_read_guest_virt(vcpu, gva, vmpointer, sizeof(*vmpointer), &e);</blue>
	if (r != X86EMUL_CONTINUE) {
<yellow>		*ret = kvm_handle_memory_failure(vcpu, r, &e);</yellow>
		return -EINVAL;
	}

	return 0;
}

/*
 * Allocate a shadow VMCS and associate it with the currently loaded
 * VMCS, unless such a shadow VMCS already exists. The newly allocated
 * VMCS is also VMCLEARed, so that it is ready for use.
 */
static struct vmcs *alloc_shadow_vmcs(struct kvm_vcpu *vcpu)
{
	struct vcpu_vmx *vmx = to_vmx(vcpu);
<blue>	struct loaded_vmcs *loaded_vmcs = vmx->loaded_vmcs;</blue>

	/*
	 * KVM allocates a shadow VMCS only when L1 executes VMXON and frees it
	 * when L1 executes VMXOFF or the vCPU is forced out of nested
	 * operation.  VMXON faults if the CPU is already post-VMXON, so it
	 * should be impossible to already have an allocated shadow VMCS.  KVM
	 * doesn&#x27;t support virtualization of VMCS shadowing, so vmcs01 should
	 * always be the loaded VMCS.
	 */
<blue>	if (WARN_ON(loaded_vmcs != &vmx->vmcs01 || loaded_vmcs->shadow_vmcs))</blue>
		return loaded_vmcs-&gt;shadow_vmcs;

<blue>	loaded_vmcs->shadow_vmcs = alloc_vmcs(true);</blue>
	if (loaded_vmcs-&gt;shadow_vmcs)
<blue>		vmcs_clear(loaded_vmcs->shadow_vmcs);</blue>

	return loaded_vmcs-&gt;shadow_vmcs;
}

static int enter_vmx_operation(struct kvm_vcpu *vcpu)
<blue>{</blue>
	struct vcpu_vmx *vmx = to_vmx(vcpu);
	int r;

<blue>	r = alloc_loaded_vmcs(&vmx->nested.vmcs02);</blue>
	if (r &lt; 0)
		goto out_vmcs02;

<blue>	vmx->nested.cached_vmcs12 = kzalloc(VMCS12_SIZE, GFP_KERNEL_ACCOUNT);</blue>
	if (!vmx-&gt;nested.cached_vmcs12)
		goto out_cached_vmcs12;

<blue>	vmx->nested.shadow_vmcs12_cache.gpa = INVALID_GPA;</blue>
	vmx-&gt;nested.cached_shadow_vmcs12 = kzalloc(VMCS12_SIZE, GFP_KERNEL_ACCOUNT);
	if (!vmx-&gt;nested.cached_shadow_vmcs12)
		goto out_cached_shadow_vmcs12;

<blue>	if (enable_shadow_vmcs && !alloc_shadow_vmcs(vcpu))</blue>
		goto out_shadow_vmcs;

<blue>	hrtimer_init(&vmx->nested.preemption_timer, CLOCK_MONOTONIC,</blue>
		     HRTIMER_MODE_ABS_PINNED);
	vmx-&gt;nested.preemption_timer.function = vmx_preemption_timer_fn;

	vmx-&gt;nested.vpid02 = allocate_vpid();

	vmx-&gt;nested.vmcs02_initialized = false;
	vmx-&gt;nested.vmxon = true;

	if (vmx_pt_mode_is_host_guest()) {
<yellow>		vmx->pt_desc.guest.ctl = 0;</yellow>
		pt_update_intercept_for_msr(vcpu);
	}

	return 0;

out_shadow_vmcs:
<yellow>	kfree(vmx->nested.cached_shadow_vmcs12);</yellow>

out_cached_shadow_vmcs12:
<yellow>	kfree(vmx->nested.cached_vmcs12);</yellow>

out_cached_vmcs12:
<yellow>	free_loaded_vmcs(&vmx->nested.vmcs02);</yellow>

out_vmcs02:
	return -ENOMEM;
}

/* Emulate the VMXON instruction. */
static int handle_vmxon(struct kvm_vcpu *vcpu)
<blue>{</blue>
	int ret;
	gpa_t vmptr;
	uint32_t revision;
	struct vcpu_vmx *vmx = to_vmx(vcpu);
	const u64 VMXON_NEEDED_FEATURES = FEAT_CTL_LOCKED
		| FEAT_CTL_VMX_ENABLED_OUTSIDE_SMX;

	/*
	 * Note, KVM cannot rely on hardware to perform the CR0/CR4 #UD checks
	 * that have higher priority than VM-Exit (see Intel SDM&#x27;s pseudocode
	 * for VMXON), as KVM must load valid CR0/CR4 values into hardware while
	 * running the guest, i.e. KVM needs to check the _guest_ values.
	 *
	 * Rely on hardware for the other two pre-VM-Exit checks, !VM86 and
	 * !COMPATIBILITY modes.  KVM may run the guest in VM86 to emulate Real
	 * Mode, but KVM will never take the guest out of those modes.
	 */
<blue>	if (!nested_host_cr0_valid(vcpu, kvm_read_cr0(vcpu)) ||</blue>
<blue>	    !nested_host_cr4_valid(vcpu, kvm_read_cr4(vcpu))) {</blue>
<yellow>		kvm_queue_exception(vcpu, UD_VECTOR);</yellow>
		return 1;
	}

	/*
	 * CPL=0 and all other checks that are lower priority than VM-Exit must
	 * be checked manually.
	 */
<blue>	if (vmx_get_cpl(vcpu)) {</blue>
<yellow>		kvm_inject_gp(vcpu, 0);</yellow>
		return 1;
	}

<blue>	if (vmx->nested.vmxon)</blue>
<yellow>		return nested_vmx_fail(vcpu, VMXERR_VMXON_IN_VMX_ROOT_OPERATION);</yellow>

<blue>	if ((vmx->msr_ia32_feature_control & VMXON_NEEDED_FEATURES)</blue>
			!= VMXON_NEEDED_FEATURES) {
		kvm_inject_gp(vcpu, 0);
		return 1;
	}

<blue>	if (nested_vmx_get_vmptr(vcpu, &vmptr, &ret))</blue>
<yellow>		return ret;</yellow>

	/*
	 * SDM 3: 24.11.5
	 * The first 4 bytes of VMXON region contain the supported
	 * VMCS revision identifier
	 *
	 * Note - IA32_VMX_BASIC[48] will never be 1 for the nested case;
	 * which replaces physical address width with 32
	 */
<blue>	if (!page_address_valid(vcpu, vmptr))</blue>
<yellow>		return nested_vmx_failInvalid(vcpu);</yellow>

<blue>	if (kvm_read_guest(vcpu->kvm, vmptr, &revision, sizeof(revision)) ||</blue>
<blue>	    revision != VMCS12_REVISION)</blue>
		return nested_vmx_failInvalid(vcpu);

<blue>	vmx->nested.vmxon_ptr = vmptr;</blue>
	ret = enter_vmx_operation(vcpu);
	if (ret)
		return ret;

<blue>	return nested_vmx_succeed(vcpu);</blue>
}

<blue>static inline void nested_release_vmcs12(struct kvm_vcpu *vcpu)</blue>
{
	struct vcpu_vmx *vmx = to_vmx(vcpu);

<blue>	if (vmx->nested.current_vmptr == INVALID_GPA)</blue>
		return;

<blue>	copy_vmcs02_to_vmcs12_rare(vcpu, get_vmcs12(vcpu));</blue>

<blue>	if (enable_shadow_vmcs) {</blue>
		/* copy to memory all shadowed fields in case
		   they were modified */
<blue>		copy_shadow_to_vmcs12(vmx);</blue>
		vmx_disable_shadow_vmcs(vmx);
	}
<blue>	vmx->nested.posted_intr_nv = -1;</blue>

	/* Flush VMCS12 to guest memory */
	kvm_vcpu_write_guest_page(vcpu,
				  vmx-&gt;nested.current_vmptr &gt;&gt; PAGE_SHIFT,
				  vmx-&gt;nested.cached_vmcs12, 0, VMCS12_SIZE);

	kvm_mmu_free_roots(vcpu-&gt;kvm, &amp;vcpu-&gt;arch.guest_mmu, KVM_MMU_ROOTS_ALL);

	vmx-&gt;nested.current_vmptr = INVALID_GPA;
}

/* Emulate the VMXOFF instruction */
<blue>static int handle_vmxoff(struct kvm_vcpu *vcpu)</blue>
{
<blue>	if (!nested_vmx_check_permission(vcpu))</blue>
		return 1;

<blue>	free_nested(vcpu);</blue>

<blue>	if (kvm_apic_has_pending_init_or_sipi(vcpu))</blue>
<yellow>		kvm_make_request(KVM_REQ_EVENT, vcpu);</yellow>

<blue>	return nested_vmx_succeed(vcpu);</blue>
<blue>}</blue>

/* Emulate the VMCLEAR instruction */
static int handle_vmclear(struct kvm_vcpu *vcpu)
<blue>{</blue>
	struct vcpu_vmx *vmx = to_vmx(vcpu);
	u32 zero = 0;
	gpa_t vmptr;
	u64 evmcs_gpa;
	int r;

<blue>	if (!nested_vmx_check_permission(vcpu))</blue>
		return 1;

<blue>	if (nested_vmx_get_vmptr(vcpu, &vmptr, &r))</blue>
<yellow>		return r;</yellow>

<blue>	if (!page_address_valid(vcpu, vmptr))</blue>
<yellow>		return nested_vmx_fail(vcpu, VMXERR_VMCLEAR_INVALID_ADDRESS);</yellow>

<blue>	if (vmptr == vmx->nested.vmxon_ptr)</blue>
<yellow>		return nested_vmx_fail(vcpu, VMXERR_VMCLEAR_VMXON_POINTER);</yellow>

	/*
	 * When Enlightened VMEntry is enabled on the calling CPU we treat
	 * memory area pointer by vmptr as Enlightened VMCS (as there&#x27;s no good
	 * way to distinguish it from VMCS12) and we must not corrupt it by
	 * writing to the non-existent &#x27;launch_state&#x27; field. The area doesn&#x27;t
	 * have to be the currently active EVMCS on the calling CPU and there&#x27;s
	 * nothing KVM has to do to transition it from &#x27;active&#x27; to &#x27;non-active&#x27;
	 * state. It is possible that the area will stay mapped as
	 * vmx-&gt;nested.hv_evmcs but this shouldn&#x27;t be a problem.
	 */
<blue>	if (likely(!guest_cpuid_has_evmcs(vcpu) ||</blue>
		   !nested_enlightened_vmentry(vcpu, &amp;evmcs_gpa))) {
<blue>		if (vmptr == vmx->nested.current_vmptr)</blue>
<blue>			nested_release_vmcs12(vcpu);</blue>

<blue>		kvm_vcpu_write_guest(vcpu,</blue>
				     vmptr + offsetof(struct vmcs12,
						      launch_state),
				     &amp;zero, sizeof(zero));
<yellow>	} else if (vmx->nested.hv_evmcs && vmptr == vmx->nested.hv_evmcs_vmptr) {</yellow>
<yellow>		nested_release_evmcs(vcpu);</yellow>
	}

<blue>	return nested_vmx_succeed(vcpu);</blue>
}

/* Emulate the VMLAUNCH instruction */
static int handle_vmlaunch(struct kvm_vcpu *vcpu)
{
<blue>	return nested_vmx_run(vcpu, true);</blue>
}

/* Emulate the VMRESUME instruction */
static int handle_vmresume(struct kvm_vcpu *vcpu)
{

<blue>	return nested_vmx_run(vcpu, false);</blue>
}

static int handle_vmread(struct kvm_vcpu *vcpu)
<blue>{</blue>
<blue>	struct vmcs12 *vmcs12 = is_guest_mode(vcpu) ? get_shadow_vmcs12(vcpu)</blue>
						    : get_vmcs12(vcpu);
<blue>	unsigned long exit_qualification = vmx_get_exit_qual(vcpu);</blue>
<blue>	u32 instr_info = vmcs_read32(VMX_INSTRUCTION_INFO);</blue>
	struct vcpu_vmx *vmx = to_vmx(vcpu);
	struct x86_exception e;
	unsigned long field;
	u64 value;
	gva_t gva = 0;
	short offset;
	int len, r;

<blue>	if (!nested_vmx_check_permission(vcpu))</blue>
		return 1;

	/* Decode instruction info and find the field to read */
<blue>	field = kvm_register_read(vcpu, (((instr_info) >> 28) & 0xf));</blue>

<blue>	if (!evmptr_is_valid(vmx->nested.hv_evmcs_vmptr)) {</blue>
		/*
		 * In VMX non-root operation, when the VMCS-link pointer is INVALID_GPA,
		 * any VMREAD sets the ALU flags for VMfailInvalid.
		 */
<blue>		if (vmx->nested.current_vmptr == INVALID_GPA ||</blue>
<blue>		    (is_guest_mode(vcpu) &&</blue>
<blue>		     get_vmcs12(vcpu)->vmcs_link_pointer == INVALID_GPA))</blue>
			return nested_vmx_failInvalid(vcpu);

<blue>		offset = get_vmcs12_field_offset(field);</blue>
<blue>		if (offset < 0)</blue>
<blue>			return nested_vmx_fail(vcpu, VMXERR_UNSUPPORTED_VMCS_COMPONENT);</blue>

<blue>		if (!is_guest_mode(vcpu) && is_vmcs12_ext_field(field))</blue>
<blue>			copy_vmcs02_to_vmcs12_rare(vcpu, vmcs12);</blue>

		/* Read the field, zero-extended to a u64 value */
<blue>		value = vmcs12_read_any(vmcs12, field, offset);</blue>
	} else {
		/*
		 * Hyper-V TLFS (as of 6.0b) explicitly states, that while an
		 * enlightened VMCS is active VMREAD/VMWRITE instructions are
		 * unsupported. Unfortunately, certain versions of Windows 11
		 * don&#x27;t comply with this requirement which is not enforced in
		 * genuine Hyper-V. Allow VMREAD from an enlightened VMCS as a
		 * workaround, as misbehaving guests will panic on VM-Fail.
		 * Note, enlightened VMCS is incompatible with shadow VMCS so
		 * all VMREADs from L2 should go to L1.
		 */
<yellow>		if (WARN_ON_ONCE(is_guest_mode(vcpu)))</yellow>
<blue>			return nested_vmx_failInvalid(vcpu);</blue>

<yellow>		offset = evmcs_field_offset(field, NULL);</yellow>
<yellow>		if (offset < 0)</yellow>
			return nested_vmx_fail(vcpu, VMXERR_UNSUPPORTED_VMCS_COMPONENT);

		/* Read the field, zero-extended to a u64 value */
<yellow>		value = evmcs_read_any(vmx->nested.hv_evmcs, field, offset);</yellow>
	}

	/*
	 * Now copy part of this value to register or memory, as requested.
	 * Note that the number of bits actually copied is 32 or 64 depending
	 * on the guest&#x27;s mode (32 or 64 bit), not on the given field&#x27;s length.
	 */
	if (instr_info &amp; BIT(10)) {
<blue>		kvm_register_write(vcpu, (((instr_info) >> 3) & 0xf), value);</blue>
	} else {
<yellow>		len = is_64_bit_mode(vcpu) ? 8 : 4;</yellow>
<yellow>		if (get_vmx_mem_address(vcpu, exit_qualification,</yellow>
					instr_info, true, len, &amp;gva))
			return 1;
		/* _system ok, nested_vmx_check_permission has verified cpl=0 */
<yellow>		r = kvm_write_guest_virt_system(vcpu, gva, &value, len, &e);</yellow>
		if (r != X86EMUL_CONTINUE)
<yellow>			return kvm_handle_memory_failure(vcpu, r, &e);</yellow>
	}

<blue>	return nested_vmx_succeed(vcpu);</blue>
}

static bool is_shadow_field_rw(unsigned long field)
{
<blue>	switch (field) {</blue>
#define SHADOW_FIELD_RW(x, y) case x:
#include &quot;vmcs_shadow_fields.h&quot;
		return true;
	default:
		break;
	}
	return false;
<blue>}</blue>

static bool is_shadow_field_ro(unsigned long field)
{
<blue>	switch (field) {</blue>
#define SHADOW_FIELD_RO(x, y) case x:
#include &quot;vmcs_shadow_fields.h&quot;
		return true;
	default:
		break;
	}
	return false;
}

static int handle_vmwrite(struct kvm_vcpu *vcpu)
<blue>{</blue>
<blue>	struct vmcs12 *vmcs12 = is_guest_mode(vcpu) ? get_shadow_vmcs12(vcpu)</blue>
						    : get_vmcs12(vcpu);
<blue>	unsigned long exit_qualification = vmx_get_exit_qual(vcpu);</blue>
<blue>	u32 instr_info = vmcs_read32(VMX_INSTRUCTION_INFO);</blue>
	struct vcpu_vmx *vmx = to_vmx(vcpu);
	struct x86_exception e;
	unsigned long field;
	short offset;
	gva_t gva;
	int len, r;

	/*
	 * The value to write might be 32 or 64 bits, depending on L1&#x27;s long
	 * mode, and eventually we need to write that into a field of several
	 * possible lengths. The code below first zero-extends the value to 64
	 * bit (value), and then copies only the appropriate number of
	 * bits into the vmcs12 field.
	 */
	u64 value = 0;

<blue>	if (!nested_vmx_check_permission(vcpu))</blue>
		return 1;

	/*
	 * In VMX non-root operation, when the VMCS-link pointer is INVALID_GPA,
	 * any VMWRITE sets the ALU flags for VMfailInvalid.
	 */
<blue>	if (vmx->nested.current_vmptr == INVALID_GPA ||</blue>
<blue>	    (is_guest_mode(vcpu) &&</blue>
<blue>	     get_vmcs12(vcpu)->vmcs_link_pointer == INVALID_GPA))</blue>
<blue>		return nested_vmx_failInvalid(vcpu);</blue>

<blue>	if (instr_info & BIT(10))</blue>
<blue>		value = kvm_register_read(vcpu, (((instr_info) >> 3) & 0xf));</blue>
	else {
<yellow>		len = is_64_bit_mode(vcpu) ? 8 : 4;</yellow>
<yellow>		if (get_vmx_mem_address(vcpu, exit_qualification,</yellow>
					instr_info, false, len, &amp;gva))
			return 1;
<yellow>		r = kvm_read_guest_virt(vcpu, gva, &value, len, &e);</yellow>
		if (r != X86EMUL_CONTINUE)
<yellow>			return kvm_handle_memory_failure(vcpu, r, &e);</yellow>
	}

<blue>	field = kvm_register_read(vcpu, (((instr_info) >> 28) & 0xf));</blue>

<blue>	offset = get_vmcs12_field_offset(field);</blue>
<blue>	if (offset < 0)</blue>
<blue>		return nested_vmx_fail(vcpu, VMXERR_UNSUPPORTED_VMCS_COMPONENT);</blue>

	/*
	 * If the vCPU supports &quot;VMWRITE to any supported field in the
	 * VMCS,&quot; then the &quot;read-only&quot; fields are actually read/write.
	 */
<blue>	if (vmcs_field_readonly(field) &&</blue>
<blue>	    !nested_cpu_has_vmwrite_any_field(vcpu))</blue>
<yellow>		return nested_vmx_fail(vcpu, VMXERR_VMWRITE_READ_ONLY_VMCS_COMPONENT);</yellow>

	/*
	 * Ensure vmcs12 is up-to-date before any VMWRITE that dirties
	 * vmcs12, else we may crush a field or consume a stale value.
	 */
<blue>	if (!is_guest_mode(vcpu) && !is_shadow_field_rw(field))</blue>
<blue>		copy_vmcs02_to_vmcs12_rare(vcpu, vmcs12);</blue>

	/*
	 * Some Intel CPUs intentionally drop the reserved bits of the AR byte
	 * fields on VMWRITE.  Emulate this behavior to ensure consistent KVM
	 * behavior regardless of the underlying hardware, e.g. if an AR_BYTE
	 * field is intercepted for VMWRITE but not VMREAD (in L1), then VMREAD
	 * from L1 will return a different value than VMREAD from L2 (L1 sees
	 * the stripped down value, L2 sees the full value as stored by KVM).
	 */
	if (field &gt;= GUEST_ES_AR_BYTES &amp;&amp; field &lt;= GUEST_TR_AR_BYTES)
<blue>		value &= 0x1f0ff;</blue>

<blue>	vmcs12_write_any(vmcs12, field, offset, value);</blue>

	/*
	 * Do not track vmcs12 dirty-state if in guest-mode as we actually
	 * dirty shadow vmcs12 instead of vmcs12.  Fields that can be updated
	 * by L1 without a vmexit are always updated in the vmcs02, i.e. don&#x27;t
	 * &quot;dirty&quot; vmcs12, all others go down the prepare_vmcs02() slow path.
	 */
<blue>	if (!is_guest_mode(vcpu) && !is_shadow_field_rw(field)) {</blue>
		/*
		 * L1 can read these fields without exiting, ensure the
		 * shadow VMCS is up-to-date.
		 */
<blue>		if (enable_shadow_vmcs && is_shadow_field_ro(field)) {</blue>
<blue>			preempt_disable();</blue>
			vmcs_load(vmx-&gt;vmcs01.shadow_vmcs);

<yellow>			__vmcs_writel(field, value);</yellow>

<blue>			vmcs_clear(vmx->vmcs01.shadow_vmcs);</blue>
<blue>			vmcs_load(vmx->loaded_vmcs->vmcs);</blue>
<blue>			preempt_enable();</blue>
		}
<blue>		vmx->nested.dirty_vmcs12 = true;</blue>
	}

<blue>	return nested_vmx_succeed(vcpu);</blue>
}

static void set_current_vmptr(struct vcpu_vmx *vmx, gpa_t vmptr)
{
<blue>	vmx->nested.current_vmptr = vmptr;</blue>
<blue>	if (enable_shadow_vmcs) {</blue>
<blue>		secondary_exec_controls_setbit(vmx, SECONDARY_EXEC_SHADOW_VMCS);</blue>
<blue>		vmcs_write64(VMCS_LINK_POINTER,</blue>
<blue>			     __pa(vmx->vmcs01.shadow_vmcs));</blue>
<blue>		vmx->nested.need_vmcs12_to_shadow_sync = true;</blue>
	}
<blue>	vmx->nested.dirty_vmcs12 = true;</blue>
	vmx-&gt;nested.force_msr_bitmap_recalc = true;
}

/* Emulate the VMPTRLD instruction */
<blue>static int handle_vmptrld(struct kvm_vcpu *vcpu)</blue>
<blue>{</blue>
	struct vcpu_vmx *vmx = to_vmx(vcpu);
	gpa_t vmptr;
	int r;

<blue>	if (!nested_vmx_check_permission(vcpu))</blue>
		return 1;

<blue>	if (nested_vmx_get_vmptr(vcpu, &vmptr, &r))</blue>
<blue>		return r;</blue>

<blue>	if (!page_address_valid(vcpu, vmptr))</blue>
<yellow>		return nested_vmx_fail(vcpu, VMXERR_VMPTRLD_INVALID_ADDRESS);</yellow>

<blue>	if (vmptr == vmx->nested.vmxon_ptr)</blue>
<yellow>		return nested_vmx_fail(vcpu, VMXERR_VMPTRLD_VMXON_POINTER);</yellow>

	/* Forbid normal VMPTRLD if Enlightened version was used */
<blue>	if (evmptr_is_valid(vmx->nested.hv_evmcs_vmptr))</blue>
		return 1;

<blue>	if (vmx->nested.current_vmptr != vmptr) {</blue>
		struct gfn_to_hva_cache *ghc = &amp;vmx-&gt;nested.vmcs12_cache;
		struct vmcs_hdr hdr;

<blue>		if (kvm_gfn_to_hva_cache_init(vcpu->kvm, ghc, vmptr, VMCS12_SIZE)) {</blue>
			/*
			 * Reads from an unbacked page return all 1s,
			 * which means that the 32 bits located at the
			 * given physical address won&#x27;t match the required
			 * VMCS12_REVISION identifier.
			 */
<yellow>			return nested_vmx_fail(vcpu,</yellow>
				VMXERR_VMPTRLD_INCORRECT_VMCS_REVISION_ID);
		}

<blue>		if (kvm_read_guest_offset_cached(vcpu->kvm, ghc, &hdr,</blue>
						 offsetof(struct vmcs12, hdr),
						 sizeof(hdr))) {
			return nested_vmx_fail(vcpu,
				VMXERR_VMPTRLD_INCORRECT_VMCS_REVISION_ID);
		}

<blue>		if (hdr.revision_id != VMCS12_REVISION ||</blue>
<blue>		    (hdr.shadow_vmcs &&</blue>
<yellow>		     !nested_cpu_has_vmx_shadow_vmcs(vcpu))) {</yellow>
			return nested_vmx_fail(vcpu,
				VMXERR_VMPTRLD_INCORRECT_VMCS_REVISION_ID);
		}

<blue>		nested_release_vmcs12(vcpu);</blue>

		/*
		 * Load VMCS12 from guest memory since it is not already
		 * cached.
		 */
<blue>		if (kvm_read_guest_cached(vcpu->kvm, ghc, vmx->nested.cached_vmcs12,</blue>
					  VMCS12_SIZE)) {
<yellow>			return nested_vmx_fail(vcpu,</yellow>
				VMXERR_VMPTRLD_INCORRECT_VMCS_REVISION_ID);
		}

<blue>		set_current_vmptr(vmx, vmptr);</blue>
	}

<blue>	return nested_vmx_succeed(vcpu);</blue>
}

/* Emulate the VMPTRST instruction */
static int handle_vmptrst(struct kvm_vcpu *vcpu)
<blue>{</blue>
<blue>	unsigned long exit_qual = vmx_get_exit_qual(vcpu);</blue>
<blue>	u32 instr_info = vmcs_read32(VMX_INSTRUCTION_INFO);</blue>
<blue>	gpa_t current_vmptr = to_vmx(vcpu)->nested.current_vmptr;</blue>
	struct x86_exception e;
	gva_t gva;
	int r;

	if (!nested_vmx_check_permission(vcpu))
		return 1;

<blue>	if (unlikely(evmptr_is_valid(to_vmx(vcpu)->nested.hv_evmcs_vmptr)))</blue>
		return 1;

<blue>	if (get_vmx_mem_address(vcpu, exit_qual, instr_info,</blue>
				true, sizeof(gpa_t), &amp;gva))
		return 1;
	/* *_system ok, nested_vmx_check_permission has verified cpl=0 */
<blue>	r = kvm_write_guest_virt_system(vcpu, gva, (void *)&current_vmptr,</blue>
					sizeof(gpa_t), &amp;e);
	if (r != X86EMUL_CONTINUE)
<yellow>		return kvm_handle_memory_failure(vcpu, r, &e);</yellow>

<blue>	return nested_vmx_succeed(vcpu);</blue>
}

/* Emulate the INVEPT instruction */
<blue>static int handle_invept(struct kvm_vcpu *vcpu)</blue>
<blue>{</blue>
	struct vcpu_vmx *vmx = to_vmx(vcpu);
	u32 vmx_instruction_info, types;
	unsigned long type, roots_to_free;
	struct kvm_mmu *mmu;
	gva_t gva;
	struct x86_exception e;
	struct {
		u64 eptp, gpa;
	} operand;
	int i, r, gpr_index;

<blue>	if (!(vmx->nested.msrs.secondary_ctls_high &</blue>
	      SECONDARY_EXEC_ENABLE_EPT) ||
<blue>	    !(vmx->nested.msrs.ept_caps & VMX_EPT_INVEPT_BIT)) {</blue>
<yellow>		kvm_queue_exception(vcpu, UD_VECTOR);</yellow>
		return 1;
	}

<blue>	if (!nested_vmx_check_permission(vcpu))</blue>
		return 1;

<blue>	vmx_instruction_info = vmcs_read32(VMX_INSTRUCTION_INFO);</blue>
<blue>	gpr_index = vmx_get_instr_info_reg2(vmx_instruction_info);</blue>
<blue>	type = kvm_register_read(vcpu, gpr_index);</blue>

<blue>	types = (vmx->nested.msrs.ept_caps >> VMX_EPT_EXTENT_SHIFT) & 6;</blue>

<blue>	if (type >= 32 || !(types & (1 << type)))</blue>
		return nested_vmx_fail(vcpu, VMXERR_INVALID_OPERAND_TO_INVEPT_INVVPID);

	/* According to the Intel VMX instruction reference, the memory
	 * operand is read even if it isn&#x27;t needed (e.g., for type==global)
	 */
<blue>	if (get_vmx_mem_address(vcpu, vmx_get_exit_qual(vcpu),</blue>
			vmx_instruction_info, false, sizeof(operand), &amp;gva))
		return 1;
<blue>	r = kvm_read_guest_virt(vcpu, gva, &operand, sizeof(operand), &e);</blue>
	if (r != X86EMUL_CONTINUE)
<yellow>		return kvm_handle_memory_failure(vcpu, r, &e);</yellow>

	/*
	 * Nested EPT roots are always held through guest_mmu,
	 * not root_mmu.
	 */
	mmu = &amp;vcpu-&gt;arch.guest_mmu;

<blue>	switch (type) {</blue>
	case VMX_EPT_EXTENT_CONTEXT:
<blue>		if (!nested_vmx_check_eptp(vcpu, operand.eptp))</blue>
<blue>			return nested_vmx_fail(vcpu,</blue>
				VMXERR_INVALID_OPERAND_TO_INVEPT_INVVPID);

		roots_to_free = 0;
<blue>		if (nested_ept_root_matches(mmu->root.hpa, mmu->root.pgd,</blue>
					    operand.eptp))
			roots_to_free |= KVM_MMU_ROOT_CURRENT;

<blue>		for (i = 0; i < KVM_MMU_NUM_PREV_ROOTS; i++) {</blue>
<yellow>			if (nested_ept_root_matches(mmu->prev_roots[i].hpa,</yellow>
<blue>						    mmu->prev_roots[i].pgd,</blue>
						    operand.eptp))
<yellow>				roots_to_free |= KVM_MMU_ROOT_PREVIOUS(i);</yellow>
		}
		break;
	case VMX_EPT_EXTENT_GLOBAL:
		roots_to_free = KVM_MMU_ROOTS_ALL;
		break;
	default:
<yellow>		BUG();</yellow>
		break;
	}

<blue>	if (roots_to_free)</blue>
<blue>		kvm_mmu_free_roots(vcpu->kvm, mmu, roots_to_free);</blue>

<blue>	return nested_vmx_succeed(vcpu);</blue>
}

<blue>static int handle_invvpid(struct kvm_vcpu *vcpu)</blue>
<blue>{</blue>
	struct vcpu_vmx *vmx = to_vmx(vcpu);
	u32 vmx_instruction_info;
	unsigned long type, types;
	gva_t gva;
	struct x86_exception e;
	struct {
		u64 vpid;
		u64 gla;
	} operand;
	u16 vpid02;
	int r, gpr_index;

<blue>	if (!(vmx->nested.msrs.secondary_ctls_high &</blue>
	      SECONDARY_EXEC_ENABLE_VPID) ||
<blue>			!(vmx->nested.msrs.vpid_caps & VMX_VPID_INVVPID_BIT)) {</blue>
<yellow>		kvm_queue_exception(vcpu, UD_VECTOR);</yellow>
		return 1;
	}

<blue>	if (!nested_vmx_check_permission(vcpu))</blue>
		return 1;

<blue>	vmx_instruction_info = vmcs_read32(VMX_INSTRUCTION_INFO);</blue>
<blue>	gpr_index = vmx_get_instr_info_reg2(vmx_instruction_info);</blue>
<blue>	type = kvm_register_read(vcpu, gpr_index);</blue>

<blue>	types = (vmx->nested.msrs.vpid_caps &</blue>
			VMX_VPID_EXTENT_SUPPORTED_MASK) &gt;&gt; 8;

<blue>	if (type >= 32 || !(types & (1 << type)))</blue>
		return nested_vmx_fail(vcpu,
			VMXERR_INVALID_OPERAND_TO_INVEPT_INVVPID);

	/* according to the intel vmx instruction reference, the memory
	 * operand is read even if it isn&#x27;t needed (e.g., for type==global)
	 */
<blue>	if (get_vmx_mem_address(vcpu, vmx_get_exit_qual(vcpu),</blue>
			vmx_instruction_info, false, sizeof(operand), &amp;gva))
		return 1;
<blue>	r = kvm_read_guest_virt(vcpu, gva, &operand, sizeof(operand), &e);</blue>
	if (r != X86EMUL_CONTINUE)
<yellow>		return kvm_handle_memory_failure(vcpu, r, &e);</yellow>

<blue>	if (operand.vpid >> 16)</blue>
<blue>		return nested_vmx_fail(vcpu,</blue>
			VMXERR_INVALID_OPERAND_TO_INVEPT_INVVPID);

<blue>	vpid02 = nested_get_vpid02(vcpu);</blue>
<blue>	switch (type) {</blue>
	case VMX_VPID_EXTENT_INDIVIDUAL_ADDR:
<blue>		if (!operand.vpid ||</blue>
<blue>		    is_noncanonical_address(operand.gla, vcpu))</blue>
			return nested_vmx_fail(vcpu,
				VMXERR_INVALID_OPERAND_TO_INVEPT_INVVPID);
<blue>		vpid_sync_vcpu_addr(vpid02, operand.gla);</blue>
		break;
	case VMX_VPID_EXTENT_SINGLE_CONTEXT:
	case VMX_VPID_EXTENT_SINGLE_NON_GLOBAL:
<blue>		if (!operand.vpid)</blue>
			return nested_vmx_fail(vcpu,
				VMXERR_INVALID_OPERAND_TO_INVEPT_INVVPID);
<blue>		vpid_sync_context(vpid02);</blue>
		break;
	case VMX_VPID_EXTENT_ALL_CONTEXT:
<blue>		vpid_sync_context(vpid02);</blue>
		break;
	default:
<yellow>		WARN_ON_ONCE(1);</yellow>
		return kvm_skip_emulated_instruction(vcpu);
	}

	/*
	 * Sync the shadow page tables if EPT is disabled, L1 is invalidating
	 * linear mappings for L2 (tagged with L2&#x27;s VPID).  Free all guest
	 * roots as VPIDs are not tracked in the MMU role.
	 *
	 * Note, this operates on root_mmu, not guest_mmu, as L1 and L2 share
	 * an MMU when EPT is disabled.
	 *
	 * TODO: sync only the affected SPTEs for INVDIVIDUAL_ADDR.
	 */
<blue>	if (!enable_ept)</blue>
<yellow>		kvm_mmu_free_guest_mode_roots(vcpu->kvm, &vcpu->arch.root_mmu);</yellow>

<blue>	return nested_vmx_succeed(vcpu);</blue>
}

static int nested_vmx_eptp_switching(struct kvm_vcpu *vcpu,
				     struct vmcs12 *vmcs12)
{
<yellow>	u32 index = kvm_rcx_read(vcpu);</yellow>
	u64 new_eptp;

<yellow>	if (WARN_ON_ONCE(!nested_cpu_has_ept(vmcs12)))</yellow>
		return 1;
<yellow>	if (index >= VMFUNC_EPTP_ENTRIES)</yellow>
		return 1;

<yellow>	if (kvm_vcpu_read_guest_page(vcpu, vmcs12->eptp_list_address >> PAGE_SHIFT,</yellow>
				     &amp;new_eptp, index * 8, 8))
		return 1;

	/*
	 * If the (L2) guest does a vmfunc to the currently
	 * active ept pointer, we don&#x27;t have to do anything else
	 */
<yellow>	if (vmcs12->ept_pointer != new_eptp) {</yellow>
<yellow>		if (!nested_vmx_check_eptp(vcpu, new_eptp))</yellow>
			return 1;

<yellow>		vmcs12->ept_pointer = new_eptp;</yellow>
		nested_ept_new_eptp(vcpu);

<yellow>		if (!nested_cpu_has_vpid(vmcs12))</yellow>
<yellow>			kvm_make_request(KVM_REQ_TLB_FLUSH_GUEST, vcpu);</yellow>
	}

	return 0;
}

static int handle_vmfunc(struct kvm_vcpu *vcpu)
<blue>{</blue>
	struct vcpu_vmx *vmx = to_vmx(vcpu);
	struct vmcs12 *vmcs12;
<blue>	u32 function = kvm_rax_read(vcpu);</blue>

	/*
	 * VMFUNC is only supported for nested guests, but we always enable the
	 * secondary control for simplicity; for non-nested mode, fake that we
	 * didn&#x27;t by injecting #UD.
	 */
	if (!is_guest_mode(vcpu)) {
<yellow>		kvm_queue_exception(vcpu, UD_VECTOR);</yellow>
		return 1;
	}

<blue>	vmcs12 = get_vmcs12(vcpu);</blue>

	/*
	 * #UD on out-of-bounds function has priority over VM-Exit, and VMFUNC
	 * is enabled in vmcs02 if and only if it&#x27;s enabled in vmcs12.
	 */
<blue>	if (WARN_ON_ONCE((function > 63) || !nested_cpu_has_vmfunc(vmcs12))) {</blue>
		kvm_queue_exception(vcpu, UD_VECTOR);
		return 1;
	}

<blue>	if (!(vmcs12->vm_function_control & BIT_ULL(function)))</blue>
		goto fail;

<yellow>	switch (function) {</yellow>
	case 0:
<yellow>		if (nested_vmx_eptp_switching(vcpu, vmcs12))</yellow>
			goto fail;
		break;
	default:
		goto fail;
	}
<yellow>	return kvm_skip_emulated_instruction(vcpu);</yellow>

fail:
	/*
	 * This is effectively a reflected VM-Exit, as opposed to a synthesized
	 * nested VM-Exit.  Pass the original exit reason, i.e. don&#x27;t hardcode
	 * EXIT_REASON_VMFUNC as the exit reason.
	 */
<blue>	nested_vmx_vmexit(vcpu, vmx->exit_reason.full,</blue>
			  vmx_get_intr_info(vcpu),
			  vmx_get_exit_qual(vcpu));
	return 1;
}

/*
 * Return true if an IO instruction with the specified port and size should cause
 * a VM-exit into L1.
 */
bool nested_vmx_check_io_bitmaps(struct kvm_vcpu *vcpu, unsigned int port,
				 int size)
<blue>{</blue>
<blue>	struct vmcs12 *vmcs12 = get_vmcs12(vcpu);</blue>
	gpa_t bitmap, last_bitmap;
	u8 b;

	last_bitmap = INVALID_GPA;
	b = -1;

	while (size &gt; 0) {
<blue>		if (port < 0x8000)</blue>
<blue>			bitmap = vmcs12->io_bitmap_a;</blue>
<blue>		else if (port < 0x10000)</blue>
<blue>			bitmap = vmcs12->io_bitmap_b;</blue>
		else
			return true;
<blue>		bitmap += (port & 0x7fff) / 8;</blue>

		if (last_bitmap != bitmap)
<blue>			if (kvm_vcpu_read_guest(vcpu, bitmap, &b, 1))</blue>
				return true;
<blue>		if (b & (1 << (port & 7)))</blue>
			return true;

		port++;
<blue>		size--;</blue>
		last_bitmap = bitmap;
	}

	return false;
}

static bool nested_vmx_exit_handled_io(struct kvm_vcpu *vcpu,
				       struct vmcs12 *vmcs12)
{
	unsigned long exit_qualification;
	unsigned short port;
	int size;

<blue>	if (!nested_cpu_has(vmcs12, CPU_BASED_USE_IO_BITMAPS))</blue>
<blue>		return nested_cpu_has(vmcs12, CPU_BASED_UNCOND_IO_EXITING);</blue>

<blue>	exit_qualification = vmx_get_exit_qual(vcpu);</blue>

	port = exit_qualification &gt;&gt; 16;
	size = (exit_qualification &amp; 7) + 1;

	return nested_vmx_check_io_bitmaps(vcpu, port, size);
}

/*
 * Return 1 if we should exit from L2 to L1 to handle an MSR access,
 * rather than handle it ourselves in L0. I.e., check whether L1 expressed
 * disinterest in the current event (read or write a specific MSR) by using an
 * MSR bitmap. This may be the case even when L0 doesn&#x27;t use MSR bitmaps.
 */
static bool nested_vmx_exit_handled_msr(struct kvm_vcpu *vcpu,
					struct vmcs12 *vmcs12,
					union vmx_exit_reason exit_reason)
{
<blue>	u32 msr_index = kvm_rcx_read(vcpu);</blue>
	gpa_t bitmap;

	if (!nested_cpu_has(vmcs12, CPU_BASED_USE_MSR_BITMAPS))
		return true;

	/*
	 * The MSR_BITMAP page is divided into four 1024-byte bitmaps,
	 * for the four combinations of read/write and low/high MSR numbers.
	 * First we need to figure out which of the four to use:
	 */
<blue>	bitmap = vmcs12->msr_bitmap;</blue>
	if (exit_reason.basic == EXIT_REASON_MSR_WRITE)
<blue>		bitmap += 2048;</blue>
<blue>	if (msr_index >= 0xc0000000) {</blue>
<blue>		msr_index -= 0xc0000000;</blue>
		bitmap += 1024;
	}

	/* Then read the msr_index&#x27;th bit from this bitmap: */
<blue>	if (msr_index < 1024*8) {</blue>
		unsigned char b;
<blue>		if (kvm_vcpu_read_guest(vcpu, bitmap + msr_index/8, &b, 1))</blue>
			return true;
<blue>		return 1 & (b >> (msr_index & 7));</blue>
	} else
		return true; /* let L1 handle the wrong parameter */
}

/*
 * Return 1 if we should exit from L2 to L1 to handle a CR access exit,
 * rather than handle it ourselves in L0. I.e., check if L1 wanted to
 * intercept (via guest_host_mask etc.) the current event.
 */
static bool nested_vmx_exit_handled_cr(struct kvm_vcpu *vcpu,
	struct vmcs12 *vmcs12)
{
<blue>	unsigned long exit_qualification = vmx_get_exit_qual(vcpu);</blue>
	int cr = exit_qualification &amp; 15;
	int reg;
	unsigned long val;

	switch ((exit_qualification &gt;&gt; 4) &amp; 3) {
	case 0: /* mov to cr */
<blue>		reg = (exit_qualification >> 8) & 15;</blue>
<blue>		val = kvm_register_read(vcpu, reg);</blue>
<blue>		switch (cr) {</blue>
		case 0:
<blue>			if (vmcs12->cr0_guest_host_mask &</blue>
			    (val ^ vmcs12-&gt;cr0_read_shadow))
				return true;
			break;
		case 3:
<blue>			if (nested_cpu_has(vmcs12, CPU_BASED_CR3_LOAD_EXITING))</blue>
				return true;
			break;
		case 4:
<blue>			if (vmcs12->cr4_guest_host_mask &</blue>
			    (vmcs12-&gt;cr4_read_shadow ^ val))
				return true;
			break;
		case 8:
<blue>			if (nested_cpu_has(vmcs12, CPU_BASED_CR8_LOAD_EXITING))</blue>
				return true;
			break;
		}
		break;
	case 2: /* clts */
<yellow>		if ((vmcs12->cr0_guest_host_mask & X86_CR0_TS) &&</yellow>
<yellow>		    (vmcs12->cr0_read_shadow & X86_CR0_TS))</yellow>
			return true;
		break;
	case 1: /* mov from cr */
<blue>		switch (cr) {</blue>
		case 3:
<blue>			if (vmcs12->cpu_based_vm_exec_control &</blue>
			    CPU_BASED_CR3_STORE_EXITING)
				return true;
			break;
		case 8:
<blue>			if (vmcs12->cpu_based_vm_exec_control &</blue>
			    CPU_BASED_CR8_STORE_EXITING)
				return true;
			break;
		}
		break;
	case 3: /* lmsw */
		/*
		 * lmsw can change bits 1..3 of cr0, and only set bit 0 of
		 * cr0. Other attempted changes are ignored, with no exit.
		 */
		val = (exit_qualification &gt;&gt; LMSW_SOURCE_DATA_SHIFT) &amp; 0x0f;
<yellow>		if (vmcs12->cr0_guest_host_mask & 0xe &</yellow>
		    (val ^ vmcs12-&gt;cr0_read_shadow))
			return true;
<yellow>		if ((vmcs12->cr0_guest_host_mask & 0x1) &&</yellow>
<yellow>		    !(vmcs12->cr0_read_shadow & 0x1) &&</yellow>
<yellow>		    (val & 0x1))</yellow>
			return true;
		break;
	}
	return false;
}

static bool nested_vmx_exit_handled_encls(struct kvm_vcpu *vcpu,
					  struct vmcs12 *vmcs12)
{
	u32 encls_leaf;

<yellow>	if (!guest_cpuid_has(vcpu, X86_FEATURE_SGX) ||</yellow>
<yellow>	    !nested_cpu_has2(vmcs12, SECONDARY_EXEC_ENCLS_EXITING))</yellow>
		return false;

<yellow>	encls_leaf = kvm_rax_read(vcpu);</yellow>
	if (encls_leaf &gt; 62)
		encls_leaf = 63;
	return vmcs12-&gt;encls_exiting_bitmap &amp; BIT_ULL(encls_leaf);
}

<blue>static bool nested_vmx_exit_handled_vmcs_access(struct kvm_vcpu *vcpu,</blue>
	struct vmcs12 *vmcs12, gpa_t bitmap)
<blue>{</blue>
	u32 vmx_instruction_info;
	unsigned long field;
	u8 b;

<blue>	if (!nested_cpu_has_shadow_vmcs(vmcs12))</blue>
		return true;

	/* Decode instruction info and find the field to access */
<blue>	vmx_instruction_info = vmcs_read32(VMX_INSTRUCTION_INFO);</blue>
<blue>	field = kvm_register_read(vcpu, (((vmx_instruction_info) >> 28) & 0xf));</blue>

	/* Out-of-range fields always cause a VM exit from L2 to L1 */
<blue>	if (field >> 15)</blue>
<yellow>		return true;</yellow>

<blue>	if (kvm_vcpu_read_guest(vcpu, bitmap + field/8, &b, 1))</blue>
		return true;

<blue>	return 1 & (b >> (field & 7));</blue>
}

static bool nested_vmx_exit_handled_mtf(struct vmcs12 *vmcs12)
{
<blue>	u32 entry_intr_info = vmcs12->vm_entry_intr_info_field;</blue>

	if (nested_cpu_has_mtf(vmcs12))
		return true;

	/*
	 * An MTF VM-exit may be injected into the guest by setting the
	 * interruption-type to 7 (other event) and the vector field to 0. Such
	 * is the case regardless of the &#x27;monitor trap flag&#x27; VM-execution
	 * control.
	 */
<blue>	return entry_intr_info == (INTR_INFO_VALID_MASK</blue>
				   | INTR_TYPE_OTHER_EVENT);
}

/*
 * Return true if L0 wants to handle an exit from L2 regardless of whether or not
 * L1 wants the exit.  Only call this when in is_guest_mode (L2).
 */
static bool nested_vmx_l0_wants_exit(struct kvm_vcpu *vcpu,
				     union vmx_exit_reason exit_reason)
{
	u32 intr_info;

<blue>	switch ((u16)exit_reason.basic) {</blue>
	case EXIT_REASON_EXCEPTION_NMI:
<blue>		intr_info = vmx_get_intr_info(vcpu);</blue>
		if (is_nmi(intr_info))
			return true;
<blue>		else if (is_page_fault(intr_info))</blue>
<blue>			return vcpu->arch.apf.host_apf_flags ||</blue>
<blue>			       vmx_need_pf_intercept(vcpu);</blue>
<blue>		else if (is_debug(intr_info) &&</blue>
<blue>			 vcpu->guest_debug &</blue>
			 (KVM_GUESTDBG_SINGLESTEP | KVM_GUESTDBG_USE_HW_BP))
			return true;
<blue>		else if (is_breakpoint(intr_info) &&</blue>
<yellow>			 vcpu->guest_debug & KVM_GUESTDBG_USE_SW_BP)</yellow>
			return true;
<blue>		else if (is_alignment_check(intr_info) &&</blue>
<blue>			 !vmx_guest_inject_ac(vcpu))</blue>
			return true;
		return false;
	case EXIT_REASON_EXTERNAL_INTERRUPT:
		return true;
	case EXIT_REASON_MCE_DURING_VMENTRY:
		return true;
	case EXIT_REASON_EPT_VIOLATION:
		/*
		 * L0 always deals with the EPT violation. If nested EPT is
		 * used, and the nested mmu code discovers that the address is
		 * missing in the guest EPT table (EPT12), the EPT violation
		 * will be injected with nested_ept_inject_page_fault()
		 */
		return true;
	case EXIT_REASON_EPT_MISCONFIG:
		/*
		 * L2 never uses directly L1&#x27;s EPT, but rather L0&#x27;s own EPT
		 * table (shadow on EPT) or a merged EPT table that L0 built
		 * (EPT on EPT). So any problems with the structure of the
		 * table is L0&#x27;s fault.
		 */
		return true;
	case EXIT_REASON_PREEMPTION_TIMER:
		return true;
	case EXIT_REASON_PML_FULL:
		/*
		 * PML is emulated for an L1 VMM and should never be enabled in
		 * vmcs02, always &quot;handle&quot; PML_FULL by exiting to userspace.
		 */
		return true;
	case EXIT_REASON_VMFUNC:
		/* VM functions are emulated through L2-&gt;L0 vmexits. */
		return true;
	case EXIT_REASON_BUS_LOCK:
		/*
		 * At present, bus lock VM exit is never exposed to L1.
		 * Handle L2&#x27;s bus locks in L0 directly.
		 */
		return true;
	default:
		break;
	}
	return false;
}

/*
 * Return 1 if L1 wants to intercept an exit from L2.  Only call this when in
 * is_guest_mode (L2).
 */
static bool nested_vmx_l1_wants_exit(struct kvm_vcpu *vcpu,
				     union vmx_exit_reason exit_reason)
{
<blue>	struct vmcs12 *vmcs12 = get_vmcs12(vcpu);</blue>
	u32 intr_info;

	switch ((u16)exit_reason.basic) {
	case EXIT_REASON_EXCEPTION_NMI:
<blue>		intr_info = vmx_get_intr_info(vcpu);</blue>
		if (is_nmi(intr_info))
			return true;
<blue>		else if (is_page_fault(intr_info))</blue>
			return true;
<blue>		return vmcs12->exception_bitmap &</blue>
<blue>				(1u << (intr_info & INTR_INFO_VECTOR_MASK));</blue>
	case EXIT_REASON_EXTERNAL_INTERRUPT:
		return nested_exit_on_intr(vcpu);
	case EXIT_REASON_TRIPLE_FAULT:
		return true;
	case EXIT_REASON_INTERRUPT_WINDOW:
<blue>		return nested_cpu_has(vmcs12, CPU_BASED_INTR_WINDOW_EXITING);</blue>
	case EXIT_REASON_NMI_WINDOW:
<blue>		return nested_cpu_has(vmcs12, CPU_BASED_NMI_WINDOW_EXITING);</blue>
	case EXIT_REASON_TASK_SWITCH:
		return true;
	case EXIT_REASON_CPUID:
		return true;
	case EXIT_REASON_HLT:
<blue>		return nested_cpu_has(vmcs12, CPU_BASED_HLT_EXITING);</blue>
	case EXIT_REASON_INVD:
		return true;
	case EXIT_REASON_INVLPG:
<blue>		return nested_cpu_has(vmcs12, CPU_BASED_INVLPG_EXITING);</blue>
	case EXIT_REASON_RDPMC:
<blue>		return nested_cpu_has(vmcs12, CPU_BASED_RDPMC_EXITING);</blue>
	case EXIT_REASON_RDRAND:
<blue>		return nested_cpu_has2(vmcs12, SECONDARY_EXEC_RDRAND_EXITING);</blue>
	case EXIT_REASON_RDSEED:
<blue>		return nested_cpu_has2(vmcs12, SECONDARY_EXEC_RDSEED_EXITING);</blue>
	case EXIT_REASON_RDTSC: case EXIT_REASON_RDTSCP:
<blue>		return nested_cpu_has(vmcs12, CPU_BASED_RDTSC_EXITING);</blue>
	case EXIT_REASON_VMREAD:
<blue>		return nested_vmx_exit_handled_vmcs_access(vcpu, vmcs12,</blue>
			vmcs12-&gt;vmread_bitmap);
	case EXIT_REASON_VMWRITE:
<blue>		return nested_vmx_exit_handled_vmcs_access(vcpu, vmcs12,</blue>
			vmcs12-&gt;vmwrite_bitmap);
	case EXIT_REASON_VMCALL: case EXIT_REASON_VMCLEAR:
	case EXIT_REASON_VMLAUNCH: case EXIT_REASON_VMPTRLD:
	case EXIT_REASON_VMPTRST: case EXIT_REASON_VMRESUME:
	case EXIT_REASON_VMOFF: case EXIT_REASON_VMON:
	case EXIT_REASON_INVEPT: case EXIT_REASON_INVVPID:
		/*
		 * VMX instructions trap unconditionally. This allows L1 to
		 * emulate them for its L2 guest, i.e., allows 3-level nesting!
		 */
		return true;
	case EXIT_REASON_CR_ACCESS:
<blue>		return nested_vmx_exit_handled_cr(vcpu, vmcs12);</blue>
	case EXIT_REASON_DR_ACCESS:
<blue>		return nested_cpu_has(vmcs12, CPU_BASED_MOV_DR_EXITING);</blue>
	case EXIT_REASON_IO_INSTRUCTION:
<blue>		return nested_vmx_exit_handled_io(vcpu, vmcs12);</blue>
	case EXIT_REASON_GDTR_IDTR: case EXIT_REASON_LDTR_TR:
<blue>		return nested_cpu_has2(vmcs12, SECONDARY_EXEC_DESC);</blue>
	case EXIT_REASON_MSR_READ:
	case EXIT_REASON_MSR_WRITE:
<blue>		return nested_vmx_exit_handled_msr(vcpu, vmcs12, exit_reason);</blue>
	case EXIT_REASON_INVALID_STATE:
		return true;
	case EXIT_REASON_MWAIT_INSTRUCTION:
<blue>		return nested_cpu_has(vmcs12, CPU_BASED_MWAIT_EXITING);</blue>
	case EXIT_REASON_MONITOR_TRAP_FLAG:
<blue>		return nested_vmx_exit_handled_mtf(vmcs12);</blue>
	case EXIT_REASON_MONITOR_INSTRUCTION:
<blue>		return nested_cpu_has(vmcs12, CPU_BASED_MONITOR_EXITING);</blue>
	case EXIT_REASON_PAUSE_INSTRUCTION:
<blue>		return nested_cpu_has(vmcs12, CPU_BASED_PAUSE_EXITING) ||</blue>
<yellow>			nested_cpu_has2(vmcs12,</yellow>
				SECONDARY_EXEC_PAUSE_LOOP_EXITING);
	case EXIT_REASON_MCE_DURING_VMENTRY:
		return true;
	case EXIT_REASON_TPR_BELOW_THRESHOLD:
<blue>		return nested_cpu_has(vmcs12, CPU_BASED_TPR_SHADOW);</blue>
	case EXIT_REASON_APIC_ACCESS:
	case EXIT_REASON_APIC_WRITE:
	case EXIT_REASON_EOI_INDUCED:
		/*
		 * The controls for &quot;virtualize APIC accesses,&quot; &quot;APIC-
		 * register virtualization,&quot; and &quot;virtual-interrupt
		 * delivery&quot; only come from vmcs12.
		 */
		return true;
	case EXIT_REASON_INVPCID:
		return
<blue>			nested_cpu_has2(vmcs12, SECONDARY_EXEC_ENABLE_INVPCID) &&</blue>
<blue>			nested_cpu_has(vmcs12, CPU_BASED_INVLPG_EXITING);</blue>
	case EXIT_REASON_WBINVD:
<blue>		return nested_cpu_has2(vmcs12, SECONDARY_EXEC_WBINVD_EXITING);</blue>
	case EXIT_REASON_XSETBV:
		return true;
	case EXIT_REASON_XSAVES: case EXIT_REASON_XRSTORS:
		/*
		 * This should never happen, since it is not possible to
		 * set XSS to a non-zero value---neither in L1 nor in L2.
		 * If if it were, XSS would have to be checked against
		 * the XSS exit bitmap in vmcs12.
		 */
<yellow>		return nested_cpu_has2(vmcs12, SECONDARY_EXEC_XSAVES);</yellow>
	case EXIT_REASON_UMWAIT:
	case EXIT_REASON_TPAUSE:
<yellow>		return nested_cpu_has2(vmcs12,</yellow>
			SECONDARY_EXEC_ENABLE_USR_WAIT_PAUSE);
	case EXIT_REASON_ENCLS:
<yellow>		return nested_vmx_exit_handled_encls(vcpu, vmcs12);</yellow>
	case EXIT_REASON_NOTIFY:
		/* Notify VM exit is not exposed to L1 */
		return false;
	default:
		return true;
	}
}

/*
 * Conditionally reflect a VM-Exit into L1.  Returns %true if the VM-Exit was
 * reflected into L1.
 */
bool nested_vmx_reflect_vmexit(struct kvm_vcpu *vcpu)
<blue>{</blue>
	struct vcpu_vmx *vmx = to_vmx(vcpu);
<blue>	union vmx_exit_reason exit_reason = vmx->exit_reason;</blue>
	unsigned long exit_qual;
	u32 exit_intr_info;

<blue>	WARN_ON_ONCE(vmx->nested.nested_run_pending);</blue>

	/*
	 * Late nested VM-Fail shares the same flow as nested VM-Exit since KVM
	 * has already loaded L2&#x27;s state.
	 */
<blue>	if (unlikely(vmx->fail)) {</blue>
<blue>		trace_kvm_nested_vmenter_failed(</blue>
			&quot;hardware VM-instruction error: &quot;,
			vmcs_read32(VM_INSTRUCTION_ERROR));
		exit_intr_info = 0;
		exit_qual = 0;
		goto reflect_vmexit;
	}

<blue>	trace_kvm_nested_vmexit(vcpu, KVM_ISA_VMX);</blue>

	/* If L0 (KVM) wants the exit, it trumps L1&#x27;s desires. */
<blue>	if (nested_vmx_l0_wants_exit(vcpu, exit_reason))</blue>
		return false;

	/* If L1 doesn&#x27;t want the exit, handle it in L0. */
<blue>	if (!nested_vmx_l1_wants_exit(vcpu, exit_reason))</blue>
		return false;

	/*
	 * vmcs.VM_EXIT_INTR_INFO is only valid for EXCEPTION_NMI exits.  For
	 * EXTERNAL_INTERRUPT, the value for vmcs12-&gt;vm_exit_intr_info would
	 * need to be synthesized by querying the in-kernel LAPIC, but external
	 * interrupts are never reflected to L1 so it&#x27;s a non-issue.
	 */
<blue>	exit_intr_info = vmx_get_intr_info(vcpu);</blue>
	if (is_exception_with_error_code(exit_intr_info)) {
<blue>		struct vmcs12 *vmcs12 = get_vmcs12(vcpu);</blue>

<blue>		vmcs12->vm_exit_intr_error_code =</blue>
<blue>			vmcs_read32(VM_EXIT_INTR_ERROR_CODE);</blue>
	}
<blue>	exit_qual = vmx_get_exit_qual(vcpu);</blue>

reflect_vmexit:
<blue>	nested_vmx_vmexit(vcpu, exit_reason.full, exit_intr_info, exit_qual);</blue>
	return true;
}

static int vmx_get_nested_state(struct kvm_vcpu *vcpu,
				struct kvm_nested_state __user *user_kvm_nested_state,
				u32 user_data_size)
<blue>{</blue>
	struct vcpu_vmx *vmx;
	struct vmcs12 *vmcs12;
<blue>	struct kvm_nested_state kvm_state = {</blue>
		.flags = 0,
		.format = KVM_STATE_NESTED_FORMAT_VMX,
		.size = sizeof(kvm_state),
		.hdr.vmx.flags = 0,
		.hdr.vmx.vmxon_pa = INVALID_GPA,
		.hdr.vmx.vmcs12_pa = INVALID_GPA,
		.hdr.vmx.preemption_timer_deadline = 0,
	};
	struct kvm_vmx_nested_state_data __user *user_vmx_nested_state =
		&amp;user_kvm_nested_state-&gt;data.vmx[0];

	if (!vcpu)
		return kvm_state.size + sizeof(*user_vmx_nested_state);

	vmx = to_vmx(vcpu);
<blue>	vmcs12 = get_vmcs12(vcpu);</blue>

	if (nested_vmx_allowed(vcpu) &amp;&amp;
<blue>	    (vmx->nested.vmxon || vmx->nested.smm.vmxon)) {</blue>
<blue>		kvm_state.hdr.vmx.vmxon_pa = vmx->nested.vmxon_ptr;</blue>
		kvm_state.hdr.vmx.vmcs12_pa = vmx-&gt;nested.current_vmptr;

<blue>		if (vmx_has_valid_vmcs12(vcpu)) {</blue>
<blue>			kvm_state.size += sizeof(user_vmx_nested_state->vmcs12);</blue>

			/* &#x27;hv_evmcs_vmptr&#x27; can also be EVMPTR_MAP_PENDING here */
			if (vmx-&gt;nested.hv_evmcs_vmptr != EVMPTR_INVALID)
<yellow>				kvm_state.flags |= KVM_STATE_NESTED_EVMCS;</yellow>

<blue>			if (is_guest_mode(vcpu) &&</blue>
<blue>			    nested_cpu_has_shadow_vmcs(vmcs12) &&</blue>
<blue>			    vmcs12->vmcs_link_pointer != INVALID_GPA)</blue>
<blue>				kvm_state.size += sizeof(user_vmx_nested_state->shadow_vmcs12);</blue>
		}

<blue>		if (vmx->nested.smm.vmxon)</blue>
<yellow>			kvm_state.hdr.vmx.smm.flags |= KVM_STATE_NESTED_SMM_VMXON;</yellow>

<blue>		if (vmx->nested.smm.guest_mode)</blue>
<yellow>			kvm_state.hdr.vmx.smm.flags |= KVM_STATE_NESTED_SMM_GUEST_MODE;</yellow>

<blue>		if (is_guest_mode(vcpu)) {</blue>
			kvm_state.flags |= KVM_STATE_NESTED_GUEST_MODE;

<blue>			if (vmx->nested.nested_run_pending)</blue>
<yellow>				kvm_state.flags |= KVM_STATE_NESTED_RUN_PENDING;</yellow>

<blue>			if (vmx->nested.mtf_pending)</blue>
<yellow>				kvm_state.flags |= KVM_STATE_NESTED_MTF_PENDING;</yellow>

<blue>			if (nested_cpu_has_preemption_timer(vmcs12) &&</blue>
<blue>			    vmx->nested.has_preemption_timer_deadline) {</blue>
				kvm_state.hdr.vmx.flags |=
					KVM_STATE_VMX_PREEMPTION_TIMER_DEADLINE;
				kvm_state.hdr.vmx.preemption_timer_deadline =
<blue>					vmx->nested.preemption_timer_deadline;</blue>
			}
		}
	}

<blue>	if (user_data_size < kvm_state.size)</blue>
		goto out;

<blue>	if (copy_to_user(user_kvm_nested_state, &kvm_state, sizeof(kvm_state)))</blue>
		return -EFAULT;

<blue>	if (!vmx_has_valid_vmcs12(vcpu))</blue>
		goto out;

	/*
	 * When running L2, the authoritative vmcs12 state is in the
	 * vmcs02. When running L1, the authoritative vmcs12 state is
	 * in the shadow or enlightened vmcs linked to vmcs01, unless
	 * need_vmcs12_to_shadow_sync is set, in which case, the authoritative
	 * vmcs12 state is in the vmcs12 already.
	 */
<blue>	if (is_guest_mode(vcpu)) {</blue>
<blue>		sync_vmcs02_to_vmcs12(vcpu, vmcs12);</blue>
		sync_vmcs02_to_vmcs12_rare(vcpu, vmcs12);
	} else  {
<blue>		copy_vmcs02_to_vmcs12_rare(vcpu, get_vmcs12(vcpu));</blue>
<blue>		if (!vmx->nested.need_vmcs12_to_shadow_sync) {</blue>
<blue>			if (evmptr_is_valid(vmx->nested.hv_evmcs_vmptr))</blue>
				/*
				 * L1 hypervisor is not obliged to keep eVMCS
				 * clean fields data always up-to-date while
				 * not in guest mode, &#x27;hv_clean_fields&#x27; is only
				 * supposed to be actual upon vmentry so we need
				 * to ignore it here and do full copy.
				 */
<yellow>				copy_enlightened_to_vmcs12(vmx, 0);</yellow>
<blue>			else if (enable_shadow_vmcs)</blue>
<blue>				copy_shadow_to_vmcs12(vmx);</blue>
		}
	}

	BUILD_BUG_ON(sizeof(user_vmx_nested_state-&gt;vmcs12) &lt; VMCS12_SIZE);
	BUILD_BUG_ON(sizeof(user_vmx_nested_state-&gt;shadow_vmcs12) &lt; VMCS12_SIZE);

	/*
	 * Copy over the full allocated size of vmcs12 rather than just the size
	 * of the struct.
	 */
<blue>	if (copy_to_user(user_vmx_nested_state->vmcs12, vmcs12, VMCS12_SIZE))</blue>
		return -EFAULT;

<blue>	if (nested_cpu_has_shadow_vmcs(vmcs12) &&</blue>
<blue>	    vmcs12->vmcs_link_pointer != INVALID_GPA) {</blue>
		if (copy_to_user(user_vmx_nested_state-&gt;shadow_vmcs12,
<blue>				 get_shadow_vmcs12(vcpu), VMCS12_SIZE))</blue>
			return -EFAULT;
	}
out:
<blue>	return kvm_state.size;</blue>
}

void vmx_leave_nested(struct kvm_vcpu *vcpu)
{
<blue>	if (is_guest_mode(vcpu)) {</blue>
<yellow>		to_vmx(vcpu)->nested.nested_run_pending = 0;</yellow>
		nested_vmx_vmexit(vcpu, -1, 0, 0);
	}
<blue>	free_nested(vcpu);</blue>
}

static int vmx_set_nested_state(struct kvm_vcpu *vcpu,
				struct kvm_nested_state __user *user_kvm_nested_state,
				struct kvm_nested_state *kvm_state)
<blue>{</blue>
	struct vcpu_vmx *vmx = to_vmx(vcpu);
	struct vmcs12 *vmcs12;
	enum vm_entry_failure_code ignored;
	struct kvm_vmx_nested_state_data __user *user_vmx_nested_state =
		&amp;user_kvm_nested_state-&gt;data.vmx[0];
	int ret;

<blue>	if (kvm_state->format != KVM_STATE_NESTED_FORMAT_VMX)</blue>
		return -EINVAL;

<blue>	if (kvm_state->hdr.vmx.vmxon_pa == INVALID_GPA) {</blue>
<blue>		if (kvm_state->hdr.vmx.smm.flags)</blue>
			return -EINVAL;

<blue>		if (kvm_state->hdr.vmx.vmcs12_pa != INVALID_GPA)</blue>
			return -EINVAL;

		/*
		 * KVM_STATE_NESTED_EVMCS used to signal that KVM should
		 * enable eVMCS capability on vCPU. However, since then
		 * code was changed such that flag signals vmcs12 should
		 * be copied into eVMCS in guest memory.
		 *
		 * To preserve backwards compatability, allow user
		 * to set this flag even when there is no VMXON region.
		 */
<blue>		if (kvm_state->flags & ~KVM_STATE_NESTED_EVMCS)</blue>
			return -EINVAL;
	} else {
<blue>		if (!nested_vmx_allowed(vcpu))</blue>
			return -EINVAL;

<blue>		if (!page_address_valid(vcpu, kvm_state->hdr.vmx.vmxon_pa))</blue>
			return -EINVAL;
	}

<blue>	if ((kvm_state->hdr.vmx.smm.flags & KVM_STATE_NESTED_SMM_GUEST_MODE) &&</blue>
<yellow>	    (kvm_state->flags & KVM_STATE_NESTED_GUEST_MODE))</yellow>
		return -EINVAL;

<blue>	if (kvm_state->hdr.vmx.smm.flags &</blue>
	    ~(KVM_STATE_NESTED_SMM_GUEST_MODE | KVM_STATE_NESTED_SMM_VMXON))
		return -EINVAL;

<blue>	if (kvm_state->hdr.vmx.flags & ~KVM_STATE_VMX_PREEMPTION_TIMER_DEADLINE)</blue>
		return -EINVAL;

	/*
	 * SMM temporarily disables VMX, so we cannot be in guest mode,
	 * nor can VMLAUNCH/VMRESUME be pending.  Outside SMM, SMM flags
	 * must be zero.
	 */
<blue>	if (is_smm(vcpu) ?</blue>
<blue>		(kvm_state->flags &</blue>
		 (KVM_STATE_NESTED_GUEST_MODE | KVM_STATE_NESTED_RUN_PENDING))
		: kvm_state-&gt;hdr.vmx.smm.flags)
		return -EINVAL;

<blue>	if ((kvm_state->hdr.vmx.smm.flags & KVM_STATE_NESTED_SMM_GUEST_MODE) &&</blue>
	    !(kvm_state-&gt;hdr.vmx.smm.flags &amp; KVM_STATE_NESTED_SMM_VMXON))
		return -EINVAL;

<blue>	if ((kvm_state->flags & KVM_STATE_NESTED_EVMCS) &&</blue>
<blue>		(!nested_vmx_allowed(vcpu) || !vmx->nested.enlightened_vmcs_enabled))</blue>
			return -EINVAL;

<blue>	vmx_leave_nested(vcpu);</blue>

	if (kvm_state-&gt;hdr.vmx.vmxon_pa == INVALID_GPA)
		return 0;

<blue>	vmx->nested.vmxon_ptr = kvm_state->hdr.vmx.vmxon_pa;</blue>
	ret = enter_vmx_operation(vcpu);
	if (ret)
		return ret;

	/* Empty &#x27;VMXON&#x27; state is permitted if no VMCS loaded */
<blue>	if (kvm_state->size < sizeof(*kvm_state) + sizeof(*vmcs12)) {</blue>
		/* See vmx_has_valid_vmcs12.  */
<blue>		if ((kvm_state->flags & KVM_STATE_NESTED_GUEST_MODE) ||</blue>
		    (kvm_state-&gt;flags &amp; KVM_STATE_NESTED_EVMCS) ||
<blue>		    (kvm_state->hdr.vmx.vmcs12_pa != INVALID_GPA))</blue>
			return -EINVAL;
		else
			return 0;
	}

<blue>	if (kvm_state->hdr.vmx.vmcs12_pa != INVALID_GPA) {</blue>
<blue>		if (kvm_state->hdr.vmx.vmcs12_pa == kvm_state->hdr.vmx.vmxon_pa ||</blue>
<blue>		    !page_address_valid(vcpu, kvm_state->hdr.vmx.vmcs12_pa))</blue>
			return -EINVAL;

<blue>		set_current_vmptr(vmx, kvm_state->hdr.vmx.vmcs12_pa);</blue>
<blue>	} else if (kvm_state->flags & KVM_STATE_NESTED_EVMCS) {</blue>
		/*
		 * nested_vmx_handle_enlightened_vmptrld() cannot be called
		 * directly from here as HV_X64_MSR_VP_ASSIST_PAGE may not be
		 * restored yet. EVMCS will be mapped from
		 * nested_get_vmcs12_pages().
		 */
<yellow>		vmx->nested.hv_evmcs_vmptr = EVMPTR_MAP_PENDING;</yellow>
		kvm_make_request(KVM_REQ_GET_NESTED_STATE_PAGES, vcpu);
	} else {
		return -EINVAL;
	}

<blue>	if (kvm_state->hdr.vmx.smm.flags & KVM_STATE_NESTED_SMM_VMXON) {</blue>
<yellow>		vmx->nested.smm.vmxon = true;</yellow>
		vmx-&gt;nested.vmxon = false;

		if (kvm_state-&gt;hdr.vmx.smm.flags &amp; KVM_STATE_NESTED_SMM_GUEST_MODE)
<yellow>			vmx->nested.smm.guest_mode = true;</yellow>
	}

<blue>	vmcs12 = get_vmcs12(vcpu);</blue>
	if (copy_from_user(vmcs12, user_vmx_nested_state-&gt;vmcs12, sizeof(*vmcs12)))
		return -EFAULT;

<blue>	if (vmcs12->hdr.revision_id != VMCS12_REVISION)</blue>
		return -EINVAL;

<blue>	if (!(kvm_state->flags & KVM_STATE_NESTED_GUEST_MODE))</blue>
		return 0;

<yellow>	vmx->nested.nested_run_pending =</yellow>
		!!(kvm_state-&gt;flags &amp; KVM_STATE_NESTED_RUN_PENDING);

	vmx-&gt;nested.mtf_pending =
		!!(kvm_state-&gt;flags &amp; KVM_STATE_NESTED_MTF_PENDING);

	ret = -EINVAL;
<yellow>	if (nested_cpu_has_shadow_vmcs(vmcs12) &&</yellow>
<yellow>	    vmcs12->vmcs_link_pointer != INVALID_GPA) {</yellow>
<yellow>		struct vmcs12 *shadow_vmcs12 = get_shadow_vmcs12(vcpu);</yellow>

		if (kvm_state-&gt;size &lt;
		    sizeof(*kvm_state) +
		    sizeof(user_vmx_nested_state-&gt;vmcs12) + sizeof(*shadow_vmcs12))
			goto error_guest_mode;

		if (copy_from_user(shadow_vmcs12,
<yellow>				   user_vmx_nested_state->shadow_vmcs12,</yellow>
				   sizeof(*shadow_vmcs12))) {
			ret = -EFAULT;
			goto error_guest_mode;
		}

<yellow>		if (shadow_vmcs12->hdr.revision_id != VMCS12_REVISION ||</yellow>
<yellow>		    !shadow_vmcs12->hdr.shadow_vmcs)</yellow>
			goto error_guest_mode;
	}

<yellow>	vmx->nested.has_preemption_timer_deadline = false;</yellow>
	if (kvm_state-&gt;hdr.vmx.flags &amp; KVM_STATE_VMX_PREEMPTION_TIMER_DEADLINE) {
		vmx-&gt;nested.has_preemption_timer_deadline = true;
		vmx-&gt;nested.preemption_timer_deadline =
<yellow>			kvm_state->hdr.vmx.preemption_timer_deadline;</yellow>
	}

<yellow>	if (nested_vmx_check_controls(vcpu, vmcs12) ||</yellow>
<yellow>	    nested_vmx_check_host_state(vcpu, vmcs12) ||</yellow>
<yellow>	    nested_vmx_check_guest_state(vcpu, vmcs12, &ignored))</yellow>
		goto error_guest_mode;

<yellow>	vmx->nested.dirty_vmcs12 = true;</yellow>
	vmx-&gt;nested.force_msr_bitmap_recalc = true;
	ret = nested_vmx_enter_non_root_mode(vcpu, false);
	if (ret)
		goto error_guest_mode;

<yellow>	if (vmx->nested.mtf_pending)</yellow>
<yellow>		kvm_make_request(KVM_REQ_EVENT, vcpu);</yellow>

	return 0;

error_guest_mode:
<yellow>	vmx->nested.nested_run_pending = 0;</yellow>
	return ret;
}

void nested_vmx_set_vmcs_shadowing_bitmap(void)
{
<blue>	if (enable_shadow_vmcs) {</blue>
<blue>		vmcs_write64(VMREAD_BITMAP, __pa(vmx_vmread_bitmap));</blue>
<blue>		vmcs_write64(VMWRITE_BITMAP, __pa(vmx_vmwrite_bitmap));</blue>
	}
<blue>}</blue>

/*
 * Indexing into the vmcs12 uses the VMCS encoding rotated left by 6.  Undo
 * that madness to get the encoding for comparison.
 */
#define VMCS12_IDX_TO_ENC(idx) ((u16)(((u16)(idx) &gt;&gt; 6) | ((u16)(idx) &lt;&lt; 10)))

static u64 nested_vmx_calc_vmcs_enum_msr(void)
{
	/*
	 * Note these are the so called &quot;index&quot; of the VMCS field encoding, not
	 * the index into vmcs12.
	 */
	unsigned int max_idx, idx;
	int i;

	/*
	 * For better or worse, KVM allows VMREAD/VMWRITE to all fields in
	 * vmcs12, regardless of whether or not the associated feature is
	 * exposed to L1.  Simply find the field with the highest index.
	 */
	max_idx = 0;
<yellow>	for (i = 0; i < nr_vmcs12_fields; i++) {</yellow>
		/* The vmcs12 table is very, very sparsely populated. */
<yellow>		if (!vmcs12_field_offsets[i])</yellow>
			continue;

<yellow>		idx = vmcs_field_index(VMCS12_IDX_TO_ENC(i));</yellow>
		if (idx &gt; max_idx)
			max_idx = idx;
	}

<yellow>	return (u64)max_idx << VMCS_FIELD_INDEX_SHIFT;</yellow>
}

/*
 * nested_vmx_setup_ctls_msrs() sets up variables containing the values to be
 * returned for the various VMX controls MSRs when nested VMX is enabled.
 * The same values should also be used to verify that vmcs12 control fields are
 * valid during nested entry from L1 to L2.
 * Each of these control msrs has a low and high 32-bit half: A low bit is on
 * if the corresponding bit in the (32-bit) control field *must* be on, and a
 * bit in the high half is on if the corresponding bit in the control field
 * may be on. See also vmx_control_verify().
 */
void nested_vmx_setup_ctls_msrs(struct vmcs_config *vmcs_conf, u32 ept_caps)
{
	struct nested_vmx_msrs *msrs = &amp;vmcs_conf-&gt;nested;

	/*
	 * Note that as a general rule, the high half of the MSRs (bits in
	 * the control fields which may be 1) should be initialized by the
	 * intersection of the underlying hardware&#x27;s MSR (i.e., features which
	 * can be supported) and the list of features we want to expose -
	 * because they are known to be properly supported in our code.
	 * Also, usually, the low half of the MSRs (bits which must be 1) can
	 * be set to 0, meaning that L1 may turn off any of these bits. The
	 * reason is that if one of these bits is necessary, it will appear
	 * in vmcs01 and prepare_vmcs02, when it bitwise-or&#x27;s the control
	 * fields of vmcs01 and vmcs02, will turn these bits off - and
	 * nested_vmx_l1_wants_exit() will not pass related exits to L1.
	 * These rules have exceptions below.
	 */

	/* pin-based controls */
<yellow>	msrs->pinbased_ctls_low =</yellow>
		PIN_BASED_ALWAYSON_WITHOUT_TRUE_MSR;

	msrs-&gt;pinbased_ctls_high = vmcs_conf-&gt;pin_based_exec_ctrl;
<yellow>	msrs->pinbased_ctls_high &=</yellow>
		PIN_BASED_EXT_INTR_MASK |
		PIN_BASED_NMI_EXITING |
		PIN_BASED_VIRTUAL_NMIS |
		(enable_apicv ? PIN_BASED_POSTED_INTR : 0);
<yellow>	msrs->pinbased_ctls_high |=</yellow>
		PIN_BASED_ALWAYSON_WITHOUT_TRUE_MSR |
		PIN_BASED_VMX_PREEMPTION_TIMER;

	/* exit controls */
	msrs-&gt;exit_ctls_low =
		VM_EXIT_ALWAYSON_WITHOUT_TRUE_MSR;

	msrs-&gt;exit_ctls_high = vmcs_conf-&gt;vmexit_ctrl;
	msrs-&gt;exit_ctls_high &amp;=
#ifdef CONFIG_X86_64
		VM_EXIT_HOST_ADDR_SPACE_SIZE |
#endif
		VM_EXIT_LOAD_IA32_PAT | VM_EXIT_SAVE_IA32_PAT |
		VM_EXIT_CLEAR_BNDCFGS;
	msrs-&gt;exit_ctls_high |=
		VM_EXIT_ALWAYSON_WITHOUT_TRUE_MSR |
		VM_EXIT_LOAD_IA32_EFER | VM_EXIT_SAVE_IA32_EFER |
		VM_EXIT_SAVE_VMX_PREEMPTION_TIMER | VM_EXIT_ACK_INTR_ON_EXIT |
		VM_EXIT_LOAD_IA32_PERF_GLOBAL_CTRL;

	/* We support free control of debug control saving. */
	msrs-&gt;exit_ctls_low &amp;= ~VM_EXIT_SAVE_DEBUG_CONTROLS;

	/* entry controls */
	msrs-&gt;entry_ctls_low =
		VM_ENTRY_ALWAYSON_WITHOUT_TRUE_MSR;

	msrs-&gt;entry_ctls_high = vmcs_conf-&gt;vmentry_ctrl;
	msrs-&gt;entry_ctls_high &amp;=
#ifdef CONFIG_X86_64
		VM_ENTRY_IA32E_MODE |
#endif
		VM_ENTRY_LOAD_IA32_PAT | VM_ENTRY_LOAD_BNDCFGS;
	msrs-&gt;entry_ctls_high |=
		(VM_ENTRY_ALWAYSON_WITHOUT_TRUE_MSR | VM_ENTRY_LOAD_IA32_EFER |
		 VM_ENTRY_LOAD_IA32_PERF_GLOBAL_CTRL);

	/* We support free control of debug control loading. */
	msrs-&gt;entry_ctls_low &amp;= ~VM_ENTRY_LOAD_DEBUG_CONTROLS;

	/* cpu-based controls */
	msrs-&gt;procbased_ctls_low =
		CPU_BASED_ALWAYSON_WITHOUT_TRUE_MSR;

	msrs-&gt;procbased_ctls_high = vmcs_conf-&gt;cpu_based_exec_ctrl;
	msrs-&gt;procbased_ctls_high &amp;=
		CPU_BASED_INTR_WINDOW_EXITING |
		CPU_BASED_NMI_WINDOW_EXITING | CPU_BASED_USE_TSC_OFFSETTING |
		CPU_BASED_HLT_EXITING | CPU_BASED_INVLPG_EXITING |
		CPU_BASED_MWAIT_EXITING | CPU_BASED_CR3_LOAD_EXITING |
		CPU_BASED_CR3_STORE_EXITING |
#ifdef CONFIG_X86_64
		CPU_BASED_CR8_LOAD_EXITING | CPU_BASED_CR8_STORE_EXITING |
#endif
		CPU_BASED_MOV_DR_EXITING | CPU_BASED_UNCOND_IO_EXITING |
		CPU_BASED_USE_IO_BITMAPS | CPU_BASED_MONITOR_TRAP_FLAG |
		CPU_BASED_MONITOR_EXITING | CPU_BASED_RDPMC_EXITING |
		CPU_BASED_RDTSC_EXITING | CPU_BASED_PAUSE_EXITING |
		CPU_BASED_TPR_SHADOW | CPU_BASED_ACTIVATE_SECONDARY_CONTROLS;
	/*
	 * We can allow some features even when not supported by the
	 * hardware. For example, L1 can specify an MSR bitmap - and we
	 * can use it to avoid exits to L1 - even when L0 runs L2
	 * without MSR bitmaps.
	 */
	msrs-&gt;procbased_ctls_high |=
		CPU_BASED_ALWAYSON_WITHOUT_TRUE_MSR |
		CPU_BASED_USE_MSR_BITMAPS;

	/* We support free control of CR3 access interception. */
	msrs-&gt;procbased_ctls_low &amp;=
		~(CPU_BASED_CR3_LOAD_EXITING | CPU_BASED_CR3_STORE_EXITING);

	/*
	 * secondary cpu-based controls.  Do not include those that
	 * depend on CPUID bits, they are added later by
	 * vmx_vcpu_after_set_cpuid.
	 */
	msrs-&gt;secondary_ctls_low = 0;

	msrs-&gt;secondary_ctls_high = vmcs_conf-&gt;cpu_based_2nd_exec_ctrl;
	msrs-&gt;secondary_ctls_high &amp;=
		SECONDARY_EXEC_DESC |
		SECONDARY_EXEC_ENABLE_RDTSCP |
		SECONDARY_EXEC_VIRTUALIZE_X2APIC_MODE |
		SECONDARY_EXEC_WBINVD_EXITING |
		SECONDARY_EXEC_APIC_REGISTER_VIRT |
		SECONDARY_EXEC_VIRTUAL_INTR_DELIVERY |
		SECONDARY_EXEC_RDRAND_EXITING |
		SECONDARY_EXEC_ENABLE_INVPCID |
		SECONDARY_EXEC_RDSEED_EXITING |
		SECONDARY_EXEC_XSAVES |
		SECONDARY_EXEC_TSC_SCALING;

	/*
	 * We can emulate &quot;VMCS shadowing,&quot; even if the hardware
	 * doesn&#x27;t support it.
	 */
	msrs-&gt;secondary_ctls_high |=
		SECONDARY_EXEC_SHADOW_VMCS;

<yellow>	if (enable_ept) {</yellow>
		/* nested EPT: emulate EPT also to L1 */
<yellow>		msrs->secondary_ctls_high |=</yellow>
			SECONDARY_EXEC_ENABLE_EPT;
		msrs-&gt;ept_caps =
			VMX_EPT_PAGE_WALK_4_BIT |
			VMX_EPT_PAGE_WALK_5_BIT |
			VMX_EPTP_WB_BIT |
			VMX_EPT_INVEPT_BIT |
			VMX_EPT_EXECUTE_ONLY_BIT;

		msrs-&gt;ept_caps &amp;= ept_caps;
		msrs-&gt;ept_caps |= VMX_EPT_EXTENT_GLOBAL_BIT |
			VMX_EPT_EXTENT_CONTEXT_BIT | VMX_EPT_2MB_PAGE_BIT |
			VMX_EPT_1GB_PAGE_BIT;
<yellow>		if (enable_ept_ad_bits) {</yellow>
<yellow>			msrs->secondary_ctls_high |=</yellow>
				SECONDARY_EXEC_ENABLE_PML;
			msrs-&gt;ept_caps |= VMX_EPT_AD_BIT;
		}
	}

<yellow>	if (cpu_has_vmx_vmfunc()) {</yellow>
<yellow>		msrs->secondary_ctls_high |=</yellow>
			SECONDARY_EXEC_ENABLE_VMFUNC;
		/*
		 * Advertise EPTP switching unconditionally
		 * since we emulate it
		 */
<yellow>		if (enable_ept)</yellow>
<yellow>			msrs->vmfunc_controls =</yellow>
				VMX_VMFUNC_EPTP_SWITCHING;
	}

	/*
	 * Old versions of KVM use the single-context version without
	 * checking for support, so declare that it is supported even
	 * though it is treated as global context.  The alternative is
	 * not failing the single-context invvpid, and it is worse.
	 */
<yellow>	if (enable_vpid) {</yellow>
<yellow>		msrs->secondary_ctls_high |=</yellow>
			SECONDARY_EXEC_ENABLE_VPID;
		msrs-&gt;vpid_caps = VMX_VPID_INVVPID_BIT |
			VMX_VPID_EXTENT_SUPPORTED_MASK;
	}

<yellow>	if (enable_unrestricted_guest)</yellow>
<yellow>		msrs->secondary_ctls_high |=</yellow>
			SECONDARY_EXEC_UNRESTRICTED_GUEST;

<yellow>	if (flexpriority_enabled)</yellow>
<yellow>		msrs->secondary_ctls_high |=</yellow>
			SECONDARY_EXEC_VIRTUALIZE_APIC_ACCESSES;

<yellow>	if (enable_sgx)</yellow>
<yellow>		msrs->secondary_ctls_high |= SECONDARY_EXEC_ENCLS_EXITING;</yellow>

	/* miscellaneous data */
<yellow>	msrs->misc_low = (u32)vmcs_conf->misc & VMX_MISC_SAVE_EFER_LMA;</yellow>
	msrs-&gt;misc_low |=
		MSR_IA32_VMX_MISC_VMWRITE_SHADOW_RO_FIELDS |
		VMX_MISC_EMULATED_PREEMPTION_TIMER_RATE |
		VMX_MISC_ACTIVITY_HLT |
		VMX_MISC_ACTIVITY_WAIT_SIPI;
	msrs-&gt;misc_high = 0;

	/*
	 * This MSR reports some information about VMX support. We
	 * should return information about the VMX we emulate for the
	 * guest, and the VMCS structure we give it - not about the
	 * VMX support of the underlying hardware.
	 */
	msrs-&gt;basic =
		VMCS12_REVISION |
		VMX_BASIC_TRUE_CTLS |
		((u64)VMCS12_SIZE &lt;&lt; VMX_BASIC_VMCS_SIZE_SHIFT) |
		(VMX_BASIC_MEM_TYPE_WB &lt;&lt; VMX_BASIC_MEM_TYPE_SHIFT);

	if (cpu_has_vmx_basic_inout())
<yellow>		msrs->basic |= VMX_BASIC_INOUT;</yellow>

	/*
	 * These MSRs specify bits which the guest must keep fixed on
	 * while L1 is in VMXON mode (in L1&#x27;s root mode, or running an L2).
	 * We picked the standard core2 setting.
	 */
#define VMXON_CR0_ALWAYSON     (X86_CR0_PE | X86_CR0_PG | X86_CR0_NE)
#define VMXON_CR4_ALWAYSON     X86_CR4_VMXE
	msrs-&gt;cr0_fixed0 = VMXON_CR0_ALWAYSON;
	msrs-&gt;cr4_fixed0 = VMXON_CR4_ALWAYSON;

	/* These MSRs specify bits which the guest must keep fixed off. */
	rdmsrl(MSR_IA32_VMX_CR0_FIXED1, msrs-&gt;cr0_fixed1);
	rdmsrl(MSR_IA32_VMX_CR4_FIXED1, msrs-&gt;cr4_fixed1);

	if (vmx_umip_emulated())
<yellow>		msrs->cr4_fixed1 |= X86_CR4_UMIP;</yellow>

<yellow>	msrs->vmcs_enum = nested_vmx_calc_vmcs_enum_msr();</yellow>
}

<yellow>void nested_vmx_hardware_unsetup(void)</yellow>
{
	int i;

<yellow>	if (enable_shadow_vmcs) {</yellow>
		for (i = 0; i &lt; VMX_BITMAP_NR; i++)
<yellow>			free_page((unsigned long)vmx_bitmap[i]);</yellow>
	}
<yellow>}</yellow>

__init int nested_vmx_hardware_setup(int (*exit_handlers[])(struct kvm_vcpu *))
{
	int i;

	if (!cpu_has_vmx_shadow_vmcs())
		enable_shadow_vmcs = 0;
	if (enable_shadow_vmcs) {
		for (i = 0; i &lt; VMX_BITMAP_NR; i++) {
			/*
			 * The vmx_bitmap is not tied to a VM and so should
			 * not be charged to a memcg.
			 */
			vmx_bitmap[i] = (unsigned long *)
				__get_free_page(GFP_KERNEL);
			if (!vmx_bitmap[i]) {
				nested_vmx_hardware_unsetup();
				return -ENOMEM;
			}
		}

		init_vmcs_shadow_fields();
	}

	exit_handlers[EXIT_REASON_VMCLEAR]	= handle_vmclear;
	exit_handlers[EXIT_REASON_VMLAUNCH]	= handle_vmlaunch;
	exit_handlers[EXIT_REASON_VMPTRLD]	= handle_vmptrld;
	exit_handlers[EXIT_REASON_VMPTRST]	= handle_vmptrst;
	exit_handlers[EXIT_REASON_VMREAD]	= handle_vmread;
	exit_handlers[EXIT_REASON_VMRESUME]	= handle_vmresume;
	exit_handlers[EXIT_REASON_VMWRITE]	= handle_vmwrite;
	exit_handlers[EXIT_REASON_VMOFF]	= handle_vmxoff;
	exit_handlers[EXIT_REASON_VMON]		= handle_vmxon;
	exit_handlers[EXIT_REASON_INVEPT]	= handle_invept;
	exit_handlers[EXIT_REASON_INVVPID]	= handle_invvpid;
	exit_handlers[EXIT_REASON_VMFUNC]	= handle_vmfunc;

	return 0;
}

struct kvm_x86_nested_ops vmx_nested_ops = {
	.leave_nested = vmx_leave_nested,
	.is_exception_vmexit = nested_vmx_is_exception_vmexit,
	.check_events = vmx_check_nested_events,
	.has_events = vmx_has_nested_events,
	.triple_fault = nested_vmx_triple_fault,
	.get_state = vmx_get_nested_state,
	.set_state = vmx_set_nested_state,
	.get_nested_state_pages = vmx_get_nested_state_pages,
	.write_log_dirty = nested_vmx_write_pml_buffer,
	.enable_evmcs = nested_enable_evmcs,
	.get_evmcs_version = nested_get_evmcs_version,
};


</code></pre></td></tr></table>
</body>
</html>
