<doctype html>
<html lang="ja">
<head>
<meta charset="utf-8">
<script src="https://cdn.rawgit.com/google/code-prettify/master/loader/run_prettify.js"></script>
<style>
    code{
        font-family:Monaco, Menlo, Consolas, 'Courier New', Courier, monospace, sans-serif;
        font-size: 14px;
        line-height: 18px;
        overflow: auto;
        resize: horizontal;
    }
    code_line{
        font-family: Monaco, Menlo, Consolas, 'Courier New', Courier, monospace, sans-serif;;
        font-size: 14px;
        line-height: 18px;
        overflow: auto;
        resize: horizontal;
        color:#303134;
    }
    blue{
        background-color:#BEEDE8;
    }
    yellow{
        background-color:#FFFF99;
    }
    red{
        background-color:#FF99AC;
    }
</style>

</head>
<body>
<table summary='blob content' class='blob' cellspacing="15">
<tr><td align="right"><pre><code_line>1.<br>2.<br>3.<br>4.<br>5.<br>6.<br>7.<br>8.<br>9.<br>10.<br>11.<br>12.<br>13.<br>14.<br>15.<br>16.<br>17.<br>18.<br>19.<br>20.<br>21.<br>22.<br>23.<br>24.<br>25.<br>26.<br>27.<br>28.<br>29.<br>30.<br>31.<br>32.<br>33.<br>34.<br>35.<br>36.<br>37.<br>38.<br>39.<br>40.<br>41.<br>42.<br>43.<br>44.<br>45.<br>46.<br>47.<br>48.<br>49.<br>50.<br>51.<br>52.<br>53.<br>54.<br>55.<br>56.<br>57.<br>58.<br>59.<br>60.<br>61.<br>62.<br>63.<br>64.<br>65.<br>66.<br>67.<br>68.<br>69.<br>70.<br>71.<br>72.<br>73.<br>74.<br>75.<br>76.<br>77.<br>78.<br>79.<br>80.<br>81.<br>82.<br>83.<br>84.<br>85.<br>86.<br>87.<br>88.<br>89.<br>90.<br>91.<br>92.<br>93.<br>94.<br>95.<br>96.<br>97.<br>98.<br>99.<br>100.<br>101.<br>102.<br>103.<br>104.<br>105.<br>106.<br>107.<br>108.<br>109.<br>110.<br>111.<br>112.<br>113.<br>114.<br>115.<br>116.<br>117.<br>118.<br>119.<br>120.<br>121.<br>122.<br>123.<br>124.<br>125.<br>126.<br>127.<br>128.<br>129.<br>130.<br>131.<br>132.<br>133.<br>134.<br>135.<br>136.<br>137.<br>138.<br>139.<br>140.<br>141.<br>142.<br>143.<br>144.<br>145.<br>146.<br>147.<br>148.<br>149.<br>150.<br>151.<br>152.<br>153.<br>154.<br>155.<br>156.<br>157.<br>158.<br>159.<br>160.<br>161.<br>162.<br>163.<br>164.<br>165.<br>166.<br>167.<br>168.<br>169.<br>170.<br>171.<br>172.<br>173.<br>174.<br>175.<br>176.<br>177.<br>178.<br>179.<br>180.<br>181.<br>182.<br>183.<br>184.<br>185.<br>186.<br>187.<br>188.<br>189.<br>190.<br>191.<br>192.<br>193.<br>194.<br>195.<br>196.<br>197.<br>198.<br>199.<br>200.<br>201.<br>202.<br>203.<br>204.<br>205.<br>206.<br>207.<br>208.<br>209.<br>210.<br>211.<br>212.<br>213.<br>214.<br>215.<br>216.<br>217.<br>218.<br>219.<br>220.<br>221.<br>222.<br>223.<br>224.<br>225.<br>226.<br>227.<br>228.<br>229.<br>230.<br>231.<br>232.<br>233.<br>234.<br>235.<br>236.<br>237.<br>238.<br>239.<br>240.<br>241.<br>242.<br>243.<br>244.<br>245.<br>246.<br>247.<br>248.<br>249.<br>250.<br>251.<br>252.<br>253.<br>254.<br>255.<br>256.<br>257.<br>258.<br>259.<br>260.<br>261.<br>262.<br>263.<br>264.<br>265.<br>266.<br>267.<br>268.<br>269.<br>270.<br>271.<br>272.<br>273.<br>274.<br>275.<br>276.<br>277.<br>278.<br>279.<br>280.<br>281.<br>282.<br>283.<br>284.<br>285.<br>286.<br>287.<br>288.<br>289.<br>290.<br>291.<br>292.<br>293.<br>294.<br>295.<br>296.<br>297.<br>298.<br>299.<br>300.<br>301.<br>302.<br>303.<br>304.<br>305.<br>306.<br>307.<br>308.<br>309.<br>310.<br>311.<br>312.<br>313.<br>314.<br>315.<br>316.<br>317.<br>318.<br>319.<br>320.<br>321.<br>322.<br>323.<br>324.<br>325.<br>326.<br>327.<br>328.<br>329.<br>330.<br>331.<br>332.<br>333.<br>334.<br>335.<br>336.<br>337.<br>338.<br>339.<br>340.<br>341.<br>342.<br>343.<br>344.<br>345.<br>346.<br>347.<br>348.<br>349.<br>350.<br>351.<br>352.<br>353.<br>354.<br>355.<br>356.<br>357.<br>358.<br>359.<br>360.<br>361.<br>362.<br>363.<br>364.<br>365.<br>366.<br>367.<br>368.<br>369.<br>370.<br>371.<br>372.<br>373.<br>374.<br>375.<br>376.<br>377.<br>378.<br>379.<br>380.<br>381.<br>382.<br>383.<br>384.<br>385.<br>386.<br>387.<br>388.<br>389.<br>390.<br>391.<br>392.<br>393.<br>394.<br>395.<br>396.<br>397.<br>398.<br>399.<br>400.<br>401.<br>402.<br>403.<br>404.<br>405.<br>406.<br>407.<br>408.<br>409.<br>410.<br>411.<br>412.<br>413.<br>414.<br>415.<br>416.<br>417.<br>418.<br>419.<br>420.<br>421.<br>422.<br>423.<br>424.<br>425.<br>426.<br>427.<br>428.<br>429.<br>430.<br>431.<br>432.<br>433.<br>434.<br>435.<br>436.<br>437.<br>438.<br>439.<br>440.<br>441.<br>442.<br>443.<br>444.<br>445.<br>446.<br>447.<br>448.<br>449.<br>450.<br>451.<br>452.<br>453.<br>454.<br>455.<br>456.<br>457.<br>458.<br>459.<br>460.<br>461.<br>462.<br>463.<br>464.<br>465.<br>466.<br>467.<br>468.<br>469.<br>470.<br>471.<br>472.<br>473.<br>474.<br>475.<br>476.<br>477.<br>478.<br>479.<br>480.<br>481.<br>482.<br>483.<br>484.<br>485.<br>486.<br>487.<br>488.<br>489.<br>490.<br>491.<br>492.<br>493.<br>494.<br>495.<br>496.<br>497.<br>498.<br>499.<br>500.<br>501.<br>502.<br>503.<br>504.<br>505.<br>506.<br>507.<br>508.<br>509.<br>510.<br>511.<br>512.<br>513.<br>514.<br>515.<br>516.<br>517.<br>518.<br>519.<br>520.<br>521.<br>522.<br>523.<br>524.<br>525.<br>526.<br>527.<br>528.<br>529.<br>530.<br>531.<br>532.<br>533.<br>534.<br>535.<br>536.<br>537.<br>538.<br>539.<br>540.<br>541.<br>542.<br>543.<br>544.<br>545.<br>546.<br>547.<br>548.<br>549.<br>550.<br>551.<br>552.<br>553.<br>554.<br>555.<br>556.<br>557.<br>558.<br>559.<br>560.<br>561.<br>562.<br>563.<br>564.<br>565.<br>566.<br>567.<br>568.<br>569.<br>570.<br>571.<br>572.<br>573.<br>574.<br>575.<br>576.<br>577.<br>578.<br>579.<br>580.<br>581.<br>582.<br>583.<br>584.<br>585.<br>586.<br>587.<br>588.<br>589.<br>590.<br>591.<br>592.<br>593.<br>594.<br>595.<br>596.<br>597.<br>598.<br>599.<br>600.<br>601.<br>602.<br>603.<br>604.<br>605.<br>606.<br>607.<br>608.<br>609.<br>610.<br>611.<br>612.<br>613.<br>614.<br>615.<br>616.<br>617.<br>618.<br>619.<br>620.<br>621.<br>622.<br>623.<br>624.<br>625.<br>626.<br>627.<br>628.<br>629.<br>630.<br>631.<br>632.<br>633.<br>634.<br>635.<br>636.<br>637.<br>638.<br>639.<br>640.<br>641.<br>642.<br>643.<br>644.<br>645.<br>646.<br>647.<br>648.<br>649.<br>650.<br>651.<br>652.<br>653.<br>654.<br>655.<br>656.<br>657.<br>658.<br>659.<br>660.<br>661.<br>662.<br>663.<br>664.<br>665.<br>666.<br>667.<br>668.<br>669.<br>670.<br>671.<br>672.<br>673.<br>674.<br>675.<br>676.<br>677.<br>678.<br>679.<br>680.<br>681.<br>682.<br>683.<br>684.<br>685.<br>686.<br>687.<br>688.<br>689.<br>690.<br>691.<br>692.<br>693.<br>694.<br>695.<br>696.<br>697.<br>698.<br>699.<br>700.<br>701.<br>702.<br>703.<br>704.<br>705.<br>706.<br>707.<br>708.<br>709.<br>710.<br>711.<br>712.<br>713.<br>714.<br>715.<br>716.<br>717.<br>718.<br>719.<br>720.<br>721.<br>722.<br>723.<br>724.<br>725.<br>726.<br>727.<br>728.<br>729.<br>730.<br>731.<br>732.<br>733.<br>734.<br>735.<br>736.<br>737.<br>738.<br>739.<br>740.<br>741.<br>742.<br>743.<br>744.<br>745.<br>746.<br>747.<br>748.<br>749.<br>750.<br>751.<br>752.<br>753.<br>754.<br>755.<br>756.<br>757.<br>758.<br>759.<br>760.<br>761.<br>762.<br>763.<br>764.<br>765.<br>766.<br>767.<br>768.<br>769.<br>770.<br>771.<br>772.<br>773.<br>774.<br>775.<br>776.<br>777.<br>778.<br>779.<br>780.<br>781.<br>782.<br>783.<br>784.<br>785.<br>786.<br>787.<br>788.<br>789.<br>790.<br>791.<br>792.<br>793.<br>794.<br>795.<br>796.<br>797.<br>798.<br>799.<br>800.<br>801.<br>802.<br>803.<br>804.<br>805.<br>806.<br>807.<br>808.<br>809.<br>810.<br>811.<br>812.<br>813.<br>814.<br>815.<br>816.<br>817.<br>818.<br>819.<br>820.<br>821.<br>822.<br>823.<br>824.<br>825.<br>826.<br>827.<br>828.<br>829.<br>830.<br>831.<br>832.<br>833.<br>834.<br>835.<br>836.<br>837.<br>838.<br>839.<br>840.<br>841.<br>842.<br>843.<br>844.<br>845.<br>846.<br>847.<br>848.<br>849.<br>850.<br>851.<br>852.<br>853.<br>854.<br>855.<br>856.<br>857.<br>858.<br>859.<br>860.<br>861.<br>862.<br>863.<br>864.<br>865.<br>866.<br>867.<br>868.<br>869.<br>870.<br>871.<br>872.<br>873.<br>874.<br>875.<br>876.<br>877.<br>878.<br>879.<br>880.<br>881.<br>882.<br>883.<br>884.<br>885.<br>886.<br>887.<br>888.<br>889.<br>890.<br>891.<br>892.<br>893.<br>894.<br>895.<br>896.<br>897.<br>898.<br>899.<br>900.<br>901.<br>902.<br>903.<br>904.<br>905.<br>906.<br>907.<br>908.<br>909.<br>910.<br>911.<br>912.<br>913.<br>914.<br>915.<br>916.<br>917.<br>918.<br>919.<br>920.<br>921.<br>922.<br>923.<br>924.<br>925.<br>926.<br>927.<br>928.<br>929.<br>930.<br>931.<br>932.<br>933.<br>934.<br>935.<br>936.<br>937.<br>938.<br>939.<br>940.<br>941.<br>942.<br>943.<br>944.<br>945.<br>946.<br>947.<br>948.<br>949.<br>950.<br>951.<br>952.<br>953.<br>954.<br>955.<br>956.<br>957.<br>958.<br>959.<br>960.<br>961.<br>962.<br>963.<br>964.<br>965.<br>966.<br>967.<br>968.<br>969.<br>970.<br>971.<br>972.<br>973.<br>974.<br>975.<br>976.<br>977.<br>978.<br>979.<br>980.<br>981.<br>982.<br>983.<br>984.<br>985.<br>986.<br>987.<br>988.<br>989.<br>990.<br>991.<br>992.<br>993.<br>994.<br>995.<br>996.<br>997.<br>998.<br>999.<br>1000.<br>1001.<br>1002.<br>1003.<br>1004.<br>1005.<br>1006.<br>1007.<br>1008.<br>1009.<br>1010.<br>1011.<br>1012.<br>1013.<br>1014.<br>1015.<br>1016.<br>1017.<br>1018.<br>1019.<br>1020.<br>1021.<br>1022.<br>1023.<br>1024.<br>1025.<br>1026.<br>1027.<br>1028.<br>1029.<br>1030.<br>1031.<br>1032.<br>1033.<br>1034.<br>1035.<br>1036.<br>1037.<br>1038.<br>1039.<br>1040.<br>1041.<br>1042.<br>1043.<br>1044.<br>1045.<br>1046.<br>1047.<br>1048.<br>1049.<br>1050.<br>1051.<br>1052.<br>1053.<br>1054.<br>1055.<br>1056.<br>1057.<br>1058.<br>1059.<br>1060.<br>1061.<br>1062.<br>1063.<br>1064.<br>1065.<br>1066.<br>1067.<br>1068.<br>1069.<br>1070.<br>1071.<br>1072.<br>1073.<br>1074.<br>1075.<br>1076.<br>1077.<br>1078.<br>1079.<br>1080.<br>1081.<br>1082.<br>1083.<br>1084.<br>1085.<br>1086.<br>1087.<br>1088.<br>1089.<br>1090.<br>1091.<br>1092.<br>1093.<br>1094.<br>1095.<br>1096.<br>1097.<br>1098.<br>1099.<br>1100.<br>1101.<br>1102.<br>1103.<br>1104.<br>1105.<br>1106.<br>1107.<br>1108.<br>1109.<br>1110.<br>1111.<br>1112.<br>1113.<br>1114.<br>1115.<br>1116.<br>1117.<br>1118.<br>1119.<br>1120.<br>1121.<br>1122.<br>1123.<br>1124.<br>1125.<br>1126.<br>1127.<br>1128.<br>1129.<br>1130.<br>1131.<br>1132.<br>1133.<br>1134.<br>1135.<br>1136.<br>1137.<br>1138.<br>1139.<br>1140.<br>1141.<br>1142.<br>1143.<br>1144.<br>1145.<br>1146.<br>1147.<br>1148.<br>1149.<br>1150.<br>1151.<br>1152.<br>1153.<br>1154.<br>1155.<br>1156.<br>1157.<br>1158.<br>1159.<br>1160.<br>1161.<br>1162.<br>1163.<br>1164.<br>1165.<br>1166.<br>1167.<br>1168.<br>1169.<br>1170.<br>1171.<br>1172.<br>1173.<br>1174.<br>1175.<br>1176.<br>1177.<br>1178.<br>1179.<br>1180.<br>1181.<br>1182.<br>1183.<br>1184.<br>1185.<br>1186.<br>1187.<br>1188.<br>1189.<br>1190.<br>1191.<br>1192.<br>1193.<br>1194.<br>1195.<br>1196.<br>1197.<br>1198.<br>1199.<br>1200.<br>1201.<br>1202.<br>1203.<br>1204.<br>1205.<br>1206.<br>1207.<br>1208.<br>1209.<br>1210.<br>1211.<br>1212.<br>1213.<br>1214.<br>1215.<br>1216.<br>1217.<br>1218.<br>1219.<br>1220.<br>1221.<br>1222.<br>1223.<br>1224.<br>1225.<br>1226.<br>1227.<br>1228.<br>1229.<br>1230.<br>1231.<br>1232.<br>1233.<br>1234.<br>1235.<br>1236.<br>1237.<br>1238.<br>1239.<br>1240.<br>1241.<br>1242.<br>1243.<br>1244.<br>1245.<br>1246.<br>1247.<br>1248.<br>1249.<br>1250.<br>1251.<br>1252.<br>1253.<br>1254.<br>1255.<br>1256.<br>1257.<br>1258.<br>1259.<br>1260.<br>1261.<br>1262.<br>1263.<br>1264.<br>1265.<br>1266.<br>1267.<br>1268.<br>1269.<br>1270.<br>1271.<br>1272.<br>1273.<br>1274.<br>1275.<br>1276.<br>1277.<br>1278.<br>1279.<br>1280.<br>1281.<br>1282.<br>1283.<br>1284.<br>1285.<br>1286.<br>1287.<br>1288.<br>1289.<br>1290.<br>1291.<br>1292.<br>1293.<br>1294.<br>1295.<br>1296.<br>1297.<br>1298.<br>1299.<br>1300.<br>1301.<br>1302.<br>1303.<br>1304.<br>1305.<br>1306.<br>1307.<br>1308.<br>1309.<br>1310.<br>1311.<br>1312.<br>1313.<br>1314.<br>1315.<br>1316.<br>1317.<br>1318.<br>1319.<br>1320.<br>1321.<br>1322.<br>1323.<br>1324.<br>1325.<br>1326.<br>1327.<br>1328.<br>1329.<br>1330.<br>1331.<br>1332.<br>1333.<br>1334.<br>1335.<br>1336.<br>1337.<br>1338.<br>1339.<br>1340.<br>1341.<br>1342.<br>1343.<br>1344.<br>1345.<br>1346.<br>1347.<br>1348.<br>1349.<br>1350.<br>1351.<br>1352.<br>1353.<br>1354.<br>1355.<br>1356.<br>1357.<br>1358.<br>1359.<br>1360.<br>1361.<br>1362.<br>1363.<br>1364.<br>1365.<br>1366.<br>1367.<br>1368.<br>1369.<br>1370.<br>1371.<br>1372.<br>1373.<br>1374.<br>1375.<br>1376.<br>1377.<br>1378.<br>1379.<br>1380.<br>1381.<br>1382.<br>1383.<br>1384.<br>1385.<br>1386.<br>1387.<br>1388.<br>1389.<br>1390.<br>1391.<br>1392.<br>1393.<br>1394.<br>1395.<br>1396.<br>1397.<br>1398.<br>1399.<br>1400.<br>1401.<br>1402.<br>1403.<br>1404.<br>1405.<br>1406.<br>1407.<br>1408.<br>1409.<br>1410.<br>1411.<br>1412.<br>1413.<br>1414.<br>1415.<br>1416.<br>1417.<br>1418.<br>1419.<br>1420.<br>1421.<br>1422.<br>1423.<br>1424.<br>1425.<br>1426.<br>1427.<br>1428.<br>1429.<br>1430.<br>1431.<br>1432.<br>1433.<br>1434.<br>1435.<br>1436.<br>1437.<br>1438.<br>1439.<br>1440.<br>1441.<br>1442.<br>1443.<br>1444.<br>1445.<br>1446.<br>1447.<br>1448.<br>1449.<br>1450.<br>1451.<br>1452.<br>1453.<br>1454.<br>1455.<br>1456.<br>1457.<br>1458.<br>1459.<br>1460.<br>1461.<br>1462.<br>1463.<br>1464.<br>1465.<br>1466.<br>1467.<br>1468.<br>1469.<br>1470.<br>1471.<br>1472.<br>1473.<br>1474.<br>1475.<br>1476.<br>1477.<br>1478.<br>1479.<br>1480.<br>1481.<br>1482.<br>1483.<br>1484.<br>1485.<br>1486.<br>1487.<br>1488.<br>1489.<br>1490.<br>1491.<br>1492.<br>1493.<br>1494.<br>1495.<br>1496.<br>1497.<br>1498.<br>1499.<br>1500.<br>1501.<br>1502.<br>1503.<br>1504.<br>1505.<br>1506.<br>1507.<br>1508.<br>1509.<br>1510.<br>1511.<br>1512.<br>1513.<br>1514.<br>1515.<br>1516.<br>1517.<br>1518.<br>1519.<br>1520.<br>1521.<br>1522.<br>1523.<br>1524.<br>1525.<br>1526.<br>1527.<br>1528.<br>1529.<br>1530.<br>1531.<br>1532.<br>1533.<br>1534.<br>1535.<br>1536.<br>1537.<br>1538.<br>1539.<br>1540.<br>1541.<br>1542.<br>1543.<br>1544.<br>1545.<br>1546.<br>1547.<br>1548.<br>1549.<br>1550.<br>1551.<br>1552.<br>1553.<br>1554.<br>1555.<br>1556.<br>1557.<br>1558.<br>1559.<br>1560.<br>1561.<br>1562.<br>1563.<br>1564.<br>1565.<br>1566.<br>1567.<br>1568.<br>1569.<br>1570.<br>1571.<br>1572.<br>1573.<br>1574.<br>1575.<br>1576.<br>1577.<br>1578.<br>1579.<br>1580.<br>1581.<br>1582.<br>1583.<br>1584.<br>1585.<br>1586.<br>1587.<br>1588.<br>1589.<br>1590.<br>1591.<br>1592.<br>1593.<br>1594.<br>1595.<br>1596.<br>1597.<br>1598.<br>1599.<br>1600.<br>1601.<br>1602.<br>1603.<br>1604.<br>1605.<br>1606.<br>1607.<br>1608.<br>1609.<br>1610.<br>1611.<br>1612.<br>1613.<br>1614.<br>1615.<br>1616.<br>1617.<br>1618.<br>1619.<br>1620.<br>1621.<br>1622.<br>1623.<br>1624.<br>1625.<br>1626.<br>1627.<br>1628.<br>1629.<br>1630.<br>1631.<br>1632.<br>1633.<br>1634.<br>1635.<br>1636.<br>1637.<br>1638.<br>1639.<br>1640.<br>1641.<br>1642.<br>1643.<br>1644.<br>1645.<br>1646.<br>1647.<br>1648.<br>1649.<br>1650.<br>1651.<br>1652.<br>1653.<br>1654.<br>1655.<br>1656.<br>1657.<br>1658.<br>1659.<br>1660.<br>1661.<br>1662.<br>1663.<br>1664.<br>1665.<br>1666.<br>1667.<br>1668.<br>1669.<br>1670.<br>1671.<br>1672.<br>1673.<br>1674.<br>1675.<br>1676.<br>1677.<br>1678.<br>1679.<br>1680.<br>1681.<br>1682.<br>1683.<br>1684.<br>1685.<br>1686.<br>1687.<br>1688.<br>1689.<br>1690.<br>1691.<br>1692.<br>1693.<br>1694.<br>1695.<br>1696.<br>1697.<br>1698.<br>1699.<br>1700.<br>1701.<br>1702.<br>1703.<br>1704.<br>1705.<br>1706.<br>1707.<br>1708.<br>1709.<br>1710.<br>1711.<br>1712.<br>1713.<br>1714.<br>1715.<br>1716.<br>1717.<br>1718.<br>1719.<br>1720.<br>1721.<br>1722.<br>1723.<br>1724.<br>1725.<br>1726.<br>1727.<br>1728.<br>1729.<br>1730.<br>1731.<br>1732.<br>1733.<br>1734.<br>1735.<br>1736.<br>1737.<br>1738.<br>1739.<br>1740.<br>1741.<br>1742.<br>1743.<br>1744.<br>1745.<br>1746.<br>1747.<br>1748.<br>1749.<br>1750.<br>1751.<br>1752.<br>1753.<br>1754.<br>1755.<br>1756.<br>1757.<br>1758.<br>1759.<br>1760.<br>1761.<br>1762.<br>1763.<br>1764.<br>1765.<br>1766.<br>1767.<br>1768.<br>1769.<br>1770.<br>1771.<br>1772.<br>1773.<br>1774.<br>1775.<br>1776.<br>1777.<br>1778.<br>1779.<br>1780.<br>1781.<br>1782.<br>1783.<br>1784.<br>1785.<br>1786.<br>1787.<br>1788.<br>1789.<br>1790.<br>1791.<br>1792.<br>1793.<br>1794.<br>1795.<br>1796.<br>1797.<br>1798.<br>1799.<br>1800.<br>1801.<br>1802.<br>1803.<br>1804.<br>1805.<br>1806.<br>1807.<br>1808.<br>1809.<br>1810.<br>1811.<br>1812.<br>1813.<br>1814.<br>1815.<br>1816.<br>1817.<br>1818.<br>1819.<br>1820.<br>1821.<br>1822.<br>1823.<br>1824.<br>1825.<br>1826.<br>1827.<br>1828.<br>1829.<br>1830.<br>1831.<br>1832.<br>1833.<br>1834.<br>1835.<br>1836.<br>1837.<br>1838.<br>1839.<br>1840.<br>1841.<br>1842.<br>1843.<br>1844.<br>1845.<br>1846.<br>1847.<br>1848.<br>1849.<br>1850.<br>1851.<br>1852.<br>1853.<br>1854.<br>1855.<br>1856.<br>1857.<br>1858.<br>1859.<br>1860.<br>1861.<br>1862.<br>1863.<br>1864.<br>1865.<br>1866.<br>1867.<br>1868.<br>1869.<br>1870.<br>1871.<br>1872.<br>1873.<br>1874.<br>1875.<br>1876.<br>1877.<br>1878.<br>1879.<br>1880.<br>1881.<br>1882.<br>1883.<br>1884.<br>1885.<br>1886.<br>1887.<br>1888.<br>1889.<br>1890.<br>1891.<br>1892.<br>1893.<br>1894.<br>1895.<br>1896.<br>1897.<br>1898.<br>1899.<br>1900.<br>1901.<br>1902.<br>1903.<br>1904.<br>1905.<br>1906.<br>1907.<br>1908.<br>1909.<br>1910.<br>1911.<br>1912.<br>1913.<br>1914.<br>1915.<br>1916.<br>1917.<br>1918.<br>1919.<br>1920.<br>1921.<br>1922.<br>1923.<br>1924.<br>1925.<br>1926.<br>1927.<br>1928.<br>1929.<br>1930.<br>1931.<br>1932.<br>1933.<br>1934.<br>1935.<br>1936.<br>1937.<br>1938.<br>1939.<br>1940.<br>1941.<br>1942.<br>1943.<br>1944.<br>1945.<br>1946.<br>1947.<br>1948.<br>1949.<br>1950.<br>1951.<br>1952.<br>1953.<br>1954.<br>1955.<br>1956.<br>1957.<br>1958.<br>1959.<br>1960.<br>1961.<br>1962.<br>1963.<br>1964.<br>1965.<br>1966.<br>1967.<br>1968.<br>1969.<br>1970.<br>1971.<br>1972.<br>1973.<br>1974.<br>1975.<br>1976.<br>1977.<br>1978.<br>1979.<br>1980.<br>1981.<br>1982.<br>1983.<br>1984.<br>1985.<br>1986.<br>1987.<br>1988.<br>1989.<br>1990.<br>1991.<br>1992.<br>1993.<br>1994.<br>1995.<br>1996.<br>1997.<br>1998.<br>1999.<br>2000.<br>2001.<br>2002.<br>2003.<br>2004.<br>2005.<br>2006.<br>2007.<br>2008.<br>2009.<br>2010.<br>2011.<br>2012.<br>2013.<br>2014.<br>2015.<br>2016.<br>2017.<br>2018.<br>2019.<br>2020.<br>2021.<br>2022.<br>2023.<br>2024.<br>2025.<br>2026.<br>2027.<br>2028.<br>2029.<br>2030.<br>2031.<br>2032.<br>2033.<br>2034.<br>2035.<br>2036.<br>2037.<br>2038.<br>2039.<br>2040.<br>2041.<br>2042.<br>2043.<br>2044.<br>2045.<br>2046.<br>2047.<br>2048.<br>2049.<br>2050.<br>2051.<br>2052.<br>2053.<br>2054.<br>2055.<br>2056.<br>2057.<br>2058.<br>2059.<br>2060.<br>2061.<br>2062.<br>2063.<br>2064.<br>2065.<br>2066.<br>2067.<br>2068.<br>2069.<br>2070.<br>2071.<br>2072.<br>2073.<br>2074.<br>2075.<br>2076.<br>2077.<br>2078.<br>2079.<br>2080.<br>2081.<br>2082.<br>2083.<br>2084.<br>2085.<br>2086.<br>2087.<br>2088.<br>2089.<br>2090.<br>2091.<br>2092.<br>2093.<br>2094.<br>2095.<br>2096.<br>2097.<br>2098.<br>2099.<br>2100.<br>2101.<br>2102.<br>2103.<br>2104.<br>2105.<br>2106.<br>2107.<br>2108.<br>2109.<br>2110.<br>2111.<br>2112.<br>2113.<br>2114.<br>2115.<br>2116.<br>2117.<br>2118.<br>2119.<br>2120.<br>2121.<br>2122.<br>2123.<br>2124.<br>2125.<br>2126.<br>2127.<br>2128.<br>2129.<br>2130.<br>2131.<br>2132.<br>2133.<br>2134.<br>2135.<br>2136.<br>2137.<br>2138.<br>2139.<br>2140.<br>2141.<br>2142.<br>2143.<br>2144.<br>2145.<br>2146.<br>2147.<br>2148.<br>2149.<br>2150.<br>2151.<br>2152.<br>2153.<br>2154.<br>2155.<br>2156.<br>2157.<br>2158.<br>2159.<br>2160.<br>2161.<br>2162.<br>2163.<br>2164.<br>2165.<br>2166.<br>2167.<br>2168.<br>2169.<br>2170.<br>2171.<br>2172.<br>2173.<br>2174.<br>2175.<br>2176.<br>2177.<br>2178.<br>2179.<br>2180.<br>2181.<br>2182.<br>2183.<br>2184.<br>2185.<br>2186.<br>2187.<br>2188.<br>2189.<br>2190.<br>2191.<br>2192.<br>2193.<br>2194.<br>2195.<br>2196.<br>2197.<br>2198.<br>2199.<br>2200.<br>2201.<br>2202.<br>2203.<br>2204.<br>2205.<br>2206.<br>2207.<br>2208.<br>2209.<br>2210.<br>2211.<br>2212.<br>2213.<br>2214.<br>2215.<br>2216.<br>2217.<br>2218.<br>2219.<br>2220.<br>2221.<br>2222.<br>2223.<br>2224.<br>2225.<br>2226.<br>2227.<br>2228.<br>2229.<br>2230.<br>2231.<br>2232.<br>2233.<br>2234.<br>2235.<br>2236.<br>2237.<br>2238.<br>2239.<br>2240.<br>2241.<br>2242.<br>2243.<br>2244.<br>2245.<br>2246.<br>2247.<br>2248.<br>2249.<br>2250.<br>2251.<br>2252.<br>2253.<br>2254.<br>2255.<br>2256.<br>2257.<br>2258.<br>2259.<br>2260.<br>2261.<br>2262.<br>2263.<br>2264.<br>2265.<br>2266.<br>2267.<br>2268.<br>2269.<br>2270.<br>2271.<br>2272.<br>2273.<br>2274.<br>2275.<br>2276.<br>2277.<br>2278.<br>2279.<br>2280.<br>2281.<br>2282.<br>2283.<br>2284.<br>2285.<br>2286.<br>2287.<br>2288.<br>2289.<br>2290.<br>2291.<br>2292.<br>2293.<br>2294.<br>2295.<br>2296.<br>2297.<br>2298.<br>2299.<br>2300.<br>2301.<br>2302.<br>2303.<br>2304.<br>2305.<br>2306.<br>2307.<br>2308.<br>2309.<br>2310.<br>2311.<br>2312.<br>2313.<br>2314.<br>2315.<br>2316.<br>2317.<br>2318.<br>2319.<br>2320.<br>2321.<br>2322.<br>2323.<br>2324.<br>2325.<br>2326.<br>2327.<br>2328.<br>2329.<br>2330.<br>2331.<br>2332.<br>2333.<br>2334.<br>2335.<br>2336.<br>2337.<br>2338.<br>2339.<br>2340.<br>2341.<br>2342.<br>2343.<br>2344.<br>2345.<br>2346.<br>2347.<br>2348.<br>2349.<br>2350.<br>2351.<br>2352.<br>2353.<br>2354.<br>2355.<br>2356.<br>2357.<br>2358.<br>2359.<br>2360.<br>2361.<br>2362.<br>2363.<br>2364.<br>2365.<br>2366.<br>2367.<br>2368.<br>2369.<br>2370.<br>2371.<br>2372.<br>2373.<br>2374.<br>2375.<br>2376.<br>2377.<br>2378.<br>2379.<br>2380.<br>2381.<br>2382.<br>2383.<br>2384.<br>2385.<br>2386.<br>2387.<br>2388.<br>2389.<br>2390.<br>2391.<br>2392.<br>2393.<br>2394.<br>2395.<br>2396.<br>2397.<br>2398.<br>2399.<br>2400.<br>2401.<br>2402.<br>2403.<br>2404.<br>2405.<br>2406.<br>2407.<br>2408.<br>2409.<br>2410.<br>2411.<br>2412.<br>2413.<br>2414.<br>2415.<br>2416.<br>2417.<br>2418.<br>2419.<br>2420.<br>2421.<br>2422.<br>2423.<br>2424.<br>2425.<br>2426.<br>2427.<br>2428.<br>2429.<br>2430.<br>2431.<br>2432.<br>2433.<br>2434.<br>2435.<br>2436.<br>2437.<br>2438.<br>2439.<br>2440.<br>2441.<br>2442.<br>2443.<br>2444.<br>2445.<br>2446.<br>2447.<br>2448.<br>2449.<br>2450.<br>2451.<br>2452.<br>2453.<br>2454.<br>2455.<br>2456.<br>2457.<br>2458.<br>2459.<br>2460.<br>2461.<br>2462.<br>2463.<br>2464.<br>2465.<br>2466.<br>2467.<br>2468.<br>2469.<br>2470.<br>2471.<br>2472.<br>2473.<br>2474.<br>2475.<br>2476.<br>2477.<br>2478.<br>2479.<br>2480.<br>2481.<br>2482.<br>2483.<br>2484.<br>2485.<br>2486.<br>2487.<br>2488.<br>2489.<br>2490.<br>2491.<br>2492.<br>2493.<br>2494.<br>2495.<br>2496.<br>2497.<br>2498.<br>2499.<br>2500.<br>2501.<br>2502.<br>2503.<br>2504.<br>2505.<br>2506.<br>2507.<br>2508.<br>2509.<br>2510.<br>2511.<br>2512.<br>2513.<br>2514.<br>2515.<br>2516.<br>2517.<br>2518.<br>2519.<br>2520.<br>2521.<br>2522.<br>2523.<br>2524.<br>2525.<br>2526.<br>2527.<br>2528.<br>2529.<br>2530.<br>2531.<br>2532.<br>2533.<br>2534.<br>2535.<br>2536.<br>2537.<br>2538.<br>2539.<br>2540.<br>2541.<br>2542.<br>2543.<br>2544.<br>2545.<br>2546.<br>2547.<br>2548.<br>2549.<br>2550.<br>2551.<br>2552.<br>2553.<br>2554.<br>2555.<br>2556.<br>2557.<br>2558.<br>2559.<br>2560.<br>2561.<br>2562.<br>2563.<br>2564.<br>2565.<br>2566.<br>2567.<br>2568.<br>2569.<br>2570.<br>2571.<br>2572.<br>2573.<br>2574.<br>2575.<br>2576.<br>2577.<br>2578.<br>2579.<br>2580.<br>2581.<br>2582.<br>2583.<br>2584.<br>2585.<br>2586.<br>2587.<br>2588.<br>2589.<br>2590.<br>2591.<br>2592.<br>2593.<br>2594.<br>2595.<br>2596.<br>2597.<br>2598.<br>2599.<br>2600.<br>2601.<br>2602.<br>2603.<br>2604.<br>2605.<br>2606.<br>2607.<br>2608.<br>2609.<br>2610.<br>2611.<br>2612.<br>2613.<br>2614.<br>2615.<br>2616.<br>2617.<br>2618.<br>2619.<br>2620.<br>2621.<br>2622.<br>2623.<br>2624.<br>2625.<br>2626.<br>2627.<br>2628.<br>2629.<br>2630.<br>2631.<br>2632.<br>2633.<br>2634.<br>2635.<br>2636.<br>2637.<br>2638.<br>2639.<br>2640.<br>2641.<br>2642.<br>2643.<br>2644.<br>2645.<br>2646.<br>2647.<br>2648.<br>2649.<br>2650.<br>2651.<br>2652.<br>2653.<br>2654.<br>2655.<br>2656.<br>2657.<br>2658.<br>2659.<br>2660.<br>2661.<br>2662.<br>2663.<br>2664.<br>2665.<br>2666.<br>2667.<br>2668.<br>2669.<br>2670.<br>2671.<br>2672.<br>2673.<br>2674.<br>2675.<br>2676.<br>2677.<br>2678.<br>2679.<br>2680.<br>2681.<br>2682.<br>2683.<br>2684.<br>2685.<br>2686.<br>2687.<br>2688.<br>2689.<br>2690.<br>2691.<br>2692.<br>2693.<br>2694.<br>2695.<br>2696.<br>2697.<br>2698.<br>2699.<br>2700.<br>2701.<br>2702.<br>2703.<br>2704.<br>2705.<br>2706.<br>2707.<br>2708.<br>2709.<br>2710.<br>2711.<br>2712.<br>2713.<br>2714.<br>2715.<br>2716.<br>2717.<br>2718.<br>2719.<br>2720.<br>2721.<br>2722.<br>2723.<br>2724.<br>2725.<br>2726.<br>2727.<br>2728.<br>2729.<br>2730.<br>2731.<br>2732.<br>2733.<br>2734.<br>2735.<br>2736.<br>2737.<br>2738.<br>2739.<br>2740.<br>2741.<br>2742.<br>2743.<br>2744.<br>2745.<br>2746.<br>2747.<br>2748.<br>2749.<br>2750.<br>2751.<br>2752.<br>2753.<br>2754.<br>2755.<br>2756.<br>2757.<br>2758.<br>2759.<br>2760.<br>2761.<br>2762.<br>2763.<br>2764.<br>2765.<br>2766.<br>2767.<br>2768.<br>2769.<br>2770.<br>2771.<br>2772.<br>2773.<br>2774.<br>2775.<br>2776.<br>2777.<br>2778.<br>2779.<br>2780.<br>2781.<br>2782.<br>2783.<br>2784.<br>2785.<br>2786.<br>2787.<br>2788.<br>2789.<br>2790.<br>2791.<br>2792.<br>2793.<br>2794.<br>2795.<br>2796.<br>2797.<br>2798.<br>2799.<br>2800.<br>2801.<br>2802.<br>2803.<br>2804.<br>2805.<br>2806.<br>2807.<br>2808.<br>2809.<br>2810.<br>2811.<br>2812.<br>2813.<br>2814.<br>2815.<br>2816.<br>2817.<br>2818.<br>2819.<br>2820.<br>2821.<br>2822.<br>2823.<br>2824.<br>2825.<br>2826.<br>2827.<br>2828.<br>2829.<br>2830.<br>2831.<br>2832.<br>2833.<br>2834.<br>2835.<br>2836.<br>2837.<br>2838.<br>2839.<br>2840.<br>2841.<br>2842.<br>2843.<br>2844.<br>2845.<br>2846.<br>2847.<br>2848.<br>2849.<br>2850.<br>2851.<br>2852.<br>2853.<br>2854.<br>2855.<br>2856.<br>2857.<br>2858.<br>2859.<br>2860.<br>2861.<br>2862.<br>2863.<br>2864.<br>2865.<br>2866.<br>2867.<br>2868.<br>2869.<br>2870.<br>2871.<br>2872.<br>2873.<br>2874.<br>2875.<br>2876.<br>2877.<br>2878.<br>2879.<br>2880.<br>2881.<br>2882.<br>2883.<br>2884.<br>2885.<br>2886.<br>2887.<br>2888.<br>2889.<br>2890.<br>2891.<br>2892.<br>2893.<br>2894.<br>2895.<br>2896.<br>2897.<br>2898.<br>2899.<br>2900.<br>2901.<br>2902.<br>2903.<br>2904.<br>2905.<br>2906.<br>2907.<br>2908.<br>2909.<br>2910.<br>2911.<br>2912.<br>2913.<br>2914.<br>2915.<br>2916.<br>2917.<br>2918.<br>2919.<br>2920.<br>2921.<br>2922.<br>2923.<br>2924.<br>2925.<br>2926.<br>2927.<br>2928.<br>2929.<br>2930.<br>2931.<br>2932.<br>2933.<br>2934.<br>2935.<br>2936.<br>2937.<br>2938.<br>2939.<br>2940.<br>2941.<br>2942.<br>2943.<br>2944.<br>2945.<br>2946.<br>2947.<br>2948.<br>2949.<br>2950.<br>2951.<br>2952.<br>2953.<br>2954.<br>2955.<br>2956.<br>2957.<br>2958.<br>2959.<br>2960.<br>2961.<br>2962.<br>2963.<br>2964.<br>2965.<br>2966.<br>2967.<br>2968.<br>2969.<br>2970.<br>2971.<br>2972.<br>2973.<br>2974.<br>2975.<br>2976.<br>2977.<br>2978.<br>2979.<br>2980.<br>2981.<br>2982.<br>2983.<br>2984.<br>2985.<br>2986.<br>2987.<br>2988.<br>2989.<br>2990.<br>2991.<br>2992.<br>2993.<br>2994.<br>2995.<br>2996.<br>2997.<br>2998.<br>2999.<br>3000.<br>3001.<br>3002.<br>3003.<br>3004.<br>3005.<br>3006.<br>3007.<br>3008.<br>3009.<br>3010.<br>3011.<br>3012.<br>3013.<br>3014.<br>3015.<br>3016.<br>3017.<br>3018.<br>3019.<br>3020.<br>3021.<br>3022.<br>3023.<br>3024.<br>3025.<br>3026.<br>3027.<br>3028.<br>3029.<br>3030.<br>3031.<br>3032.<br>3033.<br>3034.<br>3035.<br>3036.<br>3037.<br>3038.<br>3039.<br>3040.<br>3041.<br>3042.<br>3043.<br>3044.<br>3045.<br>3046.<br>3047.<br>3048.<br>3049.<br>3050.<br>3051.<br>3052.<br>3053.<br>3054.<br>3055.<br>3056.<br>3057.<br>3058.<br>3059.<br>3060.<br>3061.<br>3062.<br>3063.<br>3064.<br>3065.<br>3066.<br>3067.<br>3068.<br>3069.<br>3070.<br>3071.<br>3072.<br>3073.<br>3074.<br>3075.<br>3076.<br>3077.<br>3078.<br>3079.<br>3080.<br>3081.<br>3082.<br>3083.<br>3084.<br>3085.<br>3086.<br>3087.<br>3088.<br>3089.<br>3090.<br>3091.<br>3092.<br>3093.<br>3094.<br>3095.<br>3096.<br>3097.<br>3098.<br>3099.<br>3100.<br>3101.<br>3102.<br>3103.<br>3104.<br>3105.<br>3106.<br>3107.<br>3108.<br>3109.<br>3110.<br>3111.<br>3112.<br>3113.<br>3114.<br>3115.<br>3116.<br>3117.<br>3118.<br>3119.<br>3120.<br>3121.<br>3122.<br>3123.<br>3124.<br>3125.<br>3126.<br>3127.<br>3128.<br>3129.<br>3130.<br>3131.<br>3132.<br>3133.<br>3134.<br>3135.<br>3136.<br>3137.<br>3138.<br>3139.<br>3140.<br>3141.<br>3142.<br>3143.<br>3144.<br>3145.<br>3146.<br>3147.<br>3148.<br>3149.<br>3150.<br>3151.<br>3152.<br>3153.<br>3154.<br>3155.<br>3156.<br>3157.<br>3158.<br>3159.<br>3160.<br>3161.<br>3162.<br>3163.<br>3164.<br>3165.<br>3166.<br>3167.<br>3168.<br>3169.<br>3170.<br>3171.<br>3172.<br>3173.<br>3174.<br>3175.<br>3176.<br>3177.<br>3178.<br>3179.<br>3180.<br>3181.<br>3182.<br>3183.<br>3184.<br>3185.<br>3186.<br>3187.<br>3188.<br>3189.<br>3190.<br>3191.<br>3192.<br>3193.<br>3194.<br>3195.<br>3196.<br>3197.<br>3198.<br>3199.<br>3200.<br>3201.<br>3202.<br>3203.<br>3204.<br>3205.<br>3206.<br>3207.<br>3208.<br>3209.<br>3210.<br>3211.<br>3212.<br>3213.<br>3214.<br>3215.<br>3216.<br>3217.<br>3218.<br>3219.<br>3220.<br>3221.<br>3222.<br>3223.<br>3224.<br>3225.<br>3226.<br>3227.<br>3228.<br>3229.<br>3230.<br>3231.<br>3232.<br>3233.<br>3234.<br>3235.<br>3236.<br>3237.<br>3238.<br>3239.<br>3240.<br>3241.<br>3242.<br>3243.<br>3244.<br>3245.<br>3246.<br>3247.<br>3248.<br>3249.<br>3250.<br>3251.<br>3252.<br>3253.<br>3254.<br>3255.<br>3256.<br>3257.<br>3258.<br>3259.<br>3260.<br>3261.<br>3262.<br>3263.<br>3264.<br>3265.<br>3266.<br>3267.<br>3268.<br>3269.<br>3270.<br>3271.<br>3272.<br>3273.<br>3274.<br>3275.<br>3276.<br>3277.<br>3278.<br>3279.<br>3280.<br>3281.<br>3282.<br>3283.<br>3284.<br>3285.<br>3286.<br>3287.<br>3288.<br>3289.<br>3290.<br>3291.<br>3292.<br>3293.<br>3294.<br>3295.<br>3296.<br>3297.<br>3298.<br>3299.<br>3300.<br>3301.<br>3302.<br>3303.<br>3304.<br>3305.<br>3306.<br>3307.<br>3308.<br>3309.<br>3310.<br>3311.<br>3312.<br>3313.<br>3314.<br>3315.<br>3316.<br>3317.<br>3318.<br>3319.<br>3320.<br>3321.<br>3322.<br>3323.<br>3324.<br>3325.<br>3326.<br>3327.<br>3328.<br>3329.<br>3330.<br>3331.<br>3332.<br>3333.<br>3334.<br>3335.<br>3336.<br>3337.<br>3338.<br>3339.<br>3340.<br>3341.<br>3342.<br>3343.<br>3344.<br>3345.<br>3346.<br>3347.<br>3348.<br>3349.<br>3350.<br>3351.<br>3352.<br>3353.<br>3354.<br>3355.<br>3356.<br>3357.<br>3358.<br>3359.<br>3360.<br>3361.<br>3362.<br>3363.<br>3364.<br>3365.<br>3366.<br>3367.<br>3368.<br>3369.<br>3370.<br>3371.<br>3372.<br>3373.<br>3374.<br>3375.<br>3376.<br>3377.<br>3378.<br>3379.<br>3380.<br>3381.<br>3382.<br>3383.<br>3384.<br>3385.<br>3386.<br>3387.<br>3388.<br>3389.<br>3390.<br>3391.<br>3392.<br>3393.<br>3394.<br>3395.<br>3396.<br>3397.<br>3398.<br>3399.<br>3400.<br>3401.<br>3402.<br>3403.<br>3404.<br>3405.<br>3406.<br>3407.<br>3408.<br>3409.<br>3410.<br>3411.<br>3412.<br>3413.<br>3414.<br>3415.<br>3416.<br>3417.<br>3418.<br>3419.<br>3420.<br>3421.<br>3422.<br>3423.<br>3424.<br>3425.<br>3426.<br>3427.<br>3428.<br>3429.<br>3430.<br>3431.<br>3432.<br>3433.<br>3434.<br>3435.<br>3436.<br>3437.<br>3438.<br>3439.<br>3440.<br>3441.<br>3442.<br>3443.<br>3444.<br>3445.<br>3446.<br>3447.<br>3448.<br>3449.<br>3450.<br>3451.<br>3452.<br>3453.<br>3454.<br>3455.<br>3456.<br>3457.<br>3458.<br>3459.<br>3460.<br>3461.<br>3462.<br>3463.<br>3464.<br>3465.<br>3466.<br>3467.<br>3468.<br>3469.<br>3470.<br>3471.<br>3472.<br>3473.<br>3474.<br>3475.<br>3476.<br>3477.<br>3478.<br>3479.<br>3480.<br>3481.<br>3482.<br>3483.<br>3484.<br>3485.<br>3486.<br>3487.<br>3488.<br>3489.<br>3490.<br>3491.<br>3492.<br>3493.<br>3494.<br>3495.<br>3496.<br>3497.<br>3498.<br>3499.<br>3500.<br>3501.<br>3502.<br>3503.<br>3504.<br>3505.<br>3506.<br>3507.<br>3508.<br>3509.<br>3510.<br>3511.<br>3512.<br>3513.<br>3514.<br>3515.<br>3516.<br>3517.<br>3518.<br>3519.<br>3520.<br>3521.<br>3522.<br>3523.<br>3524.<br>3525.<br>3526.<br>3527.<br>3528.<br>3529.<br>3530.<br>3531.<br>3532.<br>3533.<br>3534.<br>3535.<br>3536.<br>3537.<br>3538.<br>3539.<br>3540.<br>3541.<br>3542.<br>3543.<br>3544.<br>3545.<br>3546.<br>3547.<br>3548.<br>3549.<br>3550.<br>3551.<br>3552.<br>3553.<br>3554.<br>3555.<br>3556.<br>3557.<br>3558.<br>3559.<br>3560.<br>3561.<br>3562.<br>3563.<br>3564.<br>3565.<br>3566.<br>3567.<br>3568.<br>3569.<br>3570.<br>3571.<br>3572.<br>3573.<br>3574.<br>3575.<br>3576.<br>3577.<br>3578.<br>3579.<br>3580.<br>3581.<br>3582.<br>3583.<br>3584.<br>3585.<br>3586.<br>3587.<br>3588.<br>3589.<br>3590.<br>3591.<br>3592.<br>3593.<br>3594.<br>3595.<br>3596.<br>3597.<br>3598.<br>3599.<br>3600.<br>3601.<br>3602.<br>3603.<br>3604.<br>3605.<br>3606.<br>3607.<br>3608.<br>3609.<br>3610.<br>3611.<br>3612.<br>3613.<br>3614.<br>3615.<br>3616.<br>3617.<br>3618.<br>3619.<br>3620.<br>3621.<br>3622.<br>3623.<br>3624.<br>3625.<br>3626.<br>3627.<br>3628.<br>3629.<br>3630.<br>3631.<br>3632.<br>3633.<br>3634.<br>3635.<br>3636.<br>3637.<br>3638.<br>3639.<br>3640.<br>3641.<br>3642.<br>3643.<br>3644.<br>3645.<br>3646.<br>3647.<br>3648.<br>3649.<br>3650.<br>3651.<br>3652.<br>3653.<br>3654.<br>3655.<br>3656.<br>3657.<br>3658.<br>3659.<br>3660.<br>3661.<br>3662.<br>3663.<br>3664.<br>3665.<br>3666.<br>3667.<br>3668.<br>3669.<br>3670.<br>3671.<br>3672.<br>3673.<br>3674.<br>3675.<br>3676.<br>3677.<br>3678.<br>3679.<br>3680.<br>3681.<br>3682.<br>3683.<br>3684.<br>3685.<br>3686.<br>3687.<br>3688.<br>3689.<br>3690.<br>3691.<br>3692.<br>3693.<br>3694.<br>3695.<br>3696.<br>3697.<br>3698.<br>3699.<br>3700.<br>3701.<br>3702.<br>3703.<br>3704.<br>3705.<br>3706.<br>3707.<br>3708.<br>3709.<br>3710.<br>3711.<br>3712.<br>3713.<br>3714.<br>3715.<br>3716.<br>3717.<br>3718.<br>3719.<br>3720.<br>3721.<br>3722.<br>3723.<br>3724.<br>3725.<br>3726.<br>3727.<br>3728.<br>3729.<br>3730.<br>3731.<br>3732.<br>3733.<br>3734.<br>3735.<br>3736.<br>3737.<br>3738.<br>3739.<br>3740.<br>3741.<br>3742.<br>3743.<br>3744.<br>3745.<br>3746.<br>3747.<br>3748.<br>3749.<br>3750.<br>3751.<br>3752.<br>3753.<br>3754.<br>3755.<br>3756.<br>3757.<br>3758.<br>3759.<br>3760.<br>3761.<br>3762.<br>3763.<br>3764.<br>3765.<br>3766.<br>3767.<br>3768.<br>3769.<br>3770.<br>3771.<br>3772.<br>3773.<br>3774.<br>3775.<br>3776.<br>3777.<br>3778.<br>3779.<br>3780.<br>3781.<br>3782.<br>3783.<br>3784.<br>3785.<br>3786.<br>3787.<br>3788.<br>3789.<br>3790.<br>3791.<br>3792.<br>3793.<br>3794.<br>3795.<br>3796.<br>3797.<br>3798.<br>3799.<br>3800.<br>3801.<br>3802.<br>3803.<br>3804.<br>3805.<br>3806.<br>3807.<br>3808.<br>3809.<br>3810.<br>3811.<br>3812.<br>3813.<br>3814.<br>3815.<br>3816.<br>3817.<br>3818.<br>3819.<br>3820.<br>3821.<br>3822.<br>3823.<br>3824.<br>3825.<br>3826.<br>3827.<br>3828.<br>3829.<br>3830.<br>3831.<br>3832.<br>3833.<br>3834.<br>3835.<br>3836.<br>3837.<br>3838.<br>3839.<br>3840.<br>3841.<br>3842.<br>3843.<br>3844.<br>3845.<br>3846.<br>3847.<br>3848.<br>3849.<br>3850.<br>3851.<br>3852.<br>3853.<br>3854.<br>3855.<br>3856.<br>3857.<br>3858.<br>3859.<br>3860.<br>3861.<br>3862.<br>3863.<br>3864.<br>3865.<br>3866.<br>3867.<br>3868.<br>3869.<br>3870.<br>3871.<br>3872.<br>3873.<br>3874.<br>3875.<br>3876.<br>3877.<br>3878.<br>3879.<br>3880.<br>3881.<br>3882.<br>3883.<br>3884.<br>3885.<br>3886.<br>3887.<br>3888.<br>3889.<br>3890.<br>3891.<br>3892.<br>3893.<br>3894.<br>3895.<br>3896.<br>3897.<br>3898.<br>3899.<br>3900.<br>3901.<br>3902.<br>3903.<br>3904.<br>3905.<br>3906.<br>3907.<br>3908.<br>3909.<br>3910.<br>3911.<br>3912.<br>3913.<br>3914.<br>3915.<br>3916.<br>3917.<br>3918.<br>3919.<br>3920.<br>3921.<br>3922.<br>3923.<br>3924.<br>3925.<br>3926.<br>3927.<br>3928.<br>3929.<br>3930.<br>3931.<br>3932.<br>3933.<br>3934.<br>3935.<br>3936.<br>3937.<br>3938.<br>3939.<br>3940.<br>3941.<br>3942.<br>3943.<br>3944.<br>3945.<br>3946.<br>3947.<br>3948.<br>3949.<br>3950.<br>3951.<br>3952.<br>3953.<br>3954.<br>3955.<br>3956.<br>3957.<br>3958.<br>3959.<br>3960.<br>3961.<br>3962.<br>3963.<br>3964.<br>3965.<br>3966.<br>3967.<br>3968.<br>3969.<br>3970.<br>3971.<br>3972.<br>3973.<br>3974.<br>3975.<br>3976.<br>3977.<br>3978.<br>3979.<br>3980.<br>3981.<br>3982.<br>3983.<br>3984.<br>3985.<br>3986.<br>3987.<br>3988.<br>3989.<br>3990.<br>3991.<br>3992.<br>3993.<br>3994.<br>3995.<br>3996.<br>3997.<br>3998.<br>3999.<br>4000.<br>4001.<br>4002.<br>4003.<br>4004.<br>4005.<br>4006.<br>4007.<br>4008.<br>4009.<br>4010.<br>4011.<br>4012.<br>4013.<br>4014.<br>4015.<br>4016.<br>4017.<br>4018.<br>4019.<br>4020.<br>4021.<br>4022.<br>4023.<br>4024.<br>4025.<br>4026.<br>4027.<br>4028.<br>4029.<br>4030.<br>4031.<br>4032.<br>4033.<br>4034.<br>4035.<br>4036.<br>4037.<br>4038.<br>4039.<br>4040.<br>4041.<br>4042.<br>4043.<br>4044.<br>4045.<br>4046.<br>4047.<br>4048.<br>4049.<br>4050.<br>4051.<br>4052.<br>4053.<br>4054.<br>4055.<br>4056.<br>4057.<br>4058.<br>4059.<br>4060.<br>4061.<br>4062.<br>4063.<br>4064.<br>4065.<br>4066.<br>4067.<br>4068.<br>4069.<br>4070.<br>4071.<br>4072.<br>4073.<br>4074.<br>4075.<br>4076.<br>4077.<br>4078.<br>4079.<br>4080.<br>4081.<br>4082.<br>4083.<br>4084.<br>4085.<br>4086.<br>4087.<br>4088.<br>4089.<br>4090.<br>4091.<br>4092.<br>4093.<br>4094.<br>4095.<br>4096.<br>4097.<br>4098.<br>4099.<br>4100.<br>4101.<br>4102.<br>4103.<br>4104.<br>4105.<br>4106.<br>4107.<br>4108.<br>4109.<br>4110.<br>4111.<br>4112.<br>4113.<br>4114.<br>4115.<br>4116.<br>4117.<br>4118.<br>4119.<br>4120.<br>4121.<br>4122.<br>4123.<br>4124.<br>4125.<br>4126.<br>4127.<br>4128.<br>4129.<br>4130.<br>4131.<br>4132.<br>4133.<br>4134.<br>4135.<br>4136.<br>4137.<br>4138.<br>4139.<br>4140.<br>4141.<br>4142.<br>4143.<br>4144.<br>4145.<br>4146.<br>4147.<br>4148.<br>4149.<br>4150.<br>4151.<br>4152.<br>4153.<br>4154.<br>4155.<br>4156.<br>4157.<br>4158.<br>4159.<br>4160.<br>4161.<br>4162.<br>4163.<br>4164.<br>4165.<br>4166.<br>4167.<br>4168.<br>4169.<br>4170.<br>4171.<br>4172.<br>4173.<br>4174.<br>4175.<br>4176.<br>4177.<br>4178.<br>4179.<br>4180.<br>4181.<br>4182.<br>4183.<br>4184.<br>4185.<br>4186.<br>4187.<br>4188.<br>4189.<br>4190.<br>4191.<br>4192.<br>4193.<br>4194.<br>4195.<br>4196.<br>4197.<br>4198.<br>4199.<br>4200.<br>4201.<br>4202.<br>4203.<br>4204.<br>4205.<br>4206.<br>4207.<br>4208.<br>4209.<br>4210.<br>4211.<br>4212.<br>4213.<br>4214.<br>4215.<br>4216.<br>4217.<br>4218.<br>4219.<br>4220.<br>4221.<br>4222.<br>4223.<br>4224.<br>4225.<br>4226.<br>4227.<br>4228.<br>4229.<br>4230.<br>4231.<br>4232.<br>4233.<br>4234.<br>4235.<br>4236.<br>4237.<br>4238.<br>4239.<br>4240.<br>4241.<br>4242.<br>4243.<br>4244.<br>4245.<br>4246.<br>4247.<br>4248.<br>4249.<br>4250.<br>4251.<br>4252.<br>4253.<br>4254.<br>4255.<br>4256.<br>4257.<br>4258.<br>4259.<br>4260.<br>4261.<br>4262.<br>4263.<br>4264.<br>4265.<br>4266.<br>4267.<br>4268.<br>4269.<br>4270.<br>4271.<br>4272.<br>4273.<br>4274.<br>4275.<br>4276.<br>4277.<br>4278.<br>4279.<br>4280.<br>4281.<br>4282.<br>4283.<br>4284.<br>4285.<br>4286.<br>4287.<br>4288.<br>4289.<br>4290.<br>4291.<br>4292.<br>4293.<br>4294.<br>4295.<br>4296.<br>4297.<br>4298.<br>4299.<br>4300.<br>4301.<br>4302.<br>4303.<br>4304.<br>4305.<br>4306.<br>4307.<br>4308.<br>4309.<br>4310.<br>4311.<br>4312.<br>4313.<br>4314.<br>4315.<br>4316.<br>4317.<br>4318.<br>4319.<br>4320.<br>4321.<br>4322.<br>4323.<br>4324.<br>4325.<br>4326.<br>4327.<br>4328.<br>4329.<br>4330.<br>4331.<br>4332.<br>4333.<br>4334.<br>4335.<br>4336.<br>4337.<br>4338.<br>4339.<br>4340.<br>4341.<br>4342.<br>4343.<br>4344.<br>4345.<br>4346.<br>4347.<br>4348.<br>4349.<br>4350.<br>4351.<br>4352.<br>4353.<br>4354.<br>4355.<br>4356.<br>4357.<br>4358.<br>4359.<br>4360.<br>4361.<br>4362.<br>4363.<br>4364.<br>4365.<br>4366.<br>4367.<br>4368.<br>4369.<br>4370.<br>4371.<br>4372.<br>4373.<br>4374.<br>4375.<br>4376.<br>4377.<br>4378.<br>4379.<br>4380.<br>4381.<br>4382.<br>4383.<br>4384.<br>4385.<br>4386.<br>4387.<br>4388.<br>4389.<br>4390.<br>4391.<br>4392.<br>4393.<br>4394.<br>4395.<br>4396.<br>4397.<br>4398.<br>4399.<br>4400.<br>4401.<br>4402.<br>4403.<br>4404.<br>4405.<br>4406.<br>4407.<br>4408.<br>4409.<br>4410.<br>4411.<br>4412.<br>4413.<br>4414.<br>4415.<br>4416.<br>4417.<br>4418.<br>4419.<br>4420.<br>4421.<br>4422.<br>4423.<br>4424.<br>4425.<br>4426.<br>4427.<br>4428.<br>4429.<br>4430.<br>4431.<br>4432.<br>4433.<br>4434.<br>4435.<br>4436.<br>4437.<br>4438.<br>4439.<br>4440.<br>4441.<br>4442.<br>4443.<br>4444.<br>4445.<br>4446.<br>4447.<br>4448.<br>4449.<br>4450.<br>4451.<br>4452.<br>4453.<br>4454.<br>4455.<br>4456.<br>4457.<br>4458.<br>4459.<br>4460.<br>4461.<br>4462.<br>4463.<br>4464.<br>4465.<br>4466.<br>4467.<br>4468.<br>4469.<br>4470.<br>4471.<br>4472.<br>4473.<br>4474.<br>4475.<br>4476.<br>4477.<br>4478.<br>4479.<br>4480.<br>4481.<br>4482.<br>4483.<br>4484.<br>4485.<br>4486.<br>4487.<br>4488.<br>4489.<br>4490.<br>4491.<br>4492.<br>4493.<br>4494.<br>4495.<br>4496.<br>4497.<br>4498.<br>4499.<br>4500.<br>4501.<br>4502.<br>4503.<br>4504.<br>4505.<br>4506.<br>4507.<br>4508.<br>4509.<br>4510.<br>4511.<br>4512.<br>4513.<br>4514.<br>4515.<br>4516.<br>4517.<br>4518.<br>4519.<br>4520.<br>4521.<br>4522.<br>4523.<br>4524.<br>4525.<br>4526.<br>4527.<br>4528.<br>4529.<br>4530.<br>4531.<br>4532.<br>4533.<br>4534.<br>4535.<br>4536.<br>4537.<br>4538.<br>4539.<br>4540.<br>4541.<br>4542.<br>4543.<br>4544.<br>4545.<br>4546.<br>4547.<br>4548.<br>4549.<br>4550.<br>4551.<br>4552.<br>4553.<br>4554.<br>4555.<br>4556.<br>4557.<br>4558.<br>4559.<br>4560.<br>4561.<br>4562.<br>4563.<br>4564.<br>4565.<br>4566.<br>4567.<br>4568.<br>4569.<br>4570.<br>4571.<br>4572.<br>4573.<br>4574.<br>4575.<br>4576.<br>4577.<br>4578.<br>4579.<br>4580.<br>4581.<br>4582.<br>4583.<br>4584.<br>4585.<br>4586.<br>4587.<br>4588.<br>4589.<br>4590.<br>4591.<br>4592.<br>4593.<br>4594.<br>4595.<br>4596.<br>4597.<br>4598.<br>4599.<br>4600.<br>4601.<br>4602.<br>4603.<br>4604.<br>4605.<br>4606.<br>4607.<br>4608.<br>4609.<br>4610.<br>4611.<br>4612.<br>4613.<br>4614.<br>4615.<br>4616.<br>4617.<br>4618.<br>4619.<br>4620.<br>4621.<br>4622.<br>4623.<br>4624.<br>4625.<br>4626.<br>4627.<br>4628.<br>4629.<br>4630.<br>4631.<br>4632.<br>4633.<br>4634.<br>4635.<br>4636.<br>4637.<br>4638.<br>4639.<br>4640.<br>4641.<br>4642.<br>4643.<br>4644.<br>4645.<br>4646.<br>4647.<br>4648.<br>4649.<br>4650.<br>4651.<br>4652.<br>4653.<br>4654.<br>4655.<br>4656.<br>4657.<br>4658.<br>4659.<br>4660.<br>4661.<br>4662.<br>4663.<br>4664.<br>4665.<br>4666.<br>4667.<br>4668.<br>4669.<br>4670.<br>4671.<br>4672.<br>4673.<br>4674.<br>4675.<br>4676.<br>4677.<br>4678.<br>4679.<br>4680.<br>4681.<br>4682.<br>4683.<br>4684.<br>4685.<br>4686.<br>4687.<br>4688.<br>4689.<br>4690.<br>4691.<br>4692.<br>4693.<br>4694.<br>4695.<br>4696.<br>4697.<br>4698.<br>4699.<br>4700.<br>4701.<br>4702.<br>4703.<br>4704.<br>4705.<br>4706.<br>4707.<br>4708.<br>4709.<br>4710.<br>4711.<br>4712.<br>4713.<br>4714.<br>4715.<br>4716.<br>4717.<br>4718.<br>4719.<br>4720.<br>4721.<br>4722.<br>4723.<br>4724.<br>4725.<br>4726.<br>4727.<br>4728.<br>4729.<br>4730.<br>4731.<br>4732.<br>4733.<br>4734.<br>4735.<br>4736.<br>4737.<br>4738.<br>4739.<br>4740.<br>4741.<br>4742.<br>4743.<br>4744.<br>4745.<br>4746.<br>4747.<br>4748.<br>4749.<br>4750.<br>4751.<br>4752.<br>4753.<br>4754.<br>4755.<br>4756.<br>4757.<br>4758.<br>4759.<br>4760.<br>4761.<br>4762.<br>4763.<br>4764.<br>4765.<br>4766.<br>4767.<br>4768.<br>4769.<br>4770.<br>4771.<br>4772.<br>4773.<br>4774.<br>4775.<br>4776.<br>4777.<br>4778.<br>4779.<br>4780.<br>4781.<br>4782.<br>4783.<br>4784.<br>4785.<br>4786.<br>4787.<br>4788.<br>4789.<br>4790.<br>4791.<br>4792.<br>4793.<br>4794.<br>4795.<br>4796.<br>4797.<br>4798.<br>4799.<br>4800.<br>4801.<br>4802.<br>4803.<br>4804.<br>4805.<br>4806.<br>4807.<br>4808.<br>4809.<br>4810.<br>4811.<br>4812.<br>4813.<br>4814.<br>4815.<br>4816.<br>4817.<br>4818.<br>4819.<br>4820.<br>4821.<br>4822.<br>4823.<br>4824.<br>4825.<br>4826.<br>4827.<br>4828.<br>4829.<br>4830.<br>4831.<br>4832.<br>4833.<br>4834.<br>4835.<br>4836.<br>4837.<br>4838.<br>4839.<br>4840.<br>4841.<br>4842.<br>4843.<br>4844.<br>4845.<br>4846.<br>4847.<br>4848.<br>4849.<br>4850.<br>4851.<br>4852.<br>4853.<br>4854.<br>4855.<br>4856.<br>4857.<br>4858.<br>4859.<br>4860.<br>4861.<br>4862.<br>4863.<br>4864.<br>4865.<br>4866.<br>4867.<br>4868.<br>4869.<br>4870.<br>4871.<br>4872.<br>4873.<br>4874.<br>4875.<br>4876.<br>4877.<br>4878.<br>4879.<br>4880.<br>4881.<br>4882.<br>4883.<br>4884.<br>4885.<br>4886.<br>4887.<br>4888.<br>4889.<br>4890.<br>4891.<br>4892.<br>4893.<br>4894.<br>4895.<br>4896.<br>4897.<br>4898.<br>4899.<br>4900.<br>4901.<br>4902.<br>4903.<br>4904.<br>4905.<br>4906.<br>4907.<br>4908.<br>4909.<br>4910.<br>4911.<br>4912.<br>4913.<br>4914.<br>4915.<br>4916.<br>4917.<br>4918.<br>4919.<br>4920.<br>4921.<br>4922.<br>4923.<br>4924.<br>4925.<br>4926.<br>4927.<br>4928.<br>4929.<br>4930.<br>4931.<br>4932.<br>4933.<br>4934.<br>4935.<br>4936.<br>4937.<br>4938.<br>4939.<br>4940.<br>4941.<br>4942.<br>4943.<br>4944.<br>4945.<br>4946.<br>4947.<br>4948.<br>4949.<br>4950.<br>4951.<br>4952.<br>4953.<br>4954.<br>4955.<br>4956.<br>4957.<br>4958.<br>4959.<br>4960.<br>4961.<br>4962.<br>4963.<br>4964.<br>4965.<br>4966.<br>4967.<br>4968.<br>4969.<br>4970.<br>4971.<br>4972.<br>4973.<br>4974.<br>4975.<br>4976.<br>4977.<br>4978.<br>4979.<br>4980.<br>4981.<br>4982.<br>4983.<br>4984.<br>4985.<br>4986.<br>4987.<br>4988.<br>4989.<br>4990.<br>4991.<br>4992.<br>4993.<br>4994.<br>4995.<br>4996.<br>4997.<br>4998.<br>4999.<br>5000.<br>5001.<br>5002.<br>5003.<br>5004.<br>5005.<br>5006.<br>5007.<br>5008.<br>5009.<br>5010.<br>5011.<br>5012.<br>5013.<br>5014.<br>5015.<br>5016.<br>5017.<br>5018.<br>5019.<br>5020.<br>5021.<br>5022.<br>5023.<br>5024.<br>5025.<br>5026.<br>5027.<br>5028.<br>5029.<br>5030.<br>5031.<br>5032.<br>5033.<br>5034.<br>5035.<br>5036.<br>5037.<br>5038.<br>5039.<br>5040.<br>5041.<br>5042.<br>5043.<br>5044.<br>5045.<br>5046.<br>5047.<br>5048.<br>5049.<br>5050.<br>5051.<br>5052.<br>5053.<br>5054.<br>5055.<br>5056.<br>5057.<br>5058.<br>5059.<br>5060.<br>5061.<br>5062.<br>5063.<br>5064.<br>5065.<br>5066.<br>5067.<br>5068.<br>5069.<br>5070.<br>5071.<br>5072.<br>5073.<br>5074.<br>5075.<br>5076.<br>5077.<br>5078.<br>5079.<br>5080.<br>5081.<br>5082.<br>5083.<br>5084.<br>5085.<br>5086.<br>5087.<br>5088.<br>5089.<br>5090.<br>5091.<br>5092.<br>5093.<br>5094.<br>5095.<br>5096.<br>5097.<br>5098.<br>5099.<br>5100.<br>5101.<br>5102.<br>5103.<br>5104.<br>5105.<br>5106.<br>5107.<br>5108.<br>5109.<br>5110.<br>5111.<br>5112.<br>5113.<br>5114.<br>5115.<br>5116.<br>5117.<br>5118.<br>5119.<br>5120.<br>5121.<br>5122.<br>5123.<br>5124.<br>5125.<br>5126.<br>5127.<br>5128.<br>5129.<br>5130.<br>5131.<br>5132.<br>5133.<br>5134.<br>5135.<br>5136.<br>5137.<br>5138.<br>5139.<br>5140.<br>5141.<br>5142.<br>5143.<br>5144.<br>5145.<br>5146.<br>5147.<br>5148.<br>5149.<br>5150.<br>5151.<br>5152.<br>5153.<br>5154.<br>5155.<br>5156.<br>5157.<br>5158.<br>5159.<br>5160.<br>5161.<br>5162.<br>5163.<br>5164.<br>5165.<br>5166.<br>5167.<br>5168.<br>5169.<br>5170.<br>5171.<br>5172.<br>5173.<br>5174.<br>5175.<br>5176.<br>5177.<br>5178.<br>5179.<br>5180.<br>5181.<br>5182.<br>5183.<br>5184.<br>5185.<br>5186.<br>5187.<br>5188.<br>5189.<br>5190.<br>5191.<br>5192.<br>5193.<br>5194.<br>5195.<br>5196.<br>5197.<br>5198.<br>5199.<br>5200.<br>5201.<br>5202.<br>5203.<br>5204.<br>5205.<br>5206.<br>5207.<br>5208.<br>5209.<br>5210.<br>5211.<br>5212.<br>5213.<br>5214.<br>5215.<br>5216.<br>5217.<br>5218.<br>5219.<br>5220.<br>5221.<br>5222.<br>5223.<br>5224.<br>5225.<br>5226.<br>5227.<br>5228.<br>5229.<br>5230.<br>5231.<br>5232.<br>5233.<br>5234.<br>5235.<br>5236.<br>5237.<br>5238.<br>5239.<br>5240.<br>5241.<br>5242.<br>5243.<br>5244.<br>5245.<br>5246.<br>5247.<br>5248.<br>5249.<br>5250.<br>5251.<br>5252.<br>5253.<br>5254.<br>5255.<br>5256.<br>5257.<br>5258.<br>5259.<br>5260.<br>5261.<br>5262.<br>5263.<br>5264.<br>5265.<br>5266.<br>5267.<br>5268.<br>5269.<br>5270.<br>5271.<br>5272.<br>5273.<br>5274.<br>5275.<br>5276.<br>5277.<br>5278.<br>5279.<br>5280.<br>5281.<br>5282.<br>5283.<br>5284.<br>5285.<br>5286.<br>5287.<br>5288.<br>5289.<br>5290.<br>5291.<br>5292.<br>5293.<br>5294.<br>5295.<br>5296.<br>5297.<br>5298.<br>5299.<br>5300.<br>5301.<br>5302.<br>5303.<br>5304.<br>5305.<br>5306.<br>5307.<br>5308.<br>5309.<br>5310.<br>5311.<br>5312.<br>5313.<br>5314.<br>5315.<br>5316.<br>5317.<br>5318.<br>5319.<br>5320.<br>5321.<br>5322.<br>5323.<br>5324.<br>5325.<br>5326.<br>5327.<br>5328.<br>5329.<br>5330.<br>5331.<br>5332.<br>5333.<br>5334.<br>5335.<br>5336.<br>5337.<br>5338.<br>5339.<br>5340.<br>5341.<br>5342.<br>5343.<br>5344.<br>5345.<br>5346.<br>5347.<br>5348.<br>5349.<br>5350.<br>5351.<br>5352.<br>5353.<br>5354.<br>5355.<br>5356.<br>5357.<br>5358.<br>5359.<br>5360.<br>5361.<br>5362.<br>5363.<br>5364.<br>5365.<br>5366.<br>5367.<br>5368.<br>5369.<br>5370.<br>5371.<br>5372.<br>5373.<br>5374.<br>5375.<br>5376.<br>5377.<br>5378.<br>5379.<br>5380.<br>5381.<br>5382.<br>5383.<br>5384.<br>5385.<br>5386.<br>5387.<br>5388.<br>5389.<br>5390.<br>5391.<br>5392.<br>5393.<br>5394.<br>5395.<br>5396.<br>5397.<br>5398.<br>5399.<br>5400.<br>5401.<br>5402.<br>5403.<br>5404.<br>5405.<br>5406.<br>5407.<br>5408.<br>5409.<br>5410.<br>5411.<br>5412.<br>5413.<br>5414.<br>5415.<br>5416.<br>5417.<br>5418.<br>5419.<br>5420.<br>5421.<br>5422.<br>5423.<br>5424.<br>5425.<br>5426.<br>5427.<br>5428.<br>5429.<br>5430.<br>5431.<br>5432.<br>5433.<br>5434.<br>5435.<br>5436.<br>5437.<br>5438.<br>5439.<br>5440.<br>5441.<br>5442.<br>5443.<br>5444.<br>5445.<br>5446.<br>5447.<br>5448.<br>5449.<br>5450.<br>5451.<br>5452.<br>5453.<br>5454.<br>5455.<br>5456.<br>5457.<br>5458.<br>5459.<br>5460.<br>5461.<br>5462.<br>5463.<br>5464.<br>5465.<br>5466.<br>5467.<br>5468.<br>5469.<br>5470.<br>5471.<br>5472.<br>5473.<br>5474.<br>5475.<br>5476.<br>5477.<br>5478.<br>5479.<br>5480.<br>5481.<br>5482.<br>5483.<br>5484.<br>5485.<br>5486.<br>5487.<br>5488.<br>5489.<br>5490.<br>5491.<br>5492.<br>5493.<br>5494.<br>5495.<br>5496.<br>5497.<br>5498.<br>5499.<br>5500.<br>5501.<br>5502.<br>5503.<br>5504.<br>5505.<br>5506.<br>5507.<br>5508.<br>5509.<br>5510.<br>5511.<br>5512.<br>5513.<br>5514.<br>5515.<br>5516.<br>5517.<br>5518.<br>5519.<br>5520.<br>5521.<br>5522.<br>5523.<br>5524.<br>5525.<br>5526.<br>5527.<br>5528.<br>5529.<br>5530.<br>5531.<br>5532.<br>5533.<br>5534.<br>5535.<br>5536.<br>5537.<br>5538.<br>5539.<br>5540.<br>5541.<br>5542.<br>5543.<br>5544.<br>5545.<br>5546.<br>5547.<br>5548.<br>5549.<br>5550.<br>5551.<br>5552.<br>5553.<br>5554.<br>5555.<br>5556.<br>5557.<br>5558.<br>5559.<br>5560.<br>5561.<br>5562.<br>5563.<br>5564.<br>5565.<br>5566.<br>5567.<br>5568.<br>5569.<br>5570.<br>5571.<br>5572.<br>5573.<br>5574.<br>5575.<br>5576.<br>5577.<br>5578.<br>5579.<br>5580.<br>5581.<br>5582.<br>5583.<br>5584.<br>5585.<br>5586.<br>5587.<br>5588.<br>5589.<br>5590.<br>5591.<br>5592.<br>5593.<br>5594.<br>5595.<br>5596.<br>5597.<br>5598.<br>5599.<br>5600.<br>5601.<br>5602.<br>5603.<br>5604.<br>5605.<br>5606.<br>5607.<br>5608.<br>5609.<br>5610.<br>5611.<br>5612.<br>5613.<br>5614.<br>5615.<br>5616.<br>5617.<br>5618.<br>5619.<br>5620.<br>5621.<br>5622.<br>5623.<br>5624.<br>5625.<br>5626.<br>5627.<br>5628.<br>5629.<br>5630.<br>5631.<br>5632.<br>5633.<br>5634.<br>5635.<br>5636.<br>5637.<br>5638.<br>5639.<br>5640.<br>5641.<br>5642.<br>5643.<br>5644.<br>5645.<br>5646.<br>5647.<br>5648.<br>5649.<br>5650.<br>5651.<br>5652.<br>5653.<br>5654.<br>5655.<br>5656.<br>5657.<br>5658.<br>5659.<br>5660.<br>5661.<br>5662.<br>5663.<br>5664.<br>5665.<br>5666.<br>5667.<br>5668.<br>5669.<br>5670.<br>5671.<br>5672.<br>5673.<br>5674.<br>5675.<br>5676.<br>5677.<br>5678.<br>5679.<br>5680.<br>5681.<br>5682.<br>5683.<br>5684.<br>5685.<br>5686.<br>5687.<br>5688.<br>5689.<br>5690.<br>5691.<br>5692.<br>5693.<br>5694.<br>5695.<br>5696.<br>5697.<br>5698.<br>5699.<br>5700.<br>5701.<br>5702.<br>5703.<br>5704.<br>5705.<br>5706.<br>5707.<br>5708.<br>5709.<br>5710.<br>5711.<br>5712.<br>5713.<br>5714.<br>5715.<br>5716.<br>5717.<br>5718.<br>5719.<br>5720.<br>5721.<br>5722.<br>5723.<br>5724.<br>5725.<br>5726.<br>5727.<br>5728.<br>5729.<br>5730.<br>5731.<br>5732.<br>5733.<br>5734.<br>5735.<br>5736.<br>5737.<br>5738.<br>5739.<br>5740.<br>5741.<br>5742.<br>5743.<br>5744.<br>5745.<br>5746.<br>5747.<br>5748.<br>5749.<br>5750.<br>5751.<br>5752.<br>5753.<br>5754.<br>5755.<br>5756.<br>5757.<br>5758.<br>5759.<br>5760.<br>5761.<br>5762.<br>5763.<br>5764.<br>5765.<br>5766.<br>5767.<br>5768.<br>5769.<br>5770.<br>5771.<br>5772.<br>5773.<br>5774.<br>5775.<br>5776.<br>5777.<br>5778.<br>5779.<br>5780.<br>5781.<br>5782.<br>5783.<br>5784.<br>5785.<br>5786.<br>5787.<br>5788.<br>5789.<br>5790.<br>5791.<br>5792.<br>5793.<br>5794.<br>5795.<br>5796.<br>5797.<br>5798.<br>5799.<br>5800.<br>5801.<br>5802.<br>5803.<br>5804.<br>5805.<br>5806.<br>5807.<br>5808.<br>5809.<br>5810.<br>5811.<br>5812.<br>5813.<br>5814.<br>5815.<br>5816.<br>5817.<br>5818.<br>5819.<br>5820.<br>5821.<br>5822.<br>5823.<br>5824.<br>5825.<br>5826.<br>5827.<br>5828.<br>5829.<br>5830.<br>5831.<br>5832.<br>5833.<br>5834.<br>5835.<br>5836.<br>5837.<br>5838.<br>5839.<br>5840.<br>5841.<br>5842.<br>5843.<br>5844.<br>5845.<br>5846.<br>5847.<br>5848.<br>5849.<br>5850.<br>5851.<br>5852.<br>5853.<br>5854.<br>5855.<br>5856.<br>5857.<br>5858.<br>5859.<br>5860.<br>5861.<br>5862.<br>5863.<br>5864.<br>5865.<br>5866.<br>5867.<br>5868.<br>5869.<br>5870.<br>5871.<br>5872.<br>5873.<br>5874.<br>5875.<br>5876.<br>5877.<br>5878.<br>5879.<br>5880.<br>5881.<br>5882.<br>5883.<br>5884.<br>5885.<br>5886.<br>5887.<br>5888.<br>5889.<br>5890.<br>5891.<br>5892.<br>5893.<br>5894.<br>5895.<br>5896.<br>5897.<br>5898.<br>5899.<br>5900.<br>5901.<br>5902.<br>5903.<br>5904.<br>5905.<br>5906.<br>5907.<br>5908.<br>5909.<br>5910.<br>5911.<br>5912.<br>5913.<br>5914.<br>5915.<br>5916.<br>5917.<br>5918.<br>5919.<br>5920.<br>5921.<br>5922.<br>5923.<br>5924.<br>5925.<br>5926.<br>5927.<br>5928.<br>5929.<br>5930.<br>5931.<br>5932.<br>5933.<br>5934.<br>5935.<br>5936.<br>5937.<br>5938.<br>5939.<br>5940.<br>5941.<br>5942.<br>5943.<br>5944.<br>5945.<br>5946.<br>5947.<br>5948.<br>5949.<br>5950.<br>5951.<br>5952.<br>5953.<br>5954.<br>5955.<br>5956.<br>5957.<br>5958.<br>5959.<br>5960.<br>5961.<br>5962.<br>5963.<br>5964.<br>5965.<br>5966.<br>5967.<br>5968.<br>5969.<br>5970.<br>5971.<br>5972.<br>5973.<br>5974.<br>5975.<br>5976.<br>5977.<br>5978.<br>5979.<br>5980.<br>5981.<br>5982.<br>5983.<br>5984.<br>5985.<br>5986.<br>5987.<br>5988.<br>5989.<br>5990.<br>5991.<br>5992.<br>5993.<br>5994.<br>5995.<br>5996.<br>5997.<br>5998.<br>5999.<br>6000.<br>6001.<br>6002.<br>6003.<br>6004.<br>6005.<br>6006.<br>6007.<br>6008.<br>6009.<br>6010.<br>6011.<br>6012.<br>6013.<br>6014.<br>6015.<br>6016.<br>6017.<br>6018.<br>6019.<br>6020.<br>6021.<br>6022.<br>6023.<br>6024.<br>6025.<br>6026.<br>6027.<br>6028.<br>6029.<br>6030.<br>6031.<br>6032.<br>6033.<br>6034.<br>6035.<br>6036.<br>6037.<br>6038.<br>6039.<br>6040.<br>6041.<br>6042.<br>6043.<br>6044.<br>6045.<br>6046.<br>6047.<br>6048.<br>6049.<br>6050.<br>6051.<br>6052.<br>6053.<br>6054.<br>6055.<br>6056.<br>6057.<br>6058.<br>6059.<br>6060.<br>6061.<br>6062.<br>6063.<br>6064.<br>6065.<br>6066.<br>6067.<br>6068.<br>6069.<br>6070.<br>6071.<br>6072.<br>6073.<br>6074.<br>6075.<br>6076.<br>6077.<br>6078.<br>6079.<br>6080.<br>6081.<br>6082.<br>6083.<br>6084.<br>6085.<br>6086.<br>6087.<br>6088.<br>6089.<br>6090.<br>6091.<br>6092.<br>6093.<br>6094.<br>6095.<br>6096.<br>6097.<br>6098.<br>6099.<br>6100.<br>6101.<br>6102.<br>6103.<br>6104.<br>6105.<br>6106.<br>6107.<br>6108.<br>6109.<br>6110.<br>6111.<br>6112.<br>6113.<br>6114.<br>6115.<br>6116.<br>6117.<br>6118.<br>6119.<br>6120.<br>6121.<br>6122.<br>6123.<br>6124.<br>6125.<br>6126.<br>6127.<br>6128.<br>6129.<br>6130.<br>6131.<br>6132.<br>6133.<br>6134.<br>6135.<br>6136.<br>6137.<br>6138.<br>6139.<br>6140.<br>6141.<br>6142.<br>6143.<br>6144.<br>6145.<br>6146.<br>6147.<br>6148.<br>6149.<br>6150.<br>6151.<br>6152.<br>6153.<br>6154.<br>6155.<br>6156.<br>6157.<br>6158.<br>6159.<br>6160.<br>6161.<br>6162.<br>6163.<br>6164.<br>6165.<br>6166.<br>6167.<br>6168.<br>6169.<br>6170.<br>6171.<br>6172.<br>6173.<br>6174.<br>6175.<br>6176.<br>6177.<br>6178.<br>6179.<br>6180.<br>6181.<br>6182.<br>6183.<br>6184.<br>6185.<br>6186.<br>6187.<br>6188.<br>6189.<br>6190.<br>6191.<br>6192.<br>6193.<br>6194.<br>6195.<br>6196.<br>6197.<br>6198.<br>6199.<br>6200.<br>6201.<br>6202.<br>6203.<br>6204.<br>6205.<br>6206.<br>6207.<br>6208.<br>6209.<br>6210.<br>6211.<br>6212.<br>6213.<br>6214.<br>6215.<br>6216.<br>6217.<br>6218.<br>6219.<br>6220.<br>6221.<br>6222.<br>6223.<br>6224.<br>6225.<br>6226.<br>6227.<br>6228.<br>6229.<br>6230.<br>6231.<br>6232.<br>6233.<br>6234.<br>6235.<br>6236.<br>6237.<br>6238.<br>6239.<br>6240.<br>6241.<br>6242.<br>6243.<br>6244.<br>6245.<br>6246.<br>6247.<br>6248.<br>6249.<br>6250.<br>6251.<br>6252.<br>6253.<br>6254.<br>6255.<br>6256.<br>6257.<br>6258.<br>6259.<br>6260.<br>6261.<br>6262.<br>6263.<br>6264.<br>6265.<br>6266.<br>6267.<br>6268.<br>6269.<br>6270.<br>6271.<br>6272.<br>6273.<br>6274.<br>6275.<br>6276.<br>6277.<br>6278.<br>6279.<br>6280.<br>6281.<br>6282.<br>6283.<br>6284.<br>6285.<br>6286.<br>6287.<br>6288.<br>6289.<br>6290.<br>6291.<br>6292.<br>6293.<br>6294.<br>6295.<br>6296.<br>6297.<br>6298.<br>6299.<br>6300.<br>6301.<br>6302.<br>6303.<br>6304.<br>6305.<br>6306.<br>6307.<br>6308.<br>6309.<br>6310.<br>6311.<br>6312.<br>6313.<br>6314.<br>6315.<br>6316.<br>6317.<br>6318.<br>6319.<br>6320.<br>6321.<br>6322.<br>6323.<br>6324.<br>6325.<br>6326.<br>6327.<br>6328.<br>6329.<br>6330.<br>6331.<br>6332.<br>6333.<br>6334.<br>6335.<br>6336.<br>6337.<br>6338.<br>6339.<br>6340.<br>6341.<br>6342.<br>6343.<br>6344.<br>6345.<br>6346.<br>6347.<br>6348.<br>6349.<br>6350.<br>6351.<br>6352.<br>6353.<br>6354.<br>6355.<br>6356.<br>6357.<br>6358.<br>6359.<br>6360.<br>6361.<br>6362.<br>6363.<br>6364.<br>6365.<br>6366.<br>6367.<br>6368.<br>6369.<br>6370.<br>6371.<br>6372.<br>6373.<br>6374.<br>6375.<br>6376.<br>6377.<br>6378.<br>6379.<br>6380.<br>6381.<br>6382.<br>6383.<br>6384.<br>6385.<br>6386.<br>6387.<br>6388.<br>6389.<br>6390.<br>6391.<br>6392.<br>6393.<br>6394.<br>6395.<br>6396.<br>6397.<br>6398.<br>6399.<br>6400.<br>6401.<br>6402.<br>6403.<br>6404.<br>6405.<br>6406.<br>6407.<br>6408.<br>6409.<br>6410.<br>6411.<br>6412.<br>6413.<br>6414.<br>6415.<br>6416.<br>6417.<br>6418.<br>6419.<br>6420.<br>6421.<br>6422.<br>6423.<br>6424.<br>6425.<br>6426.<br>6427.<br>6428.<br>6429.<br>6430.<br>6431.<br>6432.<br>6433.<br>6434.<br>6435.<br>6436.<br>6437.<br>6438.<br>6439.<br>6440.<br>6441.<br>6442.<br>6443.<br>6444.<br>6445.<br>6446.<br>6447.<br>6448.<br>6449.<br>6450.<br>6451.<br>6452.<br>6453.<br>6454.<br>6455.<br>6456.<br>6457.<br>6458.<br>6459.<br>6460.<br>6461.<br>6462.<br>6463.<br>6464.<br>6465.<br>6466.<br>6467.<br>6468.<br>6469.<br>6470.<br>6471.<br>6472.<br>6473.<br>6474.<br>6475.<br>6476.<br>6477.<br>6478.<br>6479.<br>6480.<br>6481.<br>6482.<br>6483.<br>6484.<br>6485.<br>6486.<br>6487.<br>6488.<br>6489.<br>6490.<br>6491.<br>6492.<br>6493.<br>6494.<br>6495.<br>6496.<br>6497.<br>6498.<br>6499.<br>6500.<br>6501.<br>6502.<br>6503.<br>6504.<br>6505.<br>6506.<br>6507.<br>6508.<br>6509.<br>6510.<br>6511.<br>6512.<br>6513.<br>6514.<br>6515.<br>6516.<br>6517.<br>6518.<br>6519.<br>6520.<br>6521.<br>6522.<br>6523.<br>6524.<br>6525.<br>6526.<br>6527.<br>6528.<br>6529.<br>6530.<br>6531.<br>6532.<br>6533.<br>6534.<br>6535.<br>6536.<br>6537.<br>6538.<br>6539.<br>6540.<br>6541.<br>6542.<br>6543.<br>6544.<br>6545.<br>6546.<br>6547.<br>6548.<br>6549.<br>6550.<br>6551.<br>6552.<br>6553.<br>6554.<br>6555.<br>6556.<br>6557.<br>6558.<br>6559.<br>6560.<br>6561.<br>6562.<br>6563.<br>6564.<br>6565.<br>6566.<br>6567.<br>6568.<br>6569.<br>6570.<br>6571.<br>6572.<br>6573.<br>6574.<br>6575.<br>6576.<br>6577.<br>6578.<br>6579.<br>6580.<br>6581.<br>6582.<br>6583.<br>6584.<br>6585.<br>6586.<br>6587.<br>6588.<br>6589.<br>6590.<br>6591.<br>6592.<br>6593.<br>6594.<br>6595.<br>6596.<br>6597.<br>6598.<br>6599.<br>6600.<br>6601.<br>6602.<br>6603.<br>6604.<br>6605.<br>6606.<br>6607.<br>6608.<br>6609.<br>6610.<br>6611.<br>6612.<br>6613.<br>6614.<br>6615.<br>6616.<br>6617.<br>6618.<br>6619.<br>6620.<br>6621.<br>6622.<br>6623.<br>6624.<br>6625.<br>6626.<br>6627.<br>6628.<br>6629.<br>6630.<br>6631.<br>6632.<br>6633.<br>6634.<br>6635.<br>6636.<br>6637.<br>6638.<br>6639.<br>6640.<br>6641.<br>6642.<br>6643.<br>6644.<br>6645.<br>6646.<br>6647.<br>6648.<br>6649.<br>6650.<br>6651.<br>6652.<br>6653.<br>6654.<br>6655.<br>6656.<br>6657.<br>6658.<br>6659.<br>6660.<br>6661.<br>6662.<br>6663.<br>6664.<br>6665.<br>6666.<br>6667.<br>6668.<br>6669.<br>6670.<br>6671.<br>6672.<br>6673.<br>6674.<br>6675.<br>6676.<br>6677.<br>6678.<br>6679.<br>6680.<br>6681.<br>6682.<br>6683.<br>6684.<br>6685.<br>6686.<br>6687.<br>6688.<br>6689.<br>6690.<br>6691.<br>6692.<br>6693.<br>6694.<br>6695.<br>6696.<br>6697.<br>6698.<br>6699.<br>6700.<br>6701.<br>6702.<br>6703.<br>6704.<br>6705.<br>6706.<br>6707.<br>6708.<br>6709.<br>6710.<br>6711.<br>6712.<br>6713.<br>6714.<br>6715.<br>6716.<br>6717.<br>6718.<br>6719.<br>6720.<br>6721.<br>6722.<br>6723.<br>6724.<br>6725.<br>6726.<br>6727.<br>6728.<br>6729.<br>6730.<br>6731.<br>6732.<br>6733.<br>6734.<br>6735.<br>6736.<br>6737.<br>6738.<br>6739.<br>6740.<br>6741.<br>6742.<br>6743.<br>6744.<br>6745.<br>6746.<br>6747.<br>6748.<br>6749.<br>6750.<br>6751.<br>6752.<br>6753.<br>6754.<br>6755.<br>6756.<br>6757.<br>6758.<br>6759.<br>6760.<br>6761.<br>6762.<br>6763.<br>6764.<br>6765.<br>6766.<br>6767.<br>6768.<br>6769.<br>6770.<br>6771.<br>6772.<br>6773.<br>6774.<br>6775.<br>6776.<br>6777.<br>6778.<br>6779.<br>6780.<br>6781.<br>6782.<br>6783.<br>6784.<br>6785.<br>6786.<br>6787.<br>6788.<br>6789.<br>6790.<br>6791.<br>6792.<br>6793.<br>6794.<br>6795.<br>6796.<br>6797.<br>6798.<br>6799.<br>6800.<br>6801.<br>6802.<br>6803.<br>6804.<br>6805.<br>6806.<br>6807.<br>6808.<br>6809.<br>6810.<br>6811.<br>6812.<br>6813.<br>6814.<br>6815.<br>6816.<br>6817.<br>6818.<br>6819.<br>6820.<br>6821.<br>6822.<br>6823.<br>6824.<br>6825.<br>6826.<br>6827.<br>6828.<br>6829.<br>6830.<br>6831.<br>6832.<br>6833.<br>6834.<br>6835.<br>6836.<br>6837.<br>6838.<br>6839.<br>6840.<br>6841.<br>6842.<br>6843.<br>6844.<br>6845.<br>6846.<br>6847.<br>6848.<br>6849.<br>6850.<br>6851.<br>6852.<br>6853.<br>6854.<br>6855.<br>6856.<br>6857.<br>6858.<br>6859.<br>6860.<br>6861.<br>6862.<br>6863.<br>6864.<br>6865.<br>6866.<br>6867.<br>6868.<br>6869.<br>6870.<br>6871.<br>6872.<br>6873.<br>6874.<br>6875.<br>6876.<br>6877.<br>6878.<br>6879.<br>6880.<br>6881.<br>6882.<br>6883.<br>6884.<br>6885.<br>6886.<br>6887.<br>6888.<br>6889.<br>6890.<br>6891.<br>6892.<br>6893.<br>6894.<br>6895.<br>6896.<br>6897.<br>6898.<br>6899.<br>6900.<br>6901.<br>6902.<br>6903.<br>6904.<br>6905.<br>6906.<br>6907.<br>6908.<br>6909.<br>6910.<br>6911.<br>6912.<br>6913.<br>6914.<br>6915.<br>6916.<br>6917.<br>6918.<br>6919.<br>6920.<br>6921.<br>6922.<br>6923.<br>6924.<br>6925.<br>6926.<br>6927.<br>6928.<br>6929.<br>6930.<br>6931.<br>6932.<br>6933.<br>6934.<br>6935.<br>6936.<br>6937.<br>6938.<br>6939.<br>6940.<br>6941.<br>6942.<br>6943.<br>6944.<br>6945.<br>6946.<br>6947.<br>6948.<br>6949.<br>6950.<br>6951.<br>6952.<br>6953.<br>6954.<br>6955.<br>6956.<br>6957.<br>6958.<br>6959.<br>6960.<br>6961.<br>6962.<br>6963.<br>6964.<br>6965.<br>6966.<br>6967.<br>6968.<br>6969.<br>6970.<br>6971.<br>6972.<br>6973.<br>6974.<br>6975.<br>6976.<br>6977.<br>6978.<br>6979.<br>6980.<br>6981.<br>6982.<br>6983.<br>6984.<br>6985.<br>6986.<br>6987.<br>6988.<br>6989.<br>6990.<br>6991.<br>6992.<br>6993.<br>6994.<br>6995.<br>6996.<br>6997.<br>6998.<br>6999.<br>7000.<br>7001.<br>7002.<br>7003.<br>7004.<br>7005.<br>7006.<br>7007.<br>7008.<br>7009.<br>7010.<br>7011.<br>7012.<br>7013.<br>7014.<br>7015.<br>7016.<br>7017.<br>7018.<br>7019.<br>7020.<br>7021.<br>7022.<br>7023.<br>7024.<br>7025.<br>7026.<br>7027.<br>7028.<br>7029.<br>7030.<br>7031.<br>7032.<br>7033.<br>7034.<br>7035.<br>7036.<br>7037.<br>7038.<br>7039.<br>7040.<br>7041.<br>7042.<br>7043.<br>7044.<br>7045.<br>7046.<br>7047.<br>7048.<br>7049.<br>7050.<br>7051.<br>7052.<br>7053.<br>7054.<br>7055.<br>7056.<br>7057.<br>7058.<br>7059.<br>7060.<br>7061.<br>7062.<br>7063.<br>7064.<br>7065.<br>7066.<br>7067.<br>7068.<br>7069.<br>7070.<br>7071.<br>7072.<br>7073.<br>7074.<br>7075.<br>7076.<br>7077.<br>7078.<br>7079.<br>7080.<br>7081.<br>7082.<br>7083.<br>7084.<br>7085.<br>7086.<br>7087.<br>7088.<br>7089.<br>7090.<br>7091.<br>7092.<br>7093.<br>7094.<br>7095.<br>7096.<br>7097.<br>7098.<br>7099.<br>7100.<br>7101.<br>7102.<br>7103.<br>7104.<br>7105.<br>7106.<br>7107.<br>7108.<br>7109.<br>7110.<br>7111.<br>7112.<br>7113.<br>7114.<br>7115.<br>7116.<br>7117.<br>7118.<br>7119.<br>7120.<br>7121.<br>7122.<br>7123.<br>7124.<br>7125.<br>7126.<br>7127.<br>7128.<br>7129.<br>7130.<br>7131.<br>7132.<br>7133.<br>7134.<br>7135.<br>7136.<br>7137.<br>7138.<br>7139.<br>7140.<br>7141.<br>7142.<br>7143.<br>7144.<br>7145.<br>7146.<br>7147.<br>7148.<br>7149.<br>7150.<br>7151.<br>7152.<br>7153.<br>7154.<br>7155.<br>7156.<br>7157.<br>7158.<br>7159.<br>7160.<br>7161.<br>7162.<br>7163.<br>7164.<br>7165.<br>7166.<br>7167.<br>7168.<br>7169.<br>7170.<br>7171.<br>7172.<br>7173.<br>7174.<br>7175.<br>7176.<br>7177.<br>7178.<br>7179.<br>7180.<br>7181.<br>7182.<br>7183.<br>7184.<br>7185.<br>7186.<br>7187.<br>7188.<br>7189.<br>7190.<br>7191.<br>7192.<br>7193.<br>7194.<br>7195.<br>7196.<br>7197.<br>7198.<br>7199.<br>7200.<br>7201.<br>7202.<br>7203.<br>7204.<br>7205.<br>7206.<br>7207.<br>7208.<br>7209.<br>7210.<br>7211.<br>7212.<br>7213.<br>7214.<br>7215.<br>7216.<br>7217.<br>7218.<br>7219.<br>7220.<br>7221.<br>7222.<br>7223.<br>7224.<br>7225.<br>7226.<br>7227.<br>7228.<br>7229.<br>7230.<br>7231.<br>7232.<br>7233.<br>7234.<br>7235.<br>7236.<br>7237.<br>7238.<br>7239.<br>7240.<br>7241.<br>7242.<br>7243.<br>7244.<br>7245.<br>7246.<br>7247.<br>7248.<br>7249.<br>7250.<br>7251.<br>7252.<br>7253.<br>7254.<br>7255.<br>7256.<br>7257.<br>7258.<br>7259.<br>7260.<br>7261.<br>7262.<br>7263.<br>7264.<br>7265.<br>7266.<br>7267.<br>7268.<br>7269.<br>7270.<br>7271.<br>7272.<br>7273.<br>7274.<br>7275.<br>7276.<br>7277.<br>7278.<br>7279.<br>7280.<br>7281.<br>7282.<br>7283.<br>7284.<br>7285.<br>7286.<br>7287.<br>7288.<br>7289.<br>7290.<br>7291.<br>7292.<br>7293.<br>7294.<br>7295.<br>7296.<br>7297.<br>7298.<br>7299.<br>7300.<br>7301.<br>7302.<br>7303.<br>7304.<br>7305.<br>7306.<br>7307.<br>7308.<br>7309.<br>7310.<br>7311.<br>7312.<br>7313.<br>7314.<br>7315.<br>7316.<br>7317.<br>7318.<br>7319.<br>7320.<br>7321.<br>7322.<br>7323.<br>7324.<br>7325.<br>7326.<br>7327.<br>7328.<br>7329.<br>7330.<br>7331.<br>7332.<br>7333.<br>7334.<br>7335.<br>7336.<br>7337.<br>7338.<br>7339.<br>7340.<br>7341.<br>7342.<br>7343.<br>7344.<br>7345.<br>7346.<br>7347.<br>7348.<br>7349.<br>7350.<br>7351.<br>7352.<br>7353.<br>7354.<br>7355.<br>7356.<br>7357.<br>7358.<br>7359.<br>7360.<br>7361.<br>7362.<br>7363.<br>7364.<br>7365.<br>7366.<br>7367.<br>7368.<br>7369.<br>7370.<br>7371.<br>7372.<br>7373.<br>7374.<br>7375.<br>7376.<br>7377.<br>7378.<br>7379.<br>7380.<br>7381.<br>7382.<br>7383.<br>7384.<br>7385.<br>7386.<br>7387.<br>7388.<br>7389.<br>7390.<br>7391.<br>7392.<br>7393.<br>7394.<br>7395.<br>7396.<br>7397.<br>7398.<br>7399.<br>7400.<br>7401.<br>7402.<br>7403.<br>7404.<br>7405.<br>7406.<br>7407.<br>7408.<br>7409.<br>7410.<br>7411.<br>7412.<br>7413.<br>7414.<br>7415.<br>7416.<br>7417.<br>7418.<br>7419.<br>7420.<br>7421.<br>7422.<br>7423.<br>7424.<br>7425.<br>7426.<br>7427.<br>7428.<br>7429.<br>7430.<br>7431.<br>7432.<br>7433.<br>7434.<br>7435.<br>7436.<br>7437.<br>7438.<br>7439.<br>7440.<br>7441.<br>7442.<br>7443.<br>7444.<br>7445.<br>7446.<br>7447.<br>7448.<br>7449.<br>7450.<br>7451.<br>7452.<br>7453.<br>7454.<br>7455.<br>7456.<br>7457.<br>7458.<br>7459.<br>7460.<br>7461.<br>7462.<br>7463.<br>7464.<br>7465.<br>7466.<br>7467.<br>7468.<br>7469.<br>7470.<br>7471.<br>7472.<br>7473.<br>7474.<br>7475.<br>7476.<br>7477.<br>7478.<br>7479.<br>7480.<br>7481.<br>7482.<br>7483.<br>7484.<br>7485.<br>7486.<br>7487.<br>7488.<br>7489.<br>7490.<br>7491.<br>7492.<br>7493.<br>7494.<br>7495.<br>7496.<br>7497.<br>7498.<br>7499.<br>7500.<br>7501.<br>7502.<br>7503.<br>7504.<br>7505.<br>7506.<br>7507.<br>7508.<br>7509.<br>7510.<br>7511.<br>7512.<br>7513.<br>7514.<br>7515.<br>7516.<br>7517.<br>7518.<br>7519.<br>7520.<br>7521.<br>7522.<br>7523.<br>7524.<br>7525.<br>7526.<br>7527.<br>7528.<br>7529.<br>7530.<br>7531.<br>7532.<br>7533.<br>7534.<br>7535.<br>7536.<br>7537.<br>7538.<br>7539.<br>7540.<br>7541.<br>7542.<br>7543.<br>7544.<br>7545.<br>7546.<br>7547.<br>7548.<br>7549.<br>7550.<br>7551.<br>7552.<br>7553.<br>7554.<br>7555.<br>7556.<br>7557.<br>7558.<br>7559.<br>7560.<br>7561.<br>7562.<br>7563.<br>7564.<br>7565.<br>7566.<br>7567.<br>7568.<br>7569.<br>7570.<br>7571.<br>7572.<br>7573.<br>7574.<br>7575.<br>7576.<br>7577.<br>7578.<br>7579.<br>7580.<br>7581.<br>7582.<br>7583.<br>7584.<br>7585.<br>7586.<br>7587.<br>7588.<br>7589.<br>7590.<br>7591.<br>7592.<br>7593.<br>7594.<br>7595.<br>7596.<br>7597.<br>7598.<br>7599.<br>7600.<br>7601.<br>7602.<br>7603.<br>7604.<br>7605.<br>7606.<br>7607.<br>7608.<br>7609.<br>7610.<br>7611.<br>7612.<br>7613.<br>7614.<br>7615.<br>7616.<br>7617.<br>7618.<br>7619.<br>7620.<br>7621.<br>7622.<br>7623.<br>7624.<br>7625.<br>7626.<br>7627.<br>7628.<br>7629.<br>7630.<br>7631.<br>7632.<br>7633.<br>7634.<br>7635.<br>7636.<br>7637.<br>7638.<br>7639.<br>7640.<br>7641.<br>7642.<br>7643.<br>7644.<br>7645.<br>7646.<br>7647.<br>7648.<br>7649.<br>7650.<br>7651.<br>7652.<br>7653.<br>7654.<br>7655.<br>7656.<br>7657.<br>7658.<br>7659.<br>7660.<br>7661.<br>7662.<br>7663.<br>7664.<br>7665.<br>7666.<br>7667.<br>7668.<br>7669.<br>7670.<br>7671.<br>7672.<br>7673.<br>7674.<br>7675.<br>7676.<br>7677.<br>7678.<br>7679.<br>7680.<br>7681.<br>7682.<br>7683.<br>7684.<br>7685.<br>7686.<br>7687.<br>7688.<br>7689.<br>7690.<br>7691.<br>7692.<br>7693.<br>7694.<br>7695.<br>7696.<br>7697.<br>7698.<br>7699.<br>7700.<br>7701.<br>7702.<br>7703.<br>7704.<br>7705.<br>7706.<br>7707.<br>7708.<br>7709.<br>7710.<br>7711.<br>7712.<br>7713.<br>7714.<br>7715.<br>7716.<br>7717.<br>7718.<br>7719.<br>7720.<br>7721.<br>7722.<br>7723.<br>7724.<br>7725.<br>7726.<br>7727.<br>7728.<br>7729.<br>7730.<br>7731.<br>7732.<br>7733.<br>7734.<br>7735.<br>7736.<br>7737.<br>7738.<br>7739.<br>7740.<br>7741.<br>7742.<br>7743.<br>7744.<br>7745.<br>7746.<br>7747.<br>7748.<br>7749.<br>7750.<br>7751.<br>7752.<br>7753.<br>7754.<br>7755.<br>7756.<br>7757.<br>7758.<br>7759.<br>7760.<br>7761.<br>7762.<br>7763.<br>7764.<br>7765.<br>7766.<br>7767.<br>7768.<br>7769.<br>7770.<br>7771.<br>7772.<br>7773.<br>7774.<br>7775.<br>7776.<br>7777.<br>7778.<br>7779.<br>7780.<br>7781.<br>7782.<br>7783.<br>7784.<br>7785.<br>7786.<br>7787.<br>7788.<br>7789.<br>7790.<br>7791.<br>7792.<br>7793.<br>7794.<br>7795.<br>7796.<br>7797.<br>7798.<br>7799.<br>7800.<br>7801.<br>7802.<br>7803.<br>7804.<br>7805.<br>7806.<br>7807.<br>7808.<br>7809.<br>7810.<br>7811.<br>7812.<br>7813.<br>7814.<br>7815.<br>7816.<br>7817.<br>7818.<br>7819.<br>7820.<br>7821.<br>7822.<br>7823.<br>7824.<br>7825.<br>7826.<br>7827.<br>7828.<br>7829.<br>7830.<br>7831.<br>7832.<br>7833.<br>7834.<br>7835.<br>7836.<br>7837.<br>7838.<br>7839.<br>7840.<br>7841.<br>7842.<br>7843.<br>7844.<br>7845.<br>7846.<br>7847.<br>7848.<br>7849.<br>7850.<br>7851.<br>7852.<br>7853.<br>7854.<br>7855.<br>7856.<br>7857.<br>7858.<br>7859.<br>7860.<br>7861.<br>7862.<br>7863.<br>7864.<br>7865.<br>7866.<br>7867.<br>7868.<br>7869.<br>7870.<br>7871.<br>7872.<br>7873.<br>7874.<br>7875.<br>7876.<br>7877.<br>7878.<br>7879.<br>7880.<br>7881.<br>7882.<br>7883.<br>7884.<br>7885.<br>7886.<br>7887.<br>7888.<br>7889.<br>7890.<br>7891.<br>7892.<br>7893.<br>7894.<br>7895.<br>7896.<br>7897.<br>7898.<br>7899.<br>7900.<br>7901.<br>7902.<br>7903.<br>7904.<br>7905.<br>7906.<br>7907.<br>7908.<br>7909.<br>7910.<br>7911.<br>7912.<br>7913.<br>7914.<br>7915.<br>7916.<br>7917.<br>7918.<br>7919.<br>7920.<br>7921.<br>7922.<br>7923.<br>7924.<br>7925.<br>7926.<br>7927.<br>7928.<br>7929.<br>7930.<br>7931.<br>7932.<br>7933.<br>7934.<br>7935.<br>7936.<br>7937.<br>7938.<br>7939.<br>7940.<br>7941.<br>7942.<br>7943.<br>7944.<br>7945.<br>7946.<br>7947.<br>7948.<br>7949.<br>7950.<br>7951.<br>7952.<br>7953.<br>7954.<br>7955.<br>7956.<br>7957.<br>7958.<br>7959.<br>7960.<br>7961.<br>7962.<br>7963.<br>7964.<br>7965.<br>7966.<br>7967.<br>7968.<br>7969.<br>7970.<br>7971.<br>7972.<br>7973.<br>7974.<br>7975.<br>7976.<br>7977.<br>7978.<br>7979.<br>7980.<br>7981.<br>7982.<br>7983.<br>7984.<br>7985.<br>7986.<br>7987.<br>7988.<br>7989.<br>7990.<br>7991.<br>7992.<br>7993.<br>7994.<br>7995.<br>7996.<br>7997.<br>7998.<br>7999.<br>8000.<br>8001.<br>8002.<br>8003.<br>8004.<br>8005.<br>8006.<br>8007.<br>8008.<br>8009.<br>8010.<br>8011.<br>8012.<br>8013.<br>8014.<br>8015.<br>8016.<br>8017.<br>8018.<br>8019.<br>8020.<br>8021.<br>8022.<br>8023.<br>8024.<br>8025.<br>8026.<br>8027.<br>8028.<br>8029.<br>8030.<br>8031.<br>8032.<br>8033.<br>8034.<br>8035.<br>8036.<br>8037.<br>8038.<br>8039.<br>8040.<br>8041.<br>8042.<br>8043.<br>8044.<br>8045.<br>8046.<br>8047.<br>8048.<br>8049.<br>8050.<br>8051.<br>8052.<br>8053.<br>8054.<br>8055.<br>8056.<br>8057.<br>8058.<br>8059.<br>8060.<br>8061.<br>8062.<br>8063.<br>8064.<br>8065.<br>8066.<br>8067.<br>8068.<br>8069.<br>8070.<br>8071.<br>8072.<br>8073.<br>8074.<br>8075.<br>8076.<br>8077.<br>8078.<br>8079.<br>8080.<br>8081.<br>8082.<br>8083.<br>8084.<br>8085.<br>8086.<br>8087.<br>8088.<br>8089.<br>8090.<br>8091.<br>8092.<br>8093.<br>8094.<br>8095.<br>8096.<br>8097.<br>8098.<br>8099.<br>8100.<br>8101.<br>8102.<br>8103.<br>8104.<br>8105.<br>8106.<br>8107.<br>8108.<br>8109.<br>8110.<br>8111.<br>8112.<br>8113.<br>8114.<br>8115.<br>8116.<br>8117.<br>8118.<br>8119.<br>8120.<br>8121.<br>8122.<br>8123.<br>8124.<br>8125.<br>8126.<br>8127.<br>8128.<br>8129.<br>8130.<br>8131.<br>8132.<br>8133.<br>8134.<br>8135.<br>8136.<br>8137.<br>8138.<br>8139.<br>8140.<br>8141.<br>8142.<br>8143.<br>8144.<br>8145.<br>8146.<br>8147.<br>8148.<br>8149.<br>8150.<br>8151.<br>8152.<br>8153.<br>8154.<br>8155.<br>8156.<br>8157.<br>8158.<br>8159.<br>8160.<br>8161.<br>8162.<br>8163.<br>8164.<br>8165.<br>8166.<br>8167.<br>8168.<br>8169.<br>8170.<br>8171.<br>8172.<br>8173.<br>8174.<br>8175.<br>8176.<br>8177.<br>8178.<br>8179.<br>8180.<br>8181.<br>8182.<br>8183.<br>8184.<br>8185.<br>8186.<br>8187.<br>8188.<br>8189.<br>8190.<br>8191.<br>8192.<br>8193.<br>8194.<br>8195.<br>8196.<br>8197.<br>8198.<br>8199.<br>8200.<br>8201.<br>8202.<br>8203.<br>8204.<br>8205.<br>8206.<br>8207.<br>8208.<br>8209.<br>8210.<br>8211.<br>8212.<br>8213.<br>8214.<br>8215.<br>8216.<br>8217.<br>8218.<br>8219.<br>8220.<br>8221.<br>8222.<br>8223.<br>8224.<br>8225.<br>8226.<br>8227.<br>8228.<br>8229.<br>8230.<br>8231.<br>8232.<br>8233.<br>8234.<br>8235.<br>8236.<br>8237.<br>8238.<br>8239.<br>8240.<br>8241.<br>8242.<br>8243.<br>8244.<br>8245.<br>8246.<br>8247.<br>8248.<br>8249.<br>8250.<br>8251.<br>8252.<br>8253.<br>8254.<br>8255.<br>8256.<br>8257.<br>8258.<br>8259.<br>8260.<br>8261.<br>8262.<br>8263.<br>8264.<br>8265.<br>8266.<br>8267.<br>8268.<br>8269.<br>8270.<br>8271.<br>8272.<br>8273.<br>8274.<br>8275.<br>8276.<br>8277.<br>8278.<br>8279.<br>8280.<br>8281.<br>8282.<br>8283.<br>8284.<br>8285.<br>8286.<br>8287.<br>8288.<br>8289.<br>8290.<br>8291.<br>8292.<br>8293.<br>8294.<br>8295.<br>8296.<br>8297.<br>8298.<br>8299.<br>8300.<br>8301.<br>8302.<br>8303.<br>8304.<br>8305.<br>8306.<br>8307.<br>8308.<br>8309.<br>8310.<br>8311.<br>8312.<br>8313.<br>8314.<br>8315.<br>8316.<br>8317.<br>8318.<br>8319.<br>8320.<br>8321.<br>8322.<br>8323.<br>8324.<br>8325.<br>8326.<br>8327.<br>8328.<br>8329.<br>8330.<br>8331.<br>8332.<br>8333.<br>8334.<br>8335.<br>8336.<br>8337.<br>8338.<br>8339.<br>8340.<br>8341.<br>8342.<br>8343.<br>8344.<br>8345.<br>8346.<br>8347.<br>8348.<br>8349.<br>8350.<br>8351.<br>8352.<br>8353.<br>8354.<br>8355.<br>8356.<br>8357.<br>8358.<br>8359.<br>8360.<br>8361.<br>8362.<br>8363.<br>8364.<br>8365.<br>8366.<br>8367.<br>8368.<br>8369.<br>8370.<br>8371.<br>8372.<br>8373.<br>8374.<br>8375.<br>8376.<br>8377.<br>8378.<br>8379.<br>8380.<br>8381.<br>8382.<br>8383.<br>8384.<br>8385.<br>8386.<br>8387.<br>8388.<br>8389.<br>8390.<br>8391.<br>8392.<br>8393.<br>8394.<br>8395.<br>8396.<br>8397.<br>8398.<br>8399.<br>8400.<br>8401.<br>8402.<br>8403.<br>8404.<br>8405.<br>8406.<br>8407.<br>8408.<br>8409.<br>8410.<br>8411.<br>8412.<br>8413.<br>8414.<br>8415.<br>8416.<br>8417.<br>8418.<br>8419.<br>8420.<br>8421.<br>8422.<br>8423.<br>8424.<br>8425.<br>8426.<br>8427.<br>8428.<br>8429.<br>8430.<br>8431.<br>8432.<br>8433.<br>8434.<br>8435.<br>8436.<br>8437.<br>8438.<br>8439.<br>8440.<br>8441.<br>8442.<br>8443.<br>8444.<br>8445.<br>8446.<br>8447.<br>8448.<br>8449.<br>8450.<br>8451.<br>8452.<br>8453.<br>8454.<br>8455.<br>8456.<br>8457.<br>8458.<br>8459.<br>8460.<br>8461.<br>8462.<br>8463.<br>8464.<br>8465.<br>8466.<br>8467.<br>8468.<br>8469.<br>8470.<br>8471.<br>8472.<br>8473.<br>8474.<br>8475.<br>8476.<br>8477.<br>8478.<br>8479.<br>8480.<br>8481.<br>8482.<br>8483.<br>8484.<br>8485.<br>8486.<br>8487.<br>8488.<br>8489.<br>8490.<br>8491.<br>8492.<br>8493.<br>8494.<br>8495.<br>8496.<br>8497.<br>8498.<br>8499.<br>8500.<br>8501.<br>8502.<br>8503.<br>8504.<br>8505.<br>8506.<br>8507.<br>8508.<br>8509.<br>8510.<br>8511.<br>8512.<br>8513.<br>8514.<br>8515.<br>8516.<br>8517.<br>8518.<br>8519.<br>8520.<br>8521.<br>8522.<br>8523.<br>8524.<br>8525.<br>8526.<br>8527.<br>8528.<br>8529.<br>8530.<br>8531.<br>8532.<br>8533.<br>8534.<br>8535.<br>8536.<br>8537.<br>8538.<br>8539.<br>8540.<br>8541.<br>8542.<br>8543.<br>8544.<br>8545.<br>8546.<br>8547.<br>8548.<br>8549.<br>8550.<br>8551.<br>8552.<br>8553.<br>8554.<br>8555.<br>8556.<br>8557.<br>8558.<br>8559.<br>8560.<br>8561.<br>8562.<br>8563.<br>8564.<br>8565.<br>8566.<br>8567.<br>8568.<br>8569.<br>8570.<br>8571.<br>8572.<br>8573.<br>8574.<br>8575.<br>8576.<br>8577.<br>8578.<br>8579.<br>8580.<br>8581.<br>8582.<br>8583.<br>8584.<br>8585.<br>8586.<br>8587.<br>8588.<br>8589.<br>8590.<br>8591.<br>8592.<br>8593.<br>8594.<br>8595.<br>8596.<br>8597.<br>8598.<br>8599.<br>8600.<br>8601.<br>8602.<br>8603.<br>8604.<br>8605.<br>8606.<br>8607.<br>8608.<br>8609.<br>8610.<br>8611.<br>8612.<br>8613.<br>8614.<br>8615.<br>8616.<br>8617.<br>8618.<br>8619.<br>8620.<br>8621.<br>8622.<br>8623.<br>8624.<br>8625.<br>8626.<br>8627.<br>8628.<br>8629.<br>8630.<br>8631.<br>8632.<br>8633.<br>8634.<br>8635.<br>8636.<br>8637.<br>8638.<br>8639.<br>8640.<br>8641.<br>8642.<br>8643.<br>8644.<br>8645.<br>8646.<br>8647.<br>8648.<br>8649.<br>8650.<br>8651.<br>8652.<br>8653.<br>8654.<br>8655.<br>8656.<br>8657.<br>8658.<br>8659.<br>8660.<br>8661.<br>8662.<br>8663.<br>8664.<br>8665.<br>8666.<br>8667.<br>8668.<br>8669.<br>8670.<br>8671.<br>8672.<br>8673.<br>8674.<br>8675.<br>8676.<br>8677.<br>8678.<br>8679.<br>8680.<br>8681.<br>8682.<br>8683.<br>8684.<br>8685.<br>8686.<br>8687.<br>8688.<br>8689.<br>8690.<br>8691.<br>8692.<br>8693.<br>8694.<br>8695.<br>8696.<br>8697.<br>8698.<br>8699.<br>8700.<br>8701.<br>8702.<br>8703.<br>8704.<br>8705.<br>8706.<br>8707.<br>8708.<br>8709.<br>8710.<br>8711.<br>8712.<br>8713.<br>8714.<br>8715.<br>8716.<br>8717.<br>8718.<br>8719.<br>8720.<br>8721.<br>8722.<br>8723.<br>8724.<br>8725.<br>8726.<br>8727.<br>8728.<br>8729.<br>8730.<br>8731.<br>8732.<br>8733.<br>8734.<br>8735.<br>8736.<br>8737.<br>8738.<br>8739.<br>8740.<br>8741.<br>8742.<br>8743.<br>8744.<br>8745.<br>8746.<br>8747.<br>8748.<br>8749.<br>8750.<br>8751.<br>8752.<br>8753.<br>8754.<br>8755.<br>8756.<br>8757.<br>8758.<br>8759.<br>8760.<br>8761.<br>8762.<br>8763.<br>8764.<br>8765.<br>8766.<br>8767.<br>8768.<br>8769.<br>8770.<br>8771.<br>8772.<br>8773.<br>8774.<br>8775.<br>8776.<br>8777.<br>8778.<br>8779.<br>8780.<br>8781.<br>8782.<br>8783.<br>8784.<br>8785.<br>8786.<br>8787.<br>8788.<br>8789.<br>8790.<br>8791.<br>8792.<br>8793.<br>8794.<br>8795.<br>8796.<br>8797.<br>8798.<br>8799.<br>8800.<br>8801.<br>8802.<br>8803.<br>8804.<br>8805.<br>8806.<br>8807.<br>8808.<br>8809.<br>8810.<br>8811.<br>8812.<br>8813.<br>8814.<br>8815.<br>8816.<br>8817.<br>8818.<br>8819.<br>8820.<br>8821.<br>8822.<br>8823.<br>8824.<br>8825.<br>8826.<br>8827.<br>8828.<br>8829.<br>8830.<br>8831.<br>8832.<br>8833.<br>8834.<br>8835.<br>8836.<br>8837.<br>8838.<br>8839.<br>8840.<br>8841.<br>8842.<br>8843.<br>8844.<br>8845.<br>8846.<br>8847.<br>8848.<br>8849.<br>8850.<br>8851.<br>8852.<br>8853.<br>8854.<br>8855.<br>8856.<br>8857.<br>8858.<br>8859.<br>8860.<br>8861.<br>8862.<br>8863.<br>8864.<br>8865.<br>8866.<br>8867.<br>8868.<br>8869.<br>8870.<br>8871.<br>8872.<br>8873.<br>8874.<br>8875.<br>8876.<br>8877.<br>8878.<br>8879.<br>8880.<br>8881.<br>8882.<br>8883.<br>8884.<br>8885.<br>8886.<br>8887.<br>8888.<br>8889.<br>8890.<br>8891.<br>8892.<br>8893.<br>8894.<br>8895.<br>8896.<br>8897.<br>8898.<br>8899.<br>8900.<br>8901.<br>8902.<br>8903.<br>8904.<br>8905.<br>8906.<br>8907.<br>8908.<br>8909.<br>8910.<br>8911.<br>8912.<br>8913.<br>8914.<br>8915.<br>8916.<br>8917.<br>8918.<br>8919.<br>8920.<br>8921.<br>8922.<br>8923.<br>8924.<br>8925.<br>8926.<br>8927.<br>8928.<br>8929.<br>8930.<br>8931.<br>8932.<br>8933.<br>8934.<br>8935.<br>8936.<br>8937.<br>8938.<br>8939.<br>8940.<br>8941.<br>8942.<br>8943.<br>8944.<br>8945.<br>8946.<br>8947.<br>8948.<br>8949.<br>8950.<br>8951.<br>8952.<br>8953.<br>8954.<br>8955.<br>8956.<br>8957.<br>8958.<br>8959.<br>8960.<br>8961.<br>8962.<br>8963.<br>8964.<br>8965.<br>8966.<br>8967.<br>8968.<br>8969.<br>8970.<br>8971.<br>8972.<br>8973.<br>8974.<br>8975.<br>8976.<br>8977.<br>8978.<br>8979.<br>8980.<br>8981.<br>8982.<br>8983.<br>8984.<br>8985.<br>8986.<br>8987.<br>8988.<br>8989.<br>8990.<br>8991.<br>8992.<br>8993.<br>8994.<br>8995.<br>8996.<br>8997.<br>8998.<br>8999.<br>9000.<br>9001.<br>9002.<br>9003.<br>9004.<br>9005.<br>9006.<br>9007.<br>9008.<br>9009.<br>9010.<br>9011.<br>9012.<br>9013.<br>9014.<br>9015.<br>9016.<br>9017.<br>9018.<br>9019.<br>9020.<br>9021.<br>9022.<br>9023.<br>9024.<br>9025.<br>9026.<br>9027.<br>9028.<br>9029.<br>9030.<br>9031.<br>9032.<br>9033.<br>9034.<br>9035.<br>9036.<br>9037.<br>9038.<br>9039.<br>9040.<br>9041.<br>9042.<br>9043.<br>9044.<br>9045.<br>9046.<br>9047.<br>9048.<br>9049.<br>9050.<br>9051.<br>9052.<br>9053.<br>9054.<br>9055.<br>9056.<br>9057.<br>9058.<br>9059.<br>9060.<br>9061.<br>9062.<br>9063.<br>9064.<br>9065.<br>9066.<br>9067.<br>9068.<br>9069.<br>9070.<br>9071.<br>9072.<br>9073.<br>9074.<br>9075.<br>9076.<br>9077.<br>9078.<br>9079.<br>9080.<br>9081.<br>9082.<br>9083.<br>9084.<br>9085.<br>9086.<br>9087.<br>9088.<br>9089.<br>9090.<br>9091.<br>9092.<br>9093.<br>9094.<br>9095.<br>9096.<br>9097.<br>9098.<br>9099.<br>9100.<br>9101.<br>9102.<br>9103.<br>9104.<br>9105.<br>9106.<br>9107.<br>9108.<br>9109.<br>9110.<br>9111.<br>9112.<br>9113.<br>9114.<br>9115.<br>9116.<br>9117.<br>9118.<br>9119.<br>9120.<br>9121.<br>9122.<br>9123.<br>9124.<br>9125.<br>9126.<br>9127.<br>9128.<br>9129.<br>9130.<br>9131.<br>9132.<br>9133.<br>9134.<br>9135.<br>9136.<br>9137.<br>9138.<br>9139.<br>9140.<br>9141.<br>9142.<br>9143.<br>9144.<br>9145.<br>9146.<br>9147.<br>9148.<br>9149.<br>9150.<br>9151.<br>9152.<br>9153.<br>9154.<br>9155.<br>9156.<br>9157.<br>9158.<br>9159.<br>9160.<br>9161.<br>9162.<br>9163.<br>9164.<br>9165.<br>9166.<br>9167.<br>9168.<br>9169.<br>9170.<br>9171.<br>9172.<br>9173.<br>9174.<br>9175.<br>9176.<br>9177.<br>9178.<br>9179.<br>9180.<br>9181.<br>9182.<br>9183.<br>9184.<br>9185.<br>9186.<br>9187.<br>9188.<br>9189.<br>9190.<br>9191.<br>9192.<br>9193.<br>9194.<br>9195.<br>9196.<br>9197.<br>9198.<br>9199.<br>9200.<br>9201.<br>9202.<br>9203.<br>9204.<br>9205.<br>9206.<br>9207.<br>9208.<br>9209.<br>9210.<br>9211.<br>9212.<br>9213.<br>9214.<br>9215.<br>9216.<br>9217.<br>9218.<br>9219.<br>9220.<br>9221.<br>9222.<br>9223.<br>9224.<br>9225.<br>9226.<br>9227.<br>9228.<br>9229.<br>9230.<br>9231.<br>9232.<br>9233.<br>9234.<br>9235.<br>9236.<br>9237.<br>9238.<br>9239.<br>9240.<br>9241.<br>9242.<br>9243.<br>9244.<br>9245.<br>9246.<br>9247.<br>9248.<br>9249.<br>9250.<br>9251.<br>9252.<br>9253.<br>9254.<br>9255.<br>9256.<br>9257.<br>9258.<br>9259.<br>9260.<br>9261.<br>9262.<br>9263.<br>9264.<br>9265.<br>9266.<br>9267.<br>9268.<br>9269.<br>9270.<br>9271.<br>9272.<br>9273.<br>9274.<br>9275.<br>9276.<br>9277.<br>9278.<br>9279.<br>9280.<br>9281.<br>9282.<br>9283.<br>9284.<br>9285.<br>9286.<br>9287.<br>9288.<br>9289.<br>9290.<br>9291.<br>9292.<br>9293.<br>9294.<br>9295.<br>9296.<br>9297.<br>9298.<br>9299.<br>9300.<br>9301.<br>9302.<br>9303.<br>9304.<br>9305.<br>9306.<br>9307.<br>9308.<br>9309.<br>9310.<br>9311.<br>9312.<br>9313.<br>9314.<br>9315.<br>9316.<br>9317.<br>9318.<br>9319.<br>9320.<br>9321.<br>9322.<br>9323.<br>9324.<br>9325.<br>9326.<br>9327.<br>9328.<br>9329.<br>9330.<br>9331.<br>9332.<br>9333.<br>9334.<br>9335.<br>9336.<br>9337.<br>9338.<br>9339.<br>9340.<br>9341.<br>9342.<br>9343.<br>9344.<br>9345.<br>9346.<br>9347.<br>9348.<br>9349.<br>9350.<br>9351.<br>9352.<br>9353.<br>9354.<br>9355.<br>9356.<br>9357.<br>9358.<br>9359.<br>9360.<br>9361.<br>9362.<br>9363.<br>9364.<br>9365.<br>9366.<br>9367.<br>9368.<br>9369.<br>9370.<br>9371.<br>9372.<br>9373.<br>9374.<br>9375.<br>9376.<br>9377.<br>9378.<br>9379.<br>9380.<br>9381.<br>9382.<br>9383.<br>9384.<br>9385.<br>9386.<br>9387.<br>9388.<br>9389.<br>9390.<br>9391.<br>9392.<br>9393.<br>9394.<br>9395.<br>9396.<br>9397.<br>9398.<br>9399.<br>9400.<br>9401.<br>9402.<br>9403.<br>9404.<br>9405.<br>9406.<br>9407.<br>9408.<br>9409.<br>9410.<br>9411.<br>9412.<br>9413.<br>9414.<br>9415.<br>9416.<br>9417.<br>9418.<br>9419.<br>9420.<br>9421.<br>9422.<br>9423.<br>9424.<br>9425.<br>9426.<br>9427.<br>9428.<br>9429.<br>9430.<br>9431.<br>9432.<br>9433.<br>9434.<br>9435.<br>9436.<br>9437.<br>9438.<br>9439.<br>9440.<br>9441.<br>9442.<br>9443.<br>9444.<br>9445.<br>9446.<br>9447.<br>9448.<br>9449.<br>9450.<br>9451.<br>9452.<br>9453.<br>9454.<br>9455.<br>9456.<br>9457.<br>9458.<br>9459.<br>9460.<br>9461.<br>9462.<br>9463.<br>9464.<br>9465.<br>9466.<br>9467.<br>9468.<br>9469.<br>9470.<br>9471.<br>9472.<br>9473.<br>9474.<br>9475.<br>9476.<br>9477.<br>9478.<br>9479.<br>9480.<br>9481.<br>9482.<br>9483.<br>9484.<br>9485.<br>9486.<br>9487.<br>9488.<br>9489.<br>9490.<br>9491.<br>9492.<br>9493.<br>9494.<br>9495.<br>9496.<br>9497.<br>9498.<br>9499.<br>9500.<br>9501.<br>9502.<br>9503.<br>9504.<br>9505.<br>9506.<br>9507.<br>9508.<br>9509.<br>9510.<br>9511.<br>9512.<br>9513.<br>9514.<br>9515.<br>9516.<br>9517.<br>9518.<br>9519.<br>9520.<br>9521.<br>9522.<br>9523.<br>9524.<br>9525.<br>9526.<br>9527.<br>9528.<br>9529.<br>9530.<br>9531.<br>9532.<br>9533.<br>9534.<br>9535.<br>9536.<br>9537.<br>9538.<br>9539.<br>9540.<br>9541.<br>9542.<br>9543.<br>9544.<br>9545.<br>9546.<br>9547.<br>9548.<br>9549.<br>9550.<br>9551.<br>9552.<br>9553.<br>9554.<br>9555.<br>9556.<br>9557.<br>9558.<br>9559.<br>9560.<br>9561.<br>9562.<br>9563.<br>9564.<br>9565.<br>9566.<br>9567.<br>9568.<br>9569.<br>9570.<br>9571.<br>9572.<br>9573.<br>9574.<br>9575.<br>9576.<br>9577.<br>9578.<br>9579.<br>9580.<br>9581.<br>9582.<br>9583.<br>9584.<br>9585.<br>9586.<br>9587.<br>9588.<br>9589.<br>9590.<br>9591.<br>9592.<br>9593.<br>9594.<br>9595.<br>9596.<br>9597.<br>9598.<br>9599.<br>9600.<br>9601.<br>9602.<br>9603.<br>9604.<br>9605.<br>9606.<br>9607.<br>9608.<br>9609.<br>9610.<br>9611.<br>9612.<br>9613.<br>9614.<br>9615.<br>9616.<br>9617.<br>9618.<br>9619.<br>9620.<br>9621.<br>9622.<br>9623.<br>9624.<br>9625.<br>9626.<br>9627.<br>9628.<br>9629.<br>9630.<br>9631.<br>9632.<br>9633.<br>9634.<br>9635.<br>9636.<br>9637.<br>9638.<br>9639.<br>9640.<br>9641.<br>9642.<br>9643.<br>9644.<br>9645.<br>9646.<br>9647.<br>9648.<br>9649.<br>9650.<br>9651.<br>9652.<br>9653.<br>9654.<br>9655.<br>9656.<br>9657.<br>9658.<br>9659.<br>9660.<br>9661.<br>9662.<br>9663.<br>9664.<br>9665.<br>9666.<br>9667.<br>9668.<br>9669.<br>9670.<br>9671.<br>9672.<br>9673.<br>9674.<br>9675.<br>9676.<br>9677.<br>9678.<br>9679.<br>9680.<br>9681.<br>9682.<br>9683.<br>9684.<br>9685.<br>9686.<br>9687.<br>9688.<br>9689.<br>9690.<br>9691.<br>9692.<br>9693.<br>9694.<br>9695.<br>9696.<br>9697.<br>9698.<br>9699.<br>9700.<br>9701.<br>9702.<br>9703.<br>9704.<br>9705.<br>9706.<br>9707.<br>9708.<br>9709.<br>9710.<br>9711.<br>9712.<br>9713.<br>9714.<br>9715.<br>9716.<br>9717.<br>9718.<br>9719.<br>9720.<br>9721.<br>9722.<br>9723.<br>9724.<br>9725.<br>9726.<br>9727.<br>9728.<br>9729.<br>9730.<br>9731.<br>9732.<br>9733.<br>9734.<br>9735.<br>9736.<br>9737.<br>9738.<br>9739.<br>9740.<br>9741.<br>9742.<br>9743.<br>9744.<br>9745.<br>9746.<br>9747.<br>9748.<br>9749.<br>9750.<br>9751.<br>9752.<br>9753.<br>9754.<br>9755.<br>9756.<br>9757.<br>9758.<br>9759.<br>9760.<br>9761.<br>9762.<br>9763.<br>9764.<br>9765.<br>9766.<br>9767.<br>9768.<br>9769.<br>9770.<br>9771.<br>9772.<br>9773.<br>9774.<br>9775.<br>9776.<br>9777.<br>9778.<br>9779.<br>9780.<br>9781.<br>9782.<br>9783.<br>9784.<br>9785.<br>9786.<br>9787.<br>9788.<br>9789.<br>9790.<br>9791.<br>9792.<br>9793.<br>9794.<br>9795.<br>9796.<br>9797.<br>9798.<br>9799.<br>9800.<br>9801.<br>9802.<br>9803.<br>9804.<br>9805.<br>9806.<br>9807.<br>9808.<br>9809.<br>9810.<br>9811.<br>9812.<br>9813.<br>9814.<br>9815.<br>9816.<br>9817.<br>9818.<br>9819.<br>9820.<br>9821.<br>9822.<br>9823.<br>9824.<br>9825.<br>9826.<br>9827.<br>9828.<br>9829.<br>9830.<br>9831.<br>9832.<br>9833.<br>9834.<br>9835.<br>9836.<br>9837.<br>9838.<br>9839.<br>9840.<br>9841.<br>9842.<br>9843.<br>9844.<br>9845.<br>9846.<br>9847.<br>9848.<br>9849.<br>9850.<br>9851.<br>9852.<br>9853.<br>9854.<br>9855.<br>9856.<br>9857.<br>9858.<br>9859.<br>9860.<br>9861.<br>9862.<br>9863.<br>9864.<br>9865.<br>9866.<br>9867.<br>9868.<br>9869.<br>9870.<br>9871.<br>9872.<br>9873.<br>9874.<br>9875.<br>9876.<br>9877.<br>9878.<br>9879.<br>9880.<br>9881.<br>9882.<br>9883.<br>9884.<br>9885.<br>9886.<br>9887.<br>9888.<br>9889.<br>9890.<br>9891.<br>9892.<br>9893.<br>9894.<br>9895.<br>9896.<br>9897.<br>9898.<br>9899.<br>9900.<br>9901.<br>9902.<br>9903.<br>9904.<br>9905.<br>9906.<br>9907.<br>9908.<br>9909.<br>9910.<br>9911.<br>9912.<br>9913.<br>9914.<br>9915.<br>9916.<br>9917.<br>9918.<br>9919.<br>9920.<br>9921.<br>9922.<br>9923.<br>9924.<br>9925.<br>9926.<br>9927.<br>9928.<br>9929.<br>9930.<br>9931.<br>9932.<br>9933.<br>9934.<br>9935.<br>9936.<br>9937.<br>9938.<br>9939.<br>9940.<br>9941.<br>9942.<br>9943.<br>9944.<br>9945.<br>9946.<br>9947.<br>9948.<br>9949.<br>9950.<br>9951.<br>9952.<br>9953.<br>9954.<br>9955.<br>9956.<br>9957.<br>9958.<br>9959.<br>9960.<br>9961.<br>9962.<br>9963.<br>9964.<br>9965.<br>9966.<br>9967.<br>9968.<br>9969.<br>9970.<br>9971.<br>9972.<br>9973.<br>9974.<br>9975.<br>9976.<br>9977.<br>9978.<br>9979.<br>9980.<br>9981.<br>9982.<br>9983.<br>9984.<br>9985.<br>9986.<br>9987.<br>9988.<br>9989.<br>9990.<br>9991.<br>9992.<br>9993.<br>9994.<br>9995.<br>9996.<br>9997.<br>9998.<br>9999.<br>10000.<br>10001.<br>10002.<br>10003.<br>10004.<br>10005.<br>10006.<br>10007.<br>10008.<br>10009.<br>10010.<br>10011.<br>10012.<br>10013.<br>10014.<br>10015.<br>10016.<br>10017.<br>10018.<br>10019.<br>10020.<br>10021.<br>10022.<br>10023.<br>10024.<br>10025.<br>10026.<br>10027.<br>10028.<br>10029.<br>10030.<br>10031.<br>10032.<br>10033.<br>10034.<br>10035.<br>10036.<br>10037.<br>10038.<br>10039.<br>10040.<br>10041.<br>10042.<br>10043.<br>10044.<br>10045.<br>10046.<br>10047.<br>10048.<br>10049.<br>10050.<br>10051.<br>10052.<br>10053.<br>10054.<br>10055.<br>10056.<br>10057.<br>10058.<br>10059.<br>10060.<br>10061.<br>10062.<br>10063.<br>10064.<br>10065.<br>10066.<br>10067.<br>10068.<br>10069.<br>10070.<br>10071.<br>10072.<br>10073.<br>10074.<br>10075.<br>10076.<br>10077.<br>10078.<br>10079.<br>10080.<br>10081.<br>10082.<br>10083.<br>10084.<br>10085.<br>10086.<br>10087.<br>10088.<br>10089.<br>10090.<br>10091.<br>10092.<br>10093.<br>10094.<br>10095.<br>10096.<br>10097.<br>10098.<br>10099.<br>10100.<br>10101.<br>10102.<br>10103.<br>10104.<br>10105.<br>10106.<br>10107.<br>10108.<br>10109.<br>10110.<br>10111.<br>10112.<br>10113.<br>10114.<br>10115.<br>10116.<br>10117.<br>10118.<br>10119.<br>10120.<br>10121.<br>10122.<br>10123.<br>10124.<br>10125.<br>10126.<br>10127.<br>10128.<br>10129.<br>10130.<br>10131.<br>10132.<br>10133.<br>10134.<br>10135.<br>10136.<br>10137.<br>10138.<br>10139.<br>10140.<br>10141.<br>10142.<br>10143.<br>10144.<br>10145.<br>10146.<br>10147.<br>10148.<br>10149.<br>10150.<br>10151.<br>10152.<br>10153.<br>10154.<br>10155.<br>10156.<br>10157.<br>10158.<br>10159.<br>10160.<br>10161.<br>10162.<br>10163.<br>10164.<br>10165.<br>10166.<br>10167.<br>10168.<br>10169.<br>10170.<br>10171.<br>10172.<br>10173.<br>10174.<br>10175.<br>10176.<br>10177.<br>10178.<br>10179.<br>10180.<br>10181.<br>10182.<br>10183.<br>10184.<br>10185.<br>10186.<br>10187.<br>10188.<br>10189.<br>10190.<br>10191.<br>10192.<br>10193.<br>10194.<br>10195.<br>10196.<br>10197.<br>10198.<br>10199.<br>10200.<br>10201.<br>10202.<br>10203.<br>10204.<br>10205.<br>10206.<br>10207.<br>10208.<br>10209.<br>10210.<br>10211.<br>10212.<br>10213.<br>10214.<br>10215.<br>10216.<br>10217.<br>10218.<br>10219.<br>10220.<br>10221.<br>10222.<br>10223.<br>10224.<br>10225.<br>10226.<br>10227.<br>10228.<br>10229.<br>10230.<br>10231.<br>10232.<br>10233.<br>10234.<br>10235.<br>10236.<br>10237.<br>10238.<br>10239.<br>10240.<br>10241.<br>10242.<br>10243.<br>10244.<br>10245.<br>10246.<br>10247.<br>10248.<br>10249.<br>10250.<br>10251.<br>10252.<br>10253.<br>10254.<br>10255.<br>10256.<br>10257.<br>10258.<br>10259.<br>10260.<br>10261.<br>10262.<br>10263.<br>10264.<br>10265.<br>10266.<br>10267.<br>10268.<br>10269.<br>10270.<br>10271.<br>10272.<br>10273.<br>10274.<br>10275.<br>10276.<br>10277.<br>10278.<br>10279.<br>10280.<br>10281.<br>10282.<br>10283.<br>10284.<br>10285.<br>10286.<br>10287.<br>10288.<br>10289.<br>10290.<br>10291.<br>10292.<br>10293.<br>10294.<br>10295.<br>10296.<br>10297.<br>10298.<br>10299.<br>10300.<br>10301.<br>10302.<br>10303.<br>10304.<br>10305.<br>10306.<br>10307.<br>10308.<br>10309.<br>10310.<br>10311.<br>10312.<br>10313.<br>10314.<br>10315.<br>10316.<br>10317.<br>10318.<br>10319.<br>10320.<br>10321.<br>10322.<br>10323.<br>10324.<br>10325.<br>10326.<br>10327.<br>10328.<br>10329.<br>10330.<br>10331.<br>10332.<br>10333.<br>10334.<br>10335.<br>10336.<br>10337.<br>10338.<br>10339.<br>10340.<br>10341.<br>10342.<br>10343.<br>10344.<br>10345.<br>10346.<br>10347.<br>10348.<br>10349.<br>10350.<br>10351.<br>10352.<br>10353.<br>10354.<br>10355.<br>10356.<br>10357.<br>10358.<br>10359.<br>10360.<br>10361.<br>10362.<br>10363.<br>10364.<br>10365.<br>10366.<br>10367.<br>10368.<br>10369.<br>10370.<br>10371.<br>10372.<br>10373.<br>10374.<br>10375.<br>10376.<br>10377.<br>10378.<br>10379.<br>10380.<br>10381.<br>10382.<br>10383.<br>10384.<br>10385.<br>10386.<br>10387.<br>10388.<br>10389.<br>10390.<br>10391.<br>10392.<br>10393.<br>10394.<br>10395.<br>10396.<br>10397.<br>10398.<br>10399.<br>10400.<br>10401.<br>10402.<br>10403.<br>10404.<br>10405.<br>10406.<br>10407.<br>10408.<br>10409.<br>10410.<br>10411.<br>10412.<br>10413.<br>10414.<br>10415.<br>10416.<br>10417.<br>10418.<br>10419.<br>10420.<br>10421.<br>10422.<br>10423.<br>10424.<br>10425.<br>10426.<br>10427.<br>10428.<br>10429.<br>10430.<br>10431.<br>10432.<br>10433.<br>10434.<br>10435.<br>10436.<br>10437.<br>10438.<br>10439.<br>10440.<br>10441.<br>10442.<br>10443.<br>10444.<br>10445.<br>10446.<br>10447.<br>10448.<br>10449.<br>10450.<br>10451.<br>10452.<br>10453.<br>10454.<br>10455.<br>10456.<br>10457.<br>10458.<br>10459.<br>10460.<br>10461.<br>10462.<br>10463.<br>10464.<br>10465.<br>10466.<br>10467.<br>10468.<br>10469.<br>10470.<br>10471.<br>10472.<br>10473.<br>10474.<br>10475.<br>10476.<br>10477.<br>10478.<br>10479.<br>10480.<br>10481.<br>10482.<br>10483.<br>10484.<br>10485.<br>10486.<br>10487.<br>10488.<br>10489.<br>10490.<br>10491.<br>10492.<br>10493.<br>10494.<br>10495.<br>10496.<br>10497.<br>10498.<br>10499.<br>10500.<br>10501.<br>10502.<br>10503.<br>10504.<br>10505.<br>10506.<br>10507.<br>10508.<br>10509.<br>10510.<br>10511.<br>10512.<br>10513.<br>10514.<br>10515.<br>10516.<br>10517.<br>10518.<br>10519.<br>10520.<br>10521.<br>10522.<br>10523.<br>10524.<br>10525.<br>10526.<br>10527.<br>10528.<br>10529.<br>10530.<br>10531.<br>10532.<br>10533.<br>10534.<br>10535.<br>10536.<br>10537.<br>10538.<br>10539.<br>10540.<br>10541.<br>10542.<br>10543.<br>10544.<br>10545.<br>10546.<br>10547.<br>10548.<br>10549.<br>10550.<br>10551.<br>10552.<br>10553.<br>10554.<br>10555.<br>10556.<br>10557.<br>10558.<br>10559.<br>10560.<br>10561.<br>10562.<br>10563.<br>10564.<br>10565.<br>10566.<br>10567.<br>10568.<br>10569.<br>10570.<br>10571.<br>10572.<br>10573.<br>10574.<br>10575.<br>10576.<br>10577.<br>10578.<br>10579.<br>10580.<br>10581.<br>10582.<br>10583.<br>10584.<br>10585.<br>10586.<br>10587.<br>10588.<br>10589.<br>10590.<br>10591.<br>10592.<br>10593.<br>10594.<br>10595.<br>10596.<br>10597.<br>10598.<br>10599.<br>10600.<br>10601.<br>10602.<br>10603.<br>10604.<br>10605.<br>10606.<br>10607.<br>10608.<br>10609.<br>10610.<br>10611.<br>10612.<br>10613.<br>10614.<br>10615.<br>10616.<br>10617.<br>10618.<br>10619.<br>10620.<br>10621.<br>10622.<br>10623.<br>10624.<br>10625.<br>10626.<br>10627.<br>10628.<br>10629.<br>10630.<br>10631.<br>10632.<br>10633.<br>10634.<br>10635.<br>10636.<br>10637.<br>10638.<br>10639.<br>10640.<br>10641.<br>10642.<br>10643.<br>10644.<br>10645.<br>10646.<br>10647.<br>10648.<br>10649.<br>10650.<br>10651.<br>10652.<br>10653.<br>10654.<br>10655.<br>10656.<br>10657.<br>10658.<br>10659.<br>10660.<br>10661.<br>10662.<br>10663.<br>10664.<br>10665.<br>10666.<br>10667.<br>10668.<br>10669.<br>10670.<br>10671.<br>10672.<br>10673.<br>10674.<br>10675.<br>10676.<br>10677.<br>10678.<br>10679.<br>10680.<br>10681.<br>10682.<br>10683.<br>10684.<br>10685.<br>10686.<br>10687.<br>10688.<br>10689.<br>10690.<br>10691.<br>10692.<br>10693.<br>10694.<br>10695.<br>10696.<br>10697.<br>10698.<br>10699.<br>10700.<br>10701.<br>10702.<br>10703.<br>10704.<br>10705.<br>10706.<br>10707.<br>10708.<br>10709.<br>10710.<br>10711.<br>10712.<br>10713.<br>10714.<br>10715.<br>10716.<br>10717.<br>10718.<br>10719.<br>10720.<br>10721.<br>10722.<br>10723.<br>10724.<br>10725.<br>10726.<br>10727.<br>10728.<br>10729.<br>10730.<br>10731.<br>10732.<br>10733.<br>10734.<br>10735.<br>10736.<br>10737.<br>10738.<br>10739.<br>10740.<br>10741.<br>10742.<br>10743.<br>10744.<br>10745.<br>10746.<br>10747.<br>10748.<br>10749.<br>10750.<br>10751.<br>10752.<br>10753.<br>10754.<br>10755.<br>10756.<br>10757.<br>10758.<br>10759.<br>10760.<br>10761.<br>10762.<br>10763.<br>10764.<br>10765.<br>10766.<br>10767.<br>10768.<br>10769.<br>10770.<br>10771.<br>10772.<br>10773.<br>10774.<br>10775.<br>10776.<br>10777.<br>10778.<br>10779.<br>10780.<br>10781.<br>10782.<br>10783.<br>10784.<br>10785.<br>10786.<br>10787.<br>10788.<br>10789.<br>10790.<br>10791.<br>10792.<br>10793.<br>10794.<br>10795.<br>10796.<br>10797.<br>10798.<br>10799.<br>10800.<br>10801.<br>10802.<br>10803.<br>10804.<br>10805.<br>10806.<br>10807.<br>10808.<br>10809.<br>10810.<br>10811.<br>10812.<br>10813.<br>10814.<br>10815.<br>10816.<br>10817.<br>10818.<br>10819.<br>10820.<br>10821.<br>10822.<br>10823.<br>10824.<br>10825.<br>10826.<br>10827.<br>10828.<br>10829.<br>10830.<br>10831.<br>10832.<br>10833.<br>10834.<br>10835.<br>10836.<br>10837.<br>10838.<br>10839.<br>10840.<br>10841.<br>10842.<br>10843.<br>10844.<br>10845.<br>10846.<br>10847.<br>10848.<br>10849.<br>10850.<br>10851.<br>10852.<br>10853.<br>10854.<br>10855.<br>10856.<br>10857.<br>10858.<br>10859.<br>10860.<br>10861.<br>10862.<br>10863.<br>10864.<br>10865.<br>10866.<br>10867.<br>10868.<br>10869.<br>10870.<br>10871.<br>10872.<br>10873.<br>10874.<br>10875.<br>10876.<br>10877.<br>10878.<br>10879.<br>10880.<br>10881.<br>10882.<br>10883.<br>10884.<br>10885.<br>10886.<br>10887.<br>10888.<br>10889.<br>10890.<br>10891.<br>10892.<br>10893.<br>10894.<br>10895.<br>10896.<br>10897.<br>10898.<br>10899.<br>10900.<br>10901.<br>10902.<br>10903.<br>10904.<br>10905.<br>10906.<br>10907.<br>10908.<br>10909.<br>10910.<br>10911.<br>10912.<br>10913.<br>10914.<br>10915.<br>10916.<br>10917.<br>10918.<br>10919.<br>10920.<br>10921.<br>10922.<br>10923.<br>10924.<br>10925.<br>10926.<br>10927.<br>10928.<br>10929.<br>10930.<br>10931.<br>10932.<br>10933.<br>10934.<br>10935.<br>10936.<br>10937.<br>10938.<br>10939.<br>10940.<br>10941.<br>10942.<br>10943.<br>10944.<br>10945.<br>10946.<br>10947.<br>10948.<br>10949.<br>10950.<br>10951.<br>10952.<br>10953.<br>10954.<br>10955.<br>10956.<br>10957.<br>10958.<br>10959.<br>10960.<br>10961.<br>10962.<br>10963.<br>10964.<br>10965.<br>10966.<br>10967.<br>10968.<br>10969.<br>10970.<br>10971.<br>10972.<br>10973.<br>10974.<br>10975.<br>10976.<br>10977.<br>10978.<br>10979.<br>10980.<br>10981.<br>10982.<br>10983.<br>10984.<br>10985.<br>10986.<br>10987.<br>10988.<br>10989.<br>10990.<br>10991.<br>10992.<br>10993.<br>10994.<br>10995.<br>10996.<br>10997.<br>10998.<br>10999.<br>11000.<br>11001.<br>11002.<br>11003.<br>11004.<br>11005.<br>11006.<br>11007.<br>11008.<br>11009.<br>11010.<br>11011.<br>11012.<br>11013.<br>11014.<br>11015.<br>11016.<br>11017.<br>11018.<br>11019.<br>11020.<br>11021.<br>11022.<br>11023.<br>11024.<br>11025.<br>11026.<br>11027.<br>11028.<br>11029.<br>11030.<br>11031.<br>11032.<br>11033.<br>11034.<br>11035.<br>11036.<br>11037.<br>11038.<br>11039.<br>11040.<br>11041.<br>11042.<br>11043.<br>11044.<br>11045.<br>11046.<br>11047.<br>11048.<br>11049.<br>11050.<br>11051.<br>11052.<br>11053.<br>11054.<br>11055.<br>11056.<br>11057.<br>11058.<br>11059.<br>11060.<br>11061.<br>11062.<br>11063.<br>11064.<br>11065.<br>11066.<br>11067.<br>11068.<br>11069.<br>11070.<br>11071.<br>11072.<br>11073.<br>11074.<br>11075.<br>11076.<br>11077.<br>11078.<br>11079.<br>11080.<br>11081.<br>11082.<br>11083.<br>11084.<br>11085.<br>11086.<br>11087.<br>11088.<br>11089.<br>11090.<br>11091.<br>11092.<br>11093.<br>11094.<br>11095.<br>11096.<br>11097.<br>11098.<br>11099.<br>11100.<br>11101.<br>11102.<br>11103.<br>11104.<br>11105.<br>11106.<br>11107.<br>11108.<br>11109.<br>11110.<br>11111.<br>11112.<br>11113.<br>11114.<br>11115.<br>11116.<br>11117.<br>11118.<br>11119.<br>11120.<br>11121.<br>11122.<br>11123.<br>11124.<br>11125.<br>11126.<br>11127.<br>11128.<br>11129.<br>11130.<br>11131.<br>11132.<br>11133.<br>11134.<br>11135.<br>11136.<br>11137.<br>11138.<br>11139.<br>11140.<br>11141.<br>11142.<br>11143.<br>11144.<br>11145.<br>11146.<br>11147.<br>11148.<br>11149.<br>11150.<br>11151.<br>11152.<br>11153.<br>11154.<br>11155.<br>11156.<br>11157.<br>11158.<br>11159.<br>11160.<br>11161.<br>11162.<br>11163.<br>11164.<br>11165.<br>11166.<br>11167.<br>11168.<br>11169.<br>11170.<br>11171.<br>11172.<br>11173.<br>11174.<br>11175.<br>11176.<br>11177.<br>11178.<br>11179.<br>11180.<br>11181.<br>11182.<br>11183.<br>11184.<br>11185.<br>11186.<br>11187.<br>11188.<br>11189.<br>11190.<br>11191.<br>11192.<br>11193.<br>11194.<br>11195.<br>11196.<br>11197.<br>11198.<br>11199.<br>11200.<br>11201.<br>11202.<br>11203.<br>11204.<br>11205.<br>11206.<br>11207.<br>11208.<br>11209.<br>11210.<br>11211.<br>11212.<br>11213.<br>11214.<br>11215.<br>11216.<br>11217.<br>11218.<br>11219.<br>11220.<br>11221.<br>11222.<br>11223.<br>11224.<br>11225.<br>11226.<br>11227.<br>11228.<br>11229.<br>11230.<br>11231.<br>11232.<br>11233.<br>11234.<br>11235.<br>11236.<br>11237.<br>11238.<br>11239.<br>11240.<br>11241.<br>11242.<br>11243.<br>11244.<br>11245.<br>11246.<br>11247.<br>11248.<br>11249.<br>11250.<br>11251.<br>11252.<br>11253.<br>11254.<br>11255.<br>11256.<br>11257.<br>11258.<br>11259.<br>11260.<br>11261.<br>11262.<br>11263.<br>11264.<br>11265.<br>11266.<br>11267.<br>11268.<br>11269.<br>11270.<br>11271.<br>11272.<br>11273.<br>11274.<br>11275.<br>11276.<br>11277.<br>11278.<br>11279.<br>11280.<br>11281.<br>11282.<br>11283.<br>11284.<br>11285.<br>11286.<br>11287.<br>11288.<br>11289.<br>11290.<br>11291.<br>11292.<br>11293.<br>11294.<br>11295.<br>11296.<br>11297.<br>11298.<br>11299.<br>11300.<br>11301.<br>11302.<br>11303.<br>11304.<br>11305.<br>11306.<br>11307.<br>11308.<br>11309.<br>11310.<br>11311.<br>11312.<br>11313.<br>11314.<br>11315.<br>11316.<br>11317.<br>11318.<br>11319.<br>11320.<br>11321.<br>11322.<br>11323.<br>11324.<br>11325.<br>11326.<br>11327.<br>11328.<br>11329.<br>11330.<br>11331.<br>11332.<br>11333.<br>11334.<br>11335.<br>11336.<br>11337.<br>11338.<br>11339.<br>11340.<br>11341.<br>11342.<br>11343.<br>11344.<br>11345.<br>11346.<br>11347.<br>11348.<br>11349.<br>11350.<br>11351.<br>11352.<br>11353.<br>11354.<br>11355.<br>11356.<br>11357.<br>11358.<br>11359.<br>11360.<br>11361.<br>11362.<br>11363.<br>11364.<br>11365.<br>11366.<br>11367.<br>11368.<br>11369.<br>11370.<br>11371.<br>11372.<br>11373.<br>11374.<br>11375.<br>11376.<br>11377.<br>11378.<br>11379.<br>11380.<br>11381.<br>11382.<br>11383.<br>11384.<br>11385.<br>11386.<br>11387.<br>11388.<br>11389.<br>11390.<br>11391.<br>11392.<br>11393.<br>11394.<br>11395.<br>11396.<br>11397.<br>11398.<br>11399.<br>11400.<br>11401.<br>11402.<br>11403.<br>11404.<br>11405.<br>11406.<br>11407.<br>11408.<br>11409.<br>11410.<br>11411.<br>11412.<br>11413.<br>11414.<br>11415.<br>11416.<br>11417.<br>11418.<br>11419.<br>11420.<br>11421.<br>11422.<br>11423.<br>11424.<br>11425.<br>11426.<br>11427.<br>11428.<br>11429.<br>11430.<br>11431.<br>11432.<br>11433.<br>11434.<br>11435.<br>11436.<br>11437.<br>11438.<br>11439.<br>11440.<br>11441.<br>11442.<br>11443.<br>11444.<br>11445.<br>11446.<br>11447.<br>11448.<br>11449.<br>11450.<br>11451.<br>11452.<br>11453.<br>11454.<br>11455.<br>11456.<br>11457.<br>11458.<br>11459.<br>11460.<br>11461.<br>11462.<br>11463.<br>11464.<br>11465.<br>11466.<br>11467.<br>11468.<br>11469.<br>11470.<br>11471.<br>11472.<br>11473.<br>11474.<br>11475.<br>11476.<br>11477.<br>11478.<br>11479.<br>11480.<br>11481.<br>11482.<br>11483.<br>11484.<br>11485.<br>11486.<br>11487.<br>11488.<br>11489.<br>11490.<br>11491.<br>11492.<br>11493.<br>11494.<br>11495.<br>11496.<br>11497.<br>11498.<br>11499.<br>11500.<br>11501.<br>11502.<br>11503.<br>11504.<br>11505.<br>11506.<br>11507.<br>11508.<br>11509.<br>11510.<br>11511.<br>11512.<br>11513.<br>11514.<br>11515.<br>11516.<br>11517.<br>11518.<br>11519.<br>11520.<br>11521.<br>11522.<br>11523.<br>11524.<br>11525.<br>11526.<br>11527.<br>11528.<br>11529.<br>11530.<br>11531.<br>11532.<br>11533.<br>11534.<br>11535.<br>11536.<br>11537.<br>11538.<br>11539.<br>11540.<br>11541.<br>11542.<br>11543.<br>11544.<br>11545.<br>11546.<br>11547.<br>11548.<br>11549.<br>11550.<br>11551.<br>11552.<br>11553.<br>11554.<br>11555.<br>11556.<br>11557.<br>11558.<br>11559.<br>11560.<br>11561.<br>11562.<br>11563.<br>11564.<br>11565.<br>11566.<br>11567.<br>11568.<br>11569.<br>11570.<br>11571.<br>11572.<br>11573.<br>11574.<br>11575.<br>11576.<br>11577.<br>11578.<br>11579.<br>11580.<br>11581.<br>11582.<br>11583.<br>11584.<br>11585.<br>11586.<br>11587.<br>11588.<br>11589.<br>11590.<br>11591.<br>11592.<br>11593.<br>11594.<br>11595.<br>11596.<br>11597.<br>11598.<br>11599.<br>11600.<br>11601.<br>11602.<br>11603.<br>11604.<br>11605.<br>11606.<br>11607.<br>11608.<br>11609.<br>11610.<br>11611.<br>11612.<br>11613.<br>11614.<br>11615.<br>11616.<br>11617.<br>11618.<br>11619.<br>11620.<br>11621.<br>11622.<br>11623.<br>11624.<br>11625.<br>11626.<br>11627.<br>11628.<br>11629.<br>11630.<br>11631.<br>11632.<br>11633.<br>11634.<br>11635.<br>11636.<br>11637.<br>11638.<br>11639.<br>11640.<br>11641.<br>11642.<br>11643.<br>11644.<br>11645.<br>11646.<br>11647.<br>11648.<br>11649.<br>11650.<br>11651.<br>11652.<br>11653.<br>11654.<br>11655.<br>11656.<br>11657.<br>11658.<br>11659.<br>11660.<br>11661.<br>11662.<br>11663.<br>11664.<br>11665.<br>11666.<br>11667.<br>11668.<br>11669.<br>11670.<br>11671.<br>11672.<br>11673.<br>11674.<br>11675.<br>11676.<br>11677.<br>11678.<br>11679.<br>11680.<br>11681.<br>11682.<br>11683.<br>11684.<br>11685.<br>11686.<br>11687.<br>11688.<br>11689.<br>11690.<br>11691.<br>11692.<br>11693.<br>11694.<br>11695.<br>11696.<br>11697.<br>11698.<br>11699.<br>11700.<br>11701.<br>11702.<br>11703.<br>11704.<br>11705.<br>11706.<br>11707.<br>11708.<br>11709.<br>11710.<br>11711.<br>11712.<br>11713.<br>11714.<br>11715.<br>11716.<br>11717.<br>11718.<br>11719.<br>11720.<br>11721.<br>11722.<br>11723.<br>11724.<br>11725.<br>11726.<br>11727.<br>11728.<br>11729.<br>11730.<br>11731.<br>11732.<br>11733.<br>11734.<br>11735.<br>11736.<br>11737.<br>11738.<br>11739.<br>11740.<br>11741.<br>11742.<br>11743.<br>11744.<br>11745.<br>11746.<br>11747.<br>11748.<br>11749.<br>11750.<br>11751.<br>11752.<br>11753.<br>11754.<br>11755.<br>11756.<br>11757.<br>11758.<br>11759.<br>11760.<br>11761.<br>11762.<br>11763.<br>11764.<br>11765.<br>11766.<br>11767.<br>11768.<br>11769.<br>11770.<br>11771.<br>11772.<br>11773.<br>11774.<br>11775.<br>11776.<br>11777.<br>11778.<br>11779.<br>11780.<br>11781.<br>11782.<br>11783.<br>11784.<br>11785.<br>11786.<br>11787.<br>11788.<br>11789.<br>11790.<br>11791.<br>11792.<br>11793.<br>11794.<br>11795.<br>11796.<br>11797.<br>11798.<br>11799.<br>11800.<br>11801.<br>11802.<br>11803.<br>11804.<br>11805.<br>11806.<br>11807.<br>11808.<br>11809.<br>11810.<br>11811.<br>11812.<br>11813.<br>11814.<br>11815.<br>11816.<br>11817.<br>11818.<br>11819.<br>11820.<br>11821.<br>11822.<br>11823.<br>11824.<br>11825.<br>11826.<br>11827.<br>11828.<br>11829.<br>11830.<br>11831.<br>11832.<br>11833.<br>11834.<br>11835.<br>11836.<br>11837.<br>11838.<br>11839.<br>11840.<br>11841.<br>11842.<br>11843.<br>11844.<br>11845.<br>11846.<br>11847.<br>11848.<br>11849.<br>11850.<br>11851.<br>11852.<br>11853.<br>11854.<br>11855.<br>11856.<br>11857.<br>11858.<br>11859.<br>11860.<br>11861.<br>11862.<br>11863.<br>11864.<br>11865.<br>11866.<br>11867.<br>11868.<br>11869.<br>11870.<br>11871.<br>11872.<br>11873.<br>11874.<br>11875.<br>11876.<br>11877.<br>11878.<br>11879.<br>11880.<br>11881.<br>11882.<br>11883.<br>11884.<br>11885.<br>11886.<br>11887.<br>11888.<br>11889.<br>11890.<br>11891.<br>11892.<br>11893.<br>11894.<br>11895.<br>11896.<br>11897.<br>11898.<br>11899.<br>11900.<br>11901.<br>11902.<br>11903.<br>11904.<br>11905.<br>11906.<br>11907.<br>11908.<br>11909.<br>11910.<br>11911.<br>11912.<br>11913.<br>11914.<br>11915.<br>11916.<br>11917.<br>11918.<br>11919.<br>11920.<br>11921.<br>11922.<br>11923.<br>11924.<br>11925.<br>11926.<br>11927.<br>11928.<br>11929.<br>11930.<br>11931.<br>11932.<br>11933.<br>11934.<br>11935.<br>11936.<br>11937.<br>11938.<br>11939.<br>11940.<br>11941.<br>11942.<br>11943.<br>11944.<br>11945.<br>11946.<br>11947.<br>11948.<br>11949.<br>11950.<br>11951.<br>11952.<br>11953.<br>11954.<br>11955.<br>11956.<br>11957.<br>11958.<br>11959.<br>11960.<br>11961.<br>11962.<br>11963.<br>11964.<br>11965.<br>11966.<br>11967.<br>11968.<br>11969.<br>11970.<br>11971.<br>11972.<br>11973.<br>11974.<br>11975.<br>11976.<br>11977.<br>11978.<br>11979.<br>11980.<br>11981.<br>11982.<br>11983.<br>11984.<br>11985.<br>11986.<br>11987.<br>11988.<br>11989.<br>11990.<br>11991.<br>11992.<br>11993.<br>11994.<br>11995.<br>11996.<br>11997.<br>11998.<br>11999.<br>12000.<br>12001.<br>12002.<br>12003.<br>12004.<br>12005.<br>12006.<br>12007.<br>12008.<br>12009.<br>12010.<br>12011.<br>12012.<br>12013.<br>12014.<br>12015.<br>12016.<br>12017.<br>12018.<br>12019.<br>12020.<br>12021.<br>12022.<br>12023.<br>12024.<br>12025.<br>12026.<br>12027.<br>12028.<br>12029.<br>12030.<br>12031.<br>12032.<br>12033.<br>12034.<br>12035.<br>12036.<br>12037.<br>12038.<br>12039.<br>12040.<br>12041.<br>12042.<br>12043.<br>12044.<br>12045.<br>12046.<br>12047.<br>12048.<br>12049.<br>12050.<br>12051.<br>12052.<br>12053.<br>12054.<br>12055.<br>12056.<br>12057.<br>12058.<br>12059.<br>12060.<br>12061.<br>12062.<br>12063.<br>12064.<br>12065.<br>12066.<br>12067.<br>12068.<br>12069.<br>12070.<br>12071.<br>12072.<br>12073.<br>12074.<br>12075.<br>12076.<br>12077.<br>12078.<br>12079.<br>12080.<br>12081.<br>12082.<br>12083.<br>12084.<br>12085.<br>12086.<br>12087.<br>12088.<br>12089.<br>12090.<br>12091.<br>12092.<br>12093.<br>12094.<br>12095.<br>12096.<br>12097.<br>12098.<br>12099.<br>12100.<br>12101.<br>12102.<br>12103.<br>12104.<br>12105.<br>12106.<br>12107.<br>12108.<br>12109.<br>12110.<br>12111.<br>12112.<br>12113.<br>12114.<br>12115.<br>12116.<br>12117.<br>12118.<br>12119.<br>12120.<br>12121.<br>12122.<br>12123.<br>12124.<br>12125.<br>12126.<br>12127.<br>12128.<br>12129.<br>12130.<br>12131.<br>12132.<br>12133.<br>12134.<br>12135.<br>12136.<br>12137.<br>12138.<br>12139.<br>12140.<br>12141.<br>12142.<br>12143.<br>12144.<br>12145.<br>12146.<br>12147.<br>12148.<br>12149.<br>12150.<br>12151.<br>12152.<br>12153.<br>12154.<br>12155.<br>12156.<br>12157.<br>12158.<br>12159.<br>12160.<br>12161.<br>12162.<br>12163.<br>12164.<br>12165.<br>12166.<br>12167.<br>12168.<br>12169.<br>12170.<br>12171.<br>12172.<br>12173.<br>12174.<br>12175.<br>12176.<br>12177.<br>12178.<br>12179.<br>12180.<br>12181.<br>12182.<br>12183.<br>12184.<br>12185.<br>12186.<br>12187.<br>12188.<br>12189.<br>12190.<br>12191.<br>12192.<br>12193.<br>12194.<br>12195.<br>12196.<br>12197.<br>12198.<br>12199.<br>12200.<br>12201.<br>12202.<br>12203.<br>12204.<br>12205.<br>12206.<br>12207.<br>12208.<br>12209.<br>12210.<br>12211.<br>12212.<br>12213.<br>12214.<br>12215.<br>12216.<br>12217.<br>12218.<br>12219.<br>12220.<br>12221.<br>12222.<br>12223.<br>12224.<br>12225.<br>12226.<br>12227.<br>12228.<br>12229.<br>12230.<br>12231.<br>12232.<br>12233.<br>12234.<br>12235.<br>12236.<br>12237.<br>12238.<br>12239.<br>12240.<br>12241.<br>12242.<br>12243.<br>12244.<br>12245.<br>12246.<br>12247.<br>12248.<br>12249.<br>12250.<br>12251.<br>12252.<br>12253.<br>12254.<br>12255.<br>12256.<br>12257.<br>12258.<br>12259.<br>12260.<br>12261.<br>12262.<br>12263.<br>12264.<br>12265.<br>12266.<br>12267.<br>12268.<br>12269.<br>12270.<br>12271.<br>12272.<br>12273.<br>12274.<br>12275.<br>12276.<br>12277.<br>12278.<br>12279.<br>12280.<br>12281.<br>12282.<br>12283.<br>12284.<br>12285.<br>12286.<br>12287.<br>12288.<br>12289.<br>12290.<br>12291.<br>12292.<br>12293.<br>12294.<br>12295.<br>12296.<br>12297.<br>12298.<br>12299.<br>12300.<br>12301.<br>12302.<br>12303.<br>12304.<br>12305.<br>12306.<br>12307.<br>12308.<br>12309.<br>12310.<br>12311.<br>12312.<br>12313.<br>12314.<br>12315.<br>12316.<br>12317.<br>12318.<br>12319.<br>12320.<br>12321.<br>12322.<br>12323.<br>12324.<br>12325.<br>12326.<br>12327.<br>12328.<br>12329.<br>12330.<br>12331.<br>12332.<br>12333.<br>12334.<br>12335.<br>12336.<br>12337.<br>12338.<br>12339.<br>12340.<br>12341.<br>12342.<br>12343.<br>12344.<br>12345.<br>12346.<br>12347.<br>12348.<br>12349.<br>12350.<br>12351.<br>12352.<br>12353.<br>12354.<br>12355.<br>12356.<br>12357.<br>12358.<br>12359.<br>12360.<br>12361.<br>12362.<br>12363.<br>12364.<br>12365.<br>12366.<br>12367.<br>12368.<br>12369.<br>12370.<br>12371.<br>12372.<br>12373.<br>12374.<br>12375.<br>12376.<br>12377.<br>12378.<br>12379.<br>12380.<br>12381.<br>12382.<br>12383.<br>12384.<br>12385.<br>12386.<br>12387.<br>12388.<br>12389.<br>12390.<br>12391.<br>12392.<br>12393.<br>12394.<br>12395.<br>12396.<br>12397.<br>12398.<br>12399.<br>12400.<br>12401.<br>12402.<br>12403.<br>12404.<br>12405.<br>12406.<br>12407.<br>12408.<br>12409.<br>12410.<br>12411.<br>12412.<br>12413.<br>12414.<br>12415.<br>12416.<br>12417.<br>12418.<br>12419.<br>12420.<br>12421.<br>12422.<br>12423.<br>12424.<br>12425.<br>12426.<br>12427.<br>12428.<br>12429.<br>12430.<br>12431.<br>12432.<br>12433.<br>12434.<br>12435.<br>12436.<br>12437.<br>12438.<br>12439.<br>12440.<br>12441.<br>12442.<br>12443.<br>12444.<br>12445.<br>12446.<br>12447.<br>12448.<br>12449.<br>12450.<br>12451.<br>12452.<br>12453.<br>12454.<br>12455.<br>12456.<br>12457.<br>12458.<br>12459.<br>12460.<br>12461.<br>12462.<br>12463.<br>12464.<br>12465.<br>12466.<br>12467.<br>12468.<br>12469.<br>12470.<br>12471.<br>12472.<br>12473.<br>12474.<br>12475.<br>12476.<br>12477.<br>12478.<br>12479.<br>12480.<br>12481.<br>12482.<br>12483.<br>12484.<br>12485.<br>12486.<br>12487.<br>12488.<br>12489.<br>12490.<br>12491.<br>12492.<br>12493.<br>12494.<br>12495.<br>12496.<br>12497.<br>12498.<br>12499.<br>12500.<br>12501.<br>12502.<br>12503.<br>12504.<br>12505.<br>12506.<br>12507.<br>12508.<br>12509.<br>12510.<br>12511.<br>12512.<br>12513.<br>12514.<br>12515.<br>12516.<br>12517.<br>12518.<br>12519.<br>12520.<br>12521.<br>12522.<br>12523.<br>12524.<br>12525.<br>12526.<br>12527.<br>12528.<br>12529.<br>12530.<br>12531.<br>12532.<br>12533.<br>12534.<br>12535.<br>12536.<br>12537.<br>12538.<br>12539.<br>12540.<br>12541.<br>12542.<br>12543.<br>12544.<br>12545.<br>12546.<br>12547.<br>12548.<br>12549.<br>12550.<br>12551.<br>12552.<br>12553.<br>12554.<br>12555.<br>12556.<br>12557.<br>12558.<br>12559.<br>12560.<br>12561.<br>12562.<br>12563.<br>12564.<br>12565.<br>12566.<br>12567.<br>12568.<br>12569.<br>12570.<br>12571.<br>12572.<br>12573.<br>12574.<br>12575.<br>12576.<br>12577.<br>12578.<br>12579.<br>12580.<br>12581.<br>12582.<br>12583.<br>12584.<br>12585.<br>12586.<br>12587.<br>12588.<br>12589.<br>12590.<br>12591.<br>12592.<br>12593.<br>12594.<br>12595.<br>12596.<br>12597.<br>12598.<br>12599.<br>12600.<br>12601.<br>12602.<br>12603.<br>12604.<br>12605.<br>12606.<br>12607.<br>12608.<br>12609.<br>12610.<br>12611.<br>12612.<br>12613.<br>12614.<br>12615.<br>12616.<br>12617.<br>12618.<br>12619.<br>12620.<br>12621.<br>12622.<br>12623.<br>12624.<br>12625.<br>12626.<br>12627.<br>12628.<br>12629.<br>12630.<br>12631.<br>12632.<br>12633.<br>12634.<br>12635.<br>12636.<br>12637.<br>12638.<br>12639.<br>12640.<br>12641.<br>12642.<br>12643.<br>12644.<br>12645.<br>12646.<br>12647.<br>12648.<br>12649.<br>12650.<br>12651.<br>12652.<br>12653.<br>12654.<br>12655.<br>12656.<br>12657.<br>12658.<br>12659.<br>12660.<br>12661.<br>12662.<br>12663.<br>12664.<br>12665.<br>12666.<br>12667.<br>12668.<br>12669.<br>12670.<br>12671.<br>12672.<br>12673.<br>12674.<br>12675.<br>12676.<br>12677.<br>12678.<br>12679.<br>12680.<br>12681.<br>12682.<br>12683.<br>12684.<br>12685.<br>12686.<br>12687.<br>12688.<br>12689.<br>12690.<br>12691.<br>12692.<br>12693.<br>12694.<br>12695.<br>12696.<br>12697.<br>12698.<br>12699.<br>12700.<br>12701.<br>12702.<br>12703.<br>12704.<br>12705.<br>12706.<br>12707.<br>12708.<br>12709.<br>12710.<br>12711.<br>12712.<br>12713.<br>12714.<br>12715.<br>12716.<br>12717.<br>12718.<br>12719.<br>12720.<br>12721.<br>12722.<br>12723.<br>12724.<br>12725.<br>12726.<br>12727.<br>12728.<br>12729.<br>12730.<br>12731.<br>12732.<br>12733.<br>12734.<br>12735.<br>12736.<br>12737.<br>12738.<br>12739.<br>12740.<br>12741.<br>12742.<br>12743.<br>12744.<br>12745.<br>12746.<br>12747.<br>12748.<br>12749.<br>12750.<br>12751.<br>12752.<br>12753.<br>12754.<br>12755.<br>12756.<br>12757.<br>12758.<br>12759.<br>12760.<br>12761.<br>12762.<br>12763.<br>12764.<br>12765.<br>12766.<br>12767.<br>12768.<br>12769.<br>12770.<br>12771.<br>12772.<br>12773.<br>12774.<br>12775.<br>12776.<br>12777.<br>12778.<br>12779.<br>12780.<br>12781.<br>12782.<br>12783.<br>12784.<br>12785.<br>12786.<br>12787.<br>12788.<br>12789.<br>12790.<br>12791.<br>12792.<br>12793.<br>12794.<br>12795.<br>12796.<br>12797.<br>12798.<br>12799.<br>12800.<br>12801.<br>12802.<br>12803.<br>12804.<br>12805.<br>12806.<br>12807.<br>12808.<br>12809.<br>12810.<br>12811.<br>12812.<br>12813.<br>12814.<br>12815.<br>12816.<br>12817.<br>12818.<br>12819.<br>12820.<br>12821.<br>12822.<br>12823.<br>12824.<br>12825.<br>12826.<br>12827.<br>12828.<br>12829.<br>12830.<br>12831.<br>12832.<br>12833.<br>12834.<br>12835.<br>12836.<br>12837.<br>12838.<br>12839.<br>12840.<br>12841.<br>12842.<br>12843.<br>12844.<br>12845.<br>12846.<br>12847.<br>12848.<br>12849.<br>12850.<br>12851.<br>12852.<br>12853.<br>12854.<br>12855.<br>12856.<br>12857.<br>12858.<br>12859.<br>12860.<br>12861.<br>12862.<br>12863.<br>12864.<br>12865.<br>12866.<br>12867.<br>12868.<br>12869.<br>12870.<br>12871.<br>12872.<br>12873.<br>12874.<br>12875.<br>12876.<br>12877.<br>12878.<br>12879.<br>12880.<br>12881.<br>12882.<br>12883.<br>12884.<br>12885.<br>12886.<br>12887.<br>12888.<br>12889.<br>12890.<br>12891.<br>12892.<br>12893.<br>12894.<br>12895.<br>12896.<br>12897.<br>12898.<br>12899.<br>12900.<br>12901.<br>12902.<br>12903.<br>12904.<br>12905.<br>12906.<br>12907.<br>12908.<br>12909.<br>12910.<br>12911.<br>12912.<br>12913.<br>12914.<br>12915.<br>12916.<br>12917.<br>12918.<br>12919.<br>12920.<br>12921.<br>12922.<br>12923.<br>12924.<br>12925.<br>12926.<br>12927.<br>12928.<br>12929.<br>12930.<br>12931.<br>12932.<br>12933.<br>12934.<br>12935.<br>12936.<br>12937.<br>12938.<br>12939.<br>12940.<br>12941.<br>12942.<br>12943.<br>12944.<br>12945.<br>12946.<br>12947.<br>12948.<br>12949.<br>12950.<br>12951.<br>12952.<br>12953.<br>12954.<br>12955.<br>12956.<br>12957.<br>12958.<br>12959.<br>12960.<br>12961.<br>12962.<br>12963.<br>12964.<br>12965.<br>12966.<br>12967.<br>12968.<br>12969.<br>12970.<br>12971.<br>12972.<br>12973.<br>12974.<br>12975.<br>12976.<br>12977.<br>12978.<br>12979.<br>12980.<br>12981.<br>12982.<br>12983.<br>12984.<br>12985.<br>12986.<br>12987.<br>12988.<br>12989.<br>12990.<br>12991.<br>12992.<br>12993.<br>12994.<br>12995.<br>12996.<br>12997.<br>12998.<br>12999.<br>13000.<br>13001.<br>13002.<br>13003.<br>13004.<br>13005.<br>13006.<br>13007.<br>13008.<br>13009.<br>13010.<br>13011.<br>13012.<br>13013.<br>13014.<br>13015.<br>13016.<br>13017.<br>13018.<br>13019.<br>13020.<br>13021.<br>13022.<br>13023.<br>13024.<br>13025.<br>13026.<br>13027.<br>13028.<br>13029.<br>13030.<br>13031.<br>13032.<br>13033.<br>13034.<br>13035.<br>13036.<br>13037.<br>13038.<br>13039.<br>13040.<br>13041.<br>13042.<br>13043.<br>13044.<br>13045.<br>13046.<br>13047.<br>13048.<br>13049.<br>13050.<br>13051.<br>13052.<br>13053.<br>13054.<br>13055.<br>13056.<br>13057.<br>13058.<br>13059.<br>13060.<br>13061.<br>13062.<br>13063.<br>13064.<br>13065.<br>13066.<br>13067.<br>13068.<br>13069.<br>13070.<br>13071.<br>13072.<br>13073.<br>13074.<br>13075.<br>13076.<br>13077.<br>13078.<br>13079.<br>13080.<br>13081.<br>13082.<br>13083.<br>13084.<br>13085.<br>13086.<br>13087.<br>13088.<br>13089.<br>13090.<br>13091.<br>13092.<br>13093.<br>13094.<br>13095.<br>13096.<br>13097.<br>13098.<br>13099.<br>13100.<br>13101.<br>13102.<br>13103.<br>13104.<br>13105.<br>13106.<br>13107.<br>13108.<br>13109.<br>13110.<br>13111.<br>13112.<br>13113.<br>13114.<br>13115.<br>13116.<br>13117.<br>13118.<br>13119.<br>13120.<br>13121.<br>13122.<br>13123.<br>13124.<br>13125.<br>13126.<br>13127.<br>13128.<br>13129.<br>13130.<br>13131.<br>13132.<br>13133.<br>13134.<br>13135.<br>13136.<br>13137.<br>13138.<br>13139.<br>13140.<br>13141.<br>13142.<br>13143.<br>13144.<br>13145.<br>13146.<br>13147.<br>13148.<br>13149.<br>13150.<br>13151.<br>13152.<br>13153.<br>13154.<br>13155.<br>13156.<br>13157.<br>13158.<br>13159.<br>13160.<br>13161.<br>13162.<br>13163.<br>13164.<br>13165.<br>13166.<br>13167.<br>13168.<br>13169.<br>13170.<br>13171.<br>13172.<br>13173.<br>13174.<br>13175.<br>13176.<br>13177.<br>13178.<br>13179.<br>13180.<br>13181.<br>13182.<br>13183.<br>13184.<br>13185.<br>13186.<br>13187.<br>13188.<br>13189.<br>13190.<br>13191.<br>13192.<br>13193.<br>13194.<br>13195.<br>13196.<br>13197.<br>13198.<br>13199.<br>13200.<br>13201.<br>13202.<br>13203.<br>13204.<br>13205.<br>13206.<br>13207.<br>13208.<br>13209.<br>13210.<br>13211.<br>13212.<br>13213.<br>13214.<br>13215.<br>13216.<br>13217.<br>13218.<br>13219.<br>13220.<br>13221.<br>13222.<br>13223.<br>13224.<br>13225.<br>13226.<br>13227.<br>13228.<br>13229.<br>13230.<br>13231.<br>13232.<br>13233.<br>13234.<br>13235.<br>13236.<br>13237.<br>13238.<br>13239.<br>13240.<br>13241.<br>13242.<br>13243.<br>13244.<br>13245.<br>13246.<br>13247.<br>13248.<br>13249.<br>13250.<br>13251.<br>13252.<br>13253.<br>13254.<br>13255.<br>13256.<br>13257.<br>13258.<br>13259.<br>13260.<br>13261.<br>13262.<br>13263.<br>13264.<br>13265.<br>13266.<br>13267.<br>13268.<br>13269.<br>13270.<br>13271.<br>13272.<br>13273.<br>13274.<br>13275.<br>13276.<br>13277.<br>13278.<br>13279.<br>13280.<br>13281.<br>13282.<br>13283.<br>13284.<br>13285.<br>13286.<br>13287.<br>13288.<br>13289.<br>13290.<br>13291.<br>13292.<br>13293.<br>13294.<br>13295.<br>13296.<br>13297.<br>13298.<br>13299.<br>13300.<br>13301.<br>13302.<br>13303.<br>13304.<br>13305.<br>13306.<br>13307.<br>13308.<br>13309.<br>13310.<br>13311.<br>13312.<br>13313.<br>13314.<br>13315.<br>13316.<br>13317.<br>13318.<br>13319.<br>13320.<br>13321.<br>13322.<br>13323.<br>13324.<br>13325.<br>13326.<br>13327.<br>13328.<br>13329.<br>13330.<br>13331.<br>13332.<br>13333.<br>13334.<br>13335.<br>13336.<br>13337.<br>13338.<br>13339.<br>13340.<br>13341.<br>13342.<br>13343.<br>13344.<br>13345.<br>13346.<br>13347.<br>13348.<br>13349.<br>13350.<br>13351.<br>13352.<br>13353.<br>13354.<br>13355.<br>13356.<br>13357.<br>13358.<br>13359.<br>13360.<br>13361.<br>13362.<br>13363.<br>13364.<br>13365.<br>13366.<br>13367.<br>13368.<br>13369.<br>13370.<br>13371.<br>13372.<br>13373.<br>13374.<br>13375.<br>13376.<br>13377.<br>13378.<br>13379.<br>13380.<br>13381.<br>13382.<br>13383.<br>13384.<br>13385.<br>13386.<br>13387.<br>13388.<br>13389.<br>13390.<br>13391.<br>13392.<br>13393.<br>13394.<br>13395.<br>13396.<br>13397.<br>13398.<br>13399.<br>13400.<br>13401.<br>13402.<br>13403.<br>13404.<br>13405.<br>13406.<br>13407.<br>13408.<br>13409.<br>13410.<br>13411.<br>13412.<br>13413.<br>13414.<br>13415.<br>13416.<br>13417.<br>13418.<br>13419.<br>13420.<br>13421.<br>13422.<br>13423.<br>13424.<br>13425.<br>13426.<br>13427.<br>13428.<br>13429.<br>13430.<br>13431.<br>13432.<br>13433.<br>13434.<br>13435.<br>13436.<br>13437.<br>13438.<br>13439.<br>13440.<br>13441.<br>13442.<br>13443.<br>13444.<br>13445.<br>13446.<br>13447.<br>13448.<br>13449.<br>13450.<br>13451.<br>13452.<br>13453.<br>13454.<br>13455.<br>13456.<br>13457.<br>13458.<br>13459.<br>13460.<br>13461.<br>13462.<br>13463.<br>13464.<br>13465.<br>13466.<br>13467.<br>13468.<br>13469.<br>13470.<br>13471.<br>13472.<br>13473.<br>13474.<br>13475.<br>13476.<br>13477.<br>13478.<br>13479.<br>13480.<br>13481.<br>13482.<br>13483.<br>13484.<br>13485.<br>13486.<br>13487.<br>13488.<br>13489.<br>13490.<br>13491.<br>13492.<br>13493.<br>13494.<br>13495.<br>13496.<br>13497.<br>13498.<br>13499.<br>13500.<br>13501.<br>13502.<br>13503.<br>13504.<br>13505.<br>13506.<br>13507.<br>13508.<br>13509.<br>13510.<br>13511.<br>13512.<br>13513.<br>13514.<br>13515.<br>13516.<br>13517.<br>13518.<br>13519.<br>13520.<br>13521.<br>13522.<br>13523.<br>13524.<br>13525.<br>13526.<br>13527.<br>13528.<br>13529.<br>13530.<br>13531.<br>13532.<br>13533.<br>13534.<br>13535.<br>13536.<br>13537.<br>13538.<br>13539.<br>13540.<br>13541.<br>13542.<br>13543.<br>13544.<br>13545.<br>13546.<br>13547.<br>13548.<br>13549.<br>13550.<br>13551.<br>13552.<br>13553.<br>13554.<br>13555.<br>13556.<br>13557.<br>13558.<br>13559.<br>13560.<br>13561.<br>13562.<br>13563.<br>13564.<br>13565.<br>13566.<br>13567.<br>13568.<br>13569.<br>13570.<br>13571.<br>13572.<br>13573.<br>13574.<br>13575.<br>13576.<br>13577.<br>13578.<br>13579.<br>13580.<br>13581.<br>13582.<br>13583.<br>13584.<br>13585.<br>13586.<br>13587.<br>13588.<br>13589.<br>13590.<br>13591.<br>13592.<br>13593.<br>13594.<br>13595.<br>13596.<br>13597.<br>13598.<br>13599.<br>13600.<br>13601.<br>13602.<br>13603.<br>13604.<br>13605.<br>13606.<br>13607.<br>13608.<br>13609.<br>13610.<br>13611.<br>13612.<br>13613.<br>13614.<br>13615.<br>13616.<br>13617.<br>13618.<br>13619.<br>13620.<br>13621.<br>13622.<br>13623.<br>13624.<br>13625.<br>13626.<br>13627.<br>13628.<br>13629.<br>13630.<br>13631.<br>13632.<br>13633.<br>13634.<br>13635.<br>13636.<br>13637.<br>13638.<br>13639.<br>13640.<br>13641.<br>13642.<br>13643.<br>13644.<br>13645.<br>13646.<br>13647.<br>13648.<br>13649.<br>13650.<br>13651.<br>13652.<br>13653.<br>13654.<br>13655.<br>13656.<br>13657.<br>13658.<br>13659.<br>13660.<br>13661.<br>13662.<br>13663.<br>13664.<br>13665.<br>13666.<br>13667.<br>13668.<br>13669.<br>13670.<br>13671.<br>13672.<br>13673.<br>13674.<br>13675.<br>13676.<br>13677.<br>13678.<br>13679.<br>13680.<br>13681.<br>13682.<br>13683.<br>13684.<br>13685.<br>13686.<br>13687.<br>13688.<br>13689.<br>13690.<br>13691.<br>13692.<br>13693.<br>13694.<br>13695.<br>13696.<br>13697.<br>13698.<br>13699.<br>13700.<br>13701.<br>13702.<br>13703.<br>13704.<br>13705.<br>13706.<br>13707.<br>13708.<br>13709.<br>13710.<br>13711.<br>13712.<br>13713.<br>13714.<br>13715.<br>13716.<br>13717.<br>13718.<br>13719.<br>13720.<br>13721.<br>13722.<br>13723.<br>13724.<br>13725.<br>13726.<br>13727.<br>13728.<br>13729.<br>13730.<br>13731.<br>13732.<br>13733.<br>13734.<br>13735.<br>13736.<br>13737.<br>13738.<br>13739.<br>13740.<br>13741.<br>13742.<br>13743.<br>13744.<br>13745.<br></code_line></pre></td>
<td class='lines'><pre><code class="prettyprint">// SPDX-License-Identifier: GPL-2.0-only
/*
 * Kernel-based Virtual Machine driver for Linux
 *
 * derived from drivers/kvm/kvm_main.c
 *
 * Copyright (C) 2006 Qumranet, Inc.
 * Copyright (C) 2008 Qumranet, Inc.
 * Copyright IBM Corporation, 2008
 * Copyright 2010 Red Hat, Inc. and/or its affiliates.
 *
 * Authors:
 *   Avi Kivity   &lt;avi@qumranet.com&gt;
 *   Yaniv Kamay  &lt;yaniv@qumranet.com&gt;
 *   Amit Shah    &lt;amit.shah@qumranet.com&gt;
 *   Ben-Ami Yassour &lt;benami@il.ibm.com&gt;
 */

#include &lt;linux/kvm_host.h&gt;
#include &quot;irq.h&quot;
#include &quot;ioapic.h&quot;
#include &quot;mmu.h&quot;
#include &quot;i8254.h&quot;
#include &quot;tss.h&quot;
#include &quot;kvm_cache_regs.h&quot;
#include &quot;kvm_emulate.h&quot;
#include &quot;x86.h&quot;
#include &quot;cpuid.h&quot;
#include &quot;pmu.h&quot;
#include &quot;hyperv.h&quot;
#include &quot;lapic.h&quot;
#include &quot;xen.h&quot;

#include &lt;linux/clocksource.h&gt;
#include &lt;linux/interrupt.h&gt;
#include &lt;linux/kvm.h&gt;
#include &lt;linux/fs.h&gt;
#include &lt;linux/vmalloc.h&gt;
#include &lt;linux/export.h&gt;
#include &lt;linux/moduleparam.h&gt;
#include &lt;linux/mman.h&gt;
#include &lt;linux/highmem.h&gt;
#include &lt;linux/iommu.h&gt;
#include &lt;linux/cpufreq.h&gt;
#include &lt;linux/user-return-notifier.h&gt;
#include &lt;linux/srcu.h&gt;
#include &lt;linux/slab.h&gt;
#include &lt;linux/perf_event.h&gt;
#include &lt;linux/uaccess.h&gt;
#include &lt;linux/hash.h&gt;
#include &lt;linux/pci.h&gt;
#include &lt;linux/timekeeper_internal.h&gt;
#include &lt;linux/pvclock_gtod.h&gt;
#include &lt;linux/kvm_irqfd.h&gt;
#include &lt;linux/irqbypass.h&gt;
#include &lt;linux/sched/stat.h&gt;
#include &lt;linux/sched/isolation.h&gt;
#include &lt;linux/mem_encrypt.h&gt;
#include &lt;linux/entry-kvm.h&gt;
#include &lt;linux/suspend.h&gt;

#include &lt;trace/events/kvm.h&gt;

#include &lt;asm/debugreg.h&gt;
#include &lt;asm/msr.h&gt;
#include &lt;asm/desc.h&gt;
#include &lt;asm/mce.h&gt;
#include &lt;asm/pkru.h&gt;
#include &lt;linux/kernel_stat.h&gt;
#include &lt;asm/fpu/api.h&gt;
#include &lt;asm/fpu/xcr.h&gt;
#include &lt;asm/fpu/xstate.h&gt;
#include &lt;asm/pvclock.h&gt;
#include &lt;asm/div64.h&gt;
#include &lt;asm/irq_remapping.h&gt;
#include &lt;asm/mshyperv.h&gt;
#include &lt;asm/hypervisor.h&gt;
#include &lt;asm/tlbflush.h&gt;
#include &lt;asm/intel_pt.h&gt;
#include &lt;asm/emulate_prefix.h&gt;
#include &lt;asm/sgx.h&gt;
#include &lt;clocksource/hyperv_timer.h&gt;

#define CREATE_TRACE_POINTS
#include &quot;trace.h&quot;

#define MAX_IO_MSRS 256
#define KVM_MAX_MCE_BANKS 32

struct kvm_caps kvm_caps __read_mostly = {
	.supported_mce_cap = MCG_CTL_P | MCG_SER_P,
};
EXPORT_SYMBOL_GPL(kvm_caps);

#define  ERR_PTR_USR(e)  ((void __user *)ERR_PTR(e))

#define emul_to_vcpu(ctxt) \
	((struct kvm_vcpu *)(ctxt)-&gt;vcpu)

/* EFER defaults:
 * - enable syscall per default because its emulated by KVM
 * - enable LME and LMA per default on 64 bit KVM
 */
#ifdef CONFIG_X86_64
static
u64 __read_mostly efer_reserved_bits = ~((u64)(EFER_SCE | EFER_LME | EFER_LMA));
#else
static u64 __read_mostly efer_reserved_bits = ~((u64)EFER_SCE);
#endif

static u64 __read_mostly cr4_reserved_bits = CR4_RESERVED_BITS;

#define KVM_EXIT_HYPERCALL_VALID_MASK (1 &lt;&lt; KVM_HC_MAP_GPA_RANGE)

#define KVM_CAP_PMU_VALID_MASK KVM_PMU_CAP_DISABLE

#define KVM_X2APIC_API_VALID_FLAGS (KVM_X2APIC_API_USE_32BIT_IDS | \
                                    KVM_X2APIC_API_DISABLE_BROADCAST_QUIRK)

static void update_cr8_intercept(struct kvm_vcpu *vcpu);
static void process_nmi(struct kvm_vcpu *vcpu);
static void process_smi(struct kvm_vcpu *vcpu);
static void enter_smm(struct kvm_vcpu *vcpu);
static void __kvm_set_rflags(struct kvm_vcpu *vcpu, unsigned long rflags);
static void store_regs(struct kvm_vcpu *vcpu);
static int sync_regs(struct kvm_vcpu *vcpu);
static int kvm_vcpu_do_singlestep(struct kvm_vcpu *vcpu);

static int __set_sregs2(struct kvm_vcpu *vcpu, struct kvm_sregs2 *sregs2);
static void __get_sregs2(struct kvm_vcpu *vcpu, struct kvm_sregs2 *sregs2);

struct kvm_x86_ops kvm_x86_ops __read_mostly;

#define KVM_X86_OP(func)					     \
	DEFINE_STATIC_CALL_NULL(kvm_x86_##func,			     \
				*(((struct kvm_x86_ops *)0)-&gt;func));
#define KVM_X86_OP_OPTIONAL KVM_X86_OP
#define KVM_X86_OP_OPTIONAL_RET0 KVM_X86_OP
#include &lt;asm/kvm-x86-ops.h&gt;
EXPORT_STATIC_CALL_GPL(kvm_x86_get_cs_db_l_bits);
EXPORT_STATIC_CALL_GPL(kvm_x86_cache_reg);

static bool __read_mostly ignore_msrs = 0;
module_param(ignore_msrs, bool, S_IRUGO | S_IWUSR);

bool __read_mostly report_ignored_msrs = true;
module_param(report_ignored_msrs, bool, S_IRUGO | S_IWUSR);
EXPORT_SYMBOL_GPL(report_ignored_msrs);

unsigned int min_timer_period_us = 200;
module_param(min_timer_period_us, uint, S_IRUGO | S_IWUSR);

static bool __read_mostly kvmclock_periodic_sync = true;
module_param(kvmclock_periodic_sync, bool, S_IRUGO);

/* tsc tolerance in parts per million - default to 1/2 of the NTP threshold */
static u32 __read_mostly tsc_tolerance_ppm = 250;
module_param(tsc_tolerance_ppm, uint, S_IRUGO | S_IWUSR);

/*
 * lapic timer advance (tscdeadline mode only) in nanoseconds.  &#x27;-1&#x27; enables
 * adaptive tuning starting from default advancement of 1000ns.  &#x27;0&#x27; disables
 * advancement entirely.  Any other value is used as-is and disables adaptive
 * tuning, i.e. allows privileged userspace to set an exact advancement time.
 */
static int __read_mostly lapic_timer_advance_ns = -1;
module_param(lapic_timer_advance_ns, int, S_IRUGO | S_IWUSR);

static bool __read_mostly vector_hashing = true;
module_param(vector_hashing, bool, S_IRUGO);

bool __read_mostly enable_vmware_backdoor = false;
module_param(enable_vmware_backdoor, bool, S_IRUGO);
EXPORT_SYMBOL_GPL(enable_vmware_backdoor);

/*
 * Flags to manipulate forced emulation behavior (any non-zero value will
 * enable forced emulation).
 */
#define KVM_FEP_CLEAR_RFLAGS_RF	BIT(1)
static int __read_mostly force_emulation_prefix;
module_param(force_emulation_prefix, int, 0644);

int __read_mostly pi_inject_timer = -1;
module_param(pi_inject_timer, bint, S_IRUGO | S_IWUSR);

/* Enable/disable PMU virtualization */
bool __read_mostly enable_pmu = true;
EXPORT_SYMBOL_GPL(enable_pmu);
module_param(enable_pmu, bool, 0444);

bool __read_mostly eager_page_split = true;
module_param(eager_page_split, bool, 0644);

/*
 * Restoring the host value for MSRs that are only consumed when running in
 * usermode, e.g. SYSCALL MSRs and TSC_AUX, can be deferred until the CPU
 * returns to userspace, i.e. the kernel can run with the guest&#x27;s value.
 */
#define KVM_MAX_NR_USER_RETURN_MSRS 16

struct kvm_user_return_msrs {
	struct user_return_notifier urn;
	bool registered;
	struct kvm_user_return_msr_values {
		u64 host;
		u64 curr;
	} values[KVM_MAX_NR_USER_RETURN_MSRS];
};

u32 __read_mostly kvm_nr_uret_msrs;
EXPORT_SYMBOL_GPL(kvm_nr_uret_msrs);
static u32 __read_mostly kvm_uret_msrs_list[KVM_MAX_NR_USER_RETURN_MSRS];
static struct kvm_user_return_msrs __percpu *user_return_msrs;

#define KVM_SUPPORTED_XCR0     (XFEATURE_MASK_FP | XFEATURE_MASK_SSE \
				| XFEATURE_MASK_YMM | XFEATURE_MASK_BNDREGS \
				| XFEATURE_MASK_BNDCSR | XFEATURE_MASK_AVX512 \
				| XFEATURE_MASK_PKRU | XFEATURE_MASK_XTILE)

u64 __read_mostly host_efer;
EXPORT_SYMBOL_GPL(host_efer);

bool __read_mostly allow_smaller_maxphyaddr = 0;
EXPORT_SYMBOL_GPL(allow_smaller_maxphyaddr);

bool __read_mostly enable_apicv = true;
EXPORT_SYMBOL_GPL(enable_apicv);

u64 __read_mostly host_xss;
EXPORT_SYMBOL_GPL(host_xss);

const struct _kvm_stats_desc kvm_vm_stats_desc[] = {
	KVM_GENERIC_VM_STATS(),
	STATS_DESC_COUNTER(VM, mmu_shadow_zapped),
	STATS_DESC_COUNTER(VM, mmu_pte_write),
	STATS_DESC_COUNTER(VM, mmu_pde_zapped),
	STATS_DESC_COUNTER(VM, mmu_flooded),
	STATS_DESC_COUNTER(VM, mmu_recycled),
	STATS_DESC_COUNTER(VM, mmu_cache_miss),
	STATS_DESC_ICOUNTER(VM, mmu_unsync),
	STATS_DESC_ICOUNTER(VM, pages_4k),
	STATS_DESC_ICOUNTER(VM, pages_2m),
	STATS_DESC_ICOUNTER(VM, pages_1g),
	STATS_DESC_ICOUNTER(VM, nx_lpage_splits),
	STATS_DESC_PCOUNTER(VM, max_mmu_rmap_size),
	STATS_DESC_PCOUNTER(VM, max_mmu_page_hash_collisions)
};

const struct kvm_stats_header kvm_vm_stats_header = {
	.name_size = KVM_STATS_NAME_SIZE,
	.num_desc = ARRAY_SIZE(kvm_vm_stats_desc),
	.id_offset = sizeof(struct kvm_stats_header),
	.desc_offset = sizeof(struct kvm_stats_header) + KVM_STATS_NAME_SIZE,
	.data_offset = sizeof(struct kvm_stats_header) + KVM_STATS_NAME_SIZE +
		       sizeof(kvm_vm_stats_desc),
};

const struct _kvm_stats_desc kvm_vcpu_stats_desc[] = {
	KVM_GENERIC_VCPU_STATS(),
	STATS_DESC_COUNTER(VCPU, pf_taken),
	STATS_DESC_COUNTER(VCPU, pf_fixed),
	STATS_DESC_COUNTER(VCPU, pf_emulate),
	STATS_DESC_COUNTER(VCPU, pf_spurious),
	STATS_DESC_COUNTER(VCPU, pf_fast),
	STATS_DESC_COUNTER(VCPU, pf_mmio_spte_created),
	STATS_DESC_COUNTER(VCPU, pf_guest),
	STATS_DESC_COUNTER(VCPU, tlb_flush),
	STATS_DESC_COUNTER(VCPU, invlpg),
	STATS_DESC_COUNTER(VCPU, exits),
	STATS_DESC_COUNTER(VCPU, io_exits),
	STATS_DESC_COUNTER(VCPU, mmio_exits),
	STATS_DESC_COUNTER(VCPU, signal_exits),
	STATS_DESC_COUNTER(VCPU, irq_window_exits),
	STATS_DESC_COUNTER(VCPU, nmi_window_exits),
	STATS_DESC_COUNTER(VCPU, l1d_flush),
	STATS_DESC_COUNTER(VCPU, halt_exits),
	STATS_DESC_COUNTER(VCPU, request_irq_exits),
	STATS_DESC_COUNTER(VCPU, irq_exits),
	STATS_DESC_COUNTER(VCPU, host_state_reload),
	STATS_DESC_COUNTER(VCPU, fpu_reload),
	STATS_DESC_COUNTER(VCPU, insn_emulation),
	STATS_DESC_COUNTER(VCPU, insn_emulation_fail),
	STATS_DESC_COUNTER(VCPU, hypercalls),
	STATS_DESC_COUNTER(VCPU, irq_injections),
	STATS_DESC_COUNTER(VCPU, nmi_injections),
	STATS_DESC_COUNTER(VCPU, req_event),
	STATS_DESC_COUNTER(VCPU, nested_run),
	STATS_DESC_COUNTER(VCPU, directed_yield_attempted),
	STATS_DESC_COUNTER(VCPU, directed_yield_successful),
	STATS_DESC_COUNTER(VCPU, preemption_reported),
	STATS_DESC_COUNTER(VCPU, preemption_other),
	STATS_DESC_IBOOLEAN(VCPU, guest_mode),
	STATS_DESC_COUNTER(VCPU, notify_window_exits),
};

const struct kvm_stats_header kvm_vcpu_stats_header = {
	.name_size = KVM_STATS_NAME_SIZE,
	.num_desc = ARRAY_SIZE(kvm_vcpu_stats_desc),
	.id_offset = sizeof(struct kvm_stats_header),
	.desc_offset = sizeof(struct kvm_stats_header) + KVM_STATS_NAME_SIZE,
	.data_offset = sizeof(struct kvm_stats_header) + KVM_STATS_NAME_SIZE +
		       sizeof(kvm_vcpu_stats_desc),
};

u64 __read_mostly host_xcr0;

static struct kmem_cache *x86_emulator_cache;

/*
 * When called, it means the previous get/set msr reached an invalid msr.
 * Return true if we want to ignore/silent this failed msr access.
 */
static bool kvm_msr_ignored_check(u32 msr, u64 data, bool write)
{
<yellow>	const char *op = write ? "wrmsr" : "rdmsr";</yellow>

<yellow>	if (ignore_msrs) {</yellow>
<yellow>		if (report_ignored_msrs)</yellow>
<yellow>			kvm_pr_unimpl("ignored %s: 0x%x data 0x%llx\n",</yellow>
				      op, msr, data);
		/* Mask the error */
		return true;
	} else {
<yellow>		kvm_debug_ratelimited("unhandled %s: 0x%x data 0x%llx\n",</yellow>
				      op, msr, data);
		return false;
	}
<yellow>}</yellow>

static struct kmem_cache *kvm_alloc_emulator_cache(void)
{
	unsigned int useroffset = offsetof(struct x86_emulate_ctxt, src);
	unsigned int size = sizeof(struct x86_emulate_ctxt);

<yellow>	return kmem_cache_create_usercopy("x86_emulator", size,</yellow>
					  __alignof__(struct x86_emulate_ctxt),
					  SLAB_ACCOUNT, useroffset,
					  size - useroffset, NULL);
}

static int emulator_fix_hypercall(struct x86_emulate_ctxt *ctxt);

static inline void kvm_async_pf_hash_reset(struct kvm_vcpu *vcpu)
{
	int i;
	for (i = 0; i &lt; ASYNC_PF_PER_VCPU; i++)
<blue>		vcpu->arch.apf.gfns[i] = ~0;</blue>
}

static void kvm_on_user_return(struct user_return_notifier *urn)
{
	unsigned slot;
	struct kvm_user_return_msrs *msrs
		= container_of(urn, struct kvm_user_return_msrs, urn);
	struct kvm_user_return_msr_values *values;
	unsigned long flags;

	/*
	 * Disabling irqs at this point since the following code could be
	 * interrupted and executed through kvm_arch_hardware_disable()
	 */
<blue>	local_irq_save(flags);</blue>
<blue>	if (msrs->registered) {</blue>
<blue>		msrs->registered = false;</blue>
		user_return_notifier_unregister(urn);
	}
<blue>	local_irq_restore(flags);</blue>
<blue>	for (slot = 0; slot < kvm_nr_uret_msrs; ++slot) {</blue>
		values = &amp;msrs-&gt;values[slot];
<blue>		if (values->host != values->curr) {</blue>
<blue>			wrmsrl(kvm_uret_msrs_list[slot], values->host);</blue>
			values-&gt;curr = values-&gt;host;
		}
	}
<blue>}</blue>

static int kvm_probe_user_return_msr(u32 msr)
{
	u64 val;
	int ret;

<yellow>	preempt_disable();</yellow>
	ret = rdmsrl_safe(msr, &amp;val);
	if (ret)
		goto out;
<yellow>	ret = wrmsrl_safe(msr, val);</yellow>
out:
<yellow>	preempt_enable();</yellow>
	return ret;
}

int kvm_add_user_return_msr(u32 msr)
<yellow>{</yellow>
<yellow>	BUG_ON(kvm_nr_uret_msrs >= KVM_MAX_NR_USER_RETURN_MSRS);</yellow>

<yellow>	if (kvm_probe_user_return_msr(msr))</yellow>
		return -1;

<yellow>	kvm_uret_msrs_list[kvm_nr_uret_msrs] = msr;</yellow>
	return kvm_nr_uret_msrs++;
}
EXPORT_SYMBOL_GPL(kvm_add_user_return_msr);

int kvm_find_user_return_msr(u32 msr)
{
	int i;

<blue>	for (i = 0; i < kvm_nr_uret_msrs; ++i) {</blue>
<blue>		if (kvm_uret_msrs_list[i] == msr)</blue>
			return i;
	}
	return -1;
<blue>}</blue>
EXPORT_SYMBOL_GPL(kvm_find_user_return_msr);

static void kvm_user_return_msr_cpu_online(void)
{
<blue>	unsigned int cpu = smp_processor_id();</blue>
	struct kvm_user_return_msrs *msrs = per_cpu_ptr(user_return_msrs, cpu);
	u64 value;
	int i;

	for (i = 0; i &lt; kvm_nr_uret_msrs; ++i) {
<blue>		rdmsrl_safe(kvm_uret_msrs_list[i], &value);</blue>
		msrs-&gt;values[i].host = value;
		msrs-&gt;values[i].curr = value;
	}
}

int kvm_set_user_return_msr(unsigned slot, u64 value, u64 mask)
{
<blue>	unsigned int cpu = smp_processor_id();</blue>
	struct kvm_user_return_msrs *msrs = per_cpu_ptr(user_return_msrs, cpu);
	int err;

	value = (value &amp; mask) | (msrs-&gt;values[slot].host &amp; ~mask);
	if (value == msrs-&gt;values[slot].curr)
		return 0;
<blue>	err = wrmsrl_safe(kvm_uret_msrs_list[slot], value);</blue>
	if (err)
		return 1;

<blue>	msrs->values[slot].curr = value;</blue>
<blue>	if (!msrs->registered) {</blue>
<blue>		msrs->urn.on_user_return = kvm_on_user_return;</blue>
		user_return_notifier_register(&amp;msrs-&gt;urn);
		msrs-&gt;registered = true;
	}
	return 0;
<blue>}</blue>
EXPORT_SYMBOL_GPL(kvm_set_user_return_msr);

static void drop_user_return_notifiers(void)
{
	unsigned int cpu = smp_processor_id();
	struct kvm_user_return_msrs *msrs = per_cpu_ptr(user_return_msrs, cpu);

<yellow>	if (msrs->registered)</yellow>
<yellow>		kvm_on_user_return(&msrs->urn);</yellow>
}

u64 kvm_get_apic_base(struct kvm_vcpu *vcpu)
{
<blue>	return vcpu->arch.apic_base;</blue>
}
EXPORT_SYMBOL_GPL(kvm_get_apic_base);

enum lapic_mode kvm_get_apic_mode(struct kvm_vcpu *vcpu)
{
<blue>	return kvm_apic_mode(kvm_get_apic_base(vcpu));</blue>
}
EXPORT_SYMBOL_GPL(kvm_get_apic_mode);

int kvm_set_apic_base(struct kvm_vcpu *vcpu, struct msr_data *msr_info)
{
<blue>	enum lapic_mode old_mode = kvm_get_apic_mode(vcpu);</blue>
<blue>	enum lapic_mode new_mode = kvm_apic_mode(msr_info->data);</blue>
	u64 reserved_bits = kvm_vcpu_reserved_gpa_bits_raw(vcpu) | 0x2ff |
<blue>		(guest_cpuid_has(vcpu, X86_FEATURE_X2APIC) ? 0 : X2APIC_ENABLE);</blue>

<blue>	if ((msr_info->data & reserved_bits) != 0 || new_mode == LAPIC_MODE_INVALID)</blue>
		return 1;
<blue>	if (!msr_info->host_initiated) {</blue>
<yellow>		if (old_mode == LAPIC_MODE_X2APIC && new_mode == LAPIC_MODE_XAPIC)</yellow>
			return 1;
<yellow>		if (old_mode == LAPIC_MODE_DISABLED && new_mode == LAPIC_MODE_X2APIC)</yellow>
			return 1;
	}

<blue>	kvm_lapic_set_base(vcpu, msr_info->data);</blue>
	kvm_recalculate_apic_map(vcpu-&gt;kvm);
	return 0;
<blue>}</blue>
EXPORT_SYMBOL_GPL(kvm_set_apic_base);

/*
 * Handle a fault on a hardware virtualization (VMX or SVM) instruction.
 *
 * Hardware virtualization extension instructions may fault if a reboot turns
 * off virtualization while processes are running.  Usually after catching the
 * fault we just panic; during reboot instead the instruction is ignored.
 */
noinstr void kvm_spurious_fault(void)
{
	/* Fault while not rebooting.  We want the trace. */
	BUG_ON(!kvm_rebooting);
}
EXPORT_SYMBOL_GPL(kvm_spurious_fault);

#define EXCPT_BENIGN		0
#define EXCPT_CONTRIBUTORY	1
#define EXCPT_PF		2

static int exception_class(int vector)
{
<yellow>	switch (vector) {</yellow>
	case PF_VECTOR:
		return EXCPT_PF;
	case DE_VECTOR:
	case TS_VECTOR:
	case NP_VECTOR:
	case SS_VECTOR:
	case GP_VECTOR:
		return EXCPT_CONTRIBUTORY;
	default:
		break;
	}
	return EXCPT_BENIGN;
}

#define EXCPT_FAULT		0
#define EXCPT_TRAP		1
#define EXCPT_ABORT		2
#define EXCPT_INTERRUPT		3
#define EXCPT_DB		4

static int exception_type(int vector)
{
	unsigned int mask;

<blue>	if (WARN_ON(vector > 31 || vector == NMI_VECTOR))</blue>
<yellow>		return EXCPT_INTERRUPT;</yellow>

<blue>	mask = 1 << vector;</blue>

	/*
	 * #DBs can be trap-like or fault-like, the caller must check other CPU
	 * state, e.g. DR6, to determine whether a #DB is a trap or fault.
	 */
	if (mask &amp; (1 &lt;&lt; DB_VECTOR))
		return EXCPT_DB;

<blue>	if (mask & ((1 << BP_VECTOR) | (1 << OF_VECTOR)))</blue>
		return EXCPT_TRAP;

<blue>	if (mask & ((1 << DF_VECTOR) | (1 << MC_VECTOR)))</blue>
		return EXCPT_ABORT;

	/* Reserved exceptions will result in fault */
	return EXCPT_FAULT;
<blue>}</blue>

<blue>void kvm_deliver_exception_payload(struct kvm_vcpu *vcpu,</blue>
				   struct kvm_queued_exception *ex)
{
<blue>	if (!ex->has_payload)</blue>
		return;

<blue>	switch (ex->vector) {</blue>
	case DB_VECTOR:
		/*
		 * &quot;Certain debug exceptions may clear bit 0-3.  The
		 * remaining contents of the DR6 register are never
		 * cleared by the processor&quot;.
		 */
<blue>		vcpu->arch.dr6 &= ~DR_TRAP_BITS;</blue>
		/*
		 * In order to reflect the #DB exception payload in guest
		 * dr6, three components need to be considered: active low
		 * bit, FIXED_1 bits and active high bits (e.g. DR6_BD,
		 * DR6_BS and DR6_BT)
		 * DR6_ACTIVE_LOW contains the FIXED_1 and active low bits.
		 * In the target guest dr6:
		 * FIXED_1 bits should always be set.
		 * Active low bits should be cleared if 1-setting in payload.
		 * Active high bits should be set if 1-setting in payload.
		 *
		 * Note, the payload is compatible with the pending debug
		 * exceptions/exit qualification under VMX, that active_low bits
		 * are active high in payload.
		 * So they need to be flipped for DR6.
		 */
		vcpu-&gt;arch.dr6 |= DR6_ACTIVE_LOW;
		vcpu-&gt;arch.dr6 |= ex-&gt;payload;
		vcpu-&gt;arch.dr6 ^= ex-&gt;payload &amp; DR6_ACTIVE_LOW;

		/*
		 * The #DB payload is defined as compatible with the &#x27;pending
		 * debug exceptions&#x27; field under VMX, not DR6. While bit 12 is
		 * defined in the &#x27;pending debug exceptions&#x27; field (enabled
		 * breakpoint), it is reserved and must be zero in DR6.
		 */
		vcpu-&gt;arch.dr6 &amp;= ~BIT(12);
		break;
	case PF_VECTOR:
<blue>		vcpu->arch.cr2 = ex->payload;</blue>
		break;
	}

<blue>	ex->has_payload = false;</blue>
	ex-&gt;payload = 0;
<blue>}</blue>
EXPORT_SYMBOL_GPL(kvm_deliver_exception_payload);

static void kvm_queue_exception_vmexit(struct kvm_vcpu *vcpu, unsigned int vector,
				       bool has_error_code, u32 error_code,
				       bool has_payload, unsigned long payload)
{
	struct kvm_queued_exception *ex = &amp;vcpu-&gt;arch.exception_vmexit;

<blue>	ex->vector = vector;</blue>
	ex-&gt;injected = false;
	ex-&gt;pending = true;
	ex-&gt;has_error_code = has_error_code;
	ex-&gt;error_code = error_code;
	ex-&gt;has_payload = has_payload;
	ex-&gt;payload = payload;
}

/* Forcibly leave the nested mode in cases like a vCPU reset */
static void kvm_leave_nested(struct kvm_vcpu *vcpu)
{
<yellow>	kvm_x86_ops.nested_ops->leave_nested(vcpu);</yellow>
}

static void kvm_multiple_exception(struct kvm_vcpu *vcpu,
		unsigned nr, bool has_error, u32 error_code,
	        bool has_payload, unsigned long payload, bool reinject)
{
	u32 prev_nr;
	int class1, class2;

<blue>	kvm_make_request(KVM_REQ_EVENT, vcpu);</blue>

	/*
	 * If the exception is destined for L2 and isn&#x27;t being reinjected,
	 * morph it to a VM-Exit if L1 wants to intercept the exception.  A
	 * previously injected exception is not checked because it was checked
	 * when it was original queued, and re-checking is incorrect if _L1_
	 * injected the exception, in which case it&#x27;s exempt from interception.
	 */
<blue>	if (!reinject && is_guest_mode(vcpu) &&</blue>
<blue>	    kvm_x86_ops.nested_ops->is_exception_vmexit(vcpu, nr, error_code)) {</blue>
<blue>		kvm_queue_exception_vmexit(vcpu, nr, has_error, error_code,</blue>
					   has_payload, payload);
		return;
	}

<blue>	if (!vcpu->arch.exception.pending && !vcpu->arch.exception.injected) {</blue>
	queue:
<blue>		if (reinject) {</blue>
			/*
			 * On VM-Entry, an exception can be pending if and only
			 * if event injection was blocked by nested_run_pending.
			 * In that case, however, vcpu_enter_guest() requests an
			 * immediate exit, and the guest shouldn&#x27;t proceed far
			 * enough to need reinjection.
			 */
<blue>			WARN_ON_ONCE(kvm_is_exception_pending(vcpu));</blue>
<blue>			vcpu->arch.exception.injected = true;</blue>
<blue>			if (WARN_ON_ONCE(has_payload)) {</blue>
				/*
				 * A reinjected event has already
				 * delivered its payload.
				 */
				has_payload = false;
				payload = 0;
			}
		} else {
<blue>			vcpu->arch.exception.pending = true;</blue>
			vcpu-&gt;arch.exception.injected = false;
		}
		vcpu-&gt;arch.exception.has_error_code = has_error;
		vcpu-&gt;arch.exception.vector = nr;
		vcpu-&gt;arch.exception.error_code = error_code;
		vcpu-&gt;arch.exception.has_payload = has_payload;
		vcpu-&gt;arch.exception.payload = payload;
		if (!is_guest_mode(vcpu))
<blue>			kvm_deliver_exception_payload(vcpu,</blue>
						      &amp;vcpu-&gt;arch.exception);
		return;
	}

	/* to check exception */
<yellow>	prev_nr = vcpu->arch.exception.vector;</yellow>
	if (prev_nr == DF_VECTOR) {
		/* triple fault -&gt; shutdown */
<yellow>		kvm_make_request(KVM_REQ_TRIPLE_FAULT, vcpu);</yellow>
		return;
	}
<yellow>	class1 = exception_class(prev_nr);</yellow>
<yellow>	class2 = exception_class(nr);</yellow>
<yellow>	if ((class1 == EXCPT_CONTRIBUTORY && class2 == EXCPT_CONTRIBUTORY) ||</yellow>
	    (class1 == EXCPT_PF &amp;&amp; class2 != EXCPT_BENIGN)) {
		/*
		 * Synthesize #DF.  Clear the previously injected or pending
		 * exception so as not to incorrectly trigger shutdown.
		 */
<yellow>		vcpu->arch.exception.injected = false;</yellow>
		vcpu-&gt;arch.exception.pending = false;

		kvm_queue_exception_e(vcpu, DF_VECTOR, 0);
	} else {
		/* replace previous exception with a new one in a hope
		   that instruction re-execution will regenerate lost
		   exception */
		goto queue;
	}
<blue>}</blue>

void kvm_queue_exception(struct kvm_vcpu *vcpu, unsigned nr)
{
<blue>	kvm_multiple_exception(vcpu, nr, false, 0, false, 0, false);</blue>
}
EXPORT_SYMBOL_GPL(kvm_queue_exception);

void kvm_requeue_exception(struct kvm_vcpu *vcpu, unsigned nr)
{
<blue>	kvm_multiple_exception(vcpu, nr, false, 0, false, 0, true);</blue>
}
EXPORT_SYMBOL_GPL(kvm_requeue_exception);

void kvm_queue_exception_p(struct kvm_vcpu *vcpu, unsigned nr,
			   unsigned long payload)
{
<blue>	kvm_multiple_exception(vcpu, nr, false, 0, true, payload, false);</blue>
}
EXPORT_SYMBOL_GPL(kvm_queue_exception_p);

static void kvm_queue_exception_e_p(struct kvm_vcpu *vcpu, unsigned nr,
				    u32 error_code, unsigned long payload)
{
	kvm_multiple_exception(vcpu, nr, true, error_code,
			       true, payload, false);
}

<blue>int kvm_complete_insn_gp(struct kvm_vcpu *vcpu, int err)</blue>
{
<blue>	if (err)</blue>
<blue>		kvm_inject_gp(vcpu, 0);</blue>
	else
<blue>		return kvm_skip_emulated_instruction(vcpu);</blue>

	return 1;
<blue>}</blue>
EXPORT_SYMBOL_GPL(kvm_complete_insn_gp);

static int complete_emulated_insn_gp(struct kvm_vcpu *vcpu, int err)
{
	if (err) {
<yellow>		kvm_inject_gp(vcpu, 0);</yellow>
		return 1;
	}

<yellow>	return kvm_emulate_instruction(vcpu, EMULTYPE_NO_DECODE | EMULTYPE_SKIP |</yellow>
				       EMULTYPE_COMPLETE_USER_EXIT);
}

void kvm_inject_page_fault(struct kvm_vcpu *vcpu, struct x86_exception *fault)
{
<blue>	++vcpu->stat.pf_guest;</blue>

	/*
	 * Async #PF in L2 is always forwarded to L1 as a VM-Exit regardless of
	 * whether or not L1 wants to intercept &quot;regular&quot; #PF.
	 */
<yellow>	if (is_guest_mode(vcpu) && fault->async_page_fault)</yellow>
		kvm_queue_exception_vmexit(vcpu, PF_VECTOR,
<yellow>					   true, fault->error_code,</yellow>
					   true, fault-&gt;address);
	else
		kvm_queue_exception_e_p(vcpu, PF_VECTOR, fault-&gt;error_code,
					fault-&gt;address);
<blue>}</blue>
EXPORT_SYMBOL_GPL(kvm_inject_page_fault);

void kvm_inject_emulated_page_fault(struct kvm_vcpu *vcpu,
				    struct x86_exception *fault)
{
	struct kvm_mmu *fault_mmu;
<blue>	WARN_ON_ONCE(fault->vector != PF_VECTOR);</blue>

<blue>	fault_mmu = fault->nested_page_fault ? vcpu->arch.mmu :</blue>
					       vcpu-&gt;arch.walk_mmu;

	/*
	 * Invalidate the TLB entry for the faulting address, if it exists,
	 * else the access will fault indefinitely (and to emulate hardware).
	 */
<blue>	if ((fault->error_code & PFERR_PRESENT_MASK) &&</blue>
	    !(fault-&gt;error_code &amp; PFERR_RSVD_MASK))
<yellow>		kvm_mmu_invalidate_gva(vcpu, fault_mmu, fault->address,</yellow>
				       fault_mmu-&gt;root.hpa);

<blue>	fault_mmu->inject_page_fault(vcpu, fault);</blue>
}
EXPORT_SYMBOL_GPL(kvm_inject_emulated_page_fault);

void kvm_inject_nmi(struct kvm_vcpu *vcpu)
{
<yellow>	atomic_inc(&vcpu->arch.nmi_queued);</yellow>
	kvm_make_request(KVM_REQ_NMI, vcpu);
}
EXPORT_SYMBOL_GPL(kvm_inject_nmi);

void kvm_queue_exception_e(struct kvm_vcpu *vcpu, unsigned nr, u32 error_code)
{
<blue>	kvm_multiple_exception(vcpu, nr, true, error_code, false, 0, false);</blue>
}
EXPORT_SYMBOL_GPL(kvm_queue_exception_e);

void kvm_requeue_exception_e(struct kvm_vcpu *vcpu, unsigned nr, u32 error_code)
{
<blue>	kvm_multiple_exception(vcpu, nr, true, error_code, false, 0, true);</blue>
}
EXPORT_SYMBOL_GPL(kvm_requeue_exception_e);

/*
 * Checks if cpl &lt;= required_cpl; if true, return true.  Otherwise queue
 * a #GP and return false.
 */
<yellow>bool kvm_require_cpl(struct kvm_vcpu *vcpu, int required_cpl)</yellow>
{
<yellow>	if (static_call(kvm_x86_get_cpl)(vcpu) <= required_cpl)</yellow>
		return true;
<yellow>	kvm_queue_exception_e(vcpu, GP_VECTOR, 0);</yellow>
	return false;
<yellow>}</yellow>
EXPORT_SYMBOL_GPL(kvm_require_cpl);

bool kvm_require_dr(struct kvm_vcpu *vcpu, int dr)
{
<blue>	if ((dr != 4 && dr != 5) || !kvm_read_cr4_bits(vcpu, X86_CR4_DE))</blue>
		return true;

<yellow>	kvm_queue_exception(vcpu, UD_VECTOR);</yellow>
	return false;
<blue>}</blue>
EXPORT_SYMBOL_GPL(kvm_require_dr);

static inline u64 pdptr_rsvd_bits(struct kvm_vcpu *vcpu)
{
	return vcpu-&gt;arch.reserved_gpa_bits | rsvd_bits(5, 8) | rsvd_bits(1, 2);
}

/*
 * Load the pae pdptrs.  Return 1 if they are all valid, 0 otherwise.
 */
int load_pdptrs(struct kvm_vcpu *vcpu, unsigned long cr3)
<yellow>{</yellow>
<yellow>	struct kvm_mmu *mmu = vcpu->arch.walk_mmu;</yellow>
	gfn_t pdpt_gfn = cr3 &gt;&gt; PAGE_SHIFT;
	gpa_t real_gpa;
	int i;
	int ret;
	u64 pdpte[ARRAY_SIZE(mmu-&gt;pdptrs)];

	/*
	 * If the MMU is nested, CR3 holds an L2 GPA and needs to be translated
	 * to an L1 GPA.
	 */
<yellow>	real_gpa = kvm_translate_gpa(vcpu, mmu, gfn_to_gpa(pdpt_gfn),</yellow>
				     PFERR_USER_MASK | PFERR_WRITE_MASK, NULL);
	if (real_gpa == INVALID_GPA)
		return 0;

	/* Note the offset, PDPTRs are 32 byte aligned when using PAE paging. */
<yellow>	ret = kvm_vcpu_read_guest_page(vcpu, gpa_to_gfn(real_gpa), pdpte,</yellow>
				       cr3 &amp; GENMASK(11, 5), sizeof(pdpte));
	if (ret &lt; 0)
		return 0;

<yellow>	for (i = 0; i < ARRAY_SIZE(pdpte); ++i) {</yellow>
<yellow>		if ((pdpte[i] & PT_PRESENT_MASK) &&</yellow>
<yellow>		    (pdpte[i] & pdptr_rsvd_bits(vcpu))) {</yellow>
			return 0;
		}
	}

	/*
	 * Marking VCPU_EXREG_PDPTR dirty doesn&#x27;t work for !tdp_enabled.
	 * Shadow page roots need to be reconstructed instead.
	 */
<yellow>	if (!tdp_enabled && memcmp(mmu->pdptrs, pdpte, sizeof(mmu->pdptrs)))</yellow>
<yellow>		kvm_mmu_free_roots(vcpu->kvm, mmu, KVM_MMU_ROOT_CURRENT);</yellow>

<yellow>	memcpy(mmu->pdptrs, pdpte, sizeof(mmu->pdptrs));</yellow>
	kvm_register_mark_dirty(vcpu, VCPU_EXREG_PDPTR);
	kvm_make_request(KVM_REQ_LOAD_MMU_PGD, vcpu);
	vcpu-&gt;arch.pdptrs_from_userspace = false;

	return 1;
}
EXPORT_SYMBOL_GPL(load_pdptrs);

void kvm_post_set_cr0(struct kvm_vcpu *vcpu, unsigned long old_cr0, unsigned long cr0)
{
<blue>	if ((cr0 ^ old_cr0) & X86_CR0_PG) {</blue>
<blue>		kvm_clear_async_pf_completion_queue(vcpu);</blue>
<blue>		kvm_async_pf_hash_reset(vcpu);</blue>

		/*
		 * Clearing CR0.PG is defined to flush the TLB from the guest&#x27;s
		 * perspective.
		 */
<blue>		if (!(cr0 & X86_CR0_PG))</blue>
<yellow>			kvm_make_request(KVM_REQ_TLB_FLUSH_GUEST, vcpu);</yellow>
	}

<blue>	if ((cr0 ^ old_cr0) & KVM_MMU_CR0_ROLE_BITS)</blue>
<blue>		kvm_mmu_reset_context(vcpu);</blue>

<blue>	if (((cr0 ^ old_cr0) & X86_CR0_CD) &&</blue>
<blue>	    kvm_arch_has_noncoherent_dma(vcpu->kvm) &&</blue>
<yellow>	    !kvm_check_has_quirk(vcpu->kvm, KVM_X86_QUIRK_CD_NW_CLEARED))</yellow>
<yellow>		kvm_zap_gfn_range(vcpu->kvm, 0, ~0ULL);</yellow>
<blue>}</blue>
EXPORT_SYMBOL_GPL(kvm_post_set_cr0);

int kvm_set_cr0(struct kvm_vcpu *vcpu, unsigned long cr0)
<blue>{</blue>
<blue>	unsigned long old_cr0 = kvm_read_cr0(vcpu);</blue>

	cr0 |= X86_CR0_ET;

#ifdef CONFIG_X86_64
	if (cr0 &amp; 0xffffffff00000000UL)
		return 1;
#endif

	cr0 &amp;= ~CR0_RESERVED_BITS;

<blue>	if ((cr0 & X86_CR0_NW) && !(cr0 & X86_CR0_CD))</blue>
		return 1;

<blue>	if ((cr0 & X86_CR0_PG) && !(cr0 & X86_CR0_PE))</blue>
		return 1;

#ifdef CONFIG_X86_64
<blue>	if ((vcpu->arch.efer & EFER_LME) && !is_paging(vcpu) &&</blue>
	    (cr0 &amp; X86_CR0_PG)) {
		int cs_db, cs_l;

<blue>		if (!is_pae(vcpu))</blue>
<yellow>			return 1;</yellow>
<blue>		static_call(kvm_x86_get_cs_db_l_bits)(vcpu, &cs_db, &cs_l);</blue>
		if (cs_l)
			return 1;
	}
#endif
<blue>	if (!(vcpu->arch.efer & EFER_LME) && (cr0 & X86_CR0_PG) &&</blue>
<yellow>	    is_pae(vcpu) && ((cr0 ^ old_cr0) & X86_CR0_PDPTR_BITS) &&</yellow>
<yellow>	    !load_pdptrs(vcpu, kvm_read_cr3(vcpu)))</yellow>
		return 1;

<blue>	if (!(cr0 & X86_CR0_PG) &&</blue>
<blue>	    (is_64_bit_mode(vcpu) || kvm_read_cr4_bits(vcpu, X86_CR4_PCIDE)))</blue>
		return 1;

<blue>	static_call(kvm_x86_set_cr0)(vcpu, cr0);</blue>

	kvm_post_set_cr0(vcpu, old_cr0, cr0);

	return 0;
}
EXPORT_SYMBOL_GPL(kvm_set_cr0);

void kvm_lmsw(struct kvm_vcpu *vcpu, unsigned long msw)
{
<yellow>	(void)kvm_set_cr0(vcpu, kvm_read_cr0_bits(vcpu, ~0x0eul) | (msw & 0x0f));</yellow>
}
EXPORT_SYMBOL_GPL(kvm_lmsw);

<blue>void kvm_load_guest_xsave_state(struct kvm_vcpu *vcpu)</blue>
{
<blue>	if (vcpu->arch.guest_state_protected)</blue>
		return;

<blue>	if (kvm_read_cr4_bits(vcpu, X86_CR4_OSXSAVE)) {</blue>

<blue>		if (vcpu->arch.xcr0 != host_xcr0)</blue>
<blue>			xsetbv(XCR_XFEATURE_ENABLED_MASK, vcpu->arch.xcr0);</blue>

<blue>		if (vcpu->arch.xsaves_enabled &&</blue>
<blue>		    vcpu->arch.ia32_xss != host_xss)</blue>
<blue>			wrmsrl(MSR_IA32_XSS, vcpu->arch.ia32_xss);</blue>
	}

#ifdef CONFIG_X86_INTEL_MEMORY_PROTECTION_KEYS
<blue>	if (static_cpu_has(X86_FEATURE_PKU) &&</blue>
<blue>	    vcpu->arch.pkru != vcpu->arch.host_pkru &&</blue>
<blue>	    ((vcpu->arch.xcr0 & XFEATURE_MASK_PKRU) ||</blue>
<blue>	     kvm_read_cr4_bits(vcpu, X86_CR4_PKE)))</blue>
<blue>		write_pkru(vcpu->arch.pkru);</blue>
#endif /* CONFIG_X86_INTEL_MEMORY_PROTECTION_KEYS */
<blue>}</blue>
EXPORT_SYMBOL_GPL(kvm_load_guest_xsave_state);

<blue>void kvm_load_host_xsave_state(struct kvm_vcpu *vcpu)</blue>
{
<blue>	if (vcpu->arch.guest_state_protected)</blue>
		return;

#ifdef CONFIG_X86_INTEL_MEMORY_PROTECTION_KEYS
<blue>	if (static_cpu_has(X86_FEATURE_PKU) &&</blue>
<blue>	    ((vcpu->arch.xcr0 & XFEATURE_MASK_PKRU) ||</blue>
<blue>	     kvm_read_cr4_bits(vcpu, X86_CR4_PKE))) {</blue>
<blue>		vcpu->arch.pkru = rdpkru();</blue>
		if (vcpu-&gt;arch.pkru != vcpu-&gt;arch.host_pkru)
<blue>			write_pkru(vcpu->arch.host_pkru);</blue>
	}
#endif /* CONFIG_X86_INTEL_MEMORY_PROTECTION_KEYS */

<blue>	if (kvm_read_cr4_bits(vcpu, X86_CR4_OSXSAVE)) {</blue>

<blue>		if (vcpu->arch.xcr0 != host_xcr0)</blue>
<blue>			xsetbv(XCR_XFEATURE_ENABLED_MASK, host_xcr0);</blue>

<blue>		if (vcpu->arch.xsaves_enabled &&</blue>
<blue>		    vcpu->arch.ia32_xss != host_xss)</blue>
<blue>			wrmsrl(MSR_IA32_XSS, host_xss);</blue>
	}

<blue>}</blue>
EXPORT_SYMBOL_GPL(kvm_load_host_xsave_state);

#ifdef CONFIG_X86_64
static inline u64 kvm_guest_supported_xfd(struct kvm_vcpu *vcpu)
{
<yellow>	return vcpu->arch.guest_supported_xcr0 & XFEATURE_MASK_USER_DYNAMIC;</yellow>
}
#endif

static int __kvm_set_xcr(struct kvm_vcpu *vcpu, u32 index, u64 xcr)
{
	u64 xcr0 = xcr;
<blue>	u64 old_xcr0 = vcpu->arch.xcr0;</blue>
	u64 valid_bits;

	/* Only support XCR_XFEATURE_ENABLED_MASK(xcr0) now  */
<blue>	if (index != XCR_XFEATURE_ENABLED_MASK)</blue>
		return 1;
<blue>	if (!(xcr0 & XFEATURE_MASK_FP))</blue>
		return 1;
<blue>	if ((xcr0 & XFEATURE_MASK_YMM) && !(xcr0 & XFEATURE_MASK_SSE))</blue>
		return 1;

	/*
	 * Do not allow the guest to set bits that we do not support
	 * saving.  However, xcr0 bit 0 is always set, even if the
	 * emulated CPU does not support XSAVE (see kvm_vcpu_reset()).
	 */
<blue>	valid_bits = vcpu->arch.guest_supported_xcr0 | XFEATURE_MASK_FP;</blue>
	if (xcr0 &amp; ~valid_bits)
		return 1;

<blue>	if ((!(xcr0 & XFEATURE_MASK_BNDREGS)) !=</blue>
	    (!(xcr0 &amp; XFEATURE_MASK_BNDCSR)))
		return 1;

<blue>	if (xcr0 & XFEATURE_MASK_AVX512) {</blue>
<yellow>		if (!(xcr0 & XFEATURE_MASK_YMM))</yellow>
			return 1;
<yellow>		if ((xcr0 & XFEATURE_MASK_AVX512) != XFEATURE_MASK_AVX512)</yellow>
			return 1;
	}

<blue>	if ((xcr0 & XFEATURE_MASK_XTILE) &&</blue>
	    ((xcr0 &amp; XFEATURE_MASK_XTILE) != XFEATURE_MASK_XTILE))
		return 1;

	vcpu-&gt;arch.xcr0 = xcr0;

	if ((xcr0 ^ old_xcr0) &amp; XFEATURE_MASK_EXTEND)
<yellow>		kvm_update_cpuid_runtime(vcpu);</yellow>
	return 0;
<blue>}</blue>

int kvm_emulate_xsetbv(struct kvm_vcpu *vcpu)
{
	/* Note, #UD due to CR4.OSXSAVE=0 has priority over the intercept. */
<yellow>	if (static_call(kvm_x86_get_cpl)(vcpu) != 0 ||</yellow>
<yellow>	    __kvm_set_xcr(vcpu, kvm_rcx_read(vcpu), kvm_read_edx_eax(vcpu))) {</yellow>
<yellow>		kvm_inject_gp(vcpu, 0);</yellow>
		return 1;
	}

<yellow>	return kvm_skip_emulated_instruction(vcpu);</yellow>
<yellow>}</yellow>
EXPORT_SYMBOL_GPL(kvm_emulate_xsetbv);

bool __kvm_is_valid_cr4(struct kvm_vcpu *vcpu, unsigned long cr4)
{
<blue>	if (cr4 & cr4_reserved_bits)</blue>
		return false;

<blue>	if (cr4 & vcpu->arch.cr4_guest_rsvd_bits)</blue>
		return false;

	return true;
<blue>}</blue>
EXPORT_SYMBOL_GPL(__kvm_is_valid_cr4);

static bool kvm_is_valid_cr4(struct kvm_vcpu *vcpu, unsigned long cr4)
{
<blue>	return __kvm_is_valid_cr4(vcpu, cr4) &&</blue>
<blue>	       static_call(kvm_x86_is_valid_cr4)(vcpu, cr4);</blue>
}

void kvm_post_set_cr4(struct kvm_vcpu *vcpu, unsigned long old_cr4, unsigned long cr4)
{
<blue>	if ((cr4 ^ old_cr4) & KVM_MMU_CR4_ROLE_BITS)</blue>
<blue>		kvm_mmu_reset_context(vcpu);</blue>

	/*
	 * If CR4.PCIDE is changed 0 -&gt; 1, there is no need to flush the TLB
	 * according to the SDM; however, stale prev_roots could be reused
	 * incorrectly in the future after a MOV to CR3 with NOFLUSH=1, so we
	 * free them all.  This is *not* a superset of KVM_REQ_TLB_FLUSH_GUEST
	 * or KVM_REQ_TLB_FLUSH_CURRENT, because the hardware TLB is not flushed,
	 * so fall through.
	 */
<blue>	if (!tdp_enabled &&</blue>
<yellow>	    (cr4 & X86_CR4_PCIDE) && !(old_cr4 & X86_CR4_PCIDE))</yellow>
<yellow>		kvm_mmu_unload(vcpu);</yellow>

	/*
	 * The TLB has to be flushed for all PCIDs if any of the following
	 * (architecturally required) changes happen:
	 * - CR4.PCIDE is changed from 1 to 0
	 * - CR4.PGE is toggled
	 *
	 * This is a superset of KVM_REQ_TLB_FLUSH_CURRENT.
	 */
<blue>	if (((cr4 ^ old_cr4) & X86_CR4_PGE) ||</blue>
<blue>	    (!(cr4 & X86_CR4_PCIDE) && (old_cr4 & X86_CR4_PCIDE)))</blue>
<yellow>		kvm_make_request(KVM_REQ_TLB_FLUSH_GUEST, vcpu);</yellow>

	/*
	 * The TLB has to be flushed for the current PCID if any of the
	 * following (architecturally required) changes happen:
	 * - CR4.SMEP is changed from 0 to 1
	 * - CR4.PAE is toggled
	 */
<blue>	else if (((cr4 ^ old_cr4) & X86_CR4_PAE) ||</blue>
<blue>		 ((cr4 & X86_CR4_SMEP) && !(old_cr4 & X86_CR4_SMEP)))</blue>
<blue>		kvm_make_request(KVM_REQ_TLB_FLUSH_CURRENT, vcpu);</blue>

<blue>}</blue>
EXPORT_SYMBOL_GPL(kvm_post_set_cr4);

int kvm_set_cr4(struct kvm_vcpu *vcpu, unsigned long cr4)
{
<blue>	unsigned long old_cr4 = kvm_read_cr4(vcpu);</blue>

<blue>	if (!kvm_is_valid_cr4(vcpu, cr4))</blue>
		return 1;

<blue>	if (is_long_mode(vcpu)) {</blue>
<blue>		if (!(cr4 & X86_CR4_PAE))</blue>
			return 1;
<blue>		if ((cr4 ^ old_cr4) & X86_CR4_LA57)</blue>
			return 1;
<blue>	} else if (is_paging(vcpu) && (cr4 & X86_CR4_PAE)</blue>
<yellow>		   && ((cr4 ^ old_cr4) & X86_CR4_PDPTR_BITS)</yellow>
<yellow>		   && !load_pdptrs(vcpu, kvm_read_cr3(vcpu)))</yellow>
		return 1;

<blue>	if ((cr4 & X86_CR4_PCIDE) && !(old_cr4 & X86_CR4_PCIDE)) {</blue>
<yellow>		if (!guest_cpuid_has(vcpu, X86_FEATURE_PCID))</yellow>
			return 1;

		/* PCID can not be enabled when cr3[11:0]!=000H or EFER.LMA=0 */
<yellow>		if ((kvm_read_cr3(vcpu) & X86_CR3_PCID_MASK) || !is_long_mode(vcpu))</yellow>
			return 1;
	}

<blue>	static_call(kvm_x86_set_cr4)(vcpu, cr4);</blue>

	kvm_post_set_cr4(vcpu, old_cr4, cr4);

	return 0;
<blue>}</blue>
EXPORT_SYMBOL_GPL(kvm_set_cr4);

static void kvm_invalidate_pcid(struct kvm_vcpu *vcpu, unsigned long pcid)
{
<yellow>	struct kvm_mmu *mmu = vcpu->arch.mmu;</yellow>
	unsigned long roots_to_free = 0;
	int i;

	/*
	 * MOV CR3 and INVPCID are usually not intercepted when using TDP, but
	 * this is reachable when running EPT=1 and unrestricted_guest=0,  and
	 * also via the emulator.  KVM&#x27;s TDP page tables are not in the scope of
	 * the invalidation, but the guest&#x27;s TLB entries need to be flushed as
	 * the CPU may have cached entries in its TLB for the target PCID.
	 */
<yellow>	if (unlikely(tdp_enabled)) {</yellow>
<yellow>		kvm_make_request(KVM_REQ_TLB_FLUSH_GUEST, vcpu);</yellow>
		return;
	}

	/*
	 * If neither the current CR3 nor any of the prev_roots use the given
	 * PCID, then nothing needs to be done here because a resync will
	 * happen anyway before switching to any other CR3.
	 */
<yellow>	if (kvm_get_active_pcid(vcpu) == pcid) {</yellow>
<yellow>		kvm_make_request(KVM_REQ_MMU_SYNC, vcpu);</yellow>
		kvm_make_request(KVM_REQ_TLB_FLUSH_CURRENT, vcpu);
	}

	/*
	 * If PCID is disabled, there is no need to free prev_roots even if the
	 * PCIDs for them are also 0, because MOV to CR3 always flushes the TLB
	 * with PCIDE=0.
	 */
<yellow>	if (!kvm_read_cr4_bits(vcpu, X86_CR4_PCIDE))</yellow>
		return;

<yellow>	for (i = 0; i < KVM_MMU_NUM_PREV_ROOTS; i++)</yellow>
<yellow>		if (kvm_get_pcid(vcpu, mmu->prev_roots[i].pgd) == pcid)</yellow>
<yellow>			roots_to_free |= KVM_MMU_ROOT_PREVIOUS(i);</yellow>

<yellow>	kvm_mmu_free_roots(vcpu->kvm, mmu, roots_to_free);</yellow>
<yellow>}</yellow>

int kvm_set_cr3(struct kvm_vcpu *vcpu, unsigned long cr3)
{
	bool skip_tlb_flush = false;
	unsigned long pcid = 0;
#ifdef CONFIG_X86_64
<yellow>	bool pcid_enabled = kvm_read_cr4_bits(vcpu, X86_CR4_PCIDE);</yellow>

	if (pcid_enabled) {
<yellow>		skip_tlb_flush = cr3 & X86_CR3_PCID_NOFLUSH;</yellow>
		cr3 &amp;= ~X86_CR3_PCID_NOFLUSH;
		pcid = cr3 &amp; X86_CR3_PCID_MASK;
	}
#endif

	/* PDPTRs are always reloaded for PAE paging. */
<yellow>	if (cr3 == kvm_read_cr3(vcpu) && !is_pae_paging(vcpu))</yellow>
		goto handle_tlb_flush;

	/*
	 * Do not condition the GPA check on long mode, this helper is used to
	 * stuff CR3, e.g. for RSM emulation, and there is no guarantee that
	 * the current vCPU mode is accurate.
	 */
<yellow>	if (kvm_vcpu_is_illegal_gpa(vcpu, cr3))</yellow>
		return 1;

<yellow>	if (is_pae_paging(vcpu) && !load_pdptrs(vcpu, cr3))</yellow>
		return 1;

<yellow>	if (cr3 != kvm_read_cr3(vcpu))</yellow>
<yellow>		kvm_mmu_new_pgd(vcpu, cr3);</yellow>

<yellow>	vcpu->arch.cr3 = cr3;</yellow>
	kvm_register_mark_dirty(vcpu, VCPU_EXREG_CR3);
	/* Do not call post_set_cr3, we do not get here for confidential guests.  */

handle_tlb_flush:
	/*
	 * A load of CR3 that flushes the TLB flushes only the current PCID,
	 * even if PCID is disabled, in which case PCID=0 is flushed.  It&#x27;s a
	 * moot point in the end because _disabling_ PCID will flush all PCIDs,
	 * and it&#x27;s impossible to use a non-zero PCID when PCID is disabled,
	 * i.e. only PCID=0 can be relevant.
	 */
<yellow>	if (!skip_tlb_flush)</yellow>
<yellow>		kvm_invalidate_pcid(vcpu, pcid);</yellow>

	return 0;
<yellow>}</yellow>
EXPORT_SYMBOL_GPL(kvm_set_cr3);

<blue>int kvm_set_cr8(struct kvm_vcpu *vcpu, unsigned long cr8)</blue>
{
<blue>	if (cr8 & CR8_RESERVED_BITS)</blue>
		return 1;
<blue>	if (lapic_in_kernel(vcpu))</blue>
<blue>		kvm_lapic_set_tpr(vcpu, cr8);</blue>
	else
<yellow>		vcpu->arch.cr8 = cr8;</yellow>
	return 0;
<blue>}</blue>
EXPORT_SYMBOL_GPL(kvm_set_cr8);

unsigned long kvm_get_cr8(struct kvm_vcpu *vcpu)
{
<blue>	if (lapic_in_kernel(vcpu))</blue>
<blue>		return kvm_lapic_get_cr8(vcpu);</blue>
	else
<yellow>		return vcpu->arch.cr8;</yellow>
<blue>}</blue>
EXPORT_SYMBOL_GPL(kvm_get_cr8);

<blue>static void kvm_update_dr0123(struct kvm_vcpu *vcpu)</blue>
{
	int i;

	if (!(vcpu-&gt;guest_debug &amp; KVM_GUESTDBG_USE_HW_BP)) {
		for (i = 0; i &lt; KVM_NR_DB_REGS; i++)
<blue>			vcpu->arch.eff_db[i] = vcpu->arch.db[i];</blue>
	}
}

void kvm_update_dr7(struct kvm_vcpu *vcpu)
{
	unsigned long dr7;

<blue>	if (vcpu->guest_debug & KVM_GUESTDBG_USE_HW_BP)</blue>
<yellow>		dr7 = vcpu->arch.guest_debug_dr7;</yellow>
	else
<yellow>		dr7 = vcpu->arch.dr7;</yellow>
<blue>	static_call(kvm_x86_set_dr7)(vcpu, dr7);</blue>
<blue>	vcpu->arch.switch_db_regs &= ~KVM_DEBUGREG_BP_ENABLED;</blue>
	if (dr7 &amp; DR7_BP_EN_MASK)
<blue>		vcpu->arch.switch_db_regs |= KVM_DEBUGREG_BP_ENABLED;</blue>
<yellow>}</yellow>
EXPORT_SYMBOL_GPL(kvm_update_dr7);

static u64 kvm_dr6_fixed(struct kvm_vcpu *vcpu)
{
	u64 fixed = DR6_FIXED_1;

<yellow>	if (!guest_cpuid_has(vcpu, X86_FEATURE_RTM))</yellow>
		fixed |= DR6_RTM;

<yellow>	if (!guest_cpuid_has(vcpu, X86_FEATURE_BUS_LOCK_DETECT))</yellow>
<yellow>		fixed |= DR6_BUS_LOCK;</yellow>
	return fixed;
}

int kvm_set_dr(struct kvm_vcpu *vcpu, int dr, unsigned long val)
{
	size_t size = ARRAY_SIZE(vcpu-&gt;arch.db);

<blue>	switch (dr) {</blue>
	case 0 ... 3:
<yellow>		vcpu->arch.db[array_index_nospec(dr, size)] = val;</yellow>
		if (!(vcpu-&gt;guest_debug &amp; KVM_GUESTDBG_USE_HW_BP))
<yellow>			vcpu->arch.eff_db[dr] = val;</yellow>
		break;
	case 4:
	case 6:
<yellow>		if (!kvm_dr6_valid(val))</yellow>
			return 1; /* #GP */
<yellow>		vcpu->arch.dr6 = (val & DR6_VOLATILE) | kvm_dr6_fixed(vcpu);</yellow>
		break;
	case 5:
	default: /* 7 */
<blue>		if (!kvm_dr7_valid(val))</blue>
			return 1; /* #GP */
<blue>		vcpu->arch.dr7 = (val & DR7_VOLATILE) | DR7_FIXED_1;</blue>
<blue>		kvm_update_dr7(vcpu);</blue>
		break;
	}

	return 0;
<blue>}</blue>
EXPORT_SYMBOL_GPL(kvm_set_dr);

<blue>void kvm_get_dr(struct kvm_vcpu *vcpu, int dr, unsigned long *val)</blue>
{
	size_t size = ARRAY_SIZE(vcpu-&gt;arch.db);

<blue>	switch (dr) {</blue>
	case 0 ... 3:
<blue>		*val = vcpu->arch.db[array_index_nospec(dr, size)];</blue>
		break;
	case 4:
	case 6:
<yellow>		*val = vcpu->arch.dr6;</yellow>
		break;
	case 5:
	default: /* 7 */
<blue>		*val = vcpu->arch.dr7;</blue>
		break;
	}
}
EXPORT_SYMBOL_GPL(kvm_get_dr);

<blue>int kvm_emulate_rdpmc(struct kvm_vcpu *vcpu)</blue>
<blue>{</blue>
<blue>	u32 ecx = kvm_rcx_read(vcpu);</blue>
	u64 data;

	if (kvm_pmu_rdpmc(vcpu, ecx, &amp;data)) {
<blue>		kvm_inject_gp(vcpu, 0);</blue>
		return 1;
	}

<yellow>	kvm_rax_write(vcpu, (u32)data);</yellow>
	kvm_rdx_write(vcpu, data &gt;&gt; 32);
<yellow>	return kvm_skip_emulated_instruction(vcpu);</yellow>
}
EXPORT_SYMBOL_GPL(kvm_emulate_rdpmc);

/*
 * List of msr numbers which we expose to userspace through KVM_GET_MSRS
 * and KVM_SET_MSRS, and KVM_GET_MSR_INDEX_LIST.
 *
 * The three MSR lists(msrs_to_save, emulated_msrs, msr_based_features)
 * extract the supported MSRs from the related const lists.
 * msrs_to_save is selected from the msrs_to_save_all to reflect the
 * capabilities of the host cpu. This capabilities test skips MSRs that are
 * kvm-specific. Those are put in emulated_msrs_all; filtering of emulated_msrs
 * may depend on host virtualization features rather than host cpu features.
 */

static const u32 msrs_to_save_all[] = {
	MSR_IA32_SYSENTER_CS, MSR_IA32_SYSENTER_ESP, MSR_IA32_SYSENTER_EIP,
	MSR_STAR,
#ifdef CONFIG_X86_64
	MSR_CSTAR, MSR_KERNEL_GS_BASE, MSR_SYSCALL_MASK, MSR_LSTAR,
#endif
	MSR_IA32_TSC, MSR_IA32_CR_PAT, MSR_VM_HSAVE_PA,
	MSR_IA32_FEAT_CTL, MSR_IA32_BNDCFGS, MSR_TSC_AUX,
	MSR_IA32_SPEC_CTRL,
	MSR_IA32_RTIT_CTL, MSR_IA32_RTIT_STATUS, MSR_IA32_RTIT_CR3_MATCH,
	MSR_IA32_RTIT_OUTPUT_BASE, MSR_IA32_RTIT_OUTPUT_MASK,
	MSR_IA32_RTIT_ADDR0_A, MSR_IA32_RTIT_ADDR0_B,
	MSR_IA32_RTIT_ADDR1_A, MSR_IA32_RTIT_ADDR1_B,
	MSR_IA32_RTIT_ADDR2_A, MSR_IA32_RTIT_ADDR2_B,
	MSR_IA32_RTIT_ADDR3_A, MSR_IA32_RTIT_ADDR3_B,
	MSR_IA32_UMWAIT_CONTROL,

	MSR_ARCH_PERFMON_FIXED_CTR0, MSR_ARCH_PERFMON_FIXED_CTR1,
	MSR_ARCH_PERFMON_FIXED_CTR0 + 2,
	MSR_CORE_PERF_FIXED_CTR_CTRL, MSR_CORE_PERF_GLOBAL_STATUS,
	MSR_CORE_PERF_GLOBAL_CTRL, MSR_CORE_PERF_GLOBAL_OVF_CTRL,
	MSR_IA32_PEBS_ENABLE, MSR_IA32_DS_AREA, MSR_PEBS_DATA_CFG,

	/* This part of MSRs should match KVM_INTEL_PMC_MAX_GENERIC. */
	MSR_ARCH_PERFMON_PERFCTR0, MSR_ARCH_PERFMON_PERFCTR1,
	MSR_ARCH_PERFMON_PERFCTR0 + 2, MSR_ARCH_PERFMON_PERFCTR0 + 3,
	MSR_ARCH_PERFMON_PERFCTR0 + 4, MSR_ARCH_PERFMON_PERFCTR0 + 5,
	MSR_ARCH_PERFMON_PERFCTR0 + 6, MSR_ARCH_PERFMON_PERFCTR0 + 7,
	MSR_ARCH_PERFMON_EVENTSEL0, MSR_ARCH_PERFMON_EVENTSEL1,
	MSR_ARCH_PERFMON_EVENTSEL0 + 2, MSR_ARCH_PERFMON_EVENTSEL0 + 3,
	MSR_ARCH_PERFMON_EVENTSEL0 + 4, MSR_ARCH_PERFMON_EVENTSEL0 + 5,
	MSR_ARCH_PERFMON_EVENTSEL0 + 6, MSR_ARCH_PERFMON_EVENTSEL0 + 7,

	MSR_K7_EVNTSEL0, MSR_K7_EVNTSEL1, MSR_K7_EVNTSEL2, MSR_K7_EVNTSEL3,
	MSR_K7_PERFCTR0, MSR_K7_PERFCTR1, MSR_K7_PERFCTR2, MSR_K7_PERFCTR3,

	/* This part of MSRs should match KVM_AMD_PMC_MAX_GENERIC. */
	MSR_F15H_PERF_CTL0, MSR_F15H_PERF_CTL1, MSR_F15H_PERF_CTL2,
	MSR_F15H_PERF_CTL3, MSR_F15H_PERF_CTL4, MSR_F15H_PERF_CTL5,
	MSR_F15H_PERF_CTR0, MSR_F15H_PERF_CTR1, MSR_F15H_PERF_CTR2,
	MSR_F15H_PERF_CTR3, MSR_F15H_PERF_CTR4, MSR_F15H_PERF_CTR5,

	MSR_IA32_XFD, MSR_IA32_XFD_ERR,
};

static u32 msrs_to_save[ARRAY_SIZE(msrs_to_save_all)];
static unsigned num_msrs_to_save;

static const u32 emulated_msrs_all[] = {
	MSR_KVM_SYSTEM_TIME, MSR_KVM_WALL_CLOCK,
	MSR_KVM_SYSTEM_TIME_NEW, MSR_KVM_WALL_CLOCK_NEW,
	HV_X64_MSR_GUEST_OS_ID, HV_X64_MSR_HYPERCALL,
	HV_X64_MSR_TIME_REF_COUNT, HV_X64_MSR_REFERENCE_TSC,
	HV_X64_MSR_TSC_FREQUENCY, HV_X64_MSR_APIC_FREQUENCY,
	HV_X64_MSR_CRASH_P0, HV_X64_MSR_CRASH_P1, HV_X64_MSR_CRASH_P2,
	HV_X64_MSR_CRASH_P3, HV_X64_MSR_CRASH_P4, HV_X64_MSR_CRASH_CTL,
	HV_X64_MSR_RESET,
	HV_X64_MSR_VP_INDEX,
	HV_X64_MSR_VP_RUNTIME,
	HV_X64_MSR_SCONTROL,
	HV_X64_MSR_STIMER0_CONFIG,
	HV_X64_MSR_VP_ASSIST_PAGE,
	HV_X64_MSR_REENLIGHTENMENT_CONTROL, HV_X64_MSR_TSC_EMULATION_CONTROL,
	HV_X64_MSR_TSC_EMULATION_STATUS,
	HV_X64_MSR_SYNDBG_OPTIONS,
	HV_X64_MSR_SYNDBG_CONTROL, HV_X64_MSR_SYNDBG_STATUS,
	HV_X64_MSR_SYNDBG_SEND_BUFFER, HV_X64_MSR_SYNDBG_RECV_BUFFER,
	HV_X64_MSR_SYNDBG_PENDING_BUFFER,

	MSR_KVM_ASYNC_PF_EN, MSR_KVM_STEAL_TIME,
	MSR_KVM_PV_EOI_EN, MSR_KVM_ASYNC_PF_INT, MSR_KVM_ASYNC_PF_ACK,

	MSR_IA32_TSC_ADJUST,
	MSR_IA32_TSC_DEADLINE,
	MSR_IA32_ARCH_CAPABILITIES,
	MSR_IA32_PERF_CAPABILITIES,
	MSR_IA32_MISC_ENABLE,
	MSR_IA32_MCG_STATUS,
	MSR_IA32_MCG_CTL,
	MSR_IA32_MCG_EXT_CTL,
	MSR_IA32_SMBASE,
	MSR_SMI_COUNT,
	MSR_PLATFORM_INFO,
	MSR_MISC_FEATURES_ENABLES,
	MSR_AMD64_VIRT_SPEC_CTRL,
	MSR_AMD64_TSC_RATIO,
	MSR_IA32_POWER_CTL,
	MSR_IA32_UCODE_REV,

	/*
	 * The following list leaves out MSRs whose values are determined
	 * by arch/x86/kvm/vmx/nested.c based on CPUID or other MSRs.
	 * We always support the &quot;true&quot; VMX control MSRs, even if the host
	 * processor does not, so I am putting these registers here rather
	 * than in msrs_to_save_all.
	 */
	MSR_IA32_VMX_BASIC,
	MSR_IA32_VMX_TRUE_PINBASED_CTLS,
	MSR_IA32_VMX_TRUE_PROCBASED_CTLS,
	MSR_IA32_VMX_TRUE_EXIT_CTLS,
	MSR_IA32_VMX_TRUE_ENTRY_CTLS,
	MSR_IA32_VMX_MISC,
	MSR_IA32_VMX_CR0_FIXED0,
	MSR_IA32_VMX_CR4_FIXED0,
	MSR_IA32_VMX_VMCS_ENUM,
	MSR_IA32_VMX_PROCBASED_CTLS2,
	MSR_IA32_VMX_EPT_VPID_CAP,
	MSR_IA32_VMX_VMFUNC,

	MSR_K7_HWCR,
	MSR_KVM_POLL_CONTROL,
};

static u32 emulated_msrs[ARRAY_SIZE(emulated_msrs_all)];
static unsigned num_emulated_msrs;

/*
 * List of msr numbers which are used to expose MSR-based features that
 * can be used by a hypervisor to validate requested CPU features.
 */
static const u32 msr_based_features_all[] = {
	MSR_IA32_VMX_BASIC,
	MSR_IA32_VMX_TRUE_PINBASED_CTLS,
	MSR_IA32_VMX_PINBASED_CTLS,
	MSR_IA32_VMX_TRUE_PROCBASED_CTLS,
	MSR_IA32_VMX_PROCBASED_CTLS,
	MSR_IA32_VMX_TRUE_EXIT_CTLS,
	MSR_IA32_VMX_EXIT_CTLS,
	MSR_IA32_VMX_TRUE_ENTRY_CTLS,
	MSR_IA32_VMX_ENTRY_CTLS,
	MSR_IA32_VMX_MISC,
	MSR_IA32_VMX_CR0_FIXED0,
	MSR_IA32_VMX_CR0_FIXED1,
	MSR_IA32_VMX_CR4_FIXED0,
	MSR_IA32_VMX_CR4_FIXED1,
	MSR_IA32_VMX_VMCS_ENUM,
	MSR_IA32_VMX_PROCBASED_CTLS2,
	MSR_IA32_VMX_EPT_VPID_CAP,
	MSR_IA32_VMX_VMFUNC,

	MSR_AMD64_DE_CFG,
	MSR_IA32_UCODE_REV,
	MSR_IA32_ARCH_CAPABILITIES,
	MSR_IA32_PERF_CAPABILITIES,
};

static u32 msr_based_features[ARRAY_SIZE(msr_based_features_all)];
static unsigned int num_msr_based_features;

/*
 * Some IA32_ARCH_CAPABILITIES bits have dependencies on MSRs that KVM
 * does not yet virtualize. These include:
 *   10 - MISC_PACKAGE_CTRLS
 *   11 - ENERGY_FILTERING_CTL
 *   12 - DOITM
 *   18 - FB_CLEAR_CTRL
 *   21 - XAPIC_DISABLE_STATUS
 *   23 - OVERCLOCKING_STATUS
 */

#define KVM_SUPPORTED_ARCH_CAP \
	(ARCH_CAP_RDCL_NO | ARCH_CAP_IBRS_ALL | ARCH_CAP_RSBA | \
	 ARCH_CAP_SKIP_VMENTRY_L1DFLUSH | ARCH_CAP_SSB_NO | ARCH_CAP_MDS_NO | \
	 ARCH_CAP_PSCHANGE_MC_NO | ARCH_CAP_TSX_CTRL_MSR | ARCH_CAP_TAA_NO | \
	 ARCH_CAP_SBDR_SSDP_NO | ARCH_CAP_FBSDP_NO | ARCH_CAP_PSDP_NO | \
	 ARCH_CAP_FB_CLEAR | ARCH_CAP_RRSBA | ARCH_CAP_PBRSB_NO)

static u64 kvm_get_arch_capabilities(void)
{
	u64 data = 0;

<blue>	if (boot_cpu_has(X86_FEATURE_ARCH_CAPABILITIES)) {</blue>
<blue>		rdmsrl(MSR_IA32_ARCH_CAPABILITIES, data);</blue>
		data &amp;= KVM_SUPPORTED_ARCH_CAP;
	}

	/*
	 * If nx_huge_pages is enabled, KVM&#x27;s shadow paging will ensure that
	 * the nested hypervisor runs with NX huge pages.  If it is not,
	 * L1 is anyway vulnerable to ITLB_MULTIHIT exploits from other
	 * L1 guests, so it need not worry about its own (L2) guests.
	 */
	data |= ARCH_CAP_PSCHANGE_MC_NO;

	/*
	 * If we&#x27;re doing cache flushes (either &quot;always&quot; or &quot;cond&quot;)
	 * we will do one whenever the guest does a vmlaunch/vmresume.
	 * If an outer hypervisor is doing the cache flush for us
	 * (VMENTER_L1D_FLUSH_NESTED_VM), we can safely pass that
	 * capability to the guest too, and if EPT is disabled we&#x27;re not
	 * vulnerable.  Overall, only VMENTER_L1D_FLUSH_NEVER will
	 * require a nested hypervisor to do a flush of its own.
	 */
<blue>	if (l1tf_vmx_mitigation != VMENTER_L1D_FLUSH_NEVER)</blue>
<blue>		data |= ARCH_CAP_SKIP_VMENTRY_L1DFLUSH;</blue>

<blue>	if (!boot_cpu_has_bug(X86_BUG_CPU_MELTDOWN))</blue>
<blue>		data |= ARCH_CAP_RDCL_NO;</blue>
<blue>	if (!boot_cpu_has_bug(X86_BUG_SPEC_STORE_BYPASS))</blue>
<yellow>		data |= ARCH_CAP_SSB_NO;</yellow>
<blue>	if (!boot_cpu_has_bug(X86_BUG_MDS))</blue>
<blue>		data |= ARCH_CAP_MDS_NO;</blue>

<blue>	if (!boot_cpu_has(X86_FEATURE_RTM)) {</blue>
		/*
		 * If RTM=0 because the kernel has disabled TSX, the host might
		 * have TAA_NO or TSX_CTRL.  Clear TAA_NO (the guest sees RTM=0
		 * and therefore knows that there cannot be TAA) but keep
		 * TSX_CTRL: some buggy userspaces leave it set on tsx=on hosts,
		 * and we want to allow migrating those guests to tsx=off hosts.
		 */
<blue>		data &= ~ARCH_CAP_TAA_NO;</blue>
<yellow>	} else if (!boot_cpu_has_bug(X86_BUG_TAA)) {</yellow>
<yellow>		data |= ARCH_CAP_TAA_NO;</yellow>
	} else {
		/*
		 * Nothing to do here; we emulate TSX_CTRL if present on the
		 * host so the guest can choose between disabling TSX or
		 * using VERW to clear CPU buffers.
		 */
	}

	return data;
<blue>}</blue>

<blue>static int kvm_get_msr_feature(struct kvm_msr_entry *msr)</blue>
{
<blue>	switch (msr->index) {</blue>
	case MSR_IA32_ARCH_CAPABILITIES:
<blue>		msr->data = kvm_get_arch_capabilities();</blue>
		break;
	case MSR_IA32_UCODE_REV:
<blue>		rdmsrl_safe(msr->index, &msr->data);</blue>
		break;
	default:
<blue>		return static_call(kvm_x86_get_msr_feature)(msr);</blue>
	}
	return 0;
}

static int do_get_msr_feature(struct kvm_vcpu *vcpu, unsigned index, u64 *data)
<blue>{</blue>
	struct kvm_msr_entry msr;
	int r;

	msr.index = index;
<blue>	r = kvm_get_msr_feature(&msr);</blue>

	if (r == KVM_MSR_RET_INVALID) {
		/* Unconditionally clear the output for simplicity */
<yellow>		*data = 0;</yellow>
		if (kvm_msr_ignored_check(index, 0, false))
			r = 0;
	}

<blue>	if (r)</blue>
		return r;

<blue>	*data = msr.data;</blue>

	return 0;
}

static bool __kvm_valid_efer(struct kvm_vcpu *vcpu, u64 efer)
{
<blue>	if (efer & EFER_FFXSR && !guest_cpuid_has(vcpu, X86_FEATURE_FXSR_OPT))</blue>
		return false;

<blue>	if (efer & EFER_SVME && !guest_cpuid_has(vcpu, X86_FEATURE_SVM))</blue>
		return false;

<blue>	if (efer & (EFER_LME | EFER_LMA) &&</blue>
<blue>	    !guest_cpuid_has(vcpu, X86_FEATURE_LM))</blue>
		return false;

<blue>	if (efer & EFER_NX && !guest_cpuid_has(vcpu, X86_FEATURE_NX))</blue>
		return false;

	return true;

<blue>}</blue>
bool kvm_valid_efer(struct kvm_vcpu *vcpu, u64 efer)
{
<blue>	if (efer & efer_reserved_bits)</blue>
		return false;

<blue>	return __kvm_valid_efer(vcpu, efer);</blue>
<blue>}</blue>
EXPORT_SYMBOL_GPL(kvm_valid_efer);

static int set_efer(struct kvm_vcpu *vcpu, struct msr_data *msr_info)
{
<blue>	u64 old_efer = vcpu->arch.efer;</blue>
	u64 efer = msr_info-&gt;data;
	int r;

	if (efer &amp; efer_reserved_bits)
		return 1;

<blue>	if (!msr_info->host_initiated) {</blue>
<blue>		if (!__kvm_valid_efer(vcpu, efer))</blue>
			return 1;

<blue>		if (is_paging(vcpu) &&</blue>
<yellow>		    (vcpu->arch.efer & EFER_LME) != (efer & EFER_LME))</yellow>
			return 1;
	}

<blue>	efer &= ~EFER_LMA;</blue>
<yellow>	efer |= vcpu->arch.efer & EFER_LMA;</yellow>

	r = static_call(kvm_x86_set_efer)(vcpu, efer);
	if (r) {
<yellow>		WARN_ON(r > 0);</yellow>
		return r;
	}

<blue>	if ((efer ^ old_efer) & KVM_MMU_EFER_ROLE_BITS)</blue>
<blue>		kvm_mmu_reset_context(vcpu);</blue>

	return 0;
}

void kvm_enable_efer_bits(u64 mask)
{
<yellow>       efer_reserved_bits &= ~mask;</yellow>
}
EXPORT_SYMBOL_GPL(kvm_enable_efer_bits);

bool kvm_msr_allowed(struct kvm_vcpu *vcpu, u32 index, u32 type)
{
	struct kvm_x86_msr_filter *msr_filter;
	struct msr_bitmap_range *ranges;
<blue>	struct kvm *kvm = vcpu->kvm;</blue>
	bool allowed;
	int idx;
	u32 i;

	/* x2APIC MSRs do not support filtering. */
<blue>	if (index >= 0x800 && index <= 0x8ff)</blue>
		return true;

	idx = srcu_read_lock(&amp;kvm-&gt;srcu);

	msr_filter = srcu_dereference(kvm-&gt;arch.msr_filter, &amp;kvm-&gt;srcu);
	if (!msr_filter) {
		allowed = true;
		goto out;
	}

<yellow>	allowed = msr_filter->default_allow;</yellow>
	ranges = msr_filter-&gt;ranges;

<yellow>	for (i = 0; i < msr_filter->count; i++) {</yellow>
<yellow>		u32 start = ranges[i].base;</yellow>
<yellow>		u32 end = start + ranges[i].nmsrs;</yellow>
<yellow>		u32 flags = ranges[i].flags;</yellow>
<yellow>		unsigned long *bitmap = ranges[i].bitmap;</yellow>

		if ((index &gt;= start) &amp;&amp; (index &lt; end) &amp;&amp; (flags &amp; type)) {
			allowed = !!test_bit(index - start, bitmap);
			break;
		}
	}

out:
<blue>	srcu_read_unlock(&kvm->srcu, idx);</blue>

	return allowed;
<blue>}</blue>
EXPORT_SYMBOL_GPL(kvm_msr_allowed);

/*
 * Write @data into the MSR specified by @index.  Select MSR specific fault
 * checks are bypassed if @host_initiated is %true.
 * Returns 0 on success, non-0 otherwise.
 * Assumes vcpu_load() was already called.
 */
static int __kvm_set_msr(struct kvm_vcpu *vcpu, u32 index, u64 data,
			 bool host_initiated)
<blue>{</blue>
	struct msr_data msr;

<blue>	switch (index) {</blue>
	case MSR_FS_BASE:
	case MSR_GS_BASE:
	case MSR_KERNEL_GS_BASE:
	case MSR_CSTAR:
	case MSR_LSTAR:
<blue>		if (is_noncanonical_address(data, vcpu))</blue>
			return 1;
		break;
	case MSR_IA32_SYSENTER_EIP:
	case MSR_IA32_SYSENTER_ESP:
		/*
		 * IA32_SYSENTER_ESP and IA32_SYSENTER_EIP cause #GP if
		 * non-canonical address is written on Intel but not on
		 * AMD (which ignores the top 32-bits, because it does
		 * not implement 64-bit SYSENTER).
		 *
		 * 64-bit code should hence be able to write a non-canonical
		 * value on AMD.  Making the address canonical ensures that
		 * vmentry does not fail on Intel after writing a non-canonical
		 * value, and that something deterministic happens if the guest
		 * invokes 64-bit SYSENTER.
		 */
<blue>		data = __canonical_address(data, vcpu_virt_addr_bits(vcpu));</blue>
		break;
	case MSR_TSC_AUX:
<blue>		if (!kvm_is_supported_user_return_msr(MSR_TSC_AUX))</blue>
			return 1;

<blue>		if (!host_initiated &&</blue>
<yellow>		    !guest_cpuid_has(vcpu, X86_FEATURE_RDTSCP) &&</yellow>
<yellow>		    !guest_cpuid_has(vcpu, X86_FEATURE_RDPID))</yellow>
			return 1;

		/*
		 * Per Intel&#x27;s SDM, bits 63:32 are reserved, but AMD&#x27;s APM has
		 * incomplete and conflicting architectural behavior.  Current
		 * AMD CPUs completely ignore bits 63:32, i.e. they aren&#x27;t
		 * reserved and always read as zeros.  Enforce Intel&#x27;s reserved
		 * bits check if and only if the guest CPU is Intel, and clear
		 * the bits in all other cases.  This ensures cross-vendor
		 * migration will provide consistent behavior for the guest.
		 */
<blue>		if (guest_cpuid_is_intel(vcpu) && (data >> 32) != 0)</blue>
			return 1;

<blue>		data = (u32)data;</blue>
		break;
	}

<blue>	msr.data = data;</blue>
	msr.index = index;
	msr.host_initiated = host_initiated;

<blue>	return static_call(kvm_x86_set_msr)(vcpu, &msr);</blue>
}

<yellow>static int kvm_set_msr_ignored_check(struct kvm_vcpu *vcpu,</yellow>
				     u32 index, u64 data, bool host_initiated)
{
<blue>	int ret = __kvm_set_msr(vcpu, index, data, host_initiated);</blue>

	if (ret == KVM_MSR_RET_INVALID)
<yellow>		if (kvm_msr_ignored_check(index, data, true))</yellow>
			ret = 0;

	return ret;
}

/*
 * Read the MSR specified by @index into @data.  Select MSR specific fault
 * checks are bypassed if @host_initiated is %true.
 * Returns 0 on success, non-0 otherwise.
 * Assumes vcpu_load() was already called.
 */
int __kvm_get_msr(struct kvm_vcpu *vcpu, u32 index, u64 *data,
		  bool host_initiated)
<blue>{</blue>
	struct msr_data msr;
	int ret;

<blue>	switch (index) {</blue>
	case MSR_TSC_AUX:
<blue>		if (!kvm_is_supported_user_return_msr(MSR_TSC_AUX))</blue>
			return 1;

<blue>		if (!host_initiated &&</blue>
<yellow>		    !guest_cpuid_has(vcpu, X86_FEATURE_RDTSCP) &&</yellow>
<yellow>		    !guest_cpuid_has(vcpu, X86_FEATURE_RDPID))</yellow>
			return 1;
		break;
	}

<blue>	msr.index = index;</blue>
	msr.host_initiated = host_initiated;

	ret = static_call(kvm_x86_get_msr)(vcpu, &amp;msr);
	if (!ret)
<blue>		*data = msr.data;</blue>
	return ret;
}

<yellow>static int kvm_get_msr_ignored_check(struct kvm_vcpu *vcpu,</yellow>
				     u32 index, u64 *data, bool host_initiated)
{
<blue>	int ret = __kvm_get_msr(vcpu, index, data, host_initiated);</blue>

	if (ret == KVM_MSR_RET_INVALID) {
		/* Unconditionally clear *data for simplicity */
<yellow>		*data = 0;</yellow>
<yellow>		if (kvm_msr_ignored_check(index, 0, false))</yellow>
			ret = 0;
	}

	return ret;
}

<blue>static int kvm_get_msr_with_filter(struct kvm_vcpu *vcpu, u32 index, u64 *data)</blue>
{
	if (!kvm_msr_allowed(vcpu, index, KVM_MSR_FILTER_READ))
		return KVM_MSR_RET_FILTERED;
<blue>	return kvm_get_msr_ignored_check(vcpu, index, data, false);</blue>
}

<blue>static int kvm_set_msr_with_filter(struct kvm_vcpu *vcpu, u32 index, u64 data)</blue>
{
	if (!kvm_msr_allowed(vcpu, index, KVM_MSR_FILTER_WRITE))
		return KVM_MSR_RET_FILTERED;
<blue>	return kvm_set_msr_ignored_check(vcpu, index, data, false);</blue>
}

int kvm_get_msr(struct kvm_vcpu *vcpu, u32 index, u64 *data)
{
<blue>	return kvm_get_msr_ignored_check(vcpu, index, data, false);</blue>
<blue>}</blue>
EXPORT_SYMBOL_GPL(kvm_get_msr);

int kvm_set_msr(struct kvm_vcpu *vcpu, u32 index, u64 data)
{
<blue>	return kvm_set_msr_ignored_check(vcpu, index, data, false);</blue>
<blue>}</blue>
EXPORT_SYMBOL_GPL(kvm_set_msr);

static void complete_userspace_rdmsr(struct kvm_vcpu *vcpu)
{
<yellow>	if (!vcpu->run->msr.error) {</yellow>
<yellow>		kvm_rax_write(vcpu, (u32)vcpu->run->msr.data);</yellow>
		kvm_rdx_write(vcpu, vcpu-&gt;run-&gt;msr.data &gt;&gt; 32);
	}
}

static int complete_emulated_msr_access(struct kvm_vcpu *vcpu)
{
<yellow>	return complete_emulated_insn_gp(vcpu, vcpu->run->msr.error);</yellow>
<yellow>}</yellow>

static int complete_emulated_rdmsr(struct kvm_vcpu *vcpu)
{
<yellow>	complete_userspace_rdmsr(vcpu);</yellow>
<yellow>	return complete_emulated_msr_access(vcpu);</yellow>
<yellow>}</yellow>

static int complete_fast_msr_access(struct kvm_vcpu *vcpu)
{
<yellow>	return static_call(kvm_x86_complete_emulated_msr)(vcpu, vcpu->run->msr.error);</yellow>
}

static int complete_fast_rdmsr(struct kvm_vcpu *vcpu)
{
<yellow>	complete_userspace_rdmsr(vcpu);</yellow>
<yellow>	return complete_fast_msr_access(vcpu);</yellow>
}

static u64 kvm_msr_reason(int r)
{
<yellow>	switch (r) {</yellow>
	case KVM_MSR_RET_INVALID:
		return KVM_MSR_EXIT_REASON_UNKNOWN;
	case KVM_MSR_RET_FILTERED:
		return KVM_MSR_EXIT_REASON_FILTER;
	default:
		return KVM_MSR_EXIT_REASON_INVAL;
	}
}

static int kvm_msr_user_space(struct kvm_vcpu *vcpu, u32 index,
			      u32 exit_reason, u64 data,
			      int (*completion)(struct kvm_vcpu *vcpu),
			      int r)
{
<yellow>	u64 msr_reason = kvm_msr_reason(r);</yellow>

	/* Check if the user wanted to know about this MSR fault */
<yellow>	if (!(vcpu->kvm->arch.user_space_msr_mask & msr_reason))</yellow>
		return 0;

<yellow>	vcpu->run->exit_reason = exit_reason;</yellow>
	vcpu-&gt;run-&gt;msr.error = 0;
	memset(vcpu-&gt;run-&gt;msr.pad, 0, sizeof(vcpu-&gt;run-&gt;msr.pad));
	vcpu-&gt;run-&gt;msr.reason = msr_reason;
	vcpu-&gt;run-&gt;msr.index = index;
	vcpu-&gt;run-&gt;msr.data = data;
	vcpu-&gt;arch.complete_userspace_io = completion;

	return 1;
<yellow>}</yellow>

int kvm_emulate_rdmsr(struct kvm_vcpu *vcpu)
<blue>{</blue>
<blue>	u32 ecx = kvm_rcx_read(vcpu);</blue>
	u64 data;
	int r;

<blue>	r = kvm_get_msr_with_filter(vcpu, ecx, &data);</blue>

<blue>	if (!r) {</blue>
<blue>		trace_kvm_msr_read(ecx, data);</blue>

<blue>		kvm_rax_write(vcpu, data & -1u);</blue>
		kvm_rdx_write(vcpu, (data &gt;&gt; 32) &amp; -1u);
	} else {
		/* MSR read failed? See if we should ask user space */
<yellow>		if (kvm_msr_user_space(vcpu, ecx, KVM_EXIT_X86_RDMSR, 0,</yellow>
				       complete_fast_rdmsr, r))
			return 0;
<yellow>		trace_kvm_msr_read_ex(ecx);</yellow>
	}

<blue>	return static_call(kvm_x86_complete_emulated_msr)(vcpu, r);</blue>
}
EXPORT_SYMBOL_GPL(kvm_emulate_rdmsr);

int kvm_emulate_wrmsr(struct kvm_vcpu *vcpu)
{
<blue>	u32 ecx = kvm_rcx_read(vcpu);</blue>
	u64 data = kvm_read_edx_eax(vcpu);
	int r;

<blue>	r = kvm_set_msr_with_filter(vcpu, ecx, data);</blue>

<blue>	if (!r) {</blue>
<blue>		trace_kvm_msr_write(ecx, data);</blue>
	} else {
		/* MSR write failed? See if we should ask user space */
<yellow>		if (kvm_msr_user_space(vcpu, ecx, KVM_EXIT_X86_WRMSR, data,</yellow>
				       complete_fast_msr_access, r))
			return 0;
		/* Signal all other negative errors to userspace */
<yellow>		if (r < 0)</yellow>
			return r;
<yellow>		trace_kvm_msr_write_ex(ecx, data);</yellow>
	}

<blue>	return static_call(kvm_x86_complete_emulated_msr)(vcpu, r);</blue>
<blue>}</blue>
EXPORT_SYMBOL_GPL(kvm_emulate_wrmsr);

int kvm_emulate_as_nop(struct kvm_vcpu *vcpu)
{
<blue>	return kvm_skip_emulated_instruction(vcpu);</blue>
<yellow>}</yellow>
EXPORT_SYMBOL_GPL(kvm_emulate_as_nop);

int kvm_emulate_invd(struct kvm_vcpu *vcpu)
{
	/* Treat an INVD instruction as a NOP and just skip it. */
	return kvm_emulate_as_nop(vcpu);
}
EXPORT_SYMBOL_GPL(kvm_emulate_invd);

int kvm_handle_invalid_op(struct kvm_vcpu *vcpu)
{
<yellow>	kvm_queue_exception(vcpu, UD_VECTOR);</yellow>
	return 1;
}
EXPORT_SYMBOL_GPL(kvm_handle_invalid_op);


static int kvm_emulate_monitor_mwait(struct kvm_vcpu *vcpu, const char *insn)
{
<blue>	if (!kvm_check_has_quirk(vcpu->kvm, KVM_X86_QUIRK_MWAIT_NEVER_UD_FAULTS) &&</blue>
<yellow>	    !guest_cpuid_has(vcpu, X86_FEATURE_MWAIT))</yellow>
<yellow>		return kvm_handle_invalid_op(vcpu);</yellow>

<blue>	pr_warn_once("kvm: %s instruction emulated as NOP!\n", insn);</blue>
<blue>	return kvm_emulate_as_nop(vcpu);</blue>
<blue>}</blue>
int kvm_emulate_mwait(struct kvm_vcpu *vcpu)
{
<blue>	return kvm_emulate_monitor_mwait(vcpu, "MWAIT");</blue>
}
EXPORT_SYMBOL_GPL(kvm_emulate_mwait);

int kvm_emulate_monitor(struct kvm_vcpu *vcpu)
{
<blue>	return kvm_emulate_monitor_mwait(vcpu, "MONITOR");</blue>
}
EXPORT_SYMBOL_GPL(kvm_emulate_monitor);

static inline bool kvm_vcpu_exit_request(struct kvm_vcpu *vcpu)
{
<blue>	xfer_to_guest_mode_prepare();</blue>
<blue>	return vcpu->mode == EXITING_GUEST_MODE || kvm_request_pending(vcpu) ||</blue>
<blue>		xfer_to_guest_mode_work_pending();</blue>
}

/*
 * The fast path for frequent and performance sensitive wrmsr emulation,
 * i.e. the sending of IPI, sending IPI early in the VM-Exit flow reduces
 * the latency of virtual IPI by avoiding the expensive bits of transitioning
 * from guest to host, e.g. reacquiring KVM&#x27;s SRCU lock. In contrast to the
 * other cases which must be called after interrupts are enabled on the host.
 */
static int handle_fastpath_set_x2apic_icr_irqoff(struct kvm_vcpu *vcpu, u64 data)
{
<yellow>	if (!lapic_in_kernel(vcpu) || !apic_x2apic_mode(vcpu->arch.apic))</yellow>
		return 1;

	if (((data &amp; APIC_SHORT_MASK) == APIC_DEST_NOSHORT) &amp;&amp;
	    ((data &amp; APIC_DEST_MASK) == APIC_DEST_PHYSICAL) &amp;&amp;
	    ((data &amp; APIC_MODE_MASK) == APIC_DM_FIXED) &amp;&amp;
<yellow>	    ((u32)(data >> 32) != X2APIC_BROADCAST))</yellow>
<yellow>		return kvm_x2apic_icr_write(vcpu->arch.apic, data);</yellow>

	return 1;
}

static int handle_fastpath_set_tscdeadline(struct kvm_vcpu *vcpu, u64 data)
{
	if (!kvm_can_use_hv_timer(vcpu))
		return 1;

	kvm_set_lapic_tscdeadline_msr(vcpu, data);
	return 0;
}

fastpath_t handle_fastpath_set_msr_irqoff(struct kvm_vcpu *vcpu)
{
<blue>	u32 msr = kvm_rcx_read(vcpu);</blue>
	u64 data;
	fastpath_t ret = EXIT_FASTPATH_NONE;

	switch (msr) {
	case APIC_BASE_MSR + (APIC_ICR &gt;&gt; 4):
<yellow>		data = kvm_read_edx_eax(vcpu);</yellow>
<yellow>		if (!handle_fastpath_set_x2apic_icr_irqoff(vcpu, data)) {</yellow>
<yellow>			kvm_skip_emulated_instruction(vcpu);</yellow>
			ret = EXIT_FASTPATH_EXIT_HANDLED;
		}
		break;
	case MSR_IA32_TSC_DEADLINE:
<yellow>		data = kvm_read_edx_eax(vcpu);</yellow>
		if (!handle_fastpath_set_tscdeadline(vcpu, data)) {
			kvm_skip_emulated_instruction(vcpu);
			ret = EXIT_FASTPATH_REENTER_GUEST;
		}
		break;
	default:
		break;
	}

	if (ret != EXIT_FASTPATH_NONE)
<yellow>		trace_kvm_msr_write(msr, data);</yellow>

	return ret;
<blue>}</blue>
EXPORT_SYMBOL_GPL(handle_fastpath_set_msr_irqoff);

/*
 * Adapt set_msr() to msr_io()&#x27;s calling convention
 */
static int do_get_msr(struct kvm_vcpu *vcpu, unsigned index, u64 *data)
{
<blue>	return kvm_get_msr_ignored_check(vcpu, index, data, true);</blue>
<blue>}</blue>

static int do_set_msr(struct kvm_vcpu *vcpu, unsigned index, u64 *data)
{
<yellow>	return kvm_set_msr_ignored_check(vcpu, index, *data, true);</yellow>
}

#ifdef CONFIG_X86_64
struct pvclock_clock {
	int vclock_mode;
	u64 cycle_last;
	u64 mask;
	u32 mult;
	u32 shift;
	u64 base_cycles;
	u64 offset;
};

struct pvclock_gtod_data {
	seqcount_t	seq;

	struct pvclock_clock clock; /* extract of a clocksource struct */
	struct pvclock_clock raw_clock; /* extract of a clocksource struct */

	ktime_t		offs_boot;
	u64		wall_time_sec;
};

static struct pvclock_gtod_data pvclock_gtod_data;

static void update_pvclock_gtod(struct timekeeper *tk)
{
	struct pvclock_gtod_data *vdata = &amp;pvclock_gtod_data;

<yellow>	write_seqcount_begin(&vdata->seq);</yellow>

	/* copy pvclock gtod data */
	vdata-&gt;clock.vclock_mode	= tk-&gt;tkr_mono.clock-&gt;vdso_clock_mode;
	vdata-&gt;clock.cycle_last		= tk-&gt;tkr_mono.cycle_last;
	vdata-&gt;clock.mask		= tk-&gt;tkr_mono.mask;
	vdata-&gt;clock.mult		= tk-&gt;tkr_mono.mult;
	vdata-&gt;clock.shift		= tk-&gt;tkr_mono.shift;
	vdata-&gt;clock.base_cycles	= tk-&gt;tkr_mono.xtime_nsec;
	vdata-&gt;clock.offset		= tk-&gt;tkr_mono.base;

	vdata-&gt;raw_clock.vclock_mode	= tk-&gt;tkr_raw.clock-&gt;vdso_clock_mode;
	vdata-&gt;raw_clock.cycle_last	= tk-&gt;tkr_raw.cycle_last;
	vdata-&gt;raw_clock.mask		= tk-&gt;tkr_raw.mask;
	vdata-&gt;raw_clock.mult		= tk-&gt;tkr_raw.mult;
	vdata-&gt;raw_clock.shift		= tk-&gt;tkr_raw.shift;
	vdata-&gt;raw_clock.base_cycles	= tk-&gt;tkr_raw.xtime_nsec;
	vdata-&gt;raw_clock.offset		= tk-&gt;tkr_raw.base;

	vdata-&gt;wall_time_sec            = tk-&gt;xtime_sec;

	vdata-&gt;offs_boot		= tk-&gt;offs_boot;

	write_seqcount_end(&amp;vdata-&gt;seq);
}

static s64 get_kvmclock_base_ns(void)
{
	/* Count up from boot time, but with the frequency of the raw clock.  */
<blue>	return ktime_to_ns(ktime_add(ktime_get_raw(), pvclock_gtod_data.offs_boot));</blue>
}
#else
static s64 get_kvmclock_base_ns(void)
{
	/* Master clock not used, so we can just use CLOCK_BOOTTIME.  */
	return ktime_get_boottime_ns();
}
#endif

<blue>static void kvm_write_wall_clock(struct kvm *kvm, gpa_t wall_clock, int sec_hi_ofs)</blue>
{
	int version;
	int r;
	struct pvclock_wall_clock wc;
	u32 wc_sec_hi;
	u64 wall_nsec;

<blue>	if (!wall_clock)</blue>
		return;

<yellow>	r = kvm_read_guest(kvm, wall_clock, &version, sizeof(version));</yellow>
	if (r)
		return;

<yellow>	if (version & 1)</yellow>
<yellow>		++version;  /* first time write, random junk */</yellow>

<yellow>	++version;</yellow>

	if (kvm_write_guest(kvm, wall_clock, &amp;version, sizeof(version)))
		return;

	/*
	 * The guest calculates current wall clock time by adding
	 * system time (updated by kvm_guest_time_update below) to the
	 * wall clock specified here.  We do the reverse here.
	 */
<yellow>	wall_nsec = ktime_get_real_ns() - get_kvmclock_ns(kvm);</yellow>

	wc.nsec = do_div(wall_nsec, 1000000000);
	wc.sec = (u32)wall_nsec; /* overflow in 2106 guest time */
	wc.version = version;

	kvm_write_guest(kvm, wall_clock, &amp;wc, sizeof(wc));

	if (sec_hi_ofs) {
		wc_sec_hi = wall_nsec &gt;&gt; 32;
		kvm_write_guest(kvm, wall_clock + sec_hi_ofs,
				&amp;wc_sec_hi, sizeof(wc_sec_hi));
	}

	version++;
	kvm_write_guest(kvm, wall_clock, &amp;version, sizeof(version));
}

static void kvm_write_system_time(struct kvm_vcpu *vcpu, gpa_t system_time,
				  bool old_msr, bool host_initiated)
{
<yellow>	struct kvm_arch *ka = &vcpu->kvm->arch;</yellow>

<blue>	if (vcpu->vcpu_id == 0 && !host_initiated) {</blue>
<yellow>		if (ka->boot_vcpu_runs_old_kvmclock != old_msr)</yellow>
<yellow>			kvm_make_request(KVM_REQ_MASTERCLOCK_UPDATE, vcpu);</yellow>

<yellow>		ka->boot_vcpu_runs_old_kvmclock = old_msr;</yellow>
	}

<blue>	vcpu->arch.time = system_time;</blue>
	kvm_make_request(KVM_REQ_GLOBAL_CLOCK_UPDATE, vcpu);

	/* we verify if the enable bit is set... */
	if (system_time &amp; 1) {
<yellow>		kvm_gpc_activate(vcpu->kvm, &vcpu->arch.pv_time, vcpu,</yellow>
				 KVM_HOST_USES_PFN, system_time &amp; ~1ULL,
				 sizeof(struct pvclock_vcpu_time_info));
	} else {
<blue>		kvm_gpc_deactivate(vcpu->kvm, &vcpu->arch.pv_time);</blue>
	}

	return;
<blue>}</blue>

static uint32_t div_frac(uint32_t dividend, uint32_t divisor)
{
<yellow>	do_shl32_div32(dividend, divisor);</yellow>
	return dividend;
}

static void kvm_get_time_scale(uint64_t scaled_hz, uint64_t base_hz,
			       s8 *pshift, u32 *pmultiplier)
{
	uint64_t scaled64;
	int32_t  shift = 0;
	uint64_t tps64;
	uint32_t tps32;

	tps64 = base_hz;
	scaled64 = scaled_hz;
<blue>	while (tps64 > scaled64*2 || tps64 & 0xffffffff00000000ULL) {</blue>
<blue>		tps64 >>= 1;</blue>
		shift--;
	}

<yellow>	tps32 = (uint32_t)tps64;</yellow>
<blue>	while (tps32 <= scaled64 || scaled64 & 0xffffffff00000000ULL) {</blue>
<blue>		if (scaled64 & 0xffffffff00000000ULL || tps32 & 0x80000000)</blue>
<yellow>			scaled64 >>= 1;</yellow>
		else
<blue>			tps32 <<= 1;</blue>
		shift++;
	}

<blue>	*pshift = shift;</blue>
<yellow>	*pmultiplier = div_frac(scaled64, tps32);</yellow>
}

#ifdef CONFIG_X86_64
static atomic_t kvm_guest_has_master_clock = ATOMIC_INIT(0);
#endif

static DEFINE_PER_CPU(unsigned long, cpu_tsc_khz);
static unsigned long max_tsc_khz;

static u32 adjust_tsc_khz(u32 khz, s32 ppm)
{
	u64 v = (u64)khz * (1000000 + ppm);
	do_div(v, 1000000);
	return v;
}

static void kvm_vcpu_write_tsc_multiplier(struct kvm_vcpu *vcpu, u64 l1_multiplier);

static int set_tsc_khz(struct kvm_vcpu *vcpu, u32 user_tsc_khz, bool scale)
{
	u64 ratio;

	/* Guest TSC same frequency as host TSC? */
	if (!scale) {
<blue>		kvm_vcpu_write_tsc_multiplier(vcpu, kvm_caps.default_tsc_scaling_ratio);</blue>
		return 0;
	}

	/* TSC scaling supported? */
<yellow>	if (!kvm_caps.has_tsc_control) {</yellow>
<yellow>		if (user_tsc_khz > tsc_khz) {</yellow>
<yellow>			vcpu->arch.tsc_catchup = 1;</yellow>
			vcpu-&gt;arch.tsc_always_catchup = 1;
			return 0;
		} else {
<yellow>			pr_warn_ratelimited("user requested TSC rate below hardware speed\n");</yellow>
			return -1;
		}
	}

	/* TSC scaling required  - calculate ratio */
<yellow>	ratio = mul_u64_u32_div(1ULL << kvm_caps.tsc_scaling_ratio_frac_bits,</yellow>
				user_tsc_khz, tsc_khz);

<yellow>	if (ratio == 0 || ratio >= kvm_caps.max_tsc_scaling_ratio) {</yellow>
<yellow>		pr_warn_ratelimited("Invalid TSC scaling ratio - virtual-tsc-khz=%u\n",</yellow>
			            user_tsc_khz);
		return -1;
	}

<yellow>	kvm_vcpu_write_tsc_multiplier(vcpu, ratio);</yellow>
	return 0;
}

static int kvm_set_tsc_khz(struct kvm_vcpu *vcpu, u32 user_tsc_khz)
{
	u32 thresh_lo, thresh_hi;
	int use_scaling = 0;

	/* tsc_khz can be zero if TSC calibration fails */
<blue>	if (user_tsc_khz == 0) {</blue>
		/* set tsc_scaling_ratio to a safe value */
<yellow>		kvm_vcpu_write_tsc_multiplier(vcpu, kvm_caps.default_tsc_scaling_ratio);</yellow>
		return -1;
	}

	/* Compute a scale to convert nanoseconds in TSC cycles */
<blue>	kvm_get_time_scale(user_tsc_khz * 1000LL, NSEC_PER_SEC,</blue>
			   &amp;vcpu-&gt;arch.virtual_tsc_shift,
			   &amp;vcpu-&gt;arch.virtual_tsc_mult);
	vcpu-&gt;arch.virtual_tsc_khz = user_tsc_khz;

	/*
	 * Compute the variation in TSC rate which is acceptable
	 * within the range of tolerance and decide if the
	 * rate being applied is within that bounds of the hardware
	 * rate.  If so, no scaling or compensation need be done.
	 */
	thresh_lo = adjust_tsc_khz(tsc_khz, -tsc_tolerance_ppm);
	thresh_hi = adjust_tsc_khz(tsc_khz, tsc_tolerance_ppm);
<blue>	if (user_tsc_khz < thresh_lo || user_tsc_khz > thresh_hi) {</blue>
<yellow>		pr_debug("kvm: requested TSC rate %u falls outside tolerance [%u,%u]\n", user_tsc_khz, thresh_lo, thresh_hi);</yellow>
		use_scaling = 1;
	}
<blue>	return set_tsc_khz(vcpu, user_tsc_khz, use_scaling);</blue>
<blue>}</blue>

static u64 compute_guest_tsc(struct kvm_vcpu *vcpu, s64 kernel_ns)
{
<yellow>	u64 tsc = pvclock_scale_delta(kernel_ns-vcpu->arch.this_tsc_nsec,</yellow>
				      vcpu-&gt;arch.virtual_tsc_mult,
<yellow>				      vcpu->arch.virtual_tsc_shift);</yellow>
<yellow>	tsc += vcpu->arch.this_tsc_write;</yellow>
	return tsc;
}

#ifdef CONFIG_X86_64
static inline int gtod_is_based_on_tsc(int mode)
{
<yellow>	return mode == VDSO_CLOCKMODE_TSC || mode == VDSO_CLOCKMODE_HVCLOCK;</yellow>
}
#endif

static void kvm_track_tsc_matching(struct kvm_vcpu *vcpu)
{
#ifdef CONFIG_X86_64
	bool vcpus_matched;
	struct kvm_arch *ka = &amp;vcpu-&gt;kvm-&gt;arch;
	struct pvclock_gtod_data *gtod = &amp;pvclock_gtod_data;

<blue>	vcpus_matched = (ka->nr_vcpus_matched_tsc + 1 ==</blue>
			 atomic_read(&amp;vcpu-&gt;kvm-&gt;online_vcpus));

	/*
	 * Once the masterclock is enabled, always perform request in
	 * order to update it.
	 *
	 * In order to enable masterclock, the host clocksource must be TSC
	 * and the vcpus need to have matched TSCs.  When that happens,
	 * perform request to enable masterclock.
	 */
<blue>	if (ka->use_master_clock ||</blue>
<blue>	    (gtod_is_based_on_tsc(gtod->clock.vclock_mode) && vcpus_matched))</blue>
<blue>		kvm_make_request(KVM_REQ_MASTERCLOCK_UPDATE, vcpu);</blue>

<yellow>	trace_kvm_track_tsc(vcpu->vcpu_id, ka->nr_vcpus_matched_tsc,</yellow>
<blue>			    atomic_read(&vcpu->kvm->online_vcpus),</blue>
<blue>		            ka->use_master_clock, gtod->clock.vclock_mode);</blue>
#endif
}

/*
 * Multiply tsc by a fixed point number represented by ratio.
 *
 * The most significant 64-N bits (mult) of ratio represent the
 * integral part of the fixed point number; the remaining N bits
 * (frac) represent the fractional part, ie. ratio represents a fixed
 * point number (mult + frac * 2^(-N)).
 *
 * N equals to kvm_caps.tsc_scaling_ratio_frac_bits.
 */
static inline u64 __scale_tsc(u64 ratio, u64 tsc)
{
<yellow>	return mul_u64_u64_shr(tsc, ratio, kvm_caps.tsc_scaling_ratio_frac_bits);</yellow>
}

<yellow>u64 kvm_scale_tsc(u64 tsc, u64 ratio)</yellow>
{
	u64 _tsc = tsc;

<yellow>	if (ratio != kvm_caps.default_tsc_scaling_ratio)</yellow>
<yellow>		_tsc = __scale_tsc(ratio, tsc);</yellow>

	return _tsc;
<yellow>}</yellow>
EXPORT_SYMBOL_GPL(kvm_scale_tsc);

static u64 kvm_compute_l1_tsc_offset(struct kvm_vcpu *vcpu, u64 target_tsc)
{
	u64 tsc;

<blue>	tsc = kvm_scale_tsc(rdtsc(), vcpu->arch.l1_tsc_scaling_ratio);</blue>

<blue>	return target_tsc - tsc;</blue>
}

u64 kvm_read_l1_tsc(struct kvm_vcpu *vcpu, u64 host_tsc)
{
<blue>	return vcpu->arch.l1_tsc_offset +</blue>
<yellow>		kvm_scale_tsc(host_tsc, vcpu->arch.l1_tsc_scaling_ratio);</yellow>
}
EXPORT_SYMBOL_GPL(kvm_read_l1_tsc);

u64 kvm_calc_nested_tsc_offset(u64 l1_offset, u64 l2_offset, u64 l2_multiplier)
{
	u64 nested_offset;

<blue>	if (l2_multiplier == kvm_caps.default_tsc_scaling_ratio)</blue>
		nested_offset = l1_offset;
	else
<blue>		nested_offset = mul_s64_u64_shr((s64) l1_offset, l2_multiplier,</blue>
						kvm_caps.tsc_scaling_ratio_frac_bits);

<blue>	nested_offset += l2_offset;</blue>
	return nested_offset;
}
EXPORT_SYMBOL_GPL(kvm_calc_nested_tsc_offset);

<blue>u64 kvm_calc_nested_tsc_multiplier(u64 l1_multiplier, u64 l2_multiplier)</blue>
{
<blue>	if (l2_multiplier != kvm_caps.default_tsc_scaling_ratio)</blue>
<blue>		return mul_u64_u64_shr(l1_multiplier, l2_multiplier,</blue>
				       kvm_caps.tsc_scaling_ratio_frac_bits);

	return l1_multiplier;
<blue>}</blue>
EXPORT_SYMBOL_GPL(kvm_calc_nested_tsc_multiplier);

static void kvm_vcpu_write_tsc_offset(struct kvm_vcpu *vcpu, u64 l1_offset)
{
<blue>	trace_kvm_write_tsc_offset(vcpu->vcpu_id,</blue>
				   vcpu-&gt;arch.l1_tsc_offset,
				   l1_offset);

<blue>	vcpu->arch.l1_tsc_offset = l1_offset;</blue>

	/*
	 * If we are here because L1 chose not to trap WRMSR to TSC then
	 * according to the spec this should set L1&#x27;s TSC (as opposed to
	 * setting L1&#x27;s offset for L2).
	 */
	if (is_guest_mode(vcpu))
<blue>		vcpu->arch.tsc_offset = kvm_calc_nested_tsc_offset(</blue>
			l1_offset,
			static_call(kvm_x86_get_l2_tsc_offset)(vcpu),
			static_call(kvm_x86_get_l2_tsc_multiplier)(vcpu));
	else
		vcpu-&gt;arch.tsc_offset = l1_offset;

	static_call(kvm_x86_write_tsc_offset)(vcpu, vcpu-&gt;arch.tsc_offset);
}

static void kvm_vcpu_write_tsc_multiplier(struct kvm_vcpu *vcpu, u64 l1_multiplier)
{
<blue>	vcpu->arch.l1_tsc_scaling_ratio = l1_multiplier;</blue>

	/* Userspace is changing the multiplier while L2 is active */
	if (is_guest_mode(vcpu))
<blue>		vcpu->arch.tsc_scaling_ratio = kvm_calc_nested_tsc_multiplier(</blue>
			l1_multiplier,
			static_call(kvm_x86_get_l2_tsc_multiplier)(vcpu));
	else
		vcpu-&gt;arch.tsc_scaling_ratio = l1_multiplier;

<blue>	if (kvm_caps.has_tsc_control)</blue>
<blue>		static_call(kvm_x86_write_tsc_multiplier)(</blue>
			vcpu, vcpu-&gt;arch.tsc_scaling_ratio);
<blue>}</blue>

<blue>static inline bool kvm_check_tsc_unstable(void)</blue>
{
#ifdef CONFIG_X86_64
	/*
	 * TSC is marked unstable when we&#x27;re running on Hyper-V,
	 * &#x27;TSC page&#x27; clocksource is good.
	 */
<blue>	if (pvclock_gtod_data.clock.vclock_mode == VDSO_CLOCKMODE_HVCLOCK)</blue>
		return false;
#endif
<blue>	return check_tsc_unstable();</blue>
}

/*
 * Infers attempts to synchronize the guest&#x27;s tsc from host writes. Sets the
 * offset for the vcpu and tracks the TSC matching generation that the vcpu
 * participates in.
 */
static void __kvm_synchronize_tsc(struct kvm_vcpu *vcpu, u64 offset, u64 tsc,
				  u64 ns, bool matched)
{
<blue>	struct kvm *kvm = vcpu->kvm;</blue>

	lockdep_assert_held(&amp;kvm-&gt;arch.tsc_write_lock);

	/*
	 * We also track th most recent recorded KHZ, write and time to
	 * allow the matching interval to be extended at each write.
	 */
	kvm-&gt;arch.last_tsc_nsec = ns;
	kvm-&gt;arch.last_tsc_write = tsc;
	kvm-&gt;arch.last_tsc_khz = vcpu-&gt;arch.virtual_tsc_khz;
	kvm-&gt;arch.last_tsc_offset = offset;

	vcpu-&gt;arch.last_guest_tsc = tsc;

	kvm_vcpu_write_tsc_offset(vcpu, offset);

	if (!matched) {
		/*
		 * We split periods of matched TSC writes into generations.
		 * For each generation, we track the original measured
		 * nanosecond time, offset, and write, so if TSCs are in
		 * sync, we can match exact offset, and if not, we can match
		 * exact software computation in compute_guest_tsc()
		 *
		 * These values are tracked in kvm-&gt;arch.cur_xxx variables.
		 */
<blue>		kvm->arch.cur_tsc_generation++;</blue>
		kvm-&gt;arch.cur_tsc_nsec = ns;
		kvm-&gt;arch.cur_tsc_write = tsc;
		kvm-&gt;arch.cur_tsc_offset = offset;
		kvm-&gt;arch.nr_vcpus_matched_tsc = 0;
<blue>	} else if (vcpu->arch.this_tsc_generation != kvm->arch.cur_tsc_generation) {</blue>
<yellow>		kvm->arch.nr_vcpus_matched_tsc++;</yellow>
	}

	/* Keep track of which generation this VCPU has synchronized to */
<blue>	vcpu->arch.this_tsc_generation = kvm->arch.cur_tsc_generation;</blue>
	vcpu-&gt;arch.this_tsc_nsec = kvm-&gt;arch.cur_tsc_nsec;
	vcpu-&gt;arch.this_tsc_write = kvm-&gt;arch.cur_tsc_write;

<blue>	kvm_track_tsc_matching(vcpu);</blue>
<blue>}</blue>

static void kvm_synchronize_tsc(struct kvm_vcpu *vcpu, u64 data)
{
<blue>	struct kvm *kvm = vcpu->kvm;</blue>
	u64 offset, ns, elapsed;
	unsigned long flags;
	bool matched = false;
	bool synchronizing = false;

	raw_spin_lock_irqsave(&amp;kvm-&gt;arch.tsc_write_lock, flags);
	offset = kvm_compute_l1_tsc_offset(vcpu, data);
	ns = get_kvmclock_base_ns();
<blue>	elapsed = ns - kvm->arch.last_tsc_nsec;</blue>

	if (vcpu-&gt;arch.virtual_tsc_khz) {
		if (data == 0) {
			/*
			 * detection of vcpu initialization -- need to sync
			 * with other vCPUs. This particularly helps to keep
			 * kvm_clock stable after CPU hotplug
			 */
			synchronizing = true;
		} else {
<blue>			u64 tsc_exp = kvm->arch.last_tsc_write +</blue>
<blue>						nsec_to_cycles(vcpu, elapsed);</blue>
			u64 tsc_hz = vcpu-&gt;arch.virtual_tsc_khz * 1000LL;
			/*
			 * Special case: TSC write with a small delta (1 second)
			 * of virtual cycle time against real time is
			 * interpreted as an attempt to synchronize the CPU.
			 */
			synchronizing = data &lt; tsc_exp + tsc_hz &amp;&amp;
<blue>					data + tsc_hz > tsc_exp;</blue>
		}
	}

	/*
	 * For a reliable TSC, we can match TSC offsets, and for an unstable
	 * TSC, we add elapsed time in this computation.  We could let the
	 * compensation code attempt to catch up if we fall behind, but
	 * it&#x27;s better to try to match offsets from the beginning.
         */
	if (synchronizing &amp;&amp;
<blue>	    vcpu->arch.virtual_tsc_khz == kvm->arch.last_tsc_khz) {</blue>
<blue>		if (!kvm_check_tsc_unstable()) {</blue>
<blue>			offset = kvm->arch.cur_tsc_offset;</blue>
		} else {
<yellow>			u64 delta = nsec_to_cycles(vcpu, elapsed);</yellow>
			data += delta;
			offset = kvm_compute_l1_tsc_offset(vcpu, data);
		}
		matched = true;
	}

<blue>	__kvm_synchronize_tsc(vcpu, offset, data, ns, matched);</blue>
	raw_spin_unlock_irqrestore(&amp;kvm-&gt;arch.tsc_write_lock, flags);
}

static inline void adjust_tsc_offset_guest(struct kvm_vcpu *vcpu,
					   s64 adjustment)
{
<yellow>	u64 tsc_offset = vcpu->arch.l1_tsc_offset;</yellow>
	kvm_vcpu_write_tsc_offset(vcpu, tsc_offset + adjustment);
}

static inline void adjust_tsc_offset_host(struct kvm_vcpu *vcpu, s64 adjustment)
{
<yellow>	if (vcpu->arch.l1_tsc_scaling_ratio != kvm_caps.default_tsc_scaling_ratio)</yellow>
<yellow>		WARN_ON(adjustment < 0);</yellow>
<yellow>	adjustment = kvm_scale_tsc((u64) adjustment,</yellow>
				   vcpu-&gt;arch.l1_tsc_scaling_ratio);
<yellow>	adjust_tsc_offset_guest(vcpu, adjustment);</yellow>
}

#ifdef CONFIG_X86_64

static u64 read_tsc(void)
{
	u64 ret = (u64)rdtsc_ordered();
	u64 last = pvclock_gtod_data.clock.cycle_last;

	if (likely(ret &gt;= last))
		return ret;

	/*
	 * GCC likes to generate cmov here, but this branch is extremely
	 * predictable (it&#x27;s just a function of time and the likely is
	 * very likely) and there&#x27;s a data dependence, so force GCC
	 * to generate a branch instead.  I don&#x27;t barrier() because
	 * we don&#x27;t actually need a barrier, and if this function
	 * ever gets inlined it will generate worse code.
	 */
	asm volatile (&quot;&quot;);
<yellow>	return last;</yellow>
}

static inline u64 vgettsc(struct pvclock_clock *clock, u64 *tsc_timestamp,
			  int *mode)
{
	long v;
	u64 tsc_pg_val;

<blue>	switch (clock->vclock_mode) {</blue>
	case VDSO_CLOCKMODE_HVCLOCK:
<yellow>		tsc_pg_val = hv_read_tsc_page_tsc(hv_get_tsc_page(),</yellow>
						  tsc_timestamp);
		if (tsc_pg_val != U64_MAX) {
			/* TSC page valid */
<yellow>			*mode = VDSO_CLOCKMODE_HVCLOCK;</yellow>
			v = (tsc_pg_val - clock-&gt;cycle_last) &amp;
				clock-&gt;mask;
		} else {
			/* TSC page invalid */
<yellow>			*mode = VDSO_CLOCKMODE_NONE;</yellow>
		}
		break;
	case VDSO_CLOCKMODE_TSC:
<blue>		*mode = VDSO_CLOCKMODE_TSC;</blue>
<blue>		*tsc_timestamp = read_tsc();</blue>
		v = (*tsc_timestamp - clock-&gt;cycle_last) &amp;
			clock-&gt;mask;
		break;
	default:
<yellow>		*mode = VDSO_CLOCKMODE_NONE;</yellow>
	}

	if (*mode == VDSO_CLOCKMODE_NONE)
<yellow>		*tsc_timestamp = v = 0;</yellow>

<blue>	return v * clock->mult;</blue>
}

static int do_monotonic_raw(s64 *t, u64 *tsc_timestamp)
{
	struct pvclock_gtod_data *gtod = &amp;pvclock_gtod_data;
	unsigned long seq;
	int mode;
	u64 ns;

	do {
<blue>		seq = read_seqcount_begin(&gtod->seq);</blue>
		ns = gtod-&gt;raw_clock.base_cycles;
<blue>		ns += vgettsc(&gtod->raw_clock, tsc_timestamp, &mode);</blue>
<blue>		ns >>= gtod->raw_clock.shift;</blue>
<blue>		ns += ktime_to_ns(ktime_add(gtod->raw_clock.offset, gtod->offs_boot));</blue>
	} while (unlikely(read_seqcount_retry(&amp;gtod-&gt;seq, seq)));
	*t = ns;

	return mode;
}

static int do_realtime(struct timespec64 *ts, u64 *tsc_timestamp)
{
	struct pvclock_gtod_data *gtod = &amp;pvclock_gtod_data;
	unsigned long seq;
	int mode;
	u64 ns;

	do {
<yellow>		seq = read_seqcount_begin(&gtod->seq);</yellow>
<yellow>		ts->tv_sec = gtod->wall_time_sec;</yellow>
		ns = gtod-&gt;clock.base_cycles;
		ns += vgettsc(&amp;gtod-&gt;clock, tsc_timestamp, &amp;mode);
<yellow>		ns >>= gtod->clock.shift;</yellow>
<yellow>	} while (unlikely(read_seqcount_retry(&gtod->seq, seq)));</yellow>

<yellow>	ts->tv_sec += __iter_div_u64_rem(ns, NSEC_PER_SEC, &ns);</yellow>
	ts-&gt;tv_nsec = ns;

	return mode;
}

/* returns true if host is using TSC based clocksource */
static bool kvm_get_time_and_clockread(s64 *kernel_ns, u64 *tsc_timestamp)
{
	/* checked again under seqlock below */
	if (!gtod_is_based_on_tsc(pvclock_gtod_data.clock.vclock_mode))
		return false;

<blue>	return gtod_is_based_on_tsc(do_monotonic_raw(kernel_ns,</blue>
						      tsc_timestamp));
}

/* returns true if host is using TSC based clocksource */
<yellow>static bool kvm_get_walltime_and_clockread(struct timespec64 *ts,</yellow>
					   u64 *tsc_timestamp)
{
	/* checked again under seqlock below */
<yellow>	if (!gtod_is_based_on_tsc(pvclock_gtod_data.clock.vclock_mode))</yellow>
		return false;

<yellow>	return gtod_is_based_on_tsc(do_realtime(ts, tsc_timestamp));</yellow>
}
#endif

/*
 *
 * Assuming a stable TSC across physical CPUS, and a stable TSC
 * across virtual CPUs, the following condition is possible.
 * Each numbered line represents an event visible to both
 * CPUs at the next numbered event.
 *
 * &quot;timespecX&quot; represents host monotonic time. &quot;tscX&quot; represents
 * RDTSC value.
 *
 * 		VCPU0 on CPU0		|	VCPU1 on CPU1
 *
 * 1.  read timespec0,tsc0
 * 2.					| timespec1 = timespec0 + N
 * 					| tsc1 = tsc0 + M
 * 3. transition to guest		| transition to guest
 * 4. ret0 = timespec0 + (rdtsc - tsc0) |
 * 5.				        | ret1 = timespec1 + (rdtsc - tsc1)
 * 				        | ret1 = timespec0 + N + (rdtsc - (tsc0 + M))
 *
 * Since ret0 update is visible to VCPU1 at time 5, to obey monotonicity:
 *
 * 	- ret0 &lt; ret1
 *	- timespec0 + (rdtsc - tsc0) &lt; timespec0 + N + (rdtsc - (tsc0 + M))
 *		...
 *	- 0 &lt; N - M =&gt; M &lt; N
 *
 * That is, when timespec0 != timespec1, M &lt; N. Unfortunately that is not
 * always the case (the difference between two distinct xtime instances
 * might be smaller then the difference between corresponding TSC reads,
 * when updating guest vcpus pvclock areas).
 *
 * To avoid that problem, do not allow visibility of distinct
 * system_timestamp/tsc_timestamp values simultaneously: use a master
 * copy of host monotonic time values. Update that master copy
 * in lockstep.
 *
 * Rely on synchronization of host TSCs and guest TSCs for monotonicity.
 *
 */

static void pvclock_update_vm_gtod_copy(struct kvm *kvm)
<blue>{</blue>
#ifdef CONFIG_X86_64
	struct kvm_arch *ka = &amp;kvm-&gt;arch;
	int vclock_mode;
	bool host_tsc_clocksource, vcpus_matched;

	lockdep_assert_held(&amp;kvm-&gt;arch.tsc_write_lock);
<blue>	vcpus_matched = (ka->nr_vcpus_matched_tsc + 1 ==</blue>
			atomic_read(&amp;kvm-&gt;online_vcpus));

	/*
	 * If the host uses TSC clock, then passthrough TSC as stable
	 * to the guest.
	 */
<blue>	host_tsc_clocksource = kvm_get_time_and_clockread(</blue>
					&amp;ka-&gt;master_kernel_ns,
					&amp;ka-&gt;master_cycle_now);

<blue>	ka->use_master_clock = host_tsc_clocksource && vcpus_matched</blue>
<blue>				&& !ka->backwards_tsc_observed</blue>
<blue>				&& !ka->boot_vcpu_runs_old_kvmclock;</blue>

	if (ka-&gt;use_master_clock)
<blue>		atomic_set(&kvm_guest_has_master_clock, 1);</blue>

<blue>	vclock_mode = pvclock_gtod_data.clock.vclock_mode;</blue>
<blue>	trace_kvm_update_master_clock(ka->use_master_clock, vclock_mode,</blue>
					vcpus_matched);
#endif
}

static void kvm_make_mclock_inprogress_request(struct kvm *kvm)
{
<yellow>	kvm_make_all_cpus_request(kvm, KVM_REQ_MCLOCK_INPROGRESS);</yellow>
}

static void __kvm_start_pvclock_update(struct kvm *kvm)
{
<yellow>	raw_spin_lock_irq(&kvm->arch.tsc_write_lock);</yellow>
	write_seqcount_begin(&amp;kvm-&gt;arch.pvclock_sc);
}

static void kvm_start_pvclock_update(struct kvm *kvm)
{
	kvm_make_mclock_inprogress_request(kvm);

	/* no guest entries from this point */
	__kvm_start_pvclock_update(kvm);
}

static void kvm_end_pvclock_update(struct kvm *kvm)
<blue>{</blue>
	struct kvm_arch *ka = &amp;kvm-&gt;arch;
	struct kvm_vcpu *vcpu;
	unsigned long i;

<blue>	write_seqcount_end(&ka->pvclock_sc);</blue>
	raw_spin_unlock_irq(&amp;ka-&gt;tsc_write_lock);
	kvm_for_each_vcpu(i, vcpu, kvm)
<blue>		kvm_make_request(KVM_REQ_CLOCK_UPDATE, vcpu);</blue>

	/* guest entries allowed */
<blue>	kvm_for_each_vcpu(i, vcpu, kvm)</blue>
<blue>		kvm_clear_request(KVM_REQ_MCLOCK_INPROGRESS, vcpu);</blue>
}

static void kvm_update_masterclock(struct kvm *kvm)
{
	kvm_hv_request_tsc_page_update(kvm);
	kvm_start_pvclock_update(kvm);
	pvclock_update_vm_gtod_copy(kvm);
	kvm_end_pvclock_update(kvm);
}

/* Called within read_seqcount_begin/retry for kvm-&gt;pvclock_sc.  */
static void __get_kvmclock(struct kvm *kvm, struct kvm_clock_data *data)
<blue>{</blue>
	struct kvm_arch *ka = &amp;kvm-&gt;arch;
	struct pvclock_vcpu_time_info hv_clock;

	/* both __this_cpu_read() and rdtsc() should be on the same cpu */
<blue>	get_cpu();</blue>

	data-&gt;flags = 0;
<blue>	if (ka->use_master_clock && __this_cpu_read(cpu_tsc_khz)) {</blue>
#ifdef CONFIG_X86_64
		struct timespec64 ts;

<yellow>		if (kvm_get_walltime_and_clockread(&ts, &data->host_tsc)) {</yellow>
<yellow>			data->realtime = ts.tv_nsec + NSEC_PER_SEC * ts.tv_sec;</yellow>
			data-&gt;flags |= KVM_CLOCK_REALTIME | KVM_CLOCK_HOST_TSC;
		} else
#endif
<yellow>		data->host_tsc = rdtsc();</yellow>

<yellow>		data->flags |= KVM_CLOCK_TSC_STABLE;</yellow>
		hv_clock.tsc_timestamp = ka-&gt;master_cycle_now;
		hv_clock.system_time = ka-&gt;master_kernel_ns + ka-&gt;kvmclock_offset;
<yellow>		kvm_get_time_scale(NSEC_PER_SEC, __this_cpu_read(cpu_tsc_khz) * 1000LL,</yellow>
				   &amp;hv_clock.tsc_shift,
				   &amp;hv_clock.tsc_to_system_mul);
<yellow>		data->clock = __pvclock_read_cycles(&hv_clock, data->host_tsc);</yellow>
	} else {
<blue>		data->clock = get_kvmclock_base_ns() + ka->kvmclock_offset;</blue>
	}

<blue>	put_cpu();</blue>
}

static void get_kvmclock(struct kvm *kvm, struct kvm_clock_data *data)
{
	struct kvm_arch *ka = &amp;kvm-&gt;arch;
	unsigned seq;

	do {
<blue>		seq = read_seqcount_begin(&ka->pvclock_sc);</blue>
<blue>		__get_kvmclock(kvm, data);</blue>
	} while (read_seqcount_retry(&amp;ka-&gt;pvclock_sc, seq));
}

u64 get_kvmclock_ns(struct kvm *kvm)
{
	struct kvm_clock_data data;

<yellow>	get_kvmclock(kvm, &data);</yellow>
<yellow>	return data.clock;</yellow>
}

static void kvm_setup_guest_pvclock(struct kvm_vcpu *v,
				    struct gfn_to_pfn_cache *gpc,
				    unsigned int offset)
{
	struct kvm_vcpu_arch *vcpu = &amp;v-&gt;arch;
	struct pvclock_vcpu_time_info *guest_hv_clock;
	unsigned long flags;

<yellow>	read_lock_irqsave(&gpc->lock, flags);</yellow>
<yellow>	while (!kvm_gfn_to_pfn_cache_check(v->kvm, gpc, gpc->gpa,</yellow>
					   offset + sizeof(*guest_hv_clock))) {
<yellow>		read_unlock_irqrestore(&gpc->lock, flags);</yellow>

		if (kvm_gfn_to_pfn_cache_refresh(v-&gt;kvm, gpc, gpc-&gt;gpa,
						 offset + sizeof(*guest_hv_clock)))
			return;

<yellow>		read_lock_irqsave(&gpc->lock, flags);</yellow>
	}

<yellow>	guest_hv_clock = (void *)(gpc->khva + offset);</yellow>

	/*
	 * This VCPU is paused, but it&#x27;s legal for a guest to read another
	 * VCPU&#x27;s kvmclock, so we really have to follow the specification where
	 * it says that version is odd if data is being modified, and even after
	 * it is consistent.
	 */

	guest_hv_clock-&gt;version = vcpu-&gt;hv_clock.version = (guest_hv_clock-&gt;version + 1) | 1;
	smp_wmb();

	/* retain PVCLOCK_GUEST_STOPPED if set in guest copy */
	vcpu-&gt;hv_clock.flags |= (guest_hv_clock-&gt;flags &amp; PVCLOCK_GUEST_STOPPED);

<yellow>	if (vcpu->pvclock_set_guest_stopped_request) {</yellow>
<yellow>		vcpu->hv_clock.flags |= PVCLOCK_GUEST_STOPPED;</yellow>
		vcpu-&gt;pvclock_set_guest_stopped_request = false;
	}

<yellow>	memcpy(guest_hv_clock, &vcpu->hv_clock, sizeof(*guest_hv_clock));</yellow>
	smp_wmb();

	guest_hv_clock-&gt;version = ++vcpu-&gt;hv_clock.version;

	mark_page_dirty_in_slot(v-&gt;kvm, gpc-&gt;memslot, gpc-&gt;gpa &gt;&gt; PAGE_SHIFT);
	read_unlock_irqrestore(&amp;gpc-&gt;lock, flags);

<yellow>	trace_kvm_pvclock_update(v->vcpu_id, &vcpu->hv_clock);</yellow>
<yellow>}</yellow>

static int kvm_guest_time_update(struct kvm_vcpu *v)
{
	unsigned long flags, tgt_tsc_khz;
	unsigned seq;
	struct kvm_vcpu_arch *vcpu = &amp;v-&gt;arch;
<blue>	struct kvm_arch *ka = &v->kvm->arch;</blue>
	s64 kernel_ns;
	u64 tsc_timestamp, host_tsc;
	u8 pvclock_flags;
	bool use_master_clock;

	kernel_ns = 0;
	host_tsc = 0;

	/*
	 * If the host uses TSC clock, then passthrough TSC as stable
	 * to the guest.
	 */
	do {
<blue>		seq = read_seqcount_begin(&ka->pvclock_sc);</blue>
<blue>		use_master_clock = ka->use_master_clock;</blue>
		if (use_master_clock) {
<blue>			host_tsc = ka->master_cycle_now;</blue>
			kernel_ns = ka-&gt;master_kernel_ns;
		}
<blue>	} while (read_seqcount_retry(&ka->pvclock_sc, seq));</blue>

	/* Keep irq disabled to prevent changes to the clock */
<blue>	local_irq_save(flags);</blue>
	tgt_tsc_khz = __this_cpu_read(cpu_tsc_khz);
	if (unlikely(tgt_tsc_khz == 0)) {
<yellow>		local_irq_restore(flags);</yellow>
<yellow>		kvm_make_request(KVM_REQ_CLOCK_UPDATE, v);</yellow>
		return 1;
	}
<blue>	if (!use_master_clock) {</blue>
<yellow>		host_tsc = rdtsc();</yellow>
		kernel_ns = get_kvmclock_base_ns();
	}

<blue>	tsc_timestamp = kvm_read_l1_tsc(v, host_tsc);</blue>

	/*
	 * We may have to catch up the TSC to match elapsed wall clock
	 * time for two reasons, even if kvmclock is used.
	 *   1) CPU could have been running below the maximum TSC rate
	 *   2) Broken TSC compensation resets the base at each VCPU
	 *      entry to avoid unknown leaps of TSC even when running
	 *      again on the same CPU.  This may cause apparent elapsed
	 *      time to disappear, and the guest to stand still or run
	 *	very slowly.
	 */
<blue>	if (vcpu->tsc_catchup) {</blue>
<yellow>		u64 tsc = compute_guest_tsc(v, kernel_ns);</yellow>
		if (tsc &gt; tsc_timestamp) {
<yellow>			adjust_tsc_offset_guest(v, tsc - tsc_timestamp);</yellow>
			tsc_timestamp = tsc;
		}
	}

<blue>	local_irq_restore(flags);</blue>

	/* With all the info we got, fill in the values */

<blue>	if (kvm_caps.has_tsc_control)</blue>
<blue>		tgt_tsc_khz = kvm_scale_tsc(tgt_tsc_khz,</blue>
					    v-&gt;arch.l1_tsc_scaling_ratio);

<blue>	if (unlikely(vcpu->hw_tsc_khz != tgt_tsc_khz)) {</blue>
<blue>		kvm_get_time_scale(NSEC_PER_SEC, tgt_tsc_khz * 1000LL,</blue>
				   &amp;vcpu-&gt;hv_clock.tsc_shift,
				   &amp;vcpu-&gt;hv_clock.tsc_to_system_mul);
		vcpu-&gt;hw_tsc_khz = tgt_tsc_khz;
	}

<blue>	vcpu->hv_clock.tsc_timestamp = tsc_timestamp;</blue>
	vcpu-&gt;hv_clock.system_time = kernel_ns + v-&gt;kvm-&gt;arch.kvmclock_offset;
	vcpu-&gt;last_guest_tsc = tsc_timestamp;

	/* If the host uses TSC clocksource, then it is stable */
	pvclock_flags = 0;
	if (use_master_clock)
		pvclock_flags |= PVCLOCK_TSC_STABLE_BIT;

	vcpu-&gt;hv_clock.flags = pvclock_flags;

<blue>	if (vcpu->pv_time.active)</blue>
<yellow>		kvm_setup_guest_pvclock(v, &vcpu->pv_time, 0);</yellow>
<blue>	if (vcpu->xen.vcpu_info_cache.active)</blue>
<yellow>		kvm_setup_guest_pvclock(v, &vcpu->xen.vcpu_info_cache,</yellow>
					offsetof(struct compat_vcpu_info, time));
<blue>	if (vcpu->xen.vcpu_time_info_cache.active)</blue>
<yellow>		kvm_setup_guest_pvclock(v, &vcpu->xen.vcpu_time_info_cache, 0);</yellow>
<blue>	kvm_hv_setup_tsc_page(v->kvm, &vcpu->hv_clock);</blue>
	return 0;
<blue>}</blue>

/*
 * kvmclock updates which are isolated to a given vcpu, such as
 * vcpu-&gt;cpu migration, should not allow system_timestamp from
 * the rest of the vcpus to remain static. Otherwise ntp frequency
 * correction applies to one vcpu&#x27;s system_timestamp but not
 * the others.
 *
 * So in those cases, request a kvmclock update for all vcpus.
 * We need to rate-limit these requests though, as they can
 * considerably slow guests that have a large number of vcpus.
 * The time for a remote vcpu to update its kvmclock is bound
 * by the delay we use to rate-limit the updates.
 */

#define KVMCLOCK_UPDATE_DELAY msecs_to_jiffies(100)

static void kvmclock_update_fn(struct work_struct *work)
<yellow>{</yellow>
	unsigned long i;
	struct delayed_work *dwork = to_delayed_work(work);
	struct kvm_arch *ka = container_of(dwork, struct kvm_arch,
					   kvmclock_update_work);
	struct kvm *kvm = container_of(ka, struct kvm, arch);
	struct kvm_vcpu *vcpu;

<yellow>	kvm_for_each_vcpu(i, vcpu, kvm) {</yellow>
<yellow>		kvm_make_request(KVM_REQ_CLOCK_UPDATE, vcpu);</yellow>
		kvm_vcpu_kick(vcpu);
	}
}

static void kvm_gen_kvmclock_update(struct kvm_vcpu *v)
{
	struct kvm *kvm = v-&gt;kvm;

	kvm_make_request(KVM_REQ_CLOCK_UPDATE, v);
	schedule_delayed_work(&amp;kvm-&gt;arch.kvmclock_update_work,
					KVMCLOCK_UPDATE_DELAY);
}

#define KVMCLOCK_SYNC_PERIOD (300 * HZ)

<yellow>static void kvmclock_sync_fn(struct work_struct *work)</yellow>
{
	struct delayed_work *dwork = to_delayed_work(work);
	struct kvm_arch *ka = container_of(dwork, struct kvm_arch,
					   kvmclock_sync_work);
	struct kvm *kvm = container_of(ka, struct kvm, arch);

<yellow>	if (!kvmclock_periodic_sync)</yellow>
		return;

<yellow>	schedule_delayed_work(&kvm->arch.kvmclock_update_work, 0);</yellow>
	schedule_delayed_work(&amp;kvm-&gt;arch.kvmclock_sync_work,
					KVMCLOCK_SYNC_PERIOD);
<yellow>}</yellow>

/* These helpers are safe iff @msr is known to be an MCx bank MSR. */
static bool is_mci_control_msr(u32 msr)
{
<blue>	return (msr & 3) == 0;</blue>
}
static bool is_mci_status_msr(u32 msr)
{
	return (msr &amp; 3) == 1;
}

/*
 * On AMD, HWCR[McStatusWrEn] controls whether setting MCi_STATUS results in #GP.
 */
static bool can_set_mci_status(struct kvm_vcpu *vcpu)
{
	/* McStatusWrEn enabled? */
<yellow>	if (guest_cpuid_is_amd_or_hygon(vcpu))</yellow>
<yellow>		return !!(vcpu->arch.msr_hwcr & BIT_ULL(18));</yellow>

	return false;
}

static int set_msr_mce(struct kvm_vcpu *vcpu, struct msr_data *msr_info)
{
<blue>	u64 mcg_cap = vcpu->arch.mcg_cap;</blue>
	unsigned bank_num = mcg_cap &amp; 0xff;
	u32 msr = msr_info-&gt;index;
	u64 data = msr_info-&gt;data;
	u32 offset, last_msr;

	switch (msr) {
	case MSR_IA32_MCG_STATUS:
<blue>		vcpu->arch.mcg_status = data;</blue>
		break;
	case MSR_IA32_MCG_CTL:
<blue>		if (!(mcg_cap & MCG_CTL_P) &&</blue>
<yellow>		    (data || !msr_info->host_initiated))</yellow>
			return 1;
<blue>		if (data != 0 && data != ~(u64)0)</blue>
			return 1;
<blue>		vcpu->arch.mcg_ctl = data;</blue>
		break;
	case MSR_IA32_MC0_CTL2 ... MSR_IA32_MCx_CTL2(KVM_MAX_MCE_BANKS) - 1:
<yellow>		last_msr = MSR_IA32_MCx_CTL2(bank_num) - 1;</yellow>
		if (msr &gt; last_msr)
			return 1;

<yellow>		if (!(mcg_cap & MCG_CMCI_P) && (data || !msr_info->host_initiated))</yellow>
			return 1;
		/* An attempt to write a 1 to a reserved bit raises #GP */
<yellow>		if (data & ~(MCI_CTL2_CMCI_EN | MCI_CTL2_CMCI_THRESHOLD_MASK))</yellow>
			return 1;
<yellow>		offset = array_index_nospec(msr - MSR_IA32_MC0_CTL2,</yellow>
					    last_msr + 1 - MSR_IA32_MC0_CTL2);
		vcpu-&gt;arch.mci_ctl2_banks[offset] = data;
		break;
	case MSR_IA32_MC0_CTL ... MSR_IA32_MCx_CTL(KVM_MAX_MCE_BANKS) - 1:
<blue>		last_msr = MSR_IA32_MCx_CTL(bank_num) - 1;</blue>
		if (msr &gt; last_msr)
			return 1;

		/*
		 * Only 0 or all 1s can be written to IA32_MCi_CTL, all other
		 * values are architecturally undefined.  But, some Linux
		 * kernels clear bit 10 in bank 4 to workaround a BIOS/GART TLB
		 * issue on AMD K8s, allow bit 10 to be clear when setting all
		 * other bits in order to avoid an uncaught #GP in the guest.
		 *
		 * UNIXWARE clears bit 0 of MC1_CTL to ignore correctable,
		 * single-bit ECC data errors.
		 */
<blue>		if (is_mci_control_msr(msr) &&</blue>
<blue>		    data != 0 && (data | (1 << 10) | 1) != ~(u64)0)</blue>
			return 1;

		/*
		 * All CPUs allow writing 0 to MCi_STATUS MSRs to clear the MSR.
		 * AMD-based CPUs allow non-zero values, but if and only if
		 * HWCR[McStatusWrEn] is set.
		 */
<blue>		if (!msr_info->host_initiated && is_mci_status_msr(msr) &&</blue>
<yellow>		    data != 0 && !can_set_mci_status(vcpu))</yellow>
			return 1;

<blue>		offset = array_index_nospec(msr - MSR_IA32_MC0_CTL,</blue>
					    last_msr + 1 - MSR_IA32_MC0_CTL);
		vcpu-&gt;arch.mce_banks[offset] = data;
		break;
	default:
		return 1;
	}
	return 0;
}

static inline bool kvm_pv_async_pf_enabled(struct kvm_vcpu *vcpu)
{
	u64 mask = KVM_ASYNC_PF_ENABLED | KVM_ASYNC_PF_DELIVERY_AS_INT;

<yellow>	return (vcpu->arch.apf.msr_en_val & mask) == mask;</yellow>
}

static int kvm_pv_enable_async_pf(struct kvm_vcpu *vcpu, u64 data)
{
	gpa_t gpa = data &amp; ~0x3f;

	/* Bits 4:5 are reserved, Should be zero */
<blue>	if (data & 0x30)</blue>
		return 1;

<blue>	if (!guest_pv_has(vcpu, KVM_FEATURE_ASYNC_PF_VMEXIT) &&</blue>
<yellow>	    (data & KVM_ASYNC_PF_DELIVERY_AS_PF_VMEXIT))</yellow>
		return 1;

<blue>	if (!guest_pv_has(vcpu, KVM_FEATURE_ASYNC_PF_INT) &&</blue>
<yellow>	    (data & KVM_ASYNC_PF_DELIVERY_AS_INT))</yellow>
		return 1;

<blue>	if (!lapic_in_kernel(vcpu))</blue>
		return data ? 1 : 0;

<blue>	vcpu->arch.apf.msr_en_val = data;</blue>

	if (!kvm_pv_async_pf_enabled(vcpu)) {
<blue>		kvm_clear_async_pf_completion_queue(vcpu);</blue>
<blue>		kvm_async_pf_hash_reset(vcpu);</blue>
		return 0;
	}

<yellow>	if (kvm_gfn_to_hva_cache_init(vcpu->kvm, &vcpu->arch.apf.data, gpa,</yellow>
					sizeof(u64)))
		return 1;

<yellow>	vcpu->arch.apf.send_user_only = !(data & KVM_ASYNC_PF_SEND_ALWAYS);</yellow>
	vcpu-&gt;arch.apf.delivery_as_pf_vmexit = data &amp; KVM_ASYNC_PF_DELIVERY_AS_PF_VMEXIT;

	kvm_async_pf_wakeup_all(vcpu);

	return 0;
}

static int kvm_pv_enable_async_pf_int(struct kvm_vcpu *vcpu, u64 data)
{
	/* Bits 8-63 are reserved */
<blue>	if (data >> 8)</blue>
		return 1;

<blue>	if (!lapic_in_kernel(vcpu))</blue>
		return 1;

<blue>	vcpu->arch.apf.msr_int_val = data;</blue>

	vcpu-&gt;arch.apf.vec = data &amp; KVM_ASYNC_PF_VEC_MASK;

	return 0;
}

static void kvmclock_reset(struct kvm_vcpu *vcpu)
{
<yellow>	kvm_gpc_deactivate(vcpu->kvm, &vcpu->arch.pv_time);</yellow>
	vcpu-&gt;arch.time = 0;
}

static void kvm_vcpu_flush_tlb_all(struct kvm_vcpu *vcpu)
{
	++vcpu-&gt;stat.tlb_flush;
	static_call(kvm_x86_flush_tlb_all)(vcpu);
}

static void kvm_vcpu_flush_tlb_guest(struct kvm_vcpu *vcpu)
{
<yellow>	++vcpu->stat.tlb_flush;</yellow>

<blue>	if (!tdp_enabled) {</blue>
		/*
		 * A TLB flush on behalf of the guest is equivalent to
		 * INVPCID(all), toggling CR4.PGE, etc., which requires
		 * a forced sync of the shadow page tables.  Ensure all the
		 * roots are synced and the guest TLB in hardware is clean.
		 */
<yellow>		kvm_mmu_sync_roots(vcpu);</yellow>
		kvm_mmu_sync_prev_roots(vcpu);
	}

<blue>	static_call(kvm_x86_flush_tlb_guest)(vcpu);</blue>
}


static inline void kvm_vcpu_flush_tlb_current(struct kvm_vcpu *vcpu)
{
	++vcpu-&gt;stat.tlb_flush;
	static_call(kvm_x86_flush_tlb_current)(vcpu);
}

/*
 * Service &quot;local&quot; TLB flush requests, which are specific to the current MMU
 * context.  In addition to the generic event handling in vcpu_enter_guest(),
 * TLB flushes that are targeted at an MMU context also need to be serviced
 * prior before nested VM-Enter/VM-Exit.
 */
void kvm_service_local_tlb_flush_requests(struct kvm_vcpu *vcpu)
{
<blue>	if (kvm_check_request(KVM_REQ_TLB_FLUSH_CURRENT, vcpu))</blue>
		kvm_vcpu_flush_tlb_current(vcpu);

<blue>	if (kvm_check_request(KVM_REQ_TLB_FLUSH_GUEST, vcpu))</blue>
<blue>		kvm_vcpu_flush_tlb_guest(vcpu);</blue>
<blue>}</blue>
EXPORT_SYMBOL_GPL(kvm_service_local_tlb_flush_requests);

static void record_steal_time(struct kvm_vcpu *vcpu)
{
	struct gfn_to_hva_cache *ghc = &amp;vcpu-&gt;arch.st.cache;
	struct kvm_steal_time __user *st;
	struct kvm_memslots *slots;
<blue>	gpa_t gpa = vcpu->arch.st.msr_val & KVM_STEAL_VALID_BITS;</blue>
	u64 steal;
	u32 version;

<yellow>	if (kvm_xen_msr_enabled(vcpu->kvm)) {</yellow>
<yellow>		kvm_xen_runstate_set_running(vcpu);</yellow>
		return;
	}

<blue>	if (!(vcpu->arch.st.msr_val & KVM_MSR_ENABLED))</blue>
		return;

<yellow>	if (WARN_ON_ONCE(current->mm != vcpu->kvm->mm))</yellow>
		return;

	slots = kvm_memslots(vcpu-&gt;kvm);

<yellow>	if (unlikely(slots->generation != ghc->generation ||</yellow>
		     gpa != ghc-&gt;gpa ||
		     kvm_is_error_hva(ghc-&gt;hva) || !ghc-&gt;memslot)) {
		/* We rely on the fact that it fits in a single page. */
		BUILD_BUG_ON((sizeof(*st) - 1) &amp; KVM_STEAL_VALID_BITS);

<yellow>		if (kvm_gfn_to_hva_cache_init(vcpu->kvm, ghc, gpa, sizeof(*st)) ||</yellow>
<yellow>		    kvm_is_error_hva(ghc->hva) || !ghc->memslot)</yellow>
			return;
	}

	st = (struct kvm_steal_time __user *)ghc-&gt;hva;
	/*
	 * Doing a TLB flush here, on the guest&#x27;s behalf, can avoid
	 * expensive IPIs.
	 */
<yellow>	if (guest_pv_has(vcpu, KVM_FEATURE_PV_TLB_FLUSH)) {</yellow>
		u8 st_preempted = 0;
		int err = -EFAULT;

<yellow>		if (!user_access_begin(st, sizeof(*st)))</yellow>
			return;

		asm volatile(&quot;1: xchgb %0, %2\n&quot;
			     &quot;xor %1, %1\n&quot;
			     &quot;2:\n&quot;
			     _ASM_EXTABLE_UA(1b, 2b)
			     : &quot;+q&quot; (st_preempted),
			       &quot;+&amp;r&quot; (err),
			       &quot;+m&quot; (st-&gt;preempted));
		if (err)
			goto out;

<yellow>		user_access_end();</yellow>

		vcpu-&gt;arch.st.preempted = 0;

<yellow>		trace_kvm_pv_tlb_flush(vcpu->vcpu_id,</yellow>
				       st_preempted &amp; KVM_VCPU_FLUSH_TLB);
<yellow>		if (st_preempted & KVM_VCPU_FLUSH_TLB)</yellow>
<yellow>			kvm_vcpu_flush_tlb_guest(vcpu);</yellow>

<yellow>		if (!user_access_begin(st, sizeof(*st)))</yellow>
			goto dirty;
	} else {
<yellow>		if (!user_access_begin(st, sizeof(*st)))</yellow>
			return;

		unsafe_put_user(0, &amp;st-&gt;preempted, out);
<yellow>		vcpu->arch.st.preempted = 0;</yellow>
	}

<yellow>	unsafe_get_user(version, &st->version, out);</yellow>
<yellow>	if (version & 1)</yellow>
<yellow>		version += 1;  /* first time write, random junk */</yellow>

<yellow>	version += 1;</yellow>
	unsafe_put_user(version, &amp;st-&gt;version, out);

	smp_wmb();

<yellow>	unsafe_get_user(steal, &st->steal, out);</yellow>
<yellow>	steal += current->sched_info.run_delay -</yellow>
		vcpu-&gt;arch.st.last_steal;
	vcpu-&gt;arch.st.last_steal = current-&gt;sched_info.run_delay;
	unsafe_put_user(steal, &amp;st-&gt;steal, out);

<yellow>	version += 1;</yellow>
	unsafe_put_user(version, &amp;st-&gt;version, out);

 out:
<yellow>	user_access_end();</yellow>
 dirty:
<yellow>	mark_page_dirty_in_slot(vcpu->kvm, ghc->memslot, gpa_to_gfn(ghc->gpa));</yellow>
<blue>}</blue>

int kvm_set_msr_common(struct kvm_vcpu *vcpu, struct msr_data *msr_info)
<blue>{</blue>
	bool pr = false;
<blue>	u32 msr = msr_info->index;</blue>
	u64 data = msr_info-&gt;data;

<blue>	if (msr && msr == vcpu->kvm->arch.xen_hvm_config.msr)</blue>
<yellow>		return kvm_xen_write_hypercall_page(vcpu, data);</yellow>

<blue>	switch (msr) {</blue>
	case MSR_AMD64_NB_CFG:
	case MSR_IA32_UCODE_WRITE:
	case MSR_VM_HSAVE_PA:
	case MSR_AMD64_PATCH_LOADER:
	case MSR_AMD64_BU_CFG2:
	case MSR_AMD64_DC_CFG:
	case MSR_F15H_EX_CFG:
		break;

	case MSR_IA32_UCODE_REV:
<blue>		if (msr_info->host_initiated)</blue>
<blue>			vcpu->arch.microcode_version = data;</blue>
		break;
	case MSR_IA32_ARCH_CAPABILITIES:
<blue>		if (!msr_info->host_initiated)</blue>
			return 1;
<blue>		vcpu->arch.arch_capabilities = data;</blue>
		break;
	case MSR_IA32_PERF_CAPABILITIES: {
		struct kvm_msr_entry msr_ent = {.index = msr, .data = 0};

<blue>		if (!msr_info->host_initiated)</blue>
<blue>			return 1;</blue>
<blue>		if (kvm_get_msr_feature(&msr_ent))</blue>
			return 1;
<blue>		if (data & ~msr_ent.data)</blue>
			return 1;

<blue>		vcpu->arch.perf_capabilities = data;</blue>
		kvm_pmu_refresh(vcpu);
		return 0;
	}
	case MSR_EFER:
<blue>		return set_efer(vcpu, msr_info);</blue>
	case MSR_K7_HWCR:
		data &amp;= ~(u64)0x40;	/* ignore flush filter disable */
		data &amp;= ~(u64)0x100;	/* ignore ignne emulation enable */
<yellow>		data &= ~(u64)0x8;	/* ignore TLB cache disable */</yellow>

		/* Handle McStatusWrEn */
		if (data == BIT_ULL(18)) {
<yellow>			vcpu->arch.msr_hwcr = data;</yellow>
<yellow>		} else if (data != 0) {</yellow>
<yellow>			vcpu_unimpl(vcpu, "unimplemented HWCR wrmsr: 0x%llx\n",</yellow>
				    data);
			return 1;
		}
		break;
	case MSR_FAM10H_MMIO_CONF_BASE:
<yellow>		if (data != 0) {</yellow>
<yellow>			vcpu_unimpl(vcpu, "unimplemented MMIO_CONF_BASE wrmsr: "</yellow>
				    &quot;0x%llx\n&quot;, data);
			return 1;
		}
		break;
	case 0x200 ... MSR_IA32_MC0_CTL2 - 1:
	case MSR_IA32_MCx_CTL2(KVM_MAX_MCE_BANKS) ... 0x2ff:
<blue>		return kvm_mtrr_set_msr(vcpu, msr, data);</blue>
	case MSR_IA32_APICBASE:
<blue>		return kvm_set_apic_base(vcpu, msr_info);</blue>
	case APIC_BASE_MSR ... APIC_BASE_MSR + 0xff:
<yellow>		return kvm_x2apic_msr_write(vcpu, msr, data);</yellow>
	case MSR_IA32_TSC_DEADLINE:
<blue>		kvm_set_lapic_tscdeadline_msr(vcpu, data);</blue>
		break;
	case MSR_IA32_TSC_ADJUST:
<blue>		if (guest_cpuid_has(vcpu, X86_FEATURE_TSC_ADJUST)) {</blue>
<blue>			if (!msr_info->host_initiated) {</blue>
<yellow>				s64 adj = data - vcpu->arch.ia32_tsc_adjust_msr;</yellow>
				adjust_tsc_offset_guest(vcpu, adj);
				/* Before back to guest, tsc_timestamp must be adjusted
				 * as well, otherwise guest&#x27;s percpu pvclock time could jump.
				 */
				kvm_make_request(KVM_REQ_CLOCK_UPDATE, vcpu);
			}
<blue>			vcpu->arch.ia32_tsc_adjust_msr = data;</blue>
		}
		break;
	case MSR_IA32_MISC_ENABLE: {
<blue>		u64 old_val = vcpu->arch.ia32_misc_enable_msr;</blue>

<blue>		if (!msr_info->host_initiated) {</blue>
			/* RO bits */
<yellow>			if ((old_val ^ data) & MSR_IA32_MISC_ENABLE_PMU_RO_MASK)</yellow>
				return 1;

			/* R bits, i.e. writes are ignored, but don&#x27;t fault. */
<yellow>			data = data & ~MSR_IA32_MISC_ENABLE_EMON;</yellow>
			data |= old_val &amp; MSR_IA32_MISC_ENABLE_EMON;
		}

<blue>		if (!kvm_check_has_quirk(vcpu->kvm, KVM_X86_QUIRK_MISC_ENABLE_NO_MWAIT) &&</blue>
<yellow>		    ((old_val ^ data)  & MSR_IA32_MISC_ENABLE_MWAIT)) {</yellow>
<yellow>			if (!guest_cpuid_has(vcpu, X86_FEATURE_XMM3))</yellow>
				return 1;
<yellow>			vcpu->arch.ia32_misc_enable_msr = data;</yellow>
			kvm_update_cpuid_runtime(vcpu);
		} else {
<blue>			vcpu->arch.ia32_misc_enable_msr = data;</blue>
		}
		break;
	}
	case MSR_IA32_SMBASE:
<blue>		if (!msr_info->host_initiated)</blue>
			return 1;
<blue>		vcpu->arch.smbase = data;</blue>
		break;
	case MSR_IA32_POWER_CTL:
<yellow>		vcpu->arch.msr_ia32_power_ctl = data;</yellow>
		break;
	case MSR_IA32_TSC:
<blue>		if (msr_info->host_initiated) {</blue>
<blue>			kvm_synchronize_tsc(vcpu, data);</blue>
		} else {
<blue>			u64 adj = kvm_compute_l1_tsc_offset(vcpu, data) - vcpu->arch.l1_tsc_offset;</blue>
			adjust_tsc_offset_guest(vcpu, adj);
			vcpu-&gt;arch.ia32_tsc_adjust_msr += adj;
		}
		break;
	case MSR_IA32_XSS:
<blue>		if (!msr_info->host_initiated &&</blue>
<yellow>		    !guest_cpuid_has(vcpu, X86_FEATURE_XSAVES))</yellow>
			return 1;
		/*
		 * KVM supports exposing PT to the guest, but does not support
		 * IA32_XSS[bit 8]. Guests have to use RDMSR/WRMSR rather than
		 * XSAVES/XRSTORS to save/restore PT MSRs.
		 */
<blue>		if (data & ~kvm_caps.supported_xss)</blue>
			return 1;
<blue>		vcpu->arch.ia32_xss = data;</blue>
		kvm_update_cpuid_runtime(vcpu);
		break;
	case MSR_SMI_COUNT:
<blue>		if (!msr_info->host_initiated)</blue>
			return 1;
<blue>		vcpu->arch.smi_count = data;</blue>
		break;
	case MSR_KVM_WALL_CLOCK_NEW:
<yellow>		if (!guest_pv_has(vcpu, KVM_FEATURE_CLOCKSOURCE2))</yellow>
			return 1;

<yellow>		vcpu->kvm->arch.wall_clock = data;</yellow>
		kvm_write_wall_clock(vcpu-&gt;kvm, data, 0);
		break;
	case MSR_KVM_WALL_CLOCK:
<blue>		if (!guest_pv_has(vcpu, KVM_FEATURE_CLOCKSOURCE))</blue>
			return 1;

<blue>		vcpu->kvm->arch.wall_clock = data;</blue>
		kvm_write_wall_clock(vcpu-&gt;kvm, data, 0);
		break;
	case MSR_KVM_SYSTEM_TIME_NEW:
<yellow>		if (!guest_pv_has(vcpu, KVM_FEATURE_CLOCKSOURCE2))</yellow>
			return 1;

<yellow>		kvm_write_system_time(vcpu, data, false, msr_info->host_initiated);</yellow>
		break;
	case MSR_KVM_SYSTEM_TIME:
<blue>		if (!guest_pv_has(vcpu, KVM_FEATURE_CLOCKSOURCE))</blue>
			return 1;

<blue>		kvm_write_system_time(vcpu, data, true,  msr_info->host_initiated);</blue>
		break;
	case MSR_KVM_ASYNC_PF_EN:
<blue>		if (!guest_pv_has(vcpu, KVM_FEATURE_ASYNC_PF))</blue>
			return 1;

<blue>		if (kvm_pv_enable_async_pf(vcpu, data))</blue>
			return 1;
		break;
	case MSR_KVM_ASYNC_PF_INT:
<blue>		if (!guest_pv_has(vcpu, KVM_FEATURE_ASYNC_PF_INT))</blue>
			return 1;

<blue>		if (kvm_pv_enable_async_pf_int(vcpu, data))</blue>
			return 1;
		break;
	case MSR_KVM_ASYNC_PF_ACK:
<yellow>		if (!guest_pv_has(vcpu, KVM_FEATURE_ASYNC_PF_INT))</yellow>
			return 1;
<yellow>		if (data & 0x1) {</yellow>
<yellow>			vcpu->arch.apf.pageready_pending = false;</yellow>
			kvm_check_async_pf_completion(vcpu);
		}
		break;
	case MSR_KVM_STEAL_TIME:
<blue>		if (!guest_pv_has(vcpu, KVM_FEATURE_STEAL_TIME))</blue>
			return 1;

		if (unlikely(!sched_info_on()))
			return 1;

<blue>		if (data & KVM_STEAL_RESERVED_MASK)</blue>
			return 1;

<blue>		vcpu->arch.st.msr_val = data;</blue>

		if (!(data &amp; KVM_MSR_ENABLED))
			break;

<yellow>		kvm_make_request(KVM_REQ_STEAL_UPDATE, vcpu);</yellow>

		break;
	case MSR_KVM_PV_EOI_EN:
<blue>		if (!guest_pv_has(vcpu, KVM_FEATURE_PV_EOI))</blue>
			return 1;

<blue>		if (kvm_lapic_set_pv_eoi(vcpu, data, sizeof(u8)))</blue>
			return 1;
		break;

	case MSR_KVM_POLL_CONTROL:
<blue>		if (!guest_pv_has(vcpu, KVM_FEATURE_POLL_CONTROL))</blue>
			return 1;

		/* only enable bit supported */
<blue>		if (data & (-1ULL << 1))</blue>
			return 1;

<blue>		vcpu->arch.msr_kvm_poll_control = data;</blue>
		break;

	case MSR_IA32_MCG_CTL:
	case MSR_IA32_MCG_STATUS:
	case MSR_IA32_MC0_CTL ... MSR_IA32_MCx_CTL(KVM_MAX_MCE_BANKS) - 1:
	case MSR_IA32_MC0_CTL2 ... MSR_IA32_MCx_CTL2(KVM_MAX_MCE_BANKS) - 1:
<blue>		return set_msr_mce(vcpu, msr_info);</blue>

	case MSR_K7_PERFCTR0 ... MSR_K7_PERFCTR3:
	case MSR_P6_PERFCTR0 ... MSR_P6_PERFCTR1:
		pr = true;
		fallthrough;
	case MSR_K7_EVNTSEL0 ... MSR_K7_EVNTSEL3:
	case MSR_P6_EVNTSEL0 ... MSR_P6_EVNTSEL1:
<blue>		if (kvm_pmu_is_valid_msr(vcpu, msr))</blue>
			return kvm_pmu_set_msr(vcpu, msr_info);

<yellow>		if (pr || data != 0)</yellow>
<yellow>			vcpu_unimpl(vcpu, "disabled perfctr wrmsr: "</yellow>
				    &quot;0x%x data 0x%llx\n&quot;, msr, data);
		break;
	case MSR_K7_CLK_CTL:
		/*
		 * Ignore all writes to this no longer documented MSR.
		 * Writes are only relevant for old K7 processors,
		 * all pre-dating SVM, but a recommended workaround from
		 * AMD for these chips. It is possible to specify the
		 * affected processor models on the command line, hence
		 * the need to ignore the workaround.
		 */
		break;
	case HV_X64_MSR_GUEST_OS_ID ... HV_X64_MSR_SINT15:
	case HV_X64_MSR_SYNDBG_CONTROL ... HV_X64_MSR_SYNDBG_PENDING_BUFFER:
	case HV_X64_MSR_SYNDBG_OPTIONS:
	case HV_X64_MSR_CRASH_P0 ... HV_X64_MSR_CRASH_P4:
	case HV_X64_MSR_CRASH_CTL:
	case HV_X64_MSR_STIMER0_CONFIG ... HV_X64_MSR_STIMER3_COUNT:
	case HV_X64_MSR_REENLIGHTENMENT_CONTROL:
	case HV_X64_MSR_TSC_EMULATION_CONTROL:
	case HV_X64_MSR_TSC_EMULATION_STATUS:
<blue>		return kvm_hv_set_msr_common(vcpu, msr, data,</blue>
<blue>					     msr_info->host_initiated);</blue>
	case MSR_IA32_BBL_CR_CTL3:
		/* Drop writes to this legacy MSR -- see rdmsr
		 * counterpart for further detail.
		 */
<yellow>		if (report_ignored_msrs)</yellow>
<yellow>			vcpu_unimpl(vcpu, "ignored wrmsr: 0x%x data 0x%llx\n",</yellow>
				msr, data);
		break;
	case MSR_AMD64_OSVW_ID_LENGTH:
<yellow>		if (!guest_cpuid_has(vcpu, X86_FEATURE_OSVW))</yellow>
			return 1;
<yellow>		vcpu->arch.osvw.length = data;</yellow>
		break;
	case MSR_AMD64_OSVW_STATUS:
<yellow>		if (!guest_cpuid_has(vcpu, X86_FEATURE_OSVW))</yellow>
			return 1;
<yellow>		vcpu->arch.osvw.status = data;</yellow>
		break;
	case MSR_PLATFORM_INFO:
<yellow>		if (!msr_info->host_initiated ||</yellow>
<yellow>		    (!(data & MSR_PLATFORM_INFO_CPUID_FAULT) &&</yellow>
<yellow>		     cpuid_fault_enabled(vcpu)))</yellow>
			return 1;
<yellow>		vcpu->arch.msr_platform_info = data;</yellow>
		break;
	case MSR_MISC_FEATURES_ENABLES:
<yellow>		if (data & ~MSR_MISC_FEATURES_ENABLES_CPUID_FAULT ||</yellow>
		    (data &amp; MSR_MISC_FEATURES_ENABLES_CPUID_FAULT &amp;&amp;
<yellow>		     !supports_cpuid_fault(vcpu)))</yellow>
			return 1;
<yellow>		vcpu->arch.msr_misc_features_enables = data;</yellow>
		break;
#ifdef CONFIG_X86_64
	case MSR_IA32_XFD:
<yellow>		if (!msr_info->host_initiated &&</yellow>
<yellow>		    !guest_cpuid_has(vcpu, X86_FEATURE_XFD))</yellow>
			return 1;

<yellow>		if (data & ~kvm_guest_supported_xfd(vcpu))</yellow>
			return 1;

<yellow>		fpu_update_guest_xfd(&vcpu->arch.guest_fpu, data);</yellow>
		break;
	case MSR_IA32_XFD_ERR:
<yellow>		if (!msr_info->host_initiated &&</yellow>
<yellow>		    !guest_cpuid_has(vcpu, X86_FEATURE_XFD))</yellow>
			return 1;

<yellow>		if (data & ~kvm_guest_supported_xfd(vcpu))</yellow>
			return 1;

<yellow>		vcpu->arch.guest_fpu.xfd_err = data;</yellow>
		break;
#endif
	case MSR_IA32_PEBS_ENABLE:
	case MSR_IA32_DS_AREA:
	case MSR_PEBS_DATA_CFG:
	case MSR_F15H_PERF_CTL0 ... MSR_F15H_PERF_CTR5:
<yellow>		if (kvm_pmu_is_valid_msr(vcpu, msr))</yellow>
			return kvm_pmu_set_msr(vcpu, msr_info);
		/*
		 * Userspace is allowed to write &#x27;0&#x27; to MSRs that KVM reports
		 * as to-be-saved, even if an MSRs isn&#x27;t fully supported.
		 */
<yellow>		return !msr_info->host_initiated || data;</yellow>
	default:
<blue>		if (kvm_pmu_is_valid_msr(vcpu, msr))</blue>
<blue>			return kvm_pmu_set_msr(vcpu, msr_info);</blue>
		return KVM_MSR_RET_INVALID;
	}
	return 0;
}
EXPORT_SYMBOL_GPL(kvm_set_msr_common);

static int get_msr_mce(struct kvm_vcpu *vcpu, u32 msr, u64 *pdata, bool host)
{
	u64 data;
<blue>	u64 mcg_cap = vcpu->arch.mcg_cap;</blue>
	unsigned bank_num = mcg_cap &amp; 0xff;
	u32 offset, last_msr;

	switch (msr) {
	case MSR_IA32_P5_MC_ADDR:
	case MSR_IA32_P5_MC_TYPE:
		data = 0;
		break;
	case MSR_IA32_MCG_CAP:
		data = vcpu-&gt;arch.mcg_cap;
		break;
	case MSR_IA32_MCG_CTL:
<blue>		if (!(mcg_cap & MCG_CTL_P) && !host)</blue>
			return 1;
<blue>		data = vcpu->arch.mcg_ctl;</blue>
		break;
	case MSR_IA32_MCG_STATUS:
<blue>		data = vcpu->arch.mcg_status;</blue>
		break;
	case MSR_IA32_MC0_CTL2 ... MSR_IA32_MCx_CTL2(KVM_MAX_MCE_BANKS) - 1:
<yellow>		last_msr = MSR_IA32_MCx_CTL2(bank_num) - 1;</yellow>
		if (msr &gt; last_msr)
			return 1;

<yellow>		if (!(mcg_cap & MCG_CMCI_P) && !host)</yellow>
			return 1;
<yellow>		offset = array_index_nospec(msr - MSR_IA32_MC0_CTL2,</yellow>
					    last_msr + 1 - MSR_IA32_MC0_CTL2);
		data = vcpu-&gt;arch.mci_ctl2_banks[offset];
		break;
	case MSR_IA32_MC0_CTL ... MSR_IA32_MCx_CTL(KVM_MAX_MCE_BANKS) - 1:
<blue>		last_msr = MSR_IA32_MCx_CTL(bank_num) - 1;</blue>
		if (msr &gt; last_msr)
			return 1;

<blue>		offset = array_index_nospec(msr - MSR_IA32_MC0_CTL,</blue>
					    last_msr + 1 - MSR_IA32_MC0_CTL);
		data = vcpu-&gt;arch.mce_banks[offset];
		break;
	default:
		return 1;
	}
<blue>	*pdata = data;</blue>
	return 0;
}

int kvm_get_msr_common(struct kvm_vcpu *vcpu, struct msr_data *msr_info)
{
<blue>	switch (msr_info->index) {</blue>
	case MSR_IA32_PLATFORM_ID:
	case MSR_IA32_EBL_CR_POWERON:
	case MSR_IA32_LASTBRANCHFROMIP:
	case MSR_IA32_LASTBRANCHTOIP:
	case MSR_IA32_LASTINTFROMIP:
	case MSR_IA32_LASTINTTOIP:
	case MSR_AMD64_SYSCFG:
	case MSR_K8_TSEG_ADDR:
	case MSR_K8_TSEG_MASK:
	case MSR_VM_HSAVE_PA:
	case MSR_K8_INT_PENDING_MSG:
	case MSR_AMD64_NB_CFG:
	case MSR_FAM10H_MMIO_CONF_BASE:
	case MSR_AMD64_BU_CFG2:
	case MSR_IA32_PERF_CTL:
	case MSR_AMD64_DC_CFG:
	case MSR_F15H_EX_CFG:
	/*
	 * Intel Sandy Bridge CPUs must support the RAPL (running average power
	 * limit) MSRs. Just return 0, as we do not want to expose the host
	 * data here. Do not conditionalize this on CPUID, as KVM does not do
	 * so for existing CPU-specific MSRs.
	 */
	case MSR_RAPL_POWER_UNIT:
	case MSR_PP0_ENERGY_STATUS:	/* Power plane 0 (core) */
	case MSR_PP1_ENERGY_STATUS:	/* Power plane 1 (graphics uncore) */
	case MSR_PKG_ENERGY_STATUS:	/* Total package */
	case MSR_DRAM_ENERGY_STATUS:	/* DRAM controller */
<yellow>		msr_info->data = 0;</yellow>
		break;
	case MSR_IA32_PEBS_ENABLE:
	case MSR_IA32_DS_AREA:
	case MSR_PEBS_DATA_CFG:
	case MSR_F15H_PERF_CTL0 ... MSR_F15H_PERF_CTR5:
<yellow>		if (kvm_pmu_is_valid_msr(vcpu, msr_info->index))</yellow>
			return kvm_pmu_get_msr(vcpu, msr_info);
		/*
		 * Userspace is allowed to read MSRs that KVM reports as
		 * to-be-saved, even if an MSR isn&#x27;t fully supported.
		 */
<yellow>		if (!msr_info->host_initiated)</yellow>
			return 1;
<yellow>		msr_info->data = 0;</yellow>
		break;
	case MSR_K7_EVNTSEL0 ... MSR_K7_EVNTSEL3:
	case MSR_K7_PERFCTR0 ... MSR_K7_PERFCTR3:
	case MSR_P6_PERFCTR0 ... MSR_P6_PERFCTR1:
	case MSR_P6_EVNTSEL0 ... MSR_P6_EVNTSEL1:
<blue>		if (kvm_pmu_is_valid_msr(vcpu, msr_info->index))</blue>
			return kvm_pmu_get_msr(vcpu, msr_info);
		msr_info-&gt;data = 0;
		break;
	case MSR_IA32_UCODE_REV:
<yellow>		msr_info->data = vcpu->arch.microcode_version;</yellow>
		break;
	case MSR_IA32_ARCH_CAPABILITIES:
<yellow>		if (!msr_info->host_initiated &&</yellow>
<yellow>		    !guest_cpuid_has(vcpu, X86_FEATURE_ARCH_CAPABILITIES))</yellow>
			return 1;
<yellow>		msr_info->data = vcpu->arch.arch_capabilities;</yellow>
		break;
	case MSR_IA32_PERF_CAPABILITIES:
<yellow>		if (!msr_info->host_initiated &&</yellow>
<yellow>		    !guest_cpuid_has(vcpu, X86_FEATURE_PDCM))</yellow>
			return 1;
<yellow>		msr_info->data = vcpu->arch.perf_capabilities;</yellow>
		break;
	case MSR_IA32_POWER_CTL:
<yellow>		msr_info->data = vcpu->arch.msr_ia32_power_ctl;</yellow>
		break;
	case MSR_IA32_TSC: {
		/*
		 * Intel SDM states that MSR_IA32_TSC read adds the TSC offset
		 * even when not intercepted. AMD manual doesn&#x27;t explicitly
		 * state this but appears to behave the same.
		 *
		 * On userspace reads and writes, however, we unconditionally
		 * return L1&#x27;s TSC value to ensure backwards-compatible
		 * behavior for migration.
		 */
		u64 offset, ratio;

<blue>		if (msr_info->host_initiated) {</blue>
<blue>			offset = vcpu->arch.l1_tsc_offset;</blue>
			ratio = vcpu-&gt;arch.l1_tsc_scaling_ratio;
		} else {
			offset = vcpu-&gt;arch.tsc_offset;
			ratio = vcpu-&gt;arch.tsc_scaling_ratio;
		}

<blue>		msr_info->data = kvm_scale_tsc(rdtsc(), ratio) + offset;</blue>
		break;
	}
	case MSR_MTRRcap:
	case 0x200 ... MSR_IA32_MC0_CTL2 - 1:
	case MSR_IA32_MCx_CTL2(KVM_MAX_MCE_BANKS) ... 0x2ff:
<blue>		return kvm_mtrr_get_msr(vcpu, msr_info->index, &msr_info->data);</blue>
	case 0xcd: /* fsb frequency */
<yellow>		msr_info->data = 3;</yellow>
		break;
		/*
		 * MSR_EBC_FREQUENCY_ID
		 * Conservative value valid for even the basic CPU models.
		 * Models 0,1: 000 in bits 23:21 indicating a bus speed of
		 * 100MHz, model 2 000 in bits 18:16 indicating 100MHz,
		 * and 266MHz for model 3, or 4. Set Core Clock
		 * Frequency to System Bus Frequency Ratio to 1 (bits
		 * 31:24) even though these are only valid for CPU
		 * models &gt; 2, however guests may end up dividing or
		 * multiplying by zero otherwise.
		 */
	case MSR_EBC_FREQUENCY_ID:
<yellow>		msr_info->data = 1 << 24;</yellow>
		break;
	case MSR_IA32_APICBASE:
<blue>		msr_info->data = kvm_get_apic_base(vcpu);</blue>
		break;
	case APIC_BASE_MSR ... APIC_BASE_MSR + 0xff:
<yellow>		return kvm_x2apic_msr_read(vcpu, msr_info->index, &msr_info->data);</yellow>
	case MSR_IA32_TSC_DEADLINE:
<blue>		msr_info->data = kvm_get_lapic_tscdeadline_msr(vcpu);</blue>
		break;
	case MSR_IA32_TSC_ADJUST:
<blue>		msr_info->data = (u64)vcpu->arch.ia32_tsc_adjust_msr;</blue>
		break;
	case MSR_IA32_MISC_ENABLE:
<blue>		msr_info->data = vcpu->arch.ia32_misc_enable_msr;</blue>
		break;
	case MSR_IA32_SMBASE:
<blue>		if (!msr_info->host_initiated)</blue>
			return 1;
<blue>		msr_info->data = vcpu->arch.smbase;</blue>
		break;
	case MSR_SMI_COUNT:
<blue>		msr_info->data = vcpu->arch.smi_count;</blue>
		break;
	case MSR_IA32_PERF_STATUS:
		/* TSC increment by tick */
		msr_info-&gt;data = 1000ULL;
		/* CPU multiplier */
<yellow>		msr_info->data |= (((uint64_t)4ULL) << 40);</yellow>
		break;
	case MSR_EFER:
<blue>		msr_info->data = vcpu->arch.efer;</blue>
		break;
	case MSR_KVM_WALL_CLOCK:
<blue>		if (!guest_pv_has(vcpu, KVM_FEATURE_CLOCKSOURCE))</blue>
			return 1;

<blue>		msr_info->data = vcpu->kvm->arch.wall_clock;</blue>
		break;
	case MSR_KVM_WALL_CLOCK_NEW:
<yellow>		if (!guest_pv_has(vcpu, KVM_FEATURE_CLOCKSOURCE2))</yellow>
			return 1;

<yellow>		msr_info->data = vcpu->kvm->arch.wall_clock;</yellow>
		break;
	case MSR_KVM_SYSTEM_TIME:
<blue>		if (!guest_pv_has(vcpu, KVM_FEATURE_CLOCKSOURCE))</blue>
			return 1;

<blue>		msr_info->data = vcpu->arch.time;</blue>
		break;
	case MSR_KVM_SYSTEM_TIME_NEW:
<yellow>		if (!guest_pv_has(vcpu, KVM_FEATURE_CLOCKSOURCE2))</yellow>
			return 1;

<yellow>		msr_info->data = vcpu->arch.time;</yellow>
		break;
	case MSR_KVM_ASYNC_PF_EN:
<blue>		if (!guest_pv_has(vcpu, KVM_FEATURE_ASYNC_PF))</blue>
			return 1;

<blue>		msr_info->data = vcpu->arch.apf.msr_en_val;</blue>
		break;
	case MSR_KVM_ASYNC_PF_INT:
<blue>		if (!guest_pv_has(vcpu, KVM_FEATURE_ASYNC_PF_INT))</blue>
			return 1;

<blue>		msr_info->data = vcpu->arch.apf.msr_int_val;</blue>
		break;
	case MSR_KVM_ASYNC_PF_ACK:
<yellow>		if (!guest_pv_has(vcpu, KVM_FEATURE_ASYNC_PF_INT))</yellow>
			return 1;

		msr_info-&gt;data = 0;
		break;
	case MSR_KVM_STEAL_TIME:
<blue>		if (!guest_pv_has(vcpu, KVM_FEATURE_STEAL_TIME))</blue>
			return 1;

<blue>		msr_info->data = vcpu->arch.st.msr_val;</blue>
		break;
	case MSR_KVM_PV_EOI_EN:
<blue>		if (!guest_pv_has(vcpu, KVM_FEATURE_PV_EOI))</blue>
			return 1;

<blue>		msr_info->data = vcpu->arch.pv_eoi.msr_val;</blue>
		break;
	case MSR_KVM_POLL_CONTROL:
<blue>		if (!guest_pv_has(vcpu, KVM_FEATURE_POLL_CONTROL))</blue>
			return 1;

<blue>		msr_info->data = vcpu->arch.msr_kvm_poll_control;</blue>
		break;
	case MSR_IA32_P5_MC_ADDR:
	case MSR_IA32_P5_MC_TYPE:
	case MSR_IA32_MCG_CAP:
	case MSR_IA32_MCG_CTL:
	case MSR_IA32_MCG_STATUS:
	case MSR_IA32_MC0_CTL ... MSR_IA32_MCx_CTL(KVM_MAX_MCE_BANKS) - 1:
	case MSR_IA32_MC0_CTL2 ... MSR_IA32_MCx_CTL2(KVM_MAX_MCE_BANKS) - 1:
<blue>		return get_msr_mce(vcpu, msr_info->index, &msr_info->data,</blue>
<blue>				   msr_info->host_initiated);</blue>
	case MSR_IA32_XSS:
<yellow>		if (!msr_info->host_initiated &&</yellow>
<yellow>		    !guest_cpuid_has(vcpu, X86_FEATURE_XSAVES))</yellow>
			return 1;
<yellow>		msr_info->data = vcpu->arch.ia32_xss;</yellow>
		break;
	case MSR_K7_CLK_CTL:
		/*
		 * Provide expected ramp-up count for K7. All other
		 * are set to zero, indicating minimum divisors for
		 * every field.
		 *
		 * This prevents guest kernels on AMD host with CPU
		 * type 6, model 8 and higher from exploding due to
		 * the rdmsr failing.
		 */
<yellow>		msr_info->data = 0x20000000;</yellow>
		break;
	case HV_X64_MSR_GUEST_OS_ID ... HV_X64_MSR_SINT15:
	case HV_X64_MSR_SYNDBG_CONTROL ... HV_X64_MSR_SYNDBG_PENDING_BUFFER:
	case HV_X64_MSR_SYNDBG_OPTIONS:
	case HV_X64_MSR_CRASH_P0 ... HV_X64_MSR_CRASH_P4:
	case HV_X64_MSR_CRASH_CTL:
	case HV_X64_MSR_STIMER0_CONFIG ... HV_X64_MSR_STIMER3_COUNT:
	case HV_X64_MSR_REENLIGHTENMENT_CONTROL:
	case HV_X64_MSR_TSC_EMULATION_CONTROL:
	case HV_X64_MSR_TSC_EMULATION_STATUS:
<blue>		return kvm_hv_get_msr_common(vcpu,</blue>
					     msr_info-&gt;index, &amp;msr_info-&gt;data,
<blue>					     msr_info->host_initiated);</blue>
	case MSR_IA32_BBL_CR_CTL3:
		/* This legacy MSR exists but isn&#x27;t fully documented in current
		 * silicon.  It is however accessed by winxp in very narrow
		 * scenarios where it sets bit #19, itself documented as
		 * a &quot;reserved&quot; bit.  Best effort attempt to source coherent
		 * read data here should the balance of the register be
		 * interpreted by the guest:
		 *
		 * L2 cache control register 3: 64GB range, 256KB size,
		 * enabled, latency 0x1, configured
		 */
<yellow>		msr_info->data = 0xbe702111;</yellow>
		break;
	case MSR_AMD64_OSVW_ID_LENGTH:
<yellow>		if (!guest_cpuid_has(vcpu, X86_FEATURE_OSVW))</yellow>
			return 1;
<yellow>		msr_info->data = vcpu->arch.osvw.length;</yellow>
		break;
	case MSR_AMD64_OSVW_STATUS:
<yellow>		if (!guest_cpuid_has(vcpu, X86_FEATURE_OSVW))</yellow>
			return 1;
<yellow>		msr_info->data = vcpu->arch.osvw.status;</yellow>
		break;
	case MSR_PLATFORM_INFO:
<yellow>		if (!msr_info->host_initiated &&</yellow>
<yellow>		    !vcpu->kvm->arch.guest_can_read_msr_platform_info)</yellow>
			return 1;
<yellow>		msr_info->data = vcpu->arch.msr_platform_info;</yellow>
		break;
	case MSR_MISC_FEATURES_ENABLES:
<yellow>		msr_info->data = vcpu->arch.msr_misc_features_enables;</yellow>
		break;
	case MSR_K7_HWCR:
<yellow>		msr_info->data = vcpu->arch.msr_hwcr;</yellow>
		break;
#ifdef CONFIG_X86_64
	case MSR_IA32_XFD:
<yellow>		if (!msr_info->host_initiated &&</yellow>
<yellow>		    !guest_cpuid_has(vcpu, X86_FEATURE_XFD))</yellow>
			return 1;

<yellow>		msr_info->data = vcpu->arch.guest_fpu.fpstate->xfd;</yellow>
		break;
	case MSR_IA32_XFD_ERR:
<yellow>		if (!msr_info->host_initiated &&</yellow>
<yellow>		    !guest_cpuid_has(vcpu, X86_FEATURE_XFD))</yellow>
			return 1;

<yellow>		msr_info->data = vcpu->arch.guest_fpu.xfd_err;</yellow>
		break;
#endif
	default:
<blue>		if (kvm_pmu_is_valid_msr(vcpu, msr_info->index))</blue>
<blue>			return kvm_pmu_get_msr(vcpu, msr_info);</blue>
		return KVM_MSR_RET_INVALID;
	}
	return 0;
<blue>}</blue>
EXPORT_SYMBOL_GPL(kvm_get_msr_common);

/*
 * Read or write a bunch of msrs. All parameters are kernel addresses.
 *
 * @return number of msrs set successfully.
 */
static int __msr_io(struct kvm_vcpu *vcpu, struct kvm_msrs *msrs,
		    struct kvm_msr_entry *entries,
		    int (*do_msr)(struct kvm_vcpu *vcpu,
				  unsigned index, u64 *data))
{
	int i;

<blue>	for (i = 0; i < msrs->nmsrs; ++i)</blue>
<blue>		if (do_msr(vcpu, entries[i].index, &entries[i].data))</blue>
			break;

	return i;
}

/*
 * Read or write a bunch of msrs. Parameters are user addresses.
 *
 * @return number of msrs set successfully.
 */
static int msr_io(struct kvm_vcpu *vcpu, struct kvm_msrs __user *user_msrs,
		  int (*do_msr)(struct kvm_vcpu *vcpu,
				unsigned index, u64 *data),
		  int writeback)
<blue>{</blue>
	struct kvm_msrs msrs;
	struct kvm_msr_entry *entries;
	int r, n;
	unsigned size;

	r = -EFAULT;
<blue>	if (copy_from_user(&msrs, user_msrs, sizeof(msrs)))</blue>
		goto out;

	r = -E2BIG;
<blue>	if (msrs.nmsrs >= MAX_IO_MSRS)</blue>
		goto out;

<blue>	size = sizeof(struct kvm_msr_entry) * msrs.nmsrs;</blue>
	entries = memdup_user(user_msrs-&gt;entries, size);
	if (IS_ERR(entries)) {
<yellow>		r = PTR_ERR(entries);</yellow>
		goto out;
	}

<blue>	r = n = __msr_io(vcpu, &msrs, entries, do_msr);</blue>
<blue>	if (r < 0)</blue>
		goto out_free;

	r = -EFAULT;
<blue>	if (writeback && copy_to_user(user_msrs->entries, entries, size))</blue>
		goto out_free;

	r = n;

out_free:
<blue>	kfree(entries);</blue>
out:
	return r;
}

static inline bool kvm_can_mwait_in_guest(void)
{
<yellow>	return boot_cpu_has(X86_FEATURE_MWAIT) &&</yellow>
<yellow>		!boot_cpu_has_bug(X86_BUG_MONITOR) &&</yellow>
<yellow>		boot_cpu_has(X86_FEATURE_ARAT);</yellow>
}

static int kvm_ioctl_get_supported_hv_cpuid(struct kvm_vcpu *vcpu,
					    struct kvm_cpuid2 __user *cpuid_arg)
<blue>{</blue>
	struct kvm_cpuid2 cpuid;
	int r;

	r = -EFAULT;
<blue>	if (copy_from_user(&cpuid, cpuid_arg, sizeof(cpuid)))</blue>
		return r;

<blue>	r = kvm_get_hv_cpuid(vcpu, &cpuid, cpuid_arg->entries);</blue>
	if (r)
		return r;

	r = -EFAULT;
<blue>	if (copy_to_user(cpuid_arg, &cpuid, sizeof(cpuid)))</blue>
		return r;

	return 0;
}

int kvm_vm_ioctl_check_extension(struct kvm *kvm, long ext)
{
	int r = 0;

<blue>	switch (ext) {</blue>
	case KVM_CAP_IRQCHIP:
	case KVM_CAP_HLT:
	case KVM_CAP_MMU_SHADOW_CACHE_CONTROL:
	case KVM_CAP_SET_TSS_ADDR:
	case KVM_CAP_EXT_CPUID:
	case KVM_CAP_EXT_EMUL_CPUID:
	case KVM_CAP_CLOCKSOURCE:
	case KVM_CAP_PIT:
	case KVM_CAP_NOP_IO_DELAY:
	case KVM_CAP_MP_STATE:
	case KVM_CAP_SYNC_MMU:
	case KVM_CAP_USER_NMI:
	case KVM_CAP_REINJECT_CONTROL:
	case KVM_CAP_IRQ_INJECT_STATUS:
	case KVM_CAP_IOEVENTFD:
	case KVM_CAP_IOEVENTFD_NO_LENGTH:
	case KVM_CAP_PIT2:
	case KVM_CAP_PIT_STATE2:
	case KVM_CAP_SET_IDENTITY_MAP_ADDR:
	case KVM_CAP_VCPU_EVENTS:
	case KVM_CAP_HYPERV:
	case KVM_CAP_HYPERV_VAPIC:
	case KVM_CAP_HYPERV_SPIN:
	case KVM_CAP_HYPERV_SYNIC:
	case KVM_CAP_HYPERV_SYNIC2:
	case KVM_CAP_HYPERV_VP_INDEX:
	case KVM_CAP_HYPERV_EVENTFD:
	case KVM_CAP_HYPERV_TLBFLUSH:
	case KVM_CAP_HYPERV_SEND_IPI:
	case KVM_CAP_HYPERV_CPUID:
	case KVM_CAP_HYPERV_ENFORCE_CPUID:
	case KVM_CAP_SYS_HYPERV_CPUID:
	case KVM_CAP_PCI_SEGMENT:
	case KVM_CAP_DEBUGREGS:
	case KVM_CAP_X86_ROBUST_SINGLESTEP:
	case KVM_CAP_XSAVE:
	case KVM_CAP_ASYNC_PF:
	case KVM_CAP_ASYNC_PF_INT:
	case KVM_CAP_GET_TSC_KHZ:
	case KVM_CAP_KVMCLOCK_CTRL:
	case KVM_CAP_READONLY_MEM:
	case KVM_CAP_HYPERV_TIME:
	case KVM_CAP_IOAPIC_POLARITY_IGNORED:
	case KVM_CAP_TSC_DEADLINE_TIMER:
	case KVM_CAP_DISABLE_QUIRKS:
	case KVM_CAP_SET_BOOT_CPU_ID:
 	case KVM_CAP_SPLIT_IRQCHIP:
	case KVM_CAP_IMMEDIATE_EXIT:
	case KVM_CAP_PMU_EVENT_FILTER:
	case KVM_CAP_GET_MSR_FEATURES:
	case KVM_CAP_MSR_PLATFORM_INFO:
	case KVM_CAP_EXCEPTION_PAYLOAD:
	case KVM_CAP_X86_TRIPLE_FAULT_EVENT:
	case KVM_CAP_SET_GUEST_DEBUG:
	case KVM_CAP_LAST_CPU:
	case KVM_CAP_X86_USER_SPACE_MSR:
	case KVM_CAP_X86_MSR_FILTER:
	case KVM_CAP_ENFORCE_PV_FEATURE_CPUID:
#ifdef CONFIG_X86_SGX_KVM
	case KVM_CAP_SGX_ATTRIBUTE:
#endif
	case KVM_CAP_VM_COPY_ENC_CONTEXT_FROM:
	case KVM_CAP_VM_MOVE_ENC_CONTEXT_FROM:
	case KVM_CAP_SREGS2:
	case KVM_CAP_EXIT_ON_EMULATION_FAILURE:
	case KVM_CAP_VCPU_ATTRIBUTES:
	case KVM_CAP_SYS_ATTRIBUTES:
	case KVM_CAP_VAPIC:
	case KVM_CAP_ENABLE_CAP:
	case KVM_CAP_VM_DISABLE_NX_HUGE_PAGES:
		r = 1;
		break;
	case KVM_CAP_EXIT_HYPERCALL:
		r = KVM_EXIT_HYPERCALL_VALID_MASK;
		break;
	case KVM_CAP_SET_GUEST_DEBUG2:
		return KVM_GUESTDBG_VALID_MASK;
#ifdef CONFIG_KVM_XEN
	case KVM_CAP_XEN_HVM:
		r = KVM_XEN_HVM_CONFIG_HYPERCALL_MSR |
		    KVM_XEN_HVM_CONFIG_INTERCEPT_HCALL |
		    KVM_XEN_HVM_CONFIG_SHARED_INFO |
		    KVM_XEN_HVM_CONFIG_EVTCHN_2LEVEL |
		    KVM_XEN_HVM_CONFIG_EVTCHN_SEND;
		if (sched_info_on())
			r |= KVM_XEN_HVM_CONFIG_RUNSTATE;
		break;
#endif
	case KVM_CAP_SYNC_REGS:
		r = KVM_SYNC_X86_VALID_FIELDS;
		break;
	case KVM_CAP_ADJUST_CLOCK:
		r = KVM_CLOCK_VALID_FLAGS;
		break;
	case KVM_CAP_X86_DISABLE_EXITS:
		r |=  KVM_X86_DISABLE_EXITS_HLT | KVM_X86_DISABLE_EXITS_PAUSE |
		      KVM_X86_DISABLE_EXITS_CSTATE;
<yellow>		if(kvm_can_mwait_in_guest())</yellow>
			r |= KVM_X86_DISABLE_EXITS_MWAIT;
		break;
	case KVM_CAP_X86_SMM:
		/* SMBASE is usually relocated above 1M on modern chipsets,
		 * and SMM handlers might indeed rely on 4G segment limits,
		 * so do not report SMM to be available if real mode is
		 * emulated via vm86 mode.  Still, do not go to great lengths
		 * to avoid userspace&#x27;s usage of the feature, because it is a
		 * fringe case that is not enabled except via specific settings
		 * of the module parameters.
		 */
<blue>		r = static_call(kvm_x86_has_emulated_msr)(kvm, MSR_IA32_SMBASE);</blue>
		break;
	case KVM_CAP_NR_VCPUS:
<blue>		r = min_t(unsigned int, num_online_cpus(), KVM_MAX_VCPUS);</blue>
		break;
	case KVM_CAP_MAX_VCPUS:
		r = KVM_MAX_VCPUS;
		break;
	case KVM_CAP_MAX_VCPU_ID:
		r = KVM_MAX_VCPU_IDS;
		break;
	case KVM_CAP_PV_MMU:	/* obsolete */
		r = 0;
		break;
	case KVM_CAP_MCE:
		r = KVM_MAX_MCE_BANKS;
		break;
	case KVM_CAP_XCRS:
<blue>		r = boot_cpu_has(X86_FEATURE_XSAVE);</blue>
		break;
	case KVM_CAP_TSC_CONTROL:
	case KVM_CAP_VM_TSC_CONTROL:
<blue>		r = kvm_caps.has_tsc_control;</blue>
		break;
	case KVM_CAP_X2APIC_API:
		r = KVM_X2APIC_API_VALID_FLAGS;
		break;
	case KVM_CAP_NESTED_STATE:
<blue>		r = kvm_x86_ops.nested_ops->get_state ?</blue>
<blue>			kvm_x86_ops.nested_ops->get_state(NULL, NULL, 0) : 0;</blue>
		break;
	case KVM_CAP_HYPERV_DIRECT_TLBFLUSH:
<yellow>		r = kvm_x86_ops.enable_direct_tlbflush != NULL;</yellow>
		break;
	case KVM_CAP_HYPERV_ENLIGHTENED_VMCS:
<yellow>		r = kvm_x86_ops.nested_ops->enable_evmcs != NULL;</yellow>
		break;
	case KVM_CAP_SMALLER_MAXPHYADDR:
<yellow>		r = (int) allow_smaller_maxphyaddr;</yellow>
		break;
	case KVM_CAP_STEAL_TIME:
		r = sched_info_on();
		break;
	case KVM_CAP_X86_BUS_LOCK_EXIT:
<yellow>		if (kvm_caps.has_bus_lock_exit)</yellow>
			r = KVM_BUS_LOCK_DETECTION_OFF |
			    KVM_BUS_LOCK_DETECTION_EXIT;
		else
			r = 0;
		break;
	case KVM_CAP_XSAVE2: {
		u64 guest_perm = xstate_get_guest_group_perm();

<yellow>		r = xstate_required_size(kvm_caps.supported_xcr0 & guest_perm, false);</yellow>
		if (r &lt; sizeof(struct kvm_xsave))
<blue>			r = sizeof(struct kvm_xsave);</blue>
		break;
	}
	case KVM_CAP_PMU_CAPABILITY:
<yellow>		r = enable_pmu ? KVM_CAP_PMU_VALID_MASK : 0;</yellow>
		break;
	case KVM_CAP_DISABLE_QUIRKS2:
		r = KVM_X86_VALID_QUIRKS;
		break;
	case KVM_CAP_X86_NOTIFY_VMEXIT:
<blue>		r = kvm_caps.has_notify_vmexit;</blue>
		break;
	default:
		break;
	}
	return r;
<blue>}</blue>

static inline void __user *kvm_get_attr_addr(struct kvm_device_attr *attr)
{
<yellow>	void __user *uaddr = (void __user*)(unsigned long)attr->addr;</yellow>

	if ((u64)(unsigned long)uaddr != attr-&gt;addr)
		return ERR_PTR_USR(-EFAULT);
	return uaddr;
}

static int kvm_x86_dev_get_attr(struct kvm_device_attr *attr)
{
	u64 __user *uaddr = kvm_get_attr_addr(attr);

<blue>	if (attr->group)</blue>
		return -ENXIO;

<blue>	if (IS_ERR(uaddr))</blue>
<yellow>		return PTR_ERR(uaddr);</yellow>

<blue>	switch (attr->attr) {</blue>
	case KVM_X86_XCOMP_GUEST_SUPP:
<blue>		if (put_user(kvm_caps.supported_xcr0, uaddr))</blue>
			return -EFAULT;
		return 0;
	default:
		return -ENXIO;
		break;
	}
}

static int kvm_x86_dev_has_attr(struct kvm_device_attr *attr)
{
<yellow>	if (attr->group)</yellow>
		return -ENXIO;

<yellow>	switch (attr->attr) {</yellow>
	case KVM_X86_XCOMP_GUEST_SUPP:
		return 0;
	default:
		return -ENXIO;
	}
}

long kvm_arch_dev_ioctl(struct file *filp,
			unsigned int ioctl, unsigned long arg)
<blue>{</blue>
	void __user *argp = (void __user *)arg;
	long r;

<blue>	switch (ioctl) {</blue>
	case KVM_GET_MSR_INDEX_LIST: {
		struct kvm_msr_list __user *user_msr_list = argp;
		struct kvm_msr_list msr_list;
		unsigned n;

		r = -EFAULT;
<blue>		if (copy_from_user(&msr_list, user_msr_list, sizeof(msr_list)))</blue>
			goto out;
		n = msr_list.nmsrs;
		msr_list.nmsrs = num_msrs_to_save + num_emulated_msrs;
<blue>		if (copy_to_user(user_msr_list, &msr_list, sizeof(msr_list)))</blue>
			goto out;
		r = -E2BIG;
<blue>		if (n < msr_list.nmsrs)</blue>
			goto out;
		r = -EFAULT;
<blue>		if (copy_to_user(user_msr_list->indices, &msrs_to_save,</blue>
				 num_msrs_to_save * sizeof(u32)))
			goto out;
<blue>		if (copy_to_user(user_msr_list->indices + num_msrs_to_save,</blue>
				 &amp;emulated_msrs,
				 num_emulated_msrs * sizeof(u32)))
			goto out;
		r = 0;
		break;
	}
	case KVM_GET_SUPPORTED_CPUID:
	case KVM_GET_EMULATED_CPUID: {
		struct kvm_cpuid2 __user *cpuid_arg = argp;
		struct kvm_cpuid2 cpuid;

		r = -EFAULT;
<blue>		if (copy_from_user(&cpuid, cpuid_arg, sizeof(cpuid)))</blue>
			goto out;

<blue>		r = kvm_dev_ioctl_get_cpuid(&cpuid, cpuid_arg->entries,</blue>
					    ioctl);
		if (r)
			goto out;

		r = -EFAULT;
<blue>		if (copy_to_user(cpuid_arg, &cpuid, sizeof(cpuid)))</blue>
			goto out;
		r = 0;
		break;
	}
	case KVM_X86_GET_MCE_CAP_SUPPORTED:
		r = -EFAULT;
<blue>		if (copy_to_user(argp, &kvm_caps.supported_mce_cap,</blue>
				 sizeof(kvm_caps.supported_mce_cap)))
			goto out;
		r = 0;
		break;
	case KVM_GET_MSR_FEATURE_INDEX_LIST: {
		struct kvm_msr_list __user *user_msr_list = argp;
		struct kvm_msr_list msr_list;
		unsigned int n;

		r = -EFAULT;
<blue>		if (copy_from_user(&msr_list, user_msr_list, sizeof(msr_list)))</blue>
			goto out;
		n = msr_list.nmsrs;
		msr_list.nmsrs = num_msr_based_features;
<blue>		if (copy_to_user(user_msr_list, &msr_list, sizeof(msr_list)))</blue>
			goto out;
		r = -E2BIG;
<blue>		if (n < msr_list.nmsrs)</blue>
			goto out;
		r = -EFAULT;
<blue>		if (copy_to_user(user_msr_list->indices, &msr_based_features,</blue>
				 num_msr_based_features * sizeof(u32)))
			goto out;
<blue>		r = 0;</blue>
		break;
	}
	case KVM_GET_MSRS:
<blue>		r = msr_io(NULL, argp, do_get_msr_feature, 1);</blue>
		break;
	case KVM_GET_SUPPORTED_HV_CPUID:
<blue>		r = kvm_ioctl_get_supported_hv_cpuid(NULL, argp);</blue>
		break;
	case KVM_GET_DEVICE_ATTR: {
		struct kvm_device_attr attr;
		r = -EFAULT;
<blue>		if (copy_from_user(&attr, (void __user *)arg, sizeof(attr)))</blue>
			break;
<blue>		r = kvm_x86_dev_get_attr(&attr);</blue>
		break;
	}
	case KVM_HAS_DEVICE_ATTR: {
		struct kvm_device_attr attr;
		r = -EFAULT;
<yellow>		if (copy_from_user(&attr, (void __user *)arg, sizeof(attr)))</yellow>
			break;
<yellow>		r = kvm_x86_dev_has_attr(&attr);</yellow>
		break;
	}
	default:
		r = -EINVAL;
		break;
	}
out:
<blue>	return r;</blue>
}

static void wbinvd_ipi(void *garbage)
{
<yellow>	wbinvd();</yellow>
}

static bool need_emulate_wbinvd(struct kvm_vcpu *vcpu)
{
<blue>	return kvm_arch_has_noncoherent_dma(vcpu->kvm);</blue>
}

void kvm_arch_vcpu_load(struct kvm_vcpu *vcpu, int cpu)
{
	/* Address WBINVD may be executed by guest */
<blue>	if (need_emulate_wbinvd(vcpu)) {</blue>
<yellow>		if (static_call(kvm_x86_has_wbinvd_exit)())</yellow>
<yellow>			cpumask_set_cpu(cpu, vcpu->arch.wbinvd_dirty_mask);</yellow>
<yellow>		else if (vcpu->cpu != -1 && vcpu->cpu != cpu)</yellow>
<yellow>			smp_call_function_single(vcpu->cpu,</yellow>
					wbinvd_ipi, NULL, 1);
	}

<blue>	static_call(kvm_x86_vcpu_load)(vcpu, cpu);</blue>

	/* Save host pkru register if supported */
<blue>	vcpu->arch.host_pkru = read_pkru();</blue>

	/* Apply any externally detected TSC adjustments (due to suspend) */
	if (unlikely(vcpu-&gt;arch.tsc_offset_adjustment)) {
<yellow>		adjust_tsc_offset_host(vcpu, vcpu->arch.tsc_offset_adjustment);</yellow>
		vcpu-&gt;arch.tsc_offset_adjustment = 0;
		kvm_make_request(KVM_REQ_CLOCK_UPDATE, vcpu);
	}

<blue>	if (unlikely(vcpu->cpu != cpu) || kvm_check_tsc_unstable()) {</blue>
<blue>		s64 tsc_delta = !vcpu->arch.last_host_tsc ? 0 :</blue>
<blue>				rdtsc() - vcpu->arch.last_host_tsc;</blue>
		if (tsc_delta &lt; 0)
<yellow>			mark_tsc_unstable("KVM discovered backwards TSC");</yellow>

<blue>		if (kvm_check_tsc_unstable()) {</blue>
<yellow>			u64 offset = kvm_compute_l1_tsc_offset(vcpu,</yellow>
						vcpu-&gt;arch.last_guest_tsc);
			kvm_vcpu_write_tsc_offset(vcpu, offset);
			vcpu-&gt;arch.tsc_catchup = 1;
		}

<blue>		if (kvm_lapic_hv_timer_in_use(vcpu))</blue>
<yellow>			kvm_lapic_restart_hv_timer(vcpu);</yellow>

		/*
		 * On a host with synchronized TSC, there is no need to update
		 * kvmclock on vcpu-&gt;cpu migration
		 */
<blue>		if (!vcpu->kvm->arch.use_master_clock || vcpu->cpu == -1)</blue>
<blue>			kvm_make_request(KVM_REQ_GLOBAL_CLOCK_UPDATE, vcpu);</blue>
<blue>		if (vcpu->cpu != cpu)</blue>
<blue>			kvm_make_request(KVM_REQ_MIGRATE_TIMER, vcpu);</blue>
<blue>		vcpu->cpu = cpu;</blue>
	}

<blue>	kvm_make_request(KVM_REQ_STEAL_UPDATE, vcpu);</blue>
}

static void kvm_steal_time_set_preempted(struct kvm_vcpu *vcpu)
{
	struct gfn_to_hva_cache *ghc = &amp;vcpu-&gt;arch.st.cache;
	struct kvm_steal_time __user *st;
	struct kvm_memslots *slots;
	static const u8 preempted = KVM_VCPU_PREEMPTED;
<yellow>	gpa_t gpa = vcpu->arch.st.msr_val & KVM_STEAL_VALID_BITS;</yellow>

	/*
	 * The vCPU can be marked preempted if and only if the VM-Exit was on
	 * an instruction boundary and will not trigger guest emulation of any
	 * kind (see vcpu_run).  Vendor specific code controls (conservatively)
	 * when this is true, for example allowing the vCPU to be marked
	 * preempted if and only if the VM-Exit was due to a host interrupt.
	 */
<yellow>	if (!vcpu->arch.at_instruction_boundary) {</yellow>
<yellow>		vcpu->stat.preemption_other++;</yellow>
		return;
	}

<yellow>	vcpu->stat.preemption_reported++;</yellow>
	if (!(vcpu-&gt;arch.st.msr_val &amp; KVM_MSR_ENABLED))
		return;

<yellow>	if (vcpu->arch.st.preempted)</yellow>
		return;

	/* This happens on process exit */
<yellow>	if (unlikely(current->mm != vcpu->kvm->mm))</yellow>
		return;

<yellow>	slots = kvm_memslots(vcpu->kvm);</yellow>

<yellow>	if (unlikely(slots->generation != ghc->generation ||</yellow>
		     gpa != ghc-&gt;gpa ||
		     kvm_is_error_hva(ghc-&gt;hva) || !ghc-&gt;memslot))
		return;

	st = (struct kvm_steal_time __user *)ghc-&gt;hva;
	BUILD_BUG_ON(sizeof(st-&gt;preempted) != sizeof(preempted));

<yellow>	if (!copy_to_user_nofault(&st->preempted, &preempted, sizeof(preempted)))</yellow>
<yellow>		vcpu->arch.st.preempted = KVM_VCPU_PREEMPTED;</yellow>

<yellow>	mark_page_dirty_in_slot(vcpu->kvm, ghc->memslot, gpa_to_gfn(ghc->gpa));</yellow>
}

void kvm_arch_vcpu_put(struct kvm_vcpu *vcpu)
{
	int idx;

<blue>	if (vcpu->preempted) {</blue>
<yellow>		if (!vcpu->arch.guest_state_protected)</yellow>
<yellow>			vcpu->arch.preempted_in_kernel = !static_call(kvm_x86_get_cpl)(vcpu);</yellow>

		/*
		 * Take the srcu lock as memslots will be accessed to check the gfn
		 * cache generation against the memslots generation.
		 */
<yellow>		idx = srcu_read_lock(&vcpu->kvm->srcu);</yellow>
<yellow>		if (kvm_xen_msr_enabled(vcpu->kvm))</yellow>
<yellow>			kvm_xen_runstate_set_preempted(vcpu);</yellow>
		else
<yellow>			kvm_steal_time_set_preempted(vcpu);</yellow>
<yellow>		srcu_read_unlock(&vcpu->kvm->srcu, idx);</yellow>
	}

<blue>	static_call(kvm_x86_vcpu_put)(vcpu);</blue>
	vcpu-&gt;arch.last_host_tsc = rdtsc();
}

static int kvm_vcpu_ioctl_get_lapic(struct kvm_vcpu *vcpu,
				    struct kvm_lapic_state *s)
{
<blue>	static_call_cond(kvm_x86_sync_pir_to_irr)(vcpu);</blue>

	return kvm_apic_get_state(vcpu, s);
}

static int kvm_vcpu_ioctl_set_lapic(struct kvm_vcpu *vcpu,
				    struct kvm_lapic_state *s)
{
	int r;

<blue>	r = kvm_apic_set_state(vcpu, s);</blue>
	if (r)
		return r;
<blue>	update_cr8_intercept(vcpu);</blue>

	return 0;
}

<yellow>static int kvm_cpu_accept_dm_intr(struct kvm_vcpu *vcpu)</yellow>
{
	/*
	 * We can accept userspace&#x27;s request for interrupt injection
	 * as long as we have a place to store the interrupt number.
	 * The actual injection will happen when the CPU is able to
	 * deliver the interrupt.
	 */
<yellow>	if (kvm_cpu_has_extint(vcpu))</yellow>
		return false;

	/* Acknowledging ExtINT does not happen if LINT0 is masked.  */
<yellow>	return (!lapic_in_kernel(vcpu) ||</yellow>
<yellow>		kvm_apic_accept_pic_intr(vcpu));</yellow>
}

<yellow>static int kvm_vcpu_ready_for_interrupt_injection(struct kvm_vcpu *vcpu)</yellow>
{
	/*
	 * Do not cause an interrupt window exit if an exception
	 * is pending or an event needs reinjection; userspace
	 * might want to inject the interrupt manually using KVM_SET_REGS
	 * or KVM_SET_SREGS.  For that to work, we must be at an
	 * instruction boundary and with no events half-injected.
	 */
<yellow>	return (kvm_arch_interrupt_allowed(vcpu) &&</yellow>
<yellow>		kvm_cpu_accept_dm_intr(vcpu) &&</yellow>
<yellow>		!kvm_event_needs_reinjection(vcpu) &&</yellow>
<yellow>		!kvm_is_exception_pending(vcpu));</yellow>
<yellow>}</yellow>

static int kvm_vcpu_ioctl_interrupt(struct kvm_vcpu *vcpu,
				    struct kvm_interrupt *irq)
{
<yellow>	if (irq->irq >= KVM_NR_INTERRUPTS)</yellow>
		return -EINVAL;

<yellow>	if (!irqchip_in_kernel(vcpu->kvm)) {</yellow>
<yellow>		kvm_queue_interrupt(vcpu, irq->irq, false);</yellow>
		kvm_make_request(KVM_REQ_EVENT, vcpu);
		return 0;
	}

	/*
	 * With in-kernel LAPIC, we only use this to inject EXTINT, so
	 * fail for in-kernel 8259.
	 */
<yellow>	if (pic_in_kernel(vcpu->kvm))</yellow>
		return -ENXIO;

<yellow>	if (vcpu->arch.pending_external_vector != -1)</yellow>
		return -EEXIST;

<yellow>	vcpu->arch.pending_external_vector = irq->irq;</yellow>
	kvm_make_request(KVM_REQ_EVENT, vcpu);
	return 0;
}

static int kvm_vcpu_ioctl_nmi(struct kvm_vcpu *vcpu)
{
<yellow>	kvm_inject_nmi(vcpu);</yellow>

	return 0;
}

static int kvm_vcpu_ioctl_smi(struct kvm_vcpu *vcpu)
{
<yellow>	kvm_make_request(KVM_REQ_SMI, vcpu);</yellow>

	return 0;
}

static int vcpu_ioctl_tpr_access_reporting(struct kvm_vcpu *vcpu,
					   struct kvm_tpr_access_ctl *tac)
{
<blue>	if (tac->flags)</blue>
		return -EINVAL;
<blue>	vcpu->arch.tpr_access_reporting = !!tac->enabled;</blue>
	return 0;
}

static int kvm_vcpu_ioctl_x86_setup_mce(struct kvm_vcpu *vcpu,
					u64 mcg_cap)
{
	int r;
	unsigned bank_num = mcg_cap &amp; 0xff, bank;

	r = -EINVAL;
	if (!bank_num || bank_num &gt; KVM_MAX_MCE_BANKS)
		goto out;
<blue>	if (mcg_cap & ~(kvm_caps.supported_mce_cap | 0xff | 0xff0000))</blue>
		goto out;
	r = 0;
<blue>	vcpu->arch.mcg_cap = mcg_cap;</blue>
	/* Init IA32_MCG_CTL to all 1s */
	if (mcg_cap &amp; MCG_CTL_P)
<blue>		vcpu->arch.mcg_ctl = ~(u64)0;</blue>
	/* Init IA32_MCi_CTL to all 1s, IA32_MCi_CTL2 to all 0s */
<blue>	for (bank = 0; bank < bank_num; bank++) {</blue>
<blue>		vcpu->arch.mce_banks[bank*4] = ~(u64)0;</blue>
<blue>		if (mcg_cap & MCG_CMCI_P)</blue>
<yellow>			vcpu->arch.mci_ctl2_banks[bank] = 0;</yellow>
	}

<blue>	kvm_apic_after_set_mcg_cap(vcpu);</blue>

	static_call(kvm_x86_setup_mce)(vcpu);
out:
	return r;
}

/*
 * Validate this is an UCNA (uncorrectable no action) error by checking the
 * MCG_STATUS and MCi_STATUS registers:
 * - none of the bits for Machine Check Exceptions are set
 * - both the VAL (valid) and UC (uncorrectable) bits are set
 * MCI_STATUS_PCC - Processor Context Corrupted
 * MCI_STATUS_S - Signaled as a Machine Check Exception
 * MCI_STATUS_AR - Software recoverable Action Required
 */
static bool is_ucna(struct kvm_x86_mce *mce)
{
	return	!mce-&gt;mcg_status &amp;&amp;
		!(mce-&gt;status &amp; (MCI_STATUS_PCC | MCI_STATUS_S | MCI_STATUS_AR)) &amp;&amp;
<yellow>		(mce->status & MCI_STATUS_VAL) &&</yellow>
		(mce-&gt;status &amp; MCI_STATUS_UC);
}

static int kvm_vcpu_x86_set_ucna(struct kvm_vcpu *vcpu, struct kvm_x86_mce *mce, u64* banks)
{
	u64 mcg_cap = vcpu-&gt;arch.mcg_cap;

<yellow>	banks[1] = mce->status;</yellow>
	banks[2] = mce-&gt;addr;
	banks[3] = mce-&gt;misc;
	vcpu-&gt;arch.mcg_status = mce-&gt;mcg_status;

	if (!(mcg_cap &amp; MCG_CMCI_P) ||
<yellow>	    !(vcpu->arch.mci_ctl2_banks[mce->bank] & MCI_CTL2_CMCI_EN))</yellow>
		return 0;

<yellow>	if (lapic_in_kernel(vcpu))</yellow>
<yellow>		kvm_apic_local_deliver(vcpu->arch.apic, APIC_LVTCMCI);</yellow>

	return 0;
}

static int kvm_vcpu_ioctl_x86_set_mce(struct kvm_vcpu *vcpu,
				      struct kvm_x86_mce *mce)
{
<yellow>	u64 mcg_cap = vcpu->arch.mcg_cap;</yellow>
	unsigned bank_num = mcg_cap &amp; 0xff;
	u64 *banks = vcpu-&gt;arch.mce_banks;

<yellow>	if (mce->bank >= bank_num || !(mce->status & MCI_STATUS_VAL))</yellow>
		return -EINVAL;

<yellow>	banks += array_index_nospec(4 * mce->bank, 4 * bank_num);</yellow>

<yellow>	if (is_ucna(mce))</yellow>
<yellow>		return kvm_vcpu_x86_set_ucna(vcpu, mce, banks);</yellow>

	/*
	 * if IA32_MCG_CTL is not all 1s, the uncorrected error
	 * reporting is disabled
	 */
<yellow>	if ((mce->status & MCI_STATUS_UC) && (mcg_cap & MCG_CTL_P) &&</yellow>
<yellow>	    vcpu->arch.mcg_ctl != ~(u64)0)</yellow>
		return 0;
	/*
	 * if IA32_MCi_CTL is not all 1s, the uncorrected error
	 * reporting is disabled for the bank
	 */
<yellow>	if ((mce->status & MCI_STATUS_UC) && banks[0] != ~(u64)0)</yellow>
		return 0;
	if (mce-&gt;status &amp; MCI_STATUS_UC) {
<yellow>		if ((vcpu->arch.mcg_status & MCG_STATUS_MCIP) ||</yellow>
<yellow>		    !kvm_read_cr4_bits(vcpu, X86_CR4_MCE)) {</yellow>
<yellow>			kvm_make_request(KVM_REQ_TRIPLE_FAULT, vcpu);</yellow>
			return 0;
		}
<yellow>		if (banks[1] & MCI_STATUS_VAL)</yellow>
<yellow>			mce->status |= MCI_STATUS_OVER;</yellow>
<yellow>		banks[2] = mce->addr;</yellow>
		banks[3] = mce-&gt;misc;
		vcpu-&gt;arch.mcg_status = mce-&gt;mcg_status;
		banks[1] = mce-&gt;status;
		kvm_queue_exception(vcpu, MC_VECTOR);
<yellow>	} else if (!(banks[1] & MCI_STATUS_VAL)</yellow>
<yellow>		   || !(banks[1] & MCI_STATUS_UC)) {</yellow>
		if (banks[1] &amp; MCI_STATUS_VAL)
<yellow>			mce->status |= MCI_STATUS_OVER;</yellow>
<yellow>		banks[2] = mce->addr;</yellow>
		banks[3] = mce-&gt;misc;
		banks[1] = mce-&gt;status;
	} else
<yellow>		banks[1] |= MCI_STATUS_OVER;</yellow>
	return 0;
}

static void kvm_vcpu_ioctl_x86_get_vcpu_events(struct kvm_vcpu *vcpu,
					       struct kvm_vcpu_events *events)
{
	struct kvm_queued_exception *ex;

<blue>	process_nmi(vcpu);</blue>

<yellow>	if (kvm_check_request(KVM_REQ_SMI, vcpu))</yellow>
		process_smi(vcpu);

	/*
	 * KVM&#x27;s ABI only allows for one exception to be migrated.  Luckily,
	 * the only time there can be two queued exceptions is if there&#x27;s a
	 * non-exiting _injected_ exception, and a pending exiting exception.
	 * In that case, ignore the VM-Exiting exception as it&#x27;s an extension
	 * of the injected exception.
	 */
<blue>	if (vcpu->arch.exception_vmexit.pending &&</blue>
<yellow>	    !vcpu->arch.exception.pending &&</yellow>
<yellow>	    !vcpu->arch.exception.injected)</yellow>
<yellow>		ex = &vcpu->arch.exception_vmexit;</yellow>
	else
<blue>		ex = &vcpu->arch.exception;</blue>

	/*
	 * In guest mode, payload delivery should be deferred if the exception
	 * will be intercepted by L1, e.g. KVM should not modifying CR2 if L1
	 * intercepts #PF, ditto for DR6 and #DBs.  If the per-VM capability,
	 * KVM_CAP_EXCEPTION_PAYLOAD, is not set, userspace may or may not
	 * propagate the payload and so it cannot be safely deferred.  Deliver
	 * the payload if the capability hasn&#x27;t been requested.
	 */
<blue>	if (!vcpu->kvm->arch.exception_payload_enabled &&</blue>
<yellow>	    ex->pending && ex->has_payload)</yellow>
<yellow>		kvm_deliver_exception_payload(vcpu, ex);</yellow>

	/*
	 * The API doesn&#x27;t provide the instruction length for software
	 * exceptions, so don&#x27;t report them. As long as the guest RIP
	 * isn&#x27;t advanced, we should expect to encounter the exception
	 * again.
	 */
<blue>	if (kvm_exception_is_soft(ex->vector)) {</blue>
<yellow>		events->exception.injected = 0;</yellow>
		events-&gt;exception.pending = 0;
	} else {
<blue>		events->exception.injected = ex->injected;</blue>
<blue>		events->exception.pending = ex->pending;</blue>
		/*
		 * For ABI compatibility, deliberately conflate
		 * pending and injected exceptions when
		 * KVM_CAP_EXCEPTION_PAYLOAD isn&#x27;t enabled.
		 */
<blue>		if (!vcpu->kvm->arch.exception_payload_enabled)</blue>
<yellow>			events->exception.injected |= ex->pending;</yellow>
	}
<blue>	events->exception.nr = ex->vector;</blue>
<blue>	events->exception.has_error_code = ex->has_error_code;</blue>
	events-&gt;exception.error_code = ex-&gt;error_code;
<blue>	events->exception_has_payload = ex->has_payload;</blue>
	events-&gt;exception_payload = ex-&gt;payload;

<blue>	events->interrupt.injected =</blue>
<blue>		vcpu->arch.interrupt.injected && !vcpu->arch.interrupt.soft;</blue>
	events-&gt;interrupt.nr = vcpu-&gt;arch.interrupt.nr;
	events-&gt;interrupt.soft = 0;
	events-&gt;interrupt.shadow = static_call(kvm_x86_get_interrupt_shadow)(vcpu);

<blue>	events->nmi.injected = vcpu->arch.nmi_injected;</blue>
	events-&gt;nmi.pending = vcpu-&gt;arch.nmi_pending != 0;
	events-&gt;nmi.masked = static_call(kvm_x86_get_nmi_mask)(vcpu);
	events-&gt;nmi.pad = 0;

	events-&gt;sipi_vector = 0; /* never valid when reporting to user space */

	events-&gt;smi.smm = is_smm(vcpu);
<blue>	events->smi.pending = vcpu->arch.smi_pending;</blue>
	events-&gt;smi.smm_inside_nmi =
		!!(vcpu-&gt;arch.hflags &amp; HF_SMM_INSIDE_NMI_MASK);
<blue>	events->smi.latched_init = kvm_lapic_latched_init(vcpu);</blue>

	events-&gt;flags = (KVM_VCPUEVENT_VALID_NMI_PENDING
			 | KVM_VCPUEVENT_VALID_SHADOW
			 | KVM_VCPUEVENT_VALID_SMM);
<blue>	if (vcpu->kvm->arch.exception_payload_enabled)</blue>
<blue>		events->flags |= KVM_VCPUEVENT_VALID_PAYLOAD;</blue>
<blue>	if (vcpu->kvm->arch.triple_fault_event) {</blue>
<yellow>		events->triple_fault.pending = kvm_test_request(KVM_REQ_TRIPLE_FAULT, vcpu);</yellow>
		events-&gt;flags |= KVM_VCPUEVENT_VALID_TRIPLE_FAULT;
	}

<blue>	memset(&events->reserved, 0, sizeof(events->reserved));</blue>
}

static void kvm_smm_changed(struct kvm_vcpu *vcpu, bool entering_smm);

static int kvm_vcpu_ioctl_x86_set_vcpu_events(struct kvm_vcpu *vcpu,
					      struct kvm_vcpu_events *events)
{
<blue>	if (events->flags & ~(KVM_VCPUEVENT_VALID_NMI_PENDING</blue>
			      | KVM_VCPUEVENT_VALID_SIPI_VECTOR
			      | KVM_VCPUEVENT_VALID_SHADOW
			      | KVM_VCPUEVENT_VALID_SMM
			      | KVM_VCPUEVENT_VALID_PAYLOAD
			      | KVM_VCPUEVENT_VALID_TRIPLE_FAULT))
		return -EINVAL;

<blue>	if (events->flags & KVM_VCPUEVENT_VALID_PAYLOAD) {</blue>
<blue>		if (!vcpu->kvm->arch.exception_payload_enabled)</blue>
			return -EINVAL;
<blue>		if (events->exception.pending)</blue>
<yellow>			events->exception.injected = 0;</yellow>
		else
<blue>			events->exception_has_payload = 0;</blue>
	} else {
<yellow>		events->exception.pending = 0;</yellow>
		events-&gt;exception_has_payload = 0;
	}

<blue>	if ((events->exception.injected || events->exception.pending) &&</blue>
<yellow>	    (events->exception.nr > 31 || events->exception.nr == NMI_VECTOR))</yellow>
		return -EINVAL;

	/* INITs are latched while in SMM */
<blue>	if (events->flags & KVM_VCPUEVENT_VALID_SMM &&</blue>
<blue>	    (events->smi.smm || events->smi.pending) &&</blue>
<yellow>	    vcpu->arch.mp_state == KVM_MP_STATE_INIT_RECEIVED)</yellow>
		return -EINVAL;

<blue>	process_nmi(vcpu);</blue>

	/*
	 * Flag that userspace is stuffing an exception, the next KVM_RUN will
	 * morph the exception to a VM-Exit if appropriate.  Do this only for
	 * pending exceptions, already-injected exceptions are not subject to
	 * intercpetion.  Note, userspace that conflates pending and injected
	 * is hosed, and will incorrectly convert an injected exception into a
	 * pending exception, which in turn may cause a spurious VM-Exit.
	 */
	vcpu-&gt;arch.exception_from_userspace = events-&gt;exception.pending;

	vcpu-&gt;arch.exception_vmexit.pending = false;

	vcpu-&gt;arch.exception.injected = events-&gt;exception.injected;
	vcpu-&gt;arch.exception.pending = events-&gt;exception.pending;
	vcpu-&gt;arch.exception.vector = events-&gt;exception.nr;
	vcpu-&gt;arch.exception.has_error_code = events-&gt;exception.has_error_code;
	vcpu-&gt;arch.exception.error_code = events-&gt;exception.error_code;
	vcpu-&gt;arch.exception.has_payload = events-&gt;exception_has_payload;
	vcpu-&gt;arch.exception.payload = events-&gt;exception_payload;

	vcpu-&gt;arch.interrupt.injected = events-&gt;interrupt.injected;
	vcpu-&gt;arch.interrupt.nr = events-&gt;interrupt.nr;
	vcpu-&gt;arch.interrupt.soft = events-&gt;interrupt.soft;
	if (events-&gt;flags &amp; KVM_VCPUEVENT_VALID_SHADOW)
		static_call(kvm_x86_set_interrupt_shadow)(vcpu,
<blue>						events->interrupt.shadow);</blue>

<blue>	vcpu->arch.nmi_injected = events->nmi.injected;</blue>
	if (events-&gt;flags &amp; KVM_VCPUEVENT_VALID_NMI_PENDING)
<blue>		vcpu->arch.nmi_pending = events->nmi.pending;</blue>
<blue>	static_call(kvm_x86_set_nmi_mask)(vcpu, events->nmi.masked);</blue>

	if (events-&gt;flags &amp; KVM_VCPUEVENT_VALID_SIPI_VECTOR &amp;&amp;
<yellow>	    lapic_in_kernel(vcpu))</yellow>
<yellow>		vcpu->arch.apic->sipi_vector = events->sipi_vector;</yellow>

<blue>	if (events->flags & KVM_VCPUEVENT_VALID_SMM) {</blue>
<blue>		if (!!(vcpu->arch.hflags & HF_SMM_MASK) != events->smi.smm) {</blue>
<yellow>			kvm_leave_nested(vcpu);</yellow>
			kvm_smm_changed(vcpu, events-&gt;smi.smm);
		}

<blue>		vcpu->arch.smi_pending = events->smi.pending;</blue>

		if (events-&gt;smi.smm) {
<yellow>			if (events->smi.smm_inside_nmi)</yellow>
<yellow>				vcpu->arch.hflags |= HF_SMM_INSIDE_NMI_MASK;</yellow>
			else
<yellow>				vcpu->arch.hflags &= ~HF_SMM_INSIDE_NMI_MASK;</yellow>
		}

<blue>		if (lapic_in_kernel(vcpu)) {</blue>
<blue>			if (events->smi.latched_init)</blue>
<yellow>				set_bit(KVM_APIC_INIT, &vcpu->arch.apic->pending_events);</yellow>
			else
<blue>				clear_bit(KVM_APIC_INIT, &vcpu->arch.apic->pending_events);</blue>
		}
	}

<blue>	if (events->flags & KVM_VCPUEVENT_VALID_TRIPLE_FAULT) {</blue>
<yellow>		if (!vcpu->kvm->arch.triple_fault_event)</yellow>
			return -EINVAL;
<yellow>		if (events->triple_fault.pending)</yellow>
<blue>			kvm_make_request(KVM_REQ_TRIPLE_FAULT, vcpu);</blue>
		else
<yellow>			kvm_clear_request(KVM_REQ_TRIPLE_FAULT, vcpu);</yellow>
	}

<blue>	kvm_make_request(KVM_REQ_EVENT, vcpu);</blue>

	return 0;
<blue>}</blue>

static void kvm_vcpu_ioctl_x86_get_debugregs(struct kvm_vcpu *vcpu,
					     struct kvm_debugregs *dbgregs)
{
	unsigned long val;

<blue>	memcpy(dbgregs->db, vcpu->arch.db, sizeof(vcpu->arch.db));</blue>
	kvm_get_dr(vcpu, 6, &amp;val);
	dbgregs-&gt;dr6 = val;
	dbgregs-&gt;dr7 = vcpu-&gt;arch.dr7;
	dbgregs-&gt;flags = 0;
	memset(&amp;dbgregs-&gt;reserved, 0, sizeof(dbgregs-&gt;reserved));
}

static int kvm_vcpu_ioctl_x86_set_debugregs(struct kvm_vcpu *vcpu,
					    struct kvm_debugregs *dbgregs)
{
	if (dbgregs-&gt;flags)
		return -EINVAL;

<blue>	if (!kvm_dr6_valid(dbgregs->dr6))</blue>
		return -EINVAL;
	if (!kvm_dr7_valid(dbgregs-&gt;dr7))
		return -EINVAL;

<blue>	memcpy(vcpu->arch.db, dbgregs->db, sizeof(vcpu->arch.db));</blue>
<blue>	kvm_update_dr0123(vcpu);</blue>
<yellow>	vcpu->arch.dr6 = dbgregs->dr6;</yellow>
	vcpu-&gt;arch.dr7 = dbgregs-&gt;dr7;
<blue>	kvm_update_dr7(vcpu);</blue>

	return 0;
}

static void kvm_vcpu_ioctl_x86_get_xsave(struct kvm_vcpu *vcpu,
					 struct kvm_xsave *guest_xsave)
{
<blue>	if (fpstate_is_confidential(&vcpu->arch.guest_fpu))</blue>
		return;

<blue>	fpu_copy_guest_fpstate_to_uabi(&vcpu->arch.guest_fpu,</blue>
				       guest_xsave-&gt;region,
				       sizeof(guest_xsave-&gt;region),
				       vcpu-&gt;arch.pkru);
}

static void kvm_vcpu_ioctl_x86_get_xsave2(struct kvm_vcpu *vcpu,
					  u8 *state, unsigned int size)
{
<blue>	if (fpstate_is_confidential(&vcpu->arch.guest_fpu))</blue>
		return;

<blue>	fpu_copy_guest_fpstate_to_uabi(&vcpu->arch.guest_fpu,</blue>
				       state, size, vcpu-&gt;arch.pkru);
}

static int kvm_vcpu_ioctl_x86_set_xsave(struct kvm_vcpu *vcpu,
					struct kvm_xsave *guest_xsave)
{
<blue>	if (fpstate_is_confidential(&vcpu->arch.guest_fpu))</blue>
		return 0;

<blue>	return fpu_copy_uabi_to_guest_fpstate(&vcpu->arch.guest_fpu,</blue>
					      guest_xsave-&gt;region,
					      kvm_caps.supported_xcr0,
					      &amp;vcpu-&gt;arch.pkru);
}

static void kvm_vcpu_ioctl_x86_get_xcrs(struct kvm_vcpu *vcpu,
					struct kvm_xcrs *guest_xcrs)
{
<blue>	if (!boot_cpu_has(X86_FEATURE_XSAVE)) {</blue>
<yellow>		guest_xcrs->nr_xcrs = 0;</yellow>
		return;
	}

<blue>	guest_xcrs->nr_xcrs = 1;</blue>
	guest_xcrs-&gt;flags = 0;
	guest_xcrs-&gt;xcrs[0].xcr = XCR_XFEATURE_ENABLED_MASK;
	guest_xcrs-&gt;xcrs[0].value = vcpu-&gt;arch.xcr0;
}

static int kvm_vcpu_ioctl_x86_set_xcrs(struct kvm_vcpu *vcpu,
				       struct kvm_xcrs *guest_xcrs)
{
	int i, r = 0;

<blue>	if (!boot_cpu_has(X86_FEATURE_XSAVE))</blue>
		return -EINVAL;

<blue>	if (guest_xcrs->nr_xcrs > KVM_MAX_XCRS || guest_xcrs->flags)</blue>
		return -EINVAL;

<blue>	for (i = 0; i < guest_xcrs->nr_xcrs; i++)</blue>
		/* Only support XCR0 currently */
<blue>		if (guest_xcrs->xcrs[i].xcr == XCR_XFEATURE_ENABLED_MASK) {</blue>
			r = __kvm_set_xcr(vcpu, XCR_XFEATURE_ENABLED_MASK,
<blue>				guest_xcrs->xcrs[i].value);</blue>
			break;
		}
	if (r)
		r = -EINVAL;
	return r;
}

/*
 * kvm_set_guest_paused() indicates to the guest kernel that it has been
 * stopped by the hypervisor.  This function will be called from the host only.
 * EINVAL is returned when the host attempts to set the flag for a guest that
 * does not support pv clocks.
 */
static int kvm_set_guest_paused(struct kvm_vcpu *vcpu)
{
<blue>	if (!vcpu->arch.pv_time.active)</blue>
		return -EINVAL;
<yellow>	vcpu->arch.pvclock_set_guest_stopped_request = true;</yellow>
	kvm_make_request(KVM_REQ_CLOCK_UPDATE, vcpu);
	return 0;
}

static int kvm_arch_tsc_has_attr(struct kvm_vcpu *vcpu,
				 struct kvm_device_attr *attr)
{
	int r;

<yellow>	switch (attr->attr) {</yellow>
	case KVM_VCPU_TSC_OFFSET:
		r = 0;
		break;
	default:
		r = -ENXIO;
	}

	return r;
}

static int kvm_arch_tsc_get_attr(struct kvm_vcpu *vcpu,
				 struct kvm_device_attr *attr)
{
<yellow>	u64 __user *uaddr = kvm_get_attr_addr(attr);</yellow>
	int r;

	if (IS_ERR(uaddr))
		return PTR_ERR(uaddr);

<yellow>	switch (attr->attr) {</yellow>
	case KVM_VCPU_TSC_OFFSET:
		r = -EFAULT;
<yellow>		if (put_user(vcpu->arch.l1_tsc_offset, uaddr))</yellow>
			break;
		r = 0;
		break;
	default:
		r = -ENXIO;
	}

	return r;
}

static int kvm_arch_tsc_set_attr(struct kvm_vcpu *vcpu,
				 struct kvm_device_attr *attr)
{
	u64 __user *uaddr = kvm_get_attr_addr(attr);
<yellow>	struct kvm *kvm = vcpu->kvm;</yellow>
	int r;

	if (IS_ERR(uaddr))
<yellow>		return PTR_ERR(uaddr);</yellow>

<yellow>	switch (attr->attr) {</yellow>
	case KVM_VCPU_TSC_OFFSET: {
		u64 offset, tsc, ns;
		unsigned long flags;
		bool matched;

		r = -EFAULT;
<yellow>		if (get_user(offset, uaddr))</yellow>
			break;

<yellow>		raw_spin_lock_irqsave(&kvm->arch.tsc_write_lock, flags);</yellow>

		matched = (vcpu-&gt;arch.virtual_tsc_khz &amp;&amp;
<yellow>			   kvm->arch.last_tsc_khz == vcpu->arch.virtual_tsc_khz &&</yellow>
<yellow>			   kvm->arch.last_tsc_offset == offset);</yellow>

<yellow>		tsc = kvm_scale_tsc(rdtsc(), vcpu->arch.l1_tsc_scaling_ratio) + offset;</yellow>
		ns = get_kvmclock_base_ns();

		__kvm_synchronize_tsc(vcpu, offset, tsc, ns, matched);
		raw_spin_unlock_irqrestore(&amp;kvm-&gt;arch.tsc_write_lock, flags);

		r = 0;
		break;
	}
	default:
		r = -ENXIO;
	}

	return r;
}

static int kvm_vcpu_ioctl_device_attr(struct kvm_vcpu *vcpu,
				      unsigned int ioctl,
				      void __user *argp)
{
	struct kvm_device_attr attr;
	int r;

<yellow>	if (copy_from_user(&attr, argp, sizeof(attr)))</yellow>
		return -EFAULT;

<yellow>	if (attr.group != KVM_VCPU_TSC_CTRL)</yellow>
		return -ENXIO;

<yellow>	switch (ioctl) {</yellow>
	case KVM_HAS_DEVICE_ATTR:
<yellow>		r = kvm_arch_tsc_has_attr(vcpu, &attr);</yellow>
		break;
	case KVM_GET_DEVICE_ATTR:
<yellow>		r = kvm_arch_tsc_get_attr(vcpu, &attr);</yellow>
		break;
	case KVM_SET_DEVICE_ATTR:
<yellow>		r = kvm_arch_tsc_set_attr(vcpu, &attr);</yellow>
		break;
	}

	return r;
}

static int kvm_vcpu_ioctl_enable_cap(struct kvm_vcpu *vcpu,
				     struct kvm_enable_cap *cap)
{
	int r;
	uint16_t vmcs_version;
	void __user *user_ptr;

<blue>	if (cap->flags)</blue>
		return -EINVAL;

<blue>	switch (cap->cap) {</blue>
	case KVM_CAP_HYPERV_SYNIC2:
<blue>		if (cap->args[0])</blue>
			return -EINVAL;
		fallthrough;

	case KVM_CAP_HYPERV_SYNIC:
<blue>		if (!irqchip_in_kernel(vcpu->kvm))</blue>
			return -EINVAL;
<blue>		return kvm_hv_activate_synic(vcpu, cap->cap ==</blue>
					     KVM_CAP_HYPERV_SYNIC2);
	case KVM_CAP_HYPERV_ENLIGHTENED_VMCS:
<yellow>		if (!kvm_x86_ops.nested_ops->enable_evmcs)</yellow>
			return -ENOTTY;
<yellow>		r = kvm_x86_ops.nested_ops->enable_evmcs(vcpu, &vmcs_version);</yellow>
		if (!r) {
			user_ptr = (void __user *)(uintptr_t)cap-&gt;args[0];
<yellow>			if (copy_to_user(user_ptr, &vmcs_version,</yellow>
					 sizeof(vmcs_version)))
				r = -EFAULT;
		}
		return r;
	case KVM_CAP_HYPERV_DIRECT_TLBFLUSH:
<yellow>		if (!kvm_x86_ops.enable_direct_tlbflush)</yellow>
			return -ENOTTY;

<yellow>		return static_call(kvm_x86_enable_direct_tlbflush)(vcpu);</yellow>

	case KVM_CAP_HYPERV_ENFORCE_CPUID:
<blue>		return kvm_hv_set_enforce_cpuid(vcpu, cap->args[0]);</blue>

	case KVM_CAP_ENFORCE_PV_FEATURE_CPUID:
<yellow>		vcpu->arch.pv_cpuid.enforce = cap->args[0];</yellow>
<yellow>		if (vcpu->arch.pv_cpuid.enforce)</yellow>
<yellow>			kvm_update_pv_runtime(vcpu);</yellow>

		return 0;
	default:
		return -EINVAL;
	}
}

long kvm_arch_vcpu_ioctl(struct file *filp,
			 unsigned int ioctl, unsigned long arg)
{
<blue>	struct kvm_vcpu *vcpu = filp->private_data;</blue>
	void __user *argp = (void __user *)arg;
	int r;
	union {
		struct kvm_sregs2 *sregs2;
		struct kvm_lapic_state *lapic;
		struct kvm_xsave *xsave;
		struct kvm_xcrs *xcrs;
		void *buffer;
	} u;

	vcpu_load(vcpu);

<blue>	u.buffer = NULL;</blue>
	switch (ioctl) {
	case KVM_GET_LAPIC: {
		r = -EINVAL;
<blue>		if (!lapic_in_kernel(vcpu))</blue>
			goto out;
<blue>		u.lapic = kzalloc(sizeof(struct kvm_lapic_state),</blue>
				GFP_KERNEL_ACCOUNT);

		r = -ENOMEM;
		if (!u.lapic)
			goto out;
<blue>		r = kvm_vcpu_ioctl_get_lapic(vcpu, u.lapic);</blue>
		if (r)
			goto out;
		r = -EFAULT;
<blue>		if (copy_to_user(argp, u.lapic, sizeof(struct kvm_lapic_state)))</blue>
			goto out;
		r = 0;
		break;
	}
	case KVM_SET_LAPIC: {
		r = -EINVAL;
<blue>		if (!lapic_in_kernel(vcpu))</blue>
			goto out;
<blue>		u.lapic = memdup_user(argp, sizeof(*u.lapic));</blue>
		if (IS_ERR(u.lapic)) {
			r = PTR_ERR(u.lapic);
			goto out_nofree;
		}

<blue>		r = kvm_vcpu_ioctl_set_lapic(vcpu, u.lapic);</blue>
		break;
	}
	case KVM_INTERRUPT: {
		struct kvm_interrupt irq;

		r = -EFAULT;
<yellow>		if (copy_from_user(&irq, argp, sizeof(irq)))</yellow>
			goto out;
<yellow>		r = kvm_vcpu_ioctl_interrupt(vcpu, &irq);</yellow>
		break;
	}
	case KVM_NMI: {
<yellow>		r = kvm_vcpu_ioctl_nmi(vcpu);</yellow>
		break;
	}
	case KVM_SMI: {
<yellow>		r = kvm_vcpu_ioctl_smi(vcpu);</yellow>
		break;
	}
	case KVM_SET_CPUID: {
		struct kvm_cpuid __user *cpuid_arg = argp;
		struct kvm_cpuid cpuid;

		r = -EFAULT;
<yellow>		if (copy_from_user(&cpuid, cpuid_arg, sizeof(cpuid)))</yellow>
			goto out;
<yellow>		r = kvm_vcpu_ioctl_set_cpuid(vcpu, &cpuid, cpuid_arg->entries);</yellow>
		break;
	}
	case KVM_SET_CPUID2: {
		struct kvm_cpuid2 __user *cpuid_arg = argp;
		struct kvm_cpuid2 cpuid;

		r = -EFAULT;
<blue>		if (copy_from_user(&cpuid, cpuid_arg, sizeof(cpuid)))</blue>
			goto out;
<blue>		r = kvm_vcpu_ioctl_set_cpuid2(vcpu, &cpuid,</blue>
					      cpuid_arg-&gt;entries);
		break;
	}
	case KVM_GET_CPUID2: {
		struct kvm_cpuid2 __user *cpuid_arg = argp;
		struct kvm_cpuid2 cpuid;

		r = -EFAULT;
<yellow>		if (copy_from_user(&cpuid, cpuid_arg, sizeof(cpuid)))</yellow>
			goto out;
<yellow>		r = kvm_vcpu_ioctl_get_cpuid2(vcpu, &cpuid,</yellow>
					      cpuid_arg-&gt;entries);
		if (r)
			goto out;
		r = -EFAULT;
<yellow>		if (copy_to_user(cpuid_arg, &cpuid, sizeof(cpuid)))</yellow>
			goto out;
		r = 0;
		break;
	}
	case KVM_GET_MSRS: {
<blue>		int idx = srcu_read_lock(&vcpu->kvm->srcu);</blue>
		r = msr_io(vcpu, argp, do_get_msr, 1);
<blue>		srcu_read_unlock(&vcpu->kvm->srcu, idx);</blue>
		break;
	}
	case KVM_SET_MSRS: {
<blue>		int idx = srcu_read_lock(&vcpu->kvm->srcu);</blue>
<blue>		r = msr_io(vcpu, argp, do_set_msr, 0);</blue>
<blue>		srcu_read_unlock(&vcpu->kvm->srcu, idx);</blue>
		break;
	}
	case KVM_TPR_ACCESS_REPORTING: {
		struct kvm_tpr_access_ctl tac;

		r = -EFAULT;
<blue>		if (copy_from_user(&tac, argp, sizeof(tac)))</blue>
			goto out;
<blue>		r = vcpu_ioctl_tpr_access_reporting(vcpu, &tac);</blue>
		if (r)
			goto out;
		r = -EFAULT;
		if (copy_to_user(argp, &amp;tac, sizeof(tac)))
			goto out;
		r = 0;
<blue>		break;</blue>
	};
	case KVM_SET_VAPIC_ADDR: {
		struct kvm_vapic_addr va;
		int idx;

		r = -EINVAL;
<blue>		if (!lapic_in_kernel(vcpu))</blue>
			goto out;
		r = -EFAULT;
<blue>		if (copy_from_user(&va, argp, sizeof(va)))</blue>
			goto out;
<blue>		idx = srcu_read_lock(&vcpu->kvm->srcu);</blue>
		r = kvm_lapic_set_vapic_addr(vcpu, va.vapic_addr);
<blue>		srcu_read_unlock(&vcpu->kvm->srcu, idx);</blue>
		break;
	}
	case KVM_X86_SETUP_MCE: {
		u64 mcg_cap;

		r = -EFAULT;
<blue>		if (copy_from_user(&mcg_cap, argp, sizeof(mcg_cap)))</blue>
			goto out;
<blue>		r = kvm_vcpu_ioctl_x86_setup_mce(vcpu, mcg_cap);</blue>
		break;
	}
	case KVM_X86_SET_MCE: {
		struct kvm_x86_mce mce;

		r = -EFAULT;
<yellow>		if (copy_from_user(&mce, argp, sizeof(mce)))</yellow>
			goto out;
<yellow>		r = kvm_vcpu_ioctl_x86_set_mce(vcpu, &mce);</yellow>
		break;
	}
	case KVM_GET_VCPU_EVENTS: {
		struct kvm_vcpu_events events;

<blue>		kvm_vcpu_ioctl_x86_get_vcpu_events(vcpu, &events);</blue>

		r = -EFAULT;
		if (copy_to_user(argp, &amp;events, sizeof(struct kvm_vcpu_events)))
			break;
		r = 0;
		break;
	}
	case KVM_SET_VCPU_EVENTS: {
		struct kvm_vcpu_events events;

		r = -EFAULT;
<blue>		if (copy_from_user(&events, argp, sizeof(struct kvm_vcpu_events)))</blue>
			break;

<blue>		r = kvm_vcpu_ioctl_x86_set_vcpu_events(vcpu, &events);</blue>
		break;
	}
	case KVM_GET_DEBUGREGS: {
		struct kvm_debugregs dbgregs;

<blue>		kvm_vcpu_ioctl_x86_get_debugregs(vcpu, &dbgregs);</blue>

		r = -EFAULT;
		if (copy_to_user(argp, &amp;dbgregs,
				 sizeof(struct kvm_debugregs)))
			break;
		r = 0;
		break;
	}
	case KVM_SET_DEBUGREGS: {
		struct kvm_debugregs dbgregs;

		r = -EFAULT;
<blue>		if (copy_from_user(&dbgregs, argp,</blue>
				   sizeof(struct kvm_debugregs)))
			break;

<blue>		r = kvm_vcpu_ioctl_x86_set_debugregs(vcpu, &dbgregs);</blue>
		break;
	}
	case KVM_GET_XSAVE: {
		r = -EINVAL;
<blue>		if (vcpu->arch.guest_fpu.uabi_size > sizeof(struct kvm_xsave))</blue>
			break;

<blue>		u.xsave = kzalloc(sizeof(struct kvm_xsave), GFP_KERNEL_ACCOUNT);</blue>
		r = -ENOMEM;
		if (!u.xsave)
			break;

<blue>		kvm_vcpu_ioctl_x86_get_xsave(vcpu, u.xsave);</blue>

		r = -EFAULT;
<blue>		if (copy_to_user(argp, u.xsave, sizeof(struct kvm_xsave)))</blue>
			break;
		r = 0;
		break;
	}
	case KVM_SET_XSAVE: {
<blue>		int size = vcpu->arch.guest_fpu.uabi_size;</blue>

		u.xsave = memdup_user(argp, size);
		if (IS_ERR(u.xsave)) {
			r = PTR_ERR(u.xsave);
			goto out_nofree;
		}

<blue>		r = kvm_vcpu_ioctl_x86_set_xsave(vcpu, u.xsave);</blue>
		break;
	}

	case KVM_GET_XSAVE2: {
<blue>		int size = vcpu->arch.guest_fpu.uabi_size;</blue>

		u.xsave = kzalloc(size, GFP_KERNEL_ACCOUNT);
		r = -ENOMEM;
		if (!u.xsave)
			break;

<blue>		kvm_vcpu_ioctl_x86_get_xsave2(vcpu, u.buffer, size);</blue>

		r = -EFAULT;
<blue>		if (copy_to_user(argp, u.xsave, size))</blue>
			break;

		r = 0;
		break;
	}

	case KVM_GET_XCRS: {
<blue>		u.xcrs = kzalloc(sizeof(struct kvm_xcrs), GFP_KERNEL_ACCOUNT);</blue>
		r = -ENOMEM;
		if (!u.xcrs)
			break;

<blue>		kvm_vcpu_ioctl_x86_get_xcrs(vcpu, u.xcrs);</blue>

		r = -EFAULT;
<blue>		if (copy_to_user(argp, u.xcrs,</blue>
				 sizeof(struct kvm_xcrs)))
			break;
		r = 0;
		break;
	}
	case KVM_SET_XCRS: {
<blue>		u.xcrs = memdup_user(argp, sizeof(*u.xcrs));</blue>
		if (IS_ERR(u.xcrs)) {
			r = PTR_ERR(u.xcrs);
			goto out_nofree;
		}

<blue>		r = kvm_vcpu_ioctl_x86_set_xcrs(vcpu, u.xcrs);</blue>
		break;
	}
	case KVM_SET_TSC_KHZ: {
		u32 user_tsc_khz;

		r = -EINVAL;
		user_tsc_khz = (u32)arg;

<blue>		if (kvm_caps.has_tsc_control &&</blue>
<blue>		    user_tsc_khz >= kvm_caps.max_guest_tsc_khz)</blue>
			goto out;

<blue>		if (user_tsc_khz == 0)</blue>
<yellow>			user_tsc_khz = tsc_khz;</yellow>

<blue>		if (!kvm_set_tsc_khz(vcpu, user_tsc_khz))</blue>
			r = 0;

		goto out;
	}
	case KVM_GET_TSC_KHZ: {
<blue>		r = vcpu->arch.virtual_tsc_khz;</blue>
		goto out;
	}
	case KVM_KVMCLOCK_CTRL: {
<blue>		r = kvm_set_guest_paused(vcpu);</blue>
		goto out;
	}
	case KVM_ENABLE_CAP: {
		struct kvm_enable_cap cap;

		r = -EFAULT;
<blue>		if (copy_from_user(&cap, argp, sizeof(cap)))</blue>
			goto out;
<blue>		r = kvm_vcpu_ioctl_enable_cap(vcpu, &cap);</blue>
		break;
	}
	case KVM_GET_NESTED_STATE: {
		struct kvm_nested_state __user *user_kvm_nested_state = argp;
		u32 user_data_size;

		r = -EINVAL;
<blue>		if (!kvm_x86_ops.nested_ops->get_state)</blue>
			break;

		BUILD_BUG_ON(sizeof(user_data_size) != sizeof(user_kvm_nested_state-&gt;size));
		r = -EFAULT;
<blue>		if (get_user(user_data_size, &user_kvm_nested_state->size))</blue>
			break;

<blue>		r = kvm_x86_ops.nested_ops->get_state(vcpu, user_kvm_nested_state,</blue>
						     user_data_size);
		if (r &lt; 0)
			break;

<blue>		if (r > user_data_size) {</blue>
<blue>			if (put_user(r, &user_kvm_nested_state->size))</blue>
				r = -EFAULT;
			else
				r = -E2BIG;
			break;
		}

		r = 0;
		break;
	}
	case KVM_SET_NESTED_STATE: {
		struct kvm_nested_state __user *user_kvm_nested_state = argp;
		struct kvm_nested_state kvm_state;
		int idx;

		r = -EINVAL;
<blue>		if (!kvm_x86_ops.nested_ops->set_state)</blue>
			break;

		r = -EFAULT;
<blue>		if (copy_from_user(&kvm_state, user_kvm_nested_state, sizeof(kvm_state)))</blue>
			break;

		r = -EINVAL;
<blue>		if (kvm_state.size < sizeof(kvm_state))</blue>
			break;

<blue>		if (kvm_state.flags &</blue>
		    ~(KVM_STATE_NESTED_RUN_PENDING | KVM_STATE_NESTED_GUEST_MODE
		      | KVM_STATE_NESTED_EVMCS | KVM_STATE_NESTED_MTF_PENDING
		      | KVM_STATE_NESTED_GIF_SET))
			break;

		/* nested_run_pending implies guest_mode.  */
<blue>		if ((kvm_state.flags & KVM_STATE_NESTED_RUN_PENDING)</blue>
		    &amp;&amp; !(kvm_state.flags &amp; KVM_STATE_NESTED_GUEST_MODE))
			break;

<blue>		idx = srcu_read_lock(&vcpu->kvm->srcu);</blue>
		r = kvm_x86_ops.nested_ops-&gt;set_state(vcpu, user_kvm_nested_state, &amp;kvm_state);
<blue>		srcu_read_unlock(&vcpu->kvm->srcu, idx);</blue>
		break;
	}
	case KVM_GET_SUPPORTED_HV_CPUID:
<blue>		r = kvm_ioctl_get_supported_hv_cpuid(vcpu, argp);</blue>
		break;
#ifdef CONFIG_KVM_XEN
	case KVM_XEN_VCPU_GET_ATTR: {
		struct kvm_xen_vcpu_attr xva;

		r = -EFAULT;
<yellow>		if (copy_from_user(&xva, argp, sizeof(xva)))</yellow>
			goto out;
<yellow>		r = kvm_xen_vcpu_get_attr(vcpu, &xva);</yellow>
<yellow>		if (!r && copy_to_user(argp, &xva, sizeof(xva)))</yellow>
			r = -EFAULT;
		break;
	}
	case KVM_XEN_VCPU_SET_ATTR: {
		struct kvm_xen_vcpu_attr xva;

		r = -EFAULT;
<yellow>		if (copy_from_user(&xva, argp, sizeof(xva)))</yellow>
<yellow>			goto out;</yellow>
<yellow>		r = kvm_xen_vcpu_set_attr(vcpu, &xva);</yellow>
		break;
	}
#endif
	case KVM_GET_SREGS2: {
<blue>		u.sregs2 = kzalloc(sizeof(struct kvm_sregs2), GFP_KERNEL);</blue>
		r = -ENOMEM;
		if (!u.sregs2)
			goto out;
<blue>		__get_sregs2(vcpu, u.sregs2);</blue>
		r = -EFAULT;
<blue>		if (copy_to_user(argp, u.sregs2, sizeof(struct kvm_sregs2)))</blue>
			goto out;
		r = 0;
		break;
	}
	case KVM_SET_SREGS2: {
<blue>		u.sregs2 = memdup_user(argp, sizeof(struct kvm_sregs2));</blue>
		if (IS_ERR(u.sregs2)) {
			r = PTR_ERR(u.sregs2);
			u.sregs2 = NULL;
			goto out;
		}
<blue>		r = __set_sregs2(vcpu, u.sregs2);</blue>
<blue>		break;</blue>
	}
	case KVM_HAS_DEVICE_ATTR:
	case KVM_GET_DEVICE_ATTR:
	case KVM_SET_DEVICE_ATTR:
<yellow>		r = kvm_vcpu_ioctl_device_attr(vcpu, ioctl, argp);</yellow>
		break;
	default:
		r = -EINVAL;
	}
out:
<blue>	kfree(u.buffer);</blue>
out_nofree:
<blue>	vcpu_put(vcpu);</blue>
<blue>	return r;</blue>
}

vm_fault_t kvm_arch_vcpu_fault(struct kvm_vcpu *vcpu, struct vm_fault *vmf)
{
	return VM_FAULT_SIGBUS;
<yellow>}</yellow>

static int kvm_vm_ioctl_set_tss_addr(struct kvm *kvm, unsigned long addr)
{
	int ret;

<blue>	if (addr > (unsigned int)(-3 * PAGE_SIZE))</blue>
		return -EINVAL;
<blue>	ret = static_call(kvm_x86_set_tss_addr)(kvm, addr);</blue>
	return ret;
}

static int kvm_vm_ioctl_set_identity_map_addr(struct kvm *kvm,
					      u64 ident_addr)
{
<blue>	return static_call(kvm_x86_set_identity_map_addr)(kvm, ident_addr);</blue>
}

static int kvm_vm_ioctl_set_nr_mmu_pages(struct kvm *kvm,
					 unsigned long kvm_nr_mmu_pages)
{
<yellow>	if (kvm_nr_mmu_pages < KVM_MIN_ALLOC_MMU_PAGES)</yellow>
		return -EINVAL;

<yellow>	mutex_lock(&kvm->slots_lock);</yellow>

	kvm_mmu_change_mmu_pages(kvm, kvm_nr_mmu_pages);
	kvm-&gt;arch.n_requested_mmu_pages = kvm_nr_mmu_pages;

	mutex_unlock(&amp;kvm-&gt;slots_lock);
	return 0;
}

static unsigned long kvm_vm_ioctl_get_nr_mmu_pages(struct kvm *kvm)
{
<yellow>	return kvm->arch.n_max_mmu_pages;</yellow>
}

static int kvm_vm_ioctl_get_irqchip(struct kvm *kvm, struct kvm_irqchip *chip)
{
<yellow>	struct kvm_pic *pic = kvm->arch.vpic;</yellow>
	int r;

	r = 0;
	switch (chip-&gt;chip_id) {
	case KVM_IRQCHIP_PIC_MASTER:
<yellow>		memcpy(&chip->chip.pic, &pic->pics[0],</yellow>
			sizeof(struct kvm_pic_state));
		break;
	case KVM_IRQCHIP_PIC_SLAVE:
<yellow>		memcpy(&chip->chip.pic, &pic->pics[1],</yellow>
			sizeof(struct kvm_pic_state));
		break;
	case KVM_IRQCHIP_IOAPIC:
<yellow>		kvm_get_ioapic(kvm, &chip->chip.ioapic);</yellow>
		break;
	default:
		r = -EINVAL;
		break;
	}
	return r;
}

static int kvm_vm_ioctl_set_irqchip(struct kvm *kvm, struct kvm_irqchip *chip)
{
<blue>	struct kvm_pic *pic = kvm->arch.vpic;</blue>
	int r;

	r = 0;
	switch (chip-&gt;chip_id) {
	case KVM_IRQCHIP_PIC_MASTER:
<blue>		spin_lock(&pic->lock);</blue>
		memcpy(&amp;pic-&gt;pics[0], &amp;chip-&gt;chip.pic,
			sizeof(struct kvm_pic_state));
		spin_unlock(&amp;pic-&gt;lock);
		break;
	case KVM_IRQCHIP_PIC_SLAVE:
<blue>		spin_lock(&pic->lock);</blue>
		memcpy(&amp;pic-&gt;pics[1], &amp;chip-&gt;chip.pic,
			sizeof(struct kvm_pic_state));
		spin_unlock(&amp;pic-&gt;lock);
		break;
	case KVM_IRQCHIP_IOAPIC:
<blue>		kvm_set_ioapic(kvm, &chip->chip.ioapic);</blue>
		break;
	default:
		r = -EINVAL;
		break;
	}
<blue>	kvm_pic_update_irq(pic);</blue>
	return r;
}

static int kvm_vm_ioctl_get_pit(struct kvm *kvm, struct kvm_pit_state *ps)
{
	struct kvm_kpit_state *kps = &amp;kvm-&gt;arch.vpit-&gt;pit_state;

	BUILD_BUG_ON(sizeof(*ps) != sizeof(kps-&gt;channels));

<yellow>	mutex_lock(&kps->lock);</yellow>
	memcpy(ps, &amp;kps-&gt;channels, sizeof(*ps));
	mutex_unlock(&amp;kps-&gt;lock);
	return 0;
}

static int kvm_vm_ioctl_set_pit(struct kvm *kvm, struct kvm_pit_state *ps)
{
	int i;
	struct kvm_pit *pit = kvm-&gt;arch.vpit;

<yellow>	mutex_lock(&pit->pit_state.lock);</yellow>
	memcpy(&amp;pit-&gt;pit_state.channels, ps, sizeof(*ps));
	for (i = 0; i &lt; 3; i++)
<yellow>		kvm_pit_load_count(pit, i, ps->channels[i].count, 0);</yellow>
<yellow>	mutex_unlock(&pit->pit_state.lock);</yellow>
	return 0;
}

static int kvm_vm_ioctl_get_pit2(struct kvm *kvm, struct kvm_pit_state2 *ps)
{
<blue>	mutex_lock(&kvm->arch.vpit->pit_state.lock);</blue>
	memcpy(ps-&gt;channels, &amp;kvm-&gt;arch.vpit-&gt;pit_state.channels,
		sizeof(ps-&gt;channels));
	ps-&gt;flags = kvm-&gt;arch.vpit-&gt;pit_state.flags;
	mutex_unlock(&amp;kvm-&gt;arch.vpit-&gt;pit_state.lock);
	memset(&amp;ps-&gt;reserved, 0, sizeof(ps-&gt;reserved));
	return 0;
}

static int kvm_vm_ioctl_set_pit2(struct kvm *kvm, struct kvm_pit_state2 *ps)
{
	int start = 0;
	int i;
	u32 prev_legacy, cur_legacy;
	struct kvm_pit *pit = kvm-&gt;arch.vpit;

<blue>	mutex_lock(&pit->pit_state.lock);</blue>
	prev_legacy = pit-&gt;pit_state.flags &amp; KVM_PIT_FLAGS_HPET_LEGACY;
<blue>	cur_legacy = ps->flags & KVM_PIT_FLAGS_HPET_LEGACY;</blue>
	if (!prev_legacy &amp;&amp; cur_legacy)
		start = 1;
<blue>	memcpy(&pit->pit_state.channels, &ps->channels,</blue>
	       sizeof(pit-&gt;pit_state.channels));
	pit-&gt;pit_state.flags = ps-&gt;flags;
	for (i = 0; i &lt; 3; i++)
<blue>		kvm_pit_load_count(pit, i, pit->pit_state.channels[i].count,</blue>
				   start &amp;&amp; i == 0);
<blue>	mutex_unlock(&pit->pit_state.lock);</blue>
	return 0;
}

static int kvm_vm_ioctl_reinject(struct kvm *kvm,
				 struct kvm_reinject_control *control)
{
	struct kvm_pit *pit = kvm-&gt;arch.vpit;

	/* pit-&gt;pit_state.lock was overloaded to prevent userspace from getting
	 * an inconsistent state after running multiple KVM_REINJECT_CONTROL
	 * ioctls in parallel.  Use a separate lock if that ioctl isn&#x27;t rare.
	 */
<yellow>	mutex_lock(&pit->pit_state.lock);</yellow>
	kvm_pit_set_reinject(pit, control-&gt;pit_reinject);
	mutex_unlock(&amp;pit-&gt;pit_state.lock);

	return 0;
}

void kvm_arch_sync_dirty_log(struct kvm *kvm, struct kvm_memory_slot *memslot)
<yellow>{</yellow>

	/*
	 * Flush all CPUs&#x27; dirty log buffers to the  dirty_bitmap.  Called
	 * before reporting dirty_bitmap to userspace.  KVM flushes the buffers
	 * on all VM-Exits, thus we only need to kick running vCPUs to force a
	 * VM-Exit.
	 */
	struct kvm_vcpu *vcpu;
	unsigned long i;

<yellow>	kvm_for_each_vcpu(i, vcpu, kvm)</yellow>
<yellow>		kvm_vcpu_kick(vcpu);</yellow>
}

int kvm_vm_ioctl_irq_line(struct kvm *kvm, struct kvm_irq_level *irq_event,
			bool line_status)
{
<blue>	if (!irqchip_in_kernel(kvm))</blue>
		return -ENXIO;

	irq_event-&gt;status = kvm_set_irq(kvm, KVM_USERSPACE_IRQ_SOURCE_ID,
<blue>					irq_event->irq, irq_event->level,</blue>
					line_status);
	return 0;
<blue>}</blue>

int kvm_vm_ioctl_enable_cap(struct kvm *kvm,
			    struct kvm_enable_cap *cap)
<blue>{</blue>
	int r;

<blue>	if (cap->flags)</blue>
		return -EINVAL;

<blue>	switch (cap->cap) {</blue>
	case KVM_CAP_DISABLE_QUIRKS2:
		r = -EINVAL;
<yellow>		if (cap->args[0] & ~KVM_X86_VALID_QUIRKS)</yellow>
			break;
		fallthrough;
	case KVM_CAP_DISABLE_QUIRKS:
<yellow>		kvm->arch.disabled_quirks = cap->args[0];</yellow>
		r = 0;
		break;
	case KVM_CAP_SPLIT_IRQCHIP: {
<yellow>		mutex_lock(&kvm->lock);</yellow>
		r = -EINVAL;
		if (cap-&gt;args[0] &gt; MAX_NR_RESERVED_IOAPIC_PINS)
			goto split_irqchip_unlock;
		r = -EEXIST;
<yellow>		if (irqchip_in_kernel(kvm))</yellow>
			goto split_irqchip_unlock;
<yellow>		if (kvm->created_vcpus)</yellow>
			goto split_irqchip_unlock;
<yellow>		r = kvm_setup_empty_irq_routing(kvm);</yellow>
		if (r)
			goto split_irqchip_unlock;
		/* Pairs with irqchip_in_kernel. */
		smp_wmb();
<yellow>		kvm->arch.irqchip_mode = KVM_IRQCHIP_SPLIT;</yellow>
		kvm-&gt;arch.nr_reserved_ioapic_pins = cap-&gt;args[0];
		kvm_clear_apicv_inhibit(kvm, APICV_INHIBIT_REASON_ABSENT);
		r = 0;
split_irqchip_unlock:
		mutex_unlock(&amp;kvm-&gt;lock);
		break;
	}
	case KVM_CAP_X2APIC_API:
		r = -EINVAL;
<yellow>		if (cap->args[0] & ~KVM_X2APIC_API_VALID_FLAGS)</yellow>
			break;

<yellow>		if (cap->args[0] & KVM_X2APIC_API_USE_32BIT_IDS)</yellow>
<yellow>			kvm->arch.x2apic_format = true;</yellow>
<yellow>		if (cap->args[0] & KVM_X2APIC_API_DISABLE_BROADCAST_QUIRK)</yellow>
<yellow>			kvm->arch.x2apic_broadcast_quirk_disabled = true;</yellow>

		r = 0;
		break;
	case KVM_CAP_X86_DISABLE_EXITS:
		r = -EINVAL;
<yellow>		if (cap->args[0] & ~KVM_X86_DISABLE_VALID_EXITS)</yellow>
			break;

<yellow>		if ((cap->args[0] & KVM_X86_DISABLE_EXITS_MWAIT) &&</yellow>
<yellow>			kvm_can_mwait_in_guest())</yellow>
<yellow>			kvm->arch.mwait_in_guest = true;</yellow>
<yellow>		if (cap->args[0] & KVM_X86_DISABLE_EXITS_HLT)</yellow>
<yellow>			kvm->arch.hlt_in_guest = true;</yellow>
<yellow>		if (cap->args[0] & KVM_X86_DISABLE_EXITS_PAUSE)</yellow>
<yellow>			kvm->arch.pause_in_guest = true;</yellow>
<yellow>		if (cap->args[0] & KVM_X86_DISABLE_EXITS_CSTATE)</yellow>
<yellow>			kvm->arch.cstate_in_guest = true;</yellow>
		r = 0;
		break;
	case KVM_CAP_MSR_PLATFORM_INFO:
<yellow>		kvm->arch.guest_can_read_msr_platform_info = cap->args[0];</yellow>
		r = 0;
		break;
	case KVM_CAP_EXCEPTION_PAYLOAD:
<blue>		kvm->arch.exception_payload_enabled = cap->args[0];</blue>
		r = 0;
		break;
	case KVM_CAP_X86_TRIPLE_FAULT_EVENT:
<yellow>		kvm->arch.triple_fault_event = cap->args[0];</yellow>
		r = 0;
		break;
	case KVM_CAP_X86_USER_SPACE_MSR:
		r = -EINVAL;
<yellow>		if (cap->args[0] & ~(KVM_MSR_EXIT_REASON_INVAL |</yellow>
				     KVM_MSR_EXIT_REASON_UNKNOWN |
				     KVM_MSR_EXIT_REASON_FILTER))
			break;
<yellow>		kvm->arch.user_space_msr_mask = cap->args[0];</yellow>
		r = 0;
		break;
	case KVM_CAP_X86_BUS_LOCK_EXIT:
		r = -EINVAL;
<yellow>		if (cap->args[0] & ~KVM_BUS_LOCK_DETECTION_VALID_MODE)</yellow>
			break;

<yellow>		if ((cap->args[0] & KVM_BUS_LOCK_DETECTION_OFF) &&</yellow>
		    (cap-&gt;args[0] &amp; KVM_BUS_LOCK_DETECTION_EXIT))
			break;

<yellow>		if (kvm_caps.has_bus_lock_exit &&</yellow>
<yellow>		    cap->args[0] & KVM_BUS_LOCK_DETECTION_EXIT)</yellow>
<yellow>			kvm->arch.bus_lock_detection_enabled = true;</yellow>
		r = 0;
		break;
#ifdef CONFIG_X86_SGX_KVM
	case KVM_CAP_SGX_ATTRIBUTE: {
		unsigned long allowed_attributes = 0;

<yellow>		r = sgx_set_attribute(&allowed_attributes, cap->args[0]);</yellow>
		if (r)
			break;

		/* KVM only supports the PROVISIONKEY privileged attribute. */
<yellow>		if ((allowed_attributes & SGX_ATTR_PROVISIONKEY) &&</yellow>
		    !(allowed_attributes &amp; ~SGX_ATTR_PROVISIONKEY))
<yellow>			kvm->arch.sgx_provisioning_allowed = true;</yellow>
		else
<yellow>			r = -EINVAL;</yellow>
		break;
	}
#endif
	case KVM_CAP_VM_COPY_ENC_CONTEXT_FROM:
		r = -EINVAL;
<yellow>		if (!kvm_x86_ops.vm_copy_enc_context_from)</yellow>
			break;

<yellow>		r = static_call(kvm_x86_vm_copy_enc_context_from)(kvm, cap->args[0]);</yellow>
		break;
	case KVM_CAP_VM_MOVE_ENC_CONTEXT_FROM:
		r = -EINVAL;
<yellow>		if (!kvm_x86_ops.vm_move_enc_context_from)</yellow>
			break;

<yellow>		r = static_call(kvm_x86_vm_move_enc_context_from)(kvm, cap->args[0]);</yellow>
		break;
	case KVM_CAP_EXIT_HYPERCALL:
<yellow>		if (cap->args[0] & ~KVM_EXIT_HYPERCALL_VALID_MASK) {</yellow>
			r = -EINVAL;
			break;
		}
<yellow>		kvm->arch.hypercall_exit_enabled = cap->args[0];</yellow>
		r = 0;
		break;
	case KVM_CAP_EXIT_ON_EMULATION_FAILURE:
		r = -EINVAL;
<yellow>		if (cap->args[0] & ~1)</yellow>
			break;
<yellow>		kvm->arch.exit_on_emulation_error = cap->args[0];</yellow>
		r = 0;
		break;
	case KVM_CAP_PMU_CAPABILITY:
		r = -EINVAL;
<yellow>		if (!enable_pmu || (cap->args[0] & ~KVM_CAP_PMU_VALID_MASK))</yellow>
			break;

<yellow>		mutex_lock(&kvm->lock);</yellow>
		if (!kvm-&gt;created_vcpus) {
<yellow>			kvm->arch.enable_pmu = !(cap->args[0] & KVM_PMU_CAP_DISABLE);</yellow>
			r = 0;
		}
		mutex_unlock(&amp;kvm-&gt;lock);
		break;
	case KVM_CAP_MAX_VCPU_ID:
		r = -EINVAL;
<yellow>		if (cap->args[0] > KVM_MAX_VCPU_IDS)</yellow>
			break;

<yellow>		mutex_lock(&kvm->lock);</yellow>
		if (kvm-&gt;arch.max_vcpu_ids == cap-&gt;args[0]) {
			r = 0;
<yellow>		} else if (!kvm->arch.max_vcpu_ids) {</yellow>
			kvm-&gt;arch.max_vcpu_ids = cap-&gt;args[0];
<yellow>			r = 0;</yellow>
		}
		mutex_unlock(&amp;kvm-&gt;lock);
		break;
	case KVM_CAP_X86_NOTIFY_VMEXIT:
		r = -EINVAL;
<yellow>		if ((u32)cap->args[0] & ~KVM_X86_NOTIFY_VMEXIT_VALID_BITS)</yellow>
			break;
<yellow>		if (!kvm_caps.has_notify_vmexit)</yellow>
			break;
<yellow>		if (!((u32)cap->args[0] & KVM_X86_NOTIFY_VMEXIT_ENABLED))</yellow>
			break;
<yellow>		mutex_lock(&kvm->lock);</yellow>
		if (!kvm-&gt;created_vcpus) {
<yellow>			kvm->arch.notify_window = cap->args[0] >> 32;</yellow>
			kvm-&gt;arch.notify_vmexit_flags = (u32)cap-&gt;args[0];
			r = 0;
		}
		mutex_unlock(&amp;kvm-&gt;lock);
		break;
	case KVM_CAP_VM_DISABLE_NX_HUGE_PAGES:
		r = -EINVAL;

		/*
		 * Since the risk of disabling NX hugepages is a guest crashing
		 * the system, ensure the userspace process has permission to
		 * reboot the system.
		 *
		 * Note that unlike the reboot() syscall, the process must have
		 * this capability in the root namespace because exposing
		 * /dev/kvm into a container does not limit the scope of the
		 * iTLB multihit bug to that container. In other words,
		 * this must use capable(), not ns_capable().
		 */
<yellow>		if (!capable(CAP_SYS_BOOT)) {</yellow>
			r = -EPERM;
			break;
		}

<yellow>		if (cap->args[0])</yellow>
			break;

<yellow>		mutex_lock(&kvm->lock);</yellow>
		if (!kvm-&gt;created_vcpus) {
<yellow>			kvm->arch.disable_nx_huge_pages = true;</yellow>
			r = 0;
		}
<yellow>		mutex_unlock(&kvm->lock);</yellow>
		break;
	default:
		r = -EINVAL;
		break;
	}
	return r;
}

static struct kvm_x86_msr_filter *kvm_alloc_msr_filter(bool default_allow)
{
	struct kvm_x86_msr_filter *msr_filter;

<yellow>	msr_filter = kzalloc(sizeof(*msr_filter), GFP_KERNEL_ACCOUNT);</yellow>
	if (!msr_filter)
		return NULL;

<yellow>	msr_filter->default_allow = default_allow;</yellow>
	return msr_filter;
}

<yellow>static void kvm_free_msr_filter(struct kvm_x86_msr_filter *msr_filter)</yellow>
{
	u32 i;

	if (!msr_filter)
		return;

<yellow>	for (i = 0; i < msr_filter->count; i++)</yellow>
<yellow>		kfree(msr_filter->ranges[i].bitmap);</yellow>

<yellow>	kfree(msr_filter);</yellow>
}

static int kvm_add_msr_filter(struct kvm_x86_msr_filter *msr_filter,
			      struct kvm_msr_filter_range *user_range)
{
	unsigned long *bitmap = NULL;
	size_t bitmap_size;

<yellow>	if (!user_range->nmsrs)</yellow>
		return 0;

<yellow>	if (user_range->flags & ~(KVM_MSR_FILTER_READ | KVM_MSR_FILTER_WRITE))</yellow>
		return -EINVAL;

<yellow>	if (!user_range->flags)</yellow>
		return -EINVAL;

<yellow>	bitmap_size = BITS_TO_LONGS(user_range->nmsrs) * sizeof(long);</yellow>
	if (!bitmap_size || bitmap_size &gt; KVM_MSR_FILTER_MAX_BITMAP_SIZE)
		return -EINVAL;

<yellow>	bitmap = memdup_user((__user u8*)user_range->bitmap, bitmap_size);</yellow>
	if (IS_ERR(bitmap))
		return PTR_ERR(bitmap);

<yellow>	msr_filter->ranges[msr_filter->count] = (struct msr_bitmap_range) {</yellow>
		.flags = user_range-&gt;flags,
		.base = user_range-&gt;base,
		.nmsrs = user_range-&gt;nmsrs,
		.bitmap = bitmap,
	};

	msr_filter-&gt;count++;
	return 0;
}

static int kvm_vm_ioctl_set_msr_filter(struct kvm *kvm,
				       struct kvm_msr_filter *filter)
{
	struct kvm_x86_msr_filter *new_filter, *old_filter;
	bool default_allow;
	bool empty = true;
	int r = 0;
	u32 i;

<yellow>	if (filter->flags & ~KVM_MSR_FILTER_DEFAULT_DENY)</yellow>
		return -EINVAL;

	for (i = 0; i &lt; ARRAY_SIZE(filter-&gt;ranges); i++)
<yellow>		empty &= !filter->ranges[i].nmsrs;</yellow>

<yellow>	default_allow = !(filter->flags & KVM_MSR_FILTER_DEFAULT_DENY);</yellow>
<yellow>	if (empty && !default_allow)</yellow>
		return -EINVAL;

<yellow>	new_filter = kvm_alloc_msr_filter(default_allow);</yellow>
	if (!new_filter)
		return -ENOMEM;

<yellow>	for (i = 0; i < ARRAY_SIZE(filter->ranges); i++) {</yellow>
<yellow>		r = kvm_add_msr_filter(new_filter, &filter->ranges[i]);</yellow>
<yellow>		if (r) {</yellow>
<yellow>			kvm_free_msr_filter(new_filter);</yellow>
			return r;
		}
	}

<yellow>	mutex_lock(&kvm->lock);</yellow>

	/* The per-VM filter is protected by kvm-&gt;lock... */
	old_filter = srcu_dereference_check(kvm-&gt;arch.msr_filter, &amp;kvm-&gt;srcu, 1);

	rcu_assign_pointer(kvm-&gt;arch.msr_filter, new_filter);
	synchronize_srcu(&amp;kvm-&gt;srcu);

<yellow>	kvm_free_msr_filter(old_filter);</yellow>

<yellow>	kvm_make_all_cpus_request(kvm, KVM_REQ_MSR_FILTER_CHANGED);</yellow>
	mutex_unlock(&amp;kvm-&gt;lock);

	return 0;
<yellow>}</yellow>

#ifdef CONFIG_KVM_COMPAT
/* for KVM_X86_SET_MSR_FILTER */
struct kvm_msr_filter_range_compat {
	__u32 flags;
	__u32 nmsrs;
	__u32 base;
	__u32 bitmap;
};

struct kvm_msr_filter_compat {
	__u32 flags;
	struct kvm_msr_filter_range_compat ranges[KVM_MSR_FILTER_MAX_RANGES];
};

#define KVM_X86_SET_MSR_FILTER_COMPAT _IOW(KVMIO, 0xc6, struct kvm_msr_filter_compat)

long kvm_arch_vm_compat_ioctl(struct file *filp, unsigned int ioctl,
			      unsigned long arg)
<yellow>{</yellow>
	void __user *argp = (void __user *)arg;
<yellow>	struct kvm *kvm = filp->private_data;</yellow>
	long r = -ENOTTY;

	switch (ioctl) {
	case KVM_X86_SET_MSR_FILTER_COMPAT: {
		struct kvm_msr_filter __user *user_msr_filter = argp;
		struct kvm_msr_filter_compat filter_compat;
		struct kvm_msr_filter filter;
		int i;

<yellow>		if (copy_from_user(&filter_compat, user_msr_filter,</yellow>
				   sizeof(filter_compat)))
<yellow>			return -EFAULT;</yellow>

<yellow>		filter.flags = filter_compat.flags;</yellow>
		for (i = 0; i &lt; ARRAY_SIZE(filter.ranges); i++) {
			struct kvm_msr_filter_range_compat *cr;

<yellow>			cr = &filter_compat.ranges[i];</yellow>
			filter.ranges[i] = (struct kvm_msr_filter_range) {
				.flags = cr-&gt;flags,
				.nmsrs = cr-&gt;nmsrs,
				.base = cr-&gt;base,
				.bitmap = (__u8 *)(ulong)cr-&gt;bitmap,
			};
		}

<yellow>		r = kvm_vm_ioctl_set_msr_filter(kvm, &filter);</yellow>
		break;
	}
	}

	return r;
}
#endif

#ifdef CONFIG_HAVE_KVM_PM_NOTIFIER
static int kvm_arch_suspend_notifier(struct kvm *kvm)
{
	struct kvm_vcpu *vcpu;
	unsigned long i;
	int ret = 0;

<yellow>	mutex_lock(&kvm->lock);</yellow>
<yellow>	kvm_for_each_vcpu(i, vcpu, kvm) {</yellow>
<yellow>		if (!vcpu->arch.pv_time.active)</yellow>
			continue;

<yellow>		ret = kvm_set_guest_paused(vcpu);</yellow>
		if (ret) {
			kvm_err(&quot;Failed to pause guest VCPU%d: %d\n&quot;,
				vcpu-&gt;vcpu_id, ret);
			break;
		}
	}
<yellow>	mutex_unlock(&kvm->lock);</yellow>

	return ret ? NOTIFY_BAD : NOTIFY_DONE;
}

int kvm_arch_pm_notifier(struct kvm *kvm, unsigned long state)
<yellow>{</yellow>
<yellow>	switch (state) {</yellow>
	case PM_HIBERNATION_PREPARE:
	case PM_SUSPEND_PREPARE:
<yellow>		return kvm_arch_suspend_notifier(kvm);</yellow>
	}

	return NOTIFY_DONE;
}
#endif /* CONFIG_HAVE_KVM_PM_NOTIFIER */

static int kvm_vm_ioctl_get_clock(struct kvm *kvm, void __user *argp)
{
<blue>	struct kvm_clock_data data = { 0 };</blue>

<blue>	get_kvmclock(kvm, &data);</blue>
<blue>	if (copy_to_user(argp, &data, sizeof(data)))</blue>
		return -EFAULT;

	return 0;
}

static int kvm_vm_ioctl_set_clock(struct kvm *kvm, void __user *argp)
{
	struct kvm_arch *ka = &amp;kvm-&gt;arch;
	struct kvm_clock_data data;
	u64 now_raw_ns;

<blue>	if (copy_from_user(&data, argp, sizeof(data)))</blue>
		return -EFAULT;

	/*
	 * Only KVM_CLOCK_REALTIME is used, but allow passing the
	 * result of KVM_GET_CLOCK back to KVM_SET_CLOCK.
	 */
<blue>	if (data.flags & ~KVM_CLOCK_VALID_FLAGS)</blue>
		return -EINVAL;

<blue>	kvm_hv_request_tsc_page_update(kvm);</blue>
	kvm_start_pvclock_update(kvm);
	pvclock_update_vm_gtod_copy(kvm);

	/*
	 * This pairs with kvm_guest_time_update(): when masterclock is
	 * in use, we use master_kernel_ns + kvmclock_offset to set
	 * unsigned &#x27;system_time&#x27; so if we use get_kvmclock_ns() (which
	 * is slightly ahead) here we risk going negative on unsigned
	 * &#x27;system_time&#x27; when &#x27;data.clock&#x27; is very small.
	 */
	if (data.flags &amp; KVM_CLOCK_REALTIME) {
<yellow>		u64 now_real_ns = ktime_get_real_ns();</yellow>

		/*
		 * Avoid stepping the kvmclock backwards.
		 */
		if (now_real_ns &gt; data.realtime)
<yellow>			data.clock += now_real_ns - data.realtime;</yellow>
	}

<blue>	if (ka->use_master_clock)</blue>
<blue>		now_raw_ns = ka->master_kernel_ns;</blue>
	else
<yellow>		now_raw_ns = get_kvmclock_base_ns();</yellow>
<blue>	ka->kvmclock_offset = data.clock - now_raw_ns;</blue>
	kvm_end_pvclock_update(kvm);
	return 0;
}

long kvm_arch_vm_ioctl(struct file *filp,
		       unsigned int ioctl, unsigned long arg)
<blue>{</blue>
<blue>	struct kvm *kvm = filp->private_data;</blue>
	void __user *argp = (void __user *)arg;
	int r = -ENOTTY;
	/*
	 * This union makes it completely explicit to gcc-3.x
	 * that these two variables&#x27; stack usage should be
	 * combined, not added together.
	 */
	union {
		struct kvm_pit_state ps;
		struct kvm_pit_state2 ps2;
		struct kvm_pit_config pit_config;
	} u;

	switch (ioctl) {
	case KVM_SET_TSS_ADDR:
<blue>		r = kvm_vm_ioctl_set_tss_addr(kvm, arg);</blue>
		break;
	case KVM_SET_IDENTITY_MAP_ADDR: {
		u64 ident_addr;

<blue>		mutex_lock(&kvm->lock);</blue>
		r = -EINVAL;
		if (kvm-&gt;created_vcpus)
			goto set_identity_unlock;
		r = -EFAULT;
<blue>		if (copy_from_user(&ident_addr, argp, sizeof(ident_addr)))</blue>
			goto set_identity_unlock;
<blue>		r = kvm_vm_ioctl_set_identity_map_addr(kvm, ident_addr);</blue>
set_identity_unlock:
<blue>		mutex_unlock(&kvm->lock);</blue>
		break;
	}
	case KVM_SET_NR_MMU_PAGES:
<yellow>		r = kvm_vm_ioctl_set_nr_mmu_pages(kvm, arg);</yellow>
		break;
	case KVM_GET_NR_MMU_PAGES:
<yellow>		r = kvm_vm_ioctl_get_nr_mmu_pages(kvm);</yellow>
		break;
	case KVM_CREATE_IRQCHIP: {
<blue>		mutex_lock(&kvm->lock);</blue>

		r = -EEXIST;
		if (irqchip_in_kernel(kvm))
			goto create_irqchip_unlock;

		r = -EINVAL;
<blue>		if (kvm->created_vcpus)</blue>
			goto create_irqchip_unlock;

<blue>		r = kvm_pic_init(kvm);</blue>
		if (r)
			goto create_irqchip_unlock;

<blue>		r = kvm_ioapic_init(kvm);</blue>
		if (r) {
<yellow>			kvm_pic_destroy(kvm);</yellow>
			goto create_irqchip_unlock;
		}

<blue>		r = kvm_setup_default_irq_routing(kvm);</blue>
		if (r) {
<yellow>			kvm_ioapic_destroy(kvm);</yellow>
			kvm_pic_destroy(kvm);
			goto create_irqchip_unlock;
		}
		/* Write kvm-&gt;irq_routing before enabling irqchip_in_kernel. */
		smp_wmb();
<blue>		kvm->arch.irqchip_mode = KVM_IRQCHIP_KERNEL;</blue>
		kvm_clear_apicv_inhibit(kvm, APICV_INHIBIT_REASON_ABSENT);
	create_irqchip_unlock:
		mutex_unlock(&amp;kvm-&gt;lock);
		break;
	}
	case KVM_CREATE_PIT:
<yellow>		u.pit_config.flags = KVM_PIT_SPEAKER_DUMMY;</yellow>
		goto create_pit;
	case KVM_CREATE_PIT2:
		r = -EFAULT;
<blue>		if (copy_from_user(&u.pit_config, argp,</blue>
				   sizeof(struct kvm_pit_config)))
			goto out;
	create_pit:
<blue>		mutex_lock(&kvm->lock);</blue>
		r = -EEXIST;
		if (kvm-&gt;arch.vpit)
			goto create_pit_unlock;
		r = -ENOMEM;
<blue>		kvm->arch.vpit = kvm_create_pit(kvm, u.pit_config.flags);</blue>
		if (kvm-&gt;arch.vpit)
			r = 0;
	create_pit_unlock:
<blue>		mutex_unlock(&kvm->lock);</blue>
		break;
	case KVM_GET_IRQCHIP: {
		/* 0: PIC master, 1: PIC slave, 2: IOAPIC */
		struct kvm_irqchip *chip;

<yellow>		chip = memdup_user(argp, sizeof(*chip));</yellow>
		if (IS_ERR(chip)) {
			r = PTR_ERR(chip);
			goto out;
		}

		r = -ENXIO;
<yellow>		if (!irqchip_kernel(kvm))</yellow>
			goto get_irqchip_out;
<yellow>		r = kvm_vm_ioctl_get_irqchip(kvm, chip);</yellow>
		if (r)
			goto get_irqchip_out;
		r = -EFAULT;
<yellow>		if (copy_to_user(argp, chip, sizeof(*chip)))</yellow>
			goto get_irqchip_out;
		r = 0;
	get_irqchip_out:
<yellow>		kfree(chip);</yellow>
		break;
	}
	case KVM_SET_IRQCHIP: {
		/* 0: PIC master, 1: PIC slave, 2: IOAPIC */
		struct kvm_irqchip *chip;

<blue>		chip = memdup_user(argp, sizeof(*chip));</blue>
		if (IS_ERR(chip)) {
			r = PTR_ERR(chip);
			goto out;
		}

		r = -ENXIO;
<blue>		if (!irqchip_kernel(kvm))</blue>
			goto set_irqchip_out;
<blue>		r = kvm_vm_ioctl_set_irqchip(kvm, chip);</blue>
	set_irqchip_out:
<blue>		kfree(chip);</blue>
		break;
	}
	case KVM_GET_PIT: {
		r = -EFAULT;
<yellow>		if (copy_from_user(&u.ps, argp, sizeof(struct kvm_pit_state)))</yellow>
			goto out;
		r = -ENXIO;
<yellow>		if (!kvm->arch.vpit)</yellow>
			goto out;
<yellow>		r = kvm_vm_ioctl_get_pit(kvm, &u.ps);</yellow>
		if (r)
			goto out;
		r = -EFAULT;
		if (copy_to_user(argp, &amp;u.ps, sizeof(struct kvm_pit_state)))
			goto out;
		r = 0;
		break;
	}
	case KVM_SET_PIT: {
		r = -EFAULT;
<yellow>		if (copy_from_user(&u.ps, argp, sizeof(u.ps)))</yellow>
			goto out;
<yellow>		mutex_lock(&kvm->lock);</yellow>
		r = -ENXIO;
		if (!kvm-&gt;arch.vpit)
			goto set_pit_out;
<yellow>		r = kvm_vm_ioctl_set_pit(kvm, &u.ps);</yellow>
set_pit_out:
		mutex_unlock(&amp;kvm-&gt;lock);
		break;
	}
	case KVM_GET_PIT2: {
		r = -ENXIO;
<blue>		if (!kvm->arch.vpit)</blue>
			goto out;
<blue>		r = kvm_vm_ioctl_get_pit2(kvm, &u.ps2);</blue>
		if (r)
			goto out;
		r = -EFAULT;
		if (copy_to_user(argp, &amp;u.ps2, sizeof(u.ps2)))
			goto out;
		r = 0;
		break;
	}
	case KVM_SET_PIT2: {
		r = -EFAULT;
<blue>		if (copy_from_user(&u.ps2, argp, sizeof(u.ps2)))</blue>
			goto out;
<blue>		mutex_lock(&kvm->lock);</blue>
		r = -ENXIO;
		if (!kvm-&gt;arch.vpit)
			goto set_pit2_out;
<blue>		r = kvm_vm_ioctl_set_pit2(kvm, &u.ps2);</blue>
set_pit2_out:
<blue>		mutex_unlock(&kvm->lock);</blue>
		break;
	}
	case KVM_REINJECT_CONTROL: {
		struct kvm_reinject_control control;
		r =  -EFAULT;
<yellow>		if (copy_from_user(&control, argp, sizeof(control)))</yellow>
			goto out;
		r = -ENXIO;
<yellow>		if (!kvm->arch.vpit)</yellow>
			goto out;
<yellow>		r = kvm_vm_ioctl_reinject(kvm, &control);</yellow>
		break;
	}
	case KVM_SET_BOOT_CPU_ID:
		r = 0;
<yellow>		mutex_lock(&kvm->lock);</yellow>
		if (kvm-&gt;created_vcpus)
			r = -EBUSY;
		else
<yellow>			kvm->arch.bsp_vcpu_id = arg;</yellow>
<blue>		mutex_unlock(&kvm->lock);</blue>
		break;
#ifdef CONFIG_KVM_XEN
	case KVM_XEN_HVM_CONFIG: {
		struct kvm_xen_hvm_config xhc;
		r = -EFAULT;
<yellow>		if (copy_from_user(&xhc, argp, sizeof(xhc)))</yellow>
			goto out;
<yellow>		r = kvm_xen_hvm_config(kvm, &xhc);</yellow>
		break;
	}
	case KVM_XEN_HVM_GET_ATTR: {
		struct kvm_xen_hvm_attr xha;

		r = -EFAULT;
<yellow>		if (copy_from_user(&xha, argp, sizeof(xha)))</yellow>
			goto out;
<yellow>		r = kvm_xen_hvm_get_attr(kvm, &xha);</yellow>
<yellow>		if (!r && copy_to_user(argp, &xha, sizeof(xha)))</yellow>
			r = -EFAULT;
		break;
	}
	case KVM_XEN_HVM_SET_ATTR: {
		struct kvm_xen_hvm_attr xha;

		r = -EFAULT;
<yellow>		if (copy_from_user(&xha, argp, sizeof(xha)))</yellow>
			goto out;
<yellow>		r = kvm_xen_hvm_set_attr(kvm, &xha);</yellow>
		break;
	}
	case KVM_XEN_HVM_EVTCHN_SEND: {
		struct kvm_irq_routing_xen_evtchn uxe;

		r = -EFAULT;
<yellow>		if (copy_from_user(&uxe, argp, sizeof(uxe)))</yellow>
			goto out;
<yellow>		r = kvm_xen_hvm_evtchn_send(kvm, &uxe);</yellow>
		break;
	}
#endif
	case KVM_SET_CLOCK:
<blue>		r = kvm_vm_ioctl_set_clock(kvm, argp);</blue>
		break;
	case KVM_GET_CLOCK:
<blue>		r = kvm_vm_ioctl_get_clock(kvm, argp);</blue>
<blue>		break;</blue>
	case KVM_SET_TSC_KHZ: {
		u32 user_tsc_khz;

		r = -EINVAL;
		user_tsc_khz = (u32)arg;

<yellow>		if (kvm_caps.has_tsc_control &&</yellow>
<yellow>		    user_tsc_khz >= kvm_caps.max_guest_tsc_khz)</yellow>
			goto out;

<yellow>		if (user_tsc_khz == 0)</yellow>
<yellow>			user_tsc_khz = tsc_khz;</yellow>

<yellow>		WRITE_ONCE(kvm->arch.default_tsc_khz, user_tsc_khz);</yellow>
		r = 0;

		goto out;
	}
	case KVM_GET_TSC_KHZ: {
<yellow>		r = READ_ONCE(kvm->arch.default_tsc_khz);</yellow>
		goto out;
	}
	case KVM_MEMORY_ENCRYPT_OP: {
		r = -ENOTTY;
<yellow>		if (!kvm_x86_ops.mem_enc_ioctl)</yellow>
			goto out;

<yellow>		r = static_call(kvm_x86_mem_enc_ioctl)(kvm, argp);</yellow>
		break;
	}
	case KVM_MEMORY_ENCRYPT_REG_REGION: {
		struct kvm_enc_region region;

		r = -EFAULT;
<yellow>		if (copy_from_user(&region, argp, sizeof(region)))</yellow>
			goto out;

		r = -ENOTTY;
<yellow>		if (!kvm_x86_ops.mem_enc_register_region)</yellow>
			goto out;

<yellow>		r = static_call(kvm_x86_mem_enc_register_region)(kvm, &region);</yellow>
		break;
	}
	case KVM_MEMORY_ENCRYPT_UNREG_REGION: {
		struct kvm_enc_region region;

		r = -EFAULT;
<yellow>		if (copy_from_user(&region, argp, sizeof(region)))</yellow>
<blue>			goto out;</blue>

		r = -ENOTTY;
<yellow>		if (!kvm_x86_ops.mem_enc_unregister_region)</yellow>
			goto out;

<yellow>		r = static_call(kvm_x86_mem_enc_unregister_region)(kvm, &region);</yellow>
		break;
	}
	case KVM_HYPERV_EVENTFD: {
		struct kvm_hyperv_eventfd hvevfd;

		r = -EFAULT;
<yellow>		if (copy_from_user(&hvevfd, argp, sizeof(hvevfd)))</yellow>
			goto out;
<yellow>		r = kvm_vm_ioctl_hv_eventfd(kvm, &hvevfd);</yellow>
		break;
	}
	case KVM_SET_PMU_EVENT_FILTER:
<yellow>		r = kvm_vm_ioctl_set_pmu_event_filter(kvm, argp);</yellow>
		break;
	case KVM_X86_SET_MSR_FILTER: {
		struct kvm_msr_filter __user *user_msr_filter = argp;
		struct kvm_msr_filter filter;

<yellow>		if (copy_from_user(&filter, user_msr_filter, sizeof(filter)))</yellow>
<yellow>			return -EFAULT;</yellow>

<yellow>		r = kvm_vm_ioctl_set_msr_filter(kvm, &filter);</yellow>
		break;
	}
	default:
		r = -ENOTTY;
	}
out:
<yellow>	return r;</yellow>
}

static void kvm_init_msr_list(void)
{
	u32 dummy[2];
	unsigned i;

	BUILD_BUG_ON_MSG(KVM_PMC_MAX_FIXED != 3,
			 &quot;Please update the fixed PMCs in msrs_to_saved_all[]&quot;);

	num_msrs_to_save = 0;
	num_emulated_msrs = 0;
	num_msr_based_features = 0;

<yellow>	for (i = 0; i < ARRAY_SIZE(msrs_to_save_all); i++) {</yellow>
<yellow>		if (rdmsr_safe(msrs_to_save_all[i], &dummy[0], &dummy[1]) < 0)</yellow>
			continue;

		/*
		 * Even MSRs that are valid in the host may not be exposed
		 * to the guests in some cases.
		 */
<yellow>		switch (msrs_to_save_all[i]) {</yellow>
		case MSR_IA32_BNDCFGS:
<yellow>			if (!kvm_mpx_supported())</yellow>
				continue;
			break;
		case MSR_TSC_AUX:
<yellow>			if (!kvm_cpu_cap_has(X86_FEATURE_RDTSCP) &&</yellow>
			    !kvm_cpu_cap_has(X86_FEATURE_RDPID))
				continue;
			break;
		case MSR_IA32_UMWAIT_CONTROL:
<yellow>			if (!kvm_cpu_cap_has(X86_FEATURE_WAITPKG))</yellow>
				continue;
			break;
		case MSR_IA32_RTIT_CTL:
		case MSR_IA32_RTIT_STATUS:
<yellow>			if (!kvm_cpu_cap_has(X86_FEATURE_INTEL_PT))</yellow>
				continue;
			break;
		case MSR_IA32_RTIT_CR3_MATCH:
<yellow>			if (!kvm_cpu_cap_has(X86_FEATURE_INTEL_PT) ||</yellow>
<yellow>			    !intel_pt_validate_hw_cap(PT_CAP_cr3_filtering))</yellow>
				continue;
			break;
		case MSR_IA32_RTIT_OUTPUT_BASE:
		case MSR_IA32_RTIT_OUTPUT_MASK:
<yellow>			if (!kvm_cpu_cap_has(X86_FEATURE_INTEL_PT) ||</yellow>
<yellow>				(!intel_pt_validate_hw_cap(PT_CAP_topa_output) &&</yellow>
<yellow>				 !intel_pt_validate_hw_cap(PT_CAP_single_range_output)))</yellow>
				continue;
			break;
		case MSR_IA32_RTIT_ADDR0_A ... MSR_IA32_RTIT_ADDR3_B:
<yellow>			if (!kvm_cpu_cap_has(X86_FEATURE_INTEL_PT) ||</yellow>
<yellow>				msrs_to_save_all[i] - MSR_IA32_RTIT_ADDR0_A >=</yellow>
				intel_pt_validate_hw_cap(PT_CAP_num_address_ranges) * 2)
				continue;
			break;
		case MSR_ARCH_PERFMON_PERFCTR0 ... MSR_ARCH_PERFMON_PERFCTR_MAX:
<yellow>			if (msrs_to_save_all[i] - MSR_ARCH_PERFMON_PERFCTR0 >=</yellow>
			    min(KVM_INTEL_PMC_MAX_GENERIC, kvm_pmu_cap.num_counters_gp))
				continue;
			break;
		case MSR_ARCH_PERFMON_EVENTSEL0 ... MSR_ARCH_PERFMON_EVENTSEL_MAX:
<yellow>			if (msrs_to_save_all[i] - MSR_ARCH_PERFMON_EVENTSEL0 >=</yellow>
			    min(KVM_INTEL_PMC_MAX_GENERIC, kvm_pmu_cap.num_counters_gp))
				continue;
			break;
		case MSR_IA32_XFD:
		case MSR_IA32_XFD_ERR:
<yellow>			if (!kvm_cpu_cap_has(X86_FEATURE_XFD))</yellow>
				continue;
			break;
		default:
			break;
		}

<yellow>		msrs_to_save[num_msrs_to_save++] = msrs_to_save_all[i];</yellow>
	}

<yellow>	for (i = 0; i < ARRAY_SIZE(emulated_msrs_all); i++) {</yellow>
<yellow>		if (!static_call(kvm_x86_has_emulated_msr)(NULL, emulated_msrs_all[i]))</yellow>
			continue;

<yellow>		emulated_msrs[num_emulated_msrs++] = emulated_msrs_all[i];</yellow>
	}

<yellow>	for (i = 0; i < ARRAY_SIZE(msr_based_features_all); i++) {</yellow>
		struct kvm_msr_entry msr;

<yellow>		msr.index = msr_based_features_all[i];</yellow>
<yellow>		if (kvm_get_msr_feature(&msr))</yellow>
			continue;

<yellow>		msr_based_features[num_msr_based_features++] = msr_based_features_all[i];</yellow>
	}
}

static int vcpu_mmio_write(struct kvm_vcpu *vcpu, gpa_t addr, int len,
			   const void *v)
{
	int handled = 0;
	int n;

	do {
<blue>		n = min(len, 8);</blue>
<yellow>		if (!(lapic_in_kernel(vcpu) &&</yellow>
<blue>		      !kvm_iodevice_write(vcpu, &vcpu->arch.apic->dev, addr, n, v))</blue>
<blue>		    && kvm_io_bus_write(vcpu, KVM_MMIO_BUS, addr, n, v))</blue>
			break;
		handled += n;
		addr += n;
<yellow>		len -= n;</yellow>
		v += n;
	} while (len);

	return handled;
}

static int vcpu_mmio_read(struct kvm_vcpu *vcpu, gpa_t addr, int len, void *v)
{
	int handled = 0;
	int n;

	do {
<blue>		n = min(len, 8);</blue>
<yellow>		if (!(lapic_in_kernel(vcpu) &&</yellow>
<blue>		      !kvm_iodevice_read(vcpu, &vcpu->arch.apic->dev,</blue>
					 addr, n, v))
<blue>		    && kvm_io_bus_read(vcpu, KVM_MMIO_BUS, addr, n, v))</blue>
			break;
<yellow>		trace_kvm_mmio(KVM_TRACE_MMIO_READ, n, addr, v);</yellow>
		handled += n;
		addr += n;
<yellow>		len -= n;</yellow>
		v += n;
	} while (len);

	return handled;
<blue>}</blue>

static void kvm_set_segment(struct kvm_vcpu *vcpu,
			struct kvm_segment *var, int seg)
{
<blue>	static_call(kvm_x86_set_segment)(vcpu, var, seg);</blue>
}

void kvm_get_segment(struct kvm_vcpu *vcpu,
		     struct kvm_segment *var, int seg)
{
<blue>	static_call(kvm_x86_get_segment)(vcpu, var, seg);</blue>
}

gpa_t translate_nested_gpa(struct kvm_vcpu *vcpu, gpa_t gpa, u64 access,
			   struct x86_exception *exception)
{
<blue>	struct kvm_mmu *mmu = vcpu->arch.mmu;</blue>
	gpa_t t_gpa;

<yellow>	BUG_ON(!mmu_is_nested(vcpu));</yellow>

	/* NPT walks are always user-walks */
	access |= PFERR_USER_MASK;
<blue>	t_gpa  = mmu->gva_to_gpa(vcpu, mmu, gpa, access, exception);</blue>

	return t_gpa;
}

gpa_t kvm_mmu_gva_to_gpa_read(struct kvm_vcpu *vcpu, gva_t gva,
			      struct x86_exception *exception)
{
<yellow>	struct kvm_mmu *mmu = vcpu->arch.walk_mmu;</yellow>

	u64 access = (static_call(kvm_x86_get_cpl)(vcpu) == 3) ? PFERR_USER_MASK : 0;
	return mmu-&gt;gva_to_gpa(vcpu, mmu, gva, access, exception);
}
EXPORT_SYMBOL_GPL(kvm_mmu_gva_to_gpa_read);

 gpa_t kvm_mmu_gva_to_gpa_fetch(struct kvm_vcpu *vcpu, gva_t gva,
				struct x86_exception *exception)
{
<yellow>	struct kvm_mmu *mmu = vcpu->arch.walk_mmu;</yellow>

	u64 access = (static_call(kvm_x86_get_cpl)(vcpu) == 3) ? PFERR_USER_MASK : 0;
	access |= PFERR_FETCH_MASK;
	return mmu-&gt;gva_to_gpa(vcpu, mmu, gva, access, exception);
}

gpa_t kvm_mmu_gva_to_gpa_write(struct kvm_vcpu *vcpu, gva_t gva,
			       struct x86_exception *exception)
{
<yellow>	struct kvm_mmu *mmu = vcpu->arch.walk_mmu;</yellow>

	u64 access = (static_call(kvm_x86_get_cpl)(vcpu) == 3) ? PFERR_USER_MASK : 0;
	access |= PFERR_WRITE_MASK;
	return mmu-&gt;gva_to_gpa(vcpu, mmu, gva, access, exception);
}
EXPORT_SYMBOL_GPL(kvm_mmu_gva_to_gpa_write);

/* uses this to access any guest&#x27;s mapped memory without checking CPL */
gpa_t kvm_mmu_gva_to_gpa_system(struct kvm_vcpu *vcpu, gva_t gva,
				struct x86_exception *exception)
{
<yellow>	struct kvm_mmu *mmu = vcpu->arch.walk_mmu;</yellow>

	return mmu-&gt;gva_to_gpa(vcpu, mmu, gva, 0, exception);
}

static int kvm_read_guest_virt_helper(gva_t addr, void *val, unsigned int bytes,
				      struct kvm_vcpu *vcpu, u64 access,
				      struct x86_exception *exception)
{
<blue>	struct kvm_mmu *mmu = vcpu->arch.walk_mmu;</blue>
	void *data = val;
	int r = X86EMUL_CONTINUE;

	while (bytes) {
<blue>		gpa_t gpa = mmu->gva_to_gpa(vcpu, mmu, addr, access, exception);</blue>
		unsigned offset = addr &amp; (PAGE_SIZE-1);
		unsigned toread = min(bytes, (unsigned)PAGE_SIZE - offset);
		int ret;

		if (gpa == INVALID_GPA)
			return X86EMUL_PROPAGATE_FAULT;
<blue>		ret = kvm_vcpu_read_guest_page(vcpu, gpa >> PAGE_SHIFT, data,</blue>
					       offset, toread);
		if (ret &lt; 0) {
			r = X86EMUL_IO_NEEDED;
			goto out;
		}

<blue>		bytes -= toread;</blue>
		data += toread;
		addr += toread;
	}
out:
	return r;
<blue>}</blue>

/* used for instruction fetching */
static int kvm_fetch_guest_virt(struct x86_emulate_ctxt *ctxt,
				gva_t addr, void *val, unsigned int bytes,
				struct x86_exception *exception)
{
<blue>	struct kvm_vcpu *vcpu = emul_to_vcpu(ctxt);</blue>
	struct kvm_mmu *mmu = vcpu-&gt;arch.walk_mmu;
	u64 access = (static_call(kvm_x86_get_cpl)(vcpu) == 3) ? PFERR_USER_MASK : 0;
	unsigned offset;
	int ret;

	/* Inline kvm_read_guest_virt_helper for speed.  */
	gpa_t gpa = mmu-&gt;gva_to_gpa(vcpu, mmu, addr, access|PFERR_FETCH_MASK,
				    exception);
	if (unlikely(gpa == INVALID_GPA))
		return X86EMUL_PROPAGATE_FAULT;

<blue>	offset = addr & (PAGE_SIZE-1);</blue>
<yellow>	if (WARN_ON(offset + bytes > PAGE_SIZE))</yellow>
		bytes = (unsigned)PAGE_SIZE - offset;
<blue>	ret = kvm_vcpu_read_guest_page(vcpu, gpa >> PAGE_SHIFT, val,</blue>
				       offset, bytes);
	if (unlikely(ret &lt; 0))
		return X86EMUL_IO_NEEDED;

	return X86EMUL_CONTINUE;
<blue>}</blue>

int kvm_read_guest_virt(struct kvm_vcpu *vcpu,
			       gva_t addr, void *val, unsigned int bytes,
			       struct x86_exception *exception)
{
<blue>	u64 access = (static_call(kvm_x86_get_cpl)(vcpu) == 3) ? PFERR_USER_MASK : 0;</blue>

	/*
	 * FIXME: this should call handle_emulation_failure if X86EMUL_IO_NEEDED
	 * is returned, but our callers are not ready for that and they blindly
	 * call kvm_inject_page_fault.  Ensure that they at least do not leak
	 * uninitialized kernel stack memory into cr2 and error code.
	 */
	memset(exception, 0, sizeof(*exception));
	return kvm_read_guest_virt_helper(addr, val, bytes, vcpu, access,
					  exception);
}
EXPORT_SYMBOL_GPL(kvm_read_guest_virt);

static int emulator_read_std(struct x86_emulate_ctxt *ctxt,
			     gva_t addr, void *val, unsigned int bytes,
			     struct x86_exception *exception, bool system)
{
<yellow>	struct kvm_vcpu *vcpu = emul_to_vcpu(ctxt);</yellow>
	u64 access = 0;

	if (system)
		access |= PFERR_IMPLICIT_ACCESS;
<yellow>	else if (static_call(kvm_x86_get_cpl)(vcpu) == 3)</yellow>
		access |= PFERR_USER_MASK;

<yellow>	return kvm_read_guest_virt_helper(addr, val, bytes, vcpu, access, exception);</yellow>
}

static int kvm_read_guest_phys_system(struct x86_emulate_ctxt *ctxt,
		unsigned long addr, void *val, unsigned int bytes)
{
<yellow>	struct kvm_vcpu *vcpu = emul_to_vcpu(ctxt);</yellow>
	int r = kvm_vcpu_read_guest(vcpu, addr, val, bytes);

<yellow>	return r < 0 ? X86EMUL_IO_NEEDED : X86EMUL_CONTINUE;</yellow>
}

static int kvm_write_guest_virt_helper(gva_t addr, void *val, unsigned int bytes,
				      struct kvm_vcpu *vcpu, u64 access,
				      struct x86_exception *exception)
{
<blue>	struct kvm_mmu *mmu = vcpu->arch.walk_mmu;</blue>
	void *data = val;
	int r = X86EMUL_CONTINUE;

	while (bytes) {
<blue>		gpa_t gpa = mmu->gva_to_gpa(vcpu, mmu, addr, access, exception);</blue>
		unsigned offset = addr &amp; (PAGE_SIZE-1);
		unsigned towrite = min(bytes, (unsigned)PAGE_SIZE - offset);
		int ret;

		if (gpa == INVALID_GPA)
			return X86EMUL_PROPAGATE_FAULT;
<blue>		ret = kvm_vcpu_write_guest(vcpu, gpa, data, towrite);</blue>
		if (ret &lt; 0) {
			r = X86EMUL_IO_NEEDED;
			goto out;
		}

<blue>		bytes -= towrite;</blue>
		data += towrite;
		addr += towrite;
	}
out:
	return r;
<blue>}</blue>

static int emulator_write_std(struct x86_emulate_ctxt *ctxt, gva_t addr, void *val,
			      unsigned int bytes, struct x86_exception *exception,
			      bool system)
{
<yellow>	struct kvm_vcpu *vcpu = emul_to_vcpu(ctxt);</yellow>
	u64 access = PFERR_WRITE_MASK;

	if (system)
		access |= PFERR_IMPLICIT_ACCESS;
<yellow>	else if (static_call(kvm_x86_get_cpl)(vcpu) == 3)</yellow>
		access |= PFERR_USER_MASK;

<yellow>	return kvm_write_guest_virt_helper(addr, val, bytes, vcpu,</yellow>
					   access, exception);
}

int kvm_write_guest_virt_system(struct kvm_vcpu *vcpu, gva_t addr, void *val,
				unsigned int bytes, struct x86_exception *exception)
{
	/* kvm_write_guest_virt_system can pull in tons of pages. */
<blue>	vcpu->arch.l1tf_flush_l1d = true;</blue>

	return kvm_write_guest_virt_helper(addr, val, bytes, vcpu,
					   PFERR_WRITE_MASK, exception);
}
EXPORT_SYMBOL_GPL(kvm_write_guest_virt_system);

static int kvm_can_emulate_insn(struct kvm_vcpu *vcpu, int emul_type,
				void *insn, int insn_len)
{
<blue>	return static_call(kvm_x86_can_emulate_instruction)(vcpu, emul_type,</blue>
							    insn, insn_len);
}

int handle_ud(struct kvm_vcpu *vcpu)
<blue>{</blue>
	static const char kvm_emulate_prefix[] = { __KVM_EMULATE_PREFIX };
	int fep_flags = READ_ONCE(force_emulation_prefix);
	int emul_type = EMULTYPE_TRAP_UD;
	char sig[5]; /* ud2; .ascii &quot;kvm&quot; */
	struct x86_exception e;

<blue>	if (unlikely(!kvm_can_emulate_insn(vcpu, emul_type, NULL, 0)))</blue>
		return 1;

<blue>	if (fep_flags &&</blue>
<yellow>	    kvm_read_guest_virt(vcpu, kvm_get_linear_rip(vcpu),</yellow>
				sig, sizeof(sig), &amp;e) == 0 &amp;&amp;
<yellow>	    memcmp(sig, kvm_emulate_prefix, sizeof(sig)) == 0) {</yellow>
<yellow>		if (fep_flags & KVM_FEP_CLEAR_RFLAGS_RF)</yellow>
<yellow>			kvm_set_rflags(vcpu, kvm_get_rflags(vcpu) & ~X86_EFLAGS_RF);</yellow>
<yellow>		kvm_rip_write(vcpu, kvm_rip_read(vcpu) + sizeof(sig));</yellow>
		emul_type = EMULTYPE_TRAP_UD_FORCED;
	}

<blue>	return kvm_emulate_instruction(vcpu, emul_type);</blue>
}
EXPORT_SYMBOL_GPL(handle_ud);

static int vcpu_is_mmio_gpa(struct kvm_vcpu *vcpu, unsigned long gva,
			    gpa_t gpa, bool write)
{
	/* For APIC access vmexit */
<blue>	if ((gpa & PAGE_MASK) == APIC_DEFAULT_PHYS_BASE)</blue>
		return 1;

<blue>	if (vcpu_match_mmio_gpa(vcpu, gpa)) {</blue>
<blue>		trace_vcpu_match_mmio(gva, gpa, write, true);</blue>
		return 1;
	}

	return 0;
<blue>}</blue>

static int vcpu_mmio_gva_to_gpa(struct kvm_vcpu *vcpu, unsigned long gva,
				gpa_t *gpa, struct x86_exception *exception,
				bool write)
{
<blue>	struct kvm_mmu *mmu = vcpu->arch.walk_mmu;</blue>
	u64 access = ((static_call(kvm_x86_get_cpl)(vcpu) == 3) ? PFERR_USER_MASK : 0)
		| (write ? PFERR_WRITE_MASK : 0);

	/*
	 * currently PKRU is only applied to ept enabled guest so
	 * there is no pkey in EPT page table for L1 guest or EPT
	 * shadow page table for L2 guest.
	 */
<blue>	if (vcpu_match_mmio_gva(vcpu, gva) && (!is_paging(vcpu) ||</blue>
<yellow>	    !permission_fault(vcpu, vcpu->arch.walk_mmu,</yellow>
			      vcpu-&gt;arch.mmio_access, 0, access))) {
<yellow>		*gpa = vcpu->arch.mmio_gfn << PAGE_SHIFT |</yellow>
					(gva &amp; (PAGE_SIZE - 1));
<yellow>		trace_vcpu_match_mmio(gva, *gpa, write, false);</yellow>
		return 1;
	}

<blue>	*gpa = mmu->gva_to_gpa(vcpu, mmu, gva, access, exception);</blue>

	if (*gpa == INVALID_GPA)
		return -1;

<blue>	return vcpu_is_mmio_gpa(vcpu, gva, *gpa, write);</blue>
}

int emulator_write_phys(struct kvm_vcpu *vcpu, gpa_t gpa,
			const void *val, int bytes)
{
	int ret;

<blue>	ret = kvm_vcpu_write_guest(vcpu, gpa, val, bytes);</blue>
	if (ret &lt; 0)
		return 0;
<blue>	kvm_page_track_write(vcpu, gpa, val, bytes);</blue>
	return 1;
<yellow>}</yellow>

struct read_write_emulator_ops {
	int (*read_write_prepare)(struct kvm_vcpu *vcpu, void *val,
				  int bytes);
	int (*read_write_emulate)(struct kvm_vcpu *vcpu, gpa_t gpa,
				  void *val, int bytes);
	int (*read_write_mmio)(struct kvm_vcpu *vcpu, gpa_t gpa,
			       int bytes, void *val);
	int (*read_write_exit_mmio)(struct kvm_vcpu *vcpu, gpa_t gpa,
				    void *val, int bytes);
	bool write;
};

<blue>static int read_prepare(struct kvm_vcpu *vcpu, void *val, int bytes)</blue>
{
<blue>	if (vcpu->mmio_read_completed) {</blue>
<blue>		trace_kvm_mmio(KVM_TRACE_MMIO_READ, bytes,</blue>
			       vcpu-&gt;mmio_fragments[0].gpa, val);
<blue>		vcpu->mmio_read_completed = 0;</blue>
		return 1;
	}

	return 0;
<blue>}</blue>

static int read_emulate(struct kvm_vcpu *vcpu, gpa_t gpa,
			void *val, int bytes)
{
<blue>	return !kvm_vcpu_read_guest(vcpu, gpa, val, bytes);</blue>
}

static int write_emulate(struct kvm_vcpu *vcpu, gpa_t gpa,
			 void *val, int bytes)
{
<blue>	return emulator_write_phys(vcpu, gpa, val, bytes);</blue>
<blue>}</blue>

static int write_mmio(struct kvm_vcpu *vcpu, gpa_t gpa, int bytes, void *val)
{
<blue>	trace_kvm_mmio(KVM_TRACE_MMIO_WRITE, bytes, gpa, val);</blue>
<blue>	return vcpu_mmio_write(vcpu, gpa, bytes, val);</blue>
<blue>}</blue>

static int read_exit_mmio(struct kvm_vcpu *vcpu, gpa_t gpa,
			  void *val, int bytes)
{
<blue>	trace_kvm_mmio(KVM_TRACE_MMIO_READ_UNSATISFIED, bytes, gpa, NULL);</blue>
	return X86EMUL_IO_NEEDED;
<blue>}</blue>

static int write_exit_mmio(struct kvm_vcpu *vcpu, gpa_t gpa,
			   void *val, int bytes)
{
	struct kvm_mmio_fragment *frag = &amp;vcpu-&gt;mmio_fragments[0];

<blue>	memcpy(vcpu->run->mmio.data, frag->data, min(8u, frag->len));</blue>
	return X86EMUL_CONTINUE;
}

static const struct read_write_emulator_ops read_emultor = {
	.read_write_prepare = read_prepare,
	.read_write_emulate = read_emulate,
	.read_write_mmio = vcpu_mmio_read,
	.read_write_exit_mmio = read_exit_mmio,
};

static const struct read_write_emulator_ops write_emultor = {
	.read_write_emulate = write_emulate,
	.read_write_mmio = write_mmio,
	.read_write_exit_mmio = write_exit_mmio,
	.write = true,
};

static int emulator_read_write_onepage(unsigned long addr, void *val,
				       unsigned int bytes,
				       struct x86_exception *exception,
				       struct kvm_vcpu *vcpu,
				       const struct read_write_emulator_ops *ops)
{
	gpa_t gpa;
	int handled, ret;
<blue>	bool write = ops->write;</blue>
	struct kvm_mmio_fragment *frag;
<blue>	struct x86_emulate_ctxt *ctxt = vcpu->arch.emulate_ctxt;</blue>

	/*
	 * If the exit was due to a NPF we may already have a GPA.
	 * If the GPA is present, use it to avoid the GVA to GPA table walk.
	 * Note, this cannot be used on string operations since string
	 * operation using rep will only have the initial GPA from the NPF
	 * occurred.
	 */
<blue>	if (ctxt->gpa_available && emulator_can_use_gpa(ctxt) &&</blue>
<blue>	    (addr & ~PAGE_MASK) == (ctxt->gpa_val & ~PAGE_MASK)) {</blue>
		gpa = ctxt-&gt;gpa_val;
<blue>		ret = vcpu_is_mmio_gpa(vcpu, addr, gpa, write);</blue>
	} else {
<blue>		ret = vcpu_mmio_gva_to_gpa(vcpu, addr, &gpa, exception, write);</blue>
		if (ret &lt; 0)
			return X86EMUL_PROPAGATE_FAULT;
	}

<blue>	if (!ret && ops->read_write_emulate(vcpu, gpa, val, bytes))</blue>
		return X86EMUL_CONTINUE;

	/*
	 * Is this MMIO handled locally?
	 */
<blue>	handled = ops->read_write_mmio(vcpu, gpa, bytes, val);</blue>
	if (handled == bytes)
		return X86EMUL_CONTINUE;

<blue>	gpa += handled;</blue>
	bytes -= handled;
	val += handled;

<yellow>	WARN_ON(vcpu->mmio_nr_fragments >= KVM_MAX_MMIO_FRAGMENTS);</yellow>
<blue>	frag = &vcpu->mmio_fragments[vcpu->mmio_nr_fragments++];</blue>
	frag-&gt;gpa = gpa;
	frag-&gt;data = val;
	frag-&gt;len = bytes;
	return X86EMUL_CONTINUE;
<blue>}</blue>

static int emulator_read_write(struct x86_emulate_ctxt *ctxt,
			unsigned long addr,
			void *val, unsigned int bytes,
			struct x86_exception *exception,
			const struct read_write_emulator_ops *ops)
{
<blue>	struct kvm_vcpu *vcpu = emul_to_vcpu(ctxt);</blue>
	gpa_t gpa;
	int rc;

	if (ops-&gt;read_write_prepare &amp;&amp;
<blue>		  ops->read_write_prepare(vcpu, val, bytes))</blue>
		return X86EMUL_CONTINUE;

<blue>	vcpu->mmio_nr_fragments = 0;</blue>

	/* Crossing a page boundary? */
	if (((addr + bytes - 1) ^ addr) &amp; PAGE_MASK) {
		int now;

<blue>		now = -addr & ~PAGE_MASK;</blue>
		rc = emulator_read_write_onepage(addr, val, now, exception,
						 vcpu, ops);

		if (rc != X86EMUL_CONTINUE)
			return rc;
<blue>		addr += now;</blue>
		if (ctxt-&gt;mode != X86EMUL_MODE_PROT64)
<yellow>			addr = (u32)addr;</yellow>
<blue>		val += now;</blue>
		bytes -= now;
	}

<blue>	rc = emulator_read_write_onepage(addr, val, bytes, exception,</blue>
					 vcpu, ops);
	if (rc != X86EMUL_CONTINUE)
		return rc;

<blue>	if (!vcpu->mmio_nr_fragments)</blue>
		return rc;

<blue>	gpa = vcpu->mmio_fragments[0].gpa;</blue>

	vcpu-&gt;mmio_needed = 1;
	vcpu-&gt;mmio_cur_fragment = 0;

	vcpu-&gt;run-&gt;mmio.len = min(8u, vcpu-&gt;mmio_fragments[0].len);
<blue>	vcpu->run->mmio.is_write = vcpu->mmio_is_write = ops->write;</blue>
	vcpu-&gt;run-&gt;exit_reason = KVM_EXIT_MMIO;
	vcpu-&gt;run-&gt;mmio.phys_addr = gpa;

	return ops-&gt;read_write_exit_mmio(vcpu, gpa, val, bytes);
<blue>}</blue>

static int emulator_read_emulated(struct x86_emulate_ctxt *ctxt,
				  unsigned long addr,
				  void *val,
				  unsigned int bytes,
				  struct x86_exception *exception)
{
<blue>	return emulator_read_write(ctxt, addr, val, bytes,</blue>
				   exception, &amp;read_emultor);
}

static int emulator_write_emulated(struct x86_emulate_ctxt *ctxt,
			    unsigned long addr,
			    const void *val,
			    unsigned int bytes,
			    struct x86_exception *exception)
{
<blue>	return emulator_read_write(ctxt, addr, (void *)val, bytes,</blue>
				   exception, &amp;write_emultor);
}

#define emulator_try_cmpxchg_user(t, ptr, old, new) \
	(__try_cmpxchg_user((t __user *)(ptr), (t *)(old), *(t *)(new), efault ## t))

static int emulator_cmpxchg_emulated(struct x86_emulate_ctxt *ctxt,
				     unsigned long addr,
				     const void *old,
				     const void *new,
				     unsigned int bytes,
				     struct x86_exception *exception)
{
<yellow>	struct kvm_vcpu *vcpu = emul_to_vcpu(ctxt);</yellow>
	u64 page_line_mask;
	unsigned long hva;
	gpa_t gpa;
	int r;

	/* guests cmpxchg8b have to be emulated atomically */
<yellow>	if (bytes > 8 || (bytes & (bytes - 1)))</yellow>
		goto emul_write;

<yellow>	gpa = kvm_mmu_gva_to_gpa_write(vcpu, addr, NULL);</yellow>

	if (gpa == INVALID_GPA ||
<yellow>	    (gpa & PAGE_MASK) == APIC_DEFAULT_PHYS_BASE)</yellow>
		goto emul_write;

	/*
	 * Emulate the atomic as a straight write to avoid #AC if SLD is
	 * enabled in the host and the access splits a cache line.
	 */
<yellow>	if (boot_cpu_has(X86_FEATURE_SPLIT_LOCK_DETECT))</yellow>
<yellow>		page_line_mask = ~(cache_line_size() - 1);</yellow>
	else
		page_line_mask = PAGE_MASK;

<yellow>	if (((gpa + bytes - 1) & page_line_mask) != (gpa & page_line_mask))</yellow>
		goto emul_write;

<yellow>	hva = kvm_vcpu_gfn_to_hva(vcpu, gpa_to_gfn(gpa));</yellow>
	if (kvm_is_error_hva(hva))
		goto emul_write;

<yellow>	hva += offset_in_page(gpa);</yellow>

	switch (bytes) {
	case 1:
<yellow>		r = emulator_try_cmpxchg_user(u8, hva, old, new);</yellow>
		break;
	case 2:
<yellow>		r = emulator_try_cmpxchg_user(u16, hva, old, new);</yellow>
		break;
	case 4:
<yellow>		r = emulator_try_cmpxchg_user(u32, hva, old, new);</yellow>
		break;
	case 8:
<yellow>		r = emulator_try_cmpxchg_user(u64, hva, old, new);</yellow>
		break;
	default:
<yellow>		BUG();</yellow>
	}

	if (r &lt; 0)
		return X86EMUL_UNHANDLEABLE;
<yellow>	if (r)</yellow>
		return X86EMUL_CMPXCHG_FAILED;

<yellow>	kvm_page_track_write(vcpu, gpa, new, bytes);</yellow>

	return X86EMUL_CONTINUE;

emul_write:
<yellow>	printk_once(KERN_WARNING "kvm: emulating exchange as write\n");</yellow>

<yellow>	return emulator_write_emulated(ctxt, addr, new, bytes, exception);</yellow>
<yellow>}</yellow>

static int emulator_pio_in_out(struct kvm_vcpu *vcpu, int size,
			       unsigned short port, void *data,
			       unsigned int count, bool in)
{
	unsigned i;
	int r;

<blue>	WARN_ON_ONCE(vcpu->arch.pio.count);</blue>
<blue>	for (i = 0; i < count; i++) {</blue>
<blue>		if (in)</blue>
<blue>			r = kvm_io_bus_read(vcpu, KVM_PIO_BUS, port, size, data);</blue>
		else
<blue>			r = kvm_io_bus_write(vcpu, KVM_PIO_BUS, port, size, data);</blue>

<blue>		if (r) {</blue>
<blue>			if (i == 0)</blue>
				goto userspace_io;

			/*
			 * Userspace must have unregistered the device while PIO
			 * was running.  Drop writes / read as 0.
			 */
<yellow>			if (in)</yellow>
<yellow>				memset(data, 0, size * (count - i));</yellow>
			break;
		}

		data += size;
	}
	return 1;

userspace_io:
<blue>	vcpu->arch.pio.port = port;</blue>
	vcpu-&gt;arch.pio.in = in;
	vcpu-&gt;arch.pio.count = count;
	vcpu-&gt;arch.pio.size = size;

	if (in)
<blue>		memset(vcpu->arch.pio_data, 0, size * count);</blue>
	else
<blue>		memcpy(vcpu->arch.pio_data, data, size * count);</blue>

<blue>	vcpu->run->exit_reason = KVM_EXIT_IO;</blue>
	vcpu-&gt;run-&gt;io.direction = in ? KVM_EXIT_IO_IN : KVM_EXIT_IO_OUT;
	vcpu-&gt;run-&gt;io.size = size;
	vcpu-&gt;run-&gt;io.data_offset = KVM_PIO_PAGE_OFFSET * PAGE_SIZE;
	vcpu-&gt;run-&gt;io.count = count;
	vcpu-&gt;run-&gt;io.port = port;
	return 0;
<blue>}</blue>

static int emulator_pio_in(struct kvm_vcpu *vcpu, int size,
      			   unsigned short port, void *val, unsigned int count)
{
	int r = emulator_pio_in_out(vcpu, size, port, val, count, true);
	if (r)
<blue>		trace_kvm_pio(KVM_PIO_IN, port, size, count, val);</blue>

	return r;
}

static void complete_emulator_pio_in(struct kvm_vcpu *vcpu, void *val)
{
<blue>	int size = vcpu->arch.pio.size;</blue>
	unsigned int count = vcpu-&gt;arch.pio.count;
	memcpy(val, vcpu-&gt;arch.pio_data, size * count);
<yellow>	trace_kvm_pio(KVM_PIO_IN, vcpu->arch.pio.port, size, count, vcpu->arch.pio_data);</yellow>
<blue>	vcpu->arch.pio.count = 0;</blue>
}

static int emulator_pio_in_emulated(struct x86_emulate_ctxt *ctxt,
				    int size, unsigned short port, void *val,
				    unsigned int count)
{
<blue>	struct kvm_vcpu *vcpu = emul_to_vcpu(ctxt);</blue>
	if (vcpu-&gt;arch.pio.count) {
		/*
		 * Complete a previous iteration that required userspace I/O.
		 * Note, @count isn&#x27;t guaranteed to match pio.count as userspace
		 * can modify ECX before rerunning the vCPU.  Ignore any such
		 * shenanigans as KVM doesn&#x27;t support modifying the rep count,
		 * and the emulator ensures @count doesn&#x27;t overflow the buffer.
		 */
<blue>		complete_emulator_pio_in(vcpu, val);</blue>
		return 1;
	}

<blue>	return emulator_pio_in(vcpu, size, port, val, count);</blue>
<blue>}</blue>

static int emulator_pio_out(struct kvm_vcpu *vcpu, int size,
			    unsigned short port, const void *val,
			    unsigned int count)
{
<yellow>	trace_kvm_pio(KVM_PIO_OUT, port, size, count, val);</yellow>
<blue>	return emulator_pio_in_out(vcpu, size, port, (void *)val, count, false);</blue>
}

static int emulator_pio_out_emulated(struct x86_emulate_ctxt *ctxt,
				     int size, unsigned short port,
				     const void *val, unsigned int count)
{
<blue>	return emulator_pio_out(emul_to_vcpu(ctxt), size, port, val, count);</blue>
}

static unsigned long get_segment_base(struct kvm_vcpu *vcpu, int seg)
{
<yellow>	return static_call(kvm_x86_get_segment_base)(vcpu, seg);</yellow>
}

static void emulator_invlpg(struct x86_emulate_ctxt *ctxt, ulong address)
{
<yellow>	kvm_mmu_invlpg(emul_to_vcpu(ctxt), address);</yellow>
}

<yellow>static int kvm_emulate_wbinvd_noskip(struct kvm_vcpu *vcpu)</yellow>
{
<blue>	if (!need_emulate_wbinvd(vcpu))</blue>
		return X86EMUL_CONTINUE;

<yellow>	if (static_call(kvm_x86_has_wbinvd_exit)()) {</yellow>
<yellow>		int cpu = get_cpu();</yellow>

		cpumask_set_cpu(cpu, vcpu-&gt;arch.wbinvd_dirty_mask);
		on_each_cpu_mask(vcpu-&gt;arch.wbinvd_dirty_mask,
				wbinvd_ipi, NULL, 1);
<yellow>		put_cpu();</yellow>
<yellow>		cpumask_clear(vcpu->arch.wbinvd_dirty_mask);</yellow>
	} else
<yellow>		wbinvd();</yellow>
	return X86EMUL_CONTINUE;
<blue>}</blue>

int kvm_emulate_wbinvd(struct kvm_vcpu *vcpu)
{
<blue>	kvm_emulate_wbinvd_noskip(vcpu);</blue>
<blue>	return kvm_skip_emulated_instruction(vcpu);</blue>
<blue>}</blue>
EXPORT_SYMBOL_GPL(kvm_emulate_wbinvd);



static void emulator_wbinvd(struct x86_emulate_ctxt *ctxt)
{
<yellow>	kvm_emulate_wbinvd_noskip(emul_to_vcpu(ctxt));</yellow>
}

static void emulator_get_dr(struct x86_emulate_ctxt *ctxt, int dr,
			    unsigned long *dest)
{
<yellow>	kvm_get_dr(emul_to_vcpu(ctxt), dr, dest);</yellow>
}

static int emulator_set_dr(struct x86_emulate_ctxt *ctxt, int dr,
			   unsigned long value)
{

<yellow>	return kvm_set_dr(emul_to_vcpu(ctxt), dr, value);</yellow>
}

static u64 mk_cr_64(u64 curr_cr, u32 new_val)
{
	return (curr_cr &amp; ~((1ULL &lt;&lt; 32) - 1)) | new_val;
}

static unsigned long emulator_get_cr(struct x86_emulate_ctxt *ctxt, int cr)
{
<blue>	struct kvm_vcpu *vcpu = emul_to_vcpu(ctxt);</blue>
	unsigned long value;

	switch (cr) {
	case 0:
<yellow>		value = kvm_read_cr0(vcpu);</yellow>
		break;
	case 2:
<yellow>		value = vcpu->arch.cr2;</yellow>
		break;
	case 3:
<yellow>		value = kvm_read_cr3(vcpu);</yellow>
		break;
	case 4:
<blue>		value = kvm_read_cr4(vcpu);</blue>
		break;
	case 8:
<yellow>		value = kvm_get_cr8(vcpu);</yellow>
		break;
	default:
		kvm_err(&quot;%s: unexpected cr %u\n&quot;, __func__, cr);
		return 0;
	}

	return value;
<blue>}</blue>

static int emulator_set_cr(struct x86_emulate_ctxt *ctxt, int cr, ulong val)
{
<yellow>	struct kvm_vcpu *vcpu = emul_to_vcpu(ctxt);</yellow>
	int res = 0;

	switch (cr) {
	case 0:
<yellow>		res = kvm_set_cr0(vcpu, mk_cr_64(kvm_read_cr0(vcpu), val));</yellow>
		break;
	case 2:
<yellow>		vcpu->arch.cr2 = val;</yellow>
		break;
	case 3:
<yellow>		res = kvm_set_cr3(vcpu, val);</yellow>
		break;
	case 4:
<yellow>		res = kvm_set_cr4(vcpu, mk_cr_64(kvm_read_cr4(vcpu), val));</yellow>
		break;
	case 8:
<yellow>		res = kvm_set_cr8(vcpu, val);</yellow>
		break;
	default:
		kvm_err(&quot;%s: unexpected cr %u\n&quot;, __func__, cr);
		res = -1;
	}

	return res;
<yellow>}</yellow>

static int emulator_get_cpl(struct x86_emulate_ctxt *ctxt)
{
<blue>	return static_call(kvm_x86_get_cpl)(emul_to_vcpu(ctxt));</blue>
}

static void emulator_get_gdt(struct x86_emulate_ctxt *ctxt, struct desc_ptr *dt)
{
<yellow>	static_call(kvm_x86_get_gdt)(emul_to_vcpu(ctxt), dt);</yellow>
}

static void emulator_get_idt(struct x86_emulate_ctxt *ctxt, struct desc_ptr *dt)
{
<yellow>	static_call(kvm_x86_get_idt)(emul_to_vcpu(ctxt), dt);</yellow>
}

static void emulator_set_gdt(struct x86_emulate_ctxt *ctxt, struct desc_ptr *dt)
{
<yellow>	static_call(kvm_x86_set_gdt)(emul_to_vcpu(ctxt), dt);</yellow>
}

static void emulator_set_idt(struct x86_emulate_ctxt *ctxt, struct desc_ptr *dt)
{
<yellow>	static_call(kvm_x86_set_idt)(emul_to_vcpu(ctxt), dt);</yellow>
}

static unsigned long emulator_get_cached_segment_base(
	struct x86_emulate_ctxt *ctxt, int seg)
{
<blue>	return get_segment_base(emul_to_vcpu(ctxt), seg);</blue>
}

static bool emulator_get_segment(struct x86_emulate_ctxt *ctxt, u16 *selector,
				 struct desc_struct *desc, u32 *base3,
				 int seg)
<yellow>{</yellow>
	struct kvm_segment var;

<yellow>	kvm_get_segment(emul_to_vcpu(ctxt), &var, seg);</yellow>
	*selector = var.selector;

	if (var.unusable) {
<yellow>		memset(desc, 0, sizeof(*desc));</yellow>
		if (base3)
<yellow>			*base3 = 0;</yellow>
		return false;
	}

<yellow>	if (var.g)</yellow>
<yellow>		var.limit >>= 12;</yellow>
<yellow>	set_desc_limit(desc, var.limit);</yellow>
	set_desc_base(desc, (unsigned long)var.base);
#ifdef CONFIG_X86_64
	if (base3)
<yellow>		*base3 = var.base >> 32;</yellow>
#endif
<yellow>	desc->type = var.type;</yellow>
	desc-&gt;s = var.s;
	desc-&gt;dpl = var.dpl;
	desc-&gt;p = var.present;
	desc-&gt;avl = var.avl;
	desc-&gt;l = var.l;
	desc-&gt;d = var.db;
	desc-&gt;g = var.g;

	return true;
}

static void emulator_set_segment(struct x86_emulate_ctxt *ctxt, u16 selector,
				 struct desc_struct *desc, u32 base3,
				 int seg)
{
<yellow>	struct kvm_vcpu *vcpu = emul_to_vcpu(ctxt);</yellow>
	struct kvm_segment var;

	var.selector = selector;
	var.base = get_desc_base(desc);
#ifdef CONFIG_X86_64
	var.base |= ((u64)base3) &lt;&lt; 32;
#endif
	var.limit = get_desc_limit(desc);
	if (desc-&gt;g)
<yellow>		var.limit = (var.limit << 12) | 0xfff;</yellow>
<yellow>	var.type = desc->type;</yellow>
	var.dpl = desc-&gt;dpl;
	var.db = desc-&gt;d;
	var.s = desc-&gt;s;
	var.l = desc-&gt;l;
	var.g = desc-&gt;g;
	var.avl = desc-&gt;avl;
	var.present = desc-&gt;p;
	var.unusable = !var.present;
	var.padding = 0;

	kvm_set_segment(vcpu, &amp;var, seg);
	return;
}

static int emulator_get_msr_with_filter(struct x86_emulate_ctxt *ctxt,
					u32 msr_index, u64 *pdata)
{
<yellow>	struct kvm_vcpu *vcpu = emul_to_vcpu(ctxt);</yellow>
	int r;

<yellow>	r = kvm_get_msr_with_filter(vcpu, msr_index, pdata);</yellow>
<yellow>	if (r < 0)</yellow>
		return X86EMUL_UNHANDLEABLE;

<yellow>	if (r) {</yellow>
<yellow>		if (kvm_msr_user_space(vcpu, msr_index, KVM_EXIT_X86_RDMSR, 0,</yellow>
				       complete_emulated_rdmsr, r))
			return X86EMUL_IO_NEEDED;

<yellow>		trace_kvm_msr_read_ex(msr_index);</yellow>
		return X86EMUL_PROPAGATE_FAULT;
	}

<yellow>	trace_kvm_msr_read(msr_index, *pdata);</yellow>
	return X86EMUL_CONTINUE;
<yellow>}</yellow>

static int emulator_set_msr_with_filter(struct x86_emulate_ctxt *ctxt,
					u32 msr_index, u64 data)
{
<yellow>	struct kvm_vcpu *vcpu = emul_to_vcpu(ctxt);</yellow>
	int r;

<yellow>	r = kvm_set_msr_with_filter(vcpu, msr_index, data);</yellow>
<yellow>	if (r < 0)</yellow>
		return X86EMUL_UNHANDLEABLE;

<yellow>	if (r) {</yellow>
<yellow>		if (kvm_msr_user_space(vcpu, msr_index, KVM_EXIT_X86_WRMSR, data,</yellow>
				       complete_emulated_msr_access, r))
			return X86EMUL_IO_NEEDED;

<yellow>		trace_kvm_msr_write_ex(msr_index, data);</yellow>
		return X86EMUL_PROPAGATE_FAULT;
	}

<yellow>	trace_kvm_msr_write(msr_index, data);</yellow>
	return X86EMUL_CONTINUE;
<yellow>}</yellow>

static int emulator_get_msr(struct x86_emulate_ctxt *ctxt,
			    u32 msr_index, u64 *pdata)
{
<yellow>	return kvm_get_msr(emul_to_vcpu(ctxt), msr_index, pdata);</yellow>
<yellow>}</yellow>

static int emulator_set_msr(struct x86_emulate_ctxt *ctxt,
			    u32 msr_index, u64 data)
{
<yellow>	return kvm_set_msr(emul_to_vcpu(ctxt), msr_index, data);</yellow>
<yellow>}</yellow>

static u64 emulator_get_smbase(struct x86_emulate_ctxt *ctxt)
{
<yellow>	struct kvm_vcpu *vcpu = emul_to_vcpu(ctxt);</yellow>

	return vcpu-&gt;arch.smbase;
}

static void emulator_set_smbase(struct x86_emulate_ctxt *ctxt, u64 smbase)
{
<yellow>	struct kvm_vcpu *vcpu = emul_to_vcpu(ctxt);</yellow>

	vcpu-&gt;arch.smbase = smbase;
}

static int emulator_check_pmc(struct x86_emulate_ctxt *ctxt,
			      u32 pmc)
{
<yellow>	if (kvm_pmu_is_valid_rdpmc_ecx(emul_to_vcpu(ctxt), pmc))</yellow>
<yellow>		return 0;</yellow>
	return -EINVAL;
}

static int emulator_read_pmc(struct x86_emulate_ctxt *ctxt,
			     u32 pmc, u64 *pdata)
{
<yellow>	return kvm_pmu_rdpmc(emul_to_vcpu(ctxt), pmc, pdata);</yellow>
}

static void emulator_halt(struct x86_emulate_ctxt *ctxt)
{
<yellow>	emul_to_vcpu(ctxt)->arch.halt_request = 1;</yellow>
}

static int emulator_intercept(struct x86_emulate_ctxt *ctxt,
			      struct x86_instruction_info *info,
			      enum x86_intercept_stage stage)
{
<blue>	return static_call(kvm_x86_check_intercept)(emul_to_vcpu(ctxt), info, stage,</blue>
					    &amp;ctxt-&gt;exception);
}

static bool emulator_get_cpuid(struct x86_emulate_ctxt *ctxt,
			      u32 *eax, u32 *ebx, u32 *ecx, u32 *edx,
			      bool exact_only)
{
<yellow>	return kvm_cpuid(emul_to_vcpu(ctxt), eax, ebx, ecx, edx, exact_only);</yellow>
}

static bool emulator_guest_has_long_mode(struct x86_emulate_ctxt *ctxt)
{
<yellow>	return guest_cpuid_has(emul_to_vcpu(ctxt), X86_FEATURE_LM);</yellow>
<yellow>}</yellow>

static bool emulator_guest_has_movbe(struct x86_emulate_ctxt *ctxt)
{
<yellow>	return guest_cpuid_has(emul_to_vcpu(ctxt), X86_FEATURE_MOVBE);</yellow>
<yellow>}</yellow>

static bool emulator_guest_has_fxsr(struct x86_emulate_ctxt *ctxt)
{
<yellow>	return guest_cpuid_has(emul_to_vcpu(ctxt), X86_FEATURE_FXSR);</yellow>
<yellow>}</yellow>

static bool emulator_guest_has_rdpid(struct x86_emulate_ctxt *ctxt)
{
<yellow>	return guest_cpuid_has(emul_to_vcpu(ctxt), X86_FEATURE_RDPID);</yellow>
<yellow>}</yellow>

static ulong emulator_read_gpr(struct x86_emulate_ctxt *ctxt, unsigned reg)
{
<blue>	return kvm_register_read_raw(emul_to_vcpu(ctxt), reg);</blue>
<blue>}</blue>

static void emulator_write_gpr(struct x86_emulate_ctxt *ctxt, unsigned reg, ulong val)
{
<blue>	kvm_register_write_raw(emul_to_vcpu(ctxt), reg, val);</blue>
<blue>}</blue>

static void emulator_set_nmi_mask(struct x86_emulate_ctxt *ctxt, bool masked)
{
<yellow>	static_call(kvm_x86_set_nmi_mask)(emul_to_vcpu(ctxt), masked);</yellow>
}

static unsigned emulator_get_hflags(struct x86_emulate_ctxt *ctxt)
{
<blue>	return emul_to_vcpu(ctxt)->arch.hflags;</blue>
}

static void emulator_exiting_smm(struct x86_emulate_ctxt *ctxt)
{
<yellow>	struct kvm_vcpu *vcpu = emul_to_vcpu(ctxt);</yellow>

	kvm_smm_changed(vcpu, false);
}

static int emulator_leave_smm(struct x86_emulate_ctxt *ctxt,
				  const char *smstate)
{
<yellow>	return static_call(kvm_x86_leave_smm)(emul_to_vcpu(ctxt), smstate);</yellow>
}

static void emulator_triple_fault(struct x86_emulate_ctxt *ctxt)
{
<yellow>	kvm_make_request(KVM_REQ_TRIPLE_FAULT, emul_to_vcpu(ctxt));</yellow>
}

static int emulator_set_xcr(struct x86_emulate_ctxt *ctxt, u32 index, u64 xcr)
{
<yellow>	return __kvm_set_xcr(emul_to_vcpu(ctxt), index, xcr);</yellow>
}

static void emulator_vm_bugged(struct x86_emulate_ctxt *ctxt)
{
<yellow>	struct kvm *kvm = emul_to_vcpu(ctxt)->kvm;</yellow>

<yellow>	if (!kvm->vm_bugged)</yellow>
<yellow>		kvm_vm_bugged(kvm);</yellow>
<yellow>}</yellow>

static const struct x86_emulate_ops emulate_ops = {
	.vm_bugged           = emulator_vm_bugged,
	.read_gpr            = emulator_read_gpr,
	.write_gpr           = emulator_write_gpr,
	.read_std            = emulator_read_std,
	.write_std           = emulator_write_std,
	.read_phys           = kvm_read_guest_phys_system,
	.fetch               = kvm_fetch_guest_virt,
	.read_emulated       = emulator_read_emulated,
	.write_emulated      = emulator_write_emulated,
	.cmpxchg_emulated    = emulator_cmpxchg_emulated,
	.invlpg              = emulator_invlpg,
	.pio_in_emulated     = emulator_pio_in_emulated,
	.pio_out_emulated    = emulator_pio_out_emulated,
	.get_segment         = emulator_get_segment,
	.set_segment         = emulator_set_segment,
	.get_cached_segment_base = emulator_get_cached_segment_base,
	.get_gdt             = emulator_get_gdt,
	.get_idt	     = emulator_get_idt,
	.set_gdt             = emulator_set_gdt,
	.set_idt	     = emulator_set_idt,
	.get_cr              = emulator_get_cr,
	.set_cr              = emulator_set_cr,
	.cpl                 = emulator_get_cpl,
	.get_dr              = emulator_get_dr,
	.set_dr              = emulator_set_dr,
	.get_smbase          = emulator_get_smbase,
	.set_smbase          = emulator_set_smbase,
	.set_msr_with_filter = emulator_set_msr_with_filter,
	.get_msr_with_filter = emulator_get_msr_with_filter,
	.set_msr             = emulator_set_msr,
	.get_msr             = emulator_get_msr,
	.check_pmc	     = emulator_check_pmc,
	.read_pmc            = emulator_read_pmc,
	.halt                = emulator_halt,
	.wbinvd              = emulator_wbinvd,
	.fix_hypercall       = emulator_fix_hypercall,
	.intercept           = emulator_intercept,
	.get_cpuid           = emulator_get_cpuid,
	.guest_has_long_mode = emulator_guest_has_long_mode,
	.guest_has_movbe     = emulator_guest_has_movbe,
	.guest_has_fxsr      = emulator_guest_has_fxsr,
	.guest_has_rdpid     = emulator_guest_has_rdpid,
	.set_nmi_mask        = emulator_set_nmi_mask,
	.get_hflags          = emulator_get_hflags,
	.exiting_smm         = emulator_exiting_smm,
	.leave_smm           = emulator_leave_smm,
	.triple_fault        = emulator_triple_fault,
	.set_xcr             = emulator_set_xcr,
};

static void toggle_interruptibility(struct kvm_vcpu *vcpu, u32 mask)
{
	u32 int_shadow = static_call(kvm_x86_get_interrupt_shadow)(vcpu);
	/*
	 * an sti; sti; sequence only disable interrupts for the first
	 * instruction. So, if the last instruction, be it emulated or
	 * not, left the system with the INT_STI flag enabled, it
	 * means that the last instruction is an sti. We should not
	 * leave the flag on in this case. The same goes for mov ss
	 */
	if (int_shadow &amp; mask)
		mask = 0;
<blue>	if (unlikely(int_shadow || mask)) {</blue>
<blue>		static_call(kvm_x86_set_interrupt_shadow)(vcpu, mask);</blue>
		if (!mask)
<blue>			kvm_make_request(KVM_REQ_EVENT, vcpu);</blue>
	}
}

static void inject_emulated_exception(struct kvm_vcpu *vcpu)
{
<blue>	struct x86_emulate_ctxt *ctxt = vcpu->arch.emulate_ctxt;</blue>

	if (ctxt-&gt;exception.vector == PF_VECTOR)
<blue>		kvm_inject_emulated_page_fault(vcpu, &ctxt->exception);</blue>
<blue>	else if (ctxt->exception.error_code_valid)</blue>
		kvm_queue_exception_e(vcpu, ctxt-&gt;exception.vector,
<blue>				      ctxt->exception.error_code);</blue>
	else
<yellow>		kvm_queue_exception(vcpu, ctxt->exception.vector);</yellow>
<blue>}</blue>

static struct x86_emulate_ctxt *alloc_emulate_ctxt(struct kvm_vcpu *vcpu)
{
	struct x86_emulate_ctxt *ctxt;

<blue>	ctxt = kmem_cache_zalloc(x86_emulator_cache, GFP_KERNEL_ACCOUNT);</blue>
	if (!ctxt) {
		pr_err(&quot;kvm: failed to allocate vcpu&#x27;s emulator\n&quot;);
		return NULL;
	}

<blue>	ctxt->vcpu = vcpu;</blue>
	ctxt-&gt;ops = &amp;emulate_ops;
	vcpu-&gt;arch.emulate_ctxt = ctxt;

	return ctxt;
}

static void init_emulate_ctxt(struct kvm_vcpu *vcpu)
{
<blue>	struct x86_emulate_ctxt *ctxt = vcpu->arch.emulate_ctxt;</blue>
	int cs_db, cs_l;

	static_call(kvm_x86_get_cs_db_l_bits)(vcpu, &amp;cs_db, &amp;cs_l);

	ctxt-&gt;gpa_available = false;
<blue>	ctxt->eflags = kvm_get_rflags(vcpu);</blue>
<blue>	ctxt->tf = (ctxt->eflags & X86_EFLAGS_TF) != 0;</blue>

<blue>	ctxt->eip = kvm_rip_read(vcpu);</blue>
<blue>	ctxt->mode = (!is_protmode(vcpu))		? X86EMUL_MODE_REAL :</blue>
<blue>		     (ctxt->eflags & X86_EFLAGS_VM)	? X86EMUL_MODE_VM86 :</blue>
<blue>		     (cs_l && is_long_mode(vcpu))	? X86EMUL_MODE_PROT64 :</blue>
<yellow>		     cs_db				? X86EMUL_MODE_PROT32 :</yellow>
							  X86EMUL_MODE_PROT16;
	BUILD_BUG_ON(HF_GUEST_MASK != X86EMUL_GUEST_MASK);
	BUILD_BUG_ON(HF_SMM_MASK != X86EMUL_SMM_MASK);
	BUILD_BUG_ON(HF_SMM_INSIDE_NMI_MASK != X86EMUL_SMM_INSIDE_NMI_MASK);

	ctxt-&gt;interruptibility = 0;
	ctxt-&gt;have_exception = false;
	ctxt-&gt;exception.vector = -1;
	ctxt-&gt;perm_ok = false;

	init_decode_cache(ctxt);
	vcpu-&gt;arch.emulate_regs_need_sync_from_vcpu = false;
}

void kvm_inject_realmode_interrupt(struct kvm_vcpu *vcpu, int irq, int inc_eip)
{
<yellow>	struct x86_emulate_ctxt *ctxt = vcpu->arch.emulate_ctxt;</yellow>
	int ret;

	init_emulate_ctxt(vcpu);

	ctxt-&gt;op_bytes = 2;
	ctxt-&gt;ad_bytes = 2;
	ctxt-&gt;_eip = ctxt-&gt;eip + inc_eip;
	ret = emulate_int_real(ctxt, irq);

	if (ret != X86EMUL_CONTINUE) {
<yellow>		kvm_make_request(KVM_REQ_TRIPLE_FAULT, vcpu);</yellow>
	} else {
<yellow>		ctxt->eip = ctxt->_eip;</yellow>
		kvm_rip_write(vcpu, ctxt-&gt;eip);
		kvm_set_rflags(vcpu, ctxt-&gt;eflags);
	}
<yellow>}</yellow>
EXPORT_SYMBOL_GPL(kvm_inject_realmode_interrupt);

static void prepare_emulation_failure_exit(struct kvm_vcpu *vcpu, u64 *data,
					   u8 ndata, u8 *insn_bytes, u8 insn_size)
{
<blue>	struct kvm_run *run = vcpu->run;</blue>
	u64 info[5];
	u8 info_start;

	/*
	 * Zero the whole array used to retrieve the exit info, as casting to
	 * u32 for select entries will leave some chunks uninitialized.
	 */
	memset(&amp;info, 0, sizeof(info));

	static_call(kvm_x86_get_exit_info)(vcpu, (u32 *)&amp;info[0], &amp;info[1],
					   &amp;info[2], (u32 *)&amp;info[3],
					   (u32 *)&amp;info[4]);

	run-&gt;exit_reason = KVM_EXIT_INTERNAL_ERROR;
	run-&gt;emulation_failure.suberror = KVM_INTERNAL_ERROR_EMULATION;

	/*
	 * There&#x27;s currently space for 13 entries, but 5 are used for the exit
	 * reason and info.  Restrict to 4 to reduce the maintenance burden
	 * when expanding kvm_run.emulation_failure in the future.
	 */
<blue>	if (WARN_ON_ONCE(ndata > 4))</blue>
		ndata = 4;

	/* Always include the flags as a &#x27;data&#x27; entry. */
	info_start = 1;
<blue>	run->emulation_failure.flags = 0;</blue>

<blue>	if (insn_size) {</blue>
		BUILD_BUG_ON((sizeof(run-&gt;emulation_failure.insn_size) +
			      sizeof(run-&gt;emulation_failure.insn_bytes) != 16));
		info_start += 2;
<yellow>		run->emulation_failure.flags |=</yellow>
			KVM_INTERNAL_ERROR_EMULATION_FLAG_INSTRUCTION_BYTES;
		run-&gt;emulation_failure.insn_size = insn_size;
		memset(run-&gt;emulation_failure.insn_bytes, 0x90,
		       sizeof(run-&gt;emulation_failure.insn_bytes));
<yellow>		memcpy(run->emulation_failure.insn_bytes, insn_bytes, insn_size);</yellow>
	}

<blue>	memcpy(&run->internal.data[info_start], info, sizeof(info));</blue>
	memcpy(&amp;run-&gt;internal.data[info_start + ARRAY_SIZE(info)], data,
	       ndata * sizeof(data[0]));

	run-&gt;emulation_failure.ndata = info_start + ARRAY_SIZE(info) + ndata;
}

static void prepare_emulation_ctxt_failure_exit(struct kvm_vcpu *vcpu)
{
<blue>	struct x86_emulate_ctxt *ctxt = vcpu->arch.emulate_ctxt;</blue>

	prepare_emulation_failure_exit(vcpu, NULL, 0, ctxt-&gt;fetch.data,
				       ctxt-&gt;fetch.end - ctxt-&gt;fetch.data);
}

void __kvm_prepare_emulation_failure_exit(struct kvm_vcpu *vcpu, u64 *data,
					  u8 ndata)
{
<yellow>	prepare_emulation_failure_exit(vcpu, data, ndata, NULL, 0);</yellow>
}
EXPORT_SYMBOL_GPL(__kvm_prepare_emulation_failure_exit);

void kvm_prepare_emulation_failure_exit(struct kvm_vcpu *vcpu)
{
<yellow>	__kvm_prepare_emulation_failure_exit(vcpu, NULL, 0);</yellow>
}
EXPORT_SYMBOL_GPL(kvm_prepare_emulation_failure_exit);

static int handle_emulation_failure(struct kvm_vcpu *vcpu, int emulation_type)
{
<blue>	struct kvm *kvm = vcpu->kvm;</blue>

	++vcpu-&gt;stat.insn_emulation_fail;
<yellow>	trace_kvm_emulate_insn_failed(vcpu);</yellow>

<blue>	if (emulation_type & EMULTYPE_VMWARE_GP) {</blue>
<yellow>		kvm_queue_exception_e(vcpu, GP_VECTOR, 0);</yellow>
		return 1;
	}

<blue>	if (kvm->arch.exit_on_emulation_error ||</blue>
<blue>	    (emulation_type & EMULTYPE_SKIP)) {</blue>
<yellow>		prepare_emulation_ctxt_failure_exit(vcpu);</yellow>
		return 0;
	}

<blue>	kvm_queue_exception(vcpu, UD_VECTOR);</blue>

<blue>	if (!is_guest_mode(vcpu) && static_call(kvm_x86_get_cpl)(vcpu) == 0) {</blue>
<blue>		prepare_emulation_ctxt_failure_exit(vcpu);</blue>
		return 0;
	}

	return 1;
<blue>}</blue>

<blue>static bool reexecute_instruction(struct kvm_vcpu *vcpu, gpa_t cr2_or_gpa,</blue>
				  bool write_fault_to_shadow_pgtable,
				  int emulation_type)
{
	gpa_t gpa = cr2_or_gpa;
	kvm_pfn_t pfn;

<blue>	if (!(emulation_type & EMULTYPE_ALLOW_RETRY_PF))</blue>
		return false;

<blue>	if (WARN_ON_ONCE(is_guest_mode(vcpu)) ||</blue>
<blue>	    WARN_ON_ONCE(!(emulation_type & EMULTYPE_PF)))</blue>
		return false;

<blue>	if (!vcpu->arch.mmu->root_role.direct) {</blue>
		/*
		 * Write permission should be allowed since only
		 * write access need to be emulated.
		 */
<yellow>		gpa = kvm_mmu_gva_to_gpa_write(vcpu, cr2_or_gpa, NULL);</yellow>

		/*
		 * If the mapping is invalid in guest, let cpu retry
		 * it to generate fault.
		 */
		if (gpa == INVALID_GPA)
			return true;
	}

	/*
	 * Do not retry the unhandleable instruction if it faults on the
	 * readonly host memory, otherwise it will goto a infinite loop:
	 * retry instruction -&gt; write #PF -&gt; emulation fail -&gt; retry
	 * instruction -&gt; ...
	 */
<blue>	pfn = gfn_to_pfn(vcpu->kvm, gpa_to_gfn(gpa));</blue>

	/*
	 * If the instruction failed on the error pfn, it can not be fixed,
	 * report the error to userspace.
	 */
	if (is_error_noslot_pfn(pfn))
		return false;

<blue>	kvm_release_pfn_clean(pfn);</blue>

	/* The instructions are well-emulated on direct mmu. */
	if (vcpu-&gt;arch.mmu-&gt;root_role.direct) {
		unsigned int indirect_shadow_pages;

<blue>		write_lock(&vcpu->kvm->mmu_lock);</blue>
		indirect_shadow_pages = vcpu-&gt;kvm-&gt;arch.indirect_shadow_pages;
		write_unlock(&amp;vcpu-&gt;kvm-&gt;mmu_lock);

		if (indirect_shadow_pages)
<blue>			kvm_mmu_unprotect_page(vcpu->kvm, gpa_to_gfn(gpa));</blue>

		return true;
	}

	/*
	 * if emulation was due to access to shadowed page table
	 * and it failed try to unshadow page and re-enter the
	 * guest to let CPU execute the instruction.
	 */
<yellow>	kvm_mmu_unprotect_page(vcpu->kvm, gpa_to_gfn(gpa));</yellow>

	/*
	 * If the access faults on its page table, it can not
	 * be fixed by unprotecting shadow page and it should
	 * be reported to userspace.
	 */
	return !write_fault_to_shadow_pgtable;
<blue>}</blue>

static bool retry_instruction(struct x86_emulate_ctxt *ctxt,
			      gpa_t cr2_or_gpa,  int emulation_type)
{
<blue>	struct kvm_vcpu *vcpu = emul_to_vcpu(ctxt);</blue>
	unsigned long last_retry_eip, last_retry_addr, gpa = cr2_or_gpa;

	last_retry_eip = vcpu-&gt;arch.last_retry_eip;
	last_retry_addr = vcpu-&gt;arch.last_retry_addr;

	/*
	 * If the emulation is caused by #PF and it is non-page_table
	 * writing instruction, it means the VM-EXIT is caused by shadow
	 * page protected, we can zap the shadow page and retry this
	 * instruction directly.
	 *
	 * Note: if the guest uses a non-page-table modifying instruction
	 * on the PDE that points to the instruction, then we will unmap
	 * the instruction and go to an infinite loop. So, we cache the
	 * last retried eip and the last fault address, if we meet the eip
	 * and the address again, we can break out of the potential infinite
	 * loop.
	 */
	vcpu-&gt;arch.last_retry_eip = vcpu-&gt;arch.last_retry_addr = 0;

	if (!(emulation_type &amp; EMULTYPE_ALLOW_RETRY_PF))
		return false;

<blue>	if (WARN_ON_ONCE(is_guest_mode(vcpu)) ||</blue>
<blue>	    WARN_ON_ONCE(!(emulation_type & EMULTYPE_PF)))</blue>
		return false;

<blue>	if (x86_page_table_writing_insn(ctxt))</blue>
		return false;

<blue>	if (ctxt->eip == last_retry_eip && last_retry_addr == cr2_or_gpa)</blue>
		return false;

<blue>	vcpu->arch.last_retry_eip = ctxt->eip;</blue>
	vcpu-&gt;arch.last_retry_addr = cr2_or_gpa;

	if (!vcpu-&gt;arch.mmu-&gt;root_role.direct)
<yellow>		gpa = kvm_mmu_gva_to_gpa_write(vcpu, cr2_or_gpa, NULL);</yellow>

<blue>	kvm_mmu_unprotect_page(vcpu->kvm, gpa_to_gfn(gpa));</blue>

	return true;
}

static int complete_emulated_mmio(struct kvm_vcpu *vcpu);
static int complete_emulated_pio(struct kvm_vcpu *vcpu);

static void kvm_smm_changed(struct kvm_vcpu *vcpu, bool entering_smm)
{
<yellow>	trace_kvm_smm_transition(vcpu->vcpu_id, vcpu->arch.smbase, entering_smm);</yellow>

	if (entering_smm) {
<yellow>		vcpu->arch.hflags |= HF_SMM_MASK;</yellow>
	} else {
<yellow>		vcpu->arch.hflags &= ~(HF_SMM_MASK | HF_SMM_INSIDE_NMI_MASK);</yellow>

		/* Process a latched INIT or SMI, if any.  */
		kvm_make_request(KVM_REQ_EVENT, vcpu);

		/*
		 * Even if KVM_SET_SREGS2 loaded PDPTRs out of band,
		 * on SMM exit we still need to reload them from
		 * guest memory
		 */
		vcpu-&gt;arch.pdptrs_from_userspace = false;
	}

<yellow>	kvm_mmu_reset_context(vcpu);</yellow>
}

static int kvm_vcpu_check_hw_bp(unsigned long addr, u32 type, u32 dr7,
				unsigned long *db)
{
	u32 dr6 = 0;
	int i;
	u32 enable, rwlen;

	enable = dr7;
	rwlen = dr7 &gt;&gt; 16;
<blue>	for (i = 0; i < 4; i++, enable >>= 2, rwlen >>= 4)</blue>
<blue>		if ((enable & 3) && (rwlen & 15) == type && db[i] == addr)</blue>
<yellow>			dr6 |= (1 << i);</yellow>
	return dr6;
}

<yellow>static int kvm_vcpu_do_singlestep(struct kvm_vcpu *vcpu)</yellow>
{
<yellow>	struct kvm_run *kvm_run = vcpu->run;</yellow>

	if (vcpu-&gt;guest_debug &amp; KVM_GUESTDBG_SINGLESTEP) {
<yellow>		kvm_run->debug.arch.dr6 = DR6_BS | DR6_ACTIVE_LOW;</yellow>
		kvm_run-&gt;debug.arch.pc = kvm_get_linear_rip(vcpu);
		kvm_run-&gt;debug.arch.exception = DB_VECTOR;
		kvm_run-&gt;exit_reason = KVM_EXIT_DEBUG;
		return 0;
	}
<yellow>	kvm_queue_exception_p(vcpu, DB_VECTOR, DR6_BS);</yellow>
	return 1;
<yellow>}</yellow>

int kvm_skip_emulated_instruction(struct kvm_vcpu *vcpu)
{
<blue>	unsigned long rflags = static_call(kvm_x86_get_rflags)(vcpu);</blue>
	int r;

	r = static_call(kvm_x86_skip_emulated_instruction)(vcpu);
	if (unlikely(!r))
		return 0;

	kvm_pmu_trigger_event(vcpu, PERF_COUNT_HW_INSTRUCTIONS);

	/*
	 * rflags is the old, &quot;raw&quot; value of the flags.  The new value has
	 * not been saved yet.
	 *
	 * This is correct even for TF set by the guest, because &quot;the
	 * processor will not generate this exception after the instruction
	 * that sets the TF flag&quot;.
	 */
<blue>	if (unlikely(rflags & X86_EFLAGS_TF))</blue>
<yellow>		r = kvm_vcpu_do_singlestep(vcpu);</yellow>
	return r;
<blue>}</blue>
EXPORT_SYMBOL_GPL(kvm_skip_emulated_instruction);

static bool kvm_is_code_breakpoint_inhibited(struct kvm_vcpu *vcpu)
{
	u32 shadow;

<blue>	if (kvm_get_rflags(vcpu) & X86_EFLAGS_RF)</blue>
		return true;

	/*
	 * Intel CPUs inhibit code #DBs when MOV/POP SS blocking is active,
	 * but AMD CPUs do not.  MOV/POP SS blocking is rare, check that first
	 * to avoid the relatively expensive CPUID lookup.
	 */
<blue>	shadow = static_call(kvm_x86_get_interrupt_shadow)(vcpu);</blue>
	return (shadow &amp; KVM_X86_SHADOW_INT_MOV_SS) &amp;&amp;
<yellow>	       guest_cpuid_is_intel(vcpu);</yellow>
}

static bool kvm_vcpu_check_code_breakpoint(struct kvm_vcpu *vcpu,
					   int emulation_type, int *r)
{
<yellow>	WARN_ON_ONCE(emulation_type & EMULTYPE_NO_DECODE);</yellow>

	/*
	 * Do not check for code breakpoints if hardware has already done the
	 * checks, as inferred from the emulation type.  On NO_DECODE and SKIP,
	 * the instruction has passed all exception checks, and all intercepted
	 * exceptions that trigger emulation have lower priority than code
	 * breakpoints, i.e. the fact that the intercepted exception occurred
	 * means any code breakpoints have already been serviced.
	 *
	 * Note, KVM needs to check for code #DBs on EMULTYPE_TRAP_UD_FORCED as
	 * hardware has checked the RIP of the magic prefix, but not the RIP of
	 * the instruction being emulated.  The intent of forced emulation is
	 * to behave as if KVM intercepted the instruction without an exception
	 * and without a prefix.
	 */
<blue>	if (emulation_type & (EMULTYPE_NO_DECODE | EMULTYPE_SKIP |</blue>
			      EMULTYPE_TRAP_UD | EMULTYPE_VMWARE_GP | EMULTYPE_PF))
		return false;

<blue>	if (unlikely(vcpu->guest_debug & KVM_GUESTDBG_USE_HW_BP) &&</blue>
<yellow>	    (vcpu->arch.guest_debug_dr7 & DR7_BP_EN_MASK)) {</yellow>
<yellow>		struct kvm_run *kvm_run = vcpu->run;</yellow>
		unsigned long eip = kvm_get_linear_rip(vcpu);
<yellow>		u32 dr6 = kvm_vcpu_check_hw_bp(eip, 0,</yellow>
					   vcpu-&gt;arch.guest_debug_dr7,
					   vcpu-&gt;arch.eff_db);

<yellow>		if (dr6 != 0) {</yellow>
<yellow>			kvm_run->debug.arch.dr6 = dr6 | DR6_ACTIVE_LOW;</yellow>
			kvm_run-&gt;debug.arch.pc = eip;
			kvm_run-&gt;debug.arch.exception = DB_VECTOR;
			kvm_run-&gt;exit_reason = KVM_EXIT_DEBUG;
			*r = 0;
			return true;
		}
	}

<blue>	if (unlikely(vcpu->arch.dr7 & DR7_BP_EN_MASK) &&</blue>
<blue>	    !kvm_is_code_breakpoint_inhibited(vcpu)) {</blue>
<blue>		unsigned long eip = kvm_get_linear_rip(vcpu);</blue>
<blue>		u32 dr6 = kvm_vcpu_check_hw_bp(eip, 0,</blue>
					   vcpu-&gt;arch.dr7,
					   vcpu-&gt;arch.db);

<blue>		if (dr6 != 0) {</blue>
<yellow>			kvm_queue_exception_p(vcpu, DB_VECTOR, dr6);</yellow>
			*r = 1;
			return true;
		}
	}

	return false;
}

static bool is_vmware_backdoor_opcode(struct x86_emulate_ctxt *ctxt)
{
<yellow>	switch (ctxt->opcode_len) {</yellow>
	case 1:
<yellow>		switch (ctxt->b) {</yellow>
		case 0xe4:	/* IN */
		case 0xe5:
		case 0xec:
		case 0xed:
		case 0xe6:	/* OUT */
		case 0xe7:
		case 0xee:
		case 0xef:
		case 0x6c:	/* INS */
		case 0x6d:
		case 0x6e:	/* OUTS */
		case 0x6f:
			return true;
		}
		break;
	case 2:
<yellow>		switch (ctxt->b) {</yellow>
		case 0x33:	/* RDPMC */
			return true;
		}
		break;
	}

	return false;
}

/*
 * Decode an instruction for emulation.  The caller is responsible for handling
 * code breakpoints.  Note, manually detecting code breakpoints is unnecessary
 * (and wrong) when emulating on an intercepted fault-like exception[*], as
 * code breakpoints have higher priority and thus have already been done by
 * hardware.
 *
 * [*] Except #MC, which is higher priority, but KVM should never emulate in
 *     response to a machine check.
 */
int x86_decode_emulated_instruction(struct kvm_vcpu *vcpu, int emulation_type,
				    void *insn, int insn_len)
{
<blue>	struct x86_emulate_ctxt *ctxt = vcpu->arch.emulate_ctxt;</blue>
	int r;

	init_emulate_ctxt(vcpu);

	r = x86_decode_insn(ctxt, insn, insn_len, emulation_type);

<yellow>	trace_kvm_emulate_insn_start(vcpu);</yellow>
<blue>	++vcpu->stat.insn_emulation;</blue>

	return r;
}
EXPORT_SYMBOL_GPL(x86_decode_emulated_instruction);

int x86_emulate_instruction(struct kvm_vcpu *vcpu, gpa_t cr2_or_gpa,
			    int emulation_type, void *insn, int insn_len)
{
	int r;
<blue>	struct x86_emulate_ctxt *ctxt = vcpu->arch.emulate_ctxt;</blue>
	bool writeback = true;
	bool write_fault_to_spt;

	if (unlikely(!kvm_can_emulate_insn(vcpu, emulation_type, insn, insn_len)))
		return 1;

<blue>	vcpu->arch.l1tf_flush_l1d = true;</blue>

	/*
	 * Clear write_fault_to_shadow_pgtable here to ensure it is
	 * never reused.
	 */
	write_fault_to_spt = vcpu-&gt;arch.write_fault_to_shadow_pgtable;
<blue>	vcpu->arch.write_fault_to_shadow_pgtable = false;</blue>

	if (!(emulation_type &amp; EMULTYPE_NO_DECODE)) {
<blue>		kvm_clear_exception_queue(vcpu);</blue>

		/*
		 * Return immediately if RIP hits a code breakpoint, such #DBs
		 * are fault-like and are higher priority than any faults on
		 * the code fetch itself.
		 */
<blue>		if (kvm_vcpu_check_code_breakpoint(vcpu, emulation_type, &r))</blue>
			return r;

<blue>		r = x86_decode_emulated_instruction(vcpu, emulation_type,</blue>
						    insn, insn_len);
		if (r != EMULATION_OK)  {
<blue>			if ((emulation_type & EMULTYPE_TRAP_UD) ||</blue>
			    (emulation_type &amp; EMULTYPE_TRAP_UD_FORCED)) {
<blue>				kvm_queue_exception(vcpu, UD_VECTOR);</blue>
				return 1;
			}
<blue>			if (reexecute_instruction(vcpu, cr2_or_gpa,</blue>
						  write_fault_to_spt,
						  emulation_type))
				return 1;
<blue>			if (ctxt->have_exception) {</blue>
				/*
				 * #UD should result in just EMULATION_FAILED, and trap-like
				 * exception should not be encountered during decode.
				 */
<blue>				WARN_ON_ONCE(ctxt->exception.vector == UD_VECTOR ||</blue>
					     exception_type(ctxt-&gt;exception.vector) == EXCPT_TRAP);
<blue>				inject_emulated_exception(vcpu);</blue>
				return 1;
			}
			return handle_emulation_failure(vcpu, emulation_type);
		}
	}

<blue>	if ((emulation_type & EMULTYPE_VMWARE_GP) &&</blue>
<yellow>	    !is_vmware_backdoor_opcode(ctxt)) {</yellow>
<yellow>		kvm_queue_exception_e(vcpu, GP_VECTOR, 0);</yellow>
		return 1;
	}

	/*
	 * EMULTYPE_SKIP without EMULTYPE_COMPLETE_USER_EXIT is intended for
	 * use *only* by vendor callbacks for kvm_skip_emulated_instruction().
	 * The caller is responsible for updating interruptibility state and
	 * injecting single-step #DBs.
	 */
<blue>	if (emulation_type & EMULTYPE_SKIP) {</blue>
<yellow>		if (ctxt->mode != X86EMUL_MODE_PROT64)</yellow>
<yellow>			ctxt->eip = (u32)ctxt->_eip;</yellow>
		else
			ctxt-&gt;eip = ctxt-&gt;_eip;

		if (emulation_type &amp; EMULTYPE_COMPLETE_USER_EXIT) {
			r = 1;
			goto writeback;
		}

<yellow>		kvm_rip_write(vcpu, ctxt->eip);</yellow>
		if (ctxt-&gt;eflags &amp; X86_EFLAGS_RF)
<yellow>			kvm_set_rflags(vcpu, ctxt->eflags & ~X86_EFLAGS_RF);</yellow>
		return 1;
	}

<blue>	if (retry_instruction(ctxt, cr2_or_gpa, emulation_type))</blue>
		return 1;

	/* this is needed for vmware backdoor interface to work since it
	   changes registers values  during IO operation */
<blue>	if (vcpu->arch.emulate_regs_need_sync_from_vcpu) {</blue>
<blue>		vcpu->arch.emulate_regs_need_sync_from_vcpu = false;</blue>
		emulator_invalidate_register_cache(ctxt);
	}

restart:
<blue>	if (emulation_type & EMULTYPE_PF) {</blue>
		/* Save the faulting GPA (cr2) in the address field */
<blue>		ctxt->exception.address = cr2_or_gpa;</blue>

		/* With shadow page tables, cr2 contains a GVA or nGPA. */
		if (vcpu-&gt;arch.mmu-&gt;root_role.direct) {
<blue>			ctxt->gpa_available = true;</blue>
			ctxt-&gt;gpa_val = cr2_or_gpa;
		}
	} else {
		/* Sanitize the address out of an abundance of paranoia. */
<blue>		ctxt->exception.address = 0;</blue>
	}

<blue>	r = x86_emulate_insn(ctxt);</blue>

	if (r == EMULATION_INTERCEPTED)
		return 1;

<blue>	if (r == EMULATION_FAILED) {</blue>
<blue>		if (reexecute_instruction(vcpu, cr2_or_gpa, write_fault_to_spt,</blue>
					emulation_type))
			return 1;

<blue>		return handle_emulation_failure(vcpu, emulation_type);</blue>
	}

<blue>	if (ctxt->have_exception) {</blue>
		r = 1;
<blue>		inject_emulated_exception(vcpu);</blue>
<blue>	} else if (vcpu->arch.pio.count) {</blue>
<blue>		if (!vcpu->arch.pio.in) {</blue>
			/* FIXME: return into emulator if single-stepping.  */
			vcpu-&gt;arch.pio.count = 0;
		} else {
			writeback = false;
<blue>			vcpu->arch.complete_userspace_io = complete_emulated_pio;</blue>
		}
<blue>		r = 0;</blue>
<blue>	} else if (vcpu->mmio_needed) {</blue>
<blue>		++vcpu->stat.mmio_exits;</blue>

		if (!vcpu-&gt;mmio_is_write)
			writeback = false;
		r = 0;
<blue>		vcpu->arch.complete_userspace_io = complete_emulated_mmio;</blue>
<blue>	} else if (vcpu->arch.complete_userspace_io) {</blue>
		writeback = false;
		r = 0;
<blue>	} else if (r == EMULATION_RESTART)</blue>
		goto restart;
	else
		r = 1;

writeback:
	if (writeback) {
<blue>		unsigned long rflags = static_call(kvm_x86_get_rflags)(vcpu);</blue>
<blue>		toggle_interruptibility(vcpu, ctxt->interruptibility);</blue>
<blue>		vcpu->arch.emulate_regs_need_sync_to_vcpu = false;</blue>

		/*
		 * Note, EXCPT_DB is assumed to be fault-like as the emulator
		 * only supports code breakpoints and general detect #DB, both
		 * of which are fault-like.
		 */
<blue>		if (!ctxt->have_exception ||</blue>
<blue>		    exception_type(ctxt->exception.vector) == EXCPT_TRAP) {</blue>
<blue>			kvm_pmu_trigger_event(vcpu, PERF_COUNT_HW_INSTRUCTIONS);</blue>
<blue>			if (ctxt->is_branch)</blue>
<blue>				kvm_pmu_trigger_event(vcpu, PERF_COUNT_HW_BRANCH_INSTRUCTIONS);</blue>
<blue>			kvm_rip_write(vcpu, ctxt->eip);</blue>
<blue>			if (r && (ctxt->tf || (vcpu->guest_debug & KVM_GUESTDBG_SINGLESTEP)))</blue>
<yellow>				r = kvm_vcpu_do_singlestep(vcpu);</yellow>
			static_call_cond(kvm_x86_update_emulated_instruction)(vcpu);
<blue>			__kvm_set_rflags(vcpu, ctxt->eflags);</blue>
		}

		/*
		 * For STI, interrupts are shadowed; so KVM_REQ_EVENT will
		 * do nothing, and it will be requested again as soon as
		 * the shadow expires.  But we still need to check here,
		 * because POPF has no interrupt shadow.
		 */
<blue>		if (unlikely((ctxt->eflags & ~rflags) & X86_EFLAGS_IF))</blue>
<yellow>			kvm_make_request(KVM_REQ_EVENT, vcpu);</yellow>
	} else
<blue>		vcpu->arch.emulate_regs_need_sync_to_vcpu = true;</blue>

	return r;
<blue>}</blue>

int kvm_emulate_instruction(struct kvm_vcpu *vcpu, int emulation_type)
{
<blue>	return x86_emulate_instruction(vcpu, 0, emulation_type, NULL, 0);</blue>
}
EXPORT_SYMBOL_GPL(kvm_emulate_instruction);

int kvm_emulate_instruction_from_buffer(struct kvm_vcpu *vcpu,
					void *insn, int insn_len)
{
<yellow>	return x86_emulate_instruction(vcpu, 0, 0, insn, insn_len);</yellow>
}
EXPORT_SYMBOL_GPL(kvm_emulate_instruction_from_buffer);

static int complete_fast_pio_out_port_0x7e(struct kvm_vcpu *vcpu)
{
<blue>	vcpu->arch.pio.count = 0;</blue>
	return 1;
}

static int complete_fast_pio_out(struct kvm_vcpu *vcpu)
{
<blue>	vcpu->arch.pio.count = 0;</blue>

	if (unlikely(!kvm_is_linear_rip(vcpu, vcpu-&gt;arch.pio.linear_rip)))
<yellow>		return 1;</yellow>

<blue>	return kvm_skip_emulated_instruction(vcpu);</blue>
<blue>}</blue>

static int kvm_fast_pio_out(struct kvm_vcpu *vcpu, int size,
			    unsigned short port)
{
<blue>	unsigned long val = kvm_rax_read(vcpu);</blue>
<blue>	int ret = emulator_pio_out(vcpu, size, port, &val, 1);</blue>

	if (ret)
		return ret;

	/*
	 * Workaround userspace that relies on old KVM behavior of %rip being
	 * incremented prior to exiting to userspace to handle &quot;OUT 0x7e&quot;.
	 */
<blue>	if (port == 0x7e &&</blue>
<blue>	    kvm_check_has_quirk(vcpu->kvm, KVM_X86_QUIRK_OUT_7E_INC_RIP)) {</blue>
<blue>		vcpu->arch.complete_userspace_io =</blue>
			complete_fast_pio_out_port_0x7e;
		kvm_skip_emulated_instruction(vcpu);
	} else {
<blue>		vcpu->arch.pio.linear_rip = kvm_get_linear_rip(vcpu);</blue>
		vcpu-&gt;arch.complete_userspace_io = complete_fast_pio_out;
	}
	return 0;
}

static int complete_fast_pio_in(struct kvm_vcpu *vcpu)
<blue>{</blue>
	unsigned long val;

	/* We should only ever be called with arch.pio.count equal to 1 */
<blue>	BUG_ON(vcpu->arch.pio.count != 1);</blue>

<blue>	if (unlikely(!kvm_is_linear_rip(vcpu, vcpu->arch.pio.linear_rip))) {</blue>
<yellow>		vcpu->arch.pio.count = 0;</yellow>
		return 1;
	}

	/* For size less than 4 we merge, else we zero extend */
<blue>	val = (vcpu->arch.pio.size < 4) ? kvm_rax_read(vcpu) : 0;</blue>

<blue>	complete_emulator_pio_in(vcpu, &val);</blue>
	kvm_rax_write(vcpu, val);

<blue>	return kvm_skip_emulated_instruction(vcpu);</blue>
}

static int kvm_fast_pio_in(struct kvm_vcpu *vcpu, int size,
			   unsigned short port)
{
	unsigned long val;
	int ret;

	/* For size less than 4 we merge, else we zero extend */
<blue>	val = (size < 4) ? kvm_rax_read(vcpu) : 0;</blue>

<blue>	ret = emulator_pio_in(vcpu, size, port, &val, 1);</blue>
	if (ret) {
<blue>		kvm_rax_write(vcpu, val);</blue>
		return ret;
	}

<blue>	vcpu->arch.pio.linear_rip = kvm_get_linear_rip(vcpu);</blue>
	vcpu-&gt;arch.complete_userspace_io = complete_fast_pio_in;

	return 0;
}

<blue>int kvm_fast_pio(struct kvm_vcpu *vcpu, int size, unsigned short port, int in)</blue>
<blue>{</blue>
	int ret;

	if (in)
<blue>		ret = kvm_fast_pio_in(vcpu, size, port);</blue>
	else
<blue>		ret = kvm_fast_pio_out(vcpu, size, port);</blue>
<blue>	return ret && kvm_skip_emulated_instruction(vcpu);</blue>
}
EXPORT_SYMBOL_GPL(kvm_fast_pio);

static int kvmclock_cpu_down_prep(unsigned int cpu)
{
<yellow>	__this_cpu_write(cpu_tsc_khz, 0);</yellow>
	return 0;
}

static void tsc_khz_changed(void *data)
{
	struct cpufreq_freqs *freq = data;
	unsigned long khz = 0;

<yellow>	if (data)</yellow>
<yellow>		khz = freq->new;</yellow>
<yellow>	else if (!boot_cpu_has(X86_FEATURE_CONSTANT_TSC))</yellow>
<yellow>		khz = cpufreq_quick_get(raw_smp_processor_id());</yellow>
<yellow>	if (!khz)</yellow>
<yellow>		khz = tsc_khz;</yellow>
<yellow>	__this_cpu_write(cpu_tsc_khz, khz);</yellow>
}

#ifdef CONFIG_X86_64
static void kvm_hyperv_tsc_notifier(void)
{
	struct kvm *kvm;
	int cpu;

<yellow>	mutex_lock(&kvm_lock);</yellow>
	list_for_each_entry(kvm, &amp;vm_list, vm_list)
<yellow>		kvm_make_mclock_inprogress_request(kvm);</yellow>

	/* no guest entries from this point */
<yellow>	hyperv_stop_tsc_emulation();</yellow>

	/* TSC frequency always matches when on Hyper-V */
<yellow>	for_each_present_cpu(cpu)</yellow>
<yellow>		per_cpu(cpu_tsc_khz, cpu) = tsc_khz;</yellow>
<yellow>	kvm_caps.max_guest_tsc_khz = tsc_khz;</yellow>

	list_for_each_entry(kvm, &amp;vm_list, vm_list) {
<yellow>		__kvm_start_pvclock_update(kvm);</yellow>
		pvclock_update_vm_gtod_copy(kvm);
		kvm_end_pvclock_update(kvm);
	}

<yellow>	mutex_unlock(&kvm_lock);</yellow>
}
#endif

static void __kvmclock_cpufreq_notifier(struct cpufreq_freqs *freq, int cpu)
{
	struct kvm *kvm;
	struct kvm_vcpu *vcpu;
	int send_ipi = 0;
	unsigned long i;

	/*
	 * We allow guests to temporarily run on slowing clocks,
	 * provided we notify them after, or to run on accelerating
	 * clocks, provided we notify them before.  Thus time never
	 * goes backwards.
	 *
	 * However, we have a problem.  We can&#x27;t atomically update
	 * the frequency of a given CPU from this function; it is
	 * merely a notifier, which can be called from any CPU.
	 * Changing the TSC frequency at arbitrary points in time
	 * requires a recomputation of local variables related to
	 * the TSC for each VCPU.  We must flag these local variables
	 * to be updated and be sure the update takes place with the
	 * new frequency before any guests proceed.
	 *
	 * Unfortunately, the combination of hotplug CPU and frequency
	 * change creates an intractable locking scenario; the order
	 * of when these callouts happen is undefined with respect to
	 * CPU hotplug, and they can race with each other.  As such,
	 * merely setting per_cpu(cpu_tsc_khz) = X during a hotadd is
	 * undefined; you can actually have a CPU frequency change take
	 * place in between the computation of X and the setting of the
	 * variable.  To protect against this problem, all updates of
	 * the per_cpu tsc_khz variable are done in an interrupt
	 * protected IPI, and all callers wishing to update the value
	 * must wait for a synchronous IPI to complete (which is trivial
	 * if the caller is on the CPU already).  This establishes the
	 * necessary total order on variable updates.
	 *
	 * Note that because a guest time update may take place
	 * anytime after the setting of the VCPU&#x27;s request bit, the
	 * correct TSC value must be set before the request.  However,
	 * to ensure the update actually makes it to any guest which
	 * starts running in hardware virtualization between the set
	 * and the acquisition of the spinlock, we must also ping the
	 * CPU after setting the request bit.
	 *
	 */

<yellow>	smp_call_function_single(cpu, tsc_khz_changed, freq, 1);</yellow>

	mutex_lock(&amp;kvm_lock);
<yellow>	list_for_each_entry(kvm, &vm_list, vm_list) {</yellow>
<yellow>		kvm_for_each_vcpu(i, vcpu, kvm) {</yellow>
<yellow>			if (vcpu->cpu != cpu)</yellow>
				continue;
<yellow>			kvm_make_request(KVM_REQ_CLOCK_UPDATE, vcpu);</yellow>
			if (vcpu-&gt;cpu != raw_smp_processor_id())
				send_ipi = 1;
		}
	}
<yellow>	mutex_unlock(&kvm_lock);</yellow>

<yellow>	if (freq->old < freq->new && send_ipi) {</yellow>
		/*
		 * We upscale the frequency.  Must make the guest
		 * doesn&#x27;t see old kvmclock values while running with
		 * the new frequency, otherwise we risk the guest sees
		 * time go backwards.
		 *
		 * In case we update the frequency for another cpu
		 * (which might be in guest context) send an interrupt
		 * to kick the cpu out of guest context.  Next time
		 * guest context is entered kvmclock will be updated,
		 * so the guest will not see stale values.
		 */
<yellow>		smp_call_function_single(cpu, tsc_khz_changed, freq, 1);</yellow>
	}
}

static int kvmclock_cpufreq_notifier(struct notifier_block *nb, unsigned long val,
				     void *data)
<yellow>{</yellow>
	struct cpufreq_freqs *freq = data;
	int cpu;

<yellow>	if (val == CPUFREQ_PRECHANGE && freq->old > freq->new)</yellow>
		return 0;
<yellow>	if (val == CPUFREQ_POSTCHANGE && freq->old < freq->new)</yellow>
		return 0;

<yellow>	for_each_cpu(cpu, freq->policy->cpus)</yellow>
<yellow>		__kvmclock_cpufreq_notifier(freq, cpu);</yellow>

	return 0;
}

static struct notifier_block kvmclock_cpufreq_notifier_block = {
	.notifier_call  = kvmclock_cpufreq_notifier
};

static int kvmclock_cpu_online(unsigned int cpu)
{
<yellow>	tsc_khz_changed(NULL);</yellow>
	return 0;
}

static void kvm_timer_init(void)
{
<yellow>	if (!boot_cpu_has(X86_FEATURE_CONSTANT_TSC)) {</yellow>
<yellow>		max_tsc_khz = tsc_khz;</yellow>

		if (IS_ENABLED(CONFIG_CPU_FREQ)) {
			struct cpufreq_policy *policy;
			int cpu;

			cpu = get_cpu();
			policy = cpufreq_cpu_get(cpu);
			if (policy) {
<yellow>				if (policy->cpuinfo.max_freq)</yellow>
<yellow>					max_tsc_khz = policy->cpuinfo.max_freq;</yellow>
<yellow>				cpufreq_cpu_put(policy);</yellow>
			}
<yellow>			put_cpu();</yellow>
		}
<yellow>		cpufreq_register_notifier(&kvmclock_cpufreq_notifier_block,</yellow>
					  CPUFREQ_TRANSITION_NOTIFIER);
	}

<yellow>	cpuhp_setup_state(CPUHP_AP_X86_KVM_CLK_ONLINE, "x86/kvm/clk:online",</yellow>
			  kvmclock_cpu_online, kvmclock_cpu_down_prep);
}

#ifdef CONFIG_X86_64
static void pvclock_gtod_update_fn(struct work_struct *work)
{
	struct kvm *kvm;
	struct kvm_vcpu *vcpu;
	unsigned long i;

<yellow>	mutex_lock(&kvm_lock);</yellow>
<yellow>	list_for_each_entry(kvm, &vm_list, vm_list)</yellow>
<yellow>		kvm_for_each_vcpu(i, vcpu, kvm)</yellow>
<yellow>			kvm_make_request(KVM_REQ_MASTERCLOCK_UPDATE, vcpu);</yellow>
<yellow>	atomic_set(&kvm_guest_has_master_clock, 0);</yellow>
	mutex_unlock(&amp;kvm_lock);
}

static DECLARE_WORK(pvclock_gtod_work, pvclock_gtod_update_fn);

/*
 * Indirection to move queue_work() out of the tk_core.seq write held
 * region to prevent possible deadlocks against time accessors which
 * are invoked with work related locks held.
 */
static void pvclock_irq_work_fn(struct irq_work *w)
{
<yellow>	queue_work(system_long_wq, &pvclock_gtod_work);</yellow>
}

static DEFINE_IRQ_WORK(pvclock_irq_work, pvclock_irq_work_fn);

/*
 * Notification about pvclock gtod data update.
 */
<yellow>static int pvclock_gtod_notify(struct notifier_block *nb, unsigned long unused,</yellow>
			       void *priv)
{
	struct pvclock_gtod_data *gtod = &amp;pvclock_gtod_data;
	struct timekeeper *tk = priv;

<yellow>	update_pvclock_gtod(tk);</yellow>

	/*
	 * Disable master clock if host does not trust, or does not use,
	 * TSC based clocksource. Delegate queue_work() to irq_work as
	 * this is invoked with tk_core.seq write held.
	 */
	if (!gtod_is_based_on_tsc(gtod-&gt;clock.vclock_mode) &amp;&amp;
<yellow>	    atomic_read(&kvm_guest_has_master_clock) != 0)</yellow>
<yellow>		irq_work_queue(&pvclock_irq_work);</yellow>
	return 0;
<yellow>}</yellow>

static struct notifier_block pvclock_gtod_notifier = {
	.notifier_call = pvclock_gtod_notify,
};
#endif

int kvm_arch_init(void *opaque)
<yellow>{</yellow>
	struct kvm_x86_init_ops *ops = opaque;
	u64 host_pat;
	int r;

<yellow>	if (kvm_x86_ops.hardware_enable) {</yellow>
		pr_err(&quot;kvm: already loaded vendor module &#x27;%s&#x27;\n&quot;, kvm_x86_ops.name);
		return -EEXIST;
	}

<yellow>	if (!ops->cpu_has_kvm_support()) {</yellow>
<yellow>		pr_err_ratelimited("kvm: no hardware support for '%s'\n",</yellow>
				   ops-&gt;runtime_ops-&gt;name);
		return -EOPNOTSUPP;
	}
<yellow>	if (ops->disabled_by_bios()) {</yellow>
<yellow>		pr_err_ratelimited("kvm: support for '%s' disabled by bios\n",</yellow>
				   ops-&gt;runtime_ops-&gt;name);
		return -EOPNOTSUPP;
	}

	/*
	 * KVM explicitly assumes that the guest has an FPU and
	 * FXSAVE/FXRSTOR. For example, the KVM_GET_FPU explicitly casts the
	 * vCPU&#x27;s FPU state as a fxregs_state struct.
	 */
	if (!boot_cpu_has(X86_FEATURE_FPU) || !boot_cpu_has(X86_FEATURE_FXSR)) {
		printk(KERN_ERR &quot;kvm: inadequate fpu\n&quot;);
		return -EOPNOTSUPP;
	}

	if (IS_ENABLED(CONFIG_PREEMPT_RT) &amp;&amp; !boot_cpu_has(X86_FEATURE_CONSTANT_TSC)) {
		pr_err(&quot;RT requires X86_FEATURE_CONSTANT_TSC\n&quot;);
		return -EOPNOTSUPP;
	}

	/*
	 * KVM assumes that PAT entry &#x27;0&#x27; encodes WB memtype and simply zeroes
	 * the PAT bits in SPTEs.  Bail if PAT[0] is programmed to something
	 * other than WB.  Note, EPT doesn&#x27;t utilize the PAT, but don&#x27;t bother
	 * with an exception.  PAT[0] is set to WB on RESET and also by the
	 * kernel, i.e. failure indicates a kernel bug or broken firmware.
	 */
<yellow>	if (rdmsrl_safe(MSR_IA32_CR_PAT, &host_pat) ||</yellow>
<yellow>	    (host_pat & GENMASK(2, 0)) != 6) {</yellow>
		pr_err(&quot;kvm: host PAT[0] is not WB\n&quot;);
		return -EIO;
	}

<yellow>	x86_emulator_cache = kvm_alloc_emulator_cache();</yellow>
	if (!x86_emulator_cache) {
		pr_err(&quot;kvm: failed to allocate cache for x86 emulator\n&quot;);
		return -ENOMEM;
	}

<yellow>	user_return_msrs = alloc_percpu(struct kvm_user_return_msrs);</yellow>
	if (!user_return_msrs) {
		printk(KERN_ERR &quot;kvm: failed to allocate percpu kvm_user_return_msrs\n&quot;);
		r = -ENOMEM;
		goto out_free_x86_emulator_cache;
	}
<yellow>	kvm_nr_uret_msrs = 0;</yellow>

	r = kvm_mmu_vendor_module_init();
	if (r)
		goto out_free_percpu;

<yellow>	kvm_timer_init();</yellow>

	if (boot_cpu_has(X86_FEATURE_XSAVE)) {
<yellow>		host_xcr0 = xgetbv(XCR_XFEATURE_ENABLED_MASK);</yellow>
		kvm_caps.supported_xcr0 = host_xcr0 &amp; KVM_SUPPORTED_XCR0;
	}

<yellow>	if (pi_inject_timer == -1)</yellow>
<yellow>		pi_inject_timer = housekeeping_enabled(HK_TYPE_TIMER);</yellow>
#ifdef CONFIG_X86_64
<yellow>	pvclock_gtod_register_notifier(&pvclock_gtod_notifier);</yellow>

	if (hypervisor_is_type(X86_HYPER_MS_HYPERV))
<yellow>		set_hv_tscchange_cb(kvm_hyperv_tsc_notifier);</yellow>
#endif

	return 0;

out_free_percpu:
<yellow>	free_percpu(user_return_msrs);</yellow>
out_free_x86_emulator_cache:
<yellow>	kmem_cache_destroy(x86_emulator_cache);</yellow>
	return r;
}

void kvm_arch_exit(void)
{
#ifdef CONFIG_X86_64
<yellow>	if (hypervisor_is_type(X86_HYPER_MS_HYPERV))</yellow>
<yellow>		clear_hv_tscchange_cb();</yellow>
#endif
<yellow>	kvm_lapic_exit();</yellow>

	if (!boot_cpu_has(X86_FEATURE_CONSTANT_TSC))
<yellow>		cpufreq_unregister_notifier(&kvmclock_cpufreq_notifier_block,</yellow>
					    CPUFREQ_TRANSITION_NOTIFIER);
<yellow>	cpuhp_remove_state_nocalls(CPUHP_AP_X86_KVM_CLK_ONLINE);</yellow>
#ifdef CONFIG_X86_64
	pvclock_gtod_unregister_notifier(&amp;pvclock_gtod_notifier);
	irq_work_sync(&amp;pvclock_irq_work);
	cancel_work_sync(&amp;pvclock_gtod_work);
#endif
	kvm_x86_ops.hardware_enable = NULL;
	kvm_mmu_vendor_module_exit();
	free_percpu(user_return_msrs);
	kmem_cache_destroy(x86_emulator_cache);
#ifdef CONFIG_KVM_XEN
	static_key_deferred_flush(&amp;kvm_xen_enabled);
<yellow>	WARN_ON(static_branch_unlikely(&kvm_xen_enabled.key));</yellow>
#endif
<yellow>}</yellow>

static int __kvm_emulate_halt(struct kvm_vcpu *vcpu, int state, int reason)
{
	/*
	 * The vCPU has halted, e.g. executed HLT.  Update the run state if the
	 * local APIC is in-kernel, the run loop will detect the non-runnable
	 * state and halt the vCPU.  Exit to userspace if the local APIC is
	 * managed by userspace, in which case userspace is responsible for
	 * handling wake events.
	 */
<blue>	++vcpu->stat.halt_exits;</blue>
<yellow>	if (lapic_in_kernel(vcpu)) {</yellow>
<blue>		vcpu->arch.mp_state = state;</blue>
		return 1;
	} else {
<yellow>		vcpu->run->exit_reason = reason;</yellow>
		return 0;
	}
}

int kvm_emulate_halt_noskip(struct kvm_vcpu *vcpu)
{
<blue>	return __kvm_emulate_halt(vcpu, KVM_MP_STATE_HALTED, KVM_EXIT_HLT);</blue>
<blue>}</blue>
EXPORT_SYMBOL_GPL(kvm_emulate_halt_noskip);

int kvm_emulate_halt(struct kvm_vcpu *vcpu)
{
<blue>	int ret = kvm_skip_emulated_instruction(vcpu);</blue>
	/*
	 * TODO: we might be squashing a GUESTDBG_SINGLESTEP-triggered
	 * KVM_EXIT_DEBUG here.
	 */
<blue>	return kvm_emulate_halt_noskip(vcpu) && ret;</blue>
<blue>}</blue>
EXPORT_SYMBOL_GPL(kvm_emulate_halt);

int kvm_emulate_ap_reset_hold(struct kvm_vcpu *vcpu)
{
<yellow>	int ret = kvm_skip_emulated_instruction(vcpu);</yellow>

<yellow>	return __kvm_emulate_halt(vcpu, KVM_MP_STATE_AP_RESET_HOLD,</yellow>
					KVM_EXIT_AP_RESET_HOLD) &amp;&amp; ret;
<yellow>}</yellow>
EXPORT_SYMBOL_GPL(kvm_emulate_ap_reset_hold);

#ifdef CONFIG_X86_64
static int kvm_pv_clock_pairing(struct kvm_vcpu *vcpu, gpa_t paddr,
			        unsigned long clock_type)
{
	struct kvm_clock_pairing clock_pairing;
	struct timespec64 ts;
	u64 cycle;
	int ret;

<yellow>	if (clock_type != KVM_CLOCK_PAIRING_WALLCLOCK)</yellow>
		return -KVM_EOPNOTSUPP;

	/*
	 * When tsc is in permanent catchup mode guests won&#x27;t be able to use
	 * pvclock_read_retry loop to get consistent view of pvclock
	 */
<yellow>	if (vcpu->arch.tsc_always_catchup)</yellow>
		return -KVM_EOPNOTSUPP;

<yellow>	if (!kvm_get_walltime_and_clockread(&ts, &cycle))</yellow>
		return -KVM_EOPNOTSUPP;

<yellow>	clock_pairing.sec = ts.tv_sec;</yellow>
	clock_pairing.nsec = ts.tv_nsec;
<yellow>	clock_pairing.tsc = kvm_read_l1_tsc(vcpu, cycle);</yellow>
	clock_pairing.flags = 0;
<yellow>	memset(&clock_pairing.pad, 0, sizeof(clock_pairing.pad));</yellow>

	ret = 0;
	if (kvm_write_guest(vcpu-&gt;kvm, paddr, &amp;clock_pairing,
			    sizeof(struct kvm_clock_pairing)))
		ret = -KVM_EFAULT;

	return ret;
}
#endif

/*
 * kvm_pv_kick_cpu_op:  Kick a vcpu.
 *
 * @apicid - apicid of vcpu to be kicked.
 */
static void kvm_pv_kick_cpu_op(struct kvm *kvm, int apicid)
{
	/*
	 * All other fields are unused for APIC_DM_REMRD, but may be consumed by
	 * common code, e.g. for tracing. Defer initialization to the compiler.
	 */
	struct kvm_lapic_irq lapic_irq = {
		.delivery_mode = APIC_DM_REMRD,
		.dest_mode = APIC_DEST_PHYSICAL,
		.shorthand = APIC_DEST_NOSHORT,
		.dest_id = apicid,
	};

	kvm_irq_delivery_to_apic(kvm, NULL, &amp;lapic_irq, NULL);
}

bool kvm_apicv_activated(struct kvm *kvm)
{
<blue>	return (READ_ONCE(kvm->arch.apicv_inhibit_reasons) == 0);</blue>
}
EXPORT_SYMBOL_GPL(kvm_apicv_activated);

bool kvm_vcpu_apicv_activated(struct kvm_vcpu *vcpu)
{
<blue>	ulong vm_reasons = READ_ONCE(vcpu->kvm->arch.apicv_inhibit_reasons);</blue>
	ulong vcpu_reasons = static_call(kvm_x86_vcpu_get_apicv_inhibit_reasons)(vcpu);

	return (vm_reasons | vcpu_reasons) == 0;
}
EXPORT_SYMBOL_GPL(kvm_vcpu_apicv_activated);

static void set_or_clear_apicv_inhibit(unsigned long *inhibits,
				       enum kvm_apicv_inhibit reason, bool set)
{
	if (set)
<blue>		__set_bit(reason, inhibits);</blue>
	else
<blue>		__clear_bit(reason, inhibits);</blue>

<blue>	trace_kvm_apicv_inhibit_changed(reason, set, *inhibits);</blue>
<blue>}</blue>

static void kvm_apicv_init(struct kvm *kvm)
{
	unsigned long *inhibits = &amp;kvm-&gt;arch.apicv_inhibit_reasons;

	init_rwsem(&amp;kvm-&gt;arch.apicv_update_lock);

	set_or_clear_apicv_inhibit(inhibits, APICV_INHIBIT_REASON_ABSENT, true);

<blue>	if (!enable_apicv)</blue>
<yellow>		set_or_clear_apicv_inhibit(inhibits,</yellow>
					   APICV_INHIBIT_REASON_DISABLE, true);
}

<yellow>static void kvm_sched_yield(struct kvm_vcpu *vcpu, unsigned long dest_id)</yellow>
{
	struct kvm_vcpu *target = NULL;
	struct kvm_apic_map *map;

<yellow>	vcpu->stat.directed_yield_attempted++;</yellow>

	if (single_task_running())
		goto no_yield;

<yellow>	rcu_read_lock();</yellow>
	map = rcu_dereference(vcpu-&gt;kvm-&gt;arch.apic_map);

<yellow>	if (likely(map) && dest_id <= map->max_apic_id && map->phys_map[dest_id])</yellow>
<yellow>		target = map->phys_map[dest_id]->vcpu;</yellow>

<yellow>	rcu_read_unlock();</yellow>

<yellow>	if (!target || !READ_ONCE(target->ready))</yellow>
		goto no_yield;

	/* Ignore requests to yield to self */
<yellow>	if (vcpu == target)</yellow>
		goto no_yield;

<yellow>	if (kvm_vcpu_yield_to(target) <= 0)</yellow>
		goto no_yield;

<yellow>	vcpu->stat.directed_yield_successful++;</yellow>

no_yield:
	return;
<yellow>}</yellow>

static int complete_hypercall_exit(struct kvm_vcpu *vcpu)
<yellow>{</yellow>
<yellow>	u64 ret = vcpu->run->hypercall.ret;</yellow>

<yellow>	if (!is_64_bit_mode(vcpu))</yellow>
<yellow>		ret = (u32)ret;</yellow>
<yellow>	kvm_rax_write(vcpu, ret);</yellow>
	++vcpu-&gt;stat.hypercalls;
<yellow>	return kvm_skip_emulated_instruction(vcpu);</yellow>
}

<yellow>int kvm_emulate_hypercall(struct kvm_vcpu *vcpu)</yellow>
{
	unsigned long nr, a0, a1, a2, a3, ret;
	int op_64_bit;

<yellow>	if (kvm_xen_hypercall_enabled(vcpu->kvm))</yellow>
<yellow>		return kvm_xen_hypercall(vcpu);</yellow>

<yellow>	if (kvm_hv_hypercall_enabled(vcpu))</yellow>
<yellow>		return kvm_hv_hypercall(vcpu);</yellow>

<yellow>	nr = kvm_rax_read(vcpu);</yellow>
	a0 = kvm_rbx_read(vcpu);
	a1 = kvm_rcx_read(vcpu);
	a2 = kvm_rdx_read(vcpu);
	a3 = kvm_rsi_read(vcpu);

<yellow>	trace_kvm_hypercall(nr, a0, a1, a2, a3);</yellow>

<yellow>	op_64_bit = is_64_bit_hypercall(vcpu);</yellow>
	if (!op_64_bit) {
		nr &amp;= 0xFFFFFFFF;
<yellow>		a0 &= 0xFFFFFFFF;</yellow>
		a1 &amp;= 0xFFFFFFFF;
		a2 &amp;= 0xFFFFFFFF;
<yellow>		a3 &= 0xFFFFFFFF;</yellow>
	}

<yellow>	if (static_call(kvm_x86_get_cpl)(vcpu) != 0) {</yellow>
		ret = -KVM_EPERM;
		goto out;
	}

	ret = -KVM_ENOSYS;

<yellow>	switch (nr) {</yellow>
	case KVM_HC_VAPIC_POLL_IRQ:
		ret = 0;
		break;
	case KVM_HC_KICK_CPU:
<yellow>		if (!guest_pv_has(vcpu, KVM_FEATURE_PV_UNHALT))</yellow>
			break;

<yellow>		kvm_pv_kick_cpu_op(vcpu->kvm, a1);</yellow>
		kvm_sched_yield(vcpu, a1);
		ret = 0;
		break;
#ifdef CONFIG_X86_64
	case KVM_HC_CLOCK_PAIRING:
<yellow>		ret = kvm_pv_clock_pairing(vcpu, a0, a1);</yellow>
<yellow>		break;</yellow>
#endif
	case KVM_HC_SEND_IPI:
<yellow>		if (!guest_pv_has(vcpu, KVM_FEATURE_PV_SEND_IPI))</yellow>
			break;

<yellow>		ret = kvm_pv_send_ipi(vcpu->kvm, a0, a1, a2, a3, op_64_bit);</yellow>
		break;
	case KVM_HC_SCHED_YIELD:
<yellow>		if (!guest_pv_has(vcpu, KVM_FEATURE_PV_SCHED_YIELD))</yellow>
			break;

<yellow>		kvm_sched_yield(vcpu, a0);</yellow>
		ret = 0;
		break;
	case KVM_HC_MAP_GPA_RANGE: {
		u64 gpa = a0, npages = a1, attrs = a2;

		ret = -KVM_ENOSYS;
<yellow>		if (!(vcpu->kvm->arch.hypercall_exit_enabled & (1 << KVM_HC_MAP_GPA_RANGE)))</yellow>
			break;

<yellow>		if (!PAGE_ALIGNED(gpa) || !npages ||</yellow>
<yellow>		    gpa_to_gfn(gpa) + npages <= gpa_to_gfn(gpa)) {</yellow>
			ret = -KVM_EINVAL;
			break;
		}

<yellow>		vcpu->run->exit_reason        = KVM_EXIT_HYPERCALL;</yellow>
		vcpu-&gt;run-&gt;hypercall.nr       = KVM_HC_MAP_GPA_RANGE;
		vcpu-&gt;run-&gt;hypercall.args[0]  = gpa;
		vcpu-&gt;run-&gt;hypercall.args[1]  = npages;
		vcpu-&gt;run-&gt;hypercall.args[2]  = attrs;
		vcpu-&gt;run-&gt;hypercall.longmode = op_64_bit;
		vcpu-&gt;arch.complete_userspace_io = complete_hypercall_exit;
		return 0;
	}
	default:
		ret = -KVM_ENOSYS;
		break;
	}
out:
<yellow>	if (!op_64_bit)</yellow>
		ret = (u32)ret;
<yellow>	kvm_rax_write(vcpu, ret);</yellow>

	++vcpu-&gt;stat.hypercalls;
<yellow>	return kvm_skip_emulated_instruction(vcpu);</yellow>
<yellow>}</yellow>
EXPORT_SYMBOL_GPL(kvm_emulate_hypercall);

static int emulator_fix_hypercall(struct x86_emulate_ctxt *ctxt)
<yellow>{</yellow>
<yellow>	struct kvm_vcpu *vcpu = emul_to_vcpu(ctxt);</yellow>
	char instruction[3];
<yellow>	unsigned long rip = kvm_rip_read(vcpu);</yellow>

	/*
	 * If the quirk is disabled, synthesize a #UD and let the guest pick up
	 * the pieces.
	 */
	if (!kvm_check_has_quirk(vcpu-&gt;kvm, KVM_X86_QUIRK_FIX_HYPERCALL_INSN)) {
<yellow>		ctxt->exception.error_code_valid = false;</yellow>
		ctxt-&gt;exception.vector = UD_VECTOR;
		ctxt-&gt;have_exception = true;
		return X86EMUL_PROPAGATE_FAULT;
	}

<yellow>	static_call(kvm_x86_patch_hypercall)(vcpu, instruction);</yellow>

	return emulator_write_emulated(ctxt, rip, instruction, 3,
		&amp;ctxt-&gt;exception);
}

<yellow>static int dm_request_for_irq_injection(struct kvm_vcpu *vcpu)</yellow>
{
<blue>	return vcpu->run->request_interrupt_window &&</blue>
<yellow>		likely(!pic_in_kernel(vcpu->kvm));</yellow>
}

/* Called within kvm-&gt;srcu read side.  */
static void post_kvm_run_save(struct kvm_vcpu *vcpu)
{
	struct kvm_run *kvm_run = vcpu-&gt;run;

<blue>	kvm_run->if_flag = static_call(kvm_x86_get_if_flag)(vcpu);</blue>
<blue>	kvm_run->cr8 = kvm_get_cr8(vcpu);</blue>
	kvm_run-&gt;apic_base = kvm_get_apic_base(vcpu);

<blue>	kvm_run->ready_for_interrupt_injection =</blue>
		pic_in_kernel(vcpu-&gt;kvm) ||
<yellow>		kvm_vcpu_ready_for_interrupt_injection(vcpu);</yellow>

	if (is_smm(vcpu))
<yellow>		kvm_run->flags |= KVM_RUN_X86_SMM;</yellow>
}

<yellow>static void update_cr8_intercept(struct kvm_vcpu *vcpu)</yellow>
{
	int max_irr, tpr;

<blue>	if (!kvm_x86_ops.update_cr8_intercept)</blue>
		return;

<blue>	if (!lapic_in_kernel(vcpu))</blue>
		return;

<blue>	if (vcpu->arch.apic->apicv_active)</blue>
		return;

<yellow>	if (!vcpu->arch.apic->vapic_addr)</yellow>
<yellow>		max_irr = kvm_lapic_find_highest_irr(vcpu);</yellow>
	else
		max_irr = -1;

	if (max_irr != -1)
<yellow>		max_irr >>= 4;</yellow>

<yellow>	tpr = kvm_lapic_get_cr8(vcpu);</yellow>

	static_call(kvm_x86_update_cr8_intercept)(vcpu, tpr, max_irr);
<blue>}</blue>


<yellow>int kvm_check_nested_events(struct kvm_vcpu *vcpu)</yellow>
{
<blue>	if (kvm_test_request(KVM_REQ_TRIPLE_FAULT, vcpu)) {</blue>
<yellow>		kvm_x86_ops.nested_ops->triple_fault(vcpu);</yellow>
		return 1;
	}

<blue>	return kvm_x86_ops.nested_ops->check_events(vcpu);</blue>
<blue>}</blue>

static void kvm_inject_exception(struct kvm_vcpu *vcpu)
{
<blue>	trace_kvm_inj_exception(vcpu->arch.exception.vector,</blue>
				vcpu-&gt;arch.exception.has_error_code,
				vcpu-&gt;arch.exception.error_code,
<blue>				vcpu->arch.exception.injected);</blue>

<blue>	if (vcpu->arch.exception.error_code && !is_protmode(vcpu))</blue>
<yellow>		vcpu->arch.exception.error_code = false;</yellow>
<blue>	static_call(kvm_x86_inject_exception)(vcpu);</blue>
}

/*
 * Check for any event (interrupt or exception) that is ready to be injected,
 * and if there is at least one event, inject the event with the highest
 * priority.  This handles both &quot;pending&quot; events, i.e. events that have never
 * been injected into the guest, and &quot;injected&quot; events, i.e. events that were
 * injected as part of a previous VM-Enter, but weren&#x27;t successfully delivered
 * and need to be re-injected.
 *
 * Note, this is not guaranteed to be invoked on a guest instruction boundary,
 * i.e. doesn&#x27;t guarantee that there&#x27;s an event window in the guest.  KVM must
 * be able to inject exceptions in the &quot;middle&quot; of an instruction, and so must
 * also be able to re-inject NMIs and IRQs in the middle of an instruction.
 * I.e. for exceptions and re-injected events, NOT invoking this on instruction
 * boundaries is necessary and correct.
 *
 * For simplicity, KVM uses a single path to inject all events (except events
 * that are injected directly from L1 to L2) and doesn&#x27;t explicitly track
 * instruction boundaries for asynchronous events.  However, because VM-Exits
 * that can occur during instruction execution typically result in KVM skipping
 * the instruction or injecting an exception, e.g. instruction and exception
 * intercepts, and because pending exceptions have higher priority than pending
 * interrupts, KVM still honors instruction boundaries in most scenarios.
 *
 * But, if a VM-Exit occurs during instruction execution, and KVM does NOT skip
 * the instruction or inject an exception, then KVM can incorrecty inject a new
 * asynchrounous event if the event became pending after the CPU fetched the
 * instruction (in the guest).  E.g. if a page fault (#PF, #NPF, EPT violation)
 * occurs and is resolved by KVM, a coincident NMI, SMI, IRQ, etc... can be
 * injected on the restarted instruction instead of being deferred until the
 * instruction completes.
 *
 * In practice, this virtualization hole is unlikely to be observed by the
 * guest, and even less likely to cause functional problems.  To detect the
 * hole, the guest would have to trigger an event on a side effect of an early
 * phase of instruction execution, e.g. on the instruction fetch from memory.
 * And for it to be a functional problem, the guest would need to depend on the
 * ordering between that side effect, the instruction completing, _and_ the
 * delivery of the asynchronous event.
 */
static int kvm_check_and_inject_events(struct kvm_vcpu *vcpu,
				       bool *req_immediate_exit)
{
	bool can_inject;
	int r;

	/*
	 * Process nested events first, as nested VM-Exit supercedes event
	 * re-injection.  If there&#x27;s an event queued for re-injection, it will
	 * be saved into the appropriate vmc{b,s}12 fields on nested VM-Exit.
	 */
<blue>	if (is_guest_mode(vcpu))</blue>
<blue>		r = kvm_check_nested_events(vcpu);</blue>
	else
		r = 0;

	/*
	 * Re-inject exceptions and events *especially* if immediate entry+exit
	 * to/from L2 is needed, as any event that has already been injected
	 * into L2 needs to complete its lifecycle before injecting a new event.
	 *
	 * Don&#x27;t re-inject an NMI or interrupt if there is a pending exception.
	 * This collision arises if an exception occurred while vectoring the
	 * injected event, KVM intercepted said exception, and KVM ultimately
	 * determined the fault belongs to the guest and queues the exception
	 * for injection back into the guest.
	 *
	 * &quot;Injected&quot; interrupts can also collide with pending exceptions if
	 * userspace ignores the &quot;ready for injection&quot; flag and blindly queues
	 * an interrupt.  In that case, prioritizing the exception is correct,
	 * as the exception &quot;occurred&quot; before the exit to userspace.  Trap-like
	 * exceptions, e.g. most #DBs, have higher priority than interrupts.
	 * And while fault-like exceptions, e.g. #GP and #PF, are the lowest
	 * priority, they&#x27;re only generated (pended) during instruction
	 * execution, and interrupts are recognized at instruction boundaries.
	 * Thus a pending fault-like exception means the fault occurred on the
	 * *previous* instruction and must be serviced prior to recognizing any
	 * new events in order to fully complete the previous instruction.
	 */
<blue>	if (vcpu->arch.exception.injected)</blue>
<blue>		kvm_inject_exception(vcpu);</blue>
<blue>	else if (kvm_is_exception_pending(vcpu))</blue>
		; /* see above */
<blue>	else if (vcpu->arch.nmi_injected)</blue>
<blue>		static_call(kvm_x86_inject_nmi)(vcpu);</blue>
<blue>	else if (vcpu->arch.interrupt.injected)</blue>
<blue>		static_call(kvm_x86_inject_irq)(vcpu, true);</blue>

	/*
	 * Exceptions that morph to VM-Exits are handled above, and pending
	 * exceptions on top of injected exceptions that do not VM-Exit should
	 * either morph to #DF or, sadly, override the injected exception.
	 */
<blue>	WARN_ON_ONCE(vcpu->arch.exception.injected &&</blue>
		     vcpu-&gt;arch.exception.pending);

	/*
	 * Bail if immediate entry+exit to/from the guest is needed to complete
	 * nested VM-Enter or event re-injection so that a different pending
	 * event can be serviced (or if KVM needs to exit to userspace).
	 *
	 * Otherwise, continue processing events even if VM-Exit occurred.  The
	 * VM-Exit will have cleared exceptions that were meant for L2, but
	 * there may now be events that can be injected into L1.
	 */
<blue>	if (r < 0)</blue>
		goto out;

	/*
	 * A pending exception VM-Exit should either result in nested VM-Exit
	 * or force an immediate re-entry and exit to/from L2, and exception
	 * VM-Exits cannot be injected (flag should _never_ be set).
	 */
<blue>	WARN_ON_ONCE(vcpu->arch.exception_vmexit.injected ||</blue>
		     vcpu-&gt;arch.exception_vmexit.pending);

	/*
	 * New events, other than exceptions, cannot be injected if KVM needs
	 * to re-inject a previous event.  See above comments on re-injecting
	 * for why pending exceptions get priority.
	 */
<blue>	can_inject = !kvm_event_needs_reinjection(vcpu);</blue>

<blue>	if (vcpu->arch.exception.pending) {</blue>
		/*
		 * Fault-class exceptions, except #DBs, set RF=1 in the RFLAGS
		 * value pushed on the stack.  Trap-like exception and all #DBs
		 * leave RF as-is (KVM follows Intel&#x27;s behavior in this regard;
		 * AMD states that code breakpoint #DBs excplitly clear RF=0).
		 *
		 * Note, most versions of Intel&#x27;s SDM and AMD&#x27;s APM incorrectly
		 * describe the behavior of General Detect #DBs, which are
		 * fault-like.  They do _not_ set RF, a la code breakpoints.
		 */
<blue>		if (exception_type(vcpu->arch.exception.vector) == EXCPT_FAULT)</blue>
<blue>			__kvm_set_rflags(vcpu, kvm_get_rflags(vcpu) |</blue>
					     X86_EFLAGS_RF);

<blue>		if (vcpu->arch.exception.vector == DB_VECTOR) {</blue>
<blue>			kvm_deliver_exception_payload(vcpu, &vcpu->arch.exception);</blue>
			if (vcpu-&gt;arch.dr7 &amp; DR7_GD) {
				vcpu-&gt;arch.dr7 &amp;= ~DR7_GD;
<blue>				kvm_update_dr7(vcpu);</blue>
			}
		}

<blue>		kvm_inject_exception(vcpu);</blue>

		vcpu-&gt;arch.exception.pending = false;
		vcpu-&gt;arch.exception.injected = true;

		can_inject = false;
	}

	/* Don&#x27;t inject interrupts if the user asked to avoid doing so */
<blue>	if (vcpu->guest_debug & KVM_GUESTDBG_BLOCKIRQ)</blue>
		return 0;

	/*
	 * Finally, inject interrupt events.  If an event cannot be injected
	 * due to architectural conditions (e.g. IF=0) a window-open exit
	 * will re-request KVM_REQ_EVENT.  Sometimes however an event is pending
	 * and can architecturally be injected, but we cannot do it right now:
	 * an interrupt could have arrived just now and we have to inject it
	 * as a vmexit, or there could already an event in the queue, which is
	 * indicated by can_inject.  In that case we request an immediate exit
	 * in order to make progress and get back here for another iteration.
	 * The kvm_x86_ops hooks communicate this by returning -EBUSY.
	 */
<blue>	if (vcpu->arch.smi_pending) {</blue>
<yellow>		r = can_inject ? static_call(kvm_x86_smi_allowed)(vcpu, true) : -EBUSY;</yellow>
		if (r &lt; 0)
			goto out;
<yellow>		if (r) {</yellow>
<yellow>			vcpu->arch.smi_pending = false;</yellow>
			++vcpu-&gt;arch.smi_count;
			enter_smm(vcpu);
			can_inject = false;
		} else
			static_call(kvm_x86_enable_smi_window)(vcpu);
	}

<blue>	if (vcpu->arch.nmi_pending) {</blue>
<yellow>		r = can_inject ? static_call(kvm_x86_nmi_allowed)(vcpu, true) : -EBUSY;</yellow>
		if (r &lt; 0)
			goto out;
<yellow>		if (r) {</yellow>
<yellow>			--vcpu->arch.nmi_pending;</yellow>
			vcpu-&gt;arch.nmi_injected = true;
			static_call(kvm_x86_inject_nmi)(vcpu);
			can_inject = false;
<yellow>			WARN_ON(static_call(kvm_x86_nmi_allowed)(vcpu, true) < 0);</yellow>
		}
<yellow>		if (vcpu->arch.nmi_pending)</yellow>
<yellow>			static_call(kvm_x86_enable_nmi_window)(vcpu);</yellow>
	}

<blue>	if (kvm_cpu_has_injectable_intr(vcpu)) {</blue>
<blue>		r = can_inject ? static_call(kvm_x86_interrupt_allowed)(vcpu, true) : -EBUSY;</blue>
		if (r &lt; 0)
			goto out;
<blue>		if (r) {</blue>
<blue>			kvm_queue_interrupt(vcpu, kvm_cpu_get_interrupt(vcpu), false);</blue>
			static_call(kvm_x86_inject_irq)(vcpu, false);
<yellow>			WARN_ON(static_call(kvm_x86_interrupt_allowed)(vcpu, true) < 0);</yellow>
		}
<blue>		if (kvm_cpu_has_injectable_intr(vcpu))</blue>
<blue>			static_call(kvm_x86_enable_irq_window)(vcpu);</blue>
	}

<blue>	if (is_guest_mode(vcpu) &&</blue>
<blue>	    kvm_x86_ops.nested_ops->has_events &&</blue>
<blue>	    kvm_x86_ops.nested_ops->has_events(vcpu))</blue>
		*req_immediate_exit = true;

	/*
	 * KVM must never queue a new exception while injecting an event; KVM
	 * is done emulating and should only propagate the to-be-injected event
	 * to the VMCS/VMCB.  Queueing a new exception can put the vCPU into an
	 * infinite loop as KVM will bail from VM-Enter to inject the pending
	 * exception and start the cycle all over.
	 *
	 * Exempt triple faults as they have special handling and won&#x27;t put the
	 * vCPU into an infinite loop.  Triple fault can be queued when running
	 * VMX without unrestricted guest, as that requires KVM to emulate Real
	 * Mode events (see kvm_inject_realmode_interrupt()).
	 */
<blue>	WARN_ON_ONCE(vcpu->arch.exception.pending ||</blue>
		     vcpu-&gt;arch.exception_vmexit.pending);
	return 0;

out:
<blue>	if (r == -EBUSY) {</blue>
		*req_immediate_exit = true;
		r = 0;
	}
	return r;
}

static void process_nmi(struct kvm_vcpu *vcpu)
{
	unsigned limit = 2;

	/*
	 * x86 is limited to one NMI running, and one NMI pending after it.
	 * If an NMI is already in progress, limit further NMIs to just one.
	 * Otherwise, allow two (and we&#x27;ll inject the first one immediately).
	 */
<blue>	if (static_call(kvm_x86_get_nmi_mask)(vcpu) || vcpu->arch.nmi_injected)</blue>
		limit = 1;

<blue>	vcpu->arch.nmi_pending += atomic_xchg(&vcpu->arch.nmi_queued, 0);</blue>
	vcpu-&gt;arch.nmi_pending = min(vcpu-&gt;arch.nmi_pending, limit);
	kvm_make_request(KVM_REQ_EVENT, vcpu);
}

static u32 enter_smm_get_segment_flags(struct kvm_segment *seg)
{
	u32 flags = 0;
	flags |= seg-&gt;g       &lt;&lt; 23;
	flags |= seg-&gt;db      &lt;&lt; 22;
	flags |= seg-&gt;l       &lt;&lt; 21;
	flags |= seg-&gt;avl     &lt;&lt; 20;
	flags |= seg-&gt;present &lt;&lt; 15;
	flags |= seg-&gt;dpl     &lt;&lt; 13;
<yellow>	flags |= seg->s       << 12;</yellow>
	flags |= seg-&gt;type    &lt;&lt; 8;
	return flags;
}

static void enter_smm_save_seg_32(struct kvm_vcpu *vcpu, char *buf, int n)
{
	struct kvm_segment seg;
	int offset;

<yellow>	kvm_get_segment(vcpu, &seg, n);</yellow>
	put_smstate(u32, buf, 0x7fa8 + n * 4, seg.selector);

	if (n &lt; 3)
<yellow>		offset = 0x7f84 + n * 12;</yellow>
	else
<yellow>		offset = 0x7f2c + (n - 3) * 12;</yellow>

<yellow>	put_smstate(u32, buf, offset + 8, seg.base);</yellow>
	put_smstate(u32, buf, offset + 4, seg.limit);
	put_smstate(u32, buf, offset, enter_smm_get_segment_flags(&amp;seg));
}

#ifdef CONFIG_X86_64
static void enter_smm_save_seg_64(struct kvm_vcpu *vcpu, char *buf, int n)
{
	struct kvm_segment seg;
	int offset;
	u16 flags;

<yellow>	kvm_get_segment(vcpu, &seg, n);</yellow>
	offset = 0x7e00 + n * 16;

	flags = enter_smm_get_segment_flags(&amp;seg) &gt;&gt; 8;
	put_smstate(u16, buf, offset, seg.selector);
	put_smstate(u16, buf, offset + 2, flags);
	put_smstate(u32, buf, offset + 4, seg.limit);
	put_smstate(u64, buf, offset + 8, seg.base);
}
#endif

static void enter_smm_save_state_32(struct kvm_vcpu *vcpu, char *buf)
{
	struct desc_ptr dt;
	struct kvm_segment seg;
	unsigned long val;
	int i;

<yellow>	put_smstate(u32, buf, 0x7ffc, kvm_read_cr0(vcpu));</yellow>
<yellow>	put_smstate(u32, buf, 0x7ff8, kvm_read_cr3(vcpu));</yellow>
<yellow>	put_smstate(u32, buf, 0x7ff4, kvm_get_rflags(vcpu));</yellow>
<yellow>	put_smstate(u32, buf, 0x7ff0, kvm_rip_read(vcpu));</yellow>

	for (i = 0; i &lt; 8; i++)
<yellow>		put_smstate(u32, buf, 0x7fd0 + i * 4, kvm_register_read_raw(vcpu, i));</yellow>

<yellow>	kvm_get_dr(vcpu, 6, &val);</yellow>
	put_smstate(u32, buf, 0x7fcc, (u32)val);
	kvm_get_dr(vcpu, 7, &amp;val);
	put_smstate(u32, buf, 0x7fc8, (u32)val);

	kvm_get_segment(vcpu, &amp;seg, VCPU_SREG_TR);
	put_smstate(u32, buf, 0x7fc4, seg.selector);
	put_smstate(u32, buf, 0x7f64, seg.base);
	put_smstate(u32, buf, 0x7f60, seg.limit);
	put_smstate(u32, buf, 0x7f5c, enter_smm_get_segment_flags(&amp;seg));

	kvm_get_segment(vcpu, &amp;seg, VCPU_SREG_LDTR);
	put_smstate(u32, buf, 0x7fc0, seg.selector);
	put_smstate(u32, buf, 0x7f80, seg.base);
	put_smstate(u32, buf, 0x7f7c, seg.limit);
	put_smstate(u32, buf, 0x7f78, enter_smm_get_segment_flags(&amp;seg));

	static_call(kvm_x86_get_gdt)(vcpu, &amp;dt);
	put_smstate(u32, buf, 0x7f74, dt.address);
	put_smstate(u32, buf, 0x7f70, dt.size);

	static_call(kvm_x86_get_idt)(vcpu, &amp;dt);
	put_smstate(u32, buf, 0x7f58, dt.address);
	put_smstate(u32, buf, 0x7f54, dt.size);

	for (i = 0; i &lt; 6; i++)
<yellow>		enter_smm_save_seg_32(vcpu, buf, i);</yellow>

<yellow>	put_smstate(u32, buf, 0x7f14, kvm_read_cr4(vcpu));</yellow>

	/* revision id */
	put_smstate(u32, buf, 0x7efc, 0x00020000);
	put_smstate(u32, buf, 0x7ef8, vcpu-&gt;arch.smbase);
}

#ifdef CONFIG_X86_64
static void enter_smm_save_state_64(struct kvm_vcpu *vcpu, char *buf)
{
	struct desc_ptr dt;
	struct kvm_segment seg;
	unsigned long val;
	int i;

	for (i = 0; i &lt; 16; i++)
<yellow>		put_smstate(u64, buf, 0x7ff8 - i * 8, kvm_register_read_raw(vcpu, i));</yellow>

<yellow>	put_smstate(u64, buf, 0x7f78, kvm_rip_read(vcpu));</yellow>
<yellow>	put_smstate(u32, buf, 0x7f70, kvm_get_rflags(vcpu));</yellow>

<yellow>	kvm_get_dr(vcpu, 6, &val);</yellow>
	put_smstate(u64, buf, 0x7f68, val);
	kvm_get_dr(vcpu, 7, &amp;val);
	put_smstate(u64, buf, 0x7f60, val);

<yellow>	put_smstate(u64, buf, 0x7f58, kvm_read_cr0(vcpu));</yellow>
<yellow>	put_smstate(u64, buf, 0x7f50, kvm_read_cr3(vcpu));</yellow>
<yellow>	put_smstate(u64, buf, 0x7f48, kvm_read_cr4(vcpu));</yellow>

	put_smstate(u32, buf, 0x7f00, vcpu-&gt;arch.smbase);

	/* revision id */
	put_smstate(u32, buf, 0x7efc, 0x00020064);

	put_smstate(u64, buf, 0x7ed0, vcpu-&gt;arch.efer);

	kvm_get_segment(vcpu, &amp;seg, VCPU_SREG_TR);
	put_smstate(u16, buf, 0x7e90, seg.selector);
	put_smstate(u16, buf, 0x7e92, enter_smm_get_segment_flags(&amp;seg) &gt;&gt; 8);
	put_smstate(u32, buf, 0x7e94, seg.limit);
	put_smstate(u64, buf, 0x7e98, seg.base);

	static_call(kvm_x86_get_idt)(vcpu, &amp;dt);
	put_smstate(u32, buf, 0x7e84, dt.size);
	put_smstate(u64, buf, 0x7e88, dt.address);

	kvm_get_segment(vcpu, &amp;seg, VCPU_SREG_LDTR);
	put_smstate(u16, buf, 0x7e70, seg.selector);
	put_smstate(u16, buf, 0x7e72, enter_smm_get_segment_flags(&amp;seg) &gt;&gt; 8);
	put_smstate(u32, buf, 0x7e74, seg.limit);
	put_smstate(u64, buf, 0x7e78, seg.base);

	static_call(kvm_x86_get_gdt)(vcpu, &amp;dt);
	put_smstate(u32, buf, 0x7e64, dt.size);
	put_smstate(u64, buf, 0x7e68, dt.address);

	for (i = 0; i &lt; 6; i++)
<yellow>		enter_smm_save_seg_64(vcpu, buf, i);</yellow>
<yellow>}</yellow>
#endif

static void enter_smm(struct kvm_vcpu *vcpu)
{
	struct kvm_segment cs, ds;
	struct desc_ptr dt;
	unsigned long cr0;
	char buf[512];

<yellow>	memset(buf, 0, 512);</yellow>
#ifdef CONFIG_X86_64
<yellow>	if (guest_cpuid_has(vcpu, X86_FEATURE_LM))</yellow>
<yellow>		enter_smm_save_state_64(vcpu, buf);</yellow>
	else
#endif
<yellow>		enter_smm_save_state_32(vcpu, buf);</yellow>

	/*
	 * Give enter_smm() a chance to make ISA-specific changes to the vCPU
	 * state (e.g. leave guest mode) after we&#x27;ve saved the state into the
	 * SMM state-save area.
	 */
<yellow>	static_call(kvm_x86_enter_smm)(vcpu, buf);</yellow>

	kvm_smm_changed(vcpu, true);
	kvm_vcpu_write_guest(vcpu, vcpu-&gt;arch.smbase + 0xfe00, buf, sizeof(buf));

	if (static_call(kvm_x86_get_nmi_mask)(vcpu))
<yellow>		vcpu->arch.hflags |= HF_SMM_INSIDE_NMI_MASK;</yellow>
	else
<yellow>		static_call(kvm_x86_set_nmi_mask)(vcpu, true);</yellow>

<yellow>	kvm_set_rflags(vcpu, X86_EFLAGS_FIXED);</yellow>
	kvm_rip_write(vcpu, 0x8000);

	cr0 = vcpu-&gt;arch.cr0 &amp; ~(X86_CR0_PE | X86_CR0_EM | X86_CR0_TS | X86_CR0_PG);
	static_call(kvm_x86_set_cr0)(vcpu, cr0);
	vcpu-&gt;arch.cr0 = cr0;

	static_call(kvm_x86_set_cr4)(vcpu, 0);

	/* Undocumented: IDT limit is set to zero on entry to SMM.  */
	dt.address = dt.size = 0;
	static_call(kvm_x86_set_idt)(vcpu, &amp;dt);

<yellow>	kvm_set_dr(vcpu, 7, DR7_FIXED_1);</yellow>

<yellow>	cs.selector = (vcpu->arch.smbase >> 4) & 0xffff;</yellow>
	cs.base = vcpu-&gt;arch.smbase;

	ds.selector = 0;
	ds.base = 0;

	cs.limit    = ds.limit = 0xffffffff;
	cs.type     = ds.type = 0x3;
	cs.dpl      = ds.dpl = 0;
	cs.db       = ds.db = 0;
	cs.s        = ds.s = 1;
	cs.l        = ds.l = 0;
	cs.g        = ds.g = 1;
	cs.avl      = ds.avl = 0;
	cs.present  = ds.present = 1;
	cs.unusable = ds.unusable = 0;
	cs.padding  = ds.padding = 0;

	kvm_set_segment(vcpu, &amp;cs, VCPU_SREG_CS);
	kvm_set_segment(vcpu, &amp;ds, VCPU_SREG_DS);
	kvm_set_segment(vcpu, &amp;ds, VCPU_SREG_ES);
	kvm_set_segment(vcpu, &amp;ds, VCPU_SREG_FS);
	kvm_set_segment(vcpu, &amp;ds, VCPU_SREG_GS);
	kvm_set_segment(vcpu, &amp;ds, VCPU_SREG_SS);

#ifdef CONFIG_X86_64
<yellow>	if (guest_cpuid_has(vcpu, X86_FEATURE_LM))</yellow>
<yellow>		static_call(kvm_x86_set_efer)(vcpu, 0);</yellow>
#endif

<yellow>	kvm_update_cpuid_runtime(vcpu);</yellow>
	kvm_mmu_reset_context(vcpu);
}

static void process_smi(struct kvm_vcpu *vcpu)
{
	vcpu-&gt;arch.smi_pending = true;
	kvm_make_request(KVM_REQ_EVENT, vcpu);
}

void kvm_make_scan_ioapic_request_mask(struct kvm *kvm,
				       unsigned long *vcpu_bitmap)
{
<yellow>	kvm_make_vcpus_request_mask(kvm, KVM_REQ_SCAN_IOAPIC, vcpu_bitmap);</yellow>
}

void kvm_make_scan_ioapic_request(struct kvm *kvm)
{
<blue>	kvm_make_all_cpus_request(kvm, KVM_REQ_SCAN_IOAPIC);</blue>
}

void kvm_vcpu_update_apicv(struct kvm_vcpu *vcpu)
{
<blue>	struct kvm_lapic *apic = vcpu->arch.apic;</blue>
	bool activate;

<yellow>	if (!lapic_in_kernel(vcpu))</yellow>
		return;

<blue>	down_read(&vcpu->kvm->arch.apicv_update_lock);</blue>
	preempt_disable();

	/* Do not activate APICV when APIC is disabled */
	activate = kvm_vcpu_apicv_activated(vcpu) &amp;&amp;
<blue>		   (kvm_get_apic_mode(vcpu) != LAPIC_MODE_DISABLED);</blue>

<blue>	if (apic->apicv_active == activate)</blue>
		goto out;

<yellow>	apic->apicv_active = activate;</yellow>
	kvm_apic_update_apicv(vcpu);
	static_call(kvm_x86_refresh_apicv_exec_ctrl)(vcpu);

	/*
	 * When APICv gets disabled, we may still have injected interrupts
	 * pending. At the same time, KVM_REQ_EVENT may not be set as APICv was
	 * still active when the interrupt got accepted. Make sure
	 * kvm_check_and_inject_events() is called to check for that.
	 */
<yellow>	if (!apic->apicv_active)</yellow>
<yellow>		kvm_make_request(KVM_REQ_EVENT, vcpu);</yellow>

out:
<blue>	preempt_enable();</blue>
<blue>	up_read(&vcpu->kvm->arch.apicv_update_lock);</blue>
<blue>}</blue>
EXPORT_SYMBOL_GPL(kvm_vcpu_update_apicv);

<blue>void __kvm_set_or_clear_apicv_inhibit(struct kvm *kvm,</blue>
				      enum kvm_apicv_inhibit reason, bool set)
{
	unsigned long old, new;

	lockdep_assert_held_write(&amp;kvm-&gt;arch.apicv_update_lock);

<blue>	if (!static_call(kvm_x86_check_apicv_inhibit_reasons)(reason))</blue>
		return;

<blue>	old = new = kvm->arch.apicv_inhibit_reasons;</blue>

	set_or_clear_apicv_inhibit(&amp;new, reason, set);

	if (!!old != !!new) {
		/*
		 * Kick all vCPUs before setting apicv_inhibit_reasons to avoid
		 * false positives in the sanity check WARN in svm_vcpu_run().
		 * This task will wait for all vCPUs to ack the kick IRQ before
		 * updating apicv_inhibit_reasons, and all other vCPUs will
		 * block on acquiring apicv_update_lock so that vCPUs can&#x27;t
		 * redo svm_vcpu_run() without seeing the new inhibit state.
		 *
		 * Note, holding apicv_update_lock and taking it in the read
		 * side (handling the request) also prevents other vCPUs from
		 * servicing the request with a stale apicv_inhibit_reasons.
		 */
<blue>		kvm_make_all_cpus_request(kvm, KVM_REQ_APICV_UPDATE);</blue>
		kvm-&gt;arch.apicv_inhibit_reasons = new;
		if (new) {
			unsigned long gfn = gpa_to_gfn(APIC_DEFAULT_PHYS_BASE);
<yellow>			int idx = srcu_read_lock(&kvm->srcu);</yellow>

			kvm_zap_gfn_range(kvm, gfn, gfn+1);
<yellow>			srcu_read_unlock(&kvm->srcu, idx);</yellow>
		}
	} else {
<yellow>		kvm->arch.apicv_inhibit_reasons = new;</yellow>
	}
<yellow>}</yellow>

<blue>void kvm_set_or_clear_apicv_inhibit(struct kvm *kvm,</blue>
				    enum kvm_apicv_inhibit reason, bool set)
{
<blue>	if (!enable_apicv)</blue>
		return;

<blue>	down_write(&kvm->arch.apicv_update_lock);</blue>
<blue>	__kvm_set_or_clear_apicv_inhibit(kvm, reason, set);</blue>
<blue>	up_write(&kvm->arch.apicv_update_lock);</blue>
<blue>}</blue>
EXPORT_SYMBOL_GPL(kvm_set_or_clear_apicv_inhibit);

static void vcpu_scan_ioapic(struct kvm_vcpu *vcpu)
{
<blue>	if (!kvm_apic_present(vcpu))</blue>
		return;

<blue>	bitmap_zero(vcpu->arch.ioapic_handled_vectors, 256);</blue>

	if (irqchip_split(vcpu-&gt;kvm))
<yellow>		kvm_scan_ioapic_routes(vcpu, vcpu->arch.ioapic_handled_vectors);</yellow>
	else {
<blue>		static_call_cond(kvm_x86_sync_pir_to_irr)(vcpu);</blue>
		if (ioapic_in_kernel(vcpu-&gt;kvm))
<blue>			kvm_ioapic_scan_entry(vcpu, vcpu->arch.ioapic_handled_vectors);</blue>
	}

<blue>	if (is_guest_mode(vcpu))</blue>
<yellow>		vcpu->arch.load_eoi_exitmap_pending = true;</yellow>
	else
<blue>		kvm_make_request(KVM_REQ_LOAD_EOI_EXITMAP, vcpu);</blue>
}

static void vcpu_load_eoi_exitmap(struct kvm_vcpu *vcpu)
{
	u64 eoi_exit_bitmap[4];

<yellow>	if (!kvm_apic_hw_enabled(vcpu->arch.apic))</yellow>
<blue>		return;</blue>

<blue>	if (to_hv_vcpu(vcpu)) {</blue>
		bitmap_or((ulong *)eoi_exit_bitmap,
			  vcpu-&gt;arch.ioapic_handled_vectors,
<blue>			  to_hv_synic(vcpu)->vec_bitmap, 256);</blue>
		static_call_cond(kvm_x86_load_eoi_exitmap)(vcpu, eoi_exit_bitmap);
		return;
	}

<yellow>	static_call_cond(kvm_x86_load_eoi_exitmap)(</yellow>
		vcpu, (u64 *)vcpu-&gt;arch.ioapic_handled_vectors);
}

void kvm_arch_mmu_notifier_invalidate_range(struct kvm *kvm,
					    unsigned long start, unsigned long end)
{
	unsigned long apic_address;

	/*
	 * The physical address of apic access page is stored in the VMCS.
	 * Update it when it becomes invalid.
	 */
<blue>	apic_address = gfn_to_hva(kvm, APIC_DEFAULT_PHYS_BASE >> PAGE_SHIFT);</blue>
<blue>	if (start <= apic_address && apic_address < end)</blue>
<yellow>		kvm_make_all_cpus_request(kvm, KVM_REQ_APIC_PAGE_RELOAD);</yellow>
<blue>}</blue>

void kvm_arch_guest_memory_reclaimed(struct kvm *kvm)
{
<blue>	static_call_cond(kvm_x86_guest_memory_reclaimed)(kvm);</blue>
}

static void kvm_vcpu_reload_apic_access_page(struct kvm_vcpu *vcpu)
{
<yellow>	if (!lapic_in_kernel(vcpu))</yellow>
		return;

<blue>	static_call_cond(kvm_x86_set_apic_access_page_addr)(vcpu);</blue>
}

void __kvm_request_immediate_exit(struct kvm_vcpu *vcpu)
{
<blue>	smp_send_reschedule(vcpu->cpu);</blue>
}
EXPORT_SYMBOL_GPL(__kvm_request_immediate_exit);

/*
 * Called within kvm-&gt;srcu read side.
 * Returns 1 to let vcpu_run() continue the guest execution loop without
 * exiting to the userspace.  Otherwise, the value will be returned to the
 * userspace.
 */
static int vcpu_enter_guest(struct kvm_vcpu *vcpu)
<blue>{</blue>
	int r;
	bool req_int_win =
<blue>		dm_request_for_irq_injection(vcpu) &&</blue>
<yellow>		kvm_cpu_accept_dm_intr(vcpu);</yellow>
	fastpath_t exit_fastpath;

	bool req_immediate_exit = false;

	/* Forbid vmenter if vcpu dirty ring is soft-full */
<blue>	if (unlikely(vcpu->kvm->dirty_ring_size &&</blue>
		     kvm_dirty_ring_soft_full(&amp;vcpu-&gt;dirty_ring))) {
<yellow>		vcpu->run->exit_reason = KVM_EXIT_DIRTY_RING_FULL;</yellow>
<yellow>		trace_kvm_dirty_ring_exit(vcpu);</yellow>
		r = 0;
		goto out;
	}

<blue>	if (kvm_request_pending(vcpu)) {</blue>
<blue>		if (kvm_check_request(KVM_REQ_VM_DEAD, vcpu)) {</blue>
			r = -EIO;
			goto out;
		}
<blue>		if (kvm_check_request(KVM_REQ_GET_NESTED_STATE_PAGES, vcpu)) {</blue>
			if (unlikely(!kvm_x86_ops.nested_ops-&gt;get_nested_state_pages(vcpu))) {
				r = 0;
				goto out;
			}
		}
<blue>		if (kvm_check_request(KVM_REQ_MMU_FREE_OBSOLETE_ROOTS, vcpu))</blue>
			kvm_mmu_free_obsolete_roots(vcpu);
<blue>		if (kvm_check_request(KVM_REQ_MIGRATE_TIMER, vcpu))</blue>
			__kvm_migrate_timers(vcpu);
<blue>		if (kvm_check_request(KVM_REQ_MASTERCLOCK_UPDATE, vcpu))</blue>
			kvm_update_masterclock(vcpu-&gt;kvm);
<blue>		if (kvm_check_request(KVM_REQ_GLOBAL_CLOCK_UPDATE, vcpu))</blue>
			kvm_gen_kvmclock_update(vcpu);
<blue>		if (kvm_check_request(KVM_REQ_CLOCK_UPDATE, vcpu)) {</blue>
			r = kvm_guest_time_update(vcpu);
			if (unlikely(r))
				goto out;
		}
<blue>		if (kvm_check_request(KVM_REQ_MMU_SYNC, vcpu))</blue>
			kvm_mmu_sync_roots(vcpu);
<blue>		if (kvm_check_request(KVM_REQ_LOAD_MMU_PGD, vcpu))</blue>
<blue>			kvm_mmu_load_pgd(vcpu);</blue>
<blue>		if (kvm_check_request(KVM_REQ_TLB_FLUSH, vcpu)) {</blue>
			kvm_vcpu_flush_tlb_all(vcpu);

			/* Flushing all ASIDs flushes the current ASID... */
			kvm_clear_request(KVM_REQ_TLB_FLUSH_CURRENT, vcpu);
		}
<blue>		kvm_service_local_tlb_flush_requests(vcpu);</blue>

<yellow>		if (kvm_check_request(KVM_REQ_REPORT_TPR_ACCESS, vcpu)) {</yellow>
			vcpu-&gt;run-&gt;exit_reason = KVM_EXIT_TPR_ACCESS;
			r = 0;
			goto out;
		}
<blue>		if (kvm_test_request(KVM_REQ_TRIPLE_FAULT, vcpu)) {</blue>
<blue>			if (is_guest_mode(vcpu))</blue>
<yellow>				kvm_x86_ops.nested_ops->triple_fault(vcpu);</yellow>

<blue>			if (kvm_check_request(KVM_REQ_TRIPLE_FAULT, vcpu)) {</blue>
				vcpu-&gt;run-&gt;exit_reason = KVM_EXIT_SHUTDOWN;
				vcpu-&gt;mmio_needed = 0;
				r = 0;
			}
			goto out;
		}
<blue>		if (kvm_check_request(KVM_REQ_APF_HALT, vcpu)) {</blue>
			/* Page is swapped out. Do synthetic halt */
			vcpu-&gt;arch.apf.halted = true;
			r = 1;
			goto out;
		}
<blue>		if (kvm_check_request(KVM_REQ_STEAL_UPDATE, vcpu))</blue>
			record_steal_time(vcpu);
<blue>		if (kvm_check_request(KVM_REQ_SMI, vcpu))</blue>
			process_smi(vcpu);
<blue>		if (kvm_check_request(KVM_REQ_NMI, vcpu))</blue>
			process_nmi(vcpu);
<blue>		if (kvm_check_request(KVM_REQ_PMU, vcpu))</blue>
			kvm_pmu_handle_event(vcpu);
<blue>		if (kvm_check_request(KVM_REQ_PMI, vcpu))</blue>
			kvm_pmu_deliver_pmi(vcpu);
<blue>		if (kvm_check_request(KVM_REQ_IOAPIC_EOI_EXIT, vcpu)) {</blue>
<yellow>			BUG_ON(vcpu->arch.pending_ioapic_eoi > 255);</yellow>
<yellow>			if (test_bit(vcpu->arch.pending_ioapic_eoi,</yellow>
				     vcpu-&gt;arch.ioapic_handled_vectors)) {
<yellow>				vcpu->run->exit_reason = KVM_EXIT_IOAPIC_EOI;</yellow>
				vcpu-&gt;run-&gt;eoi.vector =
						vcpu-&gt;arch.pending_ioapic_eoi;
				r = 0;
				goto out;
			}
		}
<blue>		if (kvm_check_request(KVM_REQ_SCAN_IOAPIC, vcpu))</blue>
<blue>			vcpu_scan_ioapic(vcpu);</blue>
<blue>		if (kvm_check_request(KVM_REQ_LOAD_EOI_EXITMAP, vcpu))</blue>
<blue>			vcpu_load_eoi_exitmap(vcpu);</blue>
<blue>		if (kvm_check_request(KVM_REQ_APIC_PAGE_RELOAD, vcpu))</blue>
<blue>			kvm_vcpu_reload_apic_access_page(vcpu);</blue>
<blue>		if (kvm_check_request(KVM_REQ_HV_CRASH, vcpu)) {</blue>
			vcpu-&gt;run-&gt;exit_reason = KVM_EXIT_SYSTEM_EVENT;
			vcpu-&gt;run-&gt;system_event.type = KVM_SYSTEM_EVENT_CRASH;
			vcpu-&gt;run-&gt;system_event.ndata = 0;
			r = 0;
			goto out;
		}
<blue>		if (kvm_check_request(KVM_REQ_HV_RESET, vcpu)) {</blue>
			vcpu-&gt;run-&gt;exit_reason = KVM_EXIT_SYSTEM_EVENT;
			vcpu-&gt;run-&gt;system_event.type = KVM_SYSTEM_EVENT_RESET;
			vcpu-&gt;run-&gt;system_event.ndata = 0;
			r = 0;
			goto out;
		}
<blue>		if (kvm_check_request(KVM_REQ_HV_EXIT, vcpu)) {</blue>
			struct kvm_vcpu_hv *hv_vcpu = to_hv_vcpu(vcpu);

			vcpu-&gt;run-&gt;exit_reason = KVM_EXIT_HYPERV;
			vcpu-&gt;run-&gt;hyperv = hv_vcpu-&gt;exit;
			r = 0;
			goto out;
		}

		/*
		 * KVM_REQ_HV_STIMER has to be processed after
		 * KVM_REQ_CLOCK_UPDATE, because Hyper-V SynIC timers
		 * depend on the guest clock being up-to-date
		 */
<blue>		if (kvm_check_request(KVM_REQ_HV_STIMER, vcpu))</blue>
			kvm_hv_process_stimers(vcpu);
<blue>		if (kvm_check_request(KVM_REQ_APICV_UPDATE, vcpu))</blue>
			kvm_vcpu_update_apicv(vcpu);
<blue>		if (kvm_check_request(KVM_REQ_APF_READY, vcpu))</blue>
			kvm_check_async_pf_completion(vcpu);
<blue>		if (kvm_check_request(KVM_REQ_MSR_FILTER_CHANGED, vcpu))</blue>
			static_call(kvm_x86_msr_filter_changed)(vcpu);

<blue>		if (kvm_check_request(KVM_REQ_UPDATE_CPU_DIRTY_LOGGING, vcpu))</blue>
			static_call(kvm_x86_update_cpu_dirty_logging)(vcpu);
	}

<blue>	if (kvm_check_request(KVM_REQ_EVENT, vcpu) || req_int_win ||</blue>
<blue>	    kvm_xen_has_interrupt(vcpu)) {</blue>
<blue>		++vcpu->stat.req_event;</blue>
		r = kvm_apic_accept_events(vcpu);
		if (r &lt; 0) {
			r = 0;
			goto out;
		}
<blue>		if (vcpu->arch.mp_state == KVM_MP_STATE_INIT_RECEIVED) {</blue>
			r = 1;
			goto out;
		}

<blue>		r = kvm_check_and_inject_events(vcpu, &req_immediate_exit);</blue>
		if (r &lt; 0) {
			r = 0;
			goto out;
		}
<blue>		if (req_int_win)</blue>
<yellow>			static_call(kvm_x86_enable_irq_window)(vcpu);</yellow>

<blue>		if (kvm_lapic_enabled(vcpu)) {</blue>
<blue>			update_cr8_intercept(vcpu);</blue>
			kvm_lapic_sync_to_vapic(vcpu);
		}
	}

<blue>	r = kvm_mmu_reload(vcpu);</blue>
	if (unlikely(r)) {
		goto cancel_injection;
	}

<blue>	preempt_disable();</blue>

	static_call(kvm_x86_prepare_switch_to_guest)(vcpu);

	/*
	 * Disable IRQs before setting IN_GUEST_MODE.  Posted interrupt
	 * IPI are then delayed after guest entry, which ensures that they
	 * result in virtual interrupt delivery.
	 */
	local_irq_disable();

	/* Store vcpu-&gt;apicv_active before vcpu-&gt;mode.  */
	smp_store_release(&amp;vcpu-&gt;mode, IN_GUEST_MODE);

<blue>	kvm_vcpu_srcu_read_unlock(vcpu);</blue>

	/*
	 * 1) We should set -&gt;mode before checking -&gt;requests.  Please see
	 * the comment in kvm_vcpu_exiting_guest_mode().
	 *
	 * 2) For APICv, we should set -&gt;mode before checking PID.ON. This
	 * pairs with the memory barrier implicit in pi_test_and_set_on
	 * (see vmx_deliver_posted_interrupt).
	 *
	 * 3) This also orders the write to mode from any reads to the page
	 * tables done while the VCPU is running.  Please see the comment
	 * in kvm_flush_remote_tlbs.
	 */
	smp_mb__after_srcu_read_unlock();

	/*
	 * Process pending posted interrupts to handle the case where the
	 * notification IRQ arrived in the host, or was never sent (because the
	 * target vCPU wasn&#x27;t running).  Do this regardless of the vCPU&#x27;s APICv
	 * status, KVM doesn&#x27;t update assigned devices when APICv is inhibited,
	 * i.e. they can post interrupts even if APICv is temporarily disabled.
	 */
<blue>	if (kvm_lapic_enabled(vcpu))</blue>
<blue>		static_call_cond(kvm_x86_sync_pir_to_irr)(vcpu);</blue>

<blue>	if (kvm_vcpu_exit_request(vcpu)) {</blue>
<blue>		vcpu->mode = OUTSIDE_GUEST_MODE;</blue>
		smp_wmb();
		local_irq_enable();
<blue>		preempt_enable();</blue>
<blue>		kvm_vcpu_srcu_read_lock(vcpu);</blue>
		r = 1;
		goto cancel_injection;
	}

<blue>	if (req_immediate_exit) {</blue>
<blue>		kvm_make_request(KVM_REQ_EVENT, vcpu);</blue>
		static_call(kvm_x86_request_immediate_exit)(vcpu);
	}

<blue>	fpregs_assert_state_consistent();</blue>
	if (test_thread_flag(TIF_NEED_FPU_LOAD))
<blue>		switch_fpu_return();</blue>

<blue>	if (vcpu->arch.guest_fpu.xfd_err)</blue>
<yellow>		wrmsrl(MSR_IA32_XFD_ERR, vcpu->arch.guest_fpu.xfd_err);</yellow>

<blue>	if (unlikely(vcpu->arch.switch_db_regs)) {</blue>
<blue>		set_debugreg(0, 7);</blue>
		set_debugreg(vcpu-&gt;arch.eff_db[0], 0);
		set_debugreg(vcpu-&gt;arch.eff_db[1], 1);
		set_debugreg(vcpu-&gt;arch.eff_db[2], 2);
		set_debugreg(vcpu-&gt;arch.eff_db[3], 3);
<blue>	} else if (unlikely(hw_breakpoint_active())) {</blue>
<yellow>		set_debugreg(0, 7);</yellow>
	}

<blue>	guest_timing_enter_irqoff();</blue>

	for (;;) {
		/*
		 * Assert that vCPU vs. VM APICv state is consistent.  An APICv
		 * update must kick and wait for all vCPUs before toggling the
		 * per-VM state, and responsing vCPUs must wait for the update
		 * to complete before servicing KVM_REQ_APICV_UPDATE.
		 */
<blue>		WARN_ON_ONCE((kvm_vcpu_apicv_activated(vcpu) != kvm_vcpu_apicv_active(vcpu)) &&</blue>
			     (kvm_get_apic_mode(vcpu) != LAPIC_MODE_DISABLED));

<blue>		exit_fastpath = static_call(kvm_x86_vcpu_run)(vcpu);</blue>
		if (likely(exit_fastpath != EXIT_FASTPATH_REENTER_GUEST))
			break;

<yellow>		if (kvm_lapic_enabled(vcpu))</yellow>
<yellow>			static_call_cond(kvm_x86_sync_pir_to_irr)(vcpu);</yellow>

<yellow>		if (unlikely(kvm_vcpu_exit_request(vcpu))) {</yellow>
			exit_fastpath = EXIT_FASTPATH_EXIT_HANDLED;
			break;
		}
	}

	/*
	 * Do this here before restoring debug registers on the host.  And
	 * since we do this before handling the vmexit, a DR access vmexit
	 * can (a) read the correct value of the debug registers, (b) set
	 * KVM_DEBUGREG_WONT_EXIT again.
	 */
<blue>	if (unlikely(vcpu->arch.switch_db_regs & KVM_DEBUGREG_WONT_EXIT)) {</blue>
<blue>		WARN_ON(vcpu->guest_debug & KVM_GUESTDBG_USE_HW_BP);</blue>
<blue>		static_call(kvm_x86_sync_dirty_debug_regs)(vcpu);</blue>
<blue>		kvm_update_dr0123(vcpu);</blue>
<blue>		kvm_update_dr7(vcpu);</blue>
	}

	/*
	 * If the guest has used debug registers, at least dr7
	 * will be disabled while returning to the host.
	 * If we don&#x27;t have active breakpoints in the host, we don&#x27;t
	 * care about the messed up debug address registers. But if
	 * we have some of them active, restore the old state.
	 */
<blue>	if (hw_breakpoint_active())</blue>
<yellow>		hw_breakpoint_restore();</yellow>

<blue>	vcpu->arch.last_vmentry_cpu = vcpu->cpu;</blue>
<blue>	vcpu->arch.last_guest_tsc = kvm_read_l1_tsc(vcpu, rdtsc());</blue>

	vcpu-&gt;mode = OUTSIDE_GUEST_MODE;
	smp_wmb();

	/*
	 * Sync xfd before calling handle_exit_irqoff() which may
	 * rely on the fact that guest_fpu::xfd is up-to-date (e.g.
	 * in #NM irqoff handler).
	 */
<blue>	if (vcpu->arch.xfd_no_write_intercept)</blue>
<yellow>		fpu_sync_guest_vmexit_xfd_state();</yellow>

<blue>	static_call(kvm_x86_handle_exit_irqoff)(vcpu);</blue>

	if (vcpu-&gt;arch.guest_fpu.xfd_err)
<yellow>		wrmsrl(MSR_IA32_XFD_ERR, 0);</yellow>

	/*
	 * Consume any pending interrupts, including the possible source of
	 * VM-Exit on SVM and any ticks that occur between VM-Exit and now.
	 * An instruction is required after local_irq_enable() to fully unblock
	 * interrupts on processors that implement an interrupt shadow, the
	 * stat.exits increment will do nicely.
	 */
<blue>	kvm_before_interrupt(vcpu, KVM_HANDLING_IRQ);</blue>
	local_irq_enable();
	++vcpu-&gt;stat.exits;
	local_irq_disable();
	kvm_after_interrupt(vcpu);

	/*
	 * Wait until after servicing IRQs to account guest time so that any
	 * ticks that occurred while running the guest are properly accounted
	 * to the guest.  Waiting until IRQs are enabled degrades the accuracy
	 * of accounting via context tracking, but the loss of accuracy is
	 * acceptable for all known use cases.
	 */
	guest_timing_exit_irqoff();

	local_irq_enable();
<blue>	preempt_enable();</blue>

<blue>	kvm_vcpu_srcu_read_lock(vcpu);</blue>

	/*
	 * Profile KVM exit RIPs:
	 */
	if (unlikely(prof_on == KVM_PROFILING)) {
<yellow>		unsigned long rip = kvm_rip_read(vcpu);</yellow>
<yellow>		profile_hit(KVM_PROFILING, (void *)rip);</yellow>
	}

<blue>	if (unlikely(vcpu->arch.tsc_always_catchup))</blue>
<yellow>		kvm_make_request(KVM_REQ_CLOCK_UPDATE, vcpu);</yellow>

<blue>	if (vcpu->arch.apic_attention)</blue>
<yellow>		kvm_lapic_sync_from_vapic(vcpu);</yellow>

<blue>	r = static_call(kvm_x86_handle_exit)(vcpu, exit_fastpath);</blue>
	return r;

cancel_injection:
<blue>	if (req_immediate_exit)</blue>
<blue>		kvm_make_request(KVM_REQ_EVENT, vcpu);</blue>
<blue>	static_call(kvm_x86_cancel_injection)(vcpu);</blue>
	if (unlikely(vcpu-&gt;arch.apic_attention))
<yellow>		kvm_lapic_sync_from_vapic(vcpu);</yellow>
out:
	return r;
}

/* Called within kvm-&gt;srcu read side.  */
static inline int vcpu_block(struct kvm_vcpu *vcpu)
{
	bool hv_timer;

<blue>	if (!kvm_arch_vcpu_runnable(vcpu)) {</blue>
		/*
		 * Switch to the software timer before halt-polling/blocking as
		 * the guest&#x27;s timer may be a break event for the vCPU, and the
		 * hypervisor timer runs only when the CPU is in guest mode.
		 * Switch before halt-polling so that KVM recognizes an expired
		 * timer before blocking.
		 */
<blue>		hv_timer = kvm_lapic_hv_timer_in_use(vcpu);</blue>
		if (hv_timer)
<yellow>			kvm_lapic_switch_to_sw_timer(vcpu);</yellow>

<blue>		kvm_vcpu_srcu_read_unlock(vcpu);</blue>
		if (vcpu-&gt;arch.mp_state == KVM_MP_STATE_HALTED)
<blue>			kvm_vcpu_halt(vcpu);</blue>
		else
<blue>			kvm_vcpu_block(vcpu);</blue>
<blue>		kvm_vcpu_srcu_read_lock(vcpu);</blue>

		if (hv_timer)
<yellow>			kvm_lapic_switch_to_hv_timer(vcpu);</yellow>

		/*
		 * If the vCPU is not runnable, a signal or another host event
		 * of some kind is pending; service it without changing the
		 * vCPU&#x27;s activity state.
		 */
<blue>		if (!kvm_arch_vcpu_runnable(vcpu))</blue>
			return 1;
	}

	/*
	 * Evaluate nested events before exiting the halted state.  This allows
	 * the halt state to be recorded properly in the VMCS12&#x27;s activity
	 * state field (AMD does not have a similar field and a VM-Exit always
	 * causes a spurious wakeup from HLT).
	 */
<blue>	if (is_guest_mode(vcpu)) {</blue>
<blue>		if (kvm_check_nested_events(vcpu) < 0)</blue>
			return 0;
	}

<blue>	if (kvm_apic_accept_events(vcpu) < 0)</blue>
		return 0;
<blue>	switch(vcpu->arch.mp_state) {</blue>
	case KVM_MP_STATE_HALTED:
	case KVM_MP_STATE_AP_RESET_HOLD:
<blue>		vcpu->arch.pv.pv_unhalted = false;</blue>
		vcpu-&gt;arch.mp_state =
			KVM_MP_STATE_RUNNABLE;
		fallthrough;
	case KVM_MP_STATE_RUNNABLE:
<blue>		vcpu->arch.apf.halted = false;</blue>
		break;
	case KVM_MP_STATE_INIT_RECEIVED:
		break;
	default:
<yellow>		WARN_ON_ONCE(1);</yellow>
		break;
	}
	return 1;
}

static inline bool kvm_vcpu_running(struct kvm_vcpu *vcpu)
{
<blue>	return (vcpu->arch.mp_state == KVM_MP_STATE_RUNNABLE &&</blue>
<blue>		!vcpu->arch.apf.halted);</blue>
}

/* Called within kvm-&gt;srcu read side.  */
static int vcpu_run(struct kvm_vcpu *vcpu)
{
	int r;

<blue>	vcpu->arch.l1tf_flush_l1d = true;</blue>

	for (;;) {
		/*
		 * If another guest vCPU requests a PV TLB flush in the middle
		 * of instruction emulation, the rest of the emulation could
		 * use a stale page translation. Assume that any code after
		 * this point can start executing an instruction.
		 */
<blue>		vcpu->arch.at_instruction_boundary = false;</blue>
<blue>		if (kvm_vcpu_running(vcpu)) {</blue>
<blue>			r = vcpu_enter_guest(vcpu);</blue>
		} else {
<blue>			r = vcpu_block(vcpu);</blue>
		}

		if (r &lt;= 0)
			break;

<blue>		kvm_clear_request(KVM_REQ_UNBLOCK, vcpu);</blue>
<yellow>		if (kvm_xen_has_pending_events(vcpu))</yellow>
<yellow>			kvm_xen_inject_pending_events(vcpu);</yellow>

<blue>		if (kvm_cpu_has_pending_timer(vcpu))</blue>
<yellow>			kvm_inject_pending_timer_irqs(vcpu);</yellow>

<blue>		if (dm_request_for_irq_injection(vcpu) &&</blue>
<yellow>			kvm_vcpu_ready_for_interrupt_injection(vcpu)) {</yellow>
			r = 0;
<yellow>			vcpu->run->exit_reason = KVM_EXIT_IRQ_WINDOW_OPEN;</yellow>
			++vcpu-&gt;stat.request_irq_exits;
			break;
		}

<blue>		if (__xfer_to_guest_mode_work_pending()) {</blue>
<blue>			kvm_vcpu_srcu_read_unlock(vcpu);</blue>
			r = xfer_to_guest_mode_handle_work(vcpu);
			kvm_vcpu_srcu_read_lock(vcpu);
			if (r)
				return r;
		}
	}

	return r;
}

static inline int complete_emulated_io(struct kvm_vcpu *vcpu)
{
<blue>	return kvm_emulate_instruction(vcpu, EMULTYPE_NO_DECODE);</blue>
}

static int complete_emulated_pio(struct kvm_vcpu *vcpu)
{
<blue>	BUG_ON(!vcpu->arch.pio.count);</blue>

<blue>	return complete_emulated_io(vcpu);</blue>
}

/*
 * Implements the following, as a state machine:
 *
 * read:
 *   for each fragment
 *     for each mmio piece in the fragment
 *       write gpa, len
 *       exit
 *       copy data
 *   execute insn
 *
 * write:
 *   for each fragment
 *     for each mmio piece in the fragment
 *       write gpa, len
 *       copy data
 *       exit
 */
static int complete_emulated_mmio(struct kvm_vcpu *vcpu)
{
<blue>	struct kvm_run *run = vcpu->run;</blue>
	struct kvm_mmio_fragment *frag;
	unsigned len;

<yellow>	BUG_ON(!vcpu->mmio_needed);</yellow>

	/* Complete previous fragment */
<blue>	frag = &vcpu->mmio_fragments[vcpu->mmio_cur_fragment];</blue>
	len = min(8u, frag-&gt;len);
	if (!vcpu-&gt;mmio_is_write)
<blue>		memcpy(frag->data, run->mmio.data, len);</blue>

<blue>	if (frag->len <= 8) {</blue>
		/* Switch to the next fragment. */
		frag++;
<blue>		vcpu->mmio_cur_fragment++;</blue>
	} else {
		/* Go forward to the next mmio piece. */
<yellow>		frag->data += len;</yellow>
		frag-&gt;gpa += len;
		frag-&gt;len -= len;
	}

<blue>	if (vcpu->mmio_cur_fragment >= vcpu->mmio_nr_fragments) {</blue>
<blue>		vcpu->mmio_needed = 0;</blue>

		/* FIXME: return into emulator if single-stepping.  */
		if (vcpu-&gt;mmio_is_write)
			return 1;
<blue>		vcpu->mmio_read_completed = 1;</blue>
		return complete_emulated_io(vcpu);
	}

<blue>	run->exit_reason = KVM_EXIT_MMIO;</blue>
	run-&gt;mmio.phys_addr = frag-&gt;gpa;
	if (vcpu-&gt;mmio_is_write)
<blue>		memcpy(run->mmio.data, frag->data, min(8u, frag->len));</blue>
<blue>	run->mmio.len = min(8u, frag->len);</blue>
	run-&gt;mmio.is_write = vcpu-&gt;mmio_is_write;
	vcpu-&gt;arch.complete_userspace_io = complete_emulated_mmio;
	return 0;
<blue>}</blue>

/* Swap (qemu) user FPU context for the guest FPU context. */
static void kvm_load_guest_fpu(struct kvm_vcpu *vcpu)
{
	/* Exclude PKRU, it&#x27;s restored separately immediately after VM-Exit. */
<yellow>	fpu_swap_kvm_fpstate(&vcpu->arch.guest_fpu, true);</yellow>
<yellow>	trace_kvm_fpu(1);</yellow>
}

/* When vcpu_run ends, restore user space FPU context. */
static void kvm_put_guest_fpu(struct kvm_vcpu *vcpu)
{
<blue>	fpu_swap_kvm_fpstate(&vcpu->arch.guest_fpu, false);</blue>
	++vcpu-&gt;stat.fpu_reload;
<yellow>	trace_kvm_fpu(0);</yellow>
<blue>}</blue>

int kvm_arch_vcpu_ioctl_run(struct kvm_vcpu *vcpu)
{
	struct kvm_queued_exception *ex = &amp;vcpu-&gt;arch.exception;
<blue>	struct kvm_run *kvm_run = vcpu->run;</blue>
	int r;

	vcpu_load(vcpu);
	kvm_sigset_activate(vcpu);
	kvm_run-&gt;flags = 0;
<yellow>	kvm_load_guest_fpu(vcpu);</yellow>

<blue>	kvm_vcpu_srcu_read_lock(vcpu);</blue>
	if (unlikely(vcpu-&gt;arch.mp_state == KVM_MP_STATE_UNINITIALIZED)) {
<yellow>		if (kvm_run->immediate_exit) {</yellow>
			r = -EINTR;
			goto out;
		}
		/*
		 * It should be impossible for the hypervisor timer to be in
		 * use before KVM has ever run the vCPU.
		 */
<yellow>		WARN_ON_ONCE(kvm_lapic_hv_timer_in_use(vcpu));</yellow>

<yellow>		kvm_vcpu_srcu_read_unlock(vcpu);</yellow>
		kvm_vcpu_block(vcpu);
		kvm_vcpu_srcu_read_lock(vcpu);

		if (kvm_apic_accept_events(vcpu) &lt; 0) {
			r = 0;
			goto out;
		}
		r = -EAGAIN;
<yellow>		if (signal_pending(current)) {</yellow>
			r = -EINTR;
<yellow>			kvm_run->exit_reason = KVM_EXIT_INTR;</yellow>
			++vcpu-&gt;stat.signal_exits;
		}
		goto out;
	}

<blue>	if ((kvm_run->kvm_valid_regs & ~KVM_SYNC_X86_VALID_FIELDS) ||</blue>
<blue>	    (kvm_run->kvm_dirty_regs & ~KVM_SYNC_X86_VALID_FIELDS)) {</blue>
		r = -EINVAL;
		goto out;
	}

<blue>	if (kvm_run->kvm_dirty_regs) {</blue>
<yellow>		r = sync_regs(vcpu);</yellow>
		if (r != 0)
			goto out;
	}

	/* re-sync apic&#x27;s tpr */
<blue>	if (!lapic_in_kernel(vcpu)) {</blue>
<yellow>		if (kvm_set_cr8(vcpu, kvm_run->cr8) != 0) {</yellow>
			r = -EINVAL;
			goto out;
		}
	}

	/*
	 * If userspace set a pending exception and L2 is active, convert it to
	 * a pending VM-Exit if L1 wants to intercept the exception.
	 */
<blue>	if (vcpu->arch.exception_from_userspace && is_guest_mode(vcpu) &&</blue>
<yellow>	    kvm_x86_ops.nested_ops->is_exception_vmexit(vcpu, ex->vector,</yellow>
							ex-&gt;error_code)) {
<yellow>		kvm_queue_exception_vmexit(vcpu, ex->vector,</yellow>
					   ex-&gt;has_error_code, ex-&gt;error_code,
					   ex-&gt;has_payload, ex-&gt;payload);
		ex-&gt;injected = false;
		ex-&gt;pending = false;
	}
<blue>	vcpu->arch.exception_from_userspace = false;</blue>

	if (unlikely(vcpu-&gt;arch.complete_userspace_io)) {
		int (*cui)(struct kvm_vcpu *) = vcpu-&gt;arch.complete_userspace_io;
		vcpu-&gt;arch.complete_userspace_io = NULL;
<blue>		r = cui(vcpu);</blue>
		if (r &lt;= 0)
			goto out;
	} else {
<blue>		WARN_ON_ONCE(vcpu->arch.pio.count);</blue>
<blue>		WARN_ON_ONCE(vcpu->mmio_needed);</blue>
	}

<blue>	if (kvm_run->immediate_exit) {</blue>
		r = -EINTR;
		goto out;
	}

<blue>	r = static_call(kvm_x86_vcpu_pre_run)(vcpu);</blue>
	if (r &lt;= 0)
		goto out;

<blue>	r = vcpu_run(vcpu);</blue>

out:
<blue>	kvm_put_guest_fpu(vcpu);</blue>
	if (kvm_run-&gt;kvm_valid_regs)
<blue>		store_regs(vcpu);</blue>
<blue>	post_kvm_run_save(vcpu);</blue>
<blue>	kvm_vcpu_srcu_read_unlock(vcpu);</blue>

	kvm_sigset_deactivate(vcpu);
	vcpu_put(vcpu);
	return r;
}

static void __get_regs(struct kvm_vcpu *vcpu, struct kvm_regs *regs)
{
<blue>	if (vcpu->arch.emulate_regs_need_sync_to_vcpu) {</blue>
		/*
		 * We are here if userspace calls get_regs() in the middle of
		 * instruction emulation. Registers state needs to be copied
		 * back from emulation context to vcpu. Userspace shouldn&#x27;t do
		 * that usually, but some bad designed PV devices (vmware
		 * backdoor interface) need this to work
		 */
<blue>		emulator_writeback_register_cache(vcpu->arch.emulate_ctxt);</blue>
		vcpu-&gt;arch.emulate_regs_need_sync_to_vcpu = false;
	}
<blue>	regs->rax = kvm_rax_read(vcpu);</blue>
	regs-&gt;rbx = kvm_rbx_read(vcpu);
	regs-&gt;rcx = kvm_rcx_read(vcpu);
	regs-&gt;rdx = kvm_rdx_read(vcpu);
	regs-&gt;rsi = kvm_rsi_read(vcpu);
	regs-&gt;rdi = kvm_rdi_read(vcpu);
<blue>	regs->rsp = kvm_rsp_read(vcpu);</blue>
	regs-&gt;rbp = kvm_rbp_read(vcpu);
#ifdef CONFIG_X86_64
	regs-&gt;r8 = kvm_r8_read(vcpu);
	regs-&gt;r9 = kvm_r9_read(vcpu);
	regs-&gt;r10 = kvm_r10_read(vcpu);
	regs-&gt;r11 = kvm_r11_read(vcpu);
	regs-&gt;r12 = kvm_r12_read(vcpu);
	regs-&gt;r13 = kvm_r13_read(vcpu);
	regs-&gt;r14 = kvm_r14_read(vcpu);
	regs-&gt;r15 = kvm_r15_read(vcpu);
#endif

<blue>	regs->rip = kvm_rip_read(vcpu);</blue>
<blue>	regs->rflags = kvm_get_rflags(vcpu);</blue>
}

int kvm_arch_vcpu_ioctl_get_regs(struct kvm_vcpu *vcpu, struct kvm_regs *regs)
{
<blue>	vcpu_load(vcpu);</blue>
	__get_regs(vcpu, regs);
	vcpu_put(vcpu);
	return 0;
}

static void __set_regs(struct kvm_vcpu *vcpu, struct kvm_regs *regs)
{
<blue>	vcpu->arch.emulate_regs_need_sync_from_vcpu = true;</blue>
	vcpu-&gt;arch.emulate_regs_need_sync_to_vcpu = false;

	kvm_rax_write(vcpu, regs-&gt;rax);
	kvm_rbx_write(vcpu, regs-&gt;rbx);
	kvm_rcx_write(vcpu, regs-&gt;rcx);
	kvm_rdx_write(vcpu, regs-&gt;rdx);
	kvm_rsi_write(vcpu, regs-&gt;rsi);
	kvm_rdi_write(vcpu, regs-&gt;rdi);
	kvm_rsp_write(vcpu, regs-&gt;rsp);
	kvm_rbp_write(vcpu, regs-&gt;rbp);
#ifdef CONFIG_X86_64
	kvm_r8_write(vcpu, regs-&gt;r8);
	kvm_r9_write(vcpu, regs-&gt;r9);
	kvm_r10_write(vcpu, regs-&gt;r10);
	kvm_r11_write(vcpu, regs-&gt;r11);
	kvm_r12_write(vcpu, regs-&gt;r12);
	kvm_r13_write(vcpu, regs-&gt;r13);
	kvm_r14_write(vcpu, regs-&gt;r14);
	kvm_r15_write(vcpu, regs-&gt;r15);
#endif

	kvm_rip_write(vcpu, regs-&gt;rip);
	kvm_set_rflags(vcpu, regs-&gt;rflags | X86_EFLAGS_FIXED);

	vcpu-&gt;arch.exception.pending = false;
	vcpu-&gt;arch.exception_vmexit.pending = false;

	kvm_make_request(KVM_REQ_EVENT, vcpu);
}

int kvm_arch_vcpu_ioctl_set_regs(struct kvm_vcpu *vcpu, struct kvm_regs *regs)
{
<blue>	vcpu_load(vcpu);</blue>
	__set_regs(vcpu, regs);
	vcpu_put(vcpu);
	return 0;
}

static void __get_sregs_common(struct kvm_vcpu *vcpu, struct kvm_sregs *sregs)
{
	struct desc_ptr dt;

<blue>	if (vcpu->arch.guest_state_protected)</blue>
		goto skip_protected_regs;

<blue>	kvm_get_segment(vcpu, &sregs->cs, VCPU_SREG_CS);</blue>
	kvm_get_segment(vcpu, &amp;sregs-&gt;ds, VCPU_SREG_DS);
	kvm_get_segment(vcpu, &amp;sregs-&gt;es, VCPU_SREG_ES);
	kvm_get_segment(vcpu, &amp;sregs-&gt;fs, VCPU_SREG_FS);
	kvm_get_segment(vcpu, &amp;sregs-&gt;gs, VCPU_SREG_GS);
	kvm_get_segment(vcpu, &amp;sregs-&gt;ss, VCPU_SREG_SS);

	kvm_get_segment(vcpu, &amp;sregs-&gt;tr, VCPU_SREG_TR);
	kvm_get_segment(vcpu, &amp;sregs-&gt;ldt, VCPU_SREG_LDTR);

	static_call(kvm_x86_get_idt)(vcpu, &amp;dt);
	sregs-&gt;idt.limit = dt.size;
	sregs-&gt;idt.base = dt.address;
	static_call(kvm_x86_get_gdt)(vcpu, &amp;dt);
	sregs-&gt;gdt.limit = dt.size;
	sregs-&gt;gdt.base = dt.address;

	sregs-&gt;cr2 = vcpu-&gt;arch.cr2;
<blue>	sregs->cr3 = kvm_read_cr3(vcpu);</blue>

skip_protected_regs:
<blue>	sregs->cr0 = kvm_read_cr0(vcpu);</blue>
<blue>	sregs->cr4 = kvm_read_cr4(vcpu);</blue>
<blue>	sregs->cr8 = kvm_get_cr8(vcpu);</blue>
	sregs-&gt;efer = vcpu-&gt;arch.efer;
	sregs-&gt;apic_base = kvm_get_apic_base(vcpu);
}

<yellow>static void __get_sregs(struct kvm_vcpu *vcpu, struct kvm_sregs *sregs)</yellow>
{
<blue>	__get_sregs_common(vcpu, sregs);</blue>

<blue>	if (vcpu->arch.guest_state_protected)</blue>
		return;

<blue>	if (vcpu->arch.interrupt.injected && !vcpu->arch.interrupt.soft)</blue>
<yellow>		set_bit(vcpu->arch.interrupt.nr,</yellow>
			(unsigned long *)sregs-&gt;interrupt_bitmap);
<blue>}</blue>

static void __get_sregs2(struct kvm_vcpu *vcpu, struct kvm_sregs2 *sregs2)
{
	int i;

<blue>	__get_sregs_common(vcpu, (struct kvm_sregs *)sregs2);</blue>

<blue>	if (vcpu->arch.guest_state_protected)</blue>
		return;

<blue>	if (is_pae_paging(vcpu)) {</blue>
		for (i = 0 ; i &lt; 4 ; i++)
<yellow>			sregs2->pdptrs[i] = kvm_pdptr_read(vcpu, i);</yellow>
<yellow>		sregs2->flags |= KVM_SREGS2_FLAGS_PDPTRS_VALID;</yellow>
	}
}

int kvm_arch_vcpu_ioctl_get_sregs(struct kvm_vcpu *vcpu,
				  struct kvm_sregs *sregs)
{
<blue>	vcpu_load(vcpu);</blue>
	__get_sregs(vcpu, sregs);
	vcpu_put(vcpu);
	return 0;
}

int kvm_arch_vcpu_ioctl_get_mpstate(struct kvm_vcpu *vcpu,
				    struct kvm_mp_state *mp_state)
{
	int r;

<blue>	vcpu_load(vcpu);</blue>
	if (kvm_mpx_supported())
<yellow>		kvm_load_guest_fpu(vcpu);</yellow>

<blue>	r = kvm_apic_accept_events(vcpu);</blue>
	if (r &lt; 0)
		goto out;
	r = 0;

<blue>	if ((vcpu->arch.mp_state == KVM_MP_STATE_HALTED ||</blue>
<yellow>	     vcpu->arch.mp_state == KVM_MP_STATE_AP_RESET_HOLD) &&</yellow>
<yellow>	    vcpu->arch.pv.pv_unhalted)</yellow>
<yellow>		mp_state->mp_state = KVM_MP_STATE_RUNNABLE;</yellow>
	else
<blue>		mp_state->mp_state = vcpu->arch.mp_state;</blue>

out:
<blue>	if (kvm_mpx_supported())</blue>
<yellow>		kvm_put_guest_fpu(vcpu);</yellow>
<blue>	vcpu_put(vcpu);</blue>
	return r;
}

int kvm_arch_vcpu_ioctl_set_mpstate(struct kvm_vcpu *vcpu,
				    struct kvm_mp_state *mp_state)
{
	int ret = -EINVAL;

<blue>	vcpu_load(vcpu);</blue>

	switch (mp_state-&gt;mp_state) {
	case KVM_MP_STATE_UNINITIALIZED:
	case KVM_MP_STATE_HALTED:
	case KVM_MP_STATE_AP_RESET_HOLD:
	case KVM_MP_STATE_INIT_RECEIVED:
	case KVM_MP_STATE_SIPI_RECEIVED:
<yellow>		if (!lapic_in_kernel(vcpu))</yellow>
			goto out;
		break;

	case KVM_MP_STATE_RUNNABLE:
		break;

	default:
		goto out;
	}

	/*
	 * Pending INITs are reported using KVM_SET_VCPU_EVENTS, disallow
	 * forcing the guest into INIT/SIPI if those events are supposed to be
	 * blocked.  KVM prioritizes SMI over INIT, so reject INIT/SIPI state
	 * if an SMI is pending as well.
	 */
<blue>	if ((!kvm_apic_init_sipi_allowed(vcpu) || vcpu->arch.smi_pending) &&</blue>
<blue>	    (mp_state->mp_state == KVM_MP_STATE_SIPI_RECEIVED ||</blue>
	     mp_state-&gt;mp_state == KVM_MP_STATE_INIT_RECEIVED))
		goto out;

<blue>	if (mp_state->mp_state == KVM_MP_STATE_SIPI_RECEIVED) {</blue>
<yellow>		vcpu->arch.mp_state = KVM_MP_STATE_INIT_RECEIVED;</yellow>
		set_bit(KVM_APIC_SIPI, &amp;vcpu-&gt;arch.apic-&gt;pending_events);
	} else
<blue>		vcpu->arch.mp_state = mp_state->mp_state;</blue>
<blue>	kvm_make_request(KVM_REQ_EVENT, vcpu);</blue>

	ret = 0;
out:
<blue>	vcpu_put(vcpu);</blue>
	return ret;
}

int kvm_task_switch(struct kvm_vcpu *vcpu, u16 tss_selector, int idt_index,
		    int reason, bool has_error_code, u32 error_code)
{
<yellow>	struct x86_emulate_ctxt *ctxt = vcpu->arch.emulate_ctxt;</yellow>
	int ret;

	init_emulate_ctxt(vcpu);

	ret = emulator_task_switch(ctxt, tss_selector, idt_index, reason,
				   has_error_code, error_code);
	if (ret) {
<yellow>		vcpu->run->exit_reason = KVM_EXIT_INTERNAL_ERROR;</yellow>
		vcpu-&gt;run-&gt;internal.suberror = KVM_INTERNAL_ERROR_EMULATION;
		vcpu-&gt;run-&gt;internal.ndata = 0;
		return 0;
	}

<yellow>	kvm_rip_write(vcpu, ctxt->eip);</yellow>
	kvm_set_rflags(vcpu, ctxt-&gt;eflags);
	return 1;
<yellow>}</yellow>
EXPORT_SYMBOL_GPL(kvm_task_switch);

static bool kvm_is_valid_sregs(struct kvm_vcpu *vcpu, struct kvm_sregs *sregs)
{
<blue>	if ((sregs->efer & EFER_LME) && (sregs->cr0 & X86_CR0_PG)) {</blue>
		/*
		 * When EFER.LME and CR0.PG are set, the processor is in
		 * 64-bit mode (though maybe in a 32-bit code segment).
		 * CR4.PAE and EFER.LMA must be set.
		 */
<blue>		if (!(sregs->cr4 & X86_CR4_PAE) || !(sregs->efer & EFER_LMA))</blue>
			return false;
<blue>		if (kvm_vcpu_is_illegal_gpa(vcpu, sregs->cr3))</blue>
			return false;
	} else {
		/*
		 * Not in 64-bit mode: EFER.LMA is clear and the code
		 * segment cannot be 64-bit.
		 */
<blue>		if (sregs->efer & EFER_LMA || sregs->cs.l)</blue>
			return false;
	}

<blue>	return kvm_is_valid_cr4(vcpu, sregs->cr4);</blue>
}

<blue>static int __set_sregs_common(struct kvm_vcpu *vcpu, struct kvm_sregs *sregs,</blue>
		int *mmu_reset_needed, bool update_pdptrs)
{
	struct msr_data apic_base_msr;
	int idx;
	struct desc_ptr dt;

<blue>	if (!kvm_is_valid_sregs(vcpu, sregs))</blue>
		return -EINVAL;

<blue>	apic_base_msr.data = sregs->apic_base;</blue>
	apic_base_msr.host_initiated = true;
	if (kvm_set_apic_base(vcpu, &amp;apic_base_msr))
		return -EINVAL;

<blue>	if (vcpu->arch.guest_state_protected)</blue>
		return 0;

<blue>	dt.size = sregs->idt.limit;</blue>
	dt.address = sregs-&gt;idt.base;
	static_call(kvm_x86_set_idt)(vcpu, &amp;dt);
	dt.size = sregs-&gt;gdt.limit;
	dt.address = sregs-&gt;gdt.base;
	static_call(kvm_x86_set_gdt)(vcpu, &amp;dt);

	vcpu-&gt;arch.cr2 = sregs-&gt;cr2;
<blue>	*mmu_reset_needed |= kvm_read_cr3(vcpu) != sregs->cr3;</blue>
	vcpu-&gt;arch.cr3 = sregs-&gt;cr3;
	kvm_register_mark_dirty(vcpu, VCPU_EXREG_CR3);
	static_call_cond(kvm_x86_post_set_cr3)(vcpu, sregs-&gt;cr3);

<blue>	kvm_set_cr8(vcpu, sregs->cr8);</blue>

<blue>	*mmu_reset_needed |= vcpu->arch.efer != sregs->efer;</blue>
	static_call(kvm_x86_set_efer)(vcpu, sregs-&gt;efer);

<blue>	*mmu_reset_needed |= kvm_read_cr0(vcpu) != sregs->cr0;</blue>
	static_call(kvm_x86_set_cr0)(vcpu, sregs-&gt;cr0);
	vcpu-&gt;arch.cr0 = sregs-&gt;cr0;

<blue>	*mmu_reset_needed |= kvm_read_cr4(vcpu) != sregs->cr4;</blue>
	static_call(kvm_x86_set_cr4)(vcpu, sregs-&gt;cr4);

	if (update_pdptrs) {
<blue>		idx = srcu_read_lock(&vcpu->kvm->srcu);</blue>
<blue>		if (is_pae_paging(vcpu)) {</blue>
<yellow>			load_pdptrs(vcpu, kvm_read_cr3(vcpu));</yellow>
			*mmu_reset_needed = 1;
		}
<blue>		srcu_read_unlock(&vcpu->kvm->srcu, idx);</blue>
	}

<blue>	kvm_set_segment(vcpu, &sregs->cs, VCPU_SREG_CS);</blue>
	kvm_set_segment(vcpu, &amp;sregs-&gt;ds, VCPU_SREG_DS);
	kvm_set_segment(vcpu, &amp;sregs-&gt;es, VCPU_SREG_ES);
	kvm_set_segment(vcpu, &amp;sregs-&gt;fs, VCPU_SREG_FS);
	kvm_set_segment(vcpu, &amp;sregs-&gt;gs, VCPU_SREG_GS);
	kvm_set_segment(vcpu, &amp;sregs-&gt;ss, VCPU_SREG_SS);

	kvm_set_segment(vcpu, &amp;sregs-&gt;tr, VCPU_SREG_TR);
	kvm_set_segment(vcpu, &amp;sregs-&gt;ldt, VCPU_SREG_LDTR);

	update_cr8_intercept(vcpu);

	/* Older userspace won&#x27;t unhalt the vcpu on reset. */
<blue>	if (kvm_vcpu_is_bsp(vcpu) && kvm_rip_read(vcpu) == 0xfff0 &&</blue>
<blue>	    sregs->cs.selector == 0xf000 && sregs->cs.base == 0xffff0000 &&</blue>
<blue>	    !is_protmode(vcpu))</blue>
<blue>		vcpu->arch.mp_state = KVM_MP_STATE_RUNNABLE;</blue>

	return 0;
}

<blue>static int __set_sregs(struct kvm_vcpu *vcpu, struct kvm_sregs *sregs)</blue>
<blue>{</blue>
	int pending_vec, max_bits;
	int mmu_reset_needed = 0;
<blue>	int ret = __set_sregs_common(vcpu, sregs, &mmu_reset_needed, true);</blue>

	if (ret)
		return ret;

<blue>	if (mmu_reset_needed)</blue>
<yellow>		kvm_mmu_reset_context(vcpu);</yellow>

	max_bits = KVM_NR_INTERRUPTS;
	pending_vec = find_first_bit(
<blue>		(const unsigned long *)sregs->interrupt_bitmap, max_bits);</blue>

	if (pending_vec &lt; max_bits) {
<yellow>		kvm_queue_interrupt(vcpu, pending_vec, false);</yellow>
<yellow>		pr_debug("Set back pending irq %d\n", pending_vec);</yellow>
<yellow>		kvm_make_request(KVM_REQ_EVENT, vcpu);</yellow>
	}
	return 0;
}

static int __set_sregs2(struct kvm_vcpu *vcpu, struct kvm_sregs2 *sregs2)
{
	int mmu_reset_needed = 0;
<blue>	bool valid_pdptrs = sregs2->flags & KVM_SREGS2_FLAGS_PDPTRS_VALID;</blue>
<blue>	bool pae = (sregs2->cr0 & X86_CR0_PG) && (sregs2->cr4 & X86_CR4_PAE) &&</blue>
<blue>		!(sregs2->efer & EFER_LMA);</blue>
	int i, ret;

<blue>	if (sregs2->flags & ~KVM_SREGS2_FLAGS_PDPTRS_VALID)</blue>
		return -EINVAL;

<yellow>	if (valid_pdptrs && (!pae || vcpu->arch.guest_state_protected))</yellow>
		return -EINVAL;

<blue>	ret = __set_sregs_common(vcpu, (struct kvm_sregs *)sregs2,</blue>
				 &amp;mmu_reset_needed, !valid_pdptrs);
	if (ret)
		return ret;

	if (valid_pdptrs) {
		for (i = 0; i &lt; 4 ; i++)
<yellow>			kvm_pdptr_write(vcpu, i, sregs2->pdptrs[i]);</yellow>

<yellow>		kvm_register_mark_dirty(vcpu, VCPU_EXREG_PDPTR);</yellow>
		mmu_reset_needed = 1;
		vcpu-&gt;arch.pdptrs_from_userspace = true;
	}
<blue>	if (mmu_reset_needed)</blue>
<yellow>		kvm_mmu_reset_context(vcpu);</yellow>
	return 0;
}

int kvm_arch_vcpu_ioctl_set_sregs(struct kvm_vcpu *vcpu,
				  struct kvm_sregs *sregs)
{
	int ret;

<blue>	vcpu_load(vcpu);</blue>
	ret = __set_sregs(vcpu, sregs);
	vcpu_put(vcpu);
	return ret;
}

static void kvm_arch_vcpu_guestdbg_update_apicv_inhibit(struct kvm *kvm)
{
	bool set = false;
	struct kvm_vcpu *vcpu;
	unsigned long i;

<yellow>	if (!enable_apicv)</yellow>
		return;

<yellow>	down_write(&kvm->arch.apicv_update_lock);</yellow>

<yellow>	kvm_for_each_vcpu(i, vcpu, kvm) {</yellow>
<yellow>		if (vcpu->guest_debug & KVM_GUESTDBG_BLOCKIRQ) {</yellow>
			set = true;
			break;
		}
	}
<yellow>	__kvm_set_or_clear_apicv_inhibit(kvm, APICV_INHIBIT_REASON_BLOCKIRQ, set);</yellow>
<yellow>	up_write(&kvm->arch.apicv_update_lock);</yellow>
}

int kvm_arch_vcpu_ioctl_set_guest_debug(struct kvm_vcpu *vcpu,
					struct kvm_guest_debug *dbg)
<yellow>{</yellow>
	unsigned long rflags;
	int i, r;

<yellow>	if (vcpu->arch.guest_state_protected)</yellow>
		return -EINVAL;

<yellow>	vcpu_load(vcpu);</yellow>

	if (dbg-&gt;control &amp; (KVM_GUESTDBG_INJECT_DB | KVM_GUESTDBG_INJECT_BP)) {
		r = -EBUSY;
<yellow>		if (kvm_is_exception_pending(vcpu))</yellow>
			goto out;
<yellow>		if (dbg->control & KVM_GUESTDBG_INJECT_DB)</yellow>
<yellow>			kvm_queue_exception(vcpu, DB_VECTOR);</yellow>
		else
<yellow>			kvm_queue_exception(vcpu, BP_VECTOR);</yellow>
	}

	/*
	 * Read rflags as long as potentially injected trace flags are still
	 * filtered out.
	 */
<yellow>	rflags = kvm_get_rflags(vcpu);</yellow>

<yellow>	vcpu->guest_debug = dbg->control;</yellow>
	if (!(vcpu-&gt;guest_debug &amp; KVM_GUESTDBG_ENABLE))
		vcpu-&gt;guest_debug = 0;

	if (vcpu-&gt;guest_debug &amp; KVM_GUESTDBG_USE_HW_BP) {
		for (i = 0; i &lt; KVM_NR_DB_REGS; ++i)
<yellow>			vcpu->arch.eff_db[i] = dbg->arch.debugreg[i];</yellow>
		vcpu-&gt;arch.guest_debug_dr7 = dbg-&gt;arch.debugreg[7];
	} else {
		for (i = 0; i &lt; KVM_NR_DB_REGS; i++)
<yellow>			vcpu->arch.eff_db[i] = vcpu->arch.db[i];</yellow>
	}
<yellow>	kvm_update_dr7(vcpu);</yellow>

<yellow>	if (vcpu->guest_debug & KVM_GUESTDBG_SINGLESTEP)</yellow>
<yellow>		vcpu->arch.singlestep_rip = kvm_get_linear_rip(vcpu);</yellow>

	/*
	 * Trigger an rflags update that will inject or remove the trace
	 * flags.
	 */
<yellow>	kvm_set_rflags(vcpu, rflags);</yellow>

	static_call(kvm_x86_update_exception_bitmap)(vcpu);

<yellow>	kvm_arch_vcpu_guestdbg_update_apicv_inhibit(vcpu->kvm);</yellow>

<yellow>	r = 0;</yellow>

out:
<yellow>	vcpu_put(vcpu);</yellow>
	return r;
<yellow>}</yellow>

/*
 * Translate a guest virtual address to a guest physical address.
 */
int kvm_arch_vcpu_ioctl_translate(struct kvm_vcpu *vcpu,
				    struct kvm_translation *tr)
{
<yellow>	unsigned long vaddr = tr->linear_address;</yellow>
	gpa_t gpa;
	int idx;

	vcpu_load(vcpu);

	idx = srcu_read_lock(&amp;vcpu-&gt;kvm-&gt;srcu);
	gpa = kvm_mmu_gva_to_gpa_system(vcpu, vaddr, NULL);
<yellow>	srcu_read_unlock(&vcpu->kvm->srcu, idx);</yellow>
	tr-&gt;physical_address = gpa;
	tr-&gt;valid = gpa != INVALID_GPA;
	tr-&gt;writeable = 1;
	tr-&gt;usermode = 0;

	vcpu_put(vcpu);
	return 0;
}

int kvm_arch_vcpu_ioctl_get_fpu(struct kvm_vcpu *vcpu, struct kvm_fpu *fpu)
{
	struct fxregs_state *fxsave;

<yellow>	if (fpstate_is_confidential(&vcpu->arch.guest_fpu))</yellow>
		return 0;

<yellow>	vcpu_load(vcpu);</yellow>

	fxsave = &amp;vcpu-&gt;arch.guest_fpu.fpstate-&gt;regs.fxsave;
	memcpy(fpu-&gt;fpr, fxsave-&gt;st_space, 128);
	fpu-&gt;fcw = fxsave-&gt;cwd;
	fpu-&gt;fsw = fxsave-&gt;swd;
	fpu-&gt;ftwx = fxsave-&gt;twd;
	fpu-&gt;last_opcode = fxsave-&gt;fop;
	fpu-&gt;last_ip = fxsave-&gt;rip;
	fpu-&gt;last_dp = fxsave-&gt;rdp;
	memcpy(fpu-&gt;xmm, fxsave-&gt;xmm_space, sizeof(fxsave-&gt;xmm_space));

	vcpu_put(vcpu);
	return 0;
<yellow>}</yellow>

int kvm_arch_vcpu_ioctl_set_fpu(struct kvm_vcpu *vcpu, struct kvm_fpu *fpu)
{
	struct fxregs_state *fxsave;

<yellow>	if (fpstate_is_confidential(&vcpu->arch.guest_fpu))</yellow>
		return 0;

<yellow>	vcpu_load(vcpu);</yellow>

	fxsave = &amp;vcpu-&gt;arch.guest_fpu.fpstate-&gt;regs.fxsave;

	memcpy(fxsave-&gt;st_space, fpu-&gt;fpr, 128);
	fxsave-&gt;cwd = fpu-&gt;fcw;
	fxsave-&gt;swd = fpu-&gt;fsw;
	fxsave-&gt;twd = fpu-&gt;ftwx;
	fxsave-&gt;fop = fpu-&gt;last_opcode;
	fxsave-&gt;rip = fpu-&gt;last_ip;
	fxsave-&gt;rdp = fpu-&gt;last_dp;
	memcpy(fxsave-&gt;xmm_space, fpu-&gt;xmm, sizeof(fxsave-&gt;xmm_space));

	vcpu_put(vcpu);
	return 0;
<yellow>}</yellow>

static void store_regs(struct kvm_vcpu *vcpu)
{
	BUILD_BUG_ON(sizeof(struct kvm_sync_regs) &gt; SYNC_REGS_SIZE_BYTES);

<blue>	if (vcpu->run->kvm_valid_regs & KVM_SYNC_X86_REGS)</blue>
<yellow>		__get_regs(vcpu, &vcpu->run->s.regs.regs);</yellow>

<yellow>	if (vcpu->run->kvm_valid_regs & KVM_SYNC_X86_SREGS)</yellow>
<yellow>		__get_sregs(vcpu, &vcpu->run->s.regs.sregs);</yellow>

<yellow>	if (vcpu->run->kvm_valid_regs & KVM_SYNC_X86_EVENTS)</yellow>
<yellow>		kvm_vcpu_ioctl_x86_get_vcpu_events(</yellow>
				vcpu, &amp;vcpu-&gt;run-&gt;s.regs.events);
}

static int sync_regs(struct kvm_vcpu *vcpu)
{
<yellow>	if (vcpu->run->kvm_dirty_regs & KVM_SYNC_X86_REGS) {</yellow>
<yellow>		__set_regs(vcpu, &vcpu->run->s.regs.regs);</yellow>
		vcpu-&gt;run-&gt;kvm_dirty_regs &amp;= ~KVM_SYNC_X86_REGS;
	}
<yellow>	if (vcpu->run->kvm_dirty_regs & KVM_SYNC_X86_SREGS) {</yellow>
<yellow>		if (__set_sregs(vcpu, &vcpu->run->s.regs.sregs))</yellow>
			return -EINVAL;
<yellow>		vcpu->run->kvm_dirty_regs &= ~KVM_SYNC_X86_SREGS;</yellow>
	}
<yellow>	if (vcpu->run->kvm_dirty_regs & KVM_SYNC_X86_EVENTS) {</yellow>
<yellow>		if (kvm_vcpu_ioctl_x86_set_vcpu_events(</yellow>
				vcpu, &amp;vcpu-&gt;run-&gt;s.regs.events))
			return -EINVAL;
<yellow>		vcpu->run->kvm_dirty_regs &= ~KVM_SYNC_X86_EVENTS;</yellow>
	}

	return 0;
}

int kvm_arch_vcpu_precreate(struct kvm *kvm, unsigned int id)
{
<blue>	if (kvm_check_tsc_unstable() && kvm->created_vcpus)</blue>
<yellow>		pr_warn_once("kvm: SMP vm created on host with unstable TSC; "</yellow>
			     &quot;guest TSC will not be reliable\n&quot;);

<blue>	if (!kvm->arch.max_vcpu_ids)</blue>
<blue>		kvm->arch.max_vcpu_ids = KVM_MAX_VCPU_IDS;</blue>

<blue>	if (id >= kvm->arch.max_vcpu_ids)</blue>
		return -EINVAL;

<blue>	return static_call(kvm_x86_vcpu_precreate)(kvm);</blue>
<blue>}</blue>

int kvm_arch_vcpu_create(struct kvm_vcpu *vcpu)
{
	struct page *page;
	int r;

<blue>	vcpu->arch.last_vmentry_cpu = -1;</blue>
	vcpu-&gt;arch.regs_avail = ~0;
	vcpu-&gt;arch.regs_dirty = ~0;

	kvm_gpc_init(&amp;vcpu-&gt;arch.pv_time);

<blue>	if (!irqchip_in_kernel(vcpu->kvm) || kvm_vcpu_is_reset_bsp(vcpu))</blue>
<blue>		vcpu->arch.mp_state = KVM_MP_STATE_RUNNABLE;</blue>
	else
		vcpu-&gt;arch.mp_state = KVM_MP_STATE_UNINITIALIZED;

	r = kvm_mmu_create(vcpu);
	if (r &lt; 0)
		return r;

<blue>	if (irqchip_in_kernel(vcpu->kvm)) {</blue>
<blue>		r = kvm_create_lapic(vcpu, lapic_timer_advance_ns);</blue>
		if (r &lt; 0)
			goto fail_mmu_destroy;

		/*
		 * Defer evaluating inhibits until the vCPU is first run, as
		 * this vCPU will not get notified of any changes until this
		 * vCPU is visible to other vCPUs (marked online and added to
		 * the set of vCPUs).  Opportunistically mark APICv active as
		 * VMX in particularly is highly unlikely to have inhibits.
		 * Ignore the current per-VM APICv state so that vCPU creation
		 * is guaranteed to run with a deterministic value, the request
		 * will ensure the vCPU gets the correct state before VM-Entry.
		 */
<blue>		if (enable_apicv) {</blue>
<blue>			vcpu->arch.apic->apicv_active = true;</blue>
			kvm_make_request(KVM_REQ_APICV_UPDATE, vcpu);
		}
	} else
<yellow>		static_branch_inc(&kvm_has_noapic_vcpu);</yellow>

	r = -ENOMEM;

<blue>	page = alloc_page(GFP_KERNEL_ACCOUNT | __GFP_ZERO);</blue>
	if (!page)
		goto fail_free_lapic;
<blue>	vcpu->arch.pio_data = page_address(page);</blue>

	vcpu-&gt;arch.mce_banks = kcalloc(KVM_MAX_MCE_BANKS * 4, sizeof(u64),
				       GFP_KERNEL_ACCOUNT);
	vcpu-&gt;arch.mci_ctl2_banks = kcalloc(KVM_MAX_MCE_BANKS, sizeof(u64),
					    GFP_KERNEL_ACCOUNT);
<blue>	if (!vcpu->arch.mce_banks || !vcpu->arch.mci_ctl2_banks)</blue>
		goto fail_free_mce_banks;
<blue>	vcpu->arch.mcg_cap = KVM_MAX_MCE_BANKS;</blue>

	if (!zalloc_cpumask_var(&amp;vcpu-&gt;arch.wbinvd_dirty_mask,
				GFP_KERNEL_ACCOUNT))
		goto fail_free_mce_banks;

<blue>	if (!alloc_emulate_ctxt(vcpu))</blue>
		goto free_wbinvd_dirty_mask;

	if (!fpu_alloc_guest_fpstate(&amp;vcpu-&gt;arch.guest_fpu)) {
		pr_err(&quot;kvm: failed to allocate vcpu&#x27;s fpu\n&quot;);
		goto free_emulate_ctxt;
	}

<blue>	vcpu->arch.maxphyaddr = cpuid_query_maxphyaddr(vcpu);</blue>
	vcpu-&gt;arch.reserved_gpa_bits = kvm_vcpu_reserved_gpa_bits_raw(vcpu);

	vcpu-&gt;arch.pat = MSR_IA32_CR_PAT_DEFAULT;

<blue>	kvm_async_pf_hash_reset(vcpu);</blue>
<blue>	kvm_pmu_init(vcpu);</blue>

	vcpu-&gt;arch.pending_external_vector = -1;
	vcpu-&gt;arch.preempted_in_kernel = false;

#if IS_ENABLED(CONFIG_HYPERV)
	vcpu-&gt;arch.hv_root_tdp = INVALID_PAGE;
#endif

	r = static_call(kvm_x86_vcpu_create)(vcpu);
	if (r)
		goto free_guest_fpu;

<blue>	vcpu->arch.arch_capabilities = kvm_get_arch_capabilities();</blue>
	vcpu-&gt;arch.msr_platform_info = MSR_PLATFORM_INFO_CPUID_FAULT;
	kvm_xen_init_vcpu(vcpu);
	kvm_vcpu_mtrr_init(vcpu);
	vcpu_load(vcpu);
	kvm_set_tsc_khz(vcpu, vcpu-&gt;kvm-&gt;arch.default_tsc_khz);
	kvm_vcpu_reset(vcpu, false);
	kvm_init_mmu(vcpu);
	vcpu_put(vcpu);
	return 0;

free_guest_fpu:
<yellow>	fpu_free_guest_fpstate(&vcpu->arch.guest_fpu);</yellow>
free_emulate_ctxt:
<yellow>	kmem_cache_free(x86_emulator_cache, vcpu->arch.emulate_ctxt);</yellow>
free_wbinvd_dirty_mask:
<yellow>	free_cpumask_var(vcpu->arch.wbinvd_dirty_mask);</yellow>
fail_free_mce_banks:
<yellow>	kfree(vcpu->arch.mce_banks);</yellow>
	kfree(vcpu-&gt;arch.mci_ctl2_banks);
	free_page((unsigned long)vcpu-&gt;arch.pio_data);
fail_free_lapic:
<yellow>	kvm_free_lapic(vcpu);</yellow>
fail_mmu_destroy:
<yellow>	kvm_mmu_destroy(vcpu);</yellow>
	return r;
<blue>}</blue>

void kvm_arch_vcpu_postcreate(struct kvm_vcpu *vcpu)
{
<blue>	struct kvm *kvm = vcpu->kvm;</blue>

	if (mutex_lock_killable(&amp;vcpu-&gt;mutex))
		return;
<blue>	vcpu_load(vcpu);</blue>
	kvm_synchronize_tsc(vcpu, 0);
	vcpu_put(vcpu);

	/* poll control enabled by default */
	vcpu-&gt;arch.msr_kvm_poll_control = 1;

	mutex_unlock(&amp;vcpu-&gt;mutex);

<blue>	if (kvmclock_periodic_sync && vcpu->vcpu_idx == 0)</blue>
<blue>		schedule_delayed_work(&kvm->arch.kvmclock_sync_work,</blue>
						KVMCLOCK_SYNC_PERIOD);
<blue>}</blue>

void kvm_arch_vcpu_destroy(struct kvm_vcpu *vcpu)
{
	int idx;

<yellow>	kvmclock_reset(vcpu);</yellow>

	static_call(kvm_x86_vcpu_free)(vcpu);

	kmem_cache_free(x86_emulator_cache, vcpu-&gt;arch.emulate_ctxt);
	free_cpumask_var(vcpu-&gt;arch.wbinvd_dirty_mask);
	fpu_free_guest_fpstate(&amp;vcpu-&gt;arch.guest_fpu);

	kvm_xen_destroy_vcpu(vcpu);
	kvm_hv_vcpu_uninit(vcpu);
	kvm_pmu_destroy(vcpu);
	kfree(vcpu-&gt;arch.mce_banks);
	kfree(vcpu-&gt;arch.mci_ctl2_banks);
	kvm_free_lapic(vcpu);
	idx = srcu_read_lock(&amp;vcpu-&gt;kvm-&gt;srcu);
	kvm_mmu_destroy(vcpu);
<yellow>	srcu_read_unlock(&vcpu->kvm->srcu, idx);</yellow>
	free_page((unsigned long)vcpu-&gt;arch.pio_data);
	kvfree(vcpu-&gt;arch.cpuid_entries);
<yellow>	if (!lapic_in_kernel(vcpu))</yellow>
<yellow>		static_branch_dec(&kvm_has_noapic_vcpu);</yellow>
<yellow>}</yellow>

void kvm_vcpu_reset(struct kvm_vcpu *vcpu, bool init_event)
<blue>{</blue>
	struct kvm_cpuid_entry2 *cpuid_0x1;
<blue>	unsigned long old_cr0 = kvm_read_cr0(vcpu);</blue>
	unsigned long new_cr0;

	/*
	 * Several of the &quot;set&quot; flows, e.g. -&gt;set_cr0(), read other registers
	 * to handle side effects.  RESET emulation hits those flows and relies
	 * on emulated/virtualized registers, including those that are loaded
	 * into hardware, to be zeroed at vCPU creation.  Use CRs as a sentinel
	 * to detect improper or missing initialization.
	 */
<blue>	WARN_ON_ONCE(!init_event &&</blue>
		     (old_cr0 || kvm_read_cr3(vcpu) || kvm_read_cr4(vcpu)));

	/*
	 * SVM doesn&#x27;t unconditionally VM-Exit on INIT and SHUTDOWN, thus it&#x27;s
	 * possible to INIT the vCPU while L2 is active.  Force the vCPU back
	 * into L1 as EFER.SVME is cleared on INIT (along with all other EFER
	 * bits), i.e. virtualization is disabled.
	 */
<blue>	if (is_guest_mode(vcpu))</blue>
<yellow>		kvm_leave_nested(vcpu);</yellow>

<blue>	kvm_lapic_reset(vcpu, init_event);</blue>

<yellow>	WARN_ON_ONCE(is_guest_mode(vcpu) || is_smm(vcpu));</yellow>
<blue>	vcpu->arch.hflags = 0;</blue>

	vcpu-&gt;arch.smi_pending = 0;
	vcpu-&gt;arch.smi_count = 0;
	atomic_set(&amp;vcpu-&gt;arch.nmi_queued, 0);
	vcpu-&gt;arch.nmi_pending = 0;
	vcpu-&gt;arch.nmi_injected = false;
	kvm_clear_interrupt_queue(vcpu);
	kvm_clear_exception_queue(vcpu);

	memset(vcpu-&gt;arch.db, 0, sizeof(vcpu-&gt;arch.db));
<blue>	kvm_update_dr0123(vcpu);</blue>
<yellow>	vcpu->arch.dr6 = DR6_ACTIVE_LOW;</yellow>
	vcpu-&gt;arch.dr7 = DR7_FIXED_1;
<yellow>	kvm_update_dr7(vcpu);</yellow>

<blue>	vcpu->arch.cr2 = 0;</blue>

	kvm_make_request(KVM_REQ_EVENT, vcpu);
	vcpu-&gt;arch.apf.msr_en_val = 0;
	vcpu-&gt;arch.apf.msr_int_val = 0;
	vcpu-&gt;arch.st.msr_val = 0;

	kvmclock_reset(vcpu);

	kvm_clear_async_pf_completion_queue(vcpu);
<blue>	kvm_async_pf_hash_reset(vcpu);</blue>
<blue>	vcpu->arch.apf.halted = false;</blue>

<blue>	if (vcpu->arch.guest_fpu.fpstate && kvm_mpx_supported()) {</blue>
		struct fpstate *fpstate = vcpu-&gt;arch.guest_fpu.fpstate;

		/*
		 * All paths that lead to INIT are required to load the guest&#x27;s
		 * FPU state (because most paths are buried in KVM_RUN).
		 */
<yellow>		if (init_event)</yellow>
<yellow>			kvm_put_guest_fpu(vcpu);</yellow>

<yellow>		fpstate_clear_xstate_component(fpstate, XFEATURE_BNDREGS);</yellow>
		fpstate_clear_xstate_component(fpstate, XFEATURE_BNDCSR);

		if (init_event)
<yellow>			kvm_load_guest_fpu(vcpu);</yellow>
	}

<blue>	if (!init_event) {</blue>
<blue>		kvm_pmu_reset(vcpu);</blue>
		vcpu-&gt;arch.smbase = 0x30000;

		vcpu-&gt;arch.msr_misc_features_enables = 0;
		vcpu-&gt;arch.ia32_misc_enable_msr = MSR_IA32_MISC_ENABLE_PEBS_UNAVAIL |
						  MSR_IA32_MISC_ENABLE_BTS_UNAVAIL;

<yellow>		__kvm_set_xcr(vcpu, 0, XFEATURE_MASK_FP);</yellow>
<blue>		__kvm_set_msr(vcpu, MSR_IA32_XSS, 0, true);</blue>
	}

	/* All GPRs except RDX (handled below) are zeroed on RESET/INIT. */
<blue>	memset(vcpu->arch.regs, 0, sizeof(vcpu->arch.regs));</blue>
	kvm_register_mark_dirty(vcpu, VCPU_REGS_RSP);

	/*
	 * Fall back to KVM&#x27;s default Family/Model/Stepping of 0x600 (P6/Athlon)
	 * if no CPUID match is found.  Note, it&#x27;s impossible to get a match at
	 * RESET since KVM emulates RESET before exposing the vCPU to userspace,
	 * i.e. it&#x27;s impossible for kvm_find_cpuid_entry() to find a valid entry
	 * on RESET.  But, go through the motions in case that&#x27;s ever remedied.
	 */
	cpuid_0x1 = kvm_find_cpuid_entry(vcpu, 1);
<blue>	kvm_rdx_write(vcpu, cpuid_0x1 ? cpuid_0x1->eax : 0x600);</blue>

	static_call(kvm_x86_vcpu_reset)(vcpu, init_event);

	kvm_set_rflags(vcpu, X86_EFLAGS_FIXED);
	kvm_rip_write(vcpu, 0xfff0);

	vcpu-&gt;arch.cr3 = 0;
	kvm_register_mark_dirty(vcpu, VCPU_EXREG_CR3);

	/*
	 * CR0.CD/NW are set on RESET, preserved on INIT.  Note, some versions
	 * of Intel&#x27;s SDM list CD/NW as being set on INIT, but they contradict
	 * (or qualify) that with a footnote stating that CD/NW are preserved.
	 */
	new_cr0 = X86_CR0_ET;
	if (init_event)
<yellow>		new_cr0 |= (old_cr0 & (X86_CR0_NW | X86_CR0_CD));</yellow>
	else
		new_cr0 |= X86_CR0_NW | X86_CR0_CD;

<blue>	static_call(kvm_x86_set_cr0)(vcpu, new_cr0);</blue>
	static_call(kvm_x86_set_cr4)(vcpu, 0);
	static_call(kvm_x86_set_efer)(vcpu, 0);
	static_call(kvm_x86_update_exception_bitmap)(vcpu);

	/*
	 * On the standard CR0/CR4/EFER modification paths, there are several
	 * complex conditions determining whether the MMU has to be reset and/or
	 * which PCIDs have to be flushed.  However, CR0.WP and the paging-related
	 * bits in CR4 and EFER are irrelevant if CR0.PG was &#x27;0&#x27;; and a reset+flush
	 * is needed anyway if CR0.PG was &#x27;1&#x27; (which can only happen for INIT, as
	 * CR0 will be &#x27;0&#x27; prior to RESET).  So we only need to check CR0.PG here.
	 */
	if (old_cr0 &amp; X86_CR0_PG) {
<yellow>		kvm_make_request(KVM_REQ_TLB_FLUSH_GUEST, vcpu);</yellow>
		kvm_mmu_reset_context(vcpu);
	}

	/*
	 * Intel&#x27;s SDM states that all TLB entries are flushed on INIT.  AMD&#x27;s
	 * APM states the TLBs are untouched by INIT, but it also states that
	 * the TLBs are flushed on &quot;External initialization of the processor.&quot;
	 * Flush the guest TLB regardless of vendor, there is no meaningful
	 * benefit in relying on the guest to flush the TLB immediately after
	 * INIT.  A spurious TLB flush is benign and likely negligible from a
	 * performance perspective.
	 */
	if (init_event)
<yellow>		kvm_make_request(KVM_REQ_TLB_FLUSH_GUEST, vcpu);</yellow>
}
EXPORT_SYMBOL_GPL(kvm_vcpu_reset);

void kvm_vcpu_deliver_sipi_vector(struct kvm_vcpu *vcpu, u8 vector)
{
	struct kvm_segment cs;

<yellow>	kvm_get_segment(vcpu, &cs, VCPU_SREG_CS);</yellow>
	cs.selector = vector &lt;&lt; 8;
	cs.base = vector &lt;&lt; 12;
	kvm_set_segment(vcpu, &amp;cs, VCPU_SREG_CS);
	kvm_rip_write(vcpu, 0);
}
EXPORT_SYMBOL_GPL(kvm_vcpu_deliver_sipi_vector);

int kvm_arch_hardware_enable(void)
<blue>{</blue>
	struct kvm *kvm;
	struct kvm_vcpu *vcpu;
	unsigned long i;
	int ret;
	u64 local_tsc;
	u64 max_tsc = 0;
	bool stable, backwards_tsc = false;

<blue>	kvm_user_return_msr_cpu_online();</blue>
<blue>	ret = static_call(kvm_x86_hardware_enable)();</blue>
	if (ret != 0)
		return ret;

<blue>	local_tsc = rdtsc();</blue>
<blue>	stable = !kvm_check_tsc_unstable();</blue>
<blue>	list_for_each_entry(kvm, &vm_list, vm_list) {</blue>
<yellow>		kvm_for_each_vcpu(i, vcpu, kvm) {</yellow>
<yellow>			if (!stable && vcpu->cpu == smp_processor_id())</yellow>
<yellow>				kvm_make_request(KVM_REQ_CLOCK_UPDATE, vcpu);</yellow>
<yellow>			if (stable && vcpu->arch.last_host_tsc > local_tsc) {</yellow>
				backwards_tsc = true;
<yellow>				if (vcpu->arch.last_host_tsc > max_tsc)</yellow>
					max_tsc = vcpu-&gt;arch.last_host_tsc;
			}
		}
	}

	/*
	 * Sometimes, even reliable TSCs go backwards.  This happens on
	 * platforms that reset TSC during suspend or hibernate actions, but
	 * maintain synchronization.  We must compensate.  Fortunately, we can
	 * detect that condition here, which happens early in CPU bringup,
	 * before any KVM threads can be running.  Unfortunately, we can&#x27;t
	 * bring the TSCs fully up to date with real time, as we aren&#x27;t yet far
	 * enough into CPU bringup that we know how much real time has actually
	 * elapsed; our helper function, ktime_get_boottime_ns() will be using boot
	 * variables that haven&#x27;t been updated yet.
	 *
	 * So we simply find the maximum observed TSC above, then record the
	 * adjustment to TSC in each VCPU.  When the VCPU later gets loaded,
	 * the adjustment will be applied.  Note that we accumulate
	 * adjustments, in case multiple suspend cycles happen before some VCPU
	 * gets a chance to run again.  In the event that no KVM threads get a
	 * chance to run, we will miss the entire elapsed period, as we&#x27;ll have
	 * reset last_host_tsc, so VCPUs will not have the TSC adjusted and may
	 * loose cycle time.  This isn&#x27;t too big a deal, since the loss will be
	 * uniform across all VCPUs (not to mention the scenario is extremely
	 * unlikely). It is possible that a second hibernate recovery happens
	 * much faster than a first, causing the observed TSC here to be
	 * smaller; this would require additional padding adjustment, which is
	 * why we set last_host_tsc to the local tsc observed here.
	 *
	 * N.B. - this code below runs only on platforms with reliable TSC,
	 * as that is the only way backwards_tsc is set above.  Also note
	 * that this runs for ALL vcpus, which is not a bug; all VCPUs should
	 * have the same delta_cyc adjustment applied if backwards_tsc
	 * is detected.  Note further, this adjustment is only done once,
	 * as we reset last_host_tsc on all VCPUs to stop this from being
	 * called multiple times (one for each physical CPU bringup).
	 *
	 * Platforms with unreliable TSCs don&#x27;t have to deal with this, they
	 * will be compensated by the logic in vcpu_load, which sets the TSC to
	 * catchup mode.  This will catchup all VCPUs to real time, but cannot
	 * guarantee that they stay in perfect synchronization.
	 */
<yellow>	if (backwards_tsc) {</yellow>
<yellow>		u64 delta_cyc = max_tsc - local_tsc;</yellow>
		list_for_each_entry(kvm, &amp;vm_list, vm_list) {
<yellow>			kvm->arch.backwards_tsc_observed = true;</yellow>
			kvm_for_each_vcpu(i, vcpu, kvm) {
<yellow>				vcpu->arch.tsc_offset_adjustment += delta_cyc;</yellow>
				vcpu-&gt;arch.last_host_tsc = local_tsc;
				kvm_make_request(KVM_REQ_MASTERCLOCK_UPDATE, vcpu);
			}

			/*
			 * We have to disable TSC offset matching.. if you were
			 * booting a VM while issuing an S4 host suspend....
			 * you may have some problem.  Solving this issue is
			 * left as an exercise to the reader.
			 */
<yellow>			kvm->arch.last_tsc_nsec = 0;</yellow>
			kvm-&gt;arch.last_tsc_write = 0;
		}

	}
	return 0;
}

void kvm_arch_hardware_disable(void)
{
<yellow>	static_call(kvm_x86_hardware_disable)();</yellow>
<yellow>	drop_user_return_notifiers();</yellow>
<yellow>}</yellow>

static inline void kvm_ops_update(struct kvm_x86_init_ops *ops)
{
<yellow>	memcpy(&kvm_x86_ops, ops->runtime_ops, sizeof(kvm_x86_ops));</yellow>

#define __KVM_X86_OP(func) \
	static_call_update(kvm_x86_##func, kvm_x86_ops.func);
#define KVM_X86_OP(func) \
	WARN_ON(!kvm_x86_ops.func); __KVM_X86_OP(func)
#define KVM_X86_OP_OPTIONAL __KVM_X86_OP
#define KVM_X86_OP_OPTIONAL_RET0(func) \
	static_call_update(kvm_x86_##func, (void *)kvm_x86_ops.func ? : \
					   (void *)__static_call_return0);
#include &lt;asm/kvm-x86-ops.h&gt;
#undef __KVM_X86_OP

	kvm_pmu_ops_update(ops-&gt;pmu_ops);
}

int kvm_arch_hardware_setup(void *opaque)
<yellow>{</yellow>
	struct kvm_x86_init_ops *ops = opaque;
	int r;

<yellow>	rdmsrl_safe(MSR_EFER, &host_efer);</yellow>

	if (boot_cpu_has(X86_FEATURE_XSAVES))
<yellow>		rdmsrl(MSR_IA32_XSS, host_xss);</yellow>

<yellow>	kvm_init_pmu_capability();</yellow>

<yellow>	r = ops->hardware_setup();</yellow>
	if (r != 0)
		return r;

<yellow>	kvm_ops_update(ops);</yellow>

	kvm_register_perf_callbacks(ops-&gt;handle_intel_pt_intr);

	if (!kvm_cpu_cap_has(X86_FEATURE_XSAVES))
<yellow>		kvm_caps.supported_xss = 0;</yellow>

#define __kvm_cpu_cap_has(UNUSED_, f) kvm_cpu_cap_has(f)
<yellow>	cr4_reserved_bits = __cr4_reserved_bits(__kvm_cpu_cap_has, UNUSED_);</yellow>
#undef __kvm_cpu_cap_has

<yellow>	if (kvm_caps.has_tsc_control) {</yellow>
		/*
		 * Make sure the user can only configure tsc_khz values that
		 * fit into a signed integer.
		 * A min value is not calculated because it will always
		 * be 1 on all machines.
		 */
<yellow>		u64 max = min(0x7fffffffULL,</yellow>
			      __scale_tsc(kvm_caps.max_tsc_scaling_ratio, tsc_khz));
		kvm_caps.max_guest_tsc_khz = max;
	}
<yellow>	kvm_caps.default_tsc_scaling_ratio = 1ULL << kvm_caps.tsc_scaling_ratio_frac_bits;</yellow>
<yellow>	kvm_init_msr_list();</yellow>
	return 0;
}

void kvm_arch_hardware_unsetup(void)
{
<yellow>	kvm_unregister_perf_callbacks();</yellow>

	static_call(kvm_x86_hardware_unsetup)();
}

int kvm_arch_check_processor_compat(void *opaque)
{
<yellow>	struct cpuinfo_x86 *c = &cpu_data(smp_processor_id());</yellow>
	struct kvm_x86_init_ops *ops = opaque;

<yellow>	WARN_ON(!irqs_disabled());</yellow>

<yellow>	if (__cr4_reserved_bits(cpu_has, c) !=</yellow>
<yellow>	    __cr4_reserved_bits(cpu_has, &boot_cpu_data))</yellow>
		return -EIO;

<yellow>	return ops->check_processor_compatibility();</yellow>
<yellow>}</yellow>

bool kvm_vcpu_is_reset_bsp(struct kvm_vcpu *vcpu)
{
<blue>	return vcpu->kvm->arch.bsp_vcpu_id == vcpu->vcpu_id;</blue>
}
EXPORT_SYMBOL_GPL(kvm_vcpu_is_reset_bsp);

bool kvm_vcpu_is_bsp(struct kvm_vcpu *vcpu)
{
<yellow>	return (vcpu->arch.apic_base & MSR_IA32_APICBASE_BSP) != 0;</yellow>
}

__read_mostly DEFINE_STATIC_KEY_FALSE(kvm_has_noapic_vcpu);
EXPORT_SYMBOL_GPL(kvm_has_noapic_vcpu);

void kvm_arch_sched_in(struct kvm_vcpu *vcpu, int cpu)
{
	struct kvm_pmu *pmu = vcpu_to_pmu(vcpu);

<blue>	vcpu->arch.l1tf_flush_l1d = true;</blue>
<blue>	if (pmu->version && unlikely(pmu->event_count)) {</blue>
<yellow>		pmu->need_cleanup = true;</yellow>
		kvm_make_request(KVM_REQ_PMU, vcpu);
	}
<blue>	static_call(kvm_x86_sched_in)(vcpu, cpu);</blue>
}

void kvm_arch_free_vm(struct kvm *kvm)
{
<yellow>	kfree(to_kvm_hv(kvm)->hv_pa_pg);</yellow>
	__kvm_arch_free_vm(kvm);
}


int kvm_arch_init_vm(struct kvm *kvm, unsigned long type)
{
	int ret;
	unsigned long flags;

<blue>	if (type)</blue>
		return -EINVAL;

<blue>	ret = kvm_page_track_init(kvm);</blue>
	if (ret)
		goto out;

<blue>	ret = kvm_mmu_init_vm(kvm);</blue>
	if (ret)
		goto out_page_track;

<blue>	ret = static_call(kvm_x86_vm_init)(kvm);</blue>
	if (ret)
		goto out_uninit_mmu;

<blue>	INIT_HLIST_HEAD(&kvm->arch.mask_notifier_list);</blue>
	INIT_LIST_HEAD(&amp;kvm-&gt;arch.assigned_dev_head);
	atomic_set(&amp;kvm-&gt;arch.noncoherent_dma_count, 0);

	/* Reserve bit 0 of irq_sources_bitmap for userspace irq source */
	set_bit(KVM_USERSPACE_IRQ_SOURCE_ID, &amp;kvm-&gt;arch.irq_sources_bitmap);
	/* Reserve bit 1 of irq_sources_bitmap for irqfd-resampler */
	set_bit(KVM_IRQFD_RESAMPLE_IRQ_SOURCE_ID,
		&amp;kvm-&gt;arch.irq_sources_bitmap);

	raw_spin_lock_init(&amp;kvm-&gt;arch.tsc_write_lock);
	mutex_init(&amp;kvm-&gt;arch.apic_map_lock);
	seqcount_raw_spinlock_init(&amp;kvm-&gt;arch.pvclock_sc, &amp;kvm-&gt;arch.tsc_write_lock);
	kvm-&gt;arch.kvmclock_offset = -get_kvmclock_base_ns();

	raw_spin_lock_irqsave(&amp;kvm-&gt;arch.tsc_write_lock, flags);
	pvclock_update_vm_gtod_copy(kvm);
	raw_spin_unlock_irqrestore(&amp;kvm-&gt;arch.tsc_write_lock, flags);

<blue>	kvm->arch.default_tsc_khz = max_tsc_khz ? : tsc_khz;</blue>
	kvm-&gt;arch.guest_can_read_msr_platform_info = true;
<blue>	kvm->arch.enable_pmu = enable_pmu;</blue>

#if IS_ENABLED(CONFIG_HYPERV)
	spin_lock_init(&amp;kvm-&gt;arch.hv_root_tdp_lock);
	kvm-&gt;arch.hv_root_tdp = INVALID_PAGE;
#endif

	INIT_DELAYED_WORK(&amp;kvm-&gt;arch.kvmclock_update_work, kvmclock_update_fn);
	INIT_DELAYED_WORK(&amp;kvm-&gt;arch.kvmclock_sync_work, kvmclock_sync_fn);

<blue>	kvm_apicv_init(kvm);</blue>
<blue>	kvm_hv_init_vm(kvm);</blue>
	kvm_xen_init_vm(kvm);

	return 0;

out_uninit_mmu:
<yellow>	kvm_mmu_uninit_vm(kvm);</yellow>
out_page_track:
<yellow>	kvm_page_track_cleanup(kvm);</yellow>
out:
	return ret;
<blue>}</blue>

int kvm_arch_post_init_vm(struct kvm *kvm)
{
<blue>	return kvm_mmu_post_init_vm(kvm);</blue>
}

static void kvm_unload_vcpu_mmu(struct kvm_vcpu *vcpu)
{
	vcpu_load(vcpu);
	kvm_mmu_unload(vcpu);
	vcpu_put(vcpu);
}

static void kvm_unload_vcpu_mmus(struct kvm *kvm)
{
	unsigned long i;
	struct kvm_vcpu *vcpu;

<yellow>	kvm_for_each_vcpu(i, vcpu, kvm) {</yellow>
<yellow>		kvm_clear_async_pf_completion_queue(vcpu);</yellow>
		kvm_unload_vcpu_mmu(vcpu);
	}
}

void kvm_arch_sync_events(struct kvm *kvm)
{
<yellow>	cancel_delayed_work_sync(&kvm->arch.kvmclock_sync_work);</yellow>
	cancel_delayed_work_sync(&amp;kvm-&gt;arch.kvmclock_update_work);
	kvm_free_pit(kvm);
}

/**
 * __x86_set_memory_region: Setup KVM internal memory slot
 *
 * @kvm: the kvm pointer to the VM.
 * @id: the slot ID to setup.
 * @gpa: the GPA to install the slot (unused when @size == 0).
 * @size: the size of the slot. Set to zero to uninstall a slot.
 *
 * This function helps to setup a KVM internal memory slot.  Specify
 * @size &gt; 0 to install a new slot, while @size == 0 to uninstall a
 * slot.  The return code can be one of the following:
 *
 *   HVA:           on success (uninstall will return a bogus HVA)
 *   -errno:        on error
 *
 * The caller should always use IS_ERR() to check the return value
 * before use.  Note, the KVM internal memory slots are guaranteed to
 * remain valid and unchanged until the VM is destroyed, i.e., the
 * GPA-&gt;HVA translation will not change.  However, the HVA is a user
 * address, i.e. its accessibility is not guaranteed, and must be
 * accessed via __copy_{to,from}_user().
 */
void __user * __x86_set_memory_region(struct kvm *kvm, int id, gpa_t gpa,
				      u32 size)
<blue>{</blue>
	int i, r;
	unsigned long hva, old_npages;
<blue>	struct kvm_memslots *slots = kvm_memslots(kvm);</blue>
	struct kvm_memory_slot *slot;

	/* Called with kvm-&gt;slots_lock held.  */
<yellow>	if (WARN_ON(id >= KVM_MEM_SLOTS_NUM))</yellow>
		return ERR_PTR_USR(-EINVAL);

<blue>	slot = id_to_memslot(slots, id);</blue>
<blue>	if (size) {</blue>
<yellow>		if (slot && slot->npages)</yellow>
			return ERR_PTR_USR(-EEXIST);

		/*
		 * MAP_SHARED to prevent internal slot pages from being moved
		 * by fork()/COW.
		 */
<blue>		hva = vm_mmap(NULL, 0, size, PROT_READ | PROT_WRITE,</blue>
			      MAP_SHARED | MAP_ANONYMOUS, 0);
		if (IS_ERR((void *)hva))
			return (void __user *)hva;
	} else {
<yellow>		if (!slot || !slot->npages)</yellow>
			return NULL;

		old_npages = slot-&gt;npages;
<yellow>		hva = slot->userspace_addr;</yellow>
	}

	for (i = 0; i &lt; KVM_ADDRESS_SPACE_NUM; i++) {
		struct kvm_userspace_memory_region m;

		m.slot = id | (i &lt;&lt; 16);
		m.flags = 0;
<blue>		m.guest_phys_addr = gpa;</blue>
		m.userspace_addr = hva;
		m.memory_size = size;
<blue>		r = __kvm_set_memory_region(kvm, &m);</blue>
		if (r &lt; 0)
<yellow>			return ERR_PTR_USR(r);</yellow>
	}

<blue>	if (!size)</blue>
<yellow>		vm_munmap(hva, old_npages * PAGE_SIZE);</yellow>

<blue>	return (void __user *)hva;</blue>
}
EXPORT_SYMBOL_GPL(__x86_set_memory_region);

void kvm_arch_pre_destroy_vm(struct kvm *kvm)
{
<yellow>	kvm_mmu_pre_destroy_vm(kvm);</yellow>
}

void kvm_arch_destroy_vm(struct kvm *kvm)
{
<yellow>	if (current->mm == kvm->mm) {</yellow>
		/*
		 * Free memory regions allocated on behalf of userspace,
		 * unless the memory map has changed due to process exit
		 * or fd copying.
		 */
<yellow>		mutex_lock(&kvm->slots_lock);</yellow>
		__x86_set_memory_region(kvm, APIC_ACCESS_PAGE_PRIVATE_MEMSLOT,
					0, 0);
		__x86_set_memory_region(kvm, IDENTITY_PAGETABLE_PRIVATE_MEMSLOT,
					0, 0);
		__x86_set_memory_region(kvm, TSS_PRIVATE_MEMSLOT, 0, 0);
		mutex_unlock(&amp;kvm-&gt;slots_lock);
	}
<yellow>	kvm_unload_vcpu_mmus(kvm);</yellow>
<yellow>	static_call_cond(kvm_x86_vm_destroy)(kvm);</yellow>
<yellow>	kvm_free_msr_filter(srcu_dereference_check(kvm->arch.msr_filter, &kvm->srcu, 1));</yellow>
<yellow>	kvm_pic_destroy(kvm);</yellow>
	kvm_ioapic_destroy(kvm);
	kvm_destroy_vcpus(kvm);
	kvfree(rcu_dereference_check(kvm-&gt;arch.apic_map, 1));
	kfree(srcu_dereference_check(kvm-&gt;arch.pmu_event_filter, &amp;kvm-&gt;srcu, 1));
	kvm_mmu_uninit_vm(kvm);
	kvm_page_track_cleanup(kvm);
	kvm_xen_destroy_vm(kvm);
	kvm_hv_destroy_vm(kvm);
}

static void memslot_rmap_free(struct kvm_memory_slot *slot)
{
	int i;

	for (i = 0; i &lt; KVM_NR_PAGE_SIZES; ++i) {
<blue>		kvfree(slot->arch.rmap[i]);</blue>
		slot-&gt;arch.rmap[i] = NULL;
	}
}

void kvm_arch_free_memslot(struct kvm *kvm, struct kvm_memory_slot *slot)
{
	int i;

<blue>	memslot_rmap_free(slot);</blue>

	for (i = 1; i &lt; KVM_NR_PAGE_SIZES; ++i) {
<blue>		kvfree(slot->arch.lpage_info[i - 1]);</blue>
		slot-&gt;arch.lpage_info[i - 1] = NULL;
	}

	kvm_page_track_free_memslot(slot);
}

int memslot_rmap_alloc(struct kvm_memory_slot *slot, unsigned long npages)
<blue>{</blue>
	const int sz = sizeof(*slot-&gt;arch.rmap[0]);
	int i;

<blue>	for (i = 0; i < KVM_NR_PAGE_SIZES; ++i) {</blue>
<blue>		int level = i + 1;</blue>
<blue>		int lpages = __kvm_mmu_slot_lpages(slot, npages, level);</blue>

		if (slot-&gt;arch.rmap[i])
			continue;

		slot-&gt;arch.rmap[i] = __vcalloc(lpages, sz, GFP_KERNEL_ACCOUNT);
		if (!slot-&gt;arch.rmap[i]) {
<yellow>			memslot_rmap_free(slot);</yellow>
			return -ENOMEM;
		}
	}

	return 0;
<blue>}</blue>

static int kvm_alloc_memslot_metadata(struct kvm *kvm,
				      struct kvm_memory_slot *slot)
{
<blue>	unsigned long npages = slot->npages;</blue>
	int i, r;

	/*
	 * Clear out the previous array pointers for the KVM_MR_MOVE case.  The
	 * old arrays will be freed by __kvm_set_memory_region() if installing
	 * the new memslot is successful.
	 */
	memset(&amp;slot-&gt;arch, 0, sizeof(slot-&gt;arch));

<blue>	if (kvm_memslots_have_rmaps(kvm)) {</blue>
<yellow>		r = memslot_rmap_alloc(slot, npages);</yellow>
<blue>		if (r)</blue>
			return r;
	}

<blue>	for (i = 1; i < KVM_NR_PAGE_SIZES; ++i) {</blue>
		struct kvm_lpage_info *linfo;
		unsigned long ugfn;
		int lpages;
<blue>		int level = i + 1;</blue>

		lpages = __kvm_mmu_slot_lpages(slot, npages, level);

		linfo = __vcalloc(lpages, sizeof(*linfo), GFP_KERNEL_ACCOUNT);
		if (!linfo)
			goto out_free;

<blue>		slot->arch.lpage_info[i - 1] = linfo;</blue>

		if (slot-&gt;base_gfn &amp; (KVM_PAGES_PER_HPAGE(level) - 1))
<blue>			linfo[0].disallow_lpage = 1;</blue>
<blue>		if ((slot->base_gfn + npages) & (KVM_PAGES_PER_HPAGE(level) - 1))</blue>
<blue>			linfo[lpages - 1].disallow_lpage = 1;</blue>
<blue>		ugfn = slot->userspace_addr >> PAGE_SHIFT;</blue>
		/*
		 * If the gfn and userspace address are not aligned wrt each
		 * other, disable large page support for this slot.
		 */
		if ((slot-&gt;base_gfn ^ ugfn) &amp; (KVM_PAGES_PER_HPAGE(level) - 1)) {
			unsigned long j;

<blue>			for (j = 0; j < lpages; ++j)</blue>
<blue>				linfo[j].disallow_lpage = 1;</blue>
		}
	}

<blue>	if (kvm_page_track_create_memslot(kvm, slot, npages))</blue>
		goto out_free;

	return 0;

out_free:
<yellow>	memslot_rmap_free(slot);</yellow>

	for (i = 1; i &lt; KVM_NR_PAGE_SIZES; ++i) {
<yellow>		kvfree(slot->arch.lpage_info[i - 1]);</yellow>
		slot-&gt;arch.lpage_info[i - 1] = NULL;
	}
	return -ENOMEM;
}

void kvm_arch_memslots_updated(struct kvm *kvm, u64 gen)
<blue>{</blue>
	struct kvm_vcpu *vcpu;
	unsigned long i;

	/*
	 * memslots-&gt;generation has been incremented.
	 * mmio generation may have reached its maximum value.
	 */
<blue>	kvm_mmu_invalidate_mmio_sptes(kvm, gen);</blue>

	/* Force re-initialization of steal_time cache */
	kvm_for_each_vcpu(i, vcpu, kvm)
<blue>		kvm_vcpu_kick(vcpu);</blue>
}

int kvm_arch_prepare_memory_region(struct kvm *kvm,
				   const struct kvm_memory_slot *old,
				   struct kvm_memory_slot *new,
				   enum kvm_mr_change change)
{
<blue>	if (change == KVM_MR_CREATE || change == KVM_MR_MOVE) {</blue>
<blue>		if ((new->base_gfn + new->npages - 1) > kvm_mmu_max_gfn())</blue>
			return -EINVAL;

<blue>		return kvm_alloc_memslot_metadata(kvm, new);</blue>
	}

<blue>	if (change == KVM_MR_FLAGS_ONLY)</blue>
<yellow>		memcpy(&new->arch, &old->arch, sizeof(old->arch));</yellow>
<blue>	else if (WARN_ON_ONCE(change != KVM_MR_DELETE))</blue>
		return -EIO;

	return 0;
<blue>}</blue>


static void kvm_mmu_update_cpu_dirty_logging(struct kvm *kvm, bool enable)
{
	struct kvm_arch *ka = &amp;kvm-&gt;arch;

<yellow>	if (!kvm_x86_ops.cpu_dirty_log_size)</yellow>
		return;

<yellow>	if ((enable && ++ka->cpu_dirty_logging_count == 1) ||</yellow>
<yellow>	    (!enable && --ka->cpu_dirty_logging_count == 0))</yellow>
<yellow>		kvm_make_all_cpus_request(kvm, KVM_REQ_UPDATE_CPU_DIRTY_LOGGING);</yellow>

<yellow>	WARN_ON_ONCE(ka->cpu_dirty_logging_count < 0);</yellow>
}

static void kvm_mmu_slot_apply_flags(struct kvm *kvm,
				     struct kvm_memory_slot *old,
				     const struct kvm_memory_slot *new,
				     enum kvm_mr_change change)
{
<blue>	u32 old_flags = old ? old->flags : 0;</blue>
<blue>	u32 new_flags = new ? new->flags : 0;</blue>
	bool log_dirty_pages = new_flags &amp; KVM_MEM_LOG_DIRTY_PAGES;

	/*
	 * Update CPU dirty logging if dirty logging is being toggled.  This
	 * applies to all operations.
	 */
<blue>	if ((old_flags ^ new_flags) & KVM_MEM_LOG_DIRTY_PAGES)</blue>
<yellow>		kvm_mmu_update_cpu_dirty_logging(kvm, log_dirty_pages);</yellow>

	/*
	 * Nothing more to do for RO slots (which can&#x27;t be dirtied and can&#x27;t be
	 * made writable) or CREATE/MOVE/DELETE of a slot.
	 *
	 * For a memslot with dirty logging disabled:
	 * CREATE:      No dirty mappings will already exist.
	 * MOVE/DELETE: The old mappings will already have been cleaned up by
	 *		kvm_arch_flush_shadow_memslot()
	 *
	 * For a memslot with dirty logging enabled:
	 * CREATE:      No shadow pages exist, thus nothing to write-protect
	 *		and no dirty bits to clear.
	 * MOVE/DELETE: The old mappings will already have been cleaned up by
	 *		kvm_arch_flush_shadow_memslot().
	 */
<blue>	if ((change != KVM_MR_FLAGS_ONLY) || (new_flags & KVM_MEM_READONLY))</blue>
		return;

	/*
	 * READONLY and non-flags changes were filtered out above, and the only
	 * other flag is LOG_DIRTY_PAGES, i.e. something is wrong if dirty
	 * logging isn&#x27;t being toggled on or off.
	 */
<yellow>	if (WARN_ON_ONCE(!((old_flags ^ new_flags) & KVM_MEM_LOG_DIRTY_PAGES)))</yellow>
		return;

<yellow>	if (!log_dirty_pages) {</yellow>
		/*
		 * Dirty logging tracks sptes in 4k granularity, meaning that
		 * large sptes have to be split.  If live migration succeeds,
		 * the guest in the source machine will be destroyed and large
		 * sptes will be created in the destination.  However, if the
		 * guest continues to run in the source machine (for example if
		 * live migration fails), small sptes will remain around and
		 * cause bad performance.
		 *
		 * Scan sptes if dirty logging has been stopped, dropping those
		 * which can be collapsed into a single large-page spte.  Later
		 * page faults will create the large-page sptes.
		 */
<yellow>		kvm_mmu_zap_collapsible_sptes(kvm, new);</yellow>
	} else {
		/*
		 * Initially-all-set does not require write protecting any page,
		 * because they&#x27;re all assumed to be dirty.
		 */
<yellow>		if (kvm_dirty_log_manual_protect_and_init_set(kvm))</yellow>
			return;

<yellow>		if (READ_ONCE(eager_page_split))</yellow>
<yellow>			kvm_mmu_slot_try_split_huge_pages(kvm, new, PG_LEVEL_4K);</yellow>

<yellow>		if (kvm_x86_ops.cpu_dirty_log_size) {</yellow>
<yellow>			kvm_mmu_slot_leaf_clear_dirty(kvm, new);</yellow>
			kvm_mmu_slot_remove_write_access(kvm, new, PG_LEVEL_2M);
		} else {
<yellow>			kvm_mmu_slot_remove_write_access(kvm, new, PG_LEVEL_4K);</yellow>
		}

		/*
		 * Unconditionally flush the TLBs after enabling dirty logging.
		 * A flush is almost always going to be necessary (see below),
		 * and unconditionally flushing allows the helpers to omit
		 * the subtly complex checks when removing write access.
		 *
		 * Do the flush outside of mmu_lock to reduce the amount of
		 * time mmu_lock is held.  Flushing after dropping mmu_lock is
		 * safe as KVM only needs to guarantee the slot is fully
		 * write-protected before returning to userspace, i.e. before
		 * userspace can consume the dirty status.
		 *
		 * Flushing outside of mmu_lock requires KVM to be careful when
		 * making decisions based on writable status of an SPTE, e.g. a
		 * !writable SPTE doesn&#x27;t guarantee a CPU can&#x27;t perform writes.
		 *
		 * Specifically, KVM also write-protects guest page tables to
		 * monitor changes when using shadow paging, and must guarantee
		 * no CPUs can write to those page before mmu_lock is dropped.
		 * Because CPUs may have stale TLB entries at this point, a
		 * !writable SPTE doesn&#x27;t guarantee CPUs can&#x27;t perform writes.
		 *
		 * KVM also allows making SPTES writable outside of mmu_lock,
		 * e.g. to allow dirty logging without taking mmu_lock.
		 *
		 * To handle these scenarios, KVM uses a separate software-only
		 * bit (MMU-writable) to track if a SPTE is !writable due to
		 * a guest page table being write-protected (KVM clears the
		 * MMU-writable flag when write-protecting for shadow paging).
		 *
		 * The use of MMU-writable is also the primary motivation for
		 * the unconditional flush.  Because KVM must guarantee that a
		 * CPU doesn&#x27;t contain stale, writable TLB entries for a
		 * !MMU-writable SPTE, KVM must flush if it encounters any
		 * MMU-writable SPTE regardless of whether the actual hardware
		 * writable bit was set.  I.e. KVM is almost guaranteed to need
		 * to flush, while unconditionally flushing allows the &quot;remove
		 * write access&quot; helpers to ignore MMU-writable entirely.
		 *
		 * See is_writable_pte() for more details (the case involving
		 * access-tracked SPTEs is particularly relevant).
		 */
<yellow>		kvm_arch_flush_remote_tlbs_memslot(kvm, new);</yellow>
	}
}

void kvm_arch_commit_memory_region(struct kvm *kvm,
				struct kvm_memory_slot *old,
				const struct kvm_memory_slot *new,
				enum kvm_mr_change change)
{
<blue>	if (!kvm->arch.n_requested_mmu_pages &&</blue>
	    (change == KVM_MR_CREATE || change == KVM_MR_DELETE)) {
		unsigned long nr_mmu_pages;

<blue>		nr_mmu_pages = kvm->nr_memslot_pages / KVM_MEMSLOT_PAGES_TO_MMU_PAGES_RATIO;</blue>
		nr_mmu_pages = max(nr_mmu_pages, KVM_MIN_ALLOC_MMU_PAGES);
		kvm_mmu_change_mmu_pages(kvm, nr_mmu_pages);
	}

<blue>	kvm_mmu_slot_apply_flags(kvm, old, new, change);</blue>

	/* Free the arrays associated with the old memslot. */
<blue>	if (change == KVM_MR_MOVE)</blue>
<yellow>		kvm_arch_free_memslot(kvm, old);</yellow>
<blue>}</blue>

void kvm_arch_flush_shadow_all(struct kvm *kvm)
{
<yellow>	kvm_mmu_zap_all(kvm);</yellow>
}

void kvm_arch_flush_shadow_memslot(struct kvm *kvm,
				   struct kvm_memory_slot *slot)
{
<blue>	kvm_page_track_flush_slot(kvm, slot);</blue>
}

static inline bool kvm_guest_apic_has_interrupt(struct kvm_vcpu *vcpu)
{
<blue>	return (is_guest_mode(vcpu) &&</blue>
<blue>		static_call(kvm_x86_guest_apic_has_interrupt)(vcpu));</blue>
}

static inline bool kvm_vcpu_has_events(struct kvm_vcpu *vcpu)
{
<blue>	if (!list_empty_careful(&vcpu->async_pf.done))</blue>
		return true;

<blue>	if (kvm_apic_has_pending_init_or_sipi(vcpu) &&</blue>
<yellow>	    kvm_apic_init_sipi_allowed(vcpu))</yellow>
		return true;

<blue>	if (vcpu->arch.pv.pv_unhalted)</blue>
		return true;

<blue>	if (kvm_is_exception_pending(vcpu))</blue>
		return true;

<blue>	if (kvm_test_request(KVM_REQ_NMI, vcpu) ||</blue>
<blue>	    (vcpu->arch.nmi_pending &&</blue>
<yellow>	     static_call(kvm_x86_nmi_allowed)(vcpu, false)))</yellow>
		return true;

<blue>	if (kvm_test_request(KVM_REQ_SMI, vcpu) ||</blue>
<blue>	    (vcpu->arch.smi_pending &&</blue>
<yellow>	     static_call(kvm_x86_smi_allowed)(vcpu, false)))</yellow>
		return true;

<blue>	if (kvm_arch_interrupt_allowed(vcpu) &&</blue>
<blue>	    (kvm_cpu_has_interrupt(vcpu) ||</blue>
<blue>	    kvm_guest_apic_has_interrupt(vcpu)))</blue>
		return true;

<blue>	if (kvm_hv_has_stimer_pending(vcpu))</blue>
		return true;

<blue>	if (is_guest_mode(vcpu) &&</blue>
<blue>	    kvm_x86_ops.nested_ops->has_events &&</blue>
<blue>	    kvm_x86_ops.nested_ops->has_events(vcpu))</blue>
		return true;

<blue>	if (kvm_xen_has_pending_events(vcpu))</blue>
		return true;

	return false;
<blue>}</blue>

<blue>int kvm_arch_vcpu_runnable(struct kvm_vcpu *vcpu)</blue>
{
<blue>	return kvm_vcpu_running(vcpu) || kvm_vcpu_has_events(vcpu);</blue>
<blue>}</blue>

<yellow>bool kvm_arch_dy_has_pending_interrupt(struct kvm_vcpu *vcpu)</yellow>
{
<yellow>	if (kvm_vcpu_apicv_active(vcpu) &&</yellow>
<yellow>	    static_call(kvm_x86_dy_apicv_has_pending_interrupt)(vcpu))</yellow>
		return true;

<yellow>	return false;</yellow>
<yellow>}</yellow>

bool kvm_arch_dy_runnable(struct kvm_vcpu *vcpu)
{
<yellow>	if (READ_ONCE(vcpu->arch.pv.pv_unhalted))</yellow>
		return true;

<yellow>	if (kvm_test_request(KVM_REQ_NMI, vcpu) ||</yellow>
<yellow>		kvm_test_request(KVM_REQ_SMI, vcpu) ||</yellow>
<yellow>		 kvm_test_request(KVM_REQ_EVENT, vcpu))</yellow>
		return true;

<yellow>	return kvm_arch_dy_has_pending_interrupt(vcpu);</yellow>
<yellow>}</yellow>

bool kvm_arch_vcpu_in_kernel(struct kvm_vcpu *vcpu)
{
<yellow>	if (vcpu->arch.guest_state_protected)</yellow>
		return true;

<yellow>	return vcpu->arch.preempted_in_kernel;</yellow>
<yellow>}</yellow>

unsigned long kvm_arch_vcpu_get_ip(struct kvm_vcpu *vcpu)
{
<yellow>	return kvm_rip_read(vcpu);</yellow>
}

int kvm_arch_vcpu_should_kick(struct kvm_vcpu *vcpu)
{
<blue>	return kvm_vcpu_exiting_guest_mode(vcpu) == IN_GUEST_MODE;</blue>
}

int kvm_arch_interrupt_allowed(struct kvm_vcpu *vcpu)
{
<blue>	return static_call(kvm_x86_interrupt_allowed)(vcpu, false);</blue>
}

<yellow>unsigned long kvm_get_linear_rip(struct kvm_vcpu *vcpu)</yellow>
<blue>{</blue>
	/* Can&#x27;t read the RIP when guest state is protected, just return 0 */
<blue>	if (vcpu->arch.guest_state_protected)</blue>
		return 0;

<blue>	if (is_64_bit_mode(vcpu))</blue>
<blue>		return kvm_rip_read(vcpu);</blue>
<yellow>	return (u32)(get_segment_base(vcpu, VCPU_SREG_CS) +</yellow>
<yellow>		     kvm_rip_read(vcpu));</yellow>
}
EXPORT_SYMBOL_GPL(kvm_get_linear_rip);

bool kvm_is_linear_rip(struct kvm_vcpu *vcpu, unsigned long linear_rip)
{
<yellow>	return kvm_get_linear_rip(vcpu) == linear_rip;</yellow>
}
EXPORT_SYMBOL_GPL(kvm_is_linear_rip);

unsigned long kvm_get_rflags(struct kvm_vcpu *vcpu)
{
	unsigned long rflags;

<blue>	rflags = static_call(kvm_x86_get_rflags)(vcpu);</blue>
<yellow>	if (vcpu->guest_debug & KVM_GUESTDBG_SINGLESTEP)</yellow>
<yellow>		rflags &= ~X86_EFLAGS_TF;</yellow>
	return rflags;
<yellow>}</yellow>
EXPORT_SYMBOL_GPL(kvm_get_rflags);

static void __kvm_set_rflags(struct kvm_vcpu *vcpu, unsigned long rflags)
{
<blue>	if (vcpu->guest_debug & KVM_GUESTDBG_SINGLESTEP &&</blue>
<yellow>	    kvm_is_linear_rip(vcpu, vcpu->arch.singlestep_rip))</yellow>
<yellow>		rflags |= X86_EFLAGS_TF;</yellow>
<blue>	static_call(kvm_x86_set_rflags)(vcpu, rflags);</blue>
}

void kvm_set_rflags(struct kvm_vcpu *vcpu, unsigned long rflags)
{
<blue>	__kvm_set_rflags(vcpu, rflags);</blue>
	kvm_make_request(KVM_REQ_EVENT, vcpu);
}
EXPORT_SYMBOL_GPL(kvm_set_rflags);

static inline u32 kvm_async_pf_hash_fn(gfn_t gfn)
{
	BUILD_BUG_ON(!is_power_of_2(ASYNC_PF_PER_VCPU));

	return hash_32(gfn &amp; 0xffffffff, order_base_2(ASYNC_PF_PER_VCPU));
}

static inline u32 kvm_async_pf_next_probe(u32 key)
{
<yellow>	return (key + 1) & (ASYNC_PF_PER_VCPU - 1);</yellow>
}

static void kvm_add_async_pf_gfn(struct kvm_vcpu *vcpu, gfn_t gfn)
{
	u32 key = kvm_async_pf_hash_fn(gfn);

	while (vcpu-&gt;arch.apf.gfns[key] != ~0)
<yellow>		key = kvm_async_pf_next_probe(key);</yellow>

<yellow>	vcpu->arch.apf.gfns[key] = gfn;</yellow>
}

static u32 kvm_async_pf_gfn_slot(struct kvm_vcpu *vcpu, gfn_t gfn)
{
	int i;
	u32 key = kvm_async_pf_hash_fn(gfn);

<yellow>	for (i = 0; i < ASYNC_PF_PER_VCPU &&</yellow>
<yellow>		     (vcpu->arch.apf.gfns[key] != gfn &&</yellow>
<yellow>		      vcpu->arch.apf.gfns[key] != ~0); i++)</yellow>
		key = kvm_async_pf_next_probe(key);

	return key;
}

bool kvm_find_async_pf_gfn(struct kvm_vcpu *vcpu, gfn_t gfn)
{
<yellow>	return vcpu->arch.apf.gfns[kvm_async_pf_gfn_slot(vcpu, gfn)] == gfn;</yellow>
}

static void kvm_del_async_pf_gfn(struct kvm_vcpu *vcpu, gfn_t gfn)
{
	u32 i, j, k;

<yellow>	i = j = kvm_async_pf_gfn_slot(vcpu, gfn);</yellow>

<yellow>	if (WARN_ON_ONCE(vcpu->arch.apf.gfns[i] != gfn))</yellow>
		return;

	while (true) {
<yellow>		vcpu->arch.apf.gfns[i] = ~0;</yellow>
		do {
<yellow>			j = kvm_async_pf_next_probe(j);</yellow>
			if (vcpu-&gt;arch.apf.gfns[j] == ~0)
				return;
<yellow>			k = kvm_async_pf_hash_fn(vcpu->arch.apf.gfns[j]);</yellow>
			/*
			 * k lies cyclically in ]i,j]
			 * |    i.k.j |
			 * |....j i.k.| or  |.k..j i...|
			 */
<yellow>		} while ((i <= j) ? (i < k && k <= j) : (i < k || k <= j));</yellow>
<yellow>		vcpu->arch.apf.gfns[i] = vcpu->arch.apf.gfns[j];</yellow>
		i = j;
	}
}

static inline int apf_put_user_notpresent(struct kvm_vcpu *vcpu)
{
	u32 reason = KVM_PV_REASON_PAGE_NOT_PRESENT;

<yellow>	return kvm_write_guest_cached(vcpu->kvm, &vcpu->arch.apf.data, &reason,</yellow>
				      sizeof(reason));
}

static inline int apf_put_user_ready(struct kvm_vcpu *vcpu, u32 token)
{
	unsigned int offset = offsetof(struct kvm_vcpu_pv_apf_data, token);

	return kvm_write_guest_offset_cached(vcpu-&gt;kvm, &amp;vcpu-&gt;arch.apf.data,
					     &amp;token, offset, sizeof(token));
}

static inline bool apf_pageready_slot_free(struct kvm_vcpu *vcpu)
{
	unsigned int offset = offsetof(struct kvm_vcpu_pv_apf_data, token);
	u32 val;

<yellow>	if (kvm_read_guest_offset_cached(vcpu->kvm, &vcpu->arch.apf.data,</yellow>
					 &amp;val, offset, sizeof(val)))
		return false;

<yellow>	return !val;</yellow>
}

<yellow>static bool kvm_can_deliver_async_pf(struct kvm_vcpu *vcpu)</yellow>
{

<yellow>	if (!kvm_pv_async_pf_enabled(vcpu))</yellow>
<yellow>		return false;</yellow>

<yellow>	if (vcpu->arch.apf.send_user_only &&</yellow>
<yellow>	    static_call(kvm_x86_get_cpl)(vcpu) == 0)</yellow>
		return false;

<yellow>	if (is_guest_mode(vcpu)) {</yellow>
		/*
		 * L1 needs to opt into the special #PF vmexits that are
		 * used to deliver async page faults.
		 */
<yellow>		return vcpu->arch.apf.delivery_as_pf_vmexit;</yellow>
	} else {
		/*
		 * Play it safe in case the guest temporarily disables paging.
		 * The real mode IDT in particular is unlikely to have a #PF
		 * exception setup.
		 */
<yellow>		return is_paging(vcpu);</yellow>
	}
<yellow>}</yellow>

bool kvm_can_do_async_pf(struct kvm_vcpu *vcpu)
{
<yellow>	if (unlikely(!lapic_in_kernel(vcpu) ||</yellow>
		     kvm_event_needs_reinjection(vcpu) ||
		     kvm_is_exception_pending(vcpu)))
<yellow>		return false;</yellow>

<yellow>	if (kvm_hlt_in_guest(vcpu->kvm) && !kvm_can_deliver_async_pf(vcpu))</yellow>
		return false;

	/*
	 * If interrupts are off we cannot even use an artificial
	 * halt state.
	 */
<yellow>	return kvm_arch_interrupt_allowed(vcpu);</yellow>
<yellow>}</yellow>

bool kvm_arch_async_page_not_present(struct kvm_vcpu *vcpu,
				     struct kvm_async_pf *work)
<yellow>{</yellow>
	struct x86_exception fault;

<yellow>	trace_kvm_async_pf_not_present(work->arch.token, work->cr2_or_gpa);</yellow>
<yellow>	kvm_add_async_pf_gfn(vcpu, work->arch.gfn);</yellow>

	if (kvm_can_deliver_async_pf(vcpu) &amp;&amp;
<yellow>	    !apf_put_user_notpresent(vcpu)) {</yellow>
		fault.vector = PF_VECTOR;
		fault.error_code_valid = true;
		fault.error_code = 0;
		fault.nested_page_fault = false;
<yellow>		fault.address = work->arch.token;</yellow>
		fault.async_page_fault = true;
		kvm_inject_page_fault(vcpu, &amp;fault);
		return true;
	} else {
		/*
		 * It is not possible to deliver a paravirtualized asynchronous
		 * page fault, but putting the guest in an artificial halt state
		 * can be beneficial nevertheless: if an interrupt arrives, we
		 * can deliver it timely and perhaps the guest will schedule
		 * another process.  When the instruction that triggered a page
		 * fault is retried, hopefully the page will be ready in the host.
		 */
<yellow>		kvm_make_request(KVM_REQ_APF_HALT, vcpu);</yellow>
		return false;
	}
}

void kvm_arch_async_page_present(struct kvm_vcpu *vcpu,
				 struct kvm_async_pf *work)
{
	struct kvm_lapic_irq irq = {
		.delivery_mode = APIC_DM_FIXED,
<yellow>		.vector = vcpu->arch.apf.vec</yellow>
	};

<yellow>	if (work->wakeup_all)</yellow>
<yellow>		work->arch.token = ~0; /* broadcast wakeup */</yellow>
	else
<yellow>		kvm_del_async_pf_gfn(vcpu, work->arch.gfn);</yellow>
<yellow>	trace_kvm_async_pf_ready(work->arch.token, work->cr2_or_gpa);</yellow>

<yellow>	if ((work->wakeup_all || work->notpresent_injected) &&</yellow>
<yellow>	    kvm_pv_async_pf_enabled(vcpu) &&</yellow>
<yellow>	    !apf_put_user_ready(vcpu, work->arch.token)) {</yellow>
<yellow>		vcpu->arch.apf.pageready_pending = true;</yellow>
		kvm_apic_set_irq(vcpu, &amp;irq, NULL);
	}

<yellow>	vcpu->arch.apf.halted = false;</yellow>
	vcpu-&gt;arch.mp_state = KVM_MP_STATE_RUNNABLE;
}

void kvm_arch_async_page_present_queued(struct kvm_vcpu *vcpu)
{
<yellow>	kvm_make_request(KVM_REQ_APF_READY, vcpu);</yellow>
<yellow>	if (!vcpu->arch.apf.pageready_pending)</yellow>
<yellow>		kvm_vcpu_kick(vcpu);</yellow>
<yellow>}</yellow>

bool kvm_arch_can_dequeue_async_page_present(struct kvm_vcpu *vcpu)
<yellow>{</yellow>
<yellow>	if (!kvm_pv_async_pf_enabled(vcpu))</yellow>
		return true;
	else
<yellow>		return kvm_lapic_enabled(vcpu) && apf_pageready_slot_free(vcpu);</yellow>
}

void kvm_arch_start_assignment(struct kvm *kvm)
{
<yellow>	if (atomic_inc_return(&kvm->arch.assigned_device_count) == 1)</yellow>
<yellow>		static_call_cond(kvm_x86_pi_start_assignment)(kvm);</yellow>
<yellow>}</yellow>
EXPORT_SYMBOL_GPL(kvm_arch_start_assignment);

void kvm_arch_end_assignment(struct kvm *kvm)
{
<yellow>	atomic_dec(&kvm->arch.assigned_device_count);</yellow>
}
EXPORT_SYMBOL_GPL(kvm_arch_end_assignment);

bool noinstr kvm_arch_has_assigned_device(struct kvm *kvm)
{
	return arch_atomic_read(&amp;kvm-&gt;arch.assigned_device_count);
}
EXPORT_SYMBOL_GPL(kvm_arch_has_assigned_device);

void kvm_arch_register_noncoherent_dma(struct kvm *kvm)
{
<yellow>	atomic_inc(&kvm->arch.noncoherent_dma_count);</yellow>
}
EXPORT_SYMBOL_GPL(kvm_arch_register_noncoherent_dma);

void kvm_arch_unregister_noncoherent_dma(struct kvm *kvm)
{
<yellow>	atomic_dec(&kvm->arch.noncoherent_dma_count);</yellow>
}
EXPORT_SYMBOL_GPL(kvm_arch_unregister_noncoherent_dma);

bool kvm_arch_has_noncoherent_dma(struct kvm *kvm)
{
<blue>	return atomic_read(&kvm->arch.noncoherent_dma_count);</blue>
}
EXPORT_SYMBOL_GPL(kvm_arch_has_noncoherent_dma);

bool kvm_arch_has_irq_bypass(void)
{
	return true;
<yellow>}</yellow>

int kvm_arch_irq_bypass_add_producer(struct irq_bypass_consumer *cons,
				      struct irq_bypass_producer *prod)
{
	struct kvm_kernel_irqfd *irqfd =
		container_of(cons, struct kvm_kernel_irqfd, consumer);
	int ret;

<yellow>	irqfd->producer = prod;</yellow>
<yellow>	kvm_arch_start_assignment(irqfd->kvm);</yellow>
	ret = static_call(kvm_x86_pi_update_irte)(irqfd-&gt;kvm,
<yellow>					 prod->irq, irqfd->gsi, 1);</yellow>

	if (ret)
<yellow>		kvm_arch_end_assignment(irqfd->kvm);</yellow>

	return ret;
<yellow>}</yellow>

void kvm_arch_irq_bypass_del_producer(struct irq_bypass_consumer *cons,
				      struct irq_bypass_producer *prod)
{
	int ret;
	struct kvm_kernel_irqfd *irqfd =
		container_of(cons, struct kvm_kernel_irqfd, consumer);

<yellow>	WARN_ON(irqfd->producer != prod);</yellow>
<yellow>	irqfd->producer = NULL;</yellow>

	/*
	 * When producer of consumer is unregistered, we change back to
	 * remapped mode, so we can re-use the current implementation
	 * when the irq is masked/disabled or the consumer side (KVM
	 * int this case doesn&#x27;t want to receive the interrupts.
	*/
	ret = static_call(kvm_x86_pi_update_irte)(irqfd-&gt;kvm, prod-&gt;irq, irqfd-&gt;gsi, 0);
	if (ret)
		printk(KERN_INFO &quot;irq bypass consumer (token %p) unregistration&quot;
		       &quot; fails: %d\n&quot;, irqfd-&gt;consumer.token, ret);

<yellow>	kvm_arch_end_assignment(irqfd->kvm);</yellow>
}

int kvm_arch_update_irqfd_routing(struct kvm *kvm, unsigned int host_irq,
				   uint32_t guest_irq, bool set)
{
<yellow>	return static_call(kvm_x86_pi_update_irte)(kvm, host_irq, guest_irq, set);</yellow>
}

bool kvm_arch_irqfd_route_changed(struct kvm_kernel_irq_routing_entry *old,
				  struct kvm_kernel_irq_routing_entry *new)
{
<yellow>	if (new->type != KVM_IRQ_ROUTING_MSI)</yellow>
		return true;

<yellow>	return !!memcmp(&old->msi, &new->msi, sizeof(new->msi));</yellow>
<yellow>}</yellow>

bool kvm_vector_hashing_enabled(void)
{
<yellow>	return vector_hashing;</yellow>
}

bool kvm_arch_no_poll(struct kvm_vcpu *vcpu)
{
<blue>	return (vcpu->arch.msr_kvm_poll_control & 1) == 0;</blue>
}
EXPORT_SYMBOL_GPL(kvm_arch_no_poll);


int kvm_spec_ctrl_test_value(u64 value)
<blue>{</blue>
	/*
	 * test that setting IA32_SPEC_CTRL to given value
	 * is allowed by the host processor
	 */

	u64 saved_value;
	unsigned long flags;
	int ret = 0;

<blue>	local_irq_save(flags);</blue>

	if (rdmsrl_safe(MSR_IA32_SPEC_CTRL, &amp;saved_value))
		ret = 1;
<blue>	else if (wrmsrl_safe(MSR_IA32_SPEC_CTRL, value))</blue>
		ret = 1;
	else
<blue>		wrmsrl(MSR_IA32_SPEC_CTRL, saved_value);</blue>

<blue>	local_irq_restore(flags);</blue>

	return ret;
}
EXPORT_SYMBOL_GPL(kvm_spec_ctrl_test_value);

void kvm_fixup_and_inject_pf_error(struct kvm_vcpu *vcpu, gva_t gva, u16 error_code)
{
<yellow>	struct kvm_mmu *mmu = vcpu->arch.walk_mmu;</yellow>
	struct x86_exception fault;
	u64 access = error_code &amp;
		(PFERR_WRITE_MASK | PFERR_FETCH_MASK | PFERR_USER_MASK);

	if (!(error_code &amp; PFERR_PRESENT_MASK) ||
<yellow>	    mmu->gva_to_gpa(vcpu, mmu, gva, access, &fault) != INVALID_GPA) {</yellow>
		/*
		 * If vcpu-&gt;arch.walk_mmu-&gt;gva_to_gpa succeeded, the page
		 * tables probably do not match the TLB.  Just proceed
		 * with the error code that the processor gave.
		 */
<yellow>		fault.vector = PF_VECTOR;</yellow>
		fault.error_code_valid = true;
		fault.error_code = error_code;
		fault.nested_page_fault = false;
		fault.address = gva;
		fault.async_page_fault = false;
	}
<yellow>	vcpu->arch.walk_mmu->inject_page_fault(vcpu, &fault);</yellow>
}
EXPORT_SYMBOL_GPL(kvm_fixup_and_inject_pf_error);

/*
 * Handles kvm_read/write_guest_virt*() result and either injects #PF or returns
 * KVM_EXIT_INTERNAL_ERROR for cases not currently handled by KVM. Return value
 * indicates whether exit to userspace is needed.
 */
int kvm_handle_memory_failure(struct kvm_vcpu *vcpu, int r,
			      struct x86_exception *e)
{
<yellow>	if (r == X86EMUL_PROPAGATE_FAULT) {</yellow>
<yellow>		kvm_inject_emulated_page_fault(vcpu, e);</yellow>
		return 1;
	}

	/*
	 * In case kvm_read/write_guest_virt*() failed with X86EMUL_IO_NEEDED
	 * while handling a VMX instruction KVM could&#x27;ve handled the request
	 * correctly by exiting to userspace and performing I/O but there
	 * doesn&#x27;t seem to be a real use-case behind such requests, just return
	 * KVM_EXIT_INTERNAL_ERROR for now.
	 */
<yellow>	kvm_prepare_emulation_failure_exit(vcpu);</yellow>

	return 0;
<yellow>}</yellow>
EXPORT_SYMBOL_GPL(kvm_handle_memory_failure);

int kvm_handle_invpcid(struct kvm_vcpu *vcpu, unsigned long type, gva_t gva)
<yellow>{</yellow>
	bool pcid_enabled;
	struct x86_exception e;
	struct {
		u64 pcid;
		u64 gla;
	} operand;
	int r;

<yellow>	r = kvm_read_guest_virt(vcpu, gva, &operand, sizeof(operand), &e);</yellow>
	if (r != X86EMUL_CONTINUE)
<yellow>		return kvm_handle_memory_failure(vcpu, r, &e);</yellow>

<yellow>	if (operand.pcid >> 12 != 0) {</yellow>
		kvm_inject_gp(vcpu, 0);
		return 1;
	}

<yellow>	pcid_enabled = kvm_read_cr4_bits(vcpu, X86_CR4_PCIDE);</yellow>

	switch (type) {
	case INVPCID_TYPE_INDIV_ADDR:
<yellow>		if ((!pcid_enabled && (operand.pcid != 0)) ||</yellow>
<yellow>		    is_noncanonical_address(operand.gla, vcpu)) {</yellow>
			kvm_inject_gp(vcpu, 0);
			return 1;
		}
<yellow>		kvm_mmu_invpcid_gva(vcpu, operand.gla, operand.pcid);</yellow>
		return kvm_skip_emulated_instruction(vcpu);

	case INVPCID_TYPE_SINGLE_CTXT:
<yellow>		if (!pcid_enabled && (operand.pcid != 0)) {</yellow>
			kvm_inject_gp(vcpu, 0);
			return 1;
		}

<yellow>		kvm_invalidate_pcid(vcpu, operand.pcid);</yellow>
		return kvm_skip_emulated_instruction(vcpu);

	case INVPCID_TYPE_ALL_NON_GLOBAL:
		/*
		 * Currently, KVM doesn&#x27;t mark global entries in the shadow
		 * page tables, so a non-global flush just degenerates to a
		 * global flush. If needed, we could optimize this later by
		 * keeping track of global entries in shadow page tables.
		 */

		fallthrough;
	case INVPCID_TYPE_ALL_INCL_GLOBAL:
<yellow>		kvm_make_request(KVM_REQ_TLB_FLUSH_GUEST, vcpu);</yellow>
<yellow>		return kvm_skip_emulated_instruction(vcpu);</yellow>

	default:
<yellow>		kvm_inject_gp(vcpu, 0);</yellow>
		return 1;
	}
}
EXPORT_SYMBOL_GPL(kvm_handle_invpcid);

static int complete_sev_es_emulated_mmio(struct kvm_vcpu *vcpu)
{
<yellow>	struct kvm_run *run = vcpu->run;</yellow>
	struct kvm_mmio_fragment *frag;
	unsigned int len;

<yellow>	BUG_ON(!vcpu->mmio_needed);</yellow>

	/* Complete previous fragment */
<yellow>	frag = &vcpu->mmio_fragments[vcpu->mmio_cur_fragment];</yellow>
	len = min(8u, frag-&gt;len);
	if (!vcpu-&gt;mmio_is_write)
<yellow>		memcpy(frag->data, run->mmio.data, len);</yellow>

<yellow>	if (frag->len <= 8) {</yellow>
		/* Switch to the next fragment. */
		frag++;
<yellow>		vcpu->mmio_cur_fragment++;</yellow>
	} else {
		/* Go forward to the next mmio piece. */
<yellow>		frag->data += len;</yellow>
		frag-&gt;gpa += len;
		frag-&gt;len -= len;
	}

<yellow>	if (vcpu->mmio_cur_fragment >= vcpu->mmio_nr_fragments) {</yellow>
<yellow>		vcpu->mmio_needed = 0;</yellow>

		// VMG change, at this point, we&#x27;re always done
		// RIP has already been advanced
		return 1;
	}

	// More MMIO is needed
<yellow>	run->mmio.phys_addr = frag->gpa;</yellow>
	run-&gt;mmio.len = min(8u, frag-&gt;len);
	run-&gt;mmio.is_write = vcpu-&gt;mmio_is_write;
	if (run-&gt;mmio.is_write)
<yellow>		memcpy(run->mmio.data, frag->data, min(8u, frag->len));</yellow>
<yellow>	run->exit_reason = KVM_EXIT_MMIO;</yellow>

	vcpu-&gt;arch.complete_userspace_io = complete_sev_es_emulated_mmio;

	return 0;
<yellow>}</yellow>

int kvm_sev_es_mmio_write(struct kvm_vcpu *vcpu, gpa_t gpa, unsigned int bytes,
			  void *data)
{
	int handled;
	struct kvm_mmio_fragment *frag;

<yellow>	if (!data)</yellow>
		return -EINVAL;

<yellow>	handled = write_emultor.read_write_mmio(vcpu, gpa, bytes, data);</yellow>
	if (handled == bytes)
		return 1;

	bytes -= handled;
	gpa += handled;
	data += handled;

	/*TODO: Check if need to increment number of frags */
	frag = vcpu-&gt;mmio_fragments;
<yellow>	vcpu->mmio_nr_fragments = 1;</yellow>
	frag-&gt;len = bytes;
	frag-&gt;gpa = gpa;
	frag-&gt;data = data;

	vcpu-&gt;mmio_needed = 1;
	vcpu-&gt;mmio_cur_fragment = 0;

	vcpu-&gt;run-&gt;mmio.phys_addr = gpa;
	vcpu-&gt;run-&gt;mmio.len = min(8u, frag-&gt;len);
	vcpu-&gt;run-&gt;mmio.is_write = 1;
	memcpy(vcpu-&gt;run-&gt;mmio.data, frag-&gt;data, min(8u, frag-&gt;len));
	vcpu-&gt;run-&gt;exit_reason = KVM_EXIT_MMIO;

	vcpu-&gt;arch.complete_userspace_io = complete_sev_es_emulated_mmio;

	return 0;
<yellow>}</yellow>
EXPORT_SYMBOL_GPL(kvm_sev_es_mmio_write);

int kvm_sev_es_mmio_read(struct kvm_vcpu *vcpu, gpa_t gpa, unsigned int bytes,
			 void *data)
{
	int handled;
	struct kvm_mmio_fragment *frag;

<yellow>	if (!data)</yellow>
		return -EINVAL;

<yellow>	handled = read_emultor.read_write_mmio(vcpu, gpa, bytes, data);</yellow>
	if (handled == bytes)
		return 1;

	bytes -= handled;
	gpa += handled;
	data += handled;

	/*TODO: Check if need to increment number of frags */
	frag = vcpu-&gt;mmio_fragments;
<yellow>	vcpu->mmio_nr_fragments = 1;</yellow>
	frag-&gt;len = bytes;
	frag-&gt;gpa = gpa;
	frag-&gt;data = data;

	vcpu-&gt;mmio_needed = 1;
	vcpu-&gt;mmio_cur_fragment = 0;

	vcpu-&gt;run-&gt;mmio.phys_addr = gpa;
	vcpu-&gt;run-&gt;mmio.len = min(8u, frag-&gt;len);
	vcpu-&gt;run-&gt;mmio.is_write = 0;
	vcpu-&gt;run-&gt;exit_reason = KVM_EXIT_MMIO;

	vcpu-&gt;arch.complete_userspace_io = complete_sev_es_emulated_mmio;

	return 0;
<yellow>}</yellow>
EXPORT_SYMBOL_GPL(kvm_sev_es_mmio_read);

static void advance_sev_es_emulated_pio(struct kvm_vcpu *vcpu, unsigned count, int size)
{
<yellow>	vcpu->arch.sev_pio_count -= count;</yellow>
	vcpu-&gt;arch.sev_pio_data += count * size;
}

static int kvm_sev_es_outs(struct kvm_vcpu *vcpu, unsigned int size,
			   unsigned int port);

static int complete_sev_es_emulated_outs(struct kvm_vcpu *vcpu)
{
<yellow>	int size = vcpu->arch.pio.size;</yellow>
	int port = vcpu-&gt;arch.pio.port;

	vcpu-&gt;arch.pio.count = 0;
	if (vcpu-&gt;arch.sev_pio_count)
<yellow>		return kvm_sev_es_outs(vcpu, size, port);</yellow>
	return 1;
<yellow>}</yellow>

static int kvm_sev_es_outs(struct kvm_vcpu *vcpu, unsigned int size,
			   unsigned int port)
{
	for (;;) {
		unsigned int count =
<yellow>			min_t(unsigned int, PAGE_SIZE / size, vcpu->arch.sev_pio_count);</yellow>
<yellow>		int ret = emulator_pio_out(vcpu, size, port, vcpu->arch.sev_pio_data, count);</yellow>

		/* memcpy done already by emulator_pio_out.  */
		advance_sev_es_emulated_pio(vcpu, count, size);
		if (!ret)
			break;

		/* Emulation done by the kernel.  */
<yellow>		if (!vcpu->arch.sev_pio_count)</yellow>
			return 1;
	}

<yellow>	vcpu->arch.complete_userspace_io = complete_sev_es_emulated_outs;</yellow>
	return 0;
<yellow>}</yellow>

static int kvm_sev_es_ins(struct kvm_vcpu *vcpu, unsigned int size,
			  unsigned int port);

static int complete_sev_es_emulated_ins(struct kvm_vcpu *vcpu)
{
<yellow>	unsigned count = vcpu->arch.pio.count;</yellow>
	int size = vcpu-&gt;arch.pio.size;
	int port = vcpu-&gt;arch.pio.port;

	complete_emulator_pio_in(vcpu, vcpu-&gt;arch.sev_pio_data);
	advance_sev_es_emulated_pio(vcpu, count, size);
	if (vcpu-&gt;arch.sev_pio_count)
<yellow>		return kvm_sev_es_ins(vcpu, size, port);</yellow>
	return 1;
<yellow>}</yellow>

static int kvm_sev_es_ins(struct kvm_vcpu *vcpu, unsigned int size,
			  unsigned int port)
{
	for (;;) {
		unsigned int count =
<yellow>			min_t(unsigned int, PAGE_SIZE / size, vcpu->arch.sev_pio_count);</yellow>
<yellow>		if (!emulator_pio_in(vcpu, size, port, vcpu->arch.sev_pio_data, count))</yellow>
			break;

		/* Emulation done by the kernel.  */
<yellow>		advance_sev_es_emulated_pio(vcpu, count, size);</yellow>
		if (!vcpu-&gt;arch.sev_pio_count)
			return 1;
	}

<yellow>	vcpu->arch.complete_userspace_io = complete_sev_es_emulated_ins;</yellow>
	return 0;
<yellow>}</yellow>

int kvm_sev_es_string_io(struct kvm_vcpu *vcpu, unsigned int size,
			 unsigned int port, void *data,  unsigned int count,
			 int in)
{
<yellow>	vcpu->arch.sev_pio_data = data;</yellow>
	vcpu-&gt;arch.sev_pio_count = count;
<yellow>	return in ? kvm_sev_es_ins(vcpu, size, port)</yellow>
<yellow>		  : kvm_sev_es_outs(vcpu, size, port);</yellow>
<yellow>}</yellow>
EXPORT_SYMBOL_GPL(kvm_sev_es_string_io);

EXPORT_TRACEPOINT_SYMBOL_GPL(kvm_entry);
EXPORT_TRACEPOINT_SYMBOL_GPL(kvm_exit);
EXPORT_TRACEPOINT_SYMBOL_GPL(kvm_fast_mmio);
EXPORT_TRACEPOINT_SYMBOL_GPL(kvm_inj_virq);
EXPORT_TRACEPOINT_SYMBOL_GPL(kvm_page_fault);
EXPORT_TRACEPOINT_SYMBOL_GPL(kvm_msr);
EXPORT_TRACEPOINT_SYMBOL_GPL(kvm_cr);
EXPORT_TRACEPOINT_SYMBOL_GPL(kvm_nested_vmenter);
EXPORT_TRACEPOINT_SYMBOL_GPL(kvm_nested_vmexit);
EXPORT_TRACEPOINT_SYMBOL_GPL(kvm_nested_vmexit_inject);
EXPORT_TRACEPOINT_SYMBOL_GPL(kvm_nested_intr_vmexit);
EXPORT_TRACEPOINT_SYMBOL_GPL(kvm_nested_vmenter_failed);
EXPORT_TRACEPOINT_SYMBOL_GPL(kvm_invlpga);
EXPORT_TRACEPOINT_SYMBOL_GPL(kvm_skinit);
EXPORT_TRACEPOINT_SYMBOL_GPL(kvm_nested_intercepts);
EXPORT_TRACEPOINT_SYMBOL_GPL(kvm_write_tsc_offset);
EXPORT_TRACEPOINT_SYMBOL_GPL(kvm_ple_window_update);
EXPORT_TRACEPOINT_SYMBOL_GPL(kvm_pml_full);
EXPORT_TRACEPOINT_SYMBOL_GPL(kvm_pi_irte_update);
EXPORT_TRACEPOINT_SYMBOL_GPL(kvm_avic_unaccelerated_access);
EXPORT_TRACEPOINT_SYMBOL_GPL(kvm_avic_incomplete_ipi);
EXPORT_TRACEPOINT_SYMBOL_GPL(kvm_avic_ga_log);
EXPORT_TRACEPOINT_SYMBOL_GPL(kvm_avic_kick_vcpu_slowpath);
EXPORT_TRACEPOINT_SYMBOL_GPL(kvm_avic_doorbell);
EXPORT_TRACEPOINT_SYMBOL_GPL(kvm_apicv_accept_irq);
EXPORT_TRACEPOINT_SYMBOL_GPL(kvm_vmgexit_enter);
EXPORT_TRACEPOINT_SYMBOL_GPL(kvm_vmgexit_exit);
EXPORT_TRACEPOINT_SYMBOL_GPL(kvm_vmgexit_msr_protocol_enter);
EXPORT_TRACEPOINT_SYMBOL_GPL(kvm_vmgexit_msr_protocol_exit);

static int __init kvm_x86_init(void)
{
	kvm_mmu_x86_module_init();
	return 0;
}
module_init(kvm_x86_init);

static void __exit kvm_x86_exit(void)
{
	/*
	 * If module_init() is implemented, module_exit() must also be
	 * implemented to allow module unload.
	 */
}
module_exit(kvm_x86_exit);


</code></pre></td></tr></table>
</body>
</html>
