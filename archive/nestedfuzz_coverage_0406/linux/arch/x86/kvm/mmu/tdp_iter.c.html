<doctype html>
<html lang="ja">
<head><title>tdp_iter.c</title><meta charset="utf-8">
<script src="https://cdn.rawgit.com/google/code-prettify/master/loader/run_prettify.js"></script>
<style>
    code{
        font-family:Monaco, Menlo, Consolas, 'Courier New', Courier, monospace, sans-serif;
        font-size: 14px;
        line-height: 18px;
        overflow: auto;
        resize: horizontal;
    }
    code_line{
        font-family: Monaco, Menlo, Consolas, 'Courier New', Courier, monospace, sans-serif;;
        font-size: 14px;
        line-height: 18px;
        overflow: auto;
        resize: horizontal;
        color:#303134;
    }
    blue{
        background-color:#BEEDE8;
    }
    yellow{
        background-color:#FFFF99;
    }
    red{
        background-color:#FF99AC;
    }
      .split {
         height: 100%;
         position: fixed;
         z-index: 1;
         top: 0;
         overflow-x: hidden;
      }

      .tree {
         left: 0;
         width: 20%;
      }

      .right {
         border-left: 2px solid #444;
         right: 0;
         width: 80%;
         /* font-family: 'Courier New', Courier, monospace;
				color: rgb(80, 80, 80); */
      }
</style>

</head>
<body>
   <div class="split tree">
      <ul id="file_list">
      </ul>
   </div>
   <div class="split right">
<table summary='blob content' class='blob' cellspacing="15">
<tr><td align="right"><pre><code_line><script>for (let i = 1; i <= 181; i++){
         document.write(i+".\n");
   }
         </script></code_line></pre></td>
<td class='lines'><pre><code class="prettyprint">// SPDX-License-Identifier: GPL-2.0

#include &quot;mmu_internal.h&quot;
#include &quot;tdp_iter.h&quot;
#include &quot;spte.h&quot;

/*
 * Recalculates the pointer to the SPTE for the current GFN and level and
 * reread the SPTE.
 */
static void tdp_iter_refresh_sptep(struct tdp_iter *iter)
{
<blue>	iter->sptep = iter->pt_path[iter->level - 1] +</blue>
<blue>		SPTE_INDEX(iter->gfn << PAGE_SHIFT, iter->level);</blue>
<blue>	iter->old_spte = kvm_tdp_mmu_read_spte(iter->sptep);</blue>
}

static gfn_t round_gfn_for_level(gfn_t gfn, int level)
{
<blue>	return gfn & -KVM_PAGES_PER_HPAGE(level);</blue>
}

/*
 * Return the TDP iterator to the root PT and allow it to continue its
 * traversal over the paging structure from there.
 */
void tdp_iter_restart(struct tdp_iter *iter)
{
<blue>	iter->yielded = false;</blue>
	iter-&gt;yielded_gfn = iter-&gt;next_last_level_gfn;
	iter-&gt;level = iter-&gt;root_level;

<blue>	iter->gfn = round_gfn_for_level(iter->next_last_level_gfn, iter->level);</blue>
	tdp_iter_refresh_sptep(iter);

	iter-&gt;valid = true;
}

/*
 * Sets a TDP iterator to walk a pre-order traversal of the paging structure
 * rooted at root_pt, starting with the walk to translate next_last_level_gfn.
 */
void tdp_iter_start(struct tdp_iter *iter, struct kvm_mmu_page *root,
		    int min_level, gfn_t next_last_level_gfn)
{
<blue>	int root_level = root->role.level;</blue>

<yellow>	WARN_ON(root_level < 1);</yellow>
<blue>	WARN_ON(root_level > PT64_ROOT_MAX_LEVEL);</blue>

<blue>	iter->next_last_level_gfn = next_last_level_gfn;</blue>
	iter-&gt;root_level = root_level;
	iter-&gt;min_level = min_level;
	iter-&gt;pt_path[iter-&gt;root_level - 1] = (tdp_ptep_t)root-&gt;spt;
	iter-&gt;as_id = kvm_mmu_page_as_id(root);

	tdp_iter_restart(iter);
}

/*
 * Given an SPTE and its level, returns a pointer containing the host virtual
 * address of the child page table referenced by the SPTE. Returns null if
 * there is no such entry.
 */
<blue>tdp_ptep_t spte_to_child_pt(u64 spte, int level)</blue>
{
	/*
	 * There&#x27;s no child entry if this entry isn&#x27;t present or is a
	 * last-level entry.
	 */
<blue>	if (!is_shadow_present_pte(spte) || is_last_spte(spte, level))</blue>
<yellow>		return NULL;</yellow>

<blue>	return (tdp_ptep_t)__va(spte_to_pfn(spte) << PAGE_SHIFT);</blue>
<blue>}</blue>

/*
 * Steps down one level in the paging structure towards the goal GFN. Returns
 * true if the iterator was able to step down a level, false otherwise.
 */
static bool try_step_down(struct tdp_iter *iter)
{
	tdp_ptep_t child_pt;

<blue>	if (iter->level == iter->min_level)</blue>
		return false;

	/*
	 * Reread the SPTE before stepping down to avoid traversing into page
	 * tables that are no longer linked from this entry.
	 */
<blue>	iter->old_spte = kvm_tdp_mmu_read_spte(iter->sptep);</blue>

<blue>	child_pt = spte_to_child_pt(iter->old_spte, iter->level);</blue>
	if (!child_pt)
		return false;

<blue>	iter->level--;</blue>
	iter-&gt;pt_path[iter-&gt;level - 1] = child_pt;
<blue>	iter->gfn = round_gfn_for_level(iter->next_last_level_gfn, iter->level);</blue>
	tdp_iter_refresh_sptep(iter);

	return true;
}

/*
 * Steps to the next entry in the current page table, at the current page table
 * level. The next entry could point to a page backing guest memory or another
 * page table, or it could be non-present. Returns true if the iterator was
 * able to step to the next entry in the page table, false if the iterator was
 * already at the end of the current page table.
 */
static bool try_step_side(struct tdp_iter *iter)
{
	/*
	 * Check if the iterator is already at the end of the current page
	 * table.
	 */
<blue>	if (SPTE_INDEX(iter->gfn << PAGE_SHIFT, iter->level) ==</blue>
	    (SPTE_ENT_PER_PAGE - 1))
		return false;

<blue>	iter->gfn += KVM_PAGES_PER_HPAGE(iter->level);</blue>
	iter-&gt;next_last_level_gfn = iter-&gt;gfn;
	iter-&gt;sptep++;
<blue>	iter->old_spte = kvm_tdp_mmu_read_spte(iter->sptep);</blue>

	return true;
}

/*
 * Tries to traverse back up a level in the paging structure so that the walk
 * can continue from the next entry in the parent page table. Returns true on a
 * successful step up, false if already in the root page.
 */
static bool try_step_up(struct tdp_iter *iter)
{
<blue>	if (iter->level == iter->root_level)</blue>
		return false;

<blue>	iter->level++;</blue>
<blue>	iter->gfn = round_gfn_for_level(iter->gfn, iter->level);</blue>
	tdp_iter_refresh_sptep(iter);

	return true;
}

/*
 * Step to the next SPTE in a pre-order traversal of the paging structure.
 * To get to the next SPTE, the iterator either steps down towards the goal
 * GFN, if at a present, non-last-level SPTE, or over to a SPTE mapping a
 * highter GFN.
 *
 * The basic algorithm is as follows:
 * 1. If the current SPTE is a non-last-level SPTE, step down into the page
 *    table it points to.
 * 2. If the iterator cannot step down, it will try to step to the next SPTE
 *    in the current page of the paging structure.
 * 3. If the iterator cannot step to the next entry in the current page, it will
 *    try to step up to the parent paging structure page. In this case, that
 *    SPTE will have already been visited, and so the iterator must also step
 *    to the side again.
 */
void tdp_iter_next(struct tdp_iter *iter)
{
<blue>	if (iter->yielded) {</blue>
<yellow>		tdp_iter_restart(iter);</yellow>
		return;
	}

<blue>	if (try_step_down(iter))</blue>
		return;

	do {
<blue>		if (try_step_side(iter))</blue>
			return;
<blue>	} while (try_step_up(iter));</blue>
<yellow>	iter->valid = false;</yellow>
<blue>}</blue>



</code></pre></td></tr></table>
</div><script>const fileList = document.getElementById('file_list')
fileList.innerHTML+=`<li><a href="/kvm_coverage/coverage/linux/arch/x86/kvm/mmu/mmu.c.html">mmu.c 55.0%</li>`
fileList.innerHTML+=`<li><a href="/kvm_coverage/coverage/linux/arch/x86/kvm/vmx/nested.c.html">nested.c 80.8%</li>`
fileList.innerHTML+=`<li><a href="/kvm_coverage/coverage/linux/arch/x86/kvm/vmx/vmx.c.html">vmx.c 56.2%</li>`
fileList.innerHTML+=`<li><a href="/kvm_coverage/coverage/linux/arch/x86/kvm/x86.c.html">x86.c 50.7%</li>`
</script></body></html>