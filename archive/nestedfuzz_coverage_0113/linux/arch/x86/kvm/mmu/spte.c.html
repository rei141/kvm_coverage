<doctype html>
<html lang="ja">
<head>
<meta charset="utf-8">
<script src="https://cdn.rawgit.com/google/code-prettify/master/loader/run_prettify.js"></script>
<style>
    code{
        font-family:Monaco, Menlo, Consolas, 'Courier New', Courier, monospace, sans-serif;
        font-size: 14px;
        line-height: 18px;
        overflow: auto;
        resize: horizontal;
    }
    code_line{
        font-family: Monaco, Menlo, Consolas, 'Courier New', Courier, monospace, sans-serif;;
        font-size: 14px;
        line-height: 18px;
        overflow: auto;
        resize: horizontal;
        color:#303134;
    }
    blue{
        background-color:#BEEDE8;
    }
    yellow{
        background-color:#FFFF99;
    }
    red{
        background-color:#FF99AC;
    }
</style>

</head>
<body>
<table summary='blob content' class='blob' cellspacing="15">
<tr><td align="right"><pre><code_line>1.<br>2.<br>3.<br>4.<br>5.<br>6.<br>7.<br>8.<br>9.<br>10.<br>11.<br>12.<br>13.<br>14.<br>15.<br>16.<br>17.<br>18.<br>19.<br>20.<br>21.<br>22.<br>23.<br>24.<br>25.<br>26.<br>27.<br>28.<br>29.<br>30.<br>31.<br>32.<br>33.<br>34.<br>35.<br>36.<br>37.<br>38.<br>39.<br>40.<br>41.<br>42.<br>43.<br>44.<br>45.<br>46.<br>47.<br>48.<br>49.<br>50.<br>51.<br>52.<br>53.<br>54.<br>55.<br>56.<br>57.<br>58.<br>59.<br>60.<br>61.<br>62.<br>63.<br>64.<br>65.<br>66.<br>67.<br>68.<br>69.<br>70.<br>71.<br>72.<br>73.<br>74.<br>75.<br>76.<br>77.<br>78.<br>79.<br>80.<br>81.<br>82.<br>83.<br>84.<br>85.<br>86.<br>87.<br>88.<br>89.<br>90.<br>91.<br>92.<br>93.<br>94.<br>95.<br>96.<br>97.<br>98.<br>99.<br>100.<br>101.<br>102.<br>103.<br>104.<br>105.<br>106.<br>107.<br>108.<br>109.<br>110.<br>111.<br>112.<br>113.<br>114.<br>115.<br>116.<br>117.<br>118.<br>119.<br>120.<br>121.<br>122.<br>123.<br>124.<br>125.<br>126.<br>127.<br>128.<br>129.<br>130.<br>131.<br>132.<br>133.<br>134.<br>135.<br>136.<br>137.<br>138.<br>139.<br>140.<br>141.<br>142.<br>143.<br>144.<br>145.<br>146.<br>147.<br>148.<br>149.<br>150.<br>151.<br>152.<br>153.<br>154.<br>155.<br>156.<br>157.<br>158.<br>159.<br>160.<br>161.<br>162.<br>163.<br>164.<br>165.<br>166.<br>167.<br>168.<br>169.<br>170.<br>171.<br>172.<br>173.<br>174.<br>175.<br>176.<br>177.<br>178.<br>179.<br>180.<br>181.<br>182.<br>183.<br>184.<br>185.<br>186.<br>187.<br>188.<br>189.<br>190.<br>191.<br>192.<br>193.<br>194.<br>195.<br>196.<br>197.<br>198.<br>199.<br>200.<br>201.<br>202.<br>203.<br>204.<br>205.<br>206.<br>207.<br>208.<br>209.<br>210.<br>211.<br>212.<br>213.<br>214.<br>215.<br>216.<br>217.<br>218.<br>219.<br>220.<br>221.<br>222.<br>223.<br>224.<br>225.<br>226.<br>227.<br>228.<br>229.<br>230.<br>231.<br>232.<br>233.<br>234.<br>235.<br>236.<br>237.<br>238.<br>239.<br>240.<br>241.<br>242.<br>243.<br>244.<br>245.<br>246.<br>247.<br>248.<br>249.<br>250.<br>251.<br>252.<br>253.<br>254.<br>255.<br>256.<br>257.<br>258.<br>259.<br>260.<br>261.<br>262.<br>263.<br>264.<br>265.<br>266.<br>267.<br>268.<br>269.<br>270.<br>271.<br>272.<br>273.<br>274.<br>275.<br>276.<br>277.<br>278.<br>279.<br>280.<br>281.<br>282.<br>283.<br>284.<br>285.<br>286.<br>287.<br>288.<br>289.<br>290.<br>291.<br>292.<br>293.<br>294.<br>295.<br>296.<br>297.<br>298.<br>299.<br>300.<br>301.<br>302.<br>303.<br>304.<br>305.<br>306.<br>307.<br>308.<br>309.<br>310.<br>311.<br>312.<br>313.<br>314.<br>315.<br>316.<br>317.<br>318.<br>319.<br>320.<br>321.<br>322.<br>323.<br>324.<br>325.<br>326.<br>327.<br>328.<br>329.<br>330.<br>331.<br>332.<br>333.<br>334.<br>335.<br>336.<br>337.<br>338.<br>339.<br>340.<br>341.<br>342.<br>343.<br>344.<br>345.<br>346.<br>347.<br>348.<br>349.<br>350.<br>351.<br>352.<br>353.<br>354.<br>355.<br>356.<br>357.<br>358.<br>359.<br>360.<br>361.<br>362.<br>363.<br>364.<br>365.<br>366.<br>367.<br>368.<br>369.<br>370.<br>371.<br>372.<br>373.<br>374.<br>375.<br>376.<br>377.<br>378.<br>379.<br>380.<br>381.<br>382.<br>383.<br>384.<br>385.<br>386.<br>387.<br>388.<br>389.<br>390.<br>391.<br>392.<br>393.<br>394.<br>395.<br>396.<br>397.<br>398.<br>399.<br>400.<br>401.<br>402.<br>403.<br>404.<br>405.<br>406.<br>407.<br>408.<br>409.<br>410.<br>411.<br>412.<br>413.<br>414.<br>415.<br>416.<br>417.<br>418.<br>419.<br>420.<br>421.<br>422.<br>423.<br>424.<br>425.<br>426.<br>427.<br>428.<br>429.<br>430.<br>431.<br>432.<br>433.<br>434.<br>435.<br>436.<br>437.<br>438.<br>439.<br>440.<br>441.<br>442.<br>443.<br>444.<br>445.<br>446.<br>447.<br>448.<br>449.<br>450.<br>451.<br>452.<br>453.<br>454.<br>455.<br>456.<br>457.<br>458.<br>459.<br>460.<br>461.<br>462.<br>463.<br>464.<br>465.<br>466.<br>467.<br>468.<br>469.<br>470.<br>471.<br>472.<br>473.<br>474.<br>475.<br>476.<br>477.<br>478.<br>479.<br>480.<br>481.<br>482.<br>483.<br>484.<br>485.<br>486.<br>487.<br>488.<br>489.<br>490.<br>491.<br>492.<br>493.<br>494.<br>495.<br>496.<br>497.<br>498.<br>499.<br>500.<br>501.<br>502.<br>503.<br>504.<br>505.<br>506.<br>507.<br>508.<br></code_line></pre></td>
<td class='lines'><pre><code class="prettyprint">// SPDX-License-Identifier: GPL-2.0-only
/*
 * Kernel-based Virtual Machine driver for Linux
 *
 * Macros and functions to access KVM PTEs (also known as SPTEs)
 *
 * Copyright (C) 2006 Qumranet, Inc.
 * Copyright 2020 Red Hat, Inc. and/or its affiliates.
 */


#include &lt;linux/kvm_host.h&gt;
#include &quot;mmu.h&quot;
#include &quot;mmu_internal.h&quot;
#include &quot;x86.h&quot;
#include &quot;spte.h&quot;

#include &lt;asm/e820/api.h&gt;
#include &lt;asm/memtype.h&gt;
#include &lt;asm/vmx.h&gt;

bool __read_mostly enable_mmio_caching = true;
static bool __ro_after_init allow_mmio_caching;
module_param_named(mmio_caching, enable_mmio_caching, bool, 0444);
EXPORT_SYMBOL_GPL(enable_mmio_caching);

u64 __read_mostly shadow_host_writable_mask;
u64 __read_mostly shadow_mmu_writable_mask;
u64 __read_mostly shadow_nx_mask;
u64 __read_mostly shadow_x_mask; /* mutual exclusive with nx_mask */
u64 __read_mostly shadow_user_mask;
u64 __read_mostly shadow_accessed_mask;
u64 __read_mostly shadow_dirty_mask;
u64 __read_mostly shadow_mmio_value;
u64 __read_mostly shadow_mmio_mask;
u64 __read_mostly shadow_mmio_access_mask;
u64 __read_mostly shadow_present_mask;
u64 __read_mostly shadow_memtype_mask;
u64 __read_mostly shadow_me_value;
u64 __read_mostly shadow_me_mask;
u64 __read_mostly shadow_acc_track_mask;

u64 __read_mostly shadow_nonpresent_or_rsvd_mask;
u64 __read_mostly shadow_nonpresent_or_rsvd_lower_gfn_mask;

u8 __read_mostly shadow_phys_bits;

void __init kvm_mmu_spte_module_init(void)
{
	/*
	 * Snapshot userspace&#x27;s desire to allow MMIO caching.  Whether or not
	 * KVM can actually enable MMIO caching depends on vendor-specific
	 * hardware capabilities and other module params that can&#x27;t be resolved
	 * until the vendor module is loaded, i.e. enable_mmio_caching can and
	 * will change when the vendor module is (re)loaded.
	 */
	allow_mmio_caching = enable_mmio_caching;
}

static u64 generation_mmio_spte_mask(u64 gen)
{
	u64 mask;

	WARN_ON(gen &amp; ~MMIO_SPTE_GEN_MASK);

	mask = (gen &lt;&lt; MMIO_SPTE_GEN_LOW_SHIFT) &amp; MMIO_SPTE_GEN_LOW_MASK;
	mask |= (gen &lt;&lt; MMIO_SPTE_GEN_HIGH_SHIFT) &amp; MMIO_SPTE_GEN_HIGH_MASK;
	return mask;
}

u64 make_mmio_spte(struct kvm_vcpu *vcpu, u64 gfn, unsigned int access)
{
<blue>	u64 gen = kvm_vcpu_memslots(vcpu)->generation & MMIO_SPTE_GEN_MASK;</blue>
	u64 spte = generation_mmio_spte_mask(gen);
	u64 gpa = gfn &lt;&lt; PAGE_SHIFT;

<yellow>	WARN_ON_ONCE(!shadow_mmio_value);</yellow>

	access &amp;= shadow_mmio_access_mask;
	spte |= shadow_mmio_value | access;
	spte |= gpa | shadow_nonpresent_or_rsvd_mask;
<blue>	spte |= (gpa & shadow_nonpresent_or_rsvd_mask)</blue>
		&lt;&lt; SHADOW_NONPRESENT_OR_RSVD_MASK_LEN;

	return spte;
}

<blue>static bool kvm_is_mmio_pfn(kvm_pfn_t pfn)</blue>
{
<blue>	if (pfn_valid(pfn))</blue>
<blue>		return !is_zero_pfn(pfn) && PageReserved(pfn_to_page(pfn)) &&</blue>
			/*
			 * Some reserved pages, such as those from NVDIMM
			 * DAX devices, are not for MMIO, and can be mapped
			 * with cached memory type for better performance.
			 * However, the above check misconceives those pages
			 * as MMIO, and results in KVM mapping them with UC
			 * memory type, which would hurt the performance.
			 * Therefore, we check the host memory type in addition
			 * and only treat UC/UC-/WC pages as MMIO.
			 */
<yellow>			(!pat_enabled() || pat_pfn_immune_to_uc_mtrr(pfn));</yellow>

	return !e820__mapped_raw_any(pfn_to_hpa(pfn),
<yellow>				     pfn_to_hpa(pfn + 1) - 1,</yellow>
				     E820_TYPE_RAM);
<blue>}</blue>

/*
 * Returns true if the SPTE has bits that may be set without holding mmu_lock.
 * The caller is responsible for checking if the SPTE is shadow-present, and
 * for determining whether or not the caller cares about non-leaf SPTEs.
 */
bool spte_has_volatile_bits(u64 spte)
{
	/*
	 * Always atomically update spte if it can be updated
	 * out of mmu-lock, it can ensure dirty bit is not lost,
	 * also, it can help us to get a stable is_writable_pte()
	 * to ensure tlb flush is not missed.
	 */
<blue>	if (!is_writable_pte(spte) && is_mmu_writable_spte(spte))</blue>
		return true;

<blue>	if (is_access_track_spte(spte))</blue>
		return true;

	if (spte_ad_enabled(spte)) {
<blue>		if (!(spte & shadow_accessed_mask) ||</blue>
<blue>		    (is_writable_pte(spte) && !(spte & shadow_dirty_mask)))</blue>
			return true;
	}

	return false;
<blue>}</blue>

bool make_spte(struct kvm_vcpu *vcpu, struct kvm_mmu_page *sp,
	       const struct kvm_memory_slot *slot,
	       unsigned int pte_access, gfn_t gfn, kvm_pfn_t pfn,
	       u64 old_spte, bool prefetch, bool can_unsync,
	       bool host_writable, u64 *new_spte)
{
<blue>	int level = sp->role.level;</blue>
	u64 spte = SPTE_MMU_PRESENT_MASK;
	bool wrprot = false;

<yellow>	WARN_ON_ONCE(!pte_access && !shadow_present_mask);</yellow>

<blue>	if (sp->role.ad_disabled)</blue>
		spte |= SPTE_TDP_AD_DISABLED_MASK;
<blue>	else if (kvm_mmu_page_ad_need_write_protect(sp))</blue>
		spte |= SPTE_TDP_AD_WRPROT_ONLY_MASK;

	/*
	 * For the EPT case, shadow_present_mask is 0 if hardware
	 * supports exec-only page table entries.  In that case,
	 * ACC_USER_MASK and shadow_user_mask are used to represent
	 * read access.  See FNAME(gpte_access) in paging_tmpl.h.
	 */
<blue>	spte |= shadow_present_mask;</blue>
	if (!prefetch)
<blue>		spte |= spte_shadow_accessed_mask(spte);</blue>

<blue>	if (level > PG_LEVEL_4K && (pte_access & ACC_EXEC_MASK) &&</blue>
<blue>	    is_nx_huge_page_enabled(vcpu->kvm)) {</blue>
<yellow>		pte_access &= ~ACC_EXEC_MASK;</yellow>
	}

<blue>	if (pte_access & ACC_EXEC_MASK)</blue>
<blue>		spte |= shadow_x_mask;</blue>
	else
<yellow>		spte |= shadow_nx_mask;</yellow>

<blue>	if (pte_access & ACC_USER_MASK)</blue>
<blue>		spte |= shadow_user_mask;</blue>

<blue>	if (level > PG_LEVEL_4K)</blue>
<blue>		spte |= PT_PAGE_SIZE_MASK;</blue>

<blue>	if (shadow_memtype_mask)</blue>
		spte |= static_call(kvm_x86_get_mt_mask)(vcpu, gfn,
<blue>							 kvm_is_mmio_pfn(pfn));</blue>
	if (host_writable)
		spte |= shadow_host_writable_mask;
	else
		pte_access &amp;= ~ACC_WRITE_MASK;

<blue>	if (shadow_me_value && !kvm_is_mmio_pfn(pfn))</blue>
<yellow>		spte |= shadow_me_value;</yellow>

<blue>	spte |= (u64)pfn << PAGE_SHIFT;</blue>

<blue>	if (pte_access & ACC_WRITE_MASK) {</blue>
		spte |= PT_WRITABLE_MASK | shadow_mmu_writable_mask;

		/*
		 * Optimization: for pte sync, if spte was writable the hash
		 * lookup is unnecessary (and expensive). Write protection
		 * is responsibility of kvm_mmu_get_page / kvm_mmu_sync_roots.
		 * Same reasoning can be applied to dirty page accounting.
		 */
<blue>		if (is_writable_pte(old_spte))</blue>
			goto out;

		/*
		 * Unsync shadow pages that are reachable by the new, writable
		 * SPTE.  Write-protect the SPTE if the page can&#x27;t be unsync&#x27;d,
		 * e.g. it&#x27;s write-tracked (upper-level SPs) or has one or more
		 * shadow pages and unsync&#x27;ing pages is not allowed.
		 */
<blue>		if (mmu_try_to_unsync_pages(vcpu->kvm, slot, gfn, can_unsync, prefetch)) {</blue>
			pgprintk(&quot;%s: found shadow page for %llx, marking ro\n&quot;,
				 __func__, gfn);
			wrprot = true;
			pte_access &amp;= ~ACC_WRITE_MASK;
<blue>			spte &= ~(PT_WRITABLE_MASK | shadow_mmu_writable_mask);</blue>
		}
	}

	if (pte_access &amp; ACC_WRITE_MASK)
<blue>		spte |= spte_shadow_dirty_mask(spte);</blue>

out:
<blue>	if (prefetch)</blue>
<blue>		spte = mark_spte_for_access_track(spte);</blue>

<blue>	WARN_ONCE(is_rsvd_spte(&vcpu->arch.mmu->shadow_zero_check, spte, level),</blue>
		  &quot;spte = 0x%llx, level = %d, rsvd bits = 0x%llx&quot;, spte, level,
		  get_rsvd_bits(&amp;vcpu-&gt;arch.mmu-&gt;shadow_zero_check, spte, level));

<blue>	if ((spte & PT_WRITABLE_MASK) && kvm_slot_dirty_track_enabled(slot)) {</blue>
		/* Enforced by kvm_mmu_hugepage_adjust. */
<yellow>		WARN_ON(level > PG_LEVEL_4K);</yellow>
<yellow>		mark_page_dirty_in_slot(vcpu->kvm, slot, gfn);</yellow>
	}

<blue>	*new_spte = spte;</blue>
	return wrprot;
}

static u64 make_spte_executable(u64 spte)
{
<yellow>	bool is_access_track = is_access_track_spte(spte);</yellow>

	if (is_access_track)
<yellow>		spte = restore_acc_track_spte(spte);</yellow>

<yellow>	spte &= ~shadow_nx_mask;</yellow>
	spte |= shadow_x_mask;

	if (is_access_track)
		spte = mark_spte_for_access_track(spte);

	return spte;
}

/*
 * Construct an SPTE that maps a sub-page of the given huge page SPTE where
 * `index` identifies which sub-page.
 *
 * This is used during huge page splitting to build the SPTEs that make up the
 * new page table.
 */
u64 make_huge_page_split_spte(struct kvm *kvm, u64 huge_spte, union kvm_mmu_page_role role,
			      int index)
<yellow>{</yellow>
	u64 child_spte;

<yellow>	if (WARN_ON_ONCE(!is_shadow_present_pte(huge_spte)))</yellow>
		return 0;

<yellow>	if (WARN_ON_ONCE(!is_large_pte(huge_spte)))</yellow>
		return 0;

	child_spte = huge_spte;

	/*
	 * The child_spte already has the base address of the huge page being
	 * split. So we just have to OR in the offset to the page at the next
	 * lower level for the given index.
	 */
<yellow>	child_spte |= (index * KVM_PAGES_PER_HPAGE(role.level)) << PAGE_SHIFT;</yellow>

	if (role.level == PG_LEVEL_4K) {
		child_spte &amp;= ~PT_PAGE_SIZE_MASK;

		/*
		 * When splitting to a 4K page where execution is allowed, mark
		 * the page executable as the NX hugepage mitigation no longer
		 * applies.
		 */
<yellow>		if ((role.access & ACC_EXEC_MASK) && is_nx_huge_page_enabled(kvm))</yellow>
<yellow>			child_spte = make_spte_executable(child_spte);</yellow>
	}

	return child_spte;
}


u64 make_nonleaf_spte(u64 *child_pt, bool ad_disabled)
{
	u64 spte = SPTE_MMU_PRESENT_MASK;

<blue>	spte |= __pa(child_pt) | shadow_present_mask | PT_WRITABLE_MASK |</blue>
		shadow_user_mask | shadow_x_mask | shadow_me_value;

	if (ad_disabled)
<yellow>		spte |= SPTE_TDP_AD_DISABLED_MASK;</yellow>
	else
<blue>		spte |= shadow_accessed_mask;</blue>

	return spte;
<blue>}</blue>

u64 kvm_mmu_changed_pte_notifier_make_spte(u64 old_spte, kvm_pfn_t new_pfn)
{
	u64 new_spte;

<yellow>	new_spte = old_spte & ~SPTE_BASE_ADDR_MASK;</yellow>
	new_spte |= (u64)new_pfn &lt;&lt; PAGE_SHIFT;

	new_spte &amp;= ~PT_WRITABLE_MASK;
	new_spte &amp;= ~shadow_host_writable_mask;
	new_spte &amp;= ~shadow_mmu_writable_mask;

	new_spte = mark_spte_for_access_track(new_spte);

	return new_spte;
}

<yellow>u64 mark_spte_for_access_track(u64 spte)</yellow>
{
<blue>	if (spte_ad_enabled(spte))</blue>
<blue>		return spte & ~shadow_accessed_mask;</blue>

<yellow>	if (is_access_track_spte(spte))</yellow>
		return spte;

<yellow>	check_spte_writable_invariants(spte);</yellow>

<yellow>	WARN_ONCE(spte & (SHADOW_ACC_TRACK_SAVED_BITS_MASK <<</yellow>
			  SHADOW_ACC_TRACK_SAVED_BITS_SHIFT),
		  &quot;kvm: Access Tracking saved bit locations are not zero\n&quot;);

<yellow>	spte |= (spte & SHADOW_ACC_TRACK_SAVED_BITS_MASK) <<</yellow>
		SHADOW_ACC_TRACK_SAVED_BITS_SHIFT;
	spte &amp;= ~shadow_acc_track_mask;

	return spte;
<blue>}</blue>

void kvm_mmu_set_mmio_spte_mask(u64 mmio_value, u64 mmio_mask, u64 access_mask)
{
<yellow>	BUG_ON((u64)(unsigned)access_mask != access_mask);</yellow>
<yellow>	WARN_ON(mmio_value & shadow_nonpresent_or_rsvd_lower_gfn_mask);</yellow>

	/*
	 * Reset to the original module param value to honor userspace&#x27;s desire
	 * to (dis)allow MMIO caching.  Update the param itself so that
	 * userspace can see whether or not KVM is actually using MMIO caching.
	 */
<yellow>	enable_mmio_caching = allow_mmio_caching;</yellow>
<yellow>	if (!enable_mmio_caching)</yellow>
		mmio_value = 0;

	/*
	 * The mask must contain only bits that are carved out specifically for
	 * the MMIO SPTE mask, e.g. to ensure there&#x27;s no overlap with the MMIO
	 * generation.
	 */
<yellow>	if (WARN_ON(mmio_mask & ~SPTE_MMIO_ALLOWED_MASK))</yellow>
		mmio_value = 0;

	/*
	 * Disable MMIO caching if the MMIO value collides with the bits that
	 * are used to hold the relocated GFN when the L1TF mitigation is
	 * enabled.  This should never fire as there is no known hardware that
	 * can trigger this condition, e.g. SME/SEV CPUs that require a custom
	 * MMIO value are not susceptible to L1TF.
	 */
<yellow>	if (WARN_ON(mmio_value & (shadow_nonpresent_or_rsvd_mask <<</yellow>
				  SHADOW_NONPRESENT_OR_RSVD_MASK_LEN)))
		mmio_value = 0;

	/*
	 * The masked MMIO value must obviously match itself and a removed SPTE
	 * must not get a false positive.  Removed SPTEs and MMIO SPTEs should
	 * never collide as MMIO must set some RWX bits, and removed SPTEs must
	 * not set any RWX bits.
	 */
<yellow>	if (WARN_ON((mmio_value & mmio_mask) != mmio_value) ||</yellow>
<yellow>	    WARN_ON(mmio_value && (REMOVED_SPTE & mmio_mask) == mmio_value))</yellow>
		mmio_value = 0;

	if (!mmio_value)
<yellow>		enable_mmio_caching = false;</yellow>

<yellow>	shadow_mmio_value = mmio_value;</yellow>
	shadow_mmio_mask  = mmio_mask;
	shadow_mmio_access_mask = access_mask;
}
EXPORT_SYMBOL_GPL(kvm_mmu_set_mmio_spte_mask);

void kvm_mmu_set_me_spte_mask(u64 me_value, u64 me_mask)
{
	/* shadow_me_value must be a subset of shadow_me_mask */
<yellow>	if (WARN_ON(me_value & ~me_mask))</yellow>
		me_value = me_mask = 0;

<yellow>	shadow_me_value = me_value;</yellow>
	shadow_me_mask = me_mask;
}
EXPORT_SYMBOL_GPL(kvm_mmu_set_me_spte_mask);

void kvm_mmu_set_ept_masks(bool has_ad_bits, bool has_exec_only)
{
	shadow_user_mask	= VMX_EPT_READABLE_MASK;
<yellow>	shadow_accessed_mask	= has_ad_bits ? VMX_EPT_ACCESS_BIT : 0ull;</yellow>
	shadow_dirty_mask	= has_ad_bits ? VMX_EPT_DIRTY_BIT : 0ull;
	shadow_nx_mask		= 0ull;
	shadow_x_mask		= VMX_EPT_EXECUTABLE_MASK;
<yellow>	shadow_present_mask	= has_exec_only ? 0ull : VMX_EPT_READABLE_MASK;</yellow>
	/*
	 * EPT overrides the host MTRRs, and so KVM must program the desired
	 * memtype directly into the SPTEs.  Note, this mask is just the mask
	 * of all bits that factor into the memtype, the actual memtype must be
	 * dynamically calculated, e.g. to ensure host MMIO is mapped UC.
	 */
	shadow_memtype_mask	= VMX_EPT_MT_MASK | VMX_EPT_IPAT_BIT;
	shadow_acc_track_mask	= VMX_EPT_RWX_MASK;
	shadow_host_writable_mask = EPT_SPTE_HOST_WRITABLE;
	shadow_mmu_writable_mask  = EPT_SPTE_MMU_WRITABLE;

	/*
	 * EPT Misconfigurations are generated if the value of bits 2:0
	 * of an EPT paging-structure entry is 110b (write/execute).
	 */
	kvm_mmu_set_mmio_spte_mask(VMX_EPT_MISCONFIG_WX_VALUE,
				   VMX_EPT_RWX_MASK, 0);
}
EXPORT_SYMBOL_GPL(kvm_mmu_set_ept_masks);

void kvm_mmu_reset_all_pte_masks(void)
{
	u8 low_phys_bits;
	u64 mask;

<yellow>	shadow_phys_bits = kvm_get_shadow_phys_bits();</yellow>

	/*
	 * If the CPU has 46 or less physical address bits, then set an
	 * appropriate mask to guard against L1TF attacks. Otherwise, it is
	 * assumed that the CPU is not vulnerable to L1TF.
	 *
	 * Some Intel CPUs address the L1 cache using more PA bits than are
	 * reported by CPUID. Use the PA width of the L1 cache when possible
	 * to achieve more effective mitigation, e.g. if system RAM overlaps
	 * the most significant bits of legal physical address space.
	 */
	shadow_nonpresent_or_rsvd_mask = 0;
	low_phys_bits = boot_cpu_data.x86_phys_bits;
<yellow>	if (boot_cpu_has_bug(X86_BUG_L1TF) &&</yellow>
<yellow>	    !WARN_ON_ONCE(boot_cpu_data.x86_cache_bits >=</yellow>
			  52 - SHADOW_NONPRESENT_OR_RSVD_MASK_LEN)) {
		low_phys_bits = boot_cpu_data.x86_cache_bits
<yellow>			- SHADOW_NONPRESENT_OR_RSVD_MASK_LEN;</yellow>
<yellow>		shadow_nonpresent_or_rsvd_mask =</yellow>
<yellow>			rsvd_bits(low_phys_bits, boot_cpu_data.x86_cache_bits - 1);</yellow>
	}

	shadow_nonpresent_or_rsvd_lower_gfn_mask =
<yellow>		GENMASK_ULL(low_phys_bits - 1, PAGE_SHIFT);</yellow>

	shadow_user_mask	= PT_USER_MASK;
	shadow_accessed_mask	= PT_ACCESSED_MASK;
	shadow_dirty_mask	= PT_DIRTY_MASK;
	shadow_nx_mask		= PT64_NX_MASK;
	shadow_x_mask		= 0;
	shadow_present_mask	= PT_PRESENT_MASK;

	/*
	 * For shadow paging and NPT, KVM uses PAT entry &#x27;0&#x27; to encode WB
	 * memtype in the SPTEs, i.e. relies on host MTRRs to provide the
	 * correct memtype (WB is the &quot;weakest&quot; memtype).
	 */
	shadow_memtype_mask	= 0;
	shadow_acc_track_mask	= 0;
	shadow_me_mask		= 0;
	shadow_me_value		= 0;

	shadow_host_writable_mask = DEFAULT_SPTE_HOST_WRITABLE;
	shadow_mmu_writable_mask  = DEFAULT_SPTE_MMU_WRITABLE;

	/*
	 * Set a reserved PA bit in MMIO SPTEs to generate page faults with
	 * PFEC.RSVD=1 on MMIO accesses.  64-bit PTEs (PAE, x86-64, and EPT
	 * paging) support a maximum of 52 bits of PA, i.e. if the CPU supports
	 * 52-bit physical addresses then there are no reserved PA bits in the
	 * PTEs and so the reserved PA approach must be disabled.
	 */
	if (shadow_phys_bits &lt; 52)
		mask = BIT_ULL(51) | PT_PRESENT_MASK;
	else
		mask = 0;

<yellow>	kvm_mmu_set_mmio_spte_mask(mask, mask, ACC_WRITE_MASK | ACC_USER_MASK);</yellow>
}


</code></pre></td></tr></table>
</body>
</html>
