<doctype html>
<html lang="ja">
<head>
<meta charset="utf-8">
<script src="https://cdn.rawgit.com/google/code-prettify/master/loader/run_prettify.js"></script>
<style>
    code{
        font-family:Monaco, Menlo, Consolas, 'Courier New', Courier, monospace, sans-serif;
        font-size: 14px;
        line-height: 18px;
        overflow: auto;
        resize: horizontal;
    }
    code_line{
        font-family: Monaco, Menlo, Consolas, 'Courier New', Courier, monospace, sans-serif;;
        font-size: 14px;
        line-height: 18px;
        overflow: auto;
        resize: horizontal;
        color:#303134;
    }
    blue{
        background-color:#BEEDE8;
    }
    yellow{
        background-color:#FFFF99;
    }
    red{
        background-color:#FF99AC;
    }
</style>

</head>
<body>
<table summary='blob content' class='blob' cellspacing="15">
<tr><td align="right"><pre><code_line>1.
2.
3.
4.
5.
6.
7.
8.
9.
10.
11.
12.
13.
14.
15.
16.
17.
18.
19.
20.
21.
22.
23.
24.
25.
26.
27.
28.
29.
30.
31.
32.
33.
34.
35.
36.
37.
38.
39.
40.
41.
42.
43.
44.
45.
46.
47.
48.
49.
50.
51.
52.
53.
54.
55.
56.
57.
58.
59.
60.
61.
62.
63.
64.
65.
66.
67.
68.
69.
70.
71.
72.
73.
74.
75.
76.
77.
78.
79.
80.
81.
82.
83.
84.
85.
86.
87.
88.
89.
90.
91.
92.
93.
94.
95.
96.
97.
98.
99.
100.
101.
102.
103.
104.
105.
106.
107.
108.
109.
110.
111.
112.
113.
114.
115.
116.
117.
118.
119.
120.
121.
122.
123.
124.
125.
126.
127.
128.
129.
130.
131.
132.
133.
134.
135.
136.
137.
138.
139.
140.
141.
142.
143.
144.
145.
146.
147.
148.
149.
150.
151.
152.
153.
154.
155.
156.
157.
158.
159.
160.
161.
162.
163.
164.
165.
166.
167.
168.
169.
170.
171.
172.
173.
174.
175.
176.
177.
178.
179.
180.
181.
182.
183.
184.
185.
186.
187.
188.
189.
190.
191.
192.
193.
194.
195.
196.
197.
198.
199.
200.
201.
202.
203.
204.
205.
206.
207.
208.
209.
210.
211.
212.
213.
214.
215.
216.
217.
218.
219.
220.
221.
222.
223.
224.
225.
226.
227.
228.
229.
230.
231.
232.
233.
234.
235.
236.
237.
238.
239.
240.
241.
242.
243.
244.
245.
246.
247.
248.
249.
250.
251.
252.
253.
254.
255.
256.
257.
258.
259.
260.
261.
262.
263.
264.
265.
266.
267.
268.
269.
270.
271.
272.
273.
274.
275.
276.
277.
278.
279.
280.
281.
282.
283.
284.
285.
286.
287.
288.
289.
290.
291.
292.
293.
294.
295.
296.
297.
298.
299.
300.
301.
302.
303.
304.
305.
306.
307.
308.
309.
310.
311.
312.
313.
314.
315.
316.
317.
318.
319.
320.
321.
322.
323.
324.
325.
326.
327.
328.
329.
330.
331.
332.
333.
334.
335.
336.
337.
338.
339.
340.
341.
342.
343.
344.
345.
346.
347.
348.
349.
350.
351.
352.
353.
354.
355.
356.
357.
358.
359.
360.
361.
362.
363.
364.
365.
366.
367.
368.
369.
370.
371.
372.
373.
374.
375.
376.
377.
378.
379.
380.
381.
382.
383.
384.
385.
386.
387.
388.
389.
390.
391.
392.
393.
394.
395.
396.
397.
398.
399.
400.
401.
402.
403.
404.
405.
406.
407.
408.
409.
410.
411.
412.
413.
414.
415.
416.
417.
418.
419.
420.
421.
422.
423.
424.
425.
426.
427.
428.
429.
430.
431.
432.
433.
434.
435.
436.
437.
438.
439.
440.
441.
442.
443.
444.
445.
446.
447.
448.
449.
450.
451.
452.
453.
454.
455.
456.
457.
458.
459.
460.
461.
462.
463.
464.
465.
466.
467.
468.
469.
470.
471.
472.
473.
474.
475.
476.
477.
478.
479.
480.
481.
482.
483.
484.
485.
486.
487.
488.
489.
490.
491.
492.
493.
494.
495.
496.
497.
498.
499.
500.
501.
502.
503.
504.
505.
506.
507.
508.
509.
510.
511.
512.
513.
514.
515.
516.
517.
518.
519.
520.
521.
522.
523.
524.
525.
526.
527.
528.
529.
530.
531.
532.
533.
534.
535.
536.
537.
538.
539.
540.
541.
542.
543.
544.
545.
546.
547.
548.
549.
550.
551.
552.
553.
554.
555.
556.
557.
558.
559.
560.
561.
562.
563.
564.
565.
566.
567.
568.
569.
570.
571.
572.
573.
574.
575.
576.
577.
578.
579.
580.
581.
582.
583.
584.
585.
586.
587.
588.
589.
590.
591.
592.
593.
594.
595.
596.
597.
598.
599.
600.
601.
602.
603.
604.
605.
606.
607.
608.
609.
610.
611.
612.
613.
614.
615.
616.
617.
618.
619.
620.
621.
622.
623.
624.
625.
626.
627.
628.
629.
630.
631.
632.
633.
634.
635.
636.
637.
638.
639.
640.
641.
642.
643.
644.
645.
646.
647.
648.
649.
650.
651.
652.
653.
654.
655.
656.
657.
658.
659.
660.
661.
662.
663.
664.
665.
666.
667.
668.
669.
670.
671.
672.
673.
674.
675.
676.
677.
678.
679.
680.
681.
682.
683.
684.
685.
686.
687.
688.
689.
690.
691.
692.
693.
694.
695.
696.
697.
698.
699.
700.
701.
702.
703.
704.
705.
706.
707.
708.
709.
710.
711.
712.
713.
714.
715.
716.
717.
718.
719.
720.
721.
722.
723.
724.
725.
726.
727.
728.
729.
730.
731.
732.
733.
734.
735.
736.
737.
738.
739.
740.
741.
742.
743.
744.
745.
746.
747.
748.
749.
750.
751.
752.
753.
754.
755.
756.
757.
758.
759.
760.
761.
762.
763.
764.
765.
766.
767.
768.
769.
770.
771.
772.
773.
774.
775.
776.
777.
778.
779.
780.
781.
782.
783.
784.
785.
786.
787.
788.
789.
790.
791.
792.
793.
794.
795.
796.
797.
798.
799.
800.
801.
802.
803.
804.
805.
806.
807.
808.
809.
810.
811.
812.
813.
814.
815.
816.
817.
818.
819.
820.
821.
822.
823.
824.
825.
826.
827.
828.
829.
830.
831.
832.
833.
834.
835.
836.
837.
838.
839.
840.
841.
842.
843.
844.
845.
846.
847.
848.
849.
850.
851.
852.
853.
854.
855.
856.
857.
858.
859.
860.
861.
862.
863.
864.
865.
866.
867.
868.
869.
870.
871.
872.
873.
874.
875.
876.
877.
878.
879.
880.
881.
882.
883.
884.
885.
886.
887.
888.
889.
890.
891.
892.
893.
894.
895.
896.
897.
898.
899.
900.
901.
902.
903.
904.
905.
906.
907.
908.
909.
910.
911.
912.
913.
914.
915.
916.
917.
918.
919.
920.
921.
922.
923.
924.
925.
926.
927.
928.
929.
930.
931.
932.
933.
934.
935.
936.
937.
938.
939.
940.
941.
942.
943.
944.
945.
946.
947.
948.
949.
950.
951.
952.
953.
954.
955.
956.
957.
958.
959.
960.
961.
962.
963.
964.
965.
966.
967.
968.
969.
970.
971.
972.
973.
974.
975.
976.
977.
978.
979.
980.
981.
982.
983.
984.
985.
986.
987.
988.
989.
990.
991.
992.
993.
994.
995.
996.
997.
998.
999.
1000.
1001.
1002.
1003.
1004.
1005.
1006.
1007.
1008.
1009.
1010.
1011.
1012.
1013.
1014.
1015.
1016.
1017.
1018.
1019.
1020.
1021.
1022.
1023.
1024.
1025.
1026.
1027.
1028.
1029.
1030.
1031.
1032.
1033.
1034.
1035.
1036.
1037.
1038.
1039.
1040.
1041.
1042.
1043.
1044.
1045.
1046.
1047.
1048.
1049.
1050.
1051.
1052.
1053.
1054.
1055.
1056.
1057.
1058.
1059.
1060.
1061.
1062.
1063.
1064.
1065.
1066.
1067.
1068.
1069.
1070.
1071.
1072.
1073.
1074.
1075.
1076.
1077.
1078.
1079.
1080.
1081.
1082.
1083.
1084.
1085.
1086.
1087.
1088.
1089.
1090.
1091.
1092.
1093.
1094.
1095.
1096.
1097.
1098.
1099.
1100.
1101.
1102.
1103.
1104.
1105.
1106.
1107.
1108.
1109.
1110.
1111.
1112.
1113.
1114.
1115.
1116.
1117.
1118.
1119.
1120.
1121.
1122.
1123.
1124.
1125.
1126.
1127.
1128.
1129.
1130.
1131.
1132.
1133.
1134.
1135.
1136.
1137.
1138.
1139.
1140.
1141.
1142.
1143.
1144.
1145.
1146.
1147.
1148.
1149.
1150.
1151.
1152.
1153.
1154.
1155.
1156.
1157.
1158.
1159.
1160.
1161.
1162.
1163.
1164.
1165.
1166.
1167.
1168.
1169.
1170.
1171.
1172.
1173.
1174.
1175.
1176.
1177.
1178.
1179.
1180.
1181.
1182.
1183.
1184.
1185.
1186.
1187.
1188.
1189.
1190.
1191.
1192.
1193.
1194.
1195.
1196.
1197.
1198.
1199.
1200.
1201.
1202.
1203.
1204.
1205.
1206.
1207.
1208.
1209.
1210.
1211.
1212.
1213.
1214.
1215.
1216.
1217.
1218.
1219.
1220.
1221.
1222.
1223.
1224.
1225.
1226.
1227.
1228.
1229.
1230.
1231.
1232.
1233.
1234.
1235.
1236.
1237.
1238.
1239.
1240.
1241.
1242.
1243.
1244.
1245.
1246.
1247.
1248.
1249.
1250.
1251.
1252.
1253.
1254.
1255.
1256.
1257.
1258.
1259.
1260.
1261.
1262.
1263.
1264.
1265.
1266.
1267.
1268.
1269.
1270.
1271.
1272.
1273.
1274.
1275.
1276.
1277.
1278.
1279.
1280.
1281.
1282.
1283.
1284.
1285.
1286.
1287.
1288.
1289.
1290.
1291.
1292.
1293.
1294.
1295.
1296.
1297.
1298.
1299.
1300.
1301.
1302.
1303.
1304.
1305.
1306.
1307.
1308.
1309.
1310.
1311.
1312.
1313.
1314.
1315.
1316.
1317.
1318.
1319.
1320.
1321.
1322.
1323.
1324.
1325.
1326.
1327.
1328.
1329.
1330.
1331.
1332.
1333.
1334.
1335.
1336.
1337.
1338.
1339.
1340.
1341.
1342.
1343.
1344.
1345.
1346.
1347.
1348.
1349.
1350.
1351.
1352.
1353.
1354.
1355.
1356.
1357.
1358.
1359.
1360.
1361.
1362.
1363.
1364.
1365.
1366.
1367.
1368.
1369.
1370.
1371.
1372.
1373.
1374.
1375.
1376.
1377.
1378.
1379.
1380.
1381.
1382.
1383.
1384.
1385.
1386.
1387.
1388.
1389.
1390.
1391.
1392.
1393.
1394.
1395.
1396.
1397.
1398.
1399.
1400.
1401.
1402.
1403.
1404.
1405.
1406.
1407.
1408.
1409.
1410.
1411.
1412.
1413.
1414.
1415.
1416.
1417.
1418.
1419.
1420.
1421.
1422.
1423.
1424.
1425.
1426.
1427.
1428.
1429.
1430.
1431.
1432.
1433.
1434.
1435.
1436.
1437.
1438.
1439.
1440.
1441.
1442.
1443.
1444.
1445.
1446.
1447.
1448.
1449.
1450.
1451.
1452.
1453.
1454.
1455.
1456.
1457.
1458.
1459.
1460.
1461.
1462.
1463.
1464.
1465.
1466.
1467.
1468.
1469.
1470.
1471.
1472.
1473.
1474.
1475.
1476.
1477.
1478.
1479.
1480.
1481.
1482.
1483.
1484.
1485.
1486.
1487.
1488.
1489.
1490.
1491.
1492.
1493.
1494.
1495.
1496.
1497.
1498.
1499.
1500.
1501.
1502.
1503.
1504.
1505.
1506.
1507.
1508.
1509.
1510.
1511.
1512.
1513.
1514.
1515.
1516.
1517.
1518.
1519.
1520.
1521.
1522.
1523.
1524.
1525.
1526.
1527.
1528.
1529.
1530.
1531.
1532.
1533.
1534.
1535.
1536.
1537.
1538.
1539.
1540.
1541.
1542.
1543.
1544.
1545.
1546.
1547.
1548.
1549.
1550.
1551.
1552.
1553.
1554.
1555.
1556.
1557.
1558.
1559.
1560.
1561.
1562.
1563.
1564.
1565.
1566.
1567.
1568.
1569.
1570.
1571.
1572.
1573.
1574.
1575.
1576.
1577.
1578.
1579.
1580.
1581.
1582.
1583.
1584.
1585.
1586.
1587.
1588.
1589.
1590.
1591.
1592.
1593.
1594.
1595.
1596.
1597.
1598.
1599.
1600.
1601.
1602.
1603.
1604.
1605.
1606.
1607.
1608.
1609.
1610.
1611.
1612.
1613.
1614.
1615.
1616.
1617.
1618.
1619.
1620.
1621.
1622.
1623.
1624.
1625.
1626.
1627.
1628.
1629.
1630.
1631.
1632.
1633.
1634.
1635.
1636.
1637.
1638.
1639.
1640.
1641.
1642.
1643.
1644.
1645.
1646.
1647.
1648.
1649.
1650.
1651.
1652.
1653.
1654.
1655.
1656.
1657.
1658.
1659.
1660.
1661.
1662.
1663.
1664.
1665.
1666.
1667.
1668.
1669.
1670.
1671.
1672.
1673.
1674.
1675.
1676.
1677.
1678.
1679.
1680.
1681.
1682.
1683.
1684.
1685.
1686.
1687.
1688.
1689.
1690.
1691.
1692.
1693.
1694.
1695.
1696.
1697.
1698.
1699.
1700.
1701.
1702.
1703.
1704.
1705.
1706.
1707.
1708.
1709.
1710.
1711.
1712.
1713.
1714.
1715.
1716.
1717.
1718.
1719.
1720.
1721.
1722.
1723.
1724.
1725.
1726.
1727.
1728.
1729.
1730.
1731.
1732.
1733.
1734.
1735.
1736.
1737.
1738.
1739.
1740.
1741.
1742.
1743.
1744.
1745.
1746.
1747.
1748.
1749.
1750.
1751.
1752.
1753.
1754.
1755.
1756.
1757.
1758.
1759.
1760.
1761.
1762.
1763.
1764.
1765.
1766.
1767.
1768.
1769.
1770.
1771.
1772.
1773.
1774.
1775.
1776.
1777.
1778.
1779.
1780.
1781.
1782.
1783.
1784.
1785.
1786.
1787.
1788.
1789.
1790.
1791.
1792.
1793.
1794.
1795.
1796.
1797.
1798.
1799.
1800.
1801.
1802.
1803.
1804.
1805.
1806.
1807.
1808.
1809.
1810.
1811.
1812.
1813.
1814.
1815.
1816.
1817.
1818.
1819.
1820.
1821.
1822.
1823.
1824.
1825.
1826.
1827.
1828.
1829.
1830.
1831.
1832.
1833.
1834.
1835.
1836.
1837.
1838.
1839.
1840.
1841.
1842.
1843.
1844.
1845.
1846.
1847.
1848.
1849.
1850.
1851.
1852.
1853.
1854.
1855.
1856.
1857.
1858.
1859.
1860.
1861.
1862.
1863.
1864.
1865.
1866.
1867.
1868.
1869.
1870.
1871.
1872.
1873.
1874.
1875.
1876.
1877.
1878.
1879.
1880.
1881.
1882.
1883.
1884.
1885.
1886.
1887.
1888.
1889.
1890.
1891.
1892.
1893.
1894.
1895.
1896.
1897.
1898.
1899.
1900.
1901.
1902.
1903.
1904.
1905.
1906.
1907.
1908.
1909.
1910.
1911.
1912.
1913.
1914.
1915.
1916.
1917.
1918.
1919.
1920.
1921.
1922.
1923.
1924.
1925.
1926.
1927.
1928.
1929.
1930.
1931.
1932.
1933.
1934.
1935.
1936.
1937.
1938.
1939.
1940.
1941.
1942.
1943.
1944.
1945.
1946.
1947.
1948.
1949.
1950.
1951.
1952.
1953.
1954.
1955.
1956.
1957.
1958.
1959.
1960.
1961.
1962.
1963.
1964.
1965.
1966.
1967.
1968.
1969.
1970.
1971.
1972.
1973.
1974.
1975.
1976.
1977.
1978.
1979.
1980.
1981.
1982.
1983.
1984.
1985.
1986.
1987.
1988.
1989.
1990.
1991.
1992.
1993.
1994.
1995.
1996.
1997.
1998.
1999.
2000.
2001.
2002.
2003.
2004.
2005.
2006.
2007.
2008.
2009.
2010.
2011.
2012.
2013.
2014.
2015.
2016.
2017.
2018.
2019.
2020.
2021.
2022.
2023.
2024.
2025.
2026.
2027.
2028.
2029.
2030.
2031.
2032.
2033.
2034.
2035.
2036.
2037.
2038.
2039.
2040.
2041.
2042.
2043.
2044.
2045.
2046.
2047.
2048.
2049.
2050.
2051.
2052.
2053.
2054.
2055.
2056.
2057.
2058.
2059.
2060.
2061.
2062.
2063.
2064.
2065.
2066.
2067.
2068.
2069.
2070.
2071.
2072.
2073.
2074.
2075.
2076.
2077.
2078.
2079.
2080.
2081.
2082.
2083.
2084.
2085.
2086.
2087.
2088.
2089.
2090.
2091.
2092.
2093.
2094.
2095.
2096.
2097.
2098.
2099.
2100.
2101.
2102.
2103.
2104.
2105.
2106.
2107.
2108.
2109.
2110.
2111.
2112.
2113.
2114.
2115.
2116.
2117.
2118.
2119.
2120.
2121.
2122.
2123.
2124.
2125.
2126.
2127.
2128.
2129.
2130.
2131.
2132.
2133.
2134.
2135.
2136.
2137.
2138.
2139.
2140.
2141.
2142.
2143.
2144.
2145.
2146.
2147.
2148.
2149.
2150.
2151.
2152.
2153.
2154.
2155.
2156.
2157.
2158.
2159.
2160.
2161.
2162.
2163.
2164.
2165.
2166.
2167.
2168.
2169.
2170.
2171.
2172.
2173.
2174.
2175.
2176.
2177.
2178.
2179.
2180.
2181.
2182.
2183.
2184.
2185.
2186.
2187.
2188.
2189.
2190.
2191.
2192.
2193.
2194.
2195.
2196.
2197.
2198.
2199.
2200.
2201.
2202.
2203.
2204.
2205.
2206.
2207.
2208.
2209.
2210.
2211.
2212.
2213.
2214.
2215.
2216.
2217.
2218.
2219.
2220.
2221.
2222.
2223.
2224.
2225.
2226.
2227.
2228.
2229.
2230.
2231.
2232.
2233.
2234.
2235.
2236.
2237.
2238.
2239.
2240.
2241.
2242.
2243.
2244.
2245.
2246.
2247.
2248.
2249.
2250.
2251.
2252.
2253.
2254.
2255.
2256.
2257.
2258.
2259.
2260.
2261.
2262.
2263.
2264.
2265.
2266.
2267.
2268.
2269.
2270.
2271.
2272.
2273.
2274.
2275.
2276.
2277.
2278.
2279.
2280.
2281.
2282.
2283.
2284.
2285.
2286.
2287.
2288.
2289.
2290.
2291.
2292.
2293.
2294.
2295.
2296.
2297.
2298.
2299.
2300.
2301.
2302.
2303.
2304.
2305.
2306.
2307.
2308.
2309.
2310.
2311.
2312.
2313.
2314.
2315.
2316.
2317.
2318.
2319.
2320.
2321.
2322.
2323.
2324.
2325.
2326.
2327.
2328.
2329.
2330.
2331.
2332.
2333.
2334.
2335.
2336.
2337.
2338.
2339.
2340.
2341.
2342.
2343.
2344.
2345.
2346.
2347.
2348.
2349.
2350.
2351.
2352.
2353.
2354.
2355.
2356.
2357.
2358.
2359.
2360.
2361.
2362.
2363.
2364.
2365.
2366.
2367.
2368.
2369.
2370.
2371.
2372.
2373.
2374.
2375.
2376.
2377.
2378.
2379.
2380.
2381.
2382.
2383.
2384.
2385.
2386.
2387.
2388.
2389.
2390.
2391.
2392.
2393.
2394.
2395.
2396.
2397.
2398.
2399.
2400.
2401.
2402.
2403.
2404.
2405.
2406.
2407.
2408.
2409.
2410.
2411.
2412.
2413.
2414.
2415.
2416.
2417.
2418.
2419.
2420.
2421.
2422.
2423.
2424.
2425.
2426.
2427.
2428.
2429.
2430.
2431.
2432.
2433.
2434.
2435.
2436.
2437.
2438.
2439.
2440.
2441.
2442.
2443.
2444.
2445.
2446.
2447.
2448.
2449.
2450.
2451.
2452.
2453.
2454.
2455.
2456.
2457.
2458.
2459.
2460.
2461.
2462.
2463.
2464.
2465.
2466.
2467.
2468.
2469.
2470.
2471.
2472.
2473.
2474.
2475.
2476.
2477.
2478.
2479.
2480.
2481.
2482.
2483.
2484.
2485.
2486.
2487.
2488.
2489.
2490.
2491.
2492.
2493.
2494.
2495.
2496.
2497.
2498.
2499.
2500.
2501.
2502.
2503.
2504.
2505.
2506.
2507.
2508.
2509.
2510.
2511.
2512.
2513.
2514.
2515.
2516.
2517.
2518.
2519.
2520.
2521.
2522.
2523.
2524.
2525.
2526.
2527.
2528.
2529.
2530.
2531.
2532.
2533.
2534.
2535.
2536.
2537.
2538.
2539.
2540.
2541.
2542.
2543.
2544.
2545.
2546.
2547.
2548.
2549.
2550.
2551.
2552.
2553.
2554.
2555.
2556.
2557.
2558.
2559.
2560.
2561.
2562.
2563.
2564.
2565.
2566.
2567.
2568.
2569.
2570.
2571.
2572.
2573.
2574.
2575.
2576.
2577.
2578.
2579.
2580.
2581.
2582.
2583.
2584.
2585.
2586.
2587.
2588.
2589.
2590.
2591.
2592.
2593.
2594.
2595.
2596.
2597.
2598.
2599.
2600.
2601.
2602.
2603.
2604.
2605.
2606.
2607.
2608.
2609.
2610.
2611.
2612.
2613.
2614.
2615.
2616.
2617.
2618.
2619.
2620.
2621.
2622.
2623.
2624.
2625.
2626.
2627.
2628.
2629.
2630.
2631.
2632.
2633.
2634.
2635.
2636.
2637.
2638.
2639.
2640.
2641.
2642.
2643.
2644.
2645.
2646.
2647.
2648.
2649.
2650.
2651.
2652.
2653.
2654.
2655.
2656.
2657.
2658.
2659.
2660.
2661.
2662.
2663.
2664.
2665.
2666.
2667.
2668.
2669.
2670.
2671.
2672.
2673.
2674.
2675.
2676.
2677.
2678.
2679.
2680.
2681.
2682.
2683.
2684.
2685.
2686.
2687.
2688.
2689.
2690.
2691.
2692.
2693.
2694.
2695.
2696.
2697.
2698.
2699.
2700.
2701.
2702.
2703.
2704.
2705.
2706.
2707.
2708.
2709.
2710.
2711.
2712.
2713.
2714.
2715.
2716.
2717.
2718.
2719.
2720.
2721.
2722.
2723.
2724.
2725.
2726.
2727.
2728.
2729.
2730.
2731.
2732.
2733.
2734.
2735.
2736.
2737.
2738.
2739.
2740.
2741.
2742.
2743.
2744.
2745.
2746.
2747.
2748.
2749.
2750.
2751.
2752.
2753.
2754.
2755.
2756.
2757.
2758.
2759.
2760.
2761.
2762.
2763.
2764.
2765.
2766.
2767.
2768.
2769.
2770.
2771.
2772.
2773.
2774.
2775.
2776.
2777.
2778.
2779.
2780.
2781.
2782.
2783.
2784.
2785.
2786.
2787.
2788.
2789.
2790.
2791.
2792.
2793.
2794.
2795.
2796.
2797.
2798.
2799.
2800.
2801.
2802.
2803.
2804.
2805.
2806.
2807.
2808.
2809.
2810.
2811.
2812.
2813.
2814.
2815.
2816.
2817.
2818.
2819.
2820.
2821.
2822.
2823.
2824.
2825.
2826.
2827.
2828.
2829.
2830.
2831.
2832.
2833.
2834.
2835.
2836.
2837.
2838.
2839.
2840.
2841.
2842.
2843.
2844.
2845.
2846.
2847.
2848.
2849.
2850.
2851.
2852.
2853.
2854.
2855.
2856.
2857.
2858.
2859.
2860.
2861.
2862.
2863.
2864.
2865.
2866.
2867.
2868.
2869.
2870.
2871.
2872.
2873.
2874.
2875.
2876.
2877.
2878.
2879.
2880.
2881.
2882.
2883.
2884.
2885.
2886.
2887.
2888.
2889.
2890.
2891.
2892.
2893.
2894.
2895.
2896.
2897.
2898.
2899.
2900.
2901.
2902.
2903.
2904.
2905.
2906.
2907.
2908.
2909.
2910.
2911.
2912.
2913.
2914.
2915.
2916.
2917.
2918.
2919.
2920.
2921.
2922.
2923.
2924.
2925.
2926.
2927.
2928.
2929.
2930.
2931.
2932.
2933.
2934.
2935.
2936.
2937.
2938.
2939.
2940.
2941.
2942.
2943.
2944.
2945.
2946.
2947.
2948.
2949.
2950.
2951.
2952.
2953.
2954.
2955.
2956.
2957.
2958.
2959.
2960.
2961.
2962.
2963.
2964.
2965.
2966.
2967.
2968.
2969.
2970.
2971.
2972.
2973.
2974.
2975.
2976.
2977.
2978.
2979.
2980.
2981.
2982.
2983.
2984.
2985.
2986.
2987.
2988.
2989.
2990.
2991.
2992.
2993.
2994.
2995.
2996.
2997.
2998.
2999.
3000.
3001.
3002.
3003.
3004.
3005.
3006.
3007.
3008.
3009.
3010.
3011.
3012.
3013.
3014.
3015.
3016.
3017.
3018.
3019.
3020.
3021.
3022.
3023.
3024.
3025.
3026.
3027.
3028.
3029.
3030.
3031.
3032.
3033.
3034.
3035.
3036.
3037.
3038.
3039.
3040.
3041.
3042.
3043.
3044.
3045.
3046.
3047.
3048.
3049.
3050.
3051.
3052.
3053.
3054.
3055.
3056.
3057.
3058.
3059.
3060.
3061.
3062.
3063.
3064.
3065.
3066.
3067.
3068.
3069.
3070.
3071.
3072.
3073.
3074.
3075.
3076.
3077.
3078.
3079.
3080.
3081.
3082.
3083.
3084.
3085.
3086.
3087.
3088.
3089.
3090.
3091.
3092.
3093.
3094.
3095.
3096.
3097.
3098.
3099.
3100.
3101.
3102.
3103.
3104.
3105.
3106.
3107.
3108.
3109.
3110.
3111.
3112.
3113.
3114.
3115.
3116.
3117.
3118.
3119.
3120.
3121.
3122.
3123.
3124.
3125.
3126.
3127.
3128.
3129.
3130.
3131.
3132.
3133.
3134.
3135.
3136.
3137.
3138.
3139.
3140.
3141.
3142.
3143.
3144.
3145.
3146.
3147.
3148.
3149.
3150.
3151.
3152.
3153.
3154.
3155.
3156.
3157.
3158.
3159.
3160.
3161.
3162.
3163.
3164.
3165.
3166.
3167.
3168.
3169.
3170.
3171.
3172.
3173.
3174.
3175.
3176.
3177.
3178.
3179.
3180.
3181.
3182.
3183.
3184.
3185.
3186.
3187.
3188.
3189.
3190.
3191.
3192.
3193.
3194.
3195.
3196.
3197.
3198.
3199.
3200.
3201.
3202.
3203.
3204.
3205.
3206.
3207.
3208.
3209.
3210.
3211.
3212.
3213.
3214.
3215.
3216.
3217.
3218.
3219.
3220.
3221.
3222.
3223.
3224.
3225.
3226.
3227.
3228.
3229.
3230.
3231.
3232.
3233.
3234.
3235.
3236.
3237.
3238.
3239.
3240.
3241.
3242.
3243.
3244.
3245.
3246.
3247.
3248.
3249.
3250.
3251.
3252.
3253.
3254.
3255.
3256.
3257.
3258.
3259.
3260.
3261.
3262.
3263.
3264.
3265.
3266.
3267.
3268.
3269.
3270.
3271.
3272.
3273.
3274.
3275.
3276.
3277.
3278.
3279.
3280.
3281.
3282.
3283.
3284.
3285.
3286.
3287.
3288.
3289.
3290.
3291.
3292.
3293.
3294.
3295.
3296.
3297.
3298.
3299.
3300.
3301.
3302.
3303.
3304.
3305.
3306.
3307.
3308.
3309.
3310.
3311.
3312.
3313.
3314.
3315.
3316.
3317.
3318.
3319.
3320.
3321.
3322.
3323.
3324.
3325.
3326.
3327.
3328.
3329.
3330.
3331.
3332.
3333.
3334.
3335.
3336.
3337.
3338.
3339.
3340.
3341.
3342.
3343.
3344.
3345.
3346.
3347.
3348.
3349.
3350.
3351.
3352.
3353.
3354.
3355.
3356.
3357.
3358.
3359.
3360.
3361.
3362.
3363.
3364.
3365.
3366.
3367.
3368.
3369.
3370.
3371.
3372.
3373.
3374.
3375.
3376.
3377.
3378.
3379.
3380.
3381.
3382.
3383.
3384.
3385.
3386.
3387.
3388.
3389.
3390.
3391.
3392.
3393.
3394.
3395.
3396.
3397.
3398.
3399.
3400.
3401.
3402.
3403.
3404.
3405.
3406.
3407.
3408.
3409.
3410.
3411.
3412.
3413.
3414.
3415.
3416.
3417.
3418.
3419.
3420.
3421.
3422.
3423.
3424.
3425.
3426.
3427.
3428.
3429.
3430.
3431.
3432.
3433.
3434.
3435.
3436.
3437.
3438.
3439.
3440.
3441.
3442.
3443.
3444.
3445.
3446.
3447.
3448.
3449.
3450.
3451.
3452.
3453.
3454.
3455.
3456.
3457.
3458.
3459.
3460.
3461.
3462.
3463.
3464.
3465.
3466.
3467.
3468.
3469.
3470.
3471.
3472.
3473.
3474.
3475.
3476.
3477.
3478.
3479.
3480.
3481.
3482.
3483.
3484.
3485.
3486.
3487.
3488.
3489.
3490.
3491.
3492.
3493.
3494.
3495.
3496.
3497.
3498.
3499.
3500.
3501.
3502.
3503.
3504.
3505.
3506.
3507.
3508.
3509.
3510.
3511.
3512.
3513.
3514.
3515.
3516.
3517.
3518.
3519.
3520.
3521.
3522.
3523.
3524.
3525.
3526.
3527.
3528.
3529.
3530.
3531.
3532.
3533.
3534.
3535.
3536.
3537.
3538.
3539.
3540.
3541.
3542.
3543.
3544.
3545.
3546.
3547.
3548.
3549.
3550.
3551.
3552.
3553.
3554.
3555.
3556.
3557.
3558.
3559.
3560.
3561.
3562.
3563.
3564.
3565.
3566.
3567.
3568.
3569.
3570.
3571.
3572.
3573.
3574.
3575.
3576.
3577.
3578.
3579.
3580.
3581.
3582.
3583.
3584.
3585.
3586.
3587.
3588.
3589.
3590.
3591.
3592.
3593.
3594.
3595.
3596.
3597.
3598.
3599.
3600.
3601.
3602.
3603.
3604.
3605.
3606.
3607.
3608.
3609.
3610.
3611.
3612.
3613.
3614.
3615.
3616.
3617.
3618.
3619.
3620.
3621.
3622.
3623.
3624.
3625.
3626.
3627.
3628.
3629.
3630.
3631.
3632.
3633.
3634.
3635.
3636.
3637.
3638.
3639.
3640.
3641.
3642.
3643.
3644.
3645.
3646.
3647.
3648.
3649.
3650.
3651.
3652.
3653.
3654.
3655.
3656.
3657.
3658.
3659.
3660.
3661.
3662.
3663.
3664.
3665.
3666.
3667.
3668.
3669.
3670.
3671.
3672.
3673.
3674.
3675.
3676.
3677.
3678.
3679.
3680.
3681.
3682.
3683.
3684.
3685.
3686.
3687.
3688.
3689.
3690.
3691.
3692.
3693.
3694.
3695.
3696.
3697.
3698.
3699.
3700.
3701.
3702.
3703.
3704.
3705.
3706.
3707.
3708.
3709.
3710.
3711.
3712.
3713.
3714.
3715.
3716.
3717.
3718.
3719.
3720.
3721.
3722.
3723.
3724.
3725.
3726.
3727.
3728.
3729.
3730.
3731.
3732.
3733.
3734.
3735.
3736.
3737.
3738.
3739.
3740.
3741.
3742.
3743.
3744.
3745.
3746.
3747.
3748.
3749.
3750.
3751.
3752.
3753.
3754.
3755.
3756.
3757.
3758.
3759.
3760.
3761.
3762.
3763.
3764.
3765.
3766.
3767.
3768.
3769.
3770.
3771.
3772.
3773.
3774.
3775.
3776.
3777.
3778.
3779.
3780.
3781.
3782.
3783.
3784.
3785.
3786.
3787.
3788.
3789.
3790.
3791.
3792.
3793.
3794.
3795.
3796.
3797.
3798.
3799.
3800.
3801.
3802.
3803.
3804.
3805.
3806.
3807.
3808.
3809.
3810.
3811.
3812.
3813.
3814.
3815.
3816.
3817.
3818.
3819.
3820.
3821.
3822.
3823.
3824.
3825.
3826.
3827.
3828.
3829.
3830.
3831.
3832.
3833.
3834.
3835.
3836.
3837.
3838.
3839.
3840.
3841.
3842.
3843.
3844.
3845.
3846.
3847.
3848.
3849.
3850.
3851.
3852.
3853.
3854.
3855.
3856.
3857.
3858.
3859.
3860.
3861.
3862.
3863.
3864.
3865.
3866.
3867.
3868.
3869.
3870.
3871.
3872.
3873.
3874.
3875.
3876.
3877.
3878.
3879.
3880.
3881.
3882.
3883.
3884.
3885.
3886.
3887.
3888.
3889.
3890.
3891.
3892.
3893.
3894.
3895.
3896.
3897.
3898.
3899.
3900.
3901.
3902.
3903.
3904.
3905.
3906.
3907.
3908.
3909.
3910.
3911.
3912.
3913.
3914.
3915.
3916.
3917.
3918.
3919.
3920.
3921.
3922.
3923.
3924.
3925.
3926.
3927.
3928.
3929.
3930.
3931.
3932.
3933.
3934.
3935.
3936.
3937.
3938.
3939.
3940.
3941.
3942.
3943.
3944.
3945.
3946.
3947.
3948.
3949.
3950.
3951.
3952.
3953.
3954.
3955.
3956.
3957.
3958.
3959.
3960.
3961.
3962.
3963.
3964.
3965.
3966.
3967.
3968.
3969.
3970.
3971.
3972.
3973.
3974.
3975.
3976.
3977.
3978.
3979.
3980.
3981.
3982.
3983.
3984.
3985.
3986.
3987.
3988.
3989.
3990.
3991.
3992.
3993.
3994.
3995.
3996.
3997.
3998.
3999.
4000.
4001.
4002.
4003.
4004.
4005.
4006.
4007.
4008.
4009.
4010.
4011.
4012.
4013.
4014.
4015.
4016.
4017.
4018.
4019.
4020.
4021.
4022.
4023.
4024.
4025.
4026.
4027.
4028.
4029.
4030.
4031.
4032.
4033.
4034.
4035.
4036.
4037.
4038.
4039.
4040.
4041.
4042.
4043.
4044.
4045.
4046.
4047.
4048.
4049.
4050.
4051.
4052.
4053.
4054.
4055.
4056.
4057.
4058.
4059.
4060.
4061.
4062.
4063.
4064.
4065.
4066.
4067.
4068.
4069.
4070.
4071.
4072.
4073.
4074.
4075.
4076.
4077.
4078.
4079.
4080.
4081.
4082.
4083.
4084.
4085.
4086.
4087.
4088.
4089.
4090.
4091.
4092.
4093.
4094.
4095.
4096.
4097.
4098.
4099.
4100.
4101.
4102.
4103.
4104.
4105.
4106.
4107.
4108.
4109.
4110.
4111.
4112.
4113.
4114.
4115.
4116.
4117.
4118.
4119.
4120.
4121.
4122.
4123.
4124.
4125.
4126.
4127.
4128.
4129.
4130.
4131.
4132.
4133.
4134.
4135.
4136.
4137.
4138.
4139.
4140.
4141.
4142.
4143.
4144.
4145.
4146.
4147.
4148.
4149.
4150.
4151.
4152.
4153.
4154.
4155.
4156.
4157.
4158.
4159.
4160.
4161.
4162.
4163.
4164.
4165.
4166.
4167.
4168.
4169.
4170.
4171.
4172.
4173.
4174.
4175.
4176.
4177.
4178.
4179.
4180.
4181.
4182.
4183.
4184.
4185.
4186.
4187.
4188.
4189.
4190.
4191.
4192.
4193.
4194.
4195.
4196.
4197.
4198.
4199.
4200.
4201.
4202.
4203.
4204.
4205.
4206.
4207.
4208.
4209.
4210.
4211.
4212.
4213.
4214.
4215.
4216.
4217.
4218.
4219.
4220.
4221.
4222.
4223.
4224.
4225.
4226.
4227.
4228.
4229.
4230.
4231.
4232.
4233.
4234.
4235.
4236.
4237.
4238.
4239.
4240.
4241.
4242.
4243.
4244.
4245.
4246.
4247.
4248.
4249.
4250.
4251.
4252.
4253.
4254.
4255.
4256.
4257.
4258.
4259.
4260.
4261.
4262.
4263.
4264.
4265.
4266.
4267.
4268.
4269.
4270.
4271.
4272.
4273.
4274.
4275.
4276.
4277.
4278.
4279.
4280.
4281.
4282.
4283.
4284.
4285.
4286.
4287.
4288.
4289.
4290.
4291.
4292.
4293.
4294.
4295.
4296.
4297.
4298.
4299.
4300.
4301.
4302.
4303.
4304.
4305.
4306.
4307.
4308.
4309.
4310.
4311.
4312.
4313.
4314.
4315.
4316.
4317.
4318.
4319.
4320.
4321.
4322.
4323.
4324.
4325.
4326.
4327.
4328.
4329.
4330.
4331.
4332.
4333.
4334.
4335.
4336.
4337.
4338.
4339.
4340.
4341.
4342.
4343.
4344.
4345.
4346.
4347.
4348.
4349.
4350.
4351.
4352.
4353.
4354.
4355.
4356.
4357.
4358.
4359.
4360.
4361.
4362.
4363.
4364.
4365.
4366.
4367.
4368.
4369.
4370.
4371.
4372.
4373.
4374.
4375.
4376.
4377.
4378.
4379.
4380.
4381.
4382.
4383.
4384.
4385.
4386.
4387.
4388.
4389.
4390.
4391.
4392.
4393.
4394.
4395.
4396.
4397.
4398.
4399.
4400.
4401.
4402.
4403.
4404.
4405.
4406.
4407.
4408.
4409.
4410.
4411.
4412.
4413.
4414.
4415.
4416.
4417.
4418.
4419.
4420.
4421.
4422.
4423.
4424.
4425.
4426.
4427.
4428.
4429.
4430.
4431.
4432.
4433.
4434.
4435.
4436.
4437.
4438.
4439.
4440.
4441.
4442.
4443.
4444.
4445.
4446.
4447.
4448.
4449.
4450.
4451.
4452.
4453.
4454.
4455.
4456.
4457.
4458.
4459.
4460.
4461.
4462.
4463.
4464.
4465.
4466.
4467.
4468.
4469.
4470.
4471.
4472.
4473.
4474.
4475.
4476.
4477.
4478.
4479.
4480.
4481.
4482.
4483.
4484.
4485.
4486.
4487.
4488.
4489.
4490.
4491.
4492.
4493.
4494.
4495.
4496.
4497.
4498.
4499.
4500.
4501.
4502.
4503.
4504.
4505.
4506.
4507.
4508.
4509.
4510.
4511.
4512.
4513.
4514.
4515.
4516.
4517.
4518.
4519.
4520.
4521.
4522.
4523.
4524.
4525.
4526.
4527.
4528.
4529.
4530.
4531.
4532.
4533.
4534.
4535.
4536.
4537.
4538.
4539.
4540.
4541.
4542.
4543.
4544.
4545.
4546.
4547.
4548.
4549.
4550.
4551.
4552.
4553.
4554.
4555.
4556.
4557.
4558.
4559.
4560.
4561.
4562.
4563.
4564.
4565.
4566.
4567.
4568.
4569.
4570.
4571.
4572.
4573.
4574.
4575.
4576.
4577.
4578.
4579.
4580.
4581.
4582.
4583.
4584.
4585.
4586.
4587.
4588.
4589.
4590.
4591.
4592.
4593.
4594.
4595.
4596.
4597.
4598.
4599.
4600.
4601.
4602.
4603.
4604.
4605.
4606.
4607.
4608.
4609.
4610.
4611.
4612.
4613.
4614.
4615.
4616.
4617.
4618.
4619.
4620.
4621.
4622.
4623.
4624.
4625.
4626.
4627.
4628.
4629.
4630.
4631.
4632.
4633.
4634.
4635.
4636.
4637.
4638.
4639.
4640.
4641.
4642.
4643.
4644.
4645.
4646.
4647.
4648.
4649.
4650.
4651.
4652.
4653.
4654.
4655.
4656.
4657.
4658.
4659.
4660.
4661.
4662.
4663.
4664.
4665.
4666.
4667.
4668.
4669.
4670.
4671.
4672.
4673.
4674.
4675.
4676.
4677.
4678.
4679.
4680.
4681.
4682.
4683.
4684.
4685.
4686.
4687.
4688.
4689.
4690.
4691.
4692.
4693.
4694.
4695.
4696.
4697.
4698.
4699.
4700.
4701.
4702.
4703.
4704.
4705.
4706.
4707.
4708.
4709.
4710.
4711.
4712.
4713.
4714.
4715.
4716.
4717.
4718.
4719.
4720.
4721.
4722.
4723.
4724.
4725.
4726.
4727.
4728.
4729.
4730.
4731.
4732.
4733.
4734.
4735.
4736.
4737.
4738.
4739.
4740.
4741.
4742.
4743.
4744.
4745.
4746.
4747.
4748.
4749.
4750.
4751.
4752.
4753.
4754.
4755.
4756.
4757.
4758.
4759.
4760.
4761.
4762.
4763.
4764.
4765.
4766.
4767.
4768.
4769.
4770.
4771.
4772.
4773.
4774.
4775.
4776.
4777.
4778.
4779.
4780.
4781.
4782.
4783.
4784.
4785.
4786.
4787.
4788.
4789.
4790.
4791.
4792.
4793.
4794.
4795.
4796.
4797.
4798.
4799.
4800.
4801.
4802.
4803.
4804.
4805.
4806.
4807.
4808.
4809.
4810.
4811.
4812.
4813.
4814.
4815.
4816.
4817.
4818.
4819.
4820.
4821.
4822.
4823.
4824.
4825.
4826.
4827.
4828.
4829.
4830.
4831.
4832.
4833.
4834.
4835.
4836.
4837.
4838.
4839.
4840.
4841.
4842.
4843.
4844.
4845.
4846.
4847.
4848.
4849.
4850.
4851.
4852.
4853.
4854.
4855.
4856.
4857.
4858.
4859.
4860.
4861.
4862.
4863.
4864.
4865.
4866.
4867.
4868.
4869.
4870.
4871.
4872.
4873.
4874.
4875.
4876.
4877.
4878.
4879.
4880.
4881.
4882.
4883.
4884.
4885.
4886.
4887.
4888.
4889.
4890.
4891.
4892.
4893.
4894.
4895.
4896.
4897.
4898.
4899.
4900.
4901.
4902.
4903.
4904.
4905.
4906.
4907.
4908.
4909.
4910.
4911.
4912.
4913.
4914.
4915.
4916.
4917.
4918.
4919.
4920.
4921.
4922.
4923.
4924.
4925.
4926.
4927.
4928.
4929.
4930.
4931.
4932.
4933.
4934.
4935.
4936.
4937.
4938.
4939.
4940.
4941.
4942.
4943.
4944.
4945.
4946.
4947.
4948.
4949.
4950.
4951.
4952.
4953.
4954.
4955.
4956.
4957.
4958.
4959.
4960.
4961.
4962.
4963.
4964.
4965.
4966.
4967.
4968.
4969.
4970.
4971.
4972.
4973.
4974.
4975.
4976.
4977.
4978.
4979.
4980.
4981.
4982.
4983.
4984.
4985.
4986.
4987.
4988.
4989.
4990.
4991.
4992.
4993.
4994.
4995.
4996.
4997.
4998.
4999.
5000.
5001.
5002.
5003.
5004.
5005.
5006.
5007.
5008.
5009.
5010.
5011.
5012.
5013.
5014.
5015.
5016.
5017.
5018.
5019.
5020.
5021.
5022.
5023.
5024.
5025.
5026.
5027.
5028.
5029.
5030.
5031.
5032.
5033.
5034.
5035.
5036.
5037.
5038.
5039.
5040.
5041.
5042.
5043.
5044.
5045.
5046.
5047.
5048.
5049.
5050.
5051.
5052.
5053.
5054.
5055.
5056.
5057.
5058.
5059.
5060.
5061.
5062.
5063.
5064.
5065.
5066.
5067.
5068.
5069.
5070.
5071.
5072.
5073.
5074.
5075.
5076.
5077.
5078.
5079.
5080.
5081.
5082.
5083.
5084.
5085.
5086.
5087.
5088.
5089.
5090.
5091.
5092.
5093.
5094.
5095.
5096.
5097.
5098.
5099.
5100.
5101.
5102.
5103.
5104.
5105.
5106.
5107.
5108.
5109.
5110.
5111.
5112.
5113.
5114.
5115.
5116.
5117.
5118.
5119.
5120.
5121.
5122.
5123.
5124.
5125.
5126.
5127.
5128.
5129.
5130.
5131.
5132.
5133.
5134.
5135.
5136.
5137.
5138.
5139.
5140.
5141.
5142.
5143.
5144.
5145.
5146.
5147.
5148.
5149.
5150.
5151.
5152.
5153.
5154.
5155.
5156.
5157.
5158.
5159.
5160.
5161.
5162.
5163.
5164.
5165.
5166.
5167.
5168.
5169.
5170.
5171.
5172.
5173.
5174.
5175.
5176.
5177.
5178.
5179.
5180.
5181.
5182.
5183.
5184.
5185.
5186.
5187.
5188.
5189.
5190.
5191.
5192.
5193.
5194.
5195.
5196.
5197.
5198.
5199.
5200.
5201.
5202.
5203.
5204.
5205.
5206.
5207.
5208.
5209.
5210.
5211.
5212.
5213.
5214.
5215.
5216.
5217.
5218.
5219.
5220.
5221.
5222.
5223.
5224.
5225.
5226.
5227.
5228.
5229.
5230.
5231.
5232.
5233.
5234.
5235.
5236.
5237.
5238.
5239.
5240.
5241.
5242.
5243.
5244.
5245.
5246.
5247.
5248.
5249.
5250.
5251.
5252.
5253.
5254.
5255.
5256.
5257.
5258.
5259.
5260.
5261.
5262.
5263.
5264.
5265.
5266.
5267.
5268.
5269.
5270.
5271.
5272.
5273.
5274.
5275.
5276.
5277.
5278.
5279.
5280.
5281.
5282.
5283.
5284.
5285.
5286.
5287.
5288.
5289.
5290.
5291.
5292.
5293.
5294.
5295.
5296.
5297.
5298.
5299.
5300.
5301.
5302.
5303.
5304.
5305.
5306.
5307.
5308.
5309.
5310.
5311.
5312.
5313.
5314.
5315.
5316.
5317.
5318.
5319.
5320.
5321.
5322.
5323.
5324.
5325.
5326.
5327.
5328.
5329.
5330.
5331.
5332.
5333.
5334.
5335.
5336.
5337.
5338.
5339.
5340.
5341.
5342.
5343.
5344.
5345.
5346.
5347.
5348.
5349.
5350.
5351.
5352.
5353.
5354.
5355.
5356.
5357.
5358.
5359.
5360.
5361.
5362.
5363.
5364.
5365.
5366.
5367.
5368.
5369.
5370.
5371.
5372.
5373.
5374.
5375.
5376.
5377.
5378.
5379.
5380.
5381.
5382.
5383.
5384.
5385.
5386.
5387.
5388.
5389.
5390.
5391.
5392.
5393.
5394.
5395.
5396.
5397.
5398.
5399.
5400.
5401.
5402.
5403.
5404.
5405.
5406.
5407.
5408.
5409.
5410.
5411.
5412.
5413.
5414.
5415.
5416.
5417.
5418.
5419.
5420.
5421.
5422.
5423.
5424.
5425.
5426.
5427.
5428.
5429.
5430.
5431.
5432.
5433.
5434.
5435.
5436.
5437.
5438.
5439.
5440.
5441.
5442.
5443.
5444.
5445.
5446.
5447.
5448.
5449.
5450.
5451.
5452.
5453.
5454.
5455.
5456.
5457.
5458.
5459.
5460.
5461.
5462.
5463.
5464.
5465.
5466.
5467.
5468.
5469.
5470.
5471.
5472.
5473.
5474.
5475.
5476.
5477.
5478.
5479.
5480.
5481.
5482.
5483.
5484.
5485.
5486.
5487.
5488.
5489.
5490.
5491.
5492.
5493.
5494.
5495.
5496.
5497.
5498.
5499.
5500.
5501.
5502.
5503.
5504.
5505.
5506.
5507.
5508.
5509.
5510.
5511.
5512.
5513.
5514.
5515.
5516.
5517.
5518.
5519.
5520.
5521.
5522.
5523.
5524.
5525.
5526.
5527.
5528.
5529.
5530.
5531.
5532.
5533.
5534.
5535.
5536.
5537.
5538.
5539.
5540.
5541.
5542.
5543.
5544.
5545.
5546.
5547.
5548.
5549.
5550.
5551.
5552.
5553.
5554.
5555.
5556.
5557.
5558.
5559.
5560.
5561.
5562.
5563.
5564.
5565.
5566.
5567.
5568.
5569.
5570.
5571.
5572.
5573.
5574.
5575.
5576.
5577.
5578.
5579.
5580.
5581.
5582.
5583.
5584.
5585.
5586.
5587.
5588.
5589.
5590.
5591.
5592.
5593.
5594.
5595.
5596.
5597.
5598.
5599.
5600.
5601.
5602.
5603.
5604.
5605.
5606.
5607.
5608.
5609.
5610.
5611.
5612.
5613.
5614.
5615.
5616.
5617.
5618.
5619.
5620.
5621.
5622.
5623.
5624.
5625.
5626.
5627.
5628.
5629.
5630.
5631.
5632.
5633.
5634.
5635.
5636.
5637.
5638.
5639.
5640.
5641.
5642.
5643.
5644.
5645.
5646.
5647.
5648.
5649.
5650.
5651.
5652.
5653.
5654.
5655.
5656.
5657.
5658.
5659.
5660.
5661.
5662.
5663.
5664.
5665.
5666.
5667.
5668.
5669.
5670.
5671.
5672.
5673.
5674.
5675.
5676.
5677.
5678.
5679.
5680.
5681.
5682.
5683.
5684.
5685.
5686.
5687.
5688.
5689.
5690.
5691.
5692.
5693.
5694.
5695.
5696.
5697.
5698.
5699.
5700.
5701.
5702.
5703.
5704.
5705.
5706.
5707.
5708.
5709.
5710.
5711.
5712.
5713.
5714.
5715.
5716.
5717.
5718.
5719.
5720.
5721.
5722.
5723.
5724.
5725.
5726.
5727.
5728.
5729.
5730.
5731.
5732.
5733.
5734.
5735.
5736.
5737.
5738.
5739.
5740.
5741.
5742.
5743.
5744.
5745.
5746.
5747.
5748.
5749.
5750.
5751.
5752.
5753.
5754.
5755.
5756.
5757.
5758.
5759.
5760.
5761.
5762.
5763.
5764.
5765.
5766.
5767.
5768.
5769.
5770.
5771.
5772.
5773.
5774.
5775.
5776.
5777.
5778.
5779.
5780.
5781.
5782.
5783.
5784.
5785.
5786.
5787.
5788.
5789.
5790.
5791.
5792.
5793.
5794.
5795.
5796.
5797.
5798.
5799.
5800.
5801.
5802.
5803.
5804.
5805.
5806.
5807.
5808.
5809.
5810.
5811.
5812.
5813.
5814.
5815.
5816.
5817.
5818.
5819.
5820.
5821.
5822.
5823.
5824.
5825.
5826.
5827.
5828.
5829.
5830.
5831.
5832.
5833.
5834.
5835.
5836.
5837.
5838.
5839.
5840.
5841.
5842.
5843.
5844.
5845.
5846.
5847.
5848.
5849.
5850.
5851.
5852.
5853.
5854.
5855.
5856.
5857.
5858.
5859.
5860.
5861.
5862.
5863.
5864.
5865.
5866.
5867.
5868.
5869.
5870.
5871.
5872.
5873.
5874.
5875.
5876.
5877.
5878.
5879.
5880.
5881.
5882.
5883.
5884.
5885.
5886.
5887.
5888.
5889.
5890.
5891.
5892.
5893.
5894.
5895.
5896.
5897.
5898.
5899.
5900.
5901.
5902.
5903.
5904.
5905.
5906.
5907.
5908.
5909.
5910.
5911.
5912.
5913.
5914.
5915.
5916.
5917.
5918.
5919.
5920.
5921.
5922.
5923.
5924.
5925.
5926.
5927.
5928.
5929.
5930.
5931.
5932.
5933.
5934.
5935.
5936.
5937.
5938.
5939.
5940.
5941.
5942.
5943.
5944.
5945.
5946.
5947.
5948.
5949.
5950.
5951.
5952.
5953.
5954.
5955.
5956.
5957.
5958.
5959.
5960.
5961.
5962.
5963.
5964.
5965.
5966.
5967.
5968.
5969.
5970.
5971.
5972.
5973.
5974.
5975.
5976.
5977.
5978.
5979.
5980.
5981.
5982.
5983.
5984.
5985.
5986.
5987.
5988.
5989.
5990.
5991.
5992.
5993.
5994.
5995.
5996.
5997.
5998.
5999.
6000.
6001.
6002.
6003.
6004.
6005.
6006.
6007.
6008.
6009.
6010.
6011.
6012.
6013.
6014.
6015.
6016.
6017.
6018.
6019.
6020.
6021.
6022.
6023.
6024.
6025.
6026.
6027.
6028.
6029.
6030.
6031.
6032.
6033.
6034.
6035.
6036.
6037.
6038.
6039.
6040.
6041.
6042.
6043.
6044.
6045.
6046.
6047.
6048.
6049.
6050.
6051.
6052.
6053.
6054.
6055.
6056.
6057.
6058.
6059.
6060.
6061.
6062.
6063.
6064.
6065.
6066.
6067.
6068.
6069.
6070.
6071.
6072.
6073.
6074.
6075.
6076.
6077.
6078.
6079.
6080.
6081.
6082.
6083.
6084.
6085.
6086.
6087.
6088.
6089.
6090.
6091.
6092.
6093.
6094.
6095.
6096.
6097.
6098.
6099.
6100.
6101.
6102.
6103.
6104.
6105.
6106.
6107.
6108.
6109.
6110.
6111.
6112.
6113.
6114.
6115.
6116.
6117.
6118.
6119.
6120.
6121.
6122.
6123.
6124.
6125.
6126.
6127.
6128.
6129.
6130.
6131.
6132.
6133.
6134.
6135.
6136.
6137.
6138.
6139.
6140.
6141.
6142.
6143.
6144.
6145.
6146.
6147.
6148.
6149.
6150.
6151.
6152.
6153.
6154.
6155.
6156.
6157.
6158.
6159.
6160.
6161.
6162.
6163.
6164.
6165.
6166.
6167.
6168.
6169.
6170.
6171.
6172.
6173.
6174.
6175.
6176.
6177.
6178.
6179.
6180.
6181.
6182.
6183.
6184.
6185.
6186.
6187.
6188.
6189.
6190.
6191.
6192.
6193.
6194.
6195.
6196.
6197.
6198.
6199.
6200.
6201.
6202.
6203.
6204.
6205.
6206.
6207.
6208.
6209.
6210.
6211.
6212.
6213.
6214.
6215.
6216.
6217.
6218.
6219.
6220.
6221.
6222.
6223.
6224.
6225.
6226.
6227.
6228.
6229.
6230.
6231.
6232.
6233.
6234.
6235.
6236.
6237.
6238.
6239.
6240.
6241.
6242.
6243.
6244.
6245.
6246.
6247.
6248.
6249.
6250.
6251.
6252.
6253.
6254.
6255.
6256.
6257.
6258.
6259.
6260.
6261.
6262.
6263.
6264.
6265.
6266.
6267.
6268.
6269.
6270.
6271.
6272.
6273.
6274.
6275.
6276.
6277.
6278.
6279.
6280.
6281.
6282.
6283.
6284.
6285.
6286.
6287.
6288.
6289.
6290.
6291.
6292.
6293.
6294.
6295.
6296.
6297.
6298.
6299.
6300.
6301.
6302.
6303.
6304.
6305.
6306.
6307.
6308.
6309.
6310.
6311.
6312.
6313.
6314.
6315.
6316.
6317.
6318.
6319.
6320.
6321.
6322.
6323.
6324.
6325.
6326.
6327.
6328.
6329.
6330.
6331.
6332.
6333.
6334.
6335.
6336.
6337.
6338.
6339.
6340.
6341.
6342.
6343.
6344.
6345.
6346.
6347.
6348.
6349.
6350.
6351.
6352.
6353.
6354.
6355.
6356.
6357.
6358.
6359.
6360.
6361.
6362.
6363.
6364.
6365.
6366.
6367.
6368.
6369.
6370.
6371.
6372.
6373.
6374.
6375.
6376.
6377.
6378.
6379.
6380.
6381.
6382.
6383.
6384.
6385.
6386.
6387.
6388.
6389.
6390.
6391.
6392.
6393.
6394.
6395.
6396.
6397.
6398.
6399.
6400.
6401.
6402.
6403.
6404.
6405.
6406.
6407.
6408.
6409.
6410.
6411.
6412.
6413.
6414.
6415.
6416.
6417.
6418.
6419.
6420.
6421.
6422.
6423.
6424.
6425.
6426.
6427.
6428.
6429.
6430.
6431.
6432.
6433.
6434.
6435.
6436.
6437.
6438.
6439.
6440.
6441.
6442.
6443.
6444.
6445.
6446.
6447.
6448.
6449.
6450.
6451.
6452.
6453.
6454.
6455.
6456.
6457.
6458.
6459.
6460.
6461.
6462.
6463.
6464.
6465.
6466.
6467.
6468.
6469.
6470.
6471.
6472.
6473.
6474.
6475.
6476.
6477.
6478.
6479.
6480.
6481.
6482.
6483.
6484.
6485.
6486.
6487.
6488.
6489.
6490.
6491.
6492.
6493.
6494.
6495.
6496.
6497.
6498.
6499.
6500.
6501.
6502.
6503.
6504.
6505.
6506.
6507.
6508.
6509.
6510.
6511.
6512.
6513.
6514.
6515.
6516.
6517.
6518.
6519.
6520.
6521.
6522.
6523.
6524.
6525.
6526.
6527.
6528.
6529.
6530.
6531.
6532.
6533.
6534.
6535.
6536.
6537.
6538.
6539.
6540.
6541.
6542.
6543.
6544.
6545.
6546.
6547.
6548.
6549.
6550.
6551.
6552.
6553.
6554.
6555.
6556.
6557.
6558.
6559.
6560.
6561.
6562.
6563.
6564.
6565.
6566.
6567.
6568.
6569.
6570.
6571.
6572.
6573.
6574.
6575.
6576.
6577.
6578.
6579.
6580.
6581.
6582.
6583.
6584.
6585.
6586.
6587.
6588.
6589.
6590.
6591.
6592.
6593.
6594.
6595.
6596.
6597.
6598.
6599.
6600.
6601.
6602.
6603.
6604.
6605.
6606.
6607.
6608.
6609.
6610.
6611.
6612.
6613.
6614.
6615.
6616.
6617.
6618.
6619.
6620.
6621.
6622.
6623.
6624.
6625.
6626.
6627.
6628.
6629.
6630.
6631.
6632.
6633.
6634.
6635.
6636.
6637.
6638.
6639.
6640.
6641.
6642.
6643.
6644.
6645.
6646.
6647.
6648.
6649.
6650.
6651.
6652.
6653.
6654.
6655.
6656.
6657.
6658.
6659.
6660.
6661.
6662.
6663.
6664.
6665.
6666.
6667.
6668.
6669.
6670.
6671.
6672.
6673.
6674.
6675.
6676.
6677.
6678.
6679.
6680.
6681.
6682.
6683.
6684.
6685.
6686.
6687.
6688.
6689.
6690.
6691.
6692.
6693.
6694.
6695.
6696.
6697.
6698.
6699.
6700.
6701.
6702.
6703.
6704.
6705.
6706.
6707.
6708.
6709.
6710.
6711.
6712.
6713.
6714.
6715.
6716.
6717.
6718.
6719.
6720.
6721.
6722.
6723.
6724.
6725.
6726.
6727.
6728.
6729.
6730.
6731.
6732.
6733.
6734.
6735.
6736.
6737.
6738.
6739.
6740.
6741.
6742.
6743.
6744.
6745.
6746.
6747.
6748.
6749.
6750.
6751.
6752.
6753.
6754.
6755.
6756.
6757.
6758.
6759.
6760.
6761.
6762.
6763.
6764.
6765.
6766.
6767.
6768.
6769.
6770.
6771.
6772.
6773.
6774.
6775.
6776.
6777.
6778.
6779.
6780.
6781.
6782.
6783.
6784.
6785.
6786.
6787.
6788.
6789.
6790.
6791.
6792.
6793.
6794.
6795.
6796.
6797.
6798.
6799.
6800.
6801.
6802.
6803.
6804.
6805.
6806.
6807.
6808.
6809.
6810.
6811.
6812.
6813.
6814.
6815.
6816.
6817.
6818.
6819.
6820.
6821.
6822.
6823.
6824.
6825.
6826.
6827.
6828.
6829.
6830.
6831.
6832.
6833.
6834.
6835.
6836.
6837.
6838.
6839.
6840.
6841.
6842.
6843.
6844.
6845.
6846.
6847.
6848.
6849.
6850.
6851.
6852.
6853.
6854.
6855.
6856.
6857.
6858.
6859.
6860.
6861.
6862.
6863.
6864.
6865.
6866.
6867.
6868.
6869.
6870.
6871.
6872.
6873.
6874.
6875.
6876.
6877.
6878.
6879.
6880.
6881.
6882.
6883.
6884.
6885.
6886.
6887.
6888.
6889.
6890.
6891.
6892.
6893.
6894.
6895.
6896.
6897.
6898.
6899.
6900.
6901.
6902.
6903.
6904.
6905.
6906.
6907.
6908.
6909.
6910.
6911.
6912.
6913.
6914.
6915.
6916.
6917.
6918.
6919.
6920.
6921.
6922.
6923.
6924.
6925.
6926.
6927.
6928.
6929.
6930.
6931.
6932.
6933.
6934.
6935.
6936.
6937.
6938.
6939.
6940.
6941.
6942.
6943.
6944.
6945.
6946.
6947.
6948.
6949.
6950.
6951.
6952.
6953.
6954.
6955.
6956.
6957.
6958.
6959.
6960.
6961.
6962.
6963.
6964.
6965.
6966.
6967.
6968.
6969.
6970.
6971.
6972.
6973.
6974.
6975.
6976.
6977.
6978.
6979.
6980.
6981.
6982.
6983.
6984.
6985.
6986.
6987.
6988.
6989.
6990.
6991.
6992.
6993.
6994.
6995.
6996.
6997.
6998.
6999.
7000.
7001.
7002.
7003.
7004.
7005.
7006.
7007.
7008.
7009.
7010.
7011.
7012.
7013.
7014.
7015.
7016.
7017.
7018.
7019.
7020.
7021.
7022.
7023.
7024.
7025.
7026.
7027.
7028.
7029.
7030.
7031.
7032.
7033.
7034.
7035.
7036.
7037.
7038.
7039.
7040.
7041.
7042.
7043.
7044.
7045.
7046.
7047.
7048.
7049.
7050.
7051.
7052.
7053.
7054.
7055.
7056.
7057.
7058.
7059.
7060.
7061.
7062.
7063.
7064.
7065.
7066.
7067.
7068.
7069.
7070.
7071.
7072.
7073.
7074.
7075.
7076.
7077.
7078.
7079.
7080.
7081.
7082.
7083.
7084.
7085.
7086.
7087.
7088.
7089.
7090.
7091.
7092.
7093.
7094.
7095.
7096.
7097.
7098.
7099.
7100.
7101.
7102.
7103.
7104.
7105.
7106.
7107.
7108.
7109.
7110.
7111.
7112.
7113.
7114.
7115.
7116.
7117.
7118.
7119.
7120.
7121.
7122.
7123.
7124.
7125.
7126.
7127.
7128.
7129.
7130.
7131.
7132.
7133.
7134.
7135.
7136.
7137.
7138.
7139.
7140.
7141.
7142.
7143.
7144.
7145.
7146.
7147.
7148.
7149.
7150.
7151.
7152.
7153.
7154.
7155.
7156.
7157.
7158.
7159.
7160.
7161.
7162.
7163.
7164.
7165.
7166.
7167.
7168.
7169.
7170.
7171.
7172.
7173.
7174.
7175.
7176.
7177.
7178.
7179.
7180.
7181.
7182.
7183.
7184.
7185.
7186.
7187.
7188.
7189.
7190.
7191.
7192.
7193.
7194.
7195.
7196.
7197.
7198.
7199.
7200.
7201.
7202.
7203.
7204.
7205.
7206.
7207.
7208.
7209.
7210.
7211.
7212.
7213.
7214.
7215.
7216.
7217.
7218.
7219.
7220.
7221.
7222.
7223.
7224.
7225.
7226.
7227.
7228.
7229.
7230.
7231.
7232.
7233.
7234.
7235.
7236.
7237.
7238.
7239.
7240.
7241.
7242.
7243.
7244.
7245.
7246.
7247.
7248.
7249.
7250.
7251.
7252.
7253.
7254.
7255.
7256.
7257.
7258.
7259.
7260.
7261.
7262.
7263.
7264.
7265.
7266.
7267.
7268.
7269.
7270.
7271.
7272.
7273.
7274.
7275.
7276.
7277.
7278.
7279.
7280.
7281.
7282.
7283.
7284.
7285.
7286.
7287.
7288.
7289.
7290.
7291.
7292.
7293.
7294.
7295.
7296.
7297.
7298.
7299.
7300.
7301.
7302.
7303.
7304.
7305.
7306.
7307.
7308.
7309.
7310.
7311.
7312.
7313.
7314.
7315.
7316.
7317.
7318.
7319.
7320.
7321.
7322.
7323.
7324.
7325.
7326.
7327.
7328.
7329.
7330.
7331.
7332.
7333.
7334.
7335.
7336.
7337.
7338.
7339.
7340.
7341.
7342.
7343.
7344.
7345.
7346.
7347.
7348.
7349.
7350.
7351.
7352.
7353.
7354.
7355.
7356.
7357.
7358.
7359.
7360.
7361.
7362.
7363.
7364.
7365.
7366.
7367.
7368.
7369.
7370.
7371.
7372.
7373.
7374.
7375.
7376.
7377.
7378.
7379.
7380.
7381.
7382.
7383.
7384.
7385.
7386.
7387.
7388.
7389.
7390.
7391.
7392.
7393.
7394.
7395.
7396.
7397.
7398.
7399.
7400.
7401.
7402.
7403.
7404.
7405.
7406.
7407.
7408.
7409.
7410.
7411.
7412.
7413.
7414.
7415.
7416.
7417.
7418.
7419.
7420.
7421.
7422.
7423.
7424.
7425.
7426.
7427.
7428.
7429.
7430.
7431.
7432.
7433.
7434.
7435.
7436.
7437.
7438.
7439.
7440.
7441.
7442.
7443.
7444.
7445.
7446.
7447.
7448.
7449.
7450.
7451.
7452.
7453.
7454.
7455.
7456.
7457.
7458.
7459.
7460.
7461.
7462.
7463.
7464.
7465.
7466.
7467.
7468.
7469.
7470.
7471.
7472.
7473.
7474.
7475.
7476.
7477.
7478.
7479.
7480.
7481.
7482.
7483.
7484.
7485.
7486.
7487.
7488.
7489.
7490.
7491.
7492.
7493.
7494.
7495.
7496.
7497.
7498.
7499.
7500.
7501.
7502.
7503.
7504.
7505.
7506.
7507.
7508.
7509.
7510.
7511.
7512.
7513.
7514.
7515.
7516.
7517.
7518.
7519.
7520.
7521.
7522.
7523.
7524.
7525.
7526.
7527.
7528.
7529.
7530.
7531.
7532.
7533.
7534.
7535.
7536.
7537.
7538.
7539.
7540.
7541.
7542.
7543.
7544.
7545.
7546.
7547.
7548.
7549.
7550.
7551.
7552.
7553.
7554.
7555.
7556.
7557.
7558.
7559.
7560.
7561.
7562.
7563.
7564.
7565.
7566.
7567.
7568.
7569.
7570.
7571.
7572.
7573.
7574.
7575.
7576.
7577.
7578.
7579.
7580.
7581.
7582.
7583.
7584.
7585.
7586.
7587.
7588.
7589.
7590.
7591.
7592.
7593.
7594.
7595.
7596.
7597.
7598.
7599.
7600.
7601.
7602.
7603.
7604.
7605.
7606.
7607.
7608.
7609.
7610.
7611.
7612.
7613.
7614.
7615.
7616.
7617.
7618.
7619.
7620.
7621.
7622.
7623.
7624.
7625.
7626.
7627.
7628.
7629.
7630.
7631.
7632.
7633.
7634.
7635.
7636.
7637.
7638.
7639.
7640.
7641.
7642.
7643.
7644.
7645.
7646.
7647.
7648.
7649.
7650.
7651.
7652.
7653.
7654.
7655.
7656.
7657.
7658.
7659.
7660.
7661.
7662.
7663.
7664.
7665.
7666.
7667.
7668.
7669.
7670.
7671.
7672.
7673.
7674.
7675.
7676.
7677.
7678.
7679.
7680.
7681.
7682.
7683.
7684.
7685.
7686.
7687.
7688.
7689.
7690.
7691.
7692.
7693.
7694.
7695.
7696.
7697.
7698.
7699.
7700.
7701.
7702.
7703.
7704.
7705.
7706.
7707.
7708.
7709.
7710.
7711.
7712.
7713.
7714.
7715.
7716.
7717.
7718.
7719.
7720.
7721.
7722.
7723.
7724.
7725.
7726.
7727.
7728.
7729.
7730.
7731.
7732.
7733.
7734.
7735.
7736.
7737.
7738.
7739.
7740.
7741.
7742.
7743.
7744.
7745.
7746.
7747.
7748.
7749.
7750.
7751.
7752.
7753.
7754.
7755.
7756.
7757.
7758.
7759.
7760.
7761.
7762.
7763.
7764.
7765.
7766.
7767.
7768.
7769.
7770.
7771.
7772.
7773.
7774.
7775.
7776.
7777.
7778.
7779.
7780.
7781.
7782.
7783.
7784.
7785.
7786.
7787.
7788.
7789.
7790.
7791.
7792.
7793.
7794.
7795.
7796.
7797.
7798.
7799.
7800.
7801.
7802.
7803.
7804.
7805.
7806.
7807.
7808.
7809.
7810.
7811.
7812.
7813.
7814.
7815.
7816.
7817.
7818.
7819.
7820.
7821.
7822.
7823.
7824.
7825.
7826.
7827.
7828.
7829.
7830.
7831.
7832.
7833.
7834.
7835.
7836.
7837.
7838.
7839.
7840.
7841.
7842.
7843.
7844.
7845.
7846.
7847.
7848.
7849.
7850.
7851.
7852.
7853.
7854.
7855.
7856.
7857.
7858.
7859.
7860.
7861.
7862.
7863.
7864.
7865.
7866.
7867.
7868.
7869.
7870.
7871.
7872.
7873.
7874.
7875.
7876.
7877.
7878.
7879.
7880.
7881.
7882.
7883.
7884.
7885.
7886.
7887.
7888.
7889.
7890.
7891.
7892.
7893.
7894.
7895.
7896.
7897.
7898.
7899.
7900.
7901.
7902.
7903.
7904.
7905.
7906.
7907.
7908.
7909.
7910.
7911.
7912.
7913.
7914.
7915.
7916.
7917.
7918.
7919.
7920.
7921.
7922.
7923.
7924.
7925.
7926.
7927.
7928.
7929.
7930.
7931.
7932.
7933.
7934.
7935.
7936.
7937.
7938.
7939.
7940.
7941.
7942.
7943.
7944.
7945.
7946.
7947.
7948.
7949.
7950.
7951.
7952.
7953.
7954.
7955.
7956.
7957.
7958.
7959.
7960.
7961.
7962.
7963.
7964.
7965.
7966.
7967.
7968.
7969.
7970.
7971.
7972.
7973.
7974.
7975.
7976.
7977.
7978.
7979.
7980.
7981.
7982.
7983.
7984.
7985.
7986.
7987.
7988.
7989.
7990.
7991.
7992.
7993.
7994.
7995.
7996.
7997.
7998.
7999.
8000.
8001.
8002.
8003.
8004.
8005.
8006.
8007.
8008.
8009.
8010.
8011.
8012.
8013.
8014.
8015.
8016.
8017.
8018.
8019.
8020.
8021.
8022.
8023.
8024.
8025.
8026.
8027.
8028.
8029.
8030.
8031.
8032.
8033.
8034.
8035.
8036.
8037.
8038.
8039.
8040.
8041.
8042.
8043.
8044.
8045.
8046.
8047.
8048.
8049.
8050.
8051.
8052.
8053.
8054.
8055.
8056.
8057.
8058.
8059.
8060.
8061.
8062.
8063.
8064.
8065.
8066.
8067.
8068.
8069.
8070.
8071.
8072.
8073.
8074.
8075.
8076.
8077.
8078.
8079.
8080.
8081.
8082.
8083.
8084.
8085.
8086.
8087.
8088.
8089.
8090.
8091.
8092.
8093.
8094.
8095.
8096.
8097.
8098.
8099.
8100.
8101.
8102.
8103.
8104.
8105.
8106.
8107.
8108.
8109.
8110.
8111.
8112.
8113.
8114.
8115.
8116.
8117.
8118.
8119.
8120.
8121.
8122.
8123.
8124.
8125.
8126.
8127.
8128.
8129.
8130.
8131.
8132.
8133.
8134.
8135.
8136.
8137.
8138.
8139.
8140.
8141.
8142.
8143.
8144.
8145.
8146.
8147.
8148.
8149.
8150.
8151.
8152.
8153.
8154.
8155.
8156.
8157.
8158.
8159.
8160.
8161.
8162.
8163.
8164.
8165.
8166.
8167.
8168.
8169.
8170.
8171.
8172.
8173.
8174.
8175.
8176.
8177.
8178.
8179.
8180.
8181.
8182.
8183.
8184.
8185.
8186.
8187.
8188.
8189.
8190.
8191.
8192.
8193.
8194.
8195.
8196.
8197.
8198.
8199.
8200.
8201.
8202.
8203.
8204.
8205.
8206.
8207.
8208.
8209.
8210.
8211.
8212.
8213.
8214.
8215.
8216.
8217.
8218.
8219.
8220.
8221.
8222.
8223.
8224.
8225.
8226.
8227.
8228.
8229.
8230.
8231.
8232.
8233.
8234.
8235.
8236.
8237.
8238.
8239.
8240.
8241.
8242.
8243.
8244.
8245.
8246.
8247.
8248.
8249.
8250.
8251.
8252.
8253.
8254.
8255.
8256.
8257.
8258.
8259.
8260.
8261.
8262.
8263.
8264.
8265.
8266.
8267.
8268.
8269.
8270.
8271.
8272.
8273.
8274.
8275.
8276.
8277.
8278.
8279.
8280.
8281.
8282.
8283.
8284.
8285.
8286.
8287.
8288.
8289.
8290.
8291.
8292.
8293.
8294.
8295.
8296.
8297.
8298.
8299.
8300.
8301.
8302.
8303.
8304.
8305.
8306.
8307.
8308.
8309.
8310.
8311.
8312.
8313.
8314.
8315.
8316.
8317.
8318.
8319.
8320.
8321.
8322.
8323.
8324.
8325.
8326.
8327.
8328.
8329.
8330.
8331.
8332.
8333.
8334.
8335.
8336.
8337.
8338.
8339.
8340.
8341.
8342.
8343.
8344.
8345.
8346.
8347.
8348.
8349.
8350.
8351.
8352.
8353.
8354.
8355.
8356.
8357.
8358.
8359.
8360.
8361.
8362.
8363.
8364.
8365.
8366.
8367.
8368.
8369.
8370.
8371.
8372.
8373.
8374.
8375.
8376.
8377.
8378.
8379.
8380.
8381.
8382.
8383.
8384.
8385.
8386.
8387.
8388.
8389.
8390.
8391.
8392.
8393.
8394.
8395.
8396.
8397.
8398.
8399.
8400.
8401.
8402.
8403.
8404.
8405.
8406.
8407.
8408.
8409.
8410.
8411.
8412.
8413.
8414.
8415.
8416.
8417.
8418.
8419.
8420.
8421.
8422.
8423.
8424.
8425.
8426.
8427.
8428.
8429.
8430.
8431.
8432.
8433.
8434.
8435.
8436.
8437.
8438.
8439.
8440.
8441.
8442.
8443.
8444.
8445.
8446.
8447.
8448.
8449.
8450.
8451.
8452.
8453.
8454.
8455.
8456.
8457.
8458.
8459.
8460.
8461.
8462.
8463.
8464.
8465.
8466.
8467.
8468.
8469.
8470.
8471.
8472.
8473.
8474.
8475.
8476.
8477.
8478.
8479.
8480.
8481.
8482.
8483.
8484.
8485.
8486.
8487.
8488.
8489.
8490.
8491.
8492.
8493.
8494.
8495.
8496.
8497.
8498.
8499.
8500.
8501.
8502.
8503.
8504.
8505.
8506.
8507.
8508.
8509.
8510.
8511.
8512.
8513.
8514.
8515.
8516.
8517.
8518.
8519.
8520.
8521.
8522.
8523.
8524.
8525.
8526.
8527.
8528.
8529.
8530.
8531.
8532.
8533.
8534.
8535.
8536.
8537.
8538.
8539.
8540.
8541.
8542.
8543.
8544.
</code_line></pre></td>
<td class='lines'><pre><code class="prettyprint">// SPDX-License-Identifier: GPL-2.0-only
/*
 * Kernel-based Virtual Machine driver for Linux
 *
 * This module enables machines with Intel VT-x extensions to run virtual
 * machines without emulation or binary translation.
 *
 * Copyright (C) 2006 Qumranet, Inc.
 * Copyright 2010 Red Hat, Inc. and/or its affiliates.
 *
 * Authors:
 *   Avi Kivity   &lt;avi@qumranet.com&gt;
 *   Yaniv Kamay  &lt;yaniv@qumranet.com&gt;
 */

#include &lt;linux/highmem.h&gt;
#include &lt;linux/hrtimer.h&gt;
#include &lt;linux/kernel.h&gt;
#include &lt;linux/kvm_host.h&gt;
#include &lt;linux/module.h&gt;
#include &lt;linux/moduleparam.h&gt;
#include &lt;linux/mod_devicetable.h&gt;
#include &lt;linux/mm.h&gt;
#include &lt;linux/objtool.h&gt;
#include &lt;linux/sched.h&gt;
#include &lt;linux/sched/smt.h&gt;
#include &lt;linux/slab.h&gt;
#include &lt;linux/tboot.h&gt;
#include &lt;linux/trace_events.h&gt;
#include &lt;linux/entry-kvm.h&gt;

#include &lt;asm/apic.h&gt;
#include &lt;asm/asm.h&gt;
#include &lt;asm/cpu.h&gt;
#include &lt;asm/cpu_device_id.h&gt;
#include &lt;asm/debugreg.h&gt;
#include &lt;asm/desc.h&gt;
#include &lt;asm/fpu/api.h&gt;
#include &lt;asm/fpu/xstate.h&gt;
#include &lt;asm/idtentry.h&gt;
#include &lt;asm/io.h&gt;
#include &lt;asm/irq_remapping.h&gt;
#include &lt;asm/kexec.h&gt;
#include &lt;asm/perf_event.h&gt;
#include &lt;asm/mmu_context.h&gt;
#include &lt;asm/mshyperv.h&gt;
#include &lt;asm/mwait.h&gt;
#include &lt;asm/spec-ctrl.h&gt;
#include &lt;asm/virtext.h&gt;
#include &lt;asm/vmx.h&gt;

#include &quot;capabilities.h&quot;
#include &quot;cpuid.h&quot;
#include &quot;evmcs.h&quot;
#include &quot;hyperv.h&quot;
#include &quot;kvm_onhyperv.h&quot;
#include &quot;irq.h&quot;
#include &quot;kvm_cache_regs.h&quot;
#include &quot;lapic.h&quot;
#include &quot;mmu.h&quot;
#include &quot;nested.h&quot;
#include &quot;pmu.h&quot;
#include &quot;sgx.h&quot;
#include &quot;trace.h&quot;
#include &quot;vmcs.h&quot;
#include &quot;vmcs12.h&quot;
#include &quot;vmx.h&quot;
#include &quot;x86.h&quot;

MODULE_AUTHOR(&quot;Qumranet&quot;);
MODULE_LICENSE(&quot;GPL&quot;);

#ifdef MODULE
static const struct x86_cpu_id vmx_cpu_id[] = {
	X86_MATCH_FEATURE(X86_FEATURE_VMX, NULL),
	{}
};
MODULE_DEVICE_TABLE(x86cpu, vmx_cpu_id);
#endif

bool __read_mostly enable_vpid = 1;
module_param_named(vpid, enable_vpid, bool, 0444);

static bool __read_mostly enable_vnmi = 1;
module_param_named(vnmi, enable_vnmi, bool, S_IRUGO);

bool __read_mostly flexpriority_enabled = 1;
module_param_named(flexpriority, flexpriority_enabled, bool, S_IRUGO);

bool __read_mostly enable_ept = 1;
module_param_named(ept, enable_ept, bool, S_IRUGO);

bool __read_mostly enable_unrestricted_guest = 1;
module_param_named(unrestricted_guest,
			enable_unrestricted_guest, bool, S_IRUGO);

bool __read_mostly enable_ept_ad_bits = 1;
module_param_named(eptad, enable_ept_ad_bits, bool, S_IRUGO);

static bool __read_mostly emulate_invalid_guest_state = true;
module_param(emulate_invalid_guest_state, bool, S_IRUGO);

static bool __read_mostly fasteoi = 1;
module_param(fasteoi, bool, S_IRUGO);

module_param(enable_apicv, bool, S_IRUGO);

bool __read_mostly enable_ipiv = true;
module_param(enable_ipiv, bool, 0444);

/*
 * If nested=1, nested virtualization is supported, i.e., guests may use
 * VMX and be a hypervisor for its own guests. If nested=0, guests may not
 * use VMX instructions.
 */
static bool __read_mostly nested = 1;
module_param(nested, bool, S_IRUGO);

bool __read_mostly enable_pml = 1;
module_param_named(pml, enable_pml, bool, S_IRUGO);

static bool __read_mostly error_on_inconsistent_vmcs_config = true;
module_param(error_on_inconsistent_vmcs_config, bool, 0444);

static bool __read_mostly dump_invalid_vmcs = 0;
module_param(dump_invalid_vmcs, bool, 0644);

#define MSR_BITMAP_MODE_X2APIC		1
#define MSR_BITMAP_MODE_X2APIC_APICV	2

#define KVM_VMX_TSC_MULTIPLIER_MAX     0xffffffffffffffffULL

/* Guest_tsc -&gt; host_tsc conversion requires 64-bit division.  */
static int __read_mostly cpu_preemption_timer_multi;
static bool __read_mostly enable_preemption_timer = 1;
#ifdef CONFIG_X86_64
module_param_named(preemption_timer, enable_preemption_timer, bool, S_IRUGO);
#endif

extern bool __read_mostly allow_smaller_maxphyaddr;
module_param(allow_smaller_maxphyaddr, bool, S_IRUGO);

#define KVM_VM_CR0_ALWAYS_OFF (X86_CR0_NW | X86_CR0_CD)
#define KVM_VM_CR0_ALWAYS_ON_UNRESTRICTED_GUEST X86_CR0_NE
#define KVM_VM_CR0_ALWAYS_ON				\
	(KVM_VM_CR0_ALWAYS_ON_UNRESTRICTED_GUEST | X86_CR0_PG | X86_CR0_PE)

#define KVM_VM_CR4_ALWAYS_ON_UNRESTRICTED_GUEST X86_CR4_VMXE
#define KVM_PMODE_VM_CR4_ALWAYS_ON (X86_CR4_PAE | X86_CR4_VMXE)
#define KVM_RMODE_VM_CR4_ALWAYS_ON (X86_CR4_VME | X86_CR4_PAE | X86_CR4_VMXE)

#define RMODE_GUEST_OWNED_EFLAGS_BITS (~(X86_EFLAGS_IOPL | X86_EFLAGS_VM))

#define MSR_IA32_RTIT_STATUS_MASK (~(RTIT_STATUS_FILTEREN | \
	RTIT_STATUS_CONTEXTEN | RTIT_STATUS_TRIGGEREN | \
	RTIT_STATUS_ERROR | RTIT_STATUS_STOPPED | \
	RTIT_STATUS_BYTECNT))

/*
 * List of MSRs that can be directly passed to the guest.
 * In addition to these x2apic and PT MSRs are handled specially.
 */
static u32 vmx_possible_passthrough_msrs[MAX_POSSIBLE_PASSTHROUGH_MSRS] = {
	MSR_IA32_SPEC_CTRL,
	MSR_IA32_PRED_CMD,
	MSR_IA32_TSC,
#ifdef CONFIG_X86_64
	MSR_FS_BASE,
	MSR_GS_BASE,
	MSR_KERNEL_GS_BASE,
	MSR_IA32_XFD,
	MSR_IA32_XFD_ERR,
#endif
	MSR_IA32_SYSENTER_CS,
	MSR_IA32_SYSENTER_ESP,
	MSR_IA32_SYSENTER_EIP,
	MSR_CORE_C1_RES,
	MSR_CORE_C3_RESIDENCY,
	MSR_CORE_C6_RESIDENCY,
	MSR_CORE_C7_RESIDENCY,
};

/*
 * These 2 parameters are used to config the controls for Pause-Loop Exiting:
 * ple_gap:    upper bound on the amount of time between two successive
 *             executions of PAUSE in a loop. Also indicate if ple enabled.
 *             According to test, this time is usually smaller than 128 cycles.
 * ple_window: upper bound on the amount of time a guest is allowed to execute
 *             in a PAUSE loop. Tests indicate that most spinlocks are held for
 *             less than 2^12 cycles
 * Time is measured based on a counter that runs at the same rate as the TSC,
 * refer SDM volume 3b section 21.6.13 &amp; 22.1.3.
 */
static unsigned int ple_gap = KVM_DEFAULT_PLE_GAP;
module_param(ple_gap, uint, 0444);

static unsigned int ple_window = KVM_VMX_DEFAULT_PLE_WINDOW;
module_param(ple_window, uint, 0444);

/* Default doubles per-vcpu window every exit. */
static unsigned int ple_window_grow = KVM_DEFAULT_PLE_WINDOW_GROW;
module_param(ple_window_grow, uint, 0444);

/* Default resets per-vcpu window every exit to ple_window. */
static unsigned int ple_window_shrink = KVM_DEFAULT_PLE_WINDOW_SHRINK;
module_param(ple_window_shrink, uint, 0444);

/* Default is to compute the maximum so we can never overflow. */
static unsigned int ple_window_max        = KVM_VMX_DEFAULT_PLE_WINDOW_MAX;
module_param(ple_window_max, uint, 0444);

/* Default is SYSTEM mode, 1 for host-guest mode */
int __read_mostly pt_mode = PT_MODE_SYSTEM;
module_param(pt_mode, int, S_IRUGO);

static DEFINE_STATIC_KEY_FALSE(vmx_l1d_should_flush);
static DEFINE_STATIC_KEY_FALSE(vmx_l1d_flush_cond);
static DEFINE_MUTEX(vmx_l1d_flush_mutex);

/* Storage for pre module init parameter parsing */
static enum vmx_l1d_flush_state __read_mostly vmentry_l1d_flush_param = VMENTER_L1D_FLUSH_AUTO;

static const struct {
	const char *option;
	bool for_parse;
} vmentry_l1d_param[] = {
	[VMENTER_L1D_FLUSH_AUTO]	 = {&quot;auto&quot;, true},
	[VMENTER_L1D_FLUSH_NEVER]	 = {&quot;never&quot;, true},
	[VMENTER_L1D_FLUSH_COND]	 = {&quot;cond&quot;, true},
	[VMENTER_L1D_FLUSH_ALWAYS]	 = {&quot;always&quot;, true},
	[VMENTER_L1D_FLUSH_EPT_DISABLED] = {&quot;EPT disabled&quot;, false},
	[VMENTER_L1D_FLUSH_NOT_REQUIRED] = {&quot;not required&quot;, false},
};

#define L1D_CACHE_ORDER 4
static void *vmx_l1d_flush_pages;

/* Control for disabling CPU Fill buffer clear */
static bool __read_mostly vmx_fb_clear_ctrl_available;

static int vmx_setup_l1d_flush(enum vmx_l1d_flush_state l1tf)
{
	struct page *page;
	unsigned int i;

<yellow>	if (!boot_cpu_has_bug(X86_BUG_L1TF)) {</yellow>
<yellow>		l1tf_vmx_mitigation = VMENTER_L1D_FLUSH_NOT_REQUIRED;</yellow>
		return 0;
	}

<yellow>	if (!enable_ept) {</yellow>
<yellow>		l1tf_vmx_mitigation = VMENTER_L1D_FLUSH_EPT_DISABLED;</yellow>
		return 0;
	}

<yellow>	if (boot_cpu_has(X86_FEATURE_ARCH_CAPABILITIES)) {</yellow>
		u64 msr;

<yellow>		rdmsrl(MSR_IA32_ARCH_CAPABILITIES, msr);</yellow>
		if (msr &amp; ARCH_CAP_SKIP_VMENTRY_L1DFLUSH) {
<yellow>			l1tf_vmx_mitigation = VMENTER_L1D_FLUSH_NOT_REQUIRED;</yellow>
			return 0;
		}
	}

	/* If set to auto use the default l1tf mitigation method */
<yellow>	if (l1tf == VMENTER_L1D_FLUSH_AUTO) {</yellow>
<yellow>		switch (l1tf_mitigation) {</yellow>
		case L1TF_MITIGATION_OFF:
			l1tf = VMENTER_L1D_FLUSH_NEVER;
			break;
		case L1TF_MITIGATION_FLUSH_NOWARN:
		case L1TF_MITIGATION_FLUSH:
		case L1TF_MITIGATION_FLUSH_NOSMT:
<yellow>			l1tf = VMENTER_L1D_FLUSH_COND;</yellow>
			break;
		case L1TF_MITIGATION_FULL:
		case L1TF_MITIGATION_FULL_FORCE:
			l1tf = VMENTER_L1D_FLUSH_ALWAYS;
			break;
		}
<yellow>	} else if (l1tf_mitigation == L1TF_MITIGATION_FULL_FORCE) {</yellow>
		l1tf = VMENTER_L1D_FLUSH_ALWAYS;
	}

<yellow>	if (l1tf != VMENTER_L1D_FLUSH_NEVER && !vmx_l1d_flush_pages &&</yellow>
<yellow>	    !boot_cpu_has(X86_FEATURE_FLUSH_L1D)) {</yellow>
		/*
		 * This allocation for vmx_l1d_flush_pages is not tied to a VM
		 * lifetime and so should not be charged to a memcg.
		 */
<yellow>		page = alloc_pages(GFP_KERNEL, L1D_CACHE_ORDER);</yellow>
<yellow>		if (!page)</yellow>
			return -ENOMEM;
<yellow>		vmx_l1d_flush_pages = page_address(page);</yellow>

		/*
		 * Initialize each page with a different pattern in
		 * order to protect against KSM in the nested
		 * virtualization case.
		 */
<yellow>		for (i = 0; i < 1u << L1D_CACHE_ORDER; ++i) {</yellow>
<yellow>			memset(vmx_l1d_flush_pages + i * PAGE_SIZE, i + 1,</yellow>
			       PAGE_SIZE);
		}
	}

<yellow>	l1tf_vmx_mitigation = l1tf;</yellow>

	if (l1tf != VMENTER_L1D_FLUSH_NEVER)
<yellow>		static_branch_enable(&vmx_l1d_should_flush);</yellow>
	else
<yellow>		static_branch_disable(&vmx_l1d_should_flush);</yellow>

<yellow>	if (l1tf == VMENTER_L1D_FLUSH_COND)</yellow>
<yellow>		static_branch_enable(&vmx_l1d_flush_cond);</yellow>
	else
<yellow>		static_branch_disable(&vmx_l1d_flush_cond);</yellow>
<yellow>	return 0;</yellow>
<yellow>}</yellow>

static int vmentry_l1d_flush_parse(const char *s)
{
	unsigned int i;

<yellow>	if (s) {</yellow>
<yellow>		for (i = 0; i < ARRAY_SIZE(vmentry_l1d_param); i++) {</yellow>
<yellow>			if (vmentry_l1d_param[i].for_parse &&</yellow>
<yellow>			    sysfs_streq(s, vmentry_l1d_param[i].option))</yellow>
				return i;
		}
	}
<yellow>	return -EINVAL;</yellow>
}

static int vmentry_l1d_flush_set(const char *s, const struct kernel_param *kp)
{
	int l1tf, ret;

<yellow>	l1tf = vmentry_l1d_flush_parse(s);</yellow>
	if (l1tf &lt; 0)
		return l1tf;

<yellow>	if (!boot_cpu_has(X86_BUG_L1TF))</yellow>
		return 0;

	/*
	 * Has vmx_init() run already? If not then this is the pre init
	 * parameter parsing. In that case just store the value and let
	 * vmx_init() do the proper setup after enable_ept has been
	 * established.
	 */
<yellow>	if (l1tf_vmx_mitigation == VMENTER_L1D_FLUSH_AUTO) {</yellow>
<yellow>		vmentry_l1d_flush_param = l1tf;</yellow>
		return 0;
	}

<yellow>	mutex_lock(&vmx_l1d_flush_mutex);</yellow>
<yellow>	ret = vmx_setup_l1d_flush(l1tf);</yellow>
<yellow>	mutex_unlock(&vmx_l1d_flush_mutex);</yellow>
<yellow>	return ret;</yellow>
<yellow>}</yellow>

<yellow>static int vmentry_l1d_flush_get(char *s, const struct kernel_param *kp)</yellow>
<yellow>{</yellow>
<yellow>	if (WARN_ON_ONCE(l1tf_vmx_mitigation >= ARRAY_SIZE(vmentry_l1d_param)))</yellow>
<yellow>		return sprintf(s, "???\n");</yellow>

<yellow>	return sprintf(s, "%s\n", vmentry_l1d_param[l1tf_vmx_mitigation].option);</yellow>
<yellow>}</yellow>

static void vmx_setup_fb_clear_ctrl(void)
{
	u64 msr;

	if (boot_cpu_has(X86_FEATURE_ARCH_CAPABILITIES) &amp;&amp;
	    !boot_cpu_has_bug(X86_BUG_MDS) &amp;&amp;
	    !boot_cpu_has_bug(X86_BUG_TAA)) {
		rdmsrl(MSR_IA32_ARCH_CAPABILITIES, msr);
		if (msr &amp; ARCH_CAP_FB_CLEAR_CTRL)
			vmx_fb_clear_ctrl_available = true;
	}
}

static __always_inline void vmx_disable_fb_clear(struct vcpu_vmx *vmx)
{
	u64 msr;

	if (!vmx-&gt;disable_fb_clear)
		return;

	msr = __rdmsr(MSR_IA32_MCU_OPT_CTRL);
	msr |= FB_CLEAR_DIS;
	native_wrmsrl(MSR_IA32_MCU_OPT_CTRL, msr);
	/* Cache the MSR value to avoid reading it later */
	vmx-&gt;msr_ia32_mcu_opt_ctrl = msr;
}

static __always_inline void vmx_enable_fb_clear(struct vcpu_vmx *vmx)
{
	if (!vmx-&gt;disable_fb_clear)
		return;

	vmx-&gt;msr_ia32_mcu_opt_ctrl &amp;= ~FB_CLEAR_DIS;
	native_wrmsrl(MSR_IA32_MCU_OPT_CTRL, vmx-&gt;msr_ia32_mcu_opt_ctrl);
}

static void vmx_update_fb_clear_dis(struct kvm_vcpu *vcpu, struct vcpu_vmx *vmx)
{
<blue>	vmx->disable_fb_clear = vmx_fb_clear_ctrl_available;</blue>

	/*
	 * If guest will not execute VERW, there is no need to set FB_CLEAR_DIS
	 * at VMEntry. Skip the MSR read/write when a guest has no use case to
	 * execute VERW.
	 */
	if ((vcpu-&gt;arch.arch_capabilities &amp; ARCH_CAP_FB_CLEAR) ||
	   ((vcpu-&gt;arch.arch_capabilities &amp; ARCH_CAP_MDS_NO) &amp;&amp;
	    (vcpu-&gt;arch.arch_capabilities &amp; ARCH_CAP_TAA_NO) &amp;&amp;
	    (vcpu-&gt;arch.arch_capabilities &amp; ARCH_CAP_PSDP_NO) &amp;&amp;
<blue>	    (vcpu->arch.arch_capabilities & ARCH_CAP_FBSDP_NO) &&</blue>
	    (vcpu-&gt;arch.arch_capabilities &amp; ARCH_CAP_SBDR_SSDP_NO)))
<yellow>		vmx->disable_fb_clear = false;</yellow>
}

static const struct kernel_param_ops vmentry_l1d_flush_ops = {
	.set = vmentry_l1d_flush_set,
	.get = vmentry_l1d_flush_get,
};
module_param_cb(vmentry_l1d_flush, &amp;vmentry_l1d_flush_ops, NULL, 0644);

static u32 vmx_segment_access_rights(struct kvm_segment *var);

void vmx_vmexit(void);

#define vmx_insn_failed(fmt...)		\
do {					\
	WARN_ONCE(1, fmt);		\
	pr_warn_ratelimited(fmt);	\
} while (0)

void vmread_error(unsigned long field, bool fault)
<yellow>{</yellow>
<yellow>	if (fault)</yellow>
<yellow>		kvm_spurious_fault();</yellow>
	else
<yellow>		vmx_insn_failed("kvm: vmread failed: field=%lx\n", field);</yellow>
<yellow>}</yellow>

noinline void vmwrite_error(unsigned long field, unsigned long value)
<yellow>{</yellow>
<yellow>	vmx_insn_failed("kvm: vmwrite failed: field=%lx val=%lx err=%u\n",</yellow>
			field, value, vmcs_read32(VM_INSTRUCTION_ERROR));
<yellow>}</yellow>

noinline void vmclear_error(struct vmcs *vmcs, u64 phys_addr)
{
<yellow>	vmx_insn_failed("kvm: vmclear failed: %p/%llx err=%u\n",</yellow>
			vmcs, phys_addr, vmcs_read32(VM_INSTRUCTION_ERROR));
<yellow>}</yellow>

noinline void vmptrld_error(struct vmcs *vmcs, u64 phys_addr)
{
<yellow>	vmx_insn_failed("kvm: vmptrld failed: %p/%llx err=%u\n",</yellow>
			vmcs, phys_addr, vmcs_read32(VM_INSTRUCTION_ERROR));
<yellow>}</yellow>

noinline void invvpid_error(unsigned long ext, u16 vpid, gva_t gva)
{
<yellow>	vmx_insn_failed("kvm: invvpid failed: ext=0x%lx vpid=%u gva=0x%lx\n",</yellow>
			ext, vpid, gva);
<yellow>}</yellow>

noinline void invept_error(unsigned long ext, u64 eptp, gpa_t gpa)
{
<yellow>	vmx_insn_failed("kvm: invept failed: ext=0x%lx eptp=%llx gpa=0x%llx\n",</yellow>
			ext, eptp, gpa);
<yellow>}</yellow>

static DEFINE_PER_CPU(struct vmcs *, vmxarea);
DEFINE_PER_CPU(struct vmcs *, current_vmcs);
/*
 * We maintain a per-CPU linked-list of VMCS loaded on that CPU. This is needed
 * when a CPU is brought down, and we need to VMCLEAR all VMCSs loaded on it.
 */
static DEFINE_PER_CPU(struct list_head, loaded_vmcss_on_cpu);

static DECLARE_BITMAP(vmx_vpid_bitmap, VMX_NR_VPIDS);
static DEFINE_SPINLOCK(vmx_vpid_lock);

struct vmcs_config vmcs_config;
struct vmx_capability vmx_capability;

#define VMX_SEGMENT_FIELD(seg)					\
	[VCPU_SREG_##seg] = {                                   \
		.selector = GUEST_##seg##_SELECTOR,		\
		.base = GUEST_##seg##_BASE,		   	\
		.limit = GUEST_##seg##_LIMIT,		   	\
		.ar_bytes = GUEST_##seg##_AR_BYTES,	   	\
	}

static const struct kvm_vmx_segment_field {
	unsigned selector;
	unsigned base;
	unsigned limit;
	unsigned ar_bytes;
} kvm_vmx_segment_fields[] = {
	VMX_SEGMENT_FIELD(CS),
	VMX_SEGMENT_FIELD(DS),
	VMX_SEGMENT_FIELD(ES),
	VMX_SEGMENT_FIELD(FS),
	VMX_SEGMENT_FIELD(GS),
	VMX_SEGMENT_FIELD(SS),
	VMX_SEGMENT_FIELD(TR),
	VMX_SEGMENT_FIELD(LDTR),
};

static inline void vmx_segment_cache_clear(struct vcpu_vmx *vmx)
{
<blue>	vmx->segment_cache.bitmask = 0;</blue>
}

static unsigned long host_idt_base;

#if IS_ENABLED(CONFIG_HYPERV)
static bool __read_mostly enlightened_vmcs = true;
module_param(enlightened_vmcs, bool, 0444);

static int hv_enable_direct_tlbflush(struct kvm_vcpu *vcpu)
<yellow>{</yellow>
	struct hv_enlightened_vmcs *evmcs;
	struct hv_partition_assist_pg **p_hv_pa_pg =
<yellow>			&to_kvm_hv(vcpu->kvm)->hv_pa_pg;</yellow>
	/*
	 * Synthetic VM-Exit is not enabled in current code and so All
	 * evmcs in singe VM shares same assist page.
	 */
<yellow>	if (!*p_hv_pa_pg)</yellow>
<yellow>		*p_hv_pa_pg = kzalloc(PAGE_SIZE, GFP_KERNEL_ACCOUNT);</yellow>

	if (!*p_hv_pa_pg)
		return -ENOMEM;

<yellow>	evmcs = (struct hv_enlightened_vmcs *)to_vmx(vcpu)->loaded_vmcs->vmcs;</yellow>

<yellow>	evmcs->partition_assist_page =</yellow>
<yellow>		__pa(*p_hv_pa_pg);</yellow>
<yellow>	evmcs->hv_vm_id = (unsigned long)vcpu->kvm;</yellow>
<yellow>	evmcs->hv_enlightenments_control.nested_flush_hypercall = 1;</yellow>

	return 0;
<yellow>}</yellow>

#endif /* IS_ENABLED(CONFIG_HYPERV) */

/*
 * Comment&#x27;s format: document - errata name - stepping - processor name.
 * Refer from
 * https://www.virtualbox.org/svn/vbox/trunk/src/VBox/VMM/VMMR0/HMR0.cpp
 */
static u32 vmx_preemption_cpu_tfms[] = {
/* 323344.pdf - BA86   - D0 - Xeon 7500 Series */
0x000206E6,
/* 323056.pdf - AAX65  - C2 - Xeon L3406 */
/* 322814.pdf - AAT59  - C2 - i7-600, i5-500, i5-400 and i3-300 Mobile */
/* 322911.pdf - AAU65  - C2 - i5-600, i3-500 Desktop and Pentium G6950 */
0x00020652,
/* 322911.pdf - AAU65  - K0 - i5-600, i3-500 Desktop and Pentium G6950 */
0x00020655,
/* 322373.pdf - AAO95  - B1 - Xeon 3400 Series */
/* 322166.pdf - AAN92  - B1 - i7-800 and i5-700 Desktop */
/*
 * 320767.pdf - AAP86  - B1 -
 * i7-900 Mobile Extreme, i7-800 and i7-700 Mobile
 */
0x000106E5,
/* 321333.pdf - AAM126 - C0 - Xeon 3500 */
0x000106A0,
/* 321333.pdf - AAM126 - C1 - Xeon 3500 */
0x000106A1,
/* 320836.pdf - AAJ124 - C0 - i7-900 Desktop Extreme and i7-900 Desktop */
0x000106A4,
 /* 321333.pdf - AAM126 - D0 - Xeon 3500 */
 /* 321324.pdf - AAK139 - D0 - Xeon 5500 */
 /* 320836.pdf - AAJ124 - D0 - i7-900 Extreme and i7-900 Desktop */
0x000106A5,
 /* Xeon E3-1220 V2 */
0x000306A8,
};

static inline bool cpu_has_broken_vmx_preemption_timer(void)
{
	u32 eax = cpuid_eax(0x00000001), i;

	/* Clear the reserved bits */
	eax &amp;= ~(0x3U &lt;&lt; 14 | 0xfU &lt;&lt; 28);
	for (i = 0; i &lt; ARRAY_SIZE(vmx_preemption_cpu_tfms); i++)
		if (eax == vmx_preemption_cpu_tfms[i])
			return true;

	return false;
}

static inline bool cpu_need_virtualize_apic_accesses(struct kvm_vcpu *vcpu)
{
<blue>	return flexpriority_enabled && lapic_in_kernel(vcpu);</blue>
}

static int possible_passthrough_msr_slot(u32 msr)
{
	u32 i;

<blue>	for (i = 0; i < ARRAY_SIZE(vmx_possible_passthrough_msrs); i++)</blue>
<blue>		if (vmx_possible_passthrough_msrs[i] == msr)</blue>
			return i;

	return -ENOENT;
}

static bool is_valid_passthrough_msr(u32 msr)
<yellow>{</yellow>
	bool r;

<blue>	switch (msr) {</blue>
	case 0x800 ... 0x8ff:
		/* x2APIC MSRs. These are handled in vmx_update_msr_bitmap_x2apic() */
		return true;
	case MSR_IA32_RTIT_STATUS:
	case MSR_IA32_RTIT_OUTPUT_BASE:
	case MSR_IA32_RTIT_OUTPUT_MASK:
	case MSR_IA32_RTIT_CR3_MATCH:
	case MSR_IA32_RTIT_ADDR0_A ... MSR_IA32_RTIT_ADDR3_B:
		/* PT MSRs. These are handled in pt_update_intercept_for_msr() */
	case MSR_LBR_SELECT:
	case MSR_LBR_TOS:
	case MSR_LBR_INFO_0 ... MSR_LBR_INFO_0 + 31:
	case MSR_LBR_NHM_FROM ... MSR_LBR_NHM_FROM + 31:
	case MSR_LBR_NHM_TO ... MSR_LBR_NHM_TO + 31:
	case MSR_LBR_CORE_FROM ... MSR_LBR_CORE_FROM + 8:
	case MSR_LBR_CORE_TO ... MSR_LBR_CORE_TO + 8:
		/* LBR MSRs. These are handled in vmx_update_intercept_for_lbr_msrs() */
		return true;
	}

<blue>	r = possible_passthrough_msr_slot(msr) != -ENOENT;</blue>

<yellow>	WARN(!r, "Invalid MSR %x, please adapt vmx_possible_passthrough_msrs[]", msr);</yellow>

	return r;
<blue>}</blue>

struct vmx_uret_msr *vmx_find_uret_msr(struct vcpu_vmx *vmx, u32 msr)
{
	int i;

<blue>	i = kvm_find_user_return_msr(msr);</blue>
	if (i &gt;= 0)
<blue>		return &vmx->guest_uret_msrs[i];</blue>
	return NULL;
<yellow>}</yellow>

static int vmx_set_guest_uret_msr(struct vcpu_vmx *vmx,
				  struct vmx_uret_msr *msr, u64 data)
<yellow>{</yellow>
	unsigned int slot = msr - vmx-&gt;guest_uret_msrs;
	int ret = 0;

<blue>	if (msr->load_into_hardware) {</blue>
<blue>		preempt_disable();</blue>
<yellow>		ret = kvm_set_user_return_msr(slot, data, msr->mask);</yellow>
<blue>		preempt_enable();</blue>
	}
<blue>	if (!ret)</blue>
<blue>		msr->data = data;</blue>
<yellow>	return ret;</yellow>
<blue>}</blue>

#ifdef CONFIG_KEXEC_CORE
static void crash_vmclear_local_loaded_vmcss(void)
<yellow>{</yellow>
<yellow>	int cpu = raw_smp_processor_id();</yellow>
	struct loaded_vmcs *v;

<yellow>	list_for_each_entry(v, &per_cpu(loaded_vmcss_on_cpu, cpu),</yellow>
			    loaded_vmcss_on_cpu_link)
<yellow>		vmcs_clear(v->vmcs);</yellow>
}
#endif /* CONFIG_KEXEC_CORE */

<blue>static void __loaded_vmcs_clear(void *arg)</blue>
<blue>{</blue>
	struct loaded_vmcs *loaded_vmcs = arg;
<blue>	int cpu = raw_smp_processor_id();</blue>

	if (loaded_vmcs-&gt;cpu != cpu)
		return; /* vcpu migration can race with cpu offline */
<blue>	if (per_cpu(current_vmcs, cpu) == loaded_vmcs->vmcs)</blue>
<yellow>		per_cpu(current_vmcs, cpu) = NULL;</yellow>

<blue>	vmcs_clear(loaded_vmcs->vmcs);</blue>
<blue>	if (loaded_vmcs->shadow_vmcs && loaded_vmcs->launched)</blue>
<yellow>		vmcs_clear(loaded_vmcs->shadow_vmcs);</yellow>

<blue>	list_del(&loaded_vmcs->loaded_vmcss_on_cpu_link);</blue>

	/*
	 * Ensure all writes to loaded_vmcs, including deleting it from its
	 * current percpu list, complete before setting loaded_vmcs-&gt;cpu to
	 * -1, otherwise a different cpu can see loaded_vmcs-&gt;cpu == -1 first
	 * and add loaded_vmcs to its percpu list before it&#x27;s deleted from this
	 * cpu&#x27;s list. Pairs with the smp_rmb() in vmx_vcpu_load_vmcs().
	 */
	smp_wmb();

	loaded_vmcs-&gt;cpu = -1;
	loaded_vmcs-&gt;launched = 0;
}

void loaded_vmcs_clear(struct loaded_vmcs *loaded_vmcs)
{
<blue>	int cpu = loaded_vmcs->cpu;</blue>

<blue>	if (cpu != -1)</blue>
<blue>		smp_call_function_single(cpu,</blue>
			 __loaded_vmcs_clear, loaded_vmcs, 1);
<yellow>}</yellow>

static bool vmx_segment_cache_test_set(struct vcpu_vmx *vmx, unsigned seg,
				       unsigned field)
<yellow>{</yellow>
	bool ret;
<blue>	u32 mask = 1 << (seg * SEG_FIELD_NR + field);</blue>

<yellow>	if (!kvm_register_is_available(&vmx->vcpu, VCPU_EXREG_SEGMENTS)) {</yellow>
<blue>		kvm_register_mark_available(&vmx->vcpu, VCPU_EXREG_SEGMENTS);</blue>
<yellow>		vmx->segment_cache.bitmask = 0;</yellow>
	}
<blue>	ret = vmx->segment_cache.bitmask & mask;</blue>
<blue>	vmx->segment_cache.bitmask |= mask;</blue>
	return ret;
}

static u16 vmx_read_guest_seg_selector(struct vcpu_vmx *vmx, unsigned seg)
<yellow>{</yellow>
<blue>	u16 *p = &vmx->segment_cache.seg[seg].selector;</blue>

<yellow>	if (!vmx_segment_cache_test_set(vmx, seg, SEG_FIELD_SEL))</yellow>
<blue>		*p = vmcs_read16(kvm_vmx_segment_fields[seg].selector);</blue>
<blue>	return *p;</blue>
<blue>}</blue>

static ulong vmx_read_guest_seg_base(struct vcpu_vmx *vmx, unsigned seg)
<yellow>{</yellow>
<blue>	ulong *p = &vmx->segment_cache.seg[seg].base;</blue>

<yellow>	if (!vmx_segment_cache_test_set(vmx, seg, SEG_FIELD_BASE))</yellow>
<blue>		*p = vmcs_readl(kvm_vmx_segment_fields[seg].base);</blue>
<blue>	return *p;</blue>
<blue>}</blue>

static u32 vmx_read_guest_seg_limit(struct vcpu_vmx *vmx, unsigned seg)
{
<yellow>	u32 *p = &vmx->segment_cache.seg[seg].limit;</yellow>

<yellow>	if (!vmx_segment_cache_test_set(vmx, seg, SEG_FIELD_LIMIT))</yellow>
<blue>		*p = vmcs_read32(kvm_vmx_segment_fields[seg].limit);</blue>
<blue>	return *p;</blue>
}

static u32 vmx_read_guest_seg_ar(struct vcpu_vmx *vmx, unsigned seg)
<yellow>{</yellow>
<blue>	u32 *p = &vmx->segment_cache.seg[seg].ar;</blue>

<yellow>	if (!vmx_segment_cache_test_set(vmx, seg, SEG_FIELD_AR))</yellow>
<blue>		*p = vmcs_read32(kvm_vmx_segment_fields[seg].ar_bytes);</blue>
<blue>	return *p;</blue>
<blue>}</blue>

void vmx_update_exception_bitmap(struct kvm_vcpu *vcpu)
{
	u32 eb;

	eb = (1u &lt;&lt; PF_VECTOR) | (1u &lt;&lt; UD_VECTOR) | (1u &lt;&lt; MC_VECTOR) |
	     (1u &lt;&lt; DB_VECTOR) | (1u &lt;&lt; AC_VECTOR);
	/*
	 * Guest access to VMware backdoor ports could legitimately
	 * trigger #GP because of TSS I/O permission bitmap.
	 * We intercept those #GP and allow access to them anyway
	 * as VMware does.
	 */
<blue>	if (enable_vmware_backdoor)</blue>
		eb |= (1u &lt;&lt; GP_VECTOR);
<blue>	if ((vcpu->guest_debug &</blue>
	     (KVM_GUESTDBG_ENABLE | KVM_GUESTDBG_USE_SW_BP)) ==
	    (KVM_GUESTDBG_ENABLE | KVM_GUESTDBG_USE_SW_BP))
<yellow>		eb |= 1u << BP_VECTOR;</yellow>
<blue>	if (to_vmx(vcpu)->rmode.vm86_active)</blue>
		eb = ~0;
<blue>	if (!vmx_need_pf_intercept(vcpu))</blue>
<blue>		eb &= ~(1u << PF_VECTOR);</blue>

	/* When we are running a nested L2 guest and L1 specified for it a
	 * certain exception bitmap, we must trap the same exceptions and pass
	 * them to L1. When running L2, we will only handle the exceptions
	 * specified above if L1 did not want them.
	 */
<blue>	if (is_guest_mode(vcpu))</blue>
<blue>		eb |= get_vmcs12(vcpu)->exception_bitmap;</blue>
        else {
		int mask = 0, match = 0;

<blue>		if (enable_ept && (eb & (1u << PF_VECTOR))) {</blue>
			/*
			 * If EPT is enabled, #PF is currently only intercepted
			 * if MAXPHYADDR is smaller on the guest than on the
			 * host.  In that case we only care about present,
			 * non-reserved faults.  For vmcs02, however, PFEC_MASK
			 * and PFEC_MATCH are set in prepare_vmcs02_rare.
			 */
			mask = PFERR_PRESENT_MASK | PFERR_RSVD_MASK;
			match = PFERR_PRESENT_MASK;
		}
<blue>		vmcs_write32(PAGE_FAULT_ERROR_CODE_MASK, mask);</blue>
<blue>		vmcs_write32(PAGE_FAULT_ERROR_CODE_MATCH, match);</blue>
	}

	/*
	 * Disabling xfd interception indicates that dynamic xfeatures
	 * might be used in the guest. Always trap #NM in this case
	 * to save guest xfd_err timely.
	 */
<blue>	if (vcpu->arch.xfd_no_write_intercept)</blue>
<yellow>		eb |= (1u << NM_VECTOR);</yellow>

<blue>	vmcs_write32(EXCEPTION_BITMAP, eb);</blue>
<blue>}</blue>

/*
 * Check if MSR is intercepted for currently loaded MSR bitmap.
 */
static bool msr_write_intercepted(struct vcpu_vmx *vmx, u32 msr)
{
<blue>	if (!(exec_controls_get(vmx) & CPU_BASED_USE_MSR_BITMAPS))</blue>
		return true;

<blue>	return vmx_test_msr_bitmap_write(vmx->loaded_vmcs->msr_bitmap, msr);</blue>
}

unsigned int __vmx_vcpu_run_flags(struct vcpu_vmx *vmx)
{
	unsigned int flags = 0;

<blue>	if (vmx->loaded_vmcs->launched)</blue>
		flags |= VMX_RUN_VMRESUME;

	/*
	 * If writes to the SPEC_CTRL MSR aren&#x27;t intercepted, the guest is free
	 * to change it directly without causing a vmexit.  In that case read
	 * it after vmexit and store it in vmx-&gt;spec_ctrl.
	 */
<blue>	if (unlikely(!msr_write_intercepted(vmx, MSR_IA32_SPEC_CTRL)))</blue>
<yellow>		flags |= VMX_RUN_SAVE_SPEC_CTRL;</yellow>

	return flags;
<blue>}</blue>

static __always_inline void clear_atomic_switch_msr_special(struct vcpu_vmx *vmx,
		unsigned long entry, unsigned long exit)
{
<blue>	vm_entry_controls_clearbit(vmx, entry);</blue>
<blue>	vm_exit_controls_clearbit(vmx, exit);</blue>
}

int vmx_find_loadstore_msr_slot(struct vmx_msrs *m, u32 msr)
{
	unsigned int i;

<blue>	for (i = 0; i < m->nr; ++i) {</blue>
<blue>		if (m->val[i].index == msr)</blue>
<blue>			return i;</blue>
	}
	return -ENOENT;
<blue>}</blue>

static void clear_atomic_switch_msr(struct vcpu_vmx *vmx, unsigned msr)
{
	int i;
	struct msr_autoload *m = &amp;vmx-&gt;msr_autoload;

<blue>	switch (msr) {</blue>
	case MSR_EFER:
<yellow>		if (cpu_has_load_ia32_efer()) {</yellow>
<yellow>			clear_atomic_switch_msr_special(vmx,</yellow>
					VM_ENTRY_LOAD_IA32_EFER,
					VM_EXIT_LOAD_IA32_EFER);
			return;
		}
		break;
	case MSR_CORE_PERF_GLOBAL_CTRL:
<blue>		if (cpu_has_load_perf_global_ctrl()) {</blue>
<blue>			clear_atomic_switch_msr_special(vmx,</blue>
					VM_ENTRY_LOAD_IA32_PERF_GLOBAL_CTRL,
					VM_EXIT_LOAD_IA32_PERF_GLOBAL_CTRL);
			return;
		}
		break;
	}
<yellow>	i = vmx_find_loadstore_msr_slot(&m->guest, msr);</yellow>
<yellow>	if (i < 0)</yellow>
		goto skip_guest;
<yellow>	--m->guest.nr;</yellow>
	m-&gt;guest.val[i] = m-&gt;guest.val[m-&gt;guest.nr];
<yellow>	vmcs_write32(VM_ENTRY_MSR_LOAD_COUNT, m->guest.nr);</yellow>

skip_guest:
<yellow>	i = vmx_find_loadstore_msr_slot(&m->host, msr);</yellow>
<yellow>	if (i < 0)</yellow>
		return;

	--m-&gt;host.nr;
<yellow>	m->host.val[i] = m->host.val[m->host.nr];</yellow>
<yellow>	vmcs_write32(VM_EXIT_MSR_LOAD_COUNT, m->host.nr);</yellow>
<blue>}</blue>

static __always_inline void add_atomic_switch_msr_special(struct vcpu_vmx *vmx,
		unsigned long entry, unsigned long exit,
		unsigned long guest_val_vmcs, unsigned long host_val_vmcs,
		u64 guest_val, u64 host_val)
{
<blue>	vmcs_write64(guest_val_vmcs, guest_val);</blue>
	if (host_val_vmcs != HOST_IA32_EFER)
<yellow>		vmcs_write64(host_val_vmcs, host_val);</yellow>
<blue>	vm_entry_controls_setbit(vmx, entry);</blue>
<blue>	vm_exit_controls_setbit(vmx, exit);</blue>
}

static void add_atomic_switch_msr(struct vcpu_vmx *vmx, unsigned msr,
				  u64 guest_val, u64 host_val, bool entry_only)
{
	int i, j = 0;
	struct msr_autoload *m = &amp;vmx-&gt;msr_autoload;

<blue>	switch (msr) {</blue>
	case MSR_EFER:
<blue>		if (cpu_has_load_ia32_efer()) {</blue>
<blue>			add_atomic_switch_msr_special(vmx,</blue>
					VM_ENTRY_LOAD_IA32_EFER,
					VM_EXIT_LOAD_IA32_EFER,
					GUEST_IA32_EFER,
					HOST_IA32_EFER,
					guest_val, host_val);
			return;
		}
		break;
	case MSR_CORE_PERF_GLOBAL_CTRL:
<yellow>		if (cpu_has_load_perf_global_ctrl()) {</yellow>
<yellow>			add_atomic_switch_msr_special(vmx,</yellow>
					VM_ENTRY_LOAD_IA32_PERF_GLOBAL_CTRL,
					VM_EXIT_LOAD_IA32_PERF_GLOBAL_CTRL,
					GUEST_IA32_PERF_GLOBAL_CTRL,
					HOST_IA32_PERF_GLOBAL_CTRL,
					guest_val, host_val);
			return;
		}
		break;
	case MSR_IA32_PEBS_ENABLE:
		/* PEBS needs a quiescent period after being disabled (to write
		 * a record).  Disabling PEBS through VMX MSR swapping doesn&#x27;t
		 * provide that period, so a CPU could write host&#x27;s record into
		 * guest&#x27;s memory.
		 */
<yellow>		wrmsrl(MSR_IA32_PEBS_ENABLE, 0);</yellow>
	}

<yellow>	i = vmx_find_loadstore_msr_slot(&m->guest, msr);</yellow>
	if (!entry_only)
<yellow>		j = vmx_find_loadstore_msr_slot(&m->host, msr);</yellow>

<yellow>	if ((i < 0 && m->guest.nr == MAX_NR_LOADSTORE_MSRS) ||</yellow>
<yellow>	    (j < 0 &&  m->host.nr == MAX_NR_LOADSTORE_MSRS)) {</yellow>
<yellow>		printk_once(KERN_WARNING "Not enough msr switch entries. "</yellow>
				&quot;Can&#x27;t add msr %x\n&quot;, msr);
		return;
	}
<yellow>	if (i < 0) {</yellow>
<yellow>		i = m->guest.nr++;</yellow>
<yellow>		vmcs_write32(VM_ENTRY_MSR_LOAD_COUNT, m->guest.nr);</yellow>
	}
<yellow>	m->guest.val[i].index = msr;</yellow>
	m-&gt;guest.val[i].value = guest_val;

	if (entry_only)
		return;

	if (j &lt; 0) {
<yellow>		j = m->host.nr++;</yellow>
<yellow>		vmcs_write32(VM_EXIT_MSR_LOAD_COUNT, m->host.nr);</yellow>
	}
<yellow>	m->host.val[j].index = msr;</yellow>
	m-&gt;host.val[j].value = host_val;
<blue>}</blue>

static bool update_transition_efer(struct vcpu_vmx *vmx)
{
<blue>	u64 guest_efer = vmx->vcpu.arch.efer;</blue>
	u64 ignore_bits = 0;
	int i;

	/* Shadow paging assumes NX to be available.  */
<blue>	if (!enable_ept)</blue>
<yellow>		guest_efer |= EFER_NX;</yellow>

	/*
	 * LMA and LME handled by hardware; SCE meaningless outside long mode.
	 */
	ignore_bits |= EFER_SCE;
#ifdef CONFIG_X86_64
	ignore_bits |= EFER_LMA | EFER_LME;
	/* SCE is meaningful only in long mode on Intel */
<blue>	if (guest_efer & EFER_LMA)</blue>
		ignore_bits &amp;= ~(u64)EFER_SCE;
#endif

	/*
	 * On EPT, we can&#x27;t emulate NX, so we must switch EFER atomically.
	 * On CPUs that support &quot;load IA32_EFER&quot;, always switch EFER
	 * atomically, since it&#x27;s faster than switching it manually.
	 */
<blue>	if (cpu_has_load_ia32_efer() ||</blue>
<yellow>	    (enable_ept && ((vmx->vcpu.arch.efer ^ host_efer) & EFER_NX))) {</yellow>
<yellow>		if (!(guest_efer & EFER_LMA))</yellow>
<blue>			guest_efer &= ~EFER_LME;</blue>
<blue>		if (guest_efer != host_efer)</blue>
<blue>			add_atomic_switch_msr(vmx, MSR_EFER,</blue>
					      guest_efer, host_efer, false);
		else
<yellow>			clear_atomic_switch_msr(vmx, MSR_EFER);</yellow>
		return false;
	}

<yellow>	i = kvm_find_user_return_msr(MSR_EFER);</yellow>
	if (i &lt; 0)
		return false;

<yellow>	clear_atomic_switch_msr(vmx, MSR_EFER);</yellow>

	guest_efer &amp;= ~ignore_bits;
	guest_efer |= host_efer &amp; ignore_bits;

	vmx-&gt;guest_uret_msrs[i].data = guest_efer;
	vmx-&gt;guest_uret_msrs[i].mask = ~ignore_bits;

	return true;
}

#ifdef CONFIG_X86_32
/*
 * On 32-bit kernels, VM exits still load the FS and GS bases from the
 * VMCS rather than the segment table.  KVM uses this helper to figure
 * out the current bases to poke them into the VMCS before entry.
 */
static unsigned long segment_base(u16 selector)
{
	struct desc_struct *table;
	unsigned long v;

	if (!(selector &amp; ~SEGMENT_RPL_MASK))
		return 0;

	table = get_current_gdt_ro();

	if ((selector &amp; SEGMENT_TI_MASK) == SEGMENT_LDT) {
		u16 ldt_selector = kvm_read_ldt();

		if (!(ldt_selector &amp; ~SEGMENT_RPL_MASK))
			return 0;

		table = (struct desc_struct *)segment_base(ldt_selector);
	}
	v = get_desc_base(&amp;table[selector &gt;&gt; 3]);
	return v;
}
#endif

static inline bool pt_can_write_msr(struct vcpu_vmx *vmx)
{
<yellow>	return vmx_pt_mode_is_host_guest() &&</yellow>
<yellow>	       !(vmx->pt_desc.guest.ctl & RTIT_CTL_TRACEEN);</yellow>
}

static inline bool pt_output_base_valid(struct kvm_vcpu *vcpu, u64 base)
{
	/* The base must be 128-byte aligned and a legal physical address. */
<yellow>	return kvm_vcpu_is_legal_aligned_gpa(vcpu, base, 128);</yellow>
}

static inline void pt_load_msr(struct pt_ctx *ctx, u32 addr_range)
<yellow>{</yellow>
	u32 i;

<yellow>	wrmsrl(MSR_IA32_RTIT_STATUS, ctx->status);</yellow>
<yellow>	wrmsrl(MSR_IA32_RTIT_OUTPUT_BASE, ctx->output_base);</yellow>
<yellow>	wrmsrl(MSR_IA32_RTIT_OUTPUT_MASK, ctx->output_mask);</yellow>
<yellow>	wrmsrl(MSR_IA32_RTIT_CR3_MATCH, ctx->cr3_match);</yellow>
<yellow>	for (i = 0; i < addr_range; i++) {</yellow>
<yellow>		wrmsrl(MSR_IA32_RTIT_ADDR0_A + i * 2, ctx->addr_a[i]);</yellow>
<yellow>		wrmsrl(MSR_IA32_RTIT_ADDR0_B + i * 2, ctx->addr_b[i]);</yellow>
	}
<yellow>}</yellow>

static inline void pt_save_msr(struct pt_ctx *ctx, u32 addr_range)
{
	u32 i;

	rdmsrl(MSR_IA32_RTIT_STATUS, ctx-&gt;status);
	rdmsrl(MSR_IA32_RTIT_OUTPUT_BASE, ctx-&gt;output_base);
	rdmsrl(MSR_IA32_RTIT_OUTPUT_MASK, ctx-&gt;output_mask);
	rdmsrl(MSR_IA32_RTIT_CR3_MATCH, ctx-&gt;cr3_match);
	for (i = 0; i &lt; addr_range; i++) {
<yellow>		rdmsrl(MSR_IA32_RTIT_ADDR0_A + i * 2, ctx->addr_a[i]);</yellow>
		rdmsrl(MSR_IA32_RTIT_ADDR0_B + i * 2, ctx-&gt;addr_b[i]);
	}
}

static void pt_guest_enter(struct vcpu_vmx *vmx)
{
	if (vmx_pt_mode_is_system())
		return;

	/*
	 * GUEST_IA32_RTIT_CTL is already set in the VMCS.
	 * Save host state before VM entry.
	 */
<yellow>	rdmsrl(MSR_IA32_RTIT_CTL, vmx->pt_desc.host.ctl);</yellow>
	if (vmx-&gt;pt_desc.guest.ctl &amp; RTIT_CTL_TRACEEN) {
<yellow>		wrmsrl(MSR_IA32_RTIT_CTL, 0);</yellow>
<yellow>		pt_save_msr(&vmx->pt_desc.host, vmx->pt_desc.num_address_ranges);</yellow>
<yellow>		pt_load_msr(&vmx->pt_desc.guest, vmx->pt_desc.num_address_ranges);</yellow>
	}
}

static void pt_guest_exit(struct vcpu_vmx *vmx)
{
	if (vmx_pt_mode_is_system())
		return;

<yellow>	if (vmx->pt_desc.guest.ctl & RTIT_CTL_TRACEEN) {</yellow>
<yellow>		pt_save_msr(&vmx->pt_desc.guest, vmx->pt_desc.num_address_ranges);</yellow>
<yellow>		pt_load_msr(&vmx->pt_desc.host, vmx->pt_desc.num_address_ranges);</yellow>
	}

	/*
	 * KVM requires VM_EXIT_CLEAR_IA32_RTIT_CTL to expose PT to the guest,
	 * i.e. RTIT_CTL is always cleared on VM-Exit.  Restore it if necessary.
	 */
<yellow>	if (vmx->pt_desc.host.ctl)</yellow>
<yellow>		wrmsrl(MSR_IA32_RTIT_CTL, vmx->pt_desc.host.ctl);</yellow>
}

void vmx_set_host_fs_gs(struct vmcs_host_state *host, u16 fs_sel, u16 gs_sel,
			unsigned long fs_base, unsigned long gs_base)
{
<blue>	if (unlikely(fs_sel != host->fs_sel)) {</blue>
<yellow>		if (!(fs_sel & 7))</yellow>
<yellow>			vmcs_write16(HOST_FS_SELECTOR, fs_sel);</yellow>
		else
<yellow>			vmcs_write16(HOST_FS_SELECTOR, 0);</yellow>
<yellow>		host->fs_sel = fs_sel;</yellow>
	}
<blue>	if (unlikely(gs_sel != host->gs_sel)) {</blue>
<yellow>		if (!(gs_sel & 7))</yellow>
<yellow>			vmcs_write16(HOST_GS_SELECTOR, gs_sel);</yellow>
		else
<yellow>			vmcs_write16(HOST_GS_SELECTOR, 0);</yellow>
<yellow>		host->gs_sel = gs_sel;</yellow>
	}
<blue>	if (unlikely(fs_base != host->fs_base)) {</blue>
<blue>		vmcs_writel(HOST_FS_BASE, fs_base);</blue>
<blue>		host->fs_base = fs_base;</blue>
	}
<blue>	if (unlikely(gs_base != host->gs_base)) {</blue>
<blue>		vmcs_writel(HOST_GS_BASE, gs_base);</blue>
<blue>		host->gs_base = gs_base;</blue>
	}
<blue>}</blue>

void vmx_prepare_switch_to_guest(struct kvm_vcpu *vcpu)
{
	struct vcpu_vmx *vmx = to_vmx(vcpu);
	struct vmcs_host_state *host_state;
#ifdef CONFIG_X86_64
<blue>	int cpu = raw_smp_processor_id();</blue>
#endif
	unsigned long fs_base, gs_base;
	u16 fs_sel, gs_sel;
	int i;

	vmx-&gt;req_immediate_exit = false;

	/*
	 * Note that guest MSRs to be saved/restored can also be changed
	 * when guest state is loaded. This happens when guest transitions
	 * to/from long-mode by setting MSR_EFER.LMA.
	 */
<blue>	if (!vmx->guest_uret_msrs_loaded) {</blue>
<blue>		vmx->guest_uret_msrs_loaded = true;</blue>
<blue>		for (i = 0; i < kvm_nr_uret_msrs; ++i) {</blue>
<blue>			if (!vmx->guest_uret_msrs[i].load_into_hardware)</blue>
				continue;

			kvm_set_user_return_msr(i,
						vmx-&gt;guest_uret_msrs[i].data,
<blue>						vmx->guest_uret_msrs[i].mask);</blue>
		}
	}

<blue>    	if (vmx->nested.need_vmcs12_to_shadow_sync)</blue>
<blue>		nested_sync_vmcs12_to_shadow(vcpu);</blue>

<blue>	if (vmx->guest_state_loaded)</blue>
		return;

<blue>	host_state = &vmx->loaded_vmcs->host_state;</blue>

	/*
	 * Set host fs and gs selectors.  Unfortunately, 22.2.3 does not
	 * allow segment selectors with cpl &gt; 0 or ti == 1.
	 */
	host_state-&gt;ldt_sel = kvm_read_ldt();

#ifdef CONFIG_X86_64
	savesegment(ds, host_state-&gt;ds_sel);
	savesegment(es, host_state-&gt;es_sel);

	gs_base = cpu_kernelmode_gs_base(cpu);
	if (likely(is_64bit_mm(current-&gt;mm))) {
<blue>		current_save_fsgs();</blue>
		fs_sel = current-&gt;thread.fsindex;
		gs_sel = current-&gt;thread.gsindex;
		fs_base = current-&gt;thread.fsbase;
<blue>		vmx->msr_host_kernel_gs_base = current->thread.gsbase;</blue>
	} else {
		savesegment(fs, fs_sel);
		savesegment(gs, gs_sel);
<yellow>		fs_base = read_msr(MSR_FS_BASE);</yellow>
		vmx-&gt;msr_host_kernel_gs_base = read_msr(MSR_KERNEL_GS_BASE);
	}

	wrmsrl(MSR_KERNEL_GS_BASE, vmx-&gt;msr_guest_kernel_gs_base);
#else
	savesegment(fs, fs_sel);
	savesegment(gs, gs_sel);
	fs_base = segment_base(fs_sel);
	gs_base = segment_base(gs_sel);
#endif

	vmx_set_host_fs_gs(host_state, fs_sel, gs_sel, fs_base, gs_base);
	vmx-&gt;guest_state_loaded = true;
<blue>}</blue>

static void vmx_prepare_switch_to_host(struct vcpu_vmx *vmx)
{
	struct vmcs_host_state *host_state;

<blue>	if (!vmx->guest_state_loaded)</blue>
		return;

<blue>	host_state = &vmx->loaded_vmcs->host_state;</blue>

<yellow>	++vmx->vcpu.stat.host_state_reload;</yellow>

#ifdef CONFIG_X86_64
<yellow>	rdmsrl(MSR_KERNEL_GS_BASE, vmx->msr_guest_kernel_gs_base);</yellow>
#endif
<blue>	if (host_state->ldt_sel || (host_state->gs_sel & 7)) {</blue>
<yellow>		kvm_load_ldt(host_state->ldt_sel);</yellow>
#ifdef CONFIG_X86_64
<yellow>		load_gs_index(host_state->gs_sel);</yellow>
#else
		loadsegment(gs, host_state-&gt;gs_sel);
#endif
	}
<blue>	if (host_state->fs_sel & 7)</blue>
<yellow>		loadsegment(fs, host_state->fs_sel);</yellow>
#ifdef CONFIG_X86_64
<blue>	if (unlikely(host_state->ds_sel | host_state->es_sel)) {</blue>
<yellow>		loadsegment(ds, host_state->ds_sel);</yellow>
<yellow>		loadsegment(es, host_state->es_sel);</yellow>
	}
#endif
<blue>	invalidate_tss_limit();</blue>
#ifdef CONFIG_X86_64
<blue>	wrmsrl(MSR_KERNEL_GS_BASE, vmx->msr_host_kernel_gs_base);</blue>
#endif
<yellow>	load_fixmap_gdt(raw_smp_processor_id());</yellow>
<yellow>	vmx->guest_state_loaded = false;</yellow>
<yellow>	vmx->guest_uret_msrs_loaded = false;</yellow>
}

#ifdef CONFIG_X86_64
static u64 vmx_read_guest_kernel_gs_base(struct vcpu_vmx *vmx)
{
<blue>	preempt_disable();</blue>
<blue>	if (vmx->guest_state_loaded)</blue>
<yellow>		rdmsrl(MSR_KERNEL_GS_BASE, vmx->msr_guest_kernel_gs_base);</yellow>
<blue>	preempt_enable();</blue>
<blue>	return vmx->msr_guest_kernel_gs_base;</blue>
}

static void vmx_write_guest_kernel_gs_base(struct vcpu_vmx *vmx, u64 data)
{
<blue>	preempt_disable();</blue>
<blue>	if (vmx->guest_state_loaded)</blue>
<yellow>		wrmsrl(MSR_KERNEL_GS_BASE, data);</yellow>
<blue>	preempt_enable();</blue>
<blue>	vmx->msr_guest_kernel_gs_base = data;</blue>
}
#endif

void vmx_vcpu_load_vmcs(struct kvm_vcpu *vcpu, int cpu,
			struct loaded_vmcs *buddy)
<blue>{</blue>
	struct vcpu_vmx *vmx = to_vmx(vcpu);
<blue>	bool already_loaded = vmx->loaded_vmcs->cpu == cpu;</blue>
	struct vmcs *prev;

	if (!already_loaded) {
<blue>		loaded_vmcs_clear(vmx->loaded_vmcs);</blue>
<blue>		local_irq_disable();</blue>

		/*
		 * Ensure loaded_vmcs-&gt;cpu is read before adding loaded_vmcs to
		 * this cpu&#x27;s percpu list, otherwise it may not yet be deleted
		 * from its previous cpu&#x27;s percpu list.  Pairs with the
		 * smb_wmb() in __loaded_vmcs_clear().
		 */
		smp_rmb();

		list_add(&amp;vmx-&gt;loaded_vmcs-&gt;loaded_vmcss_on_cpu_link,
			 &amp;per_cpu(loaded_vmcss_on_cpu, cpu));
		local_irq_enable();
	}

<blue>	prev = per_cpu(current_vmcs, cpu);</blue>
	if (prev != vmx-&gt;loaded_vmcs-&gt;vmcs) {
<blue>		per_cpu(current_vmcs, cpu) = vmx->loaded_vmcs->vmcs;</blue>
<blue>		vmcs_load(vmx->loaded_vmcs->vmcs);</blue>

		/*
		 * No indirect branch prediction barrier needed when switching
		 * the active VMCS within a guest, e.g. on nested VM-Enter.
		 * The L1 VMM can protect itself with retpolines, IBPB or IBRS.
		 */
<blue>		if (!buddy || WARN_ON_ONCE(buddy->vmcs != prev))</blue>
<blue>			indirect_branch_prediction_barrier();</blue>
	}

<blue>	if (!already_loaded) {</blue>
<blue>		void *gdt = get_current_gdt_ro();</blue>

		/*
		 * Flush all EPTP/VPID contexts, the new pCPU may have stale
		 * TLB entries from its previous association with the vCPU.
		 */
		kvm_make_request(KVM_REQ_TLB_FLUSH, vcpu);

		/*
		 * Linux uses per-cpu TSS and GDT, so set these when switching
		 * processors.  See 22.2.4.
		 */
<blue>		vmcs_writel(HOST_TR_BASE,</blue>
			    (unsigned long)&amp;get_cpu_entry_area(cpu)-&gt;tss.x86_tss);
<blue>		vmcs_writel(HOST_GDTR_BASE, (unsigned long)gdt);   /* 22.2.4 */</blue>

		if (IS_ENABLED(CONFIG_IA32_EMULATION) || IS_ENABLED(CONFIG_X86_32)) {
			/* 22.2.3 */
<blue>			vmcs_writel(HOST_IA32_SYSENTER_ESP,</blue>
<blue>				    (unsigned long)(cpu_entry_stack(cpu) + 1));</blue>
		}

<blue>		vmx->loaded_vmcs->cpu = cpu;</blue>
	}
}

/*
 * Switches to specified vcpu, until a matching vcpu_put(), but assumes
 * vcpu mutex is already taken.
 */
static void vmx_vcpu_load(struct kvm_vcpu *vcpu, int cpu)
{
	struct vcpu_vmx *vmx = to_vmx(vcpu);

<blue>	vmx_vcpu_load_vmcs(vcpu, cpu, NULL);</blue>

	vmx_vcpu_pi_load(vcpu, cpu);

	vmx-&gt;host_debugctlmsr = get_debugctlmsr();
}

static void vmx_vcpu_put(struct kvm_vcpu *vcpu)
<blue>{</blue>
<blue>	vmx_vcpu_pi_put(vcpu);</blue>

<blue>	vmx_prepare_switch_to_host(to_vmx(vcpu));</blue>
<yellow>}</yellow>

bool vmx_emulation_required(struct kvm_vcpu *vcpu)
<blue>{</blue>
<blue>	return emulate_invalid_guest_state && !vmx_guest_state_valid(vcpu);</blue>
<blue>}</blue>

unsigned long vmx_get_rflags(struct kvm_vcpu *vcpu)
<yellow>{</yellow>
	struct vcpu_vmx *vmx = to_vmx(vcpu);
	unsigned long rflags, save_rflags;

<blue>	if (!kvm_register_is_available(vcpu, VCPU_EXREG_RFLAGS)) {</blue>
<blue>		kvm_register_mark_available(vcpu, VCPU_EXREG_RFLAGS);</blue>
<blue>		rflags = vmcs_readl(GUEST_RFLAGS);</blue>
<blue>		if (vmx->rmode.vm86_active) {</blue>
			rflags &amp;= RMODE_GUEST_OWNED_EFLAGS_BITS;
<yellow>			save_rflags = vmx->rmode.save_rflags;</yellow>
			rflags |= save_rflags &amp; ~RMODE_GUEST_OWNED_EFLAGS_BITS;
		}
<blue>		vmx->rflags = rflags;</blue>
	}
<blue>	return vmx->rflags;</blue>
<blue>}</blue>

void vmx_set_rflags(struct kvm_vcpu *vcpu, unsigned long rflags)
{
	struct vcpu_vmx *vmx = to_vmx(vcpu);
	unsigned long old_rflags;

<blue>	if (is_unrestricted_guest(vcpu)) {</blue>
<blue>		kvm_register_mark_available(vcpu, VCPU_EXREG_RFLAGS);</blue>
		vmx-&gt;rflags = rflags;
<blue>		vmcs_writel(GUEST_RFLAGS, rflags);</blue>
		return;
	}

	old_rflags = vmx_get_rflags(vcpu);
<blue>	vmx->rflags = rflags;</blue>
	if (vmx-&gt;rmode.vm86_active) {
<yellow>		vmx->rmode.save_rflags = rflags;</yellow>
		rflags |= X86_EFLAGS_IOPL | X86_EFLAGS_VM;
	}
<blue>	vmcs_writel(GUEST_RFLAGS, rflags);</blue>

<blue>	if ((old_rflags ^ vmx->rflags) & X86_EFLAGS_VM)</blue>
<blue>		vmx->emulation_required = vmx_emulation_required(vcpu);</blue>
<blue>}</blue>

static bool vmx_get_if_flag(struct kvm_vcpu *vcpu)
{
<blue>	return vmx_get_rflags(vcpu) & X86_EFLAGS_IF;</blue>
}

u32 vmx_get_interrupt_shadow(struct kvm_vcpu *vcpu)
{
<blue>	u32 interruptibility = vmcs_read32(GUEST_INTERRUPTIBILITY_INFO);</blue>
	int ret = 0;

<blue>	if (interruptibility & GUEST_INTR_STATE_STI)</blue>
		ret |= KVM_X86_SHADOW_INT_STI;
<blue>	if (interruptibility & GUEST_INTR_STATE_MOV_SS)</blue>
<blue>		ret |= KVM_X86_SHADOW_INT_MOV_SS;</blue>

<blue>	return ret;</blue>
<blue>}</blue>

void vmx_set_interrupt_shadow(struct kvm_vcpu *vcpu, int mask)
{
<blue>	u32 interruptibility_old = vmcs_read32(GUEST_INTERRUPTIBILITY_INFO);</blue>
	u32 interruptibility = interruptibility_old;

	interruptibility &amp;= ~(GUEST_INTR_STATE_STI | GUEST_INTR_STATE_MOV_SS);

<blue>	if (mask & KVM_X86_SHADOW_INT_MOV_SS)</blue>
<blue>		interruptibility |= GUEST_INTR_STATE_MOV_SS;</blue>
<blue>	else if (mask & KVM_X86_SHADOW_INT_STI)</blue>
<yellow>		interruptibility |= GUEST_INTR_STATE_STI;</yellow>

<blue>	if ((interruptibility != interruptibility_old))</blue>
<blue>		vmcs_write32(GUEST_INTERRUPTIBILITY_INFO, interruptibility);</blue>
<blue>}</blue>

static int vmx_rtit_ctl_check(struct kvm_vcpu *vcpu, u64 data)
{
	struct vcpu_vmx *vmx = to_vmx(vcpu);
	unsigned long value;

	/*
	 * Any MSR write that attempts to change bits marked reserved will
	 * case a #GP fault.
	 */
<yellow>	if (data & vmx->pt_desc.ctl_bitmask)</yellow>
		return 1;

	/*
	 * Any attempt to modify IA32_RTIT_CTL while TraceEn is set will
	 * result in a #GP unless the same write also clears TraceEn.
	 */
<yellow>	if ((vmx->pt_desc.guest.ctl & RTIT_CTL_TRACEEN) &&</yellow>
<yellow>		((vmx->pt_desc.guest.ctl ^ data) & ~RTIT_CTL_TRACEEN))</yellow>
		return 1;

	/*
	 * WRMSR to IA32_RTIT_CTL that sets TraceEn but clears this bit
	 * and FabricEn would cause #GP, if
	 * CPUID.(EAX=14H, ECX=0):ECX.SNGLRGNOUT[bit 2] = 0
	 */
<yellow>	if ((data & RTIT_CTL_TRACEEN) && !(data & RTIT_CTL_TOPA) &&</yellow>
		!(data &amp; RTIT_CTL_FABRIC_EN) &amp;&amp;
<yellow>		!intel_pt_validate_cap(vmx->pt_desc.caps,</yellow>
					PT_CAP_single_range_output))
		return 1;

	/*
	 * MTCFreq, CycThresh and PSBFreq encodings check, any MSR write that
	 * utilize encodings marked reserved will cause a #GP fault.
	 */
<yellow>	value = intel_pt_validate_cap(vmx->pt_desc.caps, PT_CAP_mtc_periods);</yellow>
	if (intel_pt_validate_cap(vmx-&gt;pt_desc.caps, PT_CAP_mtc) &amp;&amp;
<yellow>			!test_bit((data & RTIT_CTL_MTC_RANGE) >></yellow>
			RTIT_CTL_MTC_RANGE_OFFSET, &amp;value))
		return 1;
<yellow>	value = intel_pt_validate_cap(vmx->pt_desc.caps,</yellow>
						PT_CAP_cycle_thresholds);
	if (intel_pt_validate_cap(vmx-&gt;pt_desc.caps, PT_CAP_psb_cyc) &amp;&amp;
<yellow>			!test_bit((data & RTIT_CTL_CYC_THRESH) >></yellow>
			RTIT_CTL_CYC_THRESH_OFFSET, &amp;value))
		return 1;
<yellow>	value = intel_pt_validate_cap(vmx->pt_desc.caps, PT_CAP_psb_periods);</yellow>
	if (intel_pt_validate_cap(vmx-&gt;pt_desc.caps, PT_CAP_psb_cyc) &amp;&amp;
<yellow>			!test_bit((data & RTIT_CTL_PSB_FREQ) >></yellow>
			RTIT_CTL_PSB_FREQ_OFFSET, &amp;value))
		return 1;

	/*
	 * If ADDRx_CFG is reserved or the encodings is &gt;2 will
	 * cause a #GP fault.
	 */
<yellow>	value = (data & RTIT_CTL_ADDR0) >> RTIT_CTL_ADDR0_OFFSET;</yellow>
<yellow>	if ((value && (vmx->pt_desc.num_address_ranges < 1)) || (value > 2))</yellow>
		return 1;
<yellow>	value = (data & RTIT_CTL_ADDR1) >> RTIT_CTL_ADDR1_OFFSET;</yellow>
<yellow>	if ((value && (vmx->pt_desc.num_address_ranges < 2)) || (value > 2))</yellow>
		return 1;
<yellow>	value = (data & RTIT_CTL_ADDR2) >> RTIT_CTL_ADDR2_OFFSET;</yellow>
<yellow>	if ((value && (vmx->pt_desc.num_address_ranges < 3)) || (value > 2))</yellow>
		return 1;
<yellow>	value = (data & RTIT_CTL_ADDR3) >> RTIT_CTL_ADDR3_OFFSET;</yellow>
<yellow>	if ((value && (vmx->pt_desc.num_address_ranges < 4)) || (value > 2))</yellow>
<yellow>		return 1;</yellow>

	return 0;
}

static bool vmx_can_emulate_instruction(struct kvm_vcpu *vcpu, int emul_type,
					void *insn, int insn_len)
<yellow>{</yellow>
	/*
	 * Emulation of instructions in SGX enclaves is impossible as RIP does
	 * not point at the failing instruction, and even if it did, the code
	 * stream is inaccessible.  Inject #UD instead of exiting to userspace
	 * so that guest userspace can&#x27;t DoS the guest simply by triggering
	 * emulation (enclaves are CPL3 only).
	 */
<blue>	if (to_vmx(vcpu)->exit_reason.enclave_mode) {</blue>
<yellow>		kvm_queue_exception(vcpu, UD_VECTOR);</yellow>
		return false;
	}
	return true;
<blue>}</blue>

static int skip_emulated_instruction(struct kvm_vcpu *vcpu)
<blue>{</blue>
<blue>	union vmx_exit_reason exit_reason = to_vmx(vcpu)->exit_reason;</blue>
	unsigned long rip, orig_rip;
	u32 instr_len;

	/*
	 * Using VMCS.VM_EXIT_INSTRUCTION_LEN on EPT misconfig depends on
	 * undefined behavior: Intel&#x27;s SDM doesn&#x27;t mandate the VMCS field be
	 * set when EPT misconfig occurs.  In practice, real hardware updates
	 * VM_EXIT_INSTRUCTION_LEN on EPT misconfig, but other hypervisors
	 * (namely Hyper-V) don&#x27;t set it due to it being undefined behavior,
	 * i.e. we end up advancing IP with some random value.
	 */
<yellow>	if (!static_cpu_has(X86_FEATURE_HYPERVISOR) ||</yellow>
	    exit_reason.basic != EXIT_REASON_EPT_MISCONFIG) {
<blue>		instr_len = vmcs_read32(VM_EXIT_INSTRUCTION_LEN);</blue>

		/*
		 * Emulating an enclave&#x27;s instructions isn&#x27;t supported as KVM
		 * cannot access the enclave&#x27;s memory or its true RIP, e.g. the
		 * vmcs.GUEST_RIP points at the exit point of the enclave, not
		 * the RIP that actually triggered the VM-Exit.  But, because
		 * most instructions that cause VM-Exit will #UD in an enclave,
		 * most instruction-based VM-Exits simply do not occur.
		 *
		 * There are a few exceptions, notably the debug instructions
		 * INT1ICEBRK and INT3, as they are allowed in debug enclaves
		 * and generate #DB/#BP as expected, which KVM might intercept.
		 * But again, the CPU does the dirty work and saves an instr
		 * length of zero so VMMs don&#x27;t shoot themselves in the foot.
		 * WARN if KVM tries to skip a non-zero length instruction on
		 * a VM-Exit from an enclave.
		 */
<blue>		if (!instr_len)</blue>
			goto rip_updated;

<blue>		WARN(exit_reason.enclave_mode,</blue>
		     &quot;KVM: skipping instruction after SGX enclave VM-Exit&quot;);

<blue>		orig_rip = kvm_rip_read(vcpu);</blue>
		rip = orig_rip + instr_len;
#ifdef CONFIG_X86_64
		/*
		 * We need to mask out the high 32 bits of RIP if not in 64-bit
		 * mode, but just finding out that we are in 64-bit mode is
		 * quite expensive.  Only do it if there was a carry.
		 */
<yellow>		if (unlikely(((rip ^ orig_rip) >> 31) == 3) && !is_64_bit_mode(vcpu))</yellow>
<yellow>			rip = (u32)rip;</yellow>
#endif
<blue>		kvm_rip_write(vcpu, rip);</blue>
	} else {
<yellow>		if (!kvm_emulate_instruction(vcpu, EMULTYPE_SKIP))</yellow>
			return 0;
	}

rip_updated:
	/* skipping an emulated instruction also counts */
<blue>	vmx_set_interrupt_shadow(vcpu, 0);</blue>

	return 1;
}

/*
 * Recognizes a pending MTF VM-exit and records the nested state for later
 * delivery.
 */
static void vmx_update_emulated_instruction(struct kvm_vcpu *vcpu)
{
<blue>	struct vmcs12 *vmcs12 = get_vmcs12(vcpu);</blue>
	struct vcpu_vmx *vmx = to_vmx(vcpu);

<blue>	if (!is_guest_mode(vcpu))</blue>
		return;

	/*
	 * Per the SDM, MTF takes priority over debug-trap exceptions besides
	 * TSS T-bit traps and ICEBP (INT1).  KVM doesn&#x27;t emulate T-bit traps
	 * or ICEBP (in the emulator proper), and skipping of ICEBP after an
	 * intercepted #DB deliberately avoids single-step #DB and MTF updates
	 * as ICEBP is higher priority than both.  As instruction emulation is
	 * completed at this point (i.e. KVM is at the instruction boundary),
	 * any #DB exception pending delivery must be a debug-trap of lower
	 * priority than MTF.  Record the pending MTF state to be delivered in
	 * vmx_check_nested_events().
	 */
<yellow>	if (nested_cpu_has_mtf(vmcs12) &&</yellow>
<yellow>	    (!vcpu->arch.exception.pending ||</yellow>
<yellow>	     vcpu->arch.exception.vector == DB_VECTOR) &&</yellow>
<yellow>	    (!vcpu->arch.exception_vmexit.pending ||</yellow>
<yellow>	     vcpu->arch.exception_vmexit.vector == DB_VECTOR)) {</yellow>
<yellow>		vmx->nested.mtf_pending = true;</yellow>
<yellow>		kvm_make_request(KVM_REQ_EVENT, vcpu);</yellow>
	} else {
<blue>		vmx->nested.mtf_pending = false;</blue>
	}
<blue>}</blue>

static int vmx_skip_emulated_instruction(struct kvm_vcpu *vcpu)
{
<blue>	vmx_update_emulated_instruction(vcpu);</blue>
	return skip_emulated_instruction(vcpu);
}

static void vmx_clear_hlt(struct kvm_vcpu *vcpu)
{
	/*
	 * Ensure that we clear the HLT state in the VMCS.  We don&#x27;t need to
	 * explicitly skip the instruction because if the HLT state is set,
	 * then the instruction is already executing and RIP has already been
	 * advanced.
	 */
<blue>	if (kvm_hlt_in_guest(vcpu->kvm) &&</blue>
<yellow>			vmcs_read32(GUEST_ACTIVITY_STATE) == GUEST_ACTIVITY_HLT)</yellow>
<yellow>		vmcs_write32(GUEST_ACTIVITY_STATE, GUEST_ACTIVITY_ACTIVE);</yellow>
<yellow>}</yellow>

static void vmx_inject_exception(struct kvm_vcpu *vcpu)
{
	struct kvm_queued_exception *ex = &amp;vcpu-&gt;arch.exception;
<blue>	u32 intr_info = ex->vector | INTR_INFO_VALID_MASK;</blue>
	struct vcpu_vmx *vmx = to_vmx(vcpu);

	kvm_deliver_exception_payload(vcpu, ex);

<blue>	if (ex->has_error_code) {</blue>
		/*
		 * Despite the error code being architecturally defined as 32
		 * bits, and the VMCS field being 32 bits, Intel CPUs and thus
		 * VMX don&#x27;t actually supporting setting bits 31:16.  Hardware
		 * will (should) never provide a bogus error code, but AMD CPUs
		 * do generate error codes with bits 31:16 set, and so KVM&#x27;s
		 * ABI lets userspace shove in arbitrary 32-bit values.  Drop
		 * the upper bits to avoid VM-Fail, losing information that
		 * does&#x27;t really exist is preferable to killing the VM.
		 */
<blue>		vmcs_write32(VM_ENTRY_EXCEPTION_ERROR_CODE, (u16)ex->error_code);</blue>
<blue>		intr_info |= INTR_INFO_DELIVER_CODE_MASK;</blue>
	}

<blue>	if (vmx->rmode.vm86_active) {</blue>
		int inc_eip = 0;
<yellow>		if (kvm_exception_is_soft(ex->vector))</yellow>
<yellow>			inc_eip = vcpu->arch.event_exit_inst_len;</yellow>
<yellow>		kvm_inject_realmode_interrupt(vcpu, ex->vector, inc_eip);</yellow>
		return;
	}

<blue>	WARN_ON_ONCE(vmx->emulation_required);</blue>

<blue>	if (kvm_exception_is_soft(ex->vector)) {</blue>
<blue>		vmcs_write32(VM_ENTRY_INSTRUCTION_LEN,</blue>
<blue>			     vmx->vcpu.arch.event_exit_inst_len);</blue>
<blue>		intr_info |= INTR_TYPE_SOFT_EXCEPTION;</blue>
	} else
<blue>		intr_info |= INTR_TYPE_HARD_EXCEPTION;</blue>

<blue>	vmcs_write32(VM_ENTRY_INTR_INFO_FIELD, intr_info);</blue>

<blue>	vmx_clear_hlt(vcpu);</blue>
<blue>}</blue>

static void vmx_setup_uret_msr(struct vcpu_vmx *vmx, unsigned int msr,
			       bool load_into_hardware)
{
	struct vmx_uret_msr *uret_msr;

<blue>	uret_msr = vmx_find_uret_msr(vmx, msr);</blue>
	if (!uret_msr)
		return;

<blue>	uret_msr->load_into_hardware = load_into_hardware;</blue>
}

/*
 * Configuring user return MSRs to automatically save, load, and restore MSRs
 * that need to be shoved into hardware when running the guest.  Note, omitting
 * an MSR here does _NOT_ mean it&#x27;s not emulated, only that it will not be
 * loaded into hardware when running the guest.
 */
static void vmx_setup_uret_msrs(struct vcpu_vmx *vmx)
{
#ifdef CONFIG_X86_64
	bool load_syscall_msrs;

	/*
	 * The SYSCALL MSRs are only needed on long mode guests, and only
	 * when EFER.SCE is set.
	 */
<blue>	load_syscall_msrs = is_long_mode(&vmx->vcpu) &&</blue>
<blue>			    (vmx->vcpu.arch.efer & EFER_SCE);</blue>

<blue>	vmx_setup_uret_msr(vmx, MSR_STAR, load_syscall_msrs);</blue>
<blue>	vmx_setup_uret_msr(vmx, MSR_LSTAR, load_syscall_msrs);</blue>
<blue>	vmx_setup_uret_msr(vmx, MSR_SYSCALL_MASK, load_syscall_msrs);</blue>
#endif
<blue>	vmx_setup_uret_msr(vmx, MSR_EFER, update_transition_efer(vmx));</blue>

<blue>	vmx_setup_uret_msr(vmx, MSR_TSC_AUX,</blue>
<blue>			   guest_cpuid_has(&vmx->vcpu, X86_FEATURE_RDTSCP) ||</blue>
<blue>			   guest_cpuid_has(&vmx->vcpu, X86_FEATURE_RDPID));</blue>

	/*
	 * hle=0, rtm=0, tsx_ctrl=1 can be found with some combinations of new
	 * kernel and old userspace.  If those guests run on a tsx=off host, do
	 * allow guests to use TSX_CTRL, but don&#x27;t change the value in hardware
	 * so that TSX remains always disabled.
	 */
<blue>	vmx_setup_uret_msr(vmx, MSR_IA32_TSX_CTRL, boot_cpu_has(X86_FEATURE_RTM));</blue>

	/*
	 * The set of MSRs to load may have changed, reload MSRs before the
	 * next VM-Enter.
	 */
<blue>	vmx->guest_uret_msrs_loaded = false;</blue>
}

u64 vmx_get_l2_tsc_offset(struct kvm_vcpu *vcpu)
<yellow>{</yellow>
<blue>	struct vmcs12 *vmcs12 = get_vmcs12(vcpu);</blue>

<yellow>	if (nested_cpu_has(vmcs12, CPU_BASED_USE_TSC_OFFSETTING))</yellow>
<blue>		return vmcs12->tsc_offset;</blue>

	return 0;
<blue>}</blue>

u64 vmx_get_l2_tsc_multiplier(struct kvm_vcpu *vcpu)
{
<blue>	struct vmcs12 *vmcs12 = get_vmcs12(vcpu);</blue>

<yellow>	if (nested_cpu_has(vmcs12, CPU_BASED_USE_TSC_OFFSETTING) &&</yellow>
<blue>	    nested_cpu_has2(vmcs12, SECONDARY_EXEC_TSC_SCALING))</blue>
<blue>		return vmcs12->tsc_multiplier;</blue>

<blue>	return kvm_caps.default_tsc_scaling_ratio;</blue>
<blue>}</blue>

static void vmx_write_tsc_offset(struct kvm_vcpu *vcpu, u64 offset)
{
<blue>	vmcs_write64(TSC_OFFSET, offset);</blue>
<blue>}</blue>

static void vmx_write_tsc_multiplier(struct kvm_vcpu *vcpu, u64 multiplier)
{
<blue>	vmcs_write64(TSC_MULTIPLIER, multiplier);</blue>
<blue>}</blue>

/*
 * nested_vmx_allowed() checks whether a guest should be allowed to use VMX
 * instructions and MSRs (i.e., nested VMX). Nested VMX is disabled for
 * all guests if the &quot;nested&quot; module option is off, and can also be disabled
 * for a single guest by disabling its VMX cpuid bit.
 */
bool nested_vmx_allowed(struct kvm_vcpu *vcpu)
<yellow>{</yellow>
<blue>	return nested && guest_cpuid_has(vcpu, X86_FEATURE_VMX);</blue>
<blue>}</blue>

static inline bool vmx_feature_control_msr_valid(struct kvm_vcpu *vcpu,
						 uint64_t val)
{
<blue>	uint64_t valid_bits = to_vmx(vcpu)->msr_ia32_feature_control_valid_bits;</blue>

	return !(val &amp; ~valid_bits);
}

<blue>static int vmx_get_msr_feature(struct kvm_msr_entry *msr)</blue>
<blue>{</blue>
<blue>	switch (msr->index) {</blue>
	case MSR_IA32_VMX_BASIC ... MSR_IA32_VMX_VMFUNC:
<blue>		if (!nested)</blue>
			return 1;
<blue>		return vmx_get_vmx_msr(&vmcs_config.nested, msr->index, &msr->data);</blue>
	case MSR_IA32_PERF_CAPABILITIES:
<blue>		msr->data = vmx_get_perf_capabilities();</blue>
		return 0;
	default:
		return KVM_MSR_RET_INVALID;
	}
<yellow>}</yellow>

/*
 * Reads an msr value (of &#x27;msr_info-&gt;index&#x27;) into &#x27;msr_info-&gt;data&#x27;.
 * Returns 0 on success, non-0 otherwise.
 * Assumes vcpu_load() was already called.
 */
static int vmx_get_msr(struct kvm_vcpu *vcpu, struct msr_data *msr_info)
{
	struct vcpu_vmx *vmx = to_vmx(vcpu);
	struct vmx_uret_msr *msr;
	u32 index;

<blue>	switch (msr_info->index) {</blue>
#ifdef CONFIG_X86_64
	case MSR_FS_BASE:
<yellow>		msr_info->data = vmcs_readl(GUEST_FS_BASE);</yellow>
		break;
	case MSR_GS_BASE:
<yellow>		msr_info->data = vmcs_readl(GUEST_GS_BASE);</yellow>
		break;
	case MSR_KERNEL_GS_BASE:
<blue>		msr_info->data = vmx_read_guest_kernel_gs_base(vmx);</blue>
		break;
#endif
	case MSR_EFER:
		return kvm_get_msr_common(vcpu, msr_info);
	case MSR_IA32_TSX_CTRL:
<yellow>		if (!msr_info->host_initiated &&</yellow>
<yellow>		    !(vcpu->arch.arch_capabilities & ARCH_CAP_TSX_CTRL_MSR))</yellow>
			return 1;
		goto find_uret_msr;
	case MSR_IA32_UMWAIT_CONTROL:
<blue>		if (!msr_info->host_initiated && !vmx_has_waitpkg(vmx))</blue>
			return 1;

<blue>		msr_info->data = vmx->msr_ia32_umwait_control;</blue>
		break;
	case MSR_IA32_SPEC_CTRL:
<blue>		if (!msr_info->host_initiated &&</blue>
<yellow>		    !guest_has_spec_ctrl_msr(vcpu))</yellow>
			return 1;

<blue>		msr_info->data = to_vmx(vcpu)->spec_ctrl;</blue>
		break;
	case MSR_IA32_SYSENTER_CS:
<blue>		msr_info->data = vmcs_read32(GUEST_SYSENTER_CS);</blue>
		break;
	case MSR_IA32_SYSENTER_EIP:
<blue>		msr_info->data = vmcs_readl(GUEST_SYSENTER_EIP);</blue>
		break;
	case MSR_IA32_SYSENTER_ESP:
<blue>		msr_info->data = vmcs_readl(GUEST_SYSENTER_ESP);</blue>
		break;
	case MSR_IA32_BNDCFGS:
<yellow>		if (!kvm_mpx_supported() ||</yellow>
<yellow>		    (!msr_info->host_initiated &&</yellow>
<yellow>		     !guest_cpuid_has(vcpu, X86_FEATURE_MPX)))</yellow>
			return 1;
<yellow>		msr_info->data = vmcs_read64(GUEST_BNDCFGS);</yellow>
		break;
	case MSR_IA32_MCG_EXT_CTL:
<blue>		if (!msr_info->host_initiated &&</blue>
<yellow>		    !(vmx->msr_ia32_feature_control &</yellow>
		      FEAT_CTL_LMCE_ENABLED))
			return 1;
<blue>		msr_info->data = vcpu->arch.mcg_ext_ctl;</blue>
		break;
	case MSR_IA32_FEAT_CTL:
<blue>		msr_info->data = vmx->msr_ia32_feature_control;</blue>
		break;
	case MSR_IA32_SGXLEPUBKEYHASH0 ... MSR_IA32_SGXLEPUBKEYHASH3:
<yellow>		if (!msr_info->host_initiated &&</yellow>
<yellow>		    !guest_cpuid_has(vcpu, X86_FEATURE_SGX_LC))</yellow>
			return 1;
		msr_info-&gt;data = to_vmx(vcpu)-&gt;msr_ia32_sgxlepubkeyhash
<yellow>			[msr_info->index - MSR_IA32_SGXLEPUBKEYHASH0];</yellow>
		break;
	case MSR_IA32_VMX_BASIC ... MSR_IA32_VMX_VMFUNC:
<blue>		if (!nested_vmx_allowed(vcpu))</blue>
			return 1;
<blue>		if (vmx_get_vmx_msr(&vmx->nested.msrs, msr_info->index,</blue>
				    &amp;msr_info-&gt;data))
			return 1;
		/*
		 * Enlightened VMCS v1 doesn&#x27;t have certain VMCS fields but
		 * instead of just ignoring the features, different Hyper-V
		 * versions are either trying to use them and fail or do some
		 * sanity checking and refuse to boot. Filter all unsupported
		 * features out.
		 */
<blue>		if (!msr_info->host_initiated && guest_cpuid_has_evmcs(vcpu))</blue>
<blue>			nested_evmcs_filter_control_msr(vcpu, msr_info->index,</blue>
							&amp;msr_info-&gt;data);
		break;
	case MSR_IA32_RTIT_CTL:
<yellow>		if (!vmx_pt_mode_is_host_guest())</yellow>
			return 1;
<yellow>		msr_info->data = vmx->pt_desc.guest.ctl;</yellow>
		break;
	case MSR_IA32_RTIT_STATUS:
<yellow>		if (!vmx_pt_mode_is_host_guest())</yellow>
			return 1;
<yellow>		msr_info->data = vmx->pt_desc.guest.status;</yellow>
		break;
	case MSR_IA32_RTIT_CR3_MATCH:
<yellow>		if (!vmx_pt_mode_is_host_guest() ||</yellow>
<yellow>			!intel_pt_validate_cap(vmx->pt_desc.caps,</yellow>
						PT_CAP_cr3_filtering))
			return 1;
<yellow>		msr_info->data = vmx->pt_desc.guest.cr3_match;</yellow>
		break;
	case MSR_IA32_RTIT_OUTPUT_BASE:
<yellow>		if (!vmx_pt_mode_is_host_guest() ||</yellow>
<yellow>			(!intel_pt_validate_cap(vmx->pt_desc.caps,</yellow>
					PT_CAP_topa_output) &amp;&amp;
<yellow>			 !intel_pt_validate_cap(vmx->pt_desc.caps,</yellow>
					PT_CAP_single_range_output)))
			return 1;
<yellow>		msr_info->data = vmx->pt_desc.guest.output_base;</yellow>
		break;
	case MSR_IA32_RTIT_OUTPUT_MASK:
<yellow>		if (!vmx_pt_mode_is_host_guest() ||</yellow>
<yellow>			(!intel_pt_validate_cap(vmx->pt_desc.caps,</yellow>
					PT_CAP_topa_output) &amp;&amp;
<yellow>			 !intel_pt_validate_cap(vmx->pt_desc.caps,</yellow>
					PT_CAP_single_range_output)))
			return 1;
<yellow>		msr_info->data = vmx->pt_desc.guest.output_mask;</yellow>
		break;
	case MSR_IA32_RTIT_ADDR0_A ... MSR_IA32_RTIT_ADDR3_B:
		index = msr_info-&gt;index - MSR_IA32_RTIT_ADDR0_A;
<yellow>		if (!vmx_pt_mode_is_host_guest() ||</yellow>
<yellow>		    (index >= 2 * vmx->pt_desc.num_address_ranges))</yellow>
			return 1;
<yellow>		if (index % 2)</yellow>
<yellow>			msr_info->data = vmx->pt_desc.guest.addr_b[index / 2];</yellow>
		else
<yellow>			msr_info->data = vmx->pt_desc.guest.addr_a[index / 2];</yellow>
		break;
	case MSR_IA32_DEBUGCTLMSR:
<yellow>		msr_info->data = vmcs_read64(GUEST_IA32_DEBUGCTL);</yellow>
		break;
	default:
	find_uret_msr:
<blue>		msr = vmx_find_uret_msr(vmx, msr_info->index);</blue>
		if (msr) {
<blue>			msr_info->data = msr->data;</blue>
			break;
		}
<blue>		return kvm_get_msr_common(vcpu, msr_info);</blue>
	}

	return 0;
<blue>}</blue>

static u64 nested_vmx_truncate_sysenter_addr(struct kvm_vcpu *vcpu,
						    u64 data)
{
#ifdef CONFIG_X86_64
<blue>	if (!guest_cpuid_has(vcpu, X86_FEATURE_LM))</blue>
<yellow>		return (u32)data;</yellow>
#endif
	return (unsigned long)data;
}

static u64 vmx_get_supported_debugctl(struct kvm_vcpu *vcpu, bool host_initiated)
{
	u64 debugctl = 0;

<yellow>	if (boot_cpu_has(X86_FEATURE_BUS_LOCK_DETECT) &&</yellow>
<yellow>	    (host_initiated || guest_cpuid_has(vcpu, X86_FEATURE_BUS_LOCK_DETECT)))</yellow>
		debugctl |= DEBUGCTLMSR_BUS_LOCK_DETECT;

<yellow>	if ((vmx_get_perf_capabilities() & PMU_CAP_LBR_FMT) &&</yellow>
<yellow>	    (host_initiated || intel_pmu_lbr_is_enabled(vcpu)))</yellow>
<yellow>		debugctl |= DEBUGCTLMSR_LBR | DEBUGCTLMSR_FREEZE_LBRS_ON_PMI;</yellow>

	return debugctl;
}

/*
 * Writes msr value into the appropriate &quot;register&quot;.
 * Returns 0 on success, non-0 otherwise.
 * Assumes vcpu_load() was already called.
 */
static int vmx_set_msr(struct kvm_vcpu *vcpu, struct msr_data *msr_info)
<blue>{</blue>
	struct vcpu_vmx *vmx = to_vmx(vcpu);
	struct vmx_uret_msr *msr;
<yellow>	int ret = 0;</yellow>
<blue>	u32 msr_index = msr_info->index;</blue>
	u64 data = msr_info-&gt;data;
	u32 index;

	switch (msr_index) {
	case MSR_EFER:
		ret = kvm_set_msr_common(vcpu, msr_info);
		break;
#ifdef CONFIG_X86_64
	case MSR_FS_BASE:
<yellow>		vmx_segment_cache_clear(vmx);</yellow>
<yellow>		vmcs_writel(GUEST_FS_BASE, data);</yellow>
		break;
	case MSR_GS_BASE:
<yellow>		vmx_segment_cache_clear(vmx);</yellow>
<yellow>		vmcs_writel(GUEST_GS_BASE, data);</yellow>
		break;
	case MSR_KERNEL_GS_BASE:
<blue>		vmx_write_guest_kernel_gs_base(vmx, data);</blue>
		break;
	case MSR_IA32_XFD:
<yellow>		ret = kvm_set_msr_common(vcpu, msr_info);</yellow>
		/*
		 * Always intercepting WRMSR could incur non-negligible
		 * overhead given xfd might be changed frequently in
		 * guest context switch. Disable write interception
		 * upon the first write with a non-zero value (indicating
		 * potential usage on dynamic xfeatures). Also update
		 * exception bitmap to trap #NM for proper virtualization
		 * of guest xfd_err.
		 */
<yellow>		if (!ret && data) {</yellow>
<yellow>			vmx_disable_intercept_for_msr(vcpu, MSR_IA32_XFD,</yellow>
						      MSR_TYPE_RW);
			vcpu-&gt;arch.xfd_no_write_intercept = true;
			vmx_update_exception_bitmap(vcpu);
		}
		break;
#endif
	case MSR_IA32_SYSENTER_CS:
<blue>		if (is_guest_mode(vcpu))</blue>
<blue>			get_vmcs12(vcpu)->guest_sysenter_cs = data;</blue>
<blue>		vmcs_write32(GUEST_SYSENTER_CS, data);</blue>
		break;
	case MSR_IA32_SYSENTER_EIP:
<blue>		if (is_guest_mode(vcpu)) {</blue>
<blue>			data = nested_vmx_truncate_sysenter_addr(vcpu, data);</blue>
<blue>			get_vmcs12(vcpu)->guest_sysenter_eip = data;</blue>
		}
<blue>		vmcs_writel(GUEST_SYSENTER_EIP, data);</blue>
		break;
	case MSR_IA32_SYSENTER_ESP:
<blue>		if (is_guest_mode(vcpu)) {</blue>
<blue>			data = nested_vmx_truncate_sysenter_addr(vcpu, data);</blue>
<blue>			get_vmcs12(vcpu)->guest_sysenter_esp = data;</blue>
		}
<blue>		vmcs_writel(GUEST_SYSENTER_ESP, data);</blue>
		break;
	case MSR_IA32_DEBUGCTLMSR: {
		u64 invalid;

<yellow>		invalid = data & ~vmx_get_supported_debugctl(vcpu, msr_info->host_initiated);</yellow>
		if (invalid &amp; (DEBUGCTLMSR_BTF|DEBUGCTLMSR_LBR)) {
<yellow>			if (report_ignored_msrs)</yellow>
<yellow>				vcpu_unimpl(vcpu, "%s: BTF|LBR in IA32_DEBUGCTLMSR 0x%llx, nop\n",</yellow>
					    __func__, data);
<yellow>			data &= ~(DEBUGCTLMSR_BTF|DEBUGCTLMSR_LBR);</yellow>
			invalid &amp;= ~(DEBUGCTLMSR_BTF|DEBUGCTLMSR_LBR);
		}

<yellow>		if (invalid)</yellow>
			return 1;

<yellow>		if (is_guest_mode(vcpu) && get_vmcs12(vcpu)->vm_exit_controls &</yellow>
						VM_EXIT_SAVE_DEBUG_CONTROLS)
<yellow>			get_vmcs12(vcpu)->guest_ia32_debugctl = data;</yellow>

<yellow>		vmcs_write64(GUEST_IA32_DEBUGCTL, data);</yellow>
<yellow>		if (intel_pmu_lbr_is_enabled(vcpu) && !to_vmx(vcpu)->lbr_desc.event &&</yellow>
<yellow>		    (data & DEBUGCTLMSR_LBR))</yellow>
<yellow>			intel_pmu_create_guest_lbr_event(vcpu);</yellow>
		return 0;
	}
	case MSR_IA32_BNDCFGS:
<yellow>		if (!kvm_mpx_supported() ||</yellow>
<yellow>		    (!msr_info->host_initiated &&</yellow>
<yellow>		     !guest_cpuid_has(vcpu, X86_FEATURE_MPX)))</yellow>
			return 1;
<yellow>		if (is_noncanonical_address(data & PAGE_MASK, vcpu) ||</yellow>
<yellow>		    (data & MSR_IA32_BNDCFGS_RSVD))</yellow>
			return 1;

<yellow>		if (is_guest_mode(vcpu) &&</yellow>
<yellow>		    ((vmx->nested.msrs.entry_ctls_high & VM_ENTRY_LOAD_BNDCFGS) ||</yellow>
<yellow>		     (vmx->nested.msrs.exit_ctls_high & VM_EXIT_CLEAR_BNDCFGS)))</yellow>
<yellow>			get_vmcs12(vcpu)->guest_bndcfgs = data;</yellow>

<yellow>		vmcs_write64(GUEST_BNDCFGS, data);</yellow>
		break;
	case MSR_IA32_UMWAIT_CONTROL:
<blue>		if (!msr_info->host_initiated && !vmx_has_waitpkg(vmx))</blue>
			return 1;

		/* The reserved bit 1 and non-32 bit [63:32] should be zero */
<blue>		if (data & (BIT_ULL(1) | GENMASK_ULL(63, 32)))</blue>
			return 1;

<blue>		vmx->msr_ia32_umwait_control = data;</blue>
		break;
	case MSR_IA32_SPEC_CTRL:
<blue>		if (!msr_info->host_initiated &&</blue>
<yellow>		    !guest_has_spec_ctrl_msr(vcpu))</yellow>
			return 1;

<blue>		if (kvm_spec_ctrl_test_value(data))</blue>
			return 1;

<blue>		vmx->spec_ctrl = data;</blue>
		if (!data)
			break;

		/*
		 * For non-nested:
		 * When it&#x27;s written (to non-zero) for the first time, pass
		 * it through.
		 *
		 * For nested:
		 * The handling of the MSR bitmap for L2 guests is done in
		 * nested_vmx_prepare_msr_bitmap. We should not touch the
		 * vmcs02.msr_bitmap here since it gets completely overwritten
		 * in the merging. We update the vmcs01 here for L1 as well
		 * since it will end up touching the MSR anyway now.
		 */
<yellow>		vmx_disable_intercept_for_msr(vcpu,</yellow>
					      MSR_IA32_SPEC_CTRL,
					      MSR_TYPE_RW);
		break;
	case MSR_IA32_TSX_CTRL:
<yellow>		if (!msr_info->host_initiated &&</yellow>
<yellow>		    !(vcpu->arch.arch_capabilities & ARCH_CAP_TSX_CTRL_MSR))</yellow>
			return 1;
<yellow>		if (data & ~(TSX_CTRL_RTM_DISABLE | TSX_CTRL_CPUID_CLEAR))</yellow>
			return 1;
		goto find_uret_msr;
	case MSR_IA32_PRED_CMD:
<yellow>		if (!msr_info->host_initiated &&</yellow>
<yellow>		    !guest_has_pred_cmd_msr(vcpu))</yellow>
			return 1;

<yellow>		if (data & ~PRED_CMD_IBPB)</yellow>
			return 1;
<yellow>		if (!boot_cpu_has(X86_FEATURE_IBPB))</yellow>
			return 1;
<yellow>		if (!data)</yellow>
			break;

<yellow>		wrmsrl(MSR_IA32_PRED_CMD, PRED_CMD_IBPB);</yellow>

		/*
		 * For non-nested:
		 * When it&#x27;s written (to non-zero) for the first time, pass
		 * it through.
		 *
		 * For nested:
		 * The handling of the MSR bitmap for L2 guests is done in
		 * nested_vmx_prepare_msr_bitmap. We should not touch the
		 * vmcs02.msr_bitmap here since it gets completely overwritten
		 * in the merging.
		 */
		vmx_disable_intercept_for_msr(vcpu, MSR_IA32_PRED_CMD, MSR_TYPE_W);
		break;
	case MSR_IA32_CR_PAT:
<blue>		if (!kvm_pat_valid(data))</blue>
			return 1;

<blue>		if (is_guest_mode(vcpu) &&</blue>
<blue>		    get_vmcs12(vcpu)->vm_exit_controls & VM_EXIT_SAVE_IA32_PAT)</blue>
<yellow>			get_vmcs12(vcpu)->guest_ia32_pat = data;</yellow>

<blue>		if (vmcs_config.vmentry_ctrl & VM_ENTRY_LOAD_IA32_PAT) {</blue>
<blue>			vmcs_write64(GUEST_IA32_PAT, data);</blue>
<blue>			vcpu->arch.pat = data;</blue>
			break;
		}
		ret = kvm_set_msr_common(vcpu, msr_info);
		break;
	case MSR_IA32_MCG_EXT_CTL:
<blue>		if ((!msr_info->host_initiated &&</blue>
<yellow>		     !(to_vmx(vcpu)->msr_ia32_feature_control &</yellow>
		       FEAT_CTL_LMCE_ENABLED)) ||
<blue>		    (data & ~MCG_EXT_CTL_LMCE_EN))</blue>
			return 1;
<blue>		vcpu->arch.mcg_ext_ctl = data;</blue>
		break;
	case MSR_IA32_FEAT_CTL:
<blue>		if (!vmx_feature_control_msr_valid(vcpu, data) ||</blue>
<blue>		    (to_vmx(vcpu)->msr_ia32_feature_control &</blue>
<yellow>		     FEAT_CTL_LOCKED && !msr_info->host_initiated))</yellow>
			return 1;
<blue>		vmx->msr_ia32_feature_control = data;</blue>
<blue>		if (msr_info->host_initiated && data == 0)</blue>
<blue>			vmx_leave_nested(vcpu);</blue>

		/* SGX may be enabled/disabled by guest&#x27;s firmware */
<blue>		vmx_write_encls_bitmap(vcpu, NULL);</blue>
		break;
	case MSR_IA32_SGXLEPUBKEYHASH0 ... MSR_IA32_SGXLEPUBKEYHASH3:
		/*
		 * On real hardware, the LE hash MSRs are writable before
		 * the firmware sets bit 0 in MSR 0x7a (&quot;activating&quot; SGX),
		 * at which point SGX related bits in IA32_FEATURE_CONTROL
		 * become writable.
		 *
		 * KVM does not emulate SGX activation for simplicity, so
		 * allow writes to the LE hash MSRs if IA32_FEATURE_CONTROL
		 * is unlocked.  This is technically not architectural
		 * behavior, but it&#x27;s close enough.
		 */
<yellow>		if (!msr_info->host_initiated &&</yellow>
<yellow>		    (!guest_cpuid_has(vcpu, X86_FEATURE_SGX_LC) ||</yellow>
<yellow>		    ((vmx->msr_ia32_feature_control & FEAT_CTL_LOCKED) &&</yellow>
		    !(vmx-&gt;msr_ia32_feature_control &amp; FEAT_CTL_SGX_LC_ENABLED))))
			return 1;
		vmx-&gt;msr_ia32_sgxlepubkeyhash
<yellow>			[msr_index - MSR_IA32_SGXLEPUBKEYHASH0] = data;</yellow>
		break;
	case MSR_IA32_VMX_BASIC ... MSR_IA32_VMX_VMFUNC:
<blue>		if (!msr_info->host_initiated)</blue>
			return 1; /* they are read-only */
<blue>		if (!nested_vmx_allowed(vcpu))</blue>
			return 1;
<blue>		return vmx_set_vmx_msr(vcpu, msr_index, data);</blue>
	case MSR_IA32_RTIT_CTL:
<yellow>		if (!vmx_pt_mode_is_host_guest() ||</yellow>
<yellow>			vmx_rtit_ctl_check(vcpu, data) ||</yellow>
<yellow>			vmx->nested.vmxon)</yellow>
			return 1;
<yellow>		vmcs_write64(GUEST_IA32_RTIT_CTL, data);</yellow>
<yellow>		vmx->pt_desc.guest.ctl = data;</yellow>
		pt_update_intercept_for_msr(vcpu);
		break;
	case MSR_IA32_RTIT_STATUS:
<yellow>		if (!pt_can_write_msr(vmx))</yellow>
			return 1;
		if (data &amp; MSR_IA32_RTIT_STATUS_MASK)
			return 1;
<yellow>		vmx->pt_desc.guest.status = data;</yellow>
		break;
	case MSR_IA32_RTIT_CR3_MATCH:
<yellow>		if (!pt_can_write_msr(vmx))</yellow>
			return 1;
<yellow>		if (!intel_pt_validate_cap(vmx->pt_desc.caps,</yellow>
					   PT_CAP_cr3_filtering))
			return 1;
<yellow>		vmx->pt_desc.guest.cr3_match = data;</yellow>
		break;
	case MSR_IA32_RTIT_OUTPUT_BASE:
<yellow>		if (!pt_can_write_msr(vmx))</yellow>
			return 1;
<yellow>		if (!intel_pt_validate_cap(vmx->pt_desc.caps,</yellow>
					   PT_CAP_topa_output) &amp;&amp;
<yellow>		    !intel_pt_validate_cap(vmx->pt_desc.caps,</yellow>
					   PT_CAP_single_range_output))
			return 1;
<yellow>		if (!pt_output_base_valid(vcpu, data))</yellow>
			return 1;
<yellow>		vmx->pt_desc.guest.output_base = data;</yellow>
		break;
	case MSR_IA32_RTIT_OUTPUT_MASK:
<yellow>		if (!pt_can_write_msr(vmx))</yellow>
			return 1;
<yellow>		if (!intel_pt_validate_cap(vmx->pt_desc.caps,</yellow>
<yellow>					   PT_CAP_topa_output) &&</yellow>
<yellow>		    !intel_pt_validate_cap(vmx->pt_desc.caps,</yellow>
					   PT_CAP_single_range_output))
			return 1;
<yellow>		vmx->pt_desc.guest.output_mask = data;</yellow>
		break;
	case MSR_IA32_RTIT_ADDR0_A ... MSR_IA32_RTIT_ADDR3_B:
<yellow>		if (!pt_can_write_msr(vmx))</yellow>
			return 1;
		index = msr_info-&gt;index - MSR_IA32_RTIT_ADDR0_A;
<yellow>		if (index >= 2 * vmx->pt_desc.num_address_ranges)</yellow>
			return 1;
<yellow>		if (is_noncanonical_address(data, vcpu))</yellow>
			return 1;
<yellow>		if (index % 2)</yellow>
<yellow>			vmx->pt_desc.guest.addr_b[index / 2] = data;</yellow>
		else
<yellow>			vmx->pt_desc.guest.addr_a[index / 2] = data;</yellow>
		break;
	case MSR_IA32_PERF_CAPABILITIES:
<blue>		if (data && !vcpu_to_pmu(vcpu)->version)</blue>
			return 1;
<blue>		if (data & PMU_CAP_LBR_FMT) {</blue>
<yellow>			if ((data & PMU_CAP_LBR_FMT) !=</yellow>
<yellow>			    (vmx_get_perf_capabilities() & PMU_CAP_LBR_FMT))</yellow>
				return 1;
<yellow>			if (!cpuid_model_is_consistent(vcpu))</yellow>
				return 1;
		}
<blue>		if (data & PERF_CAP_PEBS_FORMAT) {</blue>
<yellow>			if ((data & PERF_CAP_PEBS_MASK) !=</yellow>
<yellow>			    (vmx_get_perf_capabilities() & PERF_CAP_PEBS_MASK))</yellow>
				return 1;
<yellow>			if (!guest_cpuid_has(vcpu, X86_FEATURE_DS))</yellow>
				return 1;
<yellow>			if (!guest_cpuid_has(vcpu, X86_FEATURE_DTES64))</yellow>
				return 1;
<yellow>			if (!cpuid_model_is_consistent(vcpu))</yellow>
				return 1;
		}
<blue>		ret = kvm_set_msr_common(vcpu, msr_info);</blue>
		break;

	default:
	find_uret_msr:
<blue>		msr = vmx_find_uret_msr(vmx, msr_index);</blue>
		if (msr)
<blue>			ret = vmx_set_guest_uret_msr(vmx, msr, data);</blue>
		else
<blue>			ret = kvm_set_msr_common(vcpu, msr_info);</blue>
	}

	/* FB_CLEAR may have changed, also update the FB_CLEAR_DIS behavior */
<blue>	if (msr_index == MSR_IA32_ARCH_CAPABILITIES)</blue>
<blue>		vmx_update_fb_clear_dis(vcpu, vmx);</blue>

	return ret;
}

static void vmx_cache_reg(struct kvm_vcpu *vcpu, enum kvm_reg reg)
{
	unsigned long guest_owned_bits;

<blue>	kvm_register_mark_available(vcpu, reg);</blue>

	switch (reg) {
	case VCPU_REGS_RSP:
<blue>		vcpu->arch.regs[VCPU_REGS_RSP] = vmcs_readl(GUEST_RSP);</blue>
		break;
	case VCPU_REGS_RIP:
<blue>		vcpu->arch.regs[VCPU_REGS_RIP] = vmcs_readl(GUEST_RIP);</blue>
		break;
	case VCPU_EXREG_PDPTR:
<yellow>		if (enable_ept)</yellow>
<yellow>			ept_save_pdptrs(vcpu);</yellow>
		break;
	case VCPU_EXREG_CR0:
<blue>		guest_owned_bits = vcpu->arch.cr0_guest_owned_bits;</blue>

		vcpu-&gt;arch.cr0 &amp;= ~guest_owned_bits;
<blue>		vcpu->arch.cr0 |= vmcs_readl(GUEST_CR0) & guest_owned_bits;</blue>
		break;
	case VCPU_EXREG_CR3:
		/*
		 * When intercepting CR3 loads, e.g. for shadowing paging, KVM&#x27;s
		 * CR3 is loaded into hardware, not the guest&#x27;s CR3.
		 */
<blue>		if (!(exec_controls_get(to_vmx(vcpu)) & CPU_BASED_CR3_LOAD_EXITING))</blue>
<blue>			vcpu->arch.cr3 = vmcs_readl(GUEST_CR3);</blue>
		break;
	case VCPU_EXREG_CR4:
<blue>		guest_owned_bits = vcpu->arch.cr4_guest_owned_bits;</blue>

		vcpu-&gt;arch.cr4 &amp;= ~guest_owned_bits;
<blue>		vcpu->arch.cr4 |= vmcs_readl(GUEST_CR4) & guest_owned_bits;</blue>
		break;
	default:
<yellow>		KVM_BUG_ON(1, vcpu->kvm);</yellow>
		break;
	}
<blue>}</blue>

static __init int cpu_has_kvm_support(void)
{
	return cpu_has_vmx();
}

static __init int vmx_disabled_by_bios(void)
{
	return !boot_cpu_has(X86_FEATURE_MSR_IA32_FEAT_CTL) ||
	       !boot_cpu_has(X86_FEATURE_VMX);
}

static int kvm_cpu_vmxon(u64 vmxon_pointer)
{
	u64 msr;

<yellow>	cr4_set_bits(X86_CR4_VMXE);</yellow>

<blue>	asm_volatile_goto("1: vmxon %[vmxon_pointer]\n\t"</blue>
			  _ASM_EXTABLE(1b, %l[fault])
			  : : [vmxon_pointer] &quot;m&quot;(vmxon_pointer)
			  : : fault);
	return 0;

fault:
<yellow>	WARN_ONCE(1, "VMXON faulted, MSR_IA32_FEAT_CTL (0x3a) = 0x%llx\n",</yellow>
		  rdmsrl_safe(MSR_IA32_FEAT_CTL, &amp;msr) ? 0xdeadbeef : msr);
	cr4_clear_bits(X86_CR4_VMXE);

<yellow>	return -EFAULT;</yellow>
}

static int vmx_hardware_enable(void)
<blue>{</blue>
<blue>	int cpu = raw_smp_processor_id();</blue>
<blue>	u64 phys_addr = __pa(per_cpu(vmxarea, cpu));</blue>
	int r;

	if (cr4_read_shadow() &amp; X86_CR4_VMXE)
		return -EBUSY;

	/*
	 * This can happen if we hot-added a CPU but failed to allocate
	 * VP assist page for it.
	 */
<blue>	if (static_branch_unlikely(&enable_evmcs) &&</blue>
<yellow>	    !hv_get_vp_assist_page(cpu))</yellow>
		return -EFAULT;

<blue>	intel_pt_handle_vmx(1);</blue>

<blue>	r = kvm_cpu_vmxon(phys_addr);</blue>
	if (r) {
		intel_pt_handle_vmx(0);
		return r;
	}

<blue>	if (enable_ept)</blue>
<blue>		ept_sync_global();</blue>

<blue>	return 0;</blue>
}

static void vmclear_local_loaded_vmcss(void)
{
<yellow>	int cpu = raw_smp_processor_id();</yellow>
	struct loaded_vmcs *v, *n;

	list_for_each_entry_safe(v, n, &amp;per_cpu(loaded_vmcss_on_cpu, cpu),
				 loaded_vmcss_on_cpu_link)
<yellow>		__loaded_vmcs_clear(v);</yellow>
}

static void vmx_hardware_disable(void)
{
<yellow>	vmclear_local_loaded_vmcss();</yellow>

<yellow>	if (cpu_vmxoff())</yellow>
		kvm_spurious_fault();

<yellow>	intel_pt_handle_vmx(0);</yellow>
}

/*
 * There is no X86_FEATURE for SGX yet, but anyway we need to query CPUID
 * directly instead of going through cpu_has(), to ensure KVM is trapping
 * ENCLS whenever it&#x27;s supported in hardware.  It does not matter whether
 * the host OS supports or has enabled SGX.
 */
static bool cpu_has_sgx(void)
{
	return cpuid_eax(0) &gt;= 0x12 &amp;&amp; (cpuid_eax(0x12) &amp; BIT(0));
}

/*
 * Some cpus support VM_{ENTRY,EXIT}_IA32_PERF_GLOBAL_CTRL but they
 * can&#x27;t be used due to errata where VM Exit may incorrectly clear
 * IA32_PERF_GLOBAL_CTRL[34:32]. Work around the errata by using the
 * MSR load mechanism to switch IA32_PERF_GLOBAL_CTRL.
 */
<blue>static bool cpu_has_perf_global_ctrl_bug(void)</blue>
{
<blue>	if (boot_cpu_data.x86 == 0x6) {</blue>
<blue>		switch (boot_cpu_data.x86_model) {</blue>
		case INTEL_FAM6_NEHALEM_EP:	/* AAK155 */
		case INTEL_FAM6_NEHALEM:	/* AAP115 */
		case INTEL_FAM6_WESTMERE:	/* AAT100 */
		case INTEL_FAM6_WESTMERE_EP:	/* BC86,AAY89,BD102 */
		case INTEL_FAM6_NEHALEM_EX:	/* BA97 */
			return true;
		default:
			break;
		}
	}

	return false;
}

static __init int adjust_vmx_controls(u32 ctl_min, u32 ctl_opt,
				      u32 msr, u32 *result)
{
	u32 vmx_msr_low, vmx_msr_high;
	u32 ctl = ctl_min | ctl_opt;

	rdmsr(msr, vmx_msr_low, vmx_msr_high);

	ctl &amp;= vmx_msr_high; /* bit == 0 in high word ==&gt; must be zero */
	ctl |= vmx_msr_low;  /* bit == 1 in low word  ==&gt; must be one  */

	/* Ensure minimum (required) set of control bits are supported. */
	if (ctl_min &amp; ~ctl)
		return -EIO;

	*result = ctl;
	return 0;
}

static __init u64 adjust_vmx_controls64(u64 ctl_opt, u32 msr)
{
	u64 allowed;

	rdmsrl(msr, allowed);

	return  ctl_opt &amp; allowed;
}

static __init int setup_vmcs_config(struct vmcs_config *vmcs_conf,
				    struct vmx_capability *vmx_cap)
{
	u32 vmx_msr_low, vmx_msr_high;
	u32 _pin_based_exec_control = 0;
	u32 _cpu_based_exec_control = 0;
	u32 _cpu_based_2nd_exec_control = 0;
	u64 _cpu_based_3rd_exec_control = 0;
	u32 _vmexit_control = 0;
	u32 _vmentry_control = 0;
	u64 misc_msr;
	int i;

	/*
	 * LOAD/SAVE_DEBUG_CONTROLS are absent because both are mandatory.
	 * SAVE_IA32_PAT and SAVE_IA32_EFER are absent because KVM always
	 * intercepts writes to PAT and EFER, i.e. never enables those controls.
	 */
	struct {
		u32 entry_control;
		u32 exit_control;
	} const vmcs_entry_exit_pairs[] = {
		{ VM_ENTRY_LOAD_IA32_PERF_GLOBAL_CTRL,	VM_EXIT_LOAD_IA32_PERF_GLOBAL_CTRL },
		{ VM_ENTRY_LOAD_IA32_PAT,		VM_EXIT_LOAD_IA32_PAT },
		{ VM_ENTRY_LOAD_IA32_EFER,		VM_EXIT_LOAD_IA32_EFER },
		{ VM_ENTRY_LOAD_BNDCFGS,		VM_EXIT_CLEAR_BNDCFGS },
		{ VM_ENTRY_LOAD_IA32_RTIT_CTL,		VM_EXIT_CLEAR_IA32_RTIT_CTL },
	};

	memset(vmcs_conf, 0, sizeof(*vmcs_conf));

	if (adjust_vmx_controls(KVM_REQUIRED_VMX_CPU_BASED_VM_EXEC_CONTROL,
				KVM_OPTIONAL_VMX_CPU_BASED_VM_EXEC_CONTROL,
				MSR_IA32_VMX_PROCBASED_CTLS,
				&amp;_cpu_based_exec_control))
		return -EIO;
	if (_cpu_based_exec_control &amp; CPU_BASED_ACTIVATE_SECONDARY_CONTROLS) {
		if (adjust_vmx_controls(KVM_REQUIRED_VMX_SECONDARY_VM_EXEC_CONTROL,
					KVM_OPTIONAL_VMX_SECONDARY_VM_EXEC_CONTROL,
					MSR_IA32_VMX_PROCBASED_CTLS2,
					&amp;_cpu_based_2nd_exec_control))
			return -EIO;
	}
#ifndef CONFIG_X86_64
	if (!(_cpu_based_2nd_exec_control &amp;
				SECONDARY_EXEC_VIRTUALIZE_APIC_ACCESSES))
		_cpu_based_exec_control &amp;= ~CPU_BASED_TPR_SHADOW;
#endif

	if (!(_cpu_based_exec_control &amp; CPU_BASED_TPR_SHADOW))
		_cpu_based_2nd_exec_control &amp;= ~(
				SECONDARY_EXEC_APIC_REGISTER_VIRT |
				SECONDARY_EXEC_VIRTUALIZE_X2APIC_MODE |
				SECONDARY_EXEC_VIRTUAL_INTR_DELIVERY);

	rdmsr_safe(MSR_IA32_VMX_EPT_VPID_CAP,
		&amp;vmx_cap-&gt;ept, &amp;vmx_cap-&gt;vpid);

	if (!(_cpu_based_2nd_exec_control &amp; SECONDARY_EXEC_ENABLE_EPT) &amp;&amp;
	    vmx_cap-&gt;ept) {
		pr_warn_once(&quot;EPT CAP should not exist if not support &quot;
				&quot;1-setting enable EPT VM-execution control\n&quot;);

		if (error_on_inconsistent_vmcs_config)
			return -EIO;

		vmx_cap-&gt;ept = 0;
	}
	if (!(_cpu_based_2nd_exec_control &amp; SECONDARY_EXEC_ENABLE_VPID) &amp;&amp;
	    vmx_cap-&gt;vpid) {
		pr_warn_once(&quot;VPID CAP should not exist if not support &quot;
				&quot;1-setting enable VPID VM-execution control\n&quot;);

		if (error_on_inconsistent_vmcs_config)
			return -EIO;

		vmx_cap-&gt;vpid = 0;
	}

	if (!cpu_has_sgx())
		_cpu_based_2nd_exec_control &amp;= ~SECONDARY_EXEC_ENCLS_EXITING;

	if (_cpu_based_exec_control &amp; CPU_BASED_ACTIVATE_TERTIARY_CONTROLS)
		_cpu_based_3rd_exec_control =
			adjust_vmx_controls64(KVM_OPTIONAL_VMX_TERTIARY_VM_EXEC_CONTROL,
					      MSR_IA32_VMX_PROCBASED_CTLS3);

	if (adjust_vmx_controls(KVM_REQUIRED_VMX_VM_EXIT_CONTROLS,
				KVM_OPTIONAL_VMX_VM_EXIT_CONTROLS,
				MSR_IA32_VMX_EXIT_CTLS,
				&amp;_vmexit_control))
		return -EIO;

	if (adjust_vmx_controls(KVM_REQUIRED_VMX_PIN_BASED_VM_EXEC_CONTROL,
				KVM_OPTIONAL_VMX_PIN_BASED_VM_EXEC_CONTROL,
				MSR_IA32_VMX_PINBASED_CTLS,
				&amp;_pin_based_exec_control))
		return -EIO;

	if (cpu_has_broken_vmx_preemption_timer())
		_pin_based_exec_control &amp;= ~PIN_BASED_VMX_PREEMPTION_TIMER;
	if (!(_cpu_based_2nd_exec_control &amp;
		SECONDARY_EXEC_VIRTUAL_INTR_DELIVERY))
		_pin_based_exec_control &amp;= ~PIN_BASED_POSTED_INTR;

	if (adjust_vmx_controls(KVM_REQUIRED_VMX_VM_ENTRY_CONTROLS,
				KVM_OPTIONAL_VMX_VM_ENTRY_CONTROLS,
				MSR_IA32_VMX_ENTRY_CTLS,
				&amp;_vmentry_control))
		return -EIO;

	for (i = 0; i &lt; ARRAY_SIZE(vmcs_entry_exit_pairs); i++) {
		u32 n_ctrl = vmcs_entry_exit_pairs[i].entry_control;
		u32 x_ctrl = vmcs_entry_exit_pairs[i].exit_control;

		if (!(_vmentry_control &amp; n_ctrl) == !(_vmexit_control &amp; x_ctrl))
			continue;

		pr_warn_once(&quot;Inconsistent VM-Entry/VM-Exit pair, entry = %x, exit = %x\n&quot;,
			     _vmentry_control &amp; n_ctrl, _vmexit_control &amp; x_ctrl);

		if (error_on_inconsistent_vmcs_config)
			return -EIO;

		_vmentry_control &amp;= ~n_ctrl;
		_vmexit_control &amp;= ~x_ctrl;
	}

	rdmsr(MSR_IA32_VMX_BASIC, vmx_msr_low, vmx_msr_high);

	/* IA-32 SDM Vol 3B: VMCS size is never greater than 4kB. */
	if ((vmx_msr_high &amp; 0x1fff) &gt; PAGE_SIZE)
		return -EIO;

#ifdef CONFIG_X86_64
	/* IA-32 SDM Vol 3B: 64-bit CPUs always have VMX_BASIC_MSR[48]==0. */
	if (vmx_msr_high &amp; (1u&lt;&lt;16))
		return -EIO;
#endif

	/* Require Write-Back (WB) memory type for VMCS accesses. */
	if (((vmx_msr_high &gt;&gt; 18) &amp; 15) != 6)
		return -EIO;

	rdmsrl(MSR_IA32_VMX_MISC, misc_msr);

	vmcs_conf-&gt;size = vmx_msr_high &amp; 0x1fff;
	vmcs_conf-&gt;basic_cap = vmx_msr_high &amp; ~0x1fff;

	vmcs_conf-&gt;revision_id = vmx_msr_low;

	vmcs_conf-&gt;pin_based_exec_ctrl = _pin_based_exec_control;
	vmcs_conf-&gt;cpu_based_exec_ctrl = _cpu_based_exec_control;
	vmcs_conf-&gt;cpu_based_2nd_exec_ctrl = _cpu_based_2nd_exec_control;
	vmcs_conf-&gt;cpu_based_3rd_exec_ctrl = _cpu_based_3rd_exec_control;
	vmcs_conf-&gt;vmexit_ctrl         = _vmexit_control;
	vmcs_conf-&gt;vmentry_ctrl        = _vmentry_control;
	vmcs_conf-&gt;misc	= misc_msr;

	return 0;
}

struct vmcs *alloc_vmcs_cpu(bool shadow, int cpu, gfp_t flags)
<blue>{</blue>
<blue>	int node = cpu_to_node(cpu);</blue>
	struct page *pages;
	struct vmcs *vmcs;

<blue>	pages = __alloc_pages_node(node, flags, 0);</blue>
	if (!pages)
		return NULL;
<blue>	vmcs = page_address(pages);</blue>
	memset(vmcs, 0, vmcs_config.size);

	/* KVM supports Enlightened VMCS v1 only */
	if (static_branch_unlikely(&amp;enable_evmcs))
<blue>		vmcs->hdr.revision_id = KVM_EVMCS_VERSION;</blue>
	else
<blue>		vmcs->hdr.revision_id = vmcs_config.revision_id;</blue>

	if (shadow)
<blue>		vmcs->hdr.shadow_vmcs = 1;</blue>
	return vmcs;
}

void free_vmcs(struct vmcs *vmcs)
{
<blue>	free_page((unsigned long)vmcs);</blue>
}

/*
 * Free a VMCS, but before that VMCLEAR it on the CPU where it was last loaded
 */
<yellow>void free_loaded_vmcs(struct loaded_vmcs *loaded_vmcs)</yellow>
{
<blue>	if (!loaded_vmcs->vmcs)</blue>
		return;
<blue>	loaded_vmcs_clear(loaded_vmcs);</blue>
<blue>	free_vmcs(loaded_vmcs->vmcs);</blue>
<yellow>	loaded_vmcs->vmcs = NULL;</yellow>
<yellow>	if (loaded_vmcs->msr_bitmap)</yellow>
<blue>		free_page((unsigned long)loaded_vmcs->msr_bitmap);</blue>
<blue>	WARN_ON(loaded_vmcs->shadow_vmcs != NULL);</blue>
<blue>}</blue>

int alloc_loaded_vmcs(struct loaded_vmcs *loaded_vmcs)
<blue>{</blue>
<blue>	loaded_vmcs->vmcs = alloc_vmcs(false);</blue>
	if (!loaded_vmcs-&gt;vmcs)
		return -ENOMEM;

<blue>	vmcs_clear(loaded_vmcs->vmcs);</blue>

<blue>	loaded_vmcs->shadow_vmcs = NULL;</blue>
	loaded_vmcs-&gt;hv_timer_soft_disabled = false;
	loaded_vmcs-&gt;cpu = -1;
	loaded_vmcs-&gt;launched = 0;

	if (cpu_has_vmx_msr_bitmap()) {
		loaded_vmcs-&gt;msr_bitmap = (unsigned long *)
<blue>				__get_free_page(GFP_KERNEL_ACCOUNT);</blue>
		if (!loaded_vmcs-&gt;msr_bitmap)
			goto out_vmcs;
<blue>		memset(loaded_vmcs->msr_bitmap, 0xff, PAGE_SIZE);</blue>
	}

<blue>	memset(&loaded_vmcs->host_state, 0, sizeof(struct vmcs_host_state));</blue>
	memset(&amp;loaded_vmcs-&gt;controls_shadow, 0,
		sizeof(struct vmcs_controls_shadow));

	return 0;

out_vmcs:
<yellow>	free_loaded_vmcs(loaded_vmcs);</yellow>
	return -ENOMEM;
}

static void free_kvm_area(void)
<yellow>{</yellow>
	int cpu;

<yellow>	for_each_possible_cpu(cpu) {</yellow>
<yellow>		free_vmcs(per_cpu(vmxarea, cpu));</yellow>
<yellow>		per_cpu(vmxarea, cpu) = NULL;</yellow>
	}
<yellow>}</yellow>

static __init int alloc_kvm_area(void)
{
	int cpu;

	for_each_possible_cpu(cpu) {
		struct vmcs *vmcs;

		vmcs = alloc_vmcs_cpu(false, cpu, GFP_KERNEL);
		if (!vmcs) {
			free_kvm_area();
			return -ENOMEM;
		}

		/*
		 * When eVMCS is enabled, alloc_vmcs_cpu() sets
		 * vmcs-&gt;revision_id to KVM_EVMCS_VERSION instead of
		 * revision_id reported by MSR_IA32_VMX_BASIC.
		 *
		 * However, even though not explicitly documented by
		 * TLFS, VMXArea passed as VMXON argument should
		 * still be marked with revision_id reported by
		 * physical CPU.
		 */
		if (static_branch_unlikely(&amp;enable_evmcs))
			vmcs-&gt;hdr.revision_id = vmcs_config.revision_id;

		per_cpu(vmxarea, cpu) = vmcs;
	}
	return 0;
}

static void fix_pmode_seg(struct kvm_vcpu *vcpu, int seg,
		struct kvm_segment *save)
{
<yellow>	if (!emulate_invalid_guest_state) {</yellow>
		/*
		 * CS and SS RPL should be equal during guest entry according
		 * to VMX spec, but in reality it is not always so. Since vcpu
		 * is in the middle of the transition from real mode to
		 * protected mode it is safe to assume that RPL 0 is a good
		 * default value.
		 */
		if (seg == VCPU_SREG_CS || seg == VCPU_SREG_SS)
<yellow>			save->selector &= ~SEGMENT_RPL_MASK;</yellow>
<yellow>		save->dpl = save->selector & SEGMENT_RPL_MASK;</yellow>
		save-&gt;s = 1;
	}
<yellow>	__vmx_set_segment(vcpu, save, seg);</yellow>
}

static void enter_pmode(struct kvm_vcpu *vcpu)
{
	unsigned long flags;
	struct vcpu_vmx *vmx = to_vmx(vcpu);

	/*
	 * Update real mode segment cache. It may be not up-to-date if segment
	 * register was written while vcpu was in a guest mode.
	 */
<yellow>	vmx_get_segment(vcpu, &vmx->rmode.segs[VCPU_SREG_ES], VCPU_SREG_ES);</yellow>
	vmx_get_segment(vcpu, &amp;vmx-&gt;rmode.segs[VCPU_SREG_DS], VCPU_SREG_DS);
	vmx_get_segment(vcpu, &amp;vmx-&gt;rmode.segs[VCPU_SREG_FS], VCPU_SREG_FS);
	vmx_get_segment(vcpu, &amp;vmx-&gt;rmode.segs[VCPU_SREG_GS], VCPU_SREG_GS);
	vmx_get_segment(vcpu, &amp;vmx-&gt;rmode.segs[VCPU_SREG_SS], VCPU_SREG_SS);
	vmx_get_segment(vcpu, &amp;vmx-&gt;rmode.segs[VCPU_SREG_CS], VCPU_SREG_CS);

	vmx-&gt;rmode.vm86_active = 0;

	__vmx_set_segment(vcpu, &amp;vmx-&gt;rmode.segs[VCPU_SREG_TR], VCPU_SREG_TR);

<yellow>	flags = vmcs_readl(GUEST_RFLAGS);</yellow>
<yellow>	flags &= RMODE_GUEST_OWNED_EFLAGS_BITS;</yellow>
<yellow>	flags |= vmx->rmode.save_rflags & ~RMODE_GUEST_OWNED_EFLAGS_BITS;</yellow>
<yellow>	vmcs_writel(GUEST_RFLAGS, flags);</yellow>

<yellow>	vmcs_writel(GUEST_CR4, (vmcs_readl(GUEST_CR4) & ~X86_CR4_VME) |</yellow>
<yellow>			(vmcs_readl(CR4_READ_SHADOW) & X86_CR4_VME));</yellow>

<yellow>	vmx_update_exception_bitmap(vcpu);</yellow>

<yellow>	fix_pmode_seg(vcpu, VCPU_SREG_CS, &vmx->rmode.segs[VCPU_SREG_CS]);</yellow>
<yellow>	fix_pmode_seg(vcpu, VCPU_SREG_SS, &vmx->rmode.segs[VCPU_SREG_SS]);</yellow>
<yellow>	fix_pmode_seg(vcpu, VCPU_SREG_ES, &vmx->rmode.segs[VCPU_SREG_ES]);</yellow>
<yellow>	fix_pmode_seg(vcpu, VCPU_SREG_DS, &vmx->rmode.segs[VCPU_SREG_DS]);</yellow>
<yellow>	fix_pmode_seg(vcpu, VCPU_SREG_FS, &vmx->rmode.segs[VCPU_SREG_FS]);</yellow>
<yellow>	fix_pmode_seg(vcpu, VCPU_SREG_GS, &vmx->rmode.segs[VCPU_SREG_GS]);</yellow>
}

static void fix_rmode_seg(int seg, struct kvm_segment *save)
<yellow>{</yellow>
<yellow>	const struct kvm_vmx_segment_field *sf = &kvm_vmx_segment_fields[seg];</yellow>
	struct kvm_segment var = *save;

	var.dpl = 0x3;
	if (seg == VCPU_SREG_CS)
<yellow>		var.type = 0x3;</yellow>

<yellow>	if (!emulate_invalid_guest_state) {</yellow>
<yellow>		var.selector = var.base >> 4;</yellow>
		var.base = var.base &amp; 0xffff0;
		var.limit = 0xffff;
		var.g = 0;
		var.db = 0;
		var.present = 1;
		var.s = 1;
		var.l = 0;
		var.unusable = 0;
		var.type = 0x3;
		var.avl = 0;
		if (save-&gt;base &amp; 0xf)
<yellow>			printk_once(KERN_WARNING "kvm: segment base is not "</yellow>
					&quot;paragraph aligned when entering &quot;
					&quot;protected mode (seg=%d)&quot;, seg);
	}

<yellow>	vmcs_write16(sf->selector, var.selector);</yellow>
<yellow>	vmcs_writel(sf->base, var.base);</yellow>
<yellow>	vmcs_write32(sf->limit, var.limit);</yellow>
<yellow>	vmcs_write32(sf->ar_bytes, vmx_segment_access_rights(&var));</yellow>
}

static void enter_rmode(struct kvm_vcpu *vcpu)
{
	unsigned long flags;
	struct vcpu_vmx *vmx = to_vmx(vcpu);
<yellow>	struct kvm_vmx *kvm_vmx = to_kvm_vmx(vcpu->kvm);</yellow>

	vmx_get_segment(vcpu, &amp;vmx-&gt;rmode.segs[VCPU_SREG_TR], VCPU_SREG_TR);
	vmx_get_segment(vcpu, &amp;vmx-&gt;rmode.segs[VCPU_SREG_ES], VCPU_SREG_ES);
	vmx_get_segment(vcpu, &amp;vmx-&gt;rmode.segs[VCPU_SREG_DS], VCPU_SREG_DS);
	vmx_get_segment(vcpu, &amp;vmx-&gt;rmode.segs[VCPU_SREG_FS], VCPU_SREG_FS);
	vmx_get_segment(vcpu, &amp;vmx-&gt;rmode.segs[VCPU_SREG_GS], VCPU_SREG_GS);
	vmx_get_segment(vcpu, &amp;vmx-&gt;rmode.segs[VCPU_SREG_SS], VCPU_SREG_SS);
	vmx_get_segment(vcpu, &amp;vmx-&gt;rmode.segs[VCPU_SREG_CS], VCPU_SREG_CS);

	vmx-&gt;rmode.vm86_active = 1;

	/*
	 * Very old userspace does not call KVM_SET_TSS_ADDR before entering
	 * vcpu. Warn the user that an update is overdue.
	 */
	if (!kvm_vmx-&gt;tss_addr)
<yellow>		printk_once(KERN_WARNING "kvm: KVM_SET_TSS_ADDR need to be "</yellow>
			     &quot;called before entering vcpu\n&quot;);

<yellow>	vmx_segment_cache_clear(vmx);</yellow>

<yellow>	vmcs_writel(GUEST_TR_BASE, kvm_vmx->tss_addr);</yellow>
<yellow>	vmcs_write32(GUEST_TR_LIMIT, RMODE_TSS_SIZE - 1);</yellow>
<yellow>	vmcs_write32(GUEST_TR_AR_BYTES, 0x008b);</yellow>

<yellow>	flags = vmcs_readl(GUEST_RFLAGS);</yellow>
<yellow>	vmx->rmode.save_rflags = flags;</yellow>

<yellow>	flags |= X86_EFLAGS_IOPL | X86_EFLAGS_VM;</yellow>

<yellow>	vmcs_writel(GUEST_RFLAGS, flags);</yellow>
<yellow>	vmcs_writel(GUEST_CR4, vmcs_readl(GUEST_CR4) | X86_CR4_VME);</yellow>
<yellow>	vmx_update_exception_bitmap(vcpu);</yellow>

	fix_rmode_seg(VCPU_SREG_SS, &amp;vmx-&gt;rmode.segs[VCPU_SREG_SS]);
	fix_rmode_seg(VCPU_SREG_CS, &amp;vmx-&gt;rmode.segs[VCPU_SREG_CS]);
	fix_rmode_seg(VCPU_SREG_ES, &amp;vmx-&gt;rmode.segs[VCPU_SREG_ES]);
	fix_rmode_seg(VCPU_SREG_DS, &amp;vmx-&gt;rmode.segs[VCPU_SREG_DS]);
	fix_rmode_seg(VCPU_SREG_GS, &amp;vmx-&gt;rmode.segs[VCPU_SREG_GS]);
	fix_rmode_seg(VCPU_SREG_FS, &amp;vmx-&gt;rmode.segs[VCPU_SREG_FS]);
}

int vmx_set_efer(struct kvm_vcpu *vcpu, u64 efer)
{
	struct vcpu_vmx *vmx = to_vmx(vcpu);

	/* Nothing to do if hardware doesn&#x27;t support EFER. */
<blue>	if (!vmx_find_uret_msr(vmx, MSR_EFER))</blue>
		return 0;

<blue>	vcpu->arch.efer = efer;</blue>
#ifdef CONFIG_X86_64
	if (efer &amp; EFER_LMA)
<blue>		vm_entry_controls_setbit(vmx, VM_ENTRY_IA32E_MODE);</blue>
	else
<blue>		vm_entry_controls_clearbit(vmx, VM_ENTRY_IA32E_MODE);</blue>
#else
	if (KVM_BUG_ON(efer &amp; EFER_LMA, vcpu-&gt;kvm))
		return 1;
#endif

<blue>	vmx_setup_uret_msrs(vmx);</blue>
	return 0;
<blue>}</blue>

#ifdef CONFIG_X86_64

static void enter_lmode(struct kvm_vcpu *vcpu)
{
	u32 guest_tr_ar;

<blue>	vmx_segment_cache_clear(to_vmx(vcpu));</blue>

<blue>	guest_tr_ar = vmcs_read32(GUEST_TR_AR_BYTES);</blue>
<blue>	if ((guest_tr_ar & VMX_AR_TYPE_MASK) != VMX_AR_TYPE_BUSY_64_TSS) {</blue>
<yellow>		pr_debug_ratelimited("%s: tss fixup for long mode. \n",</yellow>
				     __func__);
<yellow>		vmcs_write32(GUEST_TR_AR_BYTES,</yellow>
<yellow>			     (guest_tr_ar & ~VMX_AR_TYPE_MASK)</yellow>
			     | VMX_AR_TYPE_BUSY_64_TSS);
	}
<blue>	vmx_set_efer(vcpu, vcpu->arch.efer | EFER_LMA);</blue>
}

static void exit_lmode(struct kvm_vcpu *vcpu)
{
<yellow>	vmx_set_efer(vcpu, vcpu->arch.efer & ~EFER_LMA);</yellow>
}

#endif

<blue>static void vmx_flush_tlb_all(struct kvm_vcpu *vcpu)</blue>
<blue>{</blue>
	struct vcpu_vmx *vmx = to_vmx(vcpu);

	/*
	 * INVEPT must be issued when EPT is enabled, irrespective of VPID, as
	 * the CPU is not required to invalidate guest-physical mappings on
	 * VM-Entry, even if VPID is disabled.  Guest-physical mappings are
	 * associated with the root EPT structure and not any particular VPID
	 * (INVVPID also isn&#x27;t required to invalidate guest-physical mappings).
	 */
<blue>	if (enable_ept) {</blue>
<blue>		ept_sync_global();</blue>
<yellow>	} else if (enable_vpid) {</yellow>
<yellow>		if (cpu_has_vmx_invvpid_global()) {</yellow>
<yellow>			vpid_sync_vcpu_global();</yellow>
		} else {
<yellow>			vpid_sync_vcpu_single(vmx->vpid);</yellow>
<blue>			vpid_sync_vcpu_single(vmx->nested.vpid02);</blue>
		}
	}
}

<blue>static inline int vmx_get_current_vpid(struct kvm_vcpu *vcpu)</blue>
{
<blue>	if (is_guest_mode(vcpu))</blue>
<blue>		return nested_get_vpid02(vcpu);</blue>
<blue>	return to_vmx(vcpu)->vpid;</blue>
}

<blue>static void vmx_flush_tlb_current(struct kvm_vcpu *vcpu)</blue>
<blue>{</blue>
<blue>	struct kvm_mmu *mmu = vcpu->arch.mmu;</blue>
	u64 root_hpa = mmu-&gt;root.hpa;

	/* No flush required if the current context is invalid. */
	if (!VALID_PAGE(root_hpa))
		return;

<blue>	if (enable_ept)</blue>
<blue>		ept_sync_context(construct_eptp(vcpu, root_hpa,</blue>
<blue>						mmu->root_role.level));</blue>
	else
<blue>		vpid_sync_context(vmx_get_current_vpid(vcpu));</blue>
}

static void vmx_flush_tlb_gva(struct kvm_vcpu *vcpu, gva_t addr)
<yellow>{</yellow>
	/*
	 * vpid_sync_vcpu_addr() is a nop if vpid==0, see the comment in
	 * vmx_flush_tlb_guest() for an explanation of why this is ok.
	 */
<yellow>	vpid_sync_vcpu_addr(vmx_get_current_vpid(vcpu), addr);</yellow>
<yellow>}</yellow>

static void vmx_flush_tlb_guest(struct kvm_vcpu *vcpu)
<blue>{</blue>
	/*
	 * vpid_sync_context() is a nop if vpid==0, e.g. if enable_vpid==0 or a
	 * vpid couldn&#x27;t be allocated for this vCPU.  VM-Enter and VM-Exit are
	 * required to flush GVA-&gt;{G,H}PA mappings from the TLB if vpid is
	 * disabled (VM-Enter with vpid enabled and vpid==0 is disallowed),
	 * i.e. no explicit INVVPID is necessary.
	 */
<blue>	vpid_sync_context(vmx_get_current_vpid(vcpu));</blue>
}

void vmx_ept_load_pdptrs(struct kvm_vcpu *vcpu)
{
<blue>	struct kvm_mmu *mmu = vcpu->arch.walk_mmu;</blue>

	if (!kvm_register_is_dirty(vcpu, VCPU_EXREG_PDPTR))
		return;

<blue>	if (is_pae_paging(vcpu)) {</blue>
<yellow>		vmcs_write64(GUEST_PDPTR0, mmu->pdptrs[0]);</yellow>
<yellow>		vmcs_write64(GUEST_PDPTR1, mmu->pdptrs[1]);</yellow>
<yellow>		vmcs_write64(GUEST_PDPTR2, mmu->pdptrs[2]);</yellow>
<yellow>		vmcs_write64(GUEST_PDPTR3, mmu->pdptrs[3]);</yellow>
	}
<blue>}</blue>

void ept_save_pdptrs(struct kvm_vcpu *vcpu)
{
<yellow>	struct kvm_mmu *mmu = vcpu->arch.walk_mmu;</yellow>

<yellow>	if (WARN_ON_ONCE(!is_pae_paging(vcpu)))</yellow>
		return;

<yellow>	mmu->pdptrs[0] = vmcs_read64(GUEST_PDPTR0);</yellow>
<yellow>	mmu->pdptrs[1] = vmcs_read64(GUEST_PDPTR1);</yellow>
<yellow>	mmu->pdptrs[2] = vmcs_read64(GUEST_PDPTR2);</yellow>
<yellow>	mmu->pdptrs[3] = vmcs_read64(GUEST_PDPTR3);</yellow>

<yellow>	kvm_register_mark_available(vcpu, VCPU_EXREG_PDPTR);</yellow>
<yellow>}</yellow>

#define CR3_EXITING_BITS (CPU_BASED_CR3_LOAD_EXITING | \
			  CPU_BASED_CR3_STORE_EXITING)

void vmx_set_cr0(struct kvm_vcpu *vcpu, unsigned long cr0)
{
	struct vcpu_vmx *vmx = to_vmx(vcpu);
	unsigned long hw_cr0, old_cr0_pg;
	u32 tmp;

<blue>	old_cr0_pg = kvm_read_cr0_bits(vcpu, X86_CR0_PG);</blue>

	hw_cr0 = (cr0 &amp; ~KVM_VM_CR0_ALWAYS_OFF);
<blue>	if (is_unrestricted_guest(vcpu))</blue>
<blue>		hw_cr0 |= KVM_VM_CR0_ALWAYS_ON_UNRESTRICTED_GUEST;</blue>
	else {
<blue>		hw_cr0 |= KVM_VM_CR0_ALWAYS_ON;</blue>
<blue>		if (!enable_ept)</blue>
<yellow>			hw_cr0 |= X86_CR0_WP;</yellow>

<blue>		if (vmx->rmode.vm86_active && (cr0 & X86_CR0_PE))</blue>
<yellow>			enter_pmode(vcpu);</yellow>

<blue>		if (!vmx->rmode.vm86_active && !(cr0 & X86_CR0_PE))</blue>
<yellow>			enter_rmode(vcpu);</yellow>
	}

<blue>	vmcs_writel(CR0_READ_SHADOW, cr0);</blue>
<blue>	vmcs_writel(GUEST_CR0, hw_cr0);</blue>
<blue>	vcpu->arch.cr0 = cr0;</blue>
	kvm_register_mark_available(vcpu, VCPU_EXREG_CR0);

#ifdef CONFIG_X86_64
	if (vcpu-&gt;arch.efer &amp; EFER_LME) {
<blue>		if (!old_cr0_pg && (cr0 & X86_CR0_PG))</blue>
<blue>			enter_lmode(vcpu);</blue>
<blue>		else if (old_cr0_pg && !(cr0 & X86_CR0_PG))</blue>
<yellow>			exit_lmode(vcpu);</yellow>
	}
#endif

<blue>	if (enable_ept && !is_unrestricted_guest(vcpu)) {</blue>
		/*
		 * Ensure KVM has an up-to-date snapshot of the guest&#x27;s CR3.  If
		 * the below code _enables_ CR3 exiting, vmx_cache_reg() will
		 * (correctly) stop reading vmcs.GUEST_CR3 because it thinks
		 * KVM&#x27;s CR3 is installed.
		 */
<blue>		if (!kvm_register_is_available(vcpu, VCPU_EXREG_CR3))</blue>
<blue>			vmx_cache_reg(vcpu, VCPU_EXREG_CR3);</blue>

		/*
		 * When running with EPT but not unrestricted guest, KVM must
		 * intercept CR3 accesses when paging is _disabled_.  This is
		 * necessary because restricted guests can&#x27;t actually run with
		 * paging disabled, and so KVM stuffs its own CR3 in order to
		 * run the guest when identity mapped page tables.
		 *
		 * Do _NOT_ check the old CR0.PG, e.g. to optimize away the
		 * update, it may be stale with respect to CR3 interception,
		 * e.g. after nested VM-Enter.
		 *
		 * Lastly, honor L1&#x27;s desires, i.e. intercept CR3 loads and/or
		 * stores to forward them to L1, even if KVM does not need to
		 * intercept them to preserve its identity mapped page tables.
		 */
<blue>		if (!(cr0 & X86_CR0_PG)) {</blue>
<yellow>			exec_controls_setbit(vmx, CR3_EXITING_BITS);</yellow>
<blue>		} else if (!is_guest_mode(vcpu)) {</blue>
<yellow>			exec_controls_clearbit(vmx, CR3_EXITING_BITS);</yellow>
		} else {
			tmp = exec_controls_get(vmx);
			tmp &amp;= ~CR3_EXITING_BITS;
<blue>			tmp |= get_vmcs12(vcpu)->cpu_based_vm_exec_control & CR3_EXITING_BITS;</blue>
<yellow>			exec_controls_set(vmx, tmp);</yellow>
		}

		/* Note, vmx_set_cr4() consumes the new vcpu-&gt;arch.cr0. */
<blue>		if ((old_cr0_pg ^ cr0) & X86_CR0_PG)</blue>
<yellow>			vmx_set_cr4(vcpu, kvm_read_cr4(vcpu));</yellow>

		/*
		 * When !CR0_PG -&gt; CR0_PG, vcpu-&gt;arch.cr3 becomes active, but
		 * GUEST_CR3 is still vmx-&gt;ept_identity_map_addr if EPT + !URG.
		 */
<blue>		if (!(old_cr0_pg & X86_CR0_PG) && (cr0 & X86_CR0_PG))</blue>
<yellow>			kvm_register_mark_dirty(vcpu, VCPU_EXREG_CR3);</yellow>
	}

	/* depends on vcpu-&gt;arch.cr0 to be set to a new value */
<blue>	vmx->emulation_required = vmx_emulation_required(vcpu);</blue>
}

static int vmx_get_max_tdp_level(void)
{
	if (cpu_has_vmx_ept_5levels())
		return 5;
	return 4;
}

u64 construct_eptp(struct kvm_vcpu *vcpu, hpa_t root_hpa, int root_level)
{
	u64 eptp = VMX_EPTP_MT_WB;

<blue>	eptp |= (root_level == 5) ? VMX_EPTP_PWL_5 : VMX_EPTP_PWL_4;</blue>

<blue>	if (enable_ept_ad_bits &&</blue>
<blue>	    (!is_guest_mode(vcpu) || nested_ept_ad_enabled(vcpu)))</blue>
<blue>		eptp |= VMX_EPTP_AD_ENABLE_BIT;</blue>
<blue>	eptp |= root_hpa;</blue>

	return eptp;
}

static void vmx_load_mmu_pgd(struct kvm_vcpu *vcpu, hpa_t root_hpa,
			     int root_level)
{
<blue>	struct kvm *kvm = vcpu->kvm;</blue>
	bool update_guest_cr3 = true;
	unsigned long guest_cr3;
	u64 eptp;

<blue>	if (enable_ept) {</blue>
<blue>		eptp = construct_eptp(vcpu, root_hpa, root_level);</blue>
<blue>		vmcs_write64(EPT_POINTER, eptp);</blue>

<blue>		hv_track_root_tdp(vcpu, root_hpa);</blue>

<blue>		if (!enable_unrestricted_guest && !is_paging(vcpu))</blue>
<yellow>			guest_cr3 = to_kvm_vmx(kvm)->ept_identity_map_addr;</yellow>
<blue>		else if (kvm_register_is_dirty(vcpu, VCPU_EXREG_CR3))</blue>
<blue>			guest_cr3 = vcpu->arch.cr3;</blue>
		else /* vmcs.GUEST_CR3 is already up-to-date. */
			update_guest_cr3 = false;
<blue>		vmx_ept_load_pdptrs(vcpu);</blue>
	} else {
<yellow>		guest_cr3 = root_hpa | kvm_get_active_pcid(vcpu);</yellow>
	}

	if (update_guest_cr3)
<blue>		vmcs_writel(GUEST_CR3, guest_cr3);</blue>
<blue>}</blue>


<blue>static bool vmx_is_valid_cr4(struct kvm_vcpu *vcpu, unsigned long cr4)</blue>
<yellow>{</yellow>
	/*
	 * We operate under the default treatment of SMM, so VMX cannot be
	 * enabled under SMM.  Note, whether or not VMXE is allowed at all,
	 * i.e. is a reserved bit, is handled by common x86 code.
	 */
<blue>	if ((cr4 & X86_CR4_VMXE) && is_smm(vcpu))</blue>
		return false;

<blue>	if (to_vmx(vcpu)->nested.vmxon && !nested_cr4_valid(vcpu, cr4))</blue>
		return false;

	return true;
<blue>}</blue>

void vmx_set_cr4(struct kvm_vcpu *vcpu, unsigned long cr4)
{
<blue>	unsigned long old_cr4 = vcpu->arch.cr4;</blue>
	struct vcpu_vmx *vmx = to_vmx(vcpu);
	/*
	 * Pass through host&#x27;s Machine Check Enable value to hw_cr4, which
	 * is in force while we are in guest mode.  Do not let guests control
	 * this bit, even if host CR4.MCE == 0.
	 */
	unsigned long hw_cr4;

	hw_cr4 = (cr4_read_shadow() &amp; X86_CR4_MCE) | (cr4 &amp; ~X86_CR4_MCE);
<blue>	if (is_unrestricted_guest(vcpu))</blue>
<blue>		hw_cr4 |= KVM_VM_CR4_ALWAYS_ON_UNRESTRICTED_GUEST;</blue>
<blue>	else if (vmx->rmode.vm86_active)</blue>
<yellow>		hw_cr4 |= KVM_RMODE_VM_CR4_ALWAYS_ON;</yellow>
	else
<blue>		hw_cr4 |= KVM_PMODE_VM_CR4_ALWAYS_ON;</blue>

<blue>	if (!boot_cpu_has(X86_FEATURE_UMIP) && vmx_umip_emulated()) {</blue>
<yellow>		if (cr4 & X86_CR4_UMIP) {</yellow>
<yellow>			secondary_exec_controls_setbit(vmx, SECONDARY_EXEC_DESC);</yellow>
<yellow>			hw_cr4 &= ~X86_CR4_UMIP;</yellow>
<yellow>		} else if (!is_guest_mode(vcpu) ||</yellow>
<yellow>			!nested_cpu_has2(get_vmcs12(vcpu), SECONDARY_EXEC_DESC)) {</yellow>
<yellow>			secondary_exec_controls_clearbit(vmx, SECONDARY_EXEC_DESC);</yellow>
		}
	}

<blue>	vcpu->arch.cr4 = cr4;</blue>
	kvm_register_mark_available(vcpu, VCPU_EXREG_CR4);

<blue>	if (!is_unrestricted_guest(vcpu)) {</blue>
<blue>		if (enable_ept) {</blue>
<blue>			if (!is_paging(vcpu)) {</blue>
<yellow>				hw_cr4 &= ~X86_CR4_PAE;</yellow>
				hw_cr4 |= X86_CR4_PSE;
<blue>			} else if (!(cr4 & X86_CR4_PAE)) {</blue>
<blue>				hw_cr4 &= ~X86_CR4_PAE;</blue>
			}
		}

		/*
		 * SMEP/SMAP/PKU is disabled if CPU is in non-paging mode in
		 * hardware.  To emulate this behavior, SMEP/SMAP/PKU needs
		 * to be manually disabled when guest switches to non-paging
		 * mode.
		 *
		 * If !enable_unrestricted_guest, the CPU is always running
		 * with CR0.PG=1 and CR4 needs to be modified.
		 * If enable_unrestricted_guest, the CPU automatically
		 * disables SMEP/SMAP/PKU when the guest sets CR0.PG=0.
		 */
<yellow>		if (!is_paging(vcpu))</yellow>
<yellow>			hw_cr4 &= ~(X86_CR4_SMEP | X86_CR4_SMAP | X86_CR4_PKE);</yellow>
	}

<blue>	vmcs_writel(CR4_READ_SHADOW, cr4);</blue>
<blue>	vmcs_writel(GUEST_CR4, hw_cr4);</blue>

<blue>	if ((cr4 ^ old_cr4) & (X86_CR4_OSXSAVE | X86_CR4_PKE))</blue>
<blue>		kvm_update_cpuid_runtime(vcpu);</blue>
<blue>}</blue>

void vmx_get_segment(struct kvm_vcpu *vcpu, struct kvm_segment *var, int seg)
<yellow>{</yellow>
	struct vcpu_vmx *vmx = to_vmx(vcpu);
	u32 ar;

<blue>	if (vmx->rmode.vm86_active && seg != VCPU_SREG_LDTR) {</blue>
<yellow>		*var = vmx->rmode.segs[seg];</yellow>
		if (seg == VCPU_SREG_TR
<yellow>		    || var->selector == vmx_read_guest_seg_selector(vmx, seg))</yellow>
			return;
<yellow>		var->base = vmx_read_guest_seg_base(vmx, seg);</yellow>
<yellow>		var->selector = vmx_read_guest_seg_selector(vmx, seg);</yellow>
		return;
	}
<blue>	var->base = vmx_read_guest_seg_base(vmx, seg);</blue>
<blue>	var->limit = vmx_read_guest_seg_limit(vmx, seg);</blue>
<yellow>	var->selector = vmx_read_guest_seg_selector(vmx, seg);</yellow>
<yellow>	ar = vmx_read_guest_seg_ar(vmx, seg);</yellow>
<yellow>	var->unusable = (ar >> 16) & 1;</yellow>
<yellow>	var->type = ar & 15;</yellow>
<yellow>	var->s = (ar >> 4) & 1;</yellow>
<yellow>	var->dpl = (ar >> 5) & 3;</yellow>
	/*
	 * Some userspaces do not preserve unusable property. Since usable
	 * segment has to be present according to VMX spec we can use present
	 * property to amend userspace bug by making unusable segment always
	 * nonpresent. vmx_segment_access_rights() already marks nonpresent
	 * segment as unusable.
	 */
<yellow>	var->present = !var->unusable;</yellow>
<yellow>	var->avl = (ar >> 12) & 1;</yellow>
<yellow>	var->l = (ar >> 13) & 1;</yellow>
<yellow>	var->db = (ar >> 14) & 1;</yellow>
<yellow>	var->g = (ar >> 15) & 1;</yellow>
<blue>}</blue>

<yellow>static u64 vmx_get_segment_base(struct kvm_vcpu *vcpu, int seg)</yellow>
<blue>{</blue>
	struct kvm_segment s;

<blue>	if (to_vmx(vcpu)->rmode.vm86_active) {</blue>
<yellow>		vmx_get_segment(vcpu, &s, seg);</yellow>
		return s.base;
	}
<blue>	return vmx_read_guest_seg_base(to_vmx(vcpu), seg);</blue>
<yellow>}</yellow>

int vmx_get_cpl(struct kvm_vcpu *vcpu)
<yellow>{</yellow>
	struct vcpu_vmx *vmx = to_vmx(vcpu);

<blue>	if (unlikely(vmx->rmode.vm86_active))</blue>
<yellow>		return 0;</yellow>
	else {
<blue>		int ar = vmx_read_guest_seg_ar(vmx, VCPU_SREG_SS);</blue>
<blue>		return VMX_AR_DPL(ar);</blue>
	}
<yellow>}</yellow>

<blue>static u32 vmx_segment_access_rights(struct kvm_segment *var)</blue>
{
	u32 ar;

<blue>	if (var->unusable || !var->present)</blue>
		ar = 1 &lt;&lt; 16;
	else {
<blue>		ar = var->type & 15;</blue>
<blue>		ar |= (var->s & 1) << 4;</blue>
<yellow>		ar |= (var->dpl & 3) << 5;</yellow>
<yellow>		ar |= (var->present & 1) << 7;</yellow>
<yellow>		ar |= (var->avl & 1) << 12;</yellow>
<yellow>		ar |= (var->l & 1) << 13;</yellow>
<yellow>		ar |= (var->db & 1) << 14;</yellow>
<yellow>		ar |= (var->g & 1) << 15;</yellow>
	}

	return ar;
<blue>}</blue>

void __vmx_set_segment(struct kvm_vcpu *vcpu, struct kvm_segment *var, int seg)
{
	struct vcpu_vmx *vmx = to_vmx(vcpu);
<blue>	const struct kvm_vmx_segment_field *sf = &kvm_vmx_segment_fields[seg];</blue>

	vmx_segment_cache_clear(vmx);

<yellow>	if (vmx->rmode.vm86_active && seg != VCPU_SREG_LDTR) {</yellow>
<yellow>		vmx->rmode.segs[seg] = *var;</yellow>
		if (seg == VCPU_SREG_TR)
<yellow>			vmcs_write16(sf->selector, var->selector);</yellow>
<yellow>		else if (var->s)</yellow>
<yellow>			fix_rmode_seg(seg, &vmx->rmode.segs[seg]);</yellow>
		return;
	}

<blue>	vmcs_writel(sf->base, var->base);</blue>
<blue>	vmcs_write32(sf->limit, var->limit);</blue>
<blue>	vmcs_write16(sf->selector, var->selector);</blue>

	/*
	 *   Fix the &quot;Accessed&quot; bit in AR field of segment registers for older
	 * qemu binaries.
	 *   IA32 arch specifies that at the time of processor reset the
	 * &quot;Accessed&quot; bit in the AR field of segment registers is 1. And qemu
	 * is setting it to 0 in the userland code. This causes invalid guest
	 * state vmexit when &quot;unrestricted guest&quot; mode is turned on.
	 *    Fix for this setup issue in cpu_reset is being pushed in the qemu
	 * tree. Newer qemu binaries with that qemu fix would not need this
	 * kvm hack.
	 */
<blue>	if (is_unrestricted_guest(vcpu) && (seg != VCPU_SREG_LDTR))</blue>
<blue>		var->type |= 0x1; /* Accessed */</blue>

<blue>	vmcs_write32(sf->ar_bytes, vmx_segment_access_rights(var));</blue>
<blue>}</blue>

static void vmx_set_segment(struct kvm_vcpu *vcpu, struct kvm_segment *var, int seg)
{
<blue>	__vmx_set_segment(vcpu, var, seg);</blue>

<blue>	to_vmx(vcpu)->emulation_required = vmx_emulation_required(vcpu);</blue>
}

static void vmx_get_cs_db_l_bits(struct kvm_vcpu *vcpu, int *db, int *l)
<yellow>{</yellow>
<blue>	u32 ar = vmx_read_guest_seg_ar(to_vmx(vcpu), VCPU_SREG_CS);</blue>

<yellow>	*db = (ar >> 14) & 1;</yellow>
<yellow>	*l = (ar >> 13) & 1;</yellow>
<yellow>}</yellow>

static void vmx_get_idt(struct kvm_vcpu *vcpu, struct desc_ptr *dt)
<yellow>{</yellow>
<blue>	dt->size = vmcs_read32(GUEST_IDTR_LIMIT);</blue>
<blue>	dt->address = vmcs_readl(GUEST_IDTR_BASE);</blue>
}

static void vmx_set_idt(struct kvm_vcpu *vcpu, struct desc_ptr *dt)
{
<blue>	vmcs_write32(GUEST_IDTR_LIMIT, dt->size);</blue>
<blue>	vmcs_writel(GUEST_IDTR_BASE, dt->address);</blue>
<blue>}</blue>

static void vmx_get_gdt(struct kvm_vcpu *vcpu, struct desc_ptr *dt)
{
<blue>	dt->size = vmcs_read32(GUEST_GDTR_LIMIT);</blue>
<blue>	dt->address = vmcs_readl(GUEST_GDTR_BASE);</blue>
<yellow>}</yellow>

static void vmx_set_gdt(struct kvm_vcpu *vcpu, struct desc_ptr *dt)
{
<blue>	vmcs_write32(GUEST_GDTR_LIMIT, dt->size);</blue>
<blue>	vmcs_writel(GUEST_GDTR_BASE, dt->address);</blue>
<blue>}</blue>

static bool rmode_segment_valid(struct kvm_vcpu *vcpu, int seg)
<blue>{</blue>
	struct kvm_segment var;
	u32 ar;

<blue>	vmx_get_segment(vcpu, &var, seg);</blue>
	var.dpl = 0x3;
	if (seg == VCPU_SREG_CS)
<blue>		var.type = 0x3;</blue>
<blue>	ar = vmx_segment_access_rights(&var);</blue>

<blue>	if (var.base != (var.selector << 4))</blue>
<yellow>		return false;</yellow>
<blue>	if (var.limit != 0xffff)</blue>
		return false;
<yellow>	if (ar != 0xf3)</yellow>
		return false;

	return true;
<yellow>}</yellow>

static bool code_segment_valid(struct kvm_vcpu *vcpu)
{
	struct kvm_segment cs;
	unsigned int cs_rpl;

<blue>	vmx_get_segment(vcpu, &cs, VCPU_SREG_CS);</blue>
<blue>	cs_rpl = cs.selector & SEGMENT_RPL_MASK;</blue>

	if (cs.unusable)
		return false;
<blue>	if (~cs.type & (VMX_AR_TYPE_CODE_MASK|VMX_AR_TYPE_ACCESSES_MASK))</blue>
		return false;
<blue>	if (!cs.s)</blue>
		return false;
	if (cs.type &amp; VMX_AR_TYPE_WRITEABLE_MASK) {
<blue>		if (cs.dpl > cs_rpl)</blue>
			return false;
	} else {
<blue>		if (cs.dpl != cs_rpl)</blue>
			return false;
	}
<blue>	if (!cs.present)</blue>
		return false;

	/* TODO: Add Reserved field check, this&#x27;ll require a new member in the kvm_segment_field structure */
	return true;
}

static bool stack_segment_valid(struct kvm_vcpu *vcpu)
{
	struct kvm_segment ss;
	unsigned int ss_rpl;

<blue>	vmx_get_segment(vcpu, &ss, VCPU_SREG_SS);</blue>
	ss_rpl = ss.selector &amp; SEGMENT_RPL_MASK;

	if (ss.unusable)
		return true;
<blue>	if (ss.type != 3 && ss.type != 7)</blue>
		return false;
<blue>	if (!ss.s)</blue>
		return false;
<blue>	if (ss.dpl != ss_rpl) /* DPL != RPL */</blue>
		return false;
<blue>	if (!ss.present)</blue>
		return false;

	return true;
}

static bool data_segment_valid(struct kvm_vcpu *vcpu, int seg)
<blue>{</blue>
	struct kvm_segment var;
	unsigned int rpl;

<blue>	vmx_get_segment(vcpu, &var, seg);</blue>
<yellow>	rpl = var.selector & SEGMENT_RPL_MASK;</yellow>

	if (var.unusable)
		return true;
<blue>	if (!var.s)</blue>
<yellow>		return false;</yellow>
<blue>	if (!var.present)</blue>
		return false;
<blue>	if (~var.type & (VMX_AR_TYPE_CODE_MASK|VMX_AR_TYPE_WRITEABLE_MASK)) {</blue>
<blue>		if (var.dpl < rpl) /* DPL < RPL */</blue>
			return false;
	}

	/* TODO: Add other members to kvm_segment_field to allow checking for other access
	 * rights flags
	 */
	return true;
<yellow>}</yellow>

static bool tr_valid(struct kvm_vcpu *vcpu)
{
	struct kvm_segment tr;

<blue>	vmx_get_segment(vcpu, &tr, VCPU_SREG_TR);</blue>

	if (tr.unusable)
		return false;
<blue>	if (tr.selector & SEGMENT_TI_MASK)	/* TI = 1 */</blue>
		return false;
<blue>	if (tr.type != 3 && tr.type != 11) /* TODO: Check if guest is in IA32e mode */</blue>
		return false;
<blue>	if (!tr.present)</blue>
<blue>		return false;</blue>

	return true;
}

static bool ldtr_valid(struct kvm_vcpu *vcpu)
{
	struct kvm_segment ldtr;

<blue>	vmx_get_segment(vcpu, &ldtr, VCPU_SREG_LDTR);</blue>

	if (ldtr.unusable)
		return true;
<blue>	if (ldtr.selector & SEGMENT_TI_MASK)	/* TI = 1 */</blue>
		return false;
<blue>	if (ldtr.type != 2)</blue>
		return false;
<blue>	if (!ldtr.present)</blue>
		return false;

	return true;
}

static bool cs_ss_rpl_check(struct kvm_vcpu *vcpu)
{
	struct kvm_segment cs, ss;

	vmx_get_segment(vcpu, &amp;cs, VCPU_SREG_CS);
<blue>	vmx_get_segment(vcpu, &ss, VCPU_SREG_SS);</blue>

	return ((cs.selector &amp; SEGMENT_RPL_MASK) ==
		 (ss.selector &amp; SEGMENT_RPL_MASK));
}

/*
 * Check if guest state is valid. Returns true if valid, false if
 * not.
 * We assume that registers are always usable
 */
bool __vmx_guest_state_valid(struct kvm_vcpu *vcpu)
<blue>{</blue>
	/* real mode guest state checks */
<blue>	if (!is_protmode(vcpu) || (vmx_get_rflags(vcpu) & X86_EFLAGS_VM)) {</blue>
<blue>		if (!rmode_segment_valid(vcpu, VCPU_SREG_CS))</blue>
			return false;
<yellow>		if (!rmode_segment_valid(vcpu, VCPU_SREG_SS))</yellow>
			return false;
<yellow>		if (!rmode_segment_valid(vcpu, VCPU_SREG_DS))</yellow>
			return false;
<yellow>		if (!rmode_segment_valid(vcpu, VCPU_SREG_ES))</yellow>
			return false;
<yellow>		if (!rmode_segment_valid(vcpu, VCPU_SREG_FS))</yellow>
			return false;
<yellow>		if (!rmode_segment_valid(vcpu, VCPU_SREG_GS))</yellow>
			return false;
	} else {
	/* protected mode guest state checks */
<blue>		if (!cs_ss_rpl_check(vcpu))</blue>
			return false;
<blue>		if (!code_segment_valid(vcpu))</blue>
			return false;
<blue>		if (!stack_segment_valid(vcpu))</blue>
			return false;
<blue>		if (!data_segment_valid(vcpu, VCPU_SREG_DS))</blue>
			return false;
<blue>		if (!data_segment_valid(vcpu, VCPU_SREG_ES))</blue>
			return false;
<blue>		if (!data_segment_valid(vcpu, VCPU_SREG_FS))</blue>
			return false;
<blue>		if (!data_segment_valid(vcpu, VCPU_SREG_GS))</blue>
			return false;
<blue>		if (!tr_valid(vcpu))</blue>
			return false;
<blue>		if (!ldtr_valid(vcpu))</blue>
			return false;
	}
	/* TODO:
	 * - Add checks on RIP
	 * - Add checks on RFLAGS
	 */

	return true;
}

static int init_rmode_tss(struct kvm *kvm, void __user *ua)
{
<yellow>	const void *zero_page = (const void *) __va(page_to_phys(ZERO_PAGE(0)));</yellow>
	u16 data;
	int i;

<yellow>	for (i = 0; i < 3; i++) {</yellow>
<yellow>		if (__copy_to_user(ua + PAGE_SIZE * i, zero_page, PAGE_SIZE))</yellow>
			return -EFAULT;
	}

<yellow>	data = TSS_BASE_SIZE + TSS_REDIRECTION_SIZE;</yellow>
<yellow>	if (__copy_to_user(ua + TSS_IOPB_BASE_OFFSET, &data, sizeof(u16)))</yellow>
		return -EFAULT;

	data = ~0;
<yellow>	if (__copy_to_user(ua + RMODE_TSS_SIZE - 1, &data, sizeof(u8)))</yellow>
		return -EFAULT;

	return 0;
}

static int init_rmode_identity_map(struct kvm *kvm)
{
	struct kvm_vmx *kvm_vmx = to_kvm_vmx(kvm);
	int i, r = 0;
	void __user *uaddr;
	u32 tmp;

	/* Protect kvm_vmx-&gt;ept_identity_pagetable_done. */
	mutex_lock(&amp;kvm-&gt;slots_lock);

<yellow>	if (likely(kvm_vmx->ept_identity_pagetable_done))</yellow>
		goto out;

<yellow>	if (!kvm_vmx->ept_identity_map_addr)</yellow>
<yellow>		kvm_vmx->ept_identity_map_addr = VMX_EPT_IDENTITY_PAGETABLE_ADDR;</yellow>

<yellow>	uaddr = __x86_set_memory_region(kvm,</yellow>
					IDENTITY_PAGETABLE_PRIVATE_MEMSLOT,
					kvm_vmx-&gt;ept_identity_map_addr,
					PAGE_SIZE);
	if (IS_ERR(uaddr)) {
		r = PTR_ERR(uaddr);
		goto out;
	}

	/* Set up identity-mapping pagetable for EPT in real mode */
<yellow>	for (i = 0; i < (PAGE_SIZE / sizeof(tmp)); i++) {</yellow>
<yellow>		tmp = (i << 22) + (_PAGE_PRESENT | _PAGE_RW | _PAGE_USER |</yellow>
			_PAGE_ACCESSED | _PAGE_DIRTY | _PAGE_PSE);
		if (__copy_to_user(uaddr + i * sizeof(tmp), &amp;tmp, sizeof(tmp))) {
			r = -EFAULT;
			goto out;
		}
	}
<yellow>	kvm_vmx->ept_identity_pagetable_done = true;</yellow>

out:
<yellow>	mutex_unlock(&kvm->slots_lock);</yellow>
	return r;
}

static void seg_setup(int seg)
{
<blue>	const struct kvm_vmx_segment_field *sf = &kvm_vmx_segment_fields[seg];</blue>
	unsigned int ar;

<blue>	vmcs_write16(sf->selector, 0);</blue>
<blue>	vmcs_writel(sf->base, 0);</blue>
<blue>	vmcs_write32(sf->limit, 0xffff);</blue>
	ar = 0x93;
<blue>	if (seg == VCPU_SREG_CS)</blue>
		ar |= 0x08; /* code segment */

<blue>	vmcs_write32(sf->ar_bytes, ar);</blue>
<blue>}</blue>

static int alloc_apic_access_page(struct kvm *kvm)
{
	struct page *page;
	void __user *hva;
	int ret = 0;

	mutex_lock(&amp;kvm-&gt;slots_lock);
<blue>	if (kvm->arch.apic_access_memslot_enabled)</blue>
		goto out;
<blue>	hva = __x86_set_memory_region(kvm, APIC_ACCESS_PAGE_PRIVATE_MEMSLOT,</blue>
				      APIC_DEFAULT_PHYS_BASE, PAGE_SIZE);
	if (IS_ERR(hva)) {
<yellow>		ret = PTR_ERR(hva);</yellow>
		goto out;
	}

<blue>	page = gfn_to_page(kvm, APIC_DEFAULT_PHYS_BASE >> PAGE_SHIFT);</blue>
	if (is_error_page(page)) {
		ret = -EFAULT;
		goto out;
	}

	/*
	 * Do not pin the page in memory, so that memory hot-unplug
	 * is able to migrate it.
	 */
<blue>	put_page(page);</blue>
	kvm-&gt;arch.apic_access_memslot_enabled = true;
out:
<yellow>	mutex_unlock(&kvm->slots_lock);</yellow>
	return ret;
}

<blue>int allocate_vpid(void)</blue>
{
	int vpid;

<blue>	if (!enable_vpid)</blue>
		return 0;
<blue>	spin_lock(&vmx_vpid_lock);</blue>
	vpid = find_first_zero_bit(vmx_vpid_bitmap, VMX_NR_VPIDS);
	if (vpid &lt; VMX_NR_VPIDS)
<blue>		__set_bit(vpid, vmx_vpid_bitmap);</blue>
	else
		vpid = 0;
<blue>	spin_unlock(&vmx_vpid_lock);</blue>
	return vpid;
<blue>}</blue>

<blue>void free_vpid(int vpid)</blue>
{
<blue>	if (!enable_vpid || vpid == 0)</blue>
		return;
<blue>	spin_lock(&vmx_vpid_lock);</blue>
	__clear_bit(vpid, vmx_vpid_bitmap);
	spin_unlock(&amp;vmx_vpid_lock);
<blue>}</blue>

static void vmx_msr_bitmap_l01_changed(struct vcpu_vmx *vmx)
<yellow>{</yellow>
	/*
	 * When KVM is a nested hypervisor on top of Hyper-V and uses
	 * &#x27;Enlightened MSR Bitmap&#x27; feature L0 needs to know that MSR
	 * bitmap has changed.
	 */
<blue>	if (static_branch_unlikely(&enable_evmcs))</blue>
<yellow>		evmcs_touch_msr_bitmap();</yellow>

<blue>	vmx->nested.force_msr_bitmap_recalc = true;</blue>
<yellow>}</yellow>

void vmx_disable_intercept_for_msr(struct kvm_vcpu *vcpu, u32 msr, int type)
{
	struct vcpu_vmx *vmx = to_vmx(vcpu);
<blue>	unsigned long *msr_bitmap = vmx->vmcs01.msr_bitmap;</blue>

	if (!cpu_has_vmx_msr_bitmap())
		return;

<blue>	vmx_msr_bitmap_l01_changed(vmx);</blue>

	/*
	 * Mark the desired intercept state in shadow bitmap, this is needed
	 * for resync when the MSR filters change.
	*/
	if (is_valid_passthrough_msr(msr)) {
<blue>		int idx = possible_passthrough_msr_slot(msr);</blue>

		if (idx != -ENOENT) {
<blue>			if (type & MSR_TYPE_R)</blue>
<blue>				clear_bit(idx, vmx->shadow_msr_intercept.read);</blue>
<blue>			if (type & MSR_TYPE_W)</blue>
<blue>				clear_bit(idx, vmx->shadow_msr_intercept.write);</blue>
		}
	}

<blue>	if ((type & MSR_TYPE_R) &&</blue>
<blue>	    !kvm_msr_allowed(vcpu, msr, KVM_MSR_FILTER_READ)) {</blue>
<yellow>		vmx_set_msr_bitmap_read(msr_bitmap, msr);</yellow>
		type &amp;= ~MSR_TYPE_R;
	}

<blue>	if ((type & MSR_TYPE_W) &&</blue>
<blue>	    !kvm_msr_allowed(vcpu, msr, KVM_MSR_FILTER_WRITE)) {</blue>
<yellow>		vmx_set_msr_bitmap_write(msr_bitmap, msr);</yellow>
<yellow>		type &= ~MSR_TYPE_W;</yellow>
	}

<blue>	if (type & MSR_TYPE_R)</blue>
<blue>		vmx_clear_msr_bitmap_read(msr_bitmap, msr);</blue>

<blue>	if (type & MSR_TYPE_W)</blue>
<blue>		vmx_clear_msr_bitmap_write(msr_bitmap, msr);</blue>
<blue>}</blue>

void vmx_enable_intercept_for_msr(struct kvm_vcpu *vcpu, u32 msr, int type)
{
	struct vcpu_vmx *vmx = to_vmx(vcpu);
<yellow>	unsigned long *msr_bitmap = vmx->vmcs01.msr_bitmap;</yellow>

	if (!cpu_has_vmx_msr_bitmap())
		return;

<yellow>	vmx_msr_bitmap_l01_changed(vmx);</yellow>

	/*
	 * Mark the desired intercept state in shadow bitmap, this is needed
	 * for resync when the MSR filter changes.
	*/
	if (is_valid_passthrough_msr(msr)) {
<yellow>		int idx = possible_passthrough_msr_slot(msr);</yellow>

		if (idx != -ENOENT) {
<yellow>			if (type & MSR_TYPE_R)</yellow>
<yellow>				set_bit(idx, vmx->shadow_msr_intercept.read);</yellow>
<yellow>			if (type & MSR_TYPE_W)</yellow>
<yellow>				set_bit(idx, vmx->shadow_msr_intercept.write);</yellow>
		}
	}

<yellow>	if (type & MSR_TYPE_R)</yellow>
<yellow>		vmx_set_msr_bitmap_read(msr_bitmap, msr);</yellow>

<yellow>	if (type & MSR_TYPE_W)</yellow>
<yellow>		vmx_set_msr_bitmap_write(msr_bitmap, msr);</yellow>
<yellow>}</yellow>

static void vmx_reset_x2apic_msrs(struct kvm_vcpu *vcpu, u8 mode)
{
<yellow>	unsigned long *msr_bitmap = to_vmx(vcpu)->vmcs01.msr_bitmap;</yellow>
	unsigned long read_intercept;
	int msr;

	read_intercept = (mode &amp; MSR_BITMAP_MODE_X2APIC_APICV) ? 0 : ~0;

	for (msr = 0x800; msr &lt;= 0x8ff; msr += BITS_PER_LONG) {
<yellow>		unsigned int read_idx = msr / BITS_PER_LONG;</yellow>
		unsigned int write_idx = read_idx + (0x800 / sizeof(long));

		msr_bitmap[read_idx] = read_intercept;
		msr_bitmap[write_idx] = ~0ul;
	}
}

static void vmx_update_msr_bitmap_x2apic(struct kvm_vcpu *vcpu)
{
	struct vcpu_vmx *vmx = to_vmx(vcpu);
	u8 mode;

<yellow>	if (!cpu_has_vmx_msr_bitmap())</yellow>
		return;

<yellow>	if (cpu_has_secondary_exec_ctrls() &&</yellow>
<yellow>	    (secondary_exec_controls_get(vmx) &</yellow>
	     SECONDARY_EXEC_VIRTUALIZE_X2APIC_MODE)) {
		mode = MSR_BITMAP_MODE_X2APIC;
<yellow>		if (enable_apicv && kvm_vcpu_apicv_active(vcpu))</yellow>
			mode |= MSR_BITMAP_MODE_X2APIC_APICV;
	} else {
		mode = 0;
	}

<yellow>	if (mode == vmx->x2apic_msr_bitmap_mode)</yellow>
		return;

	vmx-&gt;x2apic_msr_bitmap_mode = mode;

<yellow>	vmx_reset_x2apic_msrs(vcpu, mode);</yellow>

	/*
	 * TPR reads and writes can be virtualized even if virtual interrupt
	 * delivery is not in use.
	 */
<yellow>	vmx_set_intercept_for_msr(vcpu, X2APIC_MSR(APIC_TASKPRI), MSR_TYPE_RW,</yellow>
				  !(mode &amp; MSR_BITMAP_MODE_X2APIC));

<yellow>	if (mode & MSR_BITMAP_MODE_X2APIC_APICV) {</yellow>
<yellow>		vmx_enable_intercept_for_msr(vcpu, X2APIC_MSR(APIC_TMCCT), MSR_TYPE_RW);</yellow>
		vmx_disable_intercept_for_msr(vcpu, X2APIC_MSR(APIC_EOI), MSR_TYPE_W);
		vmx_disable_intercept_for_msr(vcpu, X2APIC_MSR(APIC_SELF_IPI), MSR_TYPE_W);
<yellow>		if (enable_ipiv)</yellow>
<yellow>			vmx_disable_intercept_for_msr(vcpu, X2APIC_MSR(APIC_ICR), MSR_TYPE_RW);</yellow>
	}
<yellow>}</yellow>

void pt_update_intercept_for_msr(struct kvm_vcpu *vcpu)
{
	struct vcpu_vmx *vmx = to_vmx(vcpu);
<yellow>	bool flag = !(vmx->pt_desc.guest.ctl & RTIT_CTL_TRACEEN);</yellow>
	u32 i;

<yellow>	vmx_set_intercept_for_msr(vcpu, MSR_IA32_RTIT_STATUS, MSR_TYPE_RW, flag);</yellow>
	vmx_set_intercept_for_msr(vcpu, MSR_IA32_RTIT_OUTPUT_BASE, MSR_TYPE_RW, flag);
	vmx_set_intercept_for_msr(vcpu, MSR_IA32_RTIT_OUTPUT_MASK, MSR_TYPE_RW, flag);
	vmx_set_intercept_for_msr(vcpu, MSR_IA32_RTIT_CR3_MATCH, MSR_TYPE_RW, flag);
<yellow>	for (i = 0; i < vmx->pt_desc.num_address_ranges; i++) {</yellow>
<yellow>		vmx_set_intercept_for_msr(vcpu, MSR_IA32_RTIT_ADDR0_A + i * 2, MSR_TYPE_RW, flag);</yellow>
		vmx_set_intercept_for_msr(vcpu, MSR_IA32_RTIT_ADDR0_B + i * 2, MSR_TYPE_RW, flag);
	}
<yellow>}</yellow>

static bool vmx_guest_apic_has_interrupt(struct kvm_vcpu *vcpu)
<yellow>{</yellow>
	struct vcpu_vmx *vmx = to_vmx(vcpu);
	void *vapic_page;
	u32 vppr;
	int rvi;

<blue>	if (WARN_ON_ONCE(!is_guest_mode(vcpu)) ||</blue>
<blue>		!nested_cpu_has_vid(get_vmcs12(vcpu)) ||</blue>
<blue>		WARN_ON_ONCE(!vmx->nested.virtual_apic_map.gfn))</blue>
<yellow>		return false;</yellow>

<blue>	rvi = vmx_get_rvi();</blue>

<blue>	vapic_page = vmx->nested.virtual_apic_map.hva;</blue>
<yellow>	vppr = *((u32 *)(vapic_page + APIC_PROCPRI));</yellow>

<blue>	return ((rvi & 0xf0) > (vppr & 0xf0));</blue>
<blue>}</blue>

static void vmx_msr_filter_changed(struct kvm_vcpu *vcpu)
{
	struct vcpu_vmx *vmx = to_vmx(vcpu);
	u32 i;

	/*
	 * Redo intercept permissions for MSRs that KVM is passing through to
	 * the guest.  Disabling interception will check the new MSR filter and
	 * ensure that KVM enables interception if usersepace wants to filter
	 * the MSR.  MSRs that KVM is already intercepting don&#x27;t need to be
	 * refreshed since KVM is going to intercept them regardless of what
	 * userspace wants.
	 */
<yellow>	for (i = 0; i < ARRAY_SIZE(vmx_possible_passthrough_msrs); i++) {</yellow>
<yellow>		u32 msr = vmx_possible_passthrough_msrs[i];</yellow>

		if (!test_bit(i, vmx-&gt;shadow_msr_intercept.read))
<yellow>			vmx_disable_intercept_for_msr(vcpu, msr, MSR_TYPE_R);</yellow>

<yellow>		if (!test_bit(i, vmx->shadow_msr_intercept.write))</yellow>
<yellow>			vmx_disable_intercept_for_msr(vcpu, msr, MSR_TYPE_W);</yellow>
	}

	/* PT MSRs can be passed through iff PT is exposed to the guest. */
<yellow>	if (vmx_pt_mode_is_host_guest())</yellow>
<yellow>		pt_update_intercept_for_msr(vcpu);</yellow>
<yellow>}</yellow>

<yellow>static inline void kvm_vcpu_trigger_posted_interrupt(struct kvm_vcpu *vcpu,</yellow>
						     int pi_vec)
{
#ifdef CONFIG_SMP
<yellow>	if (vcpu->mode == IN_GUEST_MODE) {</yellow>
		/*
		 * The vector of the virtual has already been set in the PIR.
		 * Send a notification event to deliver the virtual interrupt
		 * unless the vCPU is the currently running vCPU, i.e. the
		 * event is being sent from a fastpath VM-Exit handler, in
		 * which case the PIR will be synced to the vIRR before
		 * re-entering the guest.
		 *
		 * When the target is not the running vCPU, the following
		 * possibilities emerge:
		 *
		 * Case 1: vCPU stays in non-root mode. Sending a notification
		 * event posts the interrupt to the vCPU.
		 *
		 * Case 2: vCPU exits to root mode and is still runnable. The
		 * PIR will be synced to the vIRR before re-entering the guest.
		 * Sending a notification event is ok as the host IRQ handler
		 * will ignore the spurious event.
		 *
		 * Case 3: vCPU exits to root mode and is blocked. vcpu_block()
		 * has already synced PIR to vIRR and never blocks the vCPU if
		 * the vIRR is not empty. Therefore, a blocked vCPU here does
		 * not wait for any requested interrupts in PIR, and sending a
		 * notification event also results in a benign, spurious event.
		 */

<yellow>		if (vcpu != kvm_get_running_vcpu())</yellow>
<yellow>			apic->send_IPI_mask(get_cpu_mask(vcpu->cpu), pi_vec);</yellow>
		return;
	}
#endif
	/*
	 * The vCPU isn&#x27;t in the guest; wake the vCPU in case it is blocking,
	 * otherwise do nothing as KVM will grab the highest priority pending
	 * IRQ via -&gt;sync_pir_to_irr() in vcpu_enter_guest().
	 */
<yellow>	kvm_vcpu_wake_up(vcpu);</yellow>
}

static int vmx_deliver_nested_posted_interrupt(struct kvm_vcpu *vcpu,
						int vector)
{
	struct vcpu_vmx *vmx = to_vmx(vcpu);

<yellow>	if (is_guest_mode(vcpu) &&</yellow>
<yellow>	    vector == vmx->nested.posted_intr_nv) {</yellow>
		/*
		 * If a posted intr is not recognized by hardware,
		 * we will accomplish it in the next vmentry.
		 */
<yellow>		vmx->nested.pi_pending = true;</yellow>
<yellow>		kvm_make_request(KVM_REQ_EVENT, vcpu);</yellow>

		/*
		 * This pairs with the smp_mb_*() after setting vcpu-&gt;mode in
		 * vcpu_enter_guest() to guarantee the vCPU sees the event
		 * request if triggering a posted interrupt &quot;fails&quot; because
		 * vcpu-&gt;mode != IN_GUEST_MODE.  The extra barrier is needed as
		 * the smb_wmb() in kvm_make_request() only ensures everything
		 * done before making the request is visible when the request
		 * is visible, it doesn&#x27;t ensure ordering between the store to
		 * vcpu-&gt;requests and the load from vcpu-&gt;mode.
		 */
		smp_mb__after_atomic();

		/* the PIR and ON have been set by L1. */
<yellow>		kvm_vcpu_trigger_posted_interrupt(vcpu, POSTED_INTR_NESTED_VECTOR);</yellow>
		return 0;
	}
	return -1;
}
/*
 * Send interrupt to vcpu via posted interrupt way.
 * 1. If target vcpu is running(non-root mode), send posted interrupt
 * notification to vcpu and hardware will sync PIR to vIRR atomically.
 * 2. If target vcpu isn&#x27;t running(root mode), kick it to pick up the
 * interrupt from PIR in next vmentry.
 */
static int vmx_deliver_posted_interrupt(struct kvm_vcpu *vcpu, int vector)
{
	struct vcpu_vmx *vmx = to_vmx(vcpu);
	int r;

<yellow>	r = vmx_deliver_nested_posted_interrupt(vcpu, vector);</yellow>
	if (!r)
		return 0;

	/* Note, this is called iff the local APIC is in-kernel. */
<yellow>	if (!vcpu->arch.apic->apicv_active)</yellow>
		return -1;

<yellow>	if (pi_test_and_set_pir(vector, &vmx->pi_desc))</yellow>
		return 0;

	/* If a previous notification has sent the IPI, nothing to do.  */
<yellow>	if (pi_test_and_set_on(&vmx->pi_desc))</yellow>
		return 0;

	/*
	 * The implied barrier in pi_test_and_set_on() pairs with the smp_mb_*()
	 * after setting vcpu-&gt;mode in vcpu_enter_guest(), thus the vCPU is
	 * guaranteed to see PID.ON=1 and sync the PIR to IRR if triggering a
	 * posted interrupt &quot;fails&quot; because vcpu-&gt;mode != IN_GUEST_MODE.
	 */
<yellow>	kvm_vcpu_trigger_posted_interrupt(vcpu, POSTED_INTR_VECTOR);</yellow>
	return 0;
}

static void vmx_deliver_interrupt(struct kvm_lapic *apic, int delivery_mode,
				  int trig_mode, int vector)
<yellow>{</yellow>
<yellow>	struct kvm_vcpu *vcpu = apic->vcpu;</yellow>

<yellow>	if (vmx_deliver_posted_interrupt(vcpu, vector)) {</yellow>
<yellow>		kvm_lapic_set_irr(vector, apic);</yellow>
		kvm_make_request(KVM_REQ_EVENT, vcpu);
<yellow>		kvm_vcpu_kick(vcpu);</yellow>
	} else {
<yellow>		trace_kvm_apicv_accept_irq(vcpu->vcpu_id, delivery_mode,</yellow>
					   trig_mode, vector);
	}
<yellow>}</yellow>

/*
 * Set up the vmcs&#x27;s constant host-state fields, i.e., host-state fields that
 * will not change in the lifetime of the guest.
 * Note that host-state that does change is set elsewhere. E.g., host-state
 * that is set differently for each CPU is set in vmx_vcpu_load(), not here.
 */
void vmx_set_constant_host_state(struct vcpu_vmx *vmx)
{
	u32 low32, high32;
	unsigned long tmpl;
	unsigned long cr0, cr3, cr4;

<blue>	cr0 = read_cr0();</blue>
<yellow>	WARN_ON(cr0 & X86_CR0_TS);</yellow>
<blue>	vmcs_writel(HOST_CR0, cr0);  /* 22.2.3 */</blue>

	/*
	 * Save the most likely value for this task&#x27;s CR3 in the VMCS.
	 * We can&#x27;t use __get_current_cr3_fast() because we&#x27;re not atomic.
	 */
<blue>	cr3 = __read_cr3();</blue>
<blue>	vmcs_writel(HOST_CR3, cr3);		/* 22.2.3  FIXME: shadow tables */</blue>
<blue>	vmx->loaded_vmcs->host_state.cr3 = cr3;</blue>

	/* Save the most likely value for this task&#x27;s CR4 in the VMCS. */
	cr4 = cr4_read_shadow();
<blue>	vmcs_writel(HOST_CR4, cr4);			/* 22.2.3, 22.2.5 */</blue>
<blue>	vmx->loaded_vmcs->host_state.cr4 = cr4;</blue>

<blue>	vmcs_write16(HOST_CS_SELECTOR, __KERNEL_CS);  /* 22.2.4 */</blue>
#ifdef CONFIG_X86_64
	/*
	 * Load null selectors, so we can avoid reloading them in
	 * vmx_prepare_switch_to_host(), in case userspace uses
	 * the null selectors too (the expected case).
	 */
<blue>	vmcs_write16(HOST_DS_SELECTOR, 0);</blue>
<blue>	vmcs_write16(HOST_ES_SELECTOR, 0);</blue>
#else
	vmcs_write16(HOST_DS_SELECTOR, __KERNEL_DS);  /* 22.2.4 */
	vmcs_write16(HOST_ES_SELECTOR, __KERNEL_DS);  /* 22.2.4 */
#endif
<blue>	vmcs_write16(HOST_SS_SELECTOR, __KERNEL_DS);  /* 22.2.4 */</blue>
<blue>	vmcs_write16(HOST_TR_SELECTOR, GDT_ENTRY_TSS*8);  /* 22.2.4 */</blue>

<blue>	vmcs_writel(HOST_IDTR_BASE, host_idt_base);   /* 22.2.4 */</blue>

<blue>	vmcs_writel(HOST_RIP, (unsigned long)vmx_vmexit); /* 22.2.5 */</blue>

<blue>	rdmsr(MSR_IA32_SYSENTER_CS, low32, high32);</blue>
<blue>	vmcs_write32(HOST_IA32_SYSENTER_CS, low32);</blue>

	/*
	 * SYSENTER is used for 32-bit system calls on either 32-bit or
	 * 64-bit kernels.  It is always zero If neither is allowed, otherwise
	 * vmx_vcpu_load_vmcs loads it with the per-CPU entry stack (and may
	 * have already done so!).
	 */
	if (!IS_ENABLED(CONFIG_IA32_EMULATION) &amp;&amp; !IS_ENABLED(CONFIG_X86_32))
		vmcs_writel(HOST_IA32_SYSENTER_ESP, 0);

<blue>	rdmsrl(MSR_IA32_SYSENTER_EIP, tmpl);</blue>
<blue>	vmcs_writel(HOST_IA32_SYSENTER_EIP, tmpl);   /* 22.2.3 */</blue>

<blue>	if (vmcs_config.vmexit_ctrl & VM_EXIT_LOAD_IA32_PAT) {</blue>
<blue>		rdmsr(MSR_IA32_CR_PAT, low32, high32);</blue>
<blue>		vmcs_write64(HOST_IA32_PAT, low32 | ((u64) high32 << 32));</blue>
	}

<blue>	if (cpu_has_load_ia32_efer())</blue>
<blue>		vmcs_write64(HOST_IA32_EFER, host_efer);</blue>
<blue>}</blue>

void set_cr4_guest_host_mask(struct vcpu_vmx *vmx)
{
	struct kvm_vcpu *vcpu = &amp;vmx-&gt;vcpu;

	vcpu-&gt;arch.cr4_guest_owned_bits = KVM_POSSIBLE_CR4_GUEST_BITS &amp;
<blue>					  ~vcpu->arch.cr4_guest_rsvd_bits;</blue>
<blue>	if (!enable_ept) {</blue>
		vcpu-&gt;arch.cr4_guest_owned_bits &amp;= ~X86_CR4_TLBFLUSH_BITS;
<yellow>		vcpu->arch.cr4_guest_owned_bits &= ~X86_CR4_PDPTR_BITS;</yellow>
	}
<blue>	if (is_guest_mode(&vmx->vcpu))</blue>
		vcpu-&gt;arch.cr4_guest_owned_bits &amp;=
<blue>			~get_vmcs12(vcpu)->cr4_guest_host_mask;</blue>
<blue>	vmcs_writel(CR4_GUEST_HOST_MASK, ~vcpu->arch.cr4_guest_owned_bits);</blue>
<blue>}</blue>

static u32 vmx_pin_based_exec_ctrl(struct vcpu_vmx *vmx)
{
<blue>	u32 pin_based_exec_ctrl = vmcs_config.pin_based_exec_ctrl;</blue>

<blue>	if (!kvm_vcpu_apicv_active(&vmx->vcpu))</blue>
<yellow>		pin_based_exec_ctrl &= ~PIN_BASED_POSTED_INTR;</yellow>

<blue>	if (!enable_vnmi)</blue>
<yellow>		pin_based_exec_ctrl &= ~PIN_BASED_VIRTUAL_NMIS;</yellow>

<blue>	if (!enable_preemption_timer)</blue>
<blue>		pin_based_exec_ctrl &= ~PIN_BASED_VMX_PREEMPTION_TIMER;</blue>

	return pin_based_exec_ctrl;
<blue>}</blue>

static u32 vmx_vmentry_ctrl(void)
{
	u32 vmentry_ctrl = vmcs_config.vmentry_ctrl;

<blue>	if (vmx_pt_mode_is_system())</blue>
<blue>		vmentry_ctrl &= ~(VM_ENTRY_PT_CONCEAL_PIP |</blue>
				  VM_ENTRY_LOAD_IA32_RTIT_CTL);
	/*
	 * IA32e mode, and loading of EFER and PERF_GLOBAL_CTRL are toggled dynamically.
	 */
	vmentry_ctrl &amp;= ~(VM_ENTRY_LOAD_IA32_PERF_GLOBAL_CTRL |
			  VM_ENTRY_LOAD_IA32_EFER |
			  VM_ENTRY_IA32E_MODE);

	if (cpu_has_perf_global_ctrl_bug())
		vmentry_ctrl &amp;= ~VM_ENTRY_LOAD_IA32_PERF_GLOBAL_CTRL;

	return vmentry_ctrl;
}

static u32 vmx_vmexit_ctrl(void)
{
	u32 vmexit_ctrl = vmcs_config.vmexit_ctrl;

	/*
	 * Not used by KVM and never set in vmcs01 or vmcs02, but emulated for
	 * nested virtualization and thus allowed to be set in vmcs12.
	 */
<yellow>	vmexit_ctrl &= ~(VM_EXIT_SAVE_IA32_PAT | VM_EXIT_SAVE_IA32_EFER |</yellow>
			 VM_EXIT_SAVE_VMX_PREEMPTION_TIMER);

<blue>	if (vmx_pt_mode_is_system())</blue>
<blue>		vmexit_ctrl &= ~(VM_EXIT_PT_CONCEAL_PIP |</blue>
				 VM_EXIT_CLEAR_IA32_RTIT_CTL);

<blue>	if (cpu_has_perf_global_ctrl_bug())</blue>
<yellow>		vmexit_ctrl &= ~VM_EXIT_LOAD_IA32_PERF_GLOBAL_CTRL;</yellow>

	/* Loading of EFER and PERF_GLOBAL_CTRL are toggled dynamically */
	return vmexit_ctrl &amp;
		~(VM_EXIT_LOAD_IA32_PERF_GLOBAL_CTRL | VM_EXIT_LOAD_IA32_EFER);
}

<yellow>static void vmx_refresh_apicv_exec_ctrl(struct kvm_vcpu *vcpu)</yellow>
{
	struct vcpu_vmx *vmx = to_vmx(vcpu);

<yellow>	if (is_guest_mode(vcpu)) {</yellow>
<yellow>		vmx->nested.update_vmcs01_apicv_status = true;</yellow>
		return;
	}

<yellow>	pin_controls_set(vmx, vmx_pin_based_exec_ctrl(vmx));</yellow>

<yellow>	if (kvm_vcpu_apicv_active(vcpu)) {</yellow>
<yellow>		secondary_exec_controls_setbit(vmx,</yellow>
					       SECONDARY_EXEC_APIC_REGISTER_VIRT |
					       SECONDARY_EXEC_VIRTUAL_INTR_DELIVERY);
<yellow>		if (enable_ipiv)</yellow>
<yellow>			tertiary_exec_controls_setbit(vmx, TERTIARY_EXEC_IPI_VIRT);</yellow>
	} else {
<yellow>		secondary_exec_controls_clearbit(vmx,</yellow>
						 SECONDARY_EXEC_APIC_REGISTER_VIRT |
						 SECONDARY_EXEC_VIRTUAL_INTR_DELIVERY);
<yellow>		if (enable_ipiv)</yellow>
<yellow>			tertiary_exec_controls_clearbit(vmx, TERTIARY_EXEC_IPI_VIRT);</yellow>
	}

<yellow>	vmx_update_msr_bitmap_x2apic(vcpu);</yellow>
<yellow>}</yellow>

static u32 vmx_exec_control(struct vcpu_vmx *vmx)
{
	u32 exec_control = vmcs_config.cpu_based_exec_ctrl;

	/*
	 * Not used by KVM, but fully supported for nesting, i.e. are allowed in
	 * vmcs12 and propagated to vmcs02 when set in vmcs12.
	 */
	exec_control &amp;= ~(CPU_BASED_RDTSC_EXITING |
			  CPU_BASED_USE_IO_BITMAPS |
			  CPU_BASED_MONITOR_TRAP_FLAG |
			  CPU_BASED_PAUSE_EXITING);

	/* INTR_WINDOW_EXITING and NMI_WINDOW_EXITING are toggled dynamically */
<blue>	exec_control &= ~(CPU_BASED_INTR_WINDOW_EXITING |</blue>
			  CPU_BASED_NMI_WINDOW_EXITING);

<blue>	if (vmx->vcpu.arch.switch_db_regs & KVM_DEBUGREG_WONT_EXIT)</blue>
<yellow>		exec_control &= ~CPU_BASED_MOV_DR_EXITING;</yellow>

<blue>	if (!cpu_need_tpr_shadow(&vmx->vcpu))</blue>
<yellow>		exec_control &= ~CPU_BASED_TPR_SHADOW;</yellow>

#ifdef CONFIG_X86_64
<blue>	if (exec_control & CPU_BASED_TPR_SHADOW)</blue>
<blue>		exec_control &= ~(CPU_BASED_CR8_LOAD_EXITING |</blue>
				  CPU_BASED_CR8_STORE_EXITING);
	else
<yellow>		exec_control |= CPU_BASED_CR8_STORE_EXITING |</yellow>
				CPU_BASED_CR8_LOAD_EXITING;
#endif
	/* No need to intercept CR3 access or INVPLG when using EPT. */
<blue>	if (enable_ept)</blue>
<blue>		exec_control &= ~(CPU_BASED_CR3_LOAD_EXITING |</blue>
				  CPU_BASED_CR3_STORE_EXITING |
				  CPU_BASED_INVLPG_EXITING);
<blue>	if (kvm_mwait_in_guest(vmx->vcpu.kvm))</blue>
<yellow>		exec_control &= ~(CPU_BASED_MWAIT_EXITING |</yellow>
				CPU_BASED_MONITOR_EXITING);
<blue>	if (kvm_hlt_in_guest(vmx->vcpu.kvm))</blue>
<yellow>		exec_control &= ~CPU_BASED_HLT_EXITING;</yellow>
	return exec_control;
}

static u64 vmx_tertiary_exec_control(struct vcpu_vmx *vmx)
{
	u64 exec_control = vmcs_config.cpu_based_3rd_exec_ctrl;

	/*
	 * IPI virtualization relies on APICv. Disable IPI virtualization if
	 * APICv is inhibited.
	 */
<blue>	if (!enable_ipiv || !kvm_vcpu_apicv_active(&vmx->vcpu))</blue>
<blue>		exec_control &= ~TERTIARY_EXEC_IPI_VIRT;</blue>

	return exec_control;
}

/*
 * Adjust a single secondary execution control bit to intercept/allow an
 * instruction in the guest.  This is usually done based on whether or not a
 * feature has been exposed to the guest in order to correctly emulate faults.
 */
static inline void
<blue>vmx_adjust_secondary_exec_control(struct vcpu_vmx *vmx, u32 *exec_control,</blue>
				  u32 control, bool enabled, bool exiting)
{
	/*
	 * If the control is for an opt-in feature, clear the control if the
	 * feature is not exposed to the guest, i.e. not enabled.  If the
	 * control is opt-out, i.e. an exiting control, clear the control if
	 * the feature _is_ exposed to the guest, i.e. exiting/interception is
	 * disabled for the associated instruction.  Note, the caller is
	 * responsible presetting exec_control to set all supported bits.
	 */
<yellow>	if (enabled == exiting)</yellow>
<blue>		*exec_control &= ~control;</blue>

	/*
	 * Update the nested MSR settings so that a nested VMM can/can&#x27;t set
	 * controls for features that are/aren&#x27;t exposed to the guest.
	 */
<blue>	if (nested) {</blue>
<yellow>		if (enabled)</yellow>
<blue>			vmx->nested.msrs.secondary_ctls_high |= control;</blue>
		else
<blue>			vmx->nested.msrs.secondary_ctls_high &= ~control;</blue>
	}
}

/*
 * Wrapper macro for the common case of adjusting a secondary execution control
 * based on a single guest CPUID bit, with a dedicated feature bit.  This also
 * verifies that the control is actually supported by KVM and hardware.
 */
#define vmx_adjust_sec_exec_control(vmx, exec_control, name, feat_name, ctrl_name, exiting) \
({									 \
	bool __enabled;							 \
									 \
	if (cpu_has_vmx_##name()) {					 \
		__enabled = guest_cpuid_has(&amp;(vmx)-&gt;vcpu,		 \
					    X86_FEATURE_##feat_name);	 \
		vmx_adjust_secondary_exec_control(vmx, exec_control,	 \
			SECONDARY_EXEC_##ctrl_name, __enabled, exiting); \
	}								 \
})

/* More macro magic for ENABLE_/opt-in versus _EXITING/opt-out controls. */
#define vmx_adjust_sec_exec_feature(vmx, exec_control, lname, uname) \
	vmx_adjust_sec_exec_control(vmx, exec_control, lname, uname, ENABLE_##uname, false)

#define vmx_adjust_sec_exec_exiting(vmx, exec_control, lname, uname) \
	vmx_adjust_sec_exec_control(vmx, exec_control, lname, uname, uname##_EXITING, true)

static u32 vmx_secondary_exec_control(struct vcpu_vmx *vmx)
<yellow>{</yellow>
	struct kvm_vcpu *vcpu = &amp;vmx-&gt;vcpu;

	u32 exec_control = vmcs_config.cpu_based_2nd_exec_ctrl;

<blue>	if (vmx_pt_mode_is_system())</blue>
<blue>		exec_control &= ~(SECONDARY_EXEC_PT_USE_GPA | SECONDARY_EXEC_PT_CONCEAL_VMX);</blue>
<blue>	if (!cpu_need_virtualize_apic_accesses(vcpu))</blue>
<yellow>		exec_control &= ~SECONDARY_EXEC_VIRTUALIZE_APIC_ACCESSES;</yellow>
<blue>	if (vmx->vpid == 0)</blue>
<yellow>		exec_control &= ~SECONDARY_EXEC_ENABLE_VPID;</yellow>
<blue>	if (!enable_ept) {</blue>
		exec_control &amp;= ~SECONDARY_EXEC_ENABLE_EPT;
<yellow>		enable_unrestricted_guest = 0;</yellow>
	}
<blue>	if (!enable_unrestricted_guest)</blue>
<yellow>		exec_control &= ~SECONDARY_EXEC_UNRESTRICTED_GUEST;</yellow>
<blue>	if (kvm_pause_in_guest(vmx->vcpu.kvm))</blue>
<yellow>		exec_control &= ~SECONDARY_EXEC_PAUSE_LOOP_EXITING;</yellow>
<blue>	if (!kvm_vcpu_apicv_active(vcpu))</blue>
<yellow>		exec_control &= ~(SECONDARY_EXEC_APIC_REGISTER_VIRT |</yellow>
				  SECONDARY_EXEC_VIRTUAL_INTR_DELIVERY);
	exec_control &amp;= ~SECONDARY_EXEC_VIRTUALIZE_X2APIC_MODE;

	/* SECONDARY_EXEC_DESC is enabled/disabled on writes to CR4.UMIP,
	 * in vmx_set_cr4.  */
	exec_control &amp;= ~SECONDARY_EXEC_DESC;

	/* SECONDARY_EXEC_SHADOW_VMCS is enabled when L1 executes VMPTRLD
	   (handle_vmptrld).
	   We can NOT enable shadow_vmcs here because we don&#x27;t have yet
	   a current VMCS12
	*/
<yellow>	exec_control &= ~SECONDARY_EXEC_SHADOW_VMCS;</yellow>

	/*
	 * PML is enabled/disabled when dirty logging of memsmlots changes, but
	 * it needs to be set here when dirty logging is already active, e.g.
	 * if this vCPU was created after dirty logging was enabled.
	 */
<blue>	if (!vcpu->kvm->arch.cpu_dirty_logging_count)</blue>
<blue>		exec_control &= ~SECONDARY_EXEC_ENABLE_PML;</blue>

<blue>	if (cpu_has_vmx_xsaves()) {</blue>
		/* Exposing XSAVES only when XSAVE is exposed */
		bool xsaves_enabled =
<blue>			boot_cpu_has(X86_FEATURE_XSAVE) &&</blue>
<blue>			guest_cpuid_has(vcpu, X86_FEATURE_XSAVE) &&</blue>
<blue>			guest_cpuid_has(vcpu, X86_FEATURE_XSAVES);</blue>

<blue>		vcpu->arch.xsaves_enabled = xsaves_enabled;</blue>

<blue>		vmx_adjust_secondary_exec_control(vmx, &exec_control,</blue>
						  SECONDARY_EXEC_XSAVES,
						  xsaves_enabled, false);
	}

	/*
	 * RDPID is also gated by ENABLE_RDTSCP, turn on the control if either
	 * feature is exposed to the guest.  This creates a virtualization hole
	 * if both are supported in hardware but only one is exposed to the
	 * guest, but letting the guest execute RDTSCP or RDPID when either one
	 * is advertised is preferable to emulating the advertised instruction
	 * in KVM on #UD, and obviously better than incorrectly injecting #UD.
	 */
<blue>	if (cpu_has_vmx_rdtscp()) {</blue>
		bool rdpid_or_rdtscp_enabled =
<blue>			guest_cpuid_has(vcpu, X86_FEATURE_RDTSCP) ||</blue>
<blue>			guest_cpuid_has(vcpu, X86_FEATURE_RDPID);</blue>

<blue>		vmx_adjust_secondary_exec_control(vmx, &exec_control,</blue>
						  SECONDARY_EXEC_ENABLE_RDTSCP,
						  rdpid_or_rdtscp_enabled, false);
	}
<blue>	vmx_adjust_sec_exec_feature(vmx, &exec_control, invpcid, INVPCID);</blue>

<blue>	vmx_adjust_sec_exec_exiting(vmx, &exec_control, rdrand, RDRAND);</blue>
<blue>	vmx_adjust_sec_exec_exiting(vmx, &exec_control, rdseed, RDSEED);</blue>

<blue>	vmx_adjust_sec_exec_control(vmx, &exec_control, waitpkg, WAITPKG,</blue>
				    ENABLE_USR_WAIT_PAUSE, false);

<blue>	if (!vcpu->kvm->arch.bus_lock_detection_enabled)</blue>
<blue>		exec_control &= ~SECONDARY_EXEC_BUS_LOCK_DETECTION;</blue>

<blue>	if (!kvm_notify_vmexit_enabled(vcpu->kvm))</blue>
<blue>		exec_control &= ~SECONDARY_EXEC_NOTIFY_VM_EXITING;</blue>

	return exec_control;
<blue>}</blue>

static inline int vmx_get_pid_table_order(struct kvm *kvm)
{
<yellow>	return get_order(kvm->arch.max_vcpu_ids * sizeof(*to_kvm_vmx(kvm)->pid_table));</yellow>
}

static int vmx_alloc_ipiv_pid_table(struct kvm *kvm)
{
	struct page *pages;
	struct kvm_vmx *kvm_vmx = to_kvm_vmx(kvm);

<blue>	if (!irqchip_in_kernel(kvm) || !enable_ipiv)</blue>
		return 0;

<yellow>	if (kvm_vmx->pid_table)</yellow>
		return 0;

<yellow>	pages = alloc_pages(GFP_KERNEL | __GFP_ZERO, vmx_get_pid_table_order(kvm));</yellow>
<yellow>	if (!pages)</yellow>
<yellow>		return -ENOMEM;</yellow>

<yellow>	kvm_vmx->pid_table = (void *)page_address(pages);</yellow>
	return 0;
}

static int vmx_vcpu_precreate(struct kvm *kvm)
<yellow>{</yellow>
<blue>	return vmx_alloc_ipiv_pid_table(kvm);</blue>
<blue>}</blue>

#define VMX_XSS_EXIT_BITMAP 0

static void init_vmcs(struct vcpu_vmx *vmx)
{
<blue>	struct kvm *kvm = vmx->vcpu.kvm;</blue>
	struct kvm_vmx *kvm_vmx = to_kvm_vmx(kvm);

<blue>	if (nested)</blue>
<blue>		nested_vmx_set_vmcs_shadowing_bitmap();</blue>

<blue>	if (cpu_has_vmx_msr_bitmap())</blue>
<blue>		vmcs_write64(MSR_BITMAP, __pa(vmx->vmcs01.msr_bitmap));</blue>

<blue>	vmcs_write64(VMCS_LINK_POINTER, INVALID_GPA); /* 22.3.1.5 */</blue>

	/* Control */
<blue>	pin_controls_set(vmx, vmx_pin_based_exec_ctrl(vmx));</blue>

<blue>	exec_controls_set(vmx, vmx_exec_control(vmx));</blue>

<blue>	if (cpu_has_secondary_exec_ctrls())</blue>
<blue>		secondary_exec_controls_set(vmx, vmx_secondary_exec_control(vmx));</blue>

<blue>	if (cpu_has_tertiary_exec_ctrls())</blue>
<blue>		tertiary_exec_controls_set(vmx, vmx_tertiary_exec_control(vmx));</blue>

<blue>	if (enable_apicv && lapic_in_kernel(&vmx->vcpu)) {</blue>
<blue>		vmcs_write64(EOI_EXIT_BITMAP0, 0);</blue>
<blue>		vmcs_write64(EOI_EXIT_BITMAP1, 0);</blue>
<blue>		vmcs_write64(EOI_EXIT_BITMAP2, 0);</blue>
<blue>		vmcs_write64(EOI_EXIT_BITMAP3, 0);</blue>

<blue>		vmcs_write16(GUEST_INTR_STATUS, 0);</blue>

<blue>		vmcs_write16(POSTED_INTR_NV, POSTED_INTR_VECTOR);</blue>
<blue>		vmcs_write64(POSTED_INTR_DESC_ADDR, __pa((&vmx->pi_desc)));</blue>
	}

<blue>	if (vmx_can_use_ipiv(&vmx->vcpu)) {</blue>
<yellow>		vmcs_write64(PID_POINTER_TABLE, __pa(kvm_vmx->pid_table));</yellow>
<yellow>		vmcs_write16(LAST_PID_POINTER_INDEX, kvm->arch.max_vcpu_ids - 1);</yellow>
	}

<blue>	if (!kvm_pause_in_guest(kvm)) {</blue>
<blue>		vmcs_write32(PLE_GAP, ple_gap);</blue>
<blue>		vmx->ple_window = ple_window;</blue>
		vmx-&gt;ple_window_dirty = true;
	}

<blue>	if (kvm_notify_vmexit_enabled(kvm))</blue>
<yellow>		vmcs_write32(NOTIFY_WINDOW, kvm->arch.notify_window);</yellow>

<blue>	vmcs_write32(PAGE_FAULT_ERROR_CODE_MASK, 0);</blue>
<blue>	vmcs_write32(PAGE_FAULT_ERROR_CODE_MATCH, 0);</blue>
<blue>	vmcs_write32(CR3_TARGET_COUNT, 0);           /* 22.2.1 */</blue>

<blue>	vmcs_write16(HOST_FS_SELECTOR, 0);            /* 22.2.4 */</blue>
<blue>	vmcs_write16(HOST_GS_SELECTOR, 0);            /* 22.2.4 */</blue>
<blue>	vmx_set_constant_host_state(vmx);</blue>
<blue>	vmcs_writel(HOST_FS_BASE, 0); /* 22.2.4 */</blue>
<blue>	vmcs_writel(HOST_GS_BASE, 0); /* 22.2.4 */</blue>

<blue>	if (cpu_has_vmx_vmfunc())</blue>
<blue>		vmcs_write64(VM_FUNCTION_CONTROL, 0);</blue>

<blue>	vmcs_write32(VM_EXIT_MSR_STORE_COUNT, 0);</blue>
<blue>	vmcs_write32(VM_EXIT_MSR_LOAD_COUNT, 0);</blue>
<blue>	vmcs_write64(VM_EXIT_MSR_LOAD_ADDR, __pa(vmx->msr_autoload.host.val));</blue>
<blue>	vmcs_write32(VM_ENTRY_MSR_LOAD_COUNT, 0);</blue>
<blue>	vmcs_write64(VM_ENTRY_MSR_LOAD_ADDR, __pa(vmx->msr_autoload.guest.val));</blue>

<blue>	if (vmcs_config.vmentry_ctrl & VM_ENTRY_LOAD_IA32_PAT)</blue>
<blue>		vmcs_write64(GUEST_IA32_PAT, vmx->vcpu.arch.pat);</blue>

<blue>	vm_exit_controls_set(vmx, vmx_vmexit_ctrl());</blue>

	/* 22.2.1, 20.8.1 */
<blue>	vm_entry_controls_set(vmx, vmx_vmentry_ctrl());</blue>

<blue>	vmx->vcpu.arch.cr0_guest_owned_bits = KVM_POSSIBLE_CR0_GUEST_BITS;</blue>
<blue>	vmcs_writel(CR0_GUEST_HOST_MASK, ~vmx->vcpu.arch.cr0_guest_owned_bits);</blue>

<blue>	set_cr4_guest_host_mask(vmx);</blue>

	if (vmx-&gt;vpid != 0)
<blue>		vmcs_write16(VIRTUAL_PROCESSOR_ID, vmx->vpid);</blue>

<blue>	if (cpu_has_vmx_xsaves())</blue>
<blue>		vmcs_write64(XSS_EXIT_BITMAP, VMX_XSS_EXIT_BITMAP);</blue>

<blue>	if (enable_pml) {</blue>
<yellow>		vmcs_write64(PML_ADDRESS, page_to_phys(vmx->pml_pg));</yellow>
<yellow>		vmcs_write16(GUEST_PML_INDEX, PML_ENTITY_NUM - 1);</yellow>
	}

<blue>	vmx_write_encls_bitmap(&vmx->vcpu, NULL);</blue>

	if (vmx_pt_mode_is_host_guest()) {
<yellow>		memset(&vmx->pt_desc, 0, sizeof(vmx->pt_desc));</yellow>
		/* Bit[6~0] are forced to 1, writes are ignored. */
		vmx-&gt;pt_desc.guest.output_mask = 0x7F;
<yellow>		vmcs_write64(GUEST_IA32_RTIT_CTL, 0);</yellow>
	}

<blue>	vmcs_write32(GUEST_SYSENTER_CS, 0);</blue>
<blue>	vmcs_writel(GUEST_SYSENTER_ESP, 0);</blue>
<blue>	vmcs_writel(GUEST_SYSENTER_EIP, 0);</blue>
<blue>	vmcs_write64(GUEST_IA32_DEBUGCTL, 0);</blue>

<blue>	if (cpu_has_vmx_tpr_shadow()) {</blue>
<blue>		vmcs_write64(VIRTUAL_APIC_PAGE_ADDR, 0);</blue>
<blue>		if (cpu_need_tpr_shadow(&vmx->vcpu))</blue>
<blue>			vmcs_write64(VIRTUAL_APIC_PAGE_ADDR,</blue>
<blue>				     __pa(vmx->vcpu.arch.apic->regs));</blue>
<blue>		vmcs_write32(TPR_THRESHOLD, 0);</blue>
	}

<blue>	vmx_setup_uret_msrs(vmx);</blue>
}

static void __vmx_vcpu_reset(struct kvm_vcpu *vcpu)
{
	struct vcpu_vmx *vmx = to_vmx(vcpu);

<blue>	init_vmcs(vmx);</blue>

<blue>	if (nested)</blue>
<blue>		memcpy(&vmx->nested.msrs, &vmcs_config.nested, sizeof(vmx->nested.msrs));</blue>

<blue>	vcpu_setup_sgx_lepubkeyhash(vcpu);</blue>

	vmx-&gt;nested.posted_intr_nv = -1;
	vmx-&gt;nested.vmxon_ptr = INVALID_GPA;
	vmx-&gt;nested.current_vmptr = INVALID_GPA;
	vmx-&gt;nested.hv_evmcs_vmptr = EVMPTR_INVALID;

	vcpu-&gt;arch.microcode_version = 0x100000000ULL;
	vmx-&gt;msr_ia32_feature_control_valid_bits = FEAT_CTL_LOCKED;

	/*
	 * Enforce invariant: pi_desc.nv is always either POSTED_INTR_VECTOR
	 * or POSTED_INTR_WAKEUP_VECTOR.
	 */
	vmx-&gt;pi_desc.nv = POSTED_INTR_VECTOR;
	vmx-&gt;pi_desc.sn = 1;
}

static void vmx_vcpu_reset(struct kvm_vcpu *vcpu, bool init_event)
<blue>{</blue>
	struct vcpu_vmx *vmx = to_vmx(vcpu);

<blue>	if (!init_event)</blue>
<blue>		__vmx_vcpu_reset(vcpu);</blue>

<blue>	vmx->rmode.vm86_active = 0;</blue>
	vmx-&gt;spec_ctrl = 0;

	vmx-&gt;msr_ia32_umwait_control = 0;

	vmx-&gt;hv_deadline_tsc = -1;
	kvm_set_cr8(vcpu, 0);

	vmx_segment_cache_clear(vmx);
	kvm_register_mark_available(vcpu, VCPU_EXREG_SEGMENTS);

	seg_setup(VCPU_SREG_CS);
<blue>	vmcs_write16(GUEST_CS_SELECTOR, 0xf000);</blue>
<blue>	vmcs_writel(GUEST_CS_BASE, 0xffff0000ul);</blue>

<blue>	seg_setup(VCPU_SREG_DS);</blue>
	seg_setup(VCPU_SREG_ES);
	seg_setup(VCPU_SREG_FS);
	seg_setup(VCPU_SREG_GS);
	seg_setup(VCPU_SREG_SS);

<blue>	vmcs_write16(GUEST_TR_SELECTOR, 0);</blue>
<blue>	vmcs_writel(GUEST_TR_BASE, 0);</blue>
<blue>	vmcs_write32(GUEST_TR_LIMIT, 0xffff);</blue>
<blue>	vmcs_write32(GUEST_TR_AR_BYTES, 0x008b);</blue>

<blue>	vmcs_write16(GUEST_LDTR_SELECTOR, 0);</blue>
<blue>	vmcs_writel(GUEST_LDTR_BASE, 0);</blue>
<blue>	vmcs_write32(GUEST_LDTR_LIMIT, 0xffff);</blue>
<blue>	vmcs_write32(GUEST_LDTR_AR_BYTES, 0x00082);</blue>

<blue>	vmcs_writel(GUEST_GDTR_BASE, 0);</blue>
<blue>	vmcs_write32(GUEST_GDTR_LIMIT, 0xffff);</blue>

<blue>	vmcs_writel(GUEST_IDTR_BASE, 0);</blue>
<blue>	vmcs_write32(GUEST_IDTR_LIMIT, 0xffff);</blue>

<blue>	vmcs_write32(GUEST_ACTIVITY_STATE, GUEST_ACTIVITY_ACTIVE);</blue>
<blue>	vmcs_write32(GUEST_INTERRUPTIBILITY_INFO, 0);</blue>
<blue>	vmcs_writel(GUEST_PENDING_DBG_EXCEPTIONS, 0);</blue>
<blue>	if (kvm_mpx_supported())</blue>
<yellow>		vmcs_write64(GUEST_BNDCFGS, 0);</yellow>

<blue>	vmcs_write32(VM_ENTRY_INTR_INFO_FIELD, 0);  /* 22.2.1 */</blue>

<blue>	kvm_make_request(KVM_REQ_APIC_PAGE_RELOAD, vcpu);</blue>

<blue>	vpid_sync_context(vmx->vpid);</blue>

<blue>	vmx_update_fb_clear_dis(vcpu, vmx);</blue>
}

static void vmx_enable_irq_window(struct kvm_vcpu *vcpu)
{
<blue>	exec_controls_setbit(to_vmx(vcpu), CPU_BASED_INTR_WINDOW_EXITING);</blue>
<blue>}</blue>

static void vmx_enable_nmi_window(struct kvm_vcpu *vcpu)
{
<yellow>	if (!enable_vnmi ||</yellow>
<yellow>	    vmcs_read32(GUEST_INTERRUPTIBILITY_INFO) & GUEST_INTR_STATE_STI) {</yellow>
<yellow>		vmx_enable_irq_window(vcpu);</yellow>
		return;
	}

<yellow>	exec_controls_setbit(to_vmx(vcpu), CPU_BASED_NMI_WINDOW_EXITING);</yellow>
<yellow>}</yellow>

static void vmx_inject_irq(struct kvm_vcpu *vcpu, bool reinjected)
{
	struct vcpu_vmx *vmx = to_vmx(vcpu);
	uint32_t intr;
<blue>	int irq = vcpu->arch.interrupt.nr;</blue>

<blue>	trace_kvm_inj_virq(irq, vcpu->arch.interrupt.soft, reinjected);</blue>

<blue>	++vcpu->stat.irq_injections;</blue>
	if (vmx-&gt;rmode.vm86_active) {
		int inc_eip = 0;
<yellow>		if (vcpu->arch.interrupt.soft)</yellow>
<yellow>			inc_eip = vcpu->arch.event_exit_inst_len;</yellow>
<yellow>		kvm_inject_realmode_interrupt(vcpu, irq, inc_eip);</yellow>
		return;
	}
<blue>	intr = irq | INTR_INFO_VALID_MASK;</blue>
<blue>	if (vcpu->arch.interrupt.soft) {</blue>
		intr |= INTR_TYPE_SOFT_INTR;
<blue>		vmcs_write32(VM_ENTRY_INSTRUCTION_LEN,</blue>
<blue>			     vmx->vcpu.arch.event_exit_inst_len);</blue>
	} else
		intr |= INTR_TYPE_EXT_INTR;
<blue>	vmcs_write32(VM_ENTRY_INTR_INFO_FIELD, intr);</blue>

<blue>	vmx_clear_hlt(vcpu);</blue>
<blue>}</blue>

static void vmx_inject_nmi(struct kvm_vcpu *vcpu)
{
	struct vcpu_vmx *vmx = to_vmx(vcpu);

<blue>	if (!enable_vnmi) {</blue>
		/*
		 * Tracking the NMI-blocked state in software is built upon
		 * finding the next open IRQ window. This, in turn, depends on
		 * well-behaving guests: They have to keep IRQs disabled at
		 * least as long as the NMI handler runs. Otherwise we may
		 * cause NMI nesting, maybe breaking the guest. But as this is
		 * highly unlikely, we can live with the residual risk.
		 */
<yellow>		vmx->loaded_vmcs->soft_vnmi_blocked = 1;</yellow>
		vmx-&gt;loaded_vmcs-&gt;vnmi_blocked_time = 0;
	}

<blue>	++vcpu->stat.nmi_injections;</blue>
	vmx-&gt;loaded_vmcs-&gt;nmi_known_unmasked = false;

	if (vmx-&gt;rmode.vm86_active) {
<yellow>		kvm_inject_realmode_interrupt(vcpu, NMI_VECTOR, 0);</yellow>
		return;
	}

<blue>	vmcs_write32(VM_ENTRY_INTR_INFO_FIELD,</blue>
			INTR_TYPE_NMI_INTR | INTR_INFO_VALID_MASK | NMI_VECTOR);

<blue>	vmx_clear_hlt(vcpu);</blue>
<blue>}</blue>

<blue>bool vmx_get_nmi_mask(struct kvm_vcpu *vcpu)</blue>
<yellow>{</yellow>
	struct vcpu_vmx *vmx = to_vmx(vcpu);
	bool masked;

<blue>	if (!enable_vnmi)</blue>
<blue>		return vmx->loaded_vmcs->soft_vnmi_blocked;</blue>
<blue>	if (vmx->loaded_vmcs->nmi_known_unmasked)</blue>
<yellow>		return false;</yellow>
<blue>	masked = vmcs_read32(GUEST_INTERRUPTIBILITY_INFO) & GUEST_INTR_STATE_NMI;</blue>
<blue>	vmx->loaded_vmcs->nmi_known_unmasked = !masked;</blue>
	return masked;
<blue>}</blue>

void vmx_set_nmi_mask(struct kvm_vcpu *vcpu, bool masked)
{
	struct vcpu_vmx *vmx = to_vmx(vcpu);

<blue>	if (!enable_vnmi) {</blue>
<yellow>		if (vmx->loaded_vmcs->soft_vnmi_blocked != masked) {</yellow>
<yellow>			vmx->loaded_vmcs->soft_vnmi_blocked = masked;</yellow>
			vmx-&gt;loaded_vmcs-&gt;vnmi_blocked_time = 0;
		}
	} else {
<blue>		vmx->loaded_vmcs->nmi_known_unmasked = !masked;</blue>
		if (masked)
<blue>			vmcs_set_bits(GUEST_INTERRUPTIBILITY_INFO,</blue>
				      GUEST_INTR_STATE_NMI);
		else
<blue>			vmcs_clear_bits(GUEST_INTERRUPTIBILITY_INFO,</blue>
					GUEST_INTR_STATE_NMI);
	}
<blue>}</blue>

<yellow>bool vmx_nmi_blocked(struct kvm_vcpu *vcpu)</yellow>
{
<yellow>	if (is_guest_mode(vcpu) && nested_exit_on_nmi(vcpu))</yellow>
		return false;

<yellow>	if (!enable_vnmi && to_vmx(vcpu)->loaded_vmcs->soft_vnmi_blocked)</yellow>
		return true;

<yellow>	return (vmcs_read32(GUEST_INTERRUPTIBILITY_INFO) &</yellow>
		(GUEST_INTR_STATE_MOV_SS | GUEST_INTR_STATE_STI |
		 GUEST_INTR_STATE_NMI));
<yellow>}</yellow>

static int vmx_nmi_allowed(struct kvm_vcpu *vcpu, bool for_injection)
{
<yellow>	if (to_vmx(vcpu)->nested.nested_run_pending)</yellow>
		return -EBUSY;

	/* An NMI must not be injected into L2 if it&#x27;s supposed to VM-Exit.  */
<yellow>	if (for_injection && is_guest_mode(vcpu) && nested_exit_on_nmi(vcpu))</yellow>
		return -EBUSY;

<yellow>	return !vmx_nmi_blocked(vcpu);</yellow>
<yellow>}</yellow>

bool vmx_interrupt_blocked(struct kvm_vcpu *vcpu)
{
<blue>	if (is_guest_mode(vcpu) && nested_exit_on_intr(vcpu))</blue>
		return false;

<blue>	return !(vmx_get_rflags(vcpu) & X86_EFLAGS_IF) ||</blue>
<blue>	       (vmcs_read32(GUEST_INTERRUPTIBILITY_INFO) &</blue>
		(GUEST_INTR_STATE_STI | GUEST_INTR_STATE_MOV_SS));
<blue>}</blue>

static int vmx_interrupt_allowed(struct kvm_vcpu *vcpu, bool for_injection)
{
<blue>	if (to_vmx(vcpu)->nested.nested_run_pending)</blue>
		return -EBUSY;

       /*
        * An IRQ must not be injected into L2 if it&#x27;s supposed to VM-Exit,
        * e.g. if the IRQ arrived asynchronously after checking nested events.
        */
<blue>	if (for_injection && is_guest_mode(vcpu) && nested_exit_on_intr(vcpu))</blue>
		return -EBUSY;

<blue>	return !vmx_interrupt_blocked(vcpu);</blue>
<blue>}</blue>

<yellow>static int vmx_set_tss_addr(struct kvm *kvm, unsigned int addr)</yellow>
<blue>{</blue>
	void __user *ret;

<blue>	if (enable_unrestricted_guest)</blue>
		return 0;

<yellow>	mutex_lock(&kvm->slots_lock);</yellow>
<yellow>	ret = __x86_set_memory_region(kvm, TSS_PRIVATE_MEMSLOT, addr,</yellow>
				      PAGE_SIZE * 3);
	mutex_unlock(&amp;kvm-&gt;slots_lock);

<yellow>	if (IS_ERR(ret))</yellow>
<yellow>		return PTR_ERR(ret);</yellow>

<yellow>	to_kvm_vmx(kvm)->tss_addr = addr;</yellow>

<yellow>	return init_rmode_tss(kvm, ret);</yellow>
<yellow>}</yellow>

static int vmx_set_identity_map_addr(struct kvm *kvm, u64 ident_addr)
<yellow>{</yellow>
<blue>	to_kvm_vmx(kvm)->ept_identity_map_addr = ident_addr;</blue>
	return 0;
<yellow>}</yellow>

static bool rmode_exception(struct kvm_vcpu *vcpu, int vec)
{
<yellow>	switch (vec) {</yellow>
	case BP_VECTOR:
		/*
		 * Update instruction length as we may reinject the exception
		 * from user space while in guest debugging mode.
		 */
<yellow>		to_vmx(vcpu)->vcpu.arch.event_exit_inst_len =</yellow>
<yellow>			vmcs_read32(VM_EXIT_INSTRUCTION_LEN);</yellow>
		if (vcpu-&gt;guest_debug &amp; KVM_GUESTDBG_USE_SW_BP)
			return false;
		fallthrough;
	case DB_VECTOR:
<yellow>		return !(vcpu->guest_debug &</yellow>
			(KVM_GUESTDBG_SINGLESTEP | KVM_GUESTDBG_USE_HW_BP));
	case DE_VECTOR:
	case OF_VECTOR:
	case BR_VECTOR:
	case UD_VECTOR:
	case DF_VECTOR:
	case SS_VECTOR:
	case GP_VECTOR:
	case MF_VECTOR:
		return true;
	}
	return false;
}

static int handle_rmode_exception(struct kvm_vcpu *vcpu,
				  int vec, u32 err_code)
{
	/*
	 * Instruction with address size override prefix opcode 0x67
	 * Cause the #SS fault with 0 error code in VM86 mode.
	 */
<yellow>	if (((vec == GP_VECTOR) || (vec == SS_VECTOR)) && err_code == 0) {</yellow>
<yellow>		if (kvm_emulate_instruction(vcpu, 0)) {</yellow>
<yellow>			if (vcpu->arch.halt_request) {</yellow>
				vcpu-&gt;arch.halt_request = 0;
<yellow>				return kvm_emulate_halt_noskip(vcpu);</yellow>
			}
			return 1;
		}
		return 0;
	}

	/*
	 * Forward all other exceptions that are valid in real mode.
	 * FIXME: Breaks guest debugging in real mode, needs to be fixed with
	 *        the required debugging infrastructure rework.
	 */
<yellow>	kvm_queue_exception(vcpu, vec);</yellow>
	return 1;
}

static int handle_machine_check(struct kvm_vcpu *vcpu)
{
	/* handled by vmx_vcpu_run() */
	return 1;
<yellow>}</yellow>

/*
 * If the host has split lock detection disabled, then #AC is
 * unconditionally injected into the guest, which is the pre split lock
 * detection behaviour.
 *
 * If the host has split lock detection enabled then #AC is
 * only injected into the guest when:
 *  - Guest CPL == 3 (user mode)
 *  - Guest has #AC detection enabled in CR0
 *  - Guest EFLAGS has AC bit set
 */
<blue>bool vmx_guest_inject_ac(struct kvm_vcpu *vcpu)</blue>
<blue>{</blue>
<blue>	if (!boot_cpu_has(X86_FEATURE_SPLIT_LOCK_DETECT))</blue>
		return true;

<blue>	return vmx_get_cpl(vcpu) == 3 && kvm_read_cr0_bits(vcpu, X86_CR0_AM) &&</blue>
<yellow>	       (kvm_get_rflags(vcpu) & X86_EFLAGS_AC);</yellow>
<yellow>}</yellow>

static int handle_exception_nmi(struct kvm_vcpu *vcpu)
{
	struct vcpu_vmx *vmx = to_vmx(vcpu);
<blue>	struct kvm_run *kvm_run = vcpu->run;</blue>
	u32 intr_info, ex_no, error_code;
	unsigned long cr2, dr6;
	u32 vect_info;

	vect_info = vmx-&gt;idt_vectoring_info;
	intr_info = vmx_get_intr_info(vcpu);

<blue>	if (is_machine_check(intr_info) || is_nmi(intr_info))</blue>
		return 1; /* handled by handle_exception_nmi_irqoff() */

	/*
	 * Queue the exception here instead of in handle_nm_fault_irqoff().
	 * This ensures the nested_vmx check is not skipped so vmexit can
	 * be reflected to L1 (when it intercepts #NM) before reaching this
	 * point.
	 */
<blue>	if (is_nm_fault(intr_info)) {</blue>
<yellow>		kvm_queue_exception(vcpu, NM_VECTOR);</yellow>
		return 1;
	}

<blue>	if (is_invalid_opcode(intr_info))</blue>
<blue>		return handle_ud(vcpu);</blue>

	error_code = 0;
<blue>	if (intr_info & INTR_INFO_DELIVER_CODE_MASK)</blue>
<blue>		error_code = vmcs_read32(VM_EXIT_INTR_ERROR_CODE);</blue>

<blue>	if (!vmx->rmode.vm86_active && is_gp_fault(intr_info)) {</blue>
<yellow>		WARN_ON_ONCE(!enable_vmware_backdoor);</yellow>

		/*
		 * VMware backdoor emulation on #GP interception only handles
		 * IN{S}, OUT{S}, and RDPMC, none of which generate a non-zero
		 * error code on #GP.
		 */
<yellow>		if (error_code) {</yellow>
<yellow>			kvm_queue_exception_e(vcpu, GP_VECTOR, error_code);</yellow>
			return 1;
		}
<yellow>		return kvm_emulate_instruction(vcpu, EMULTYPE_VMWARE_GP);</yellow>
	}

	/*
	 * The #PF with PFEC.RSVD = 1 indicates the guest is accessing
	 * MMIO, it is better to report an internal error.
	 * See the comments in vmx_handle_exit.
	 */
<blue>	if ((vect_info & VECTORING_INFO_VALID_MASK) &&</blue>
<yellow>	    !(is_page_fault(intr_info) && !(error_code & PFERR_RSVD_MASK))) {</yellow>
<yellow>		vcpu->run->exit_reason = KVM_EXIT_INTERNAL_ERROR;</yellow>
		vcpu-&gt;run-&gt;internal.suberror = KVM_INTERNAL_ERROR_SIMUL_EX;
		vcpu-&gt;run-&gt;internal.ndata = 4;
		vcpu-&gt;run-&gt;internal.data[0] = vect_info;
		vcpu-&gt;run-&gt;internal.data[1] = intr_info;
		vcpu-&gt;run-&gt;internal.data[2] = error_code;
		vcpu-&gt;run-&gt;internal.data[3] = vcpu-&gt;arch.last_vmentry_cpu;
		return 0;
	}

<blue>	if (is_page_fault(intr_info)) {</blue>
<yellow>		cr2 = vmx_get_exit_qual(vcpu);</yellow>
<yellow>		if (enable_ept && !vcpu->arch.apf.host_apf_flags) {</yellow>
			/*
			 * EPT will cause page fault only if we need to
			 * detect illegal GPAs.
			 */
<yellow>			WARN_ON_ONCE(!allow_smaller_maxphyaddr);</yellow>
<yellow>			kvm_fixup_and_inject_pf_error(vcpu, cr2, error_code);</yellow>
			return 1;
		} else
<yellow>			return kvm_handle_page_fault(vcpu, error_code, cr2, NULL, 0);</yellow>
	}

<blue>	ex_no = intr_info & INTR_INFO_VECTOR_MASK;</blue>

<yellow>	if (vmx->rmode.vm86_active && rmode_exception(vcpu, ex_no))</yellow>
<yellow>		return handle_rmode_exception(vcpu, ex_no, error_code);</yellow>

<blue>	switch (ex_no) {</blue>
	case DB_VECTOR:
<blue>		dr6 = vmx_get_exit_qual(vcpu);</blue>
		if (!(vcpu-&gt;guest_debug &amp;
		      (KVM_GUESTDBG_SINGLESTEP | KVM_GUESTDBG_USE_HW_BP))) {
			/*
			 * If the #DB was due to ICEBP, a.k.a. INT1, skip the
			 * instruction.  ICEBP generates a trap-like #DB, but
			 * despite its interception control being tied to #DB,
			 * is an instruction intercept, i.e. the VM-Exit occurs
			 * on the ICEBP itself.  Use the inner &quot;skip&quot; helper to
			 * avoid single-step #DB and MTF updates, as ICEBP is
			 * higher priority.  Note, skipping ICEBP still clears
			 * STI and MOVSS blocking.
			 *
			 * For all other #DBs, set vmcs.PENDING_DBG_EXCEPTIONS.BS
			 * if single-step is enabled in RFLAGS and STI or MOVSS
			 * blocking is active, as the CPU doesn&#x27;t set the bit
			 * on VM-Exit due to #DB interception.  VM-Entry has a
			 * consistency check that a single-step #DB is pending
			 * in this scenario as the previous instruction cannot
			 * have toggled RFLAGS.TF 0=&gt;1 (because STI and POP/MOV
			 * don&#x27;t modify RFLAGS), therefore the one instruction
			 * delay when activating single-step breakpoints must
			 * have already expired.  Note, the CPU sets/clears BS
			 * as appropriate for all other VM-Exits types.
			 */
<blue>			if (is_icebp(intr_info))</blue>
<blue>				WARN_ON(!skip_emulated_instruction(vcpu));</blue>
<blue>			else if ((vmx_get_rflags(vcpu) & X86_EFLAGS_TF) &&</blue>
<yellow>				 (vmcs_read32(GUEST_INTERRUPTIBILITY_INFO) &</yellow>
				  (GUEST_INTR_STATE_STI | GUEST_INTR_STATE_MOV_SS)))
<yellow>				vmcs_writel(GUEST_PENDING_DBG_EXCEPTIONS,</yellow>
<yellow>					    vmcs_readl(GUEST_PENDING_DBG_EXCEPTIONS) | DR6_BS);</yellow>

<blue>			kvm_queue_exception_p(vcpu, DB_VECTOR, dr6);</blue>
			return 1;
		}
<yellow>		kvm_run->debug.arch.dr6 = dr6 | DR6_ACTIVE_LOW;</yellow>
<yellow>		kvm_run->debug.arch.dr7 = vmcs_readl(GUEST_DR7);</yellow>
		fallthrough;
	case BP_VECTOR:
		/*
		 * Update instruction length as we may reinject #BP from
		 * user space while in guest debugging mode. Reading it for
		 * #DB as well causes no harm, it is not used in that case.
		 */
<yellow>		vmx->vcpu.arch.event_exit_inst_len =</yellow>
<yellow>			vmcs_read32(VM_EXIT_INSTRUCTION_LEN);</yellow>
		kvm_run-&gt;exit_reason = KVM_EXIT_DEBUG;
		kvm_run-&gt;debug.arch.pc = kvm_get_linear_rip(vcpu);
		kvm_run-&gt;debug.arch.exception = ex_no;
		break;
	case AC_VECTOR:
<blue>		if (vmx_guest_inject_ac(vcpu)) {</blue>
<yellow>			kvm_queue_exception_e(vcpu, AC_VECTOR, error_code);</yellow>
			return 1;
		}

		/*
		 * Handle split lock. Depending on detection mode this will
		 * either warn and disable split lock detection for this
		 * task or force SIGBUS on it.
		 */
<blue>		if (handle_guest_split_lock(kvm_rip_read(vcpu)))</blue>
			return 1;
		fallthrough;
	default:
<yellow>		kvm_run->exit_reason = KVM_EXIT_EXCEPTION;</yellow>
		kvm_run-&gt;ex.exception = ex_no;
		kvm_run-&gt;ex.error_code = error_code;
		break;
	}
	return 0;
<blue>}</blue>

static __always_inline int handle_external_interrupt(struct kvm_vcpu *vcpu)
{
<blue>	++vcpu->stat.irq_exits;</blue>
	return 1;
<yellow>}</yellow>

static int handle_triple_fault(struct kvm_vcpu *vcpu)
{
<blue>	vcpu->run->exit_reason = KVM_EXIT_SHUTDOWN;</blue>
<yellow>	vcpu->mmio_needed = 0;</yellow>
	return 0;
<yellow>}</yellow>

<blue>static int handle_io(struct kvm_vcpu *vcpu)</blue>
<yellow>{</yellow>
	unsigned long exit_qualification;
	int size, in, string;
	unsigned port;

<blue>	exit_qualification = vmx_get_exit_qual(vcpu);</blue>
	string = (exit_qualification &amp; 16) != 0;

<yellow>	++vcpu->stat.io_exits;</yellow>

	if (string)
<blue>		return kvm_emulate_instruction(vcpu, 0);</blue>

	port = exit_qualification &gt;&gt; 16;
	size = (exit_qualification &amp; 7) + 1;
<blue>	in = (exit_qualification & 8) != 0;</blue>

<yellow>	return kvm_fast_pio(vcpu, size, port, in);</yellow>
<blue>}</blue>

static void
vmx_patch_hypercall(struct kvm_vcpu *vcpu, unsigned char *hypercall)
<yellow>{</yellow>
	/*
	 * Patch in the VMCALL instruction:
	 */
<yellow>	hypercall[0] = 0x0f;</yellow>
<yellow>	hypercall[1] = 0x01;</yellow>
<yellow>	hypercall[2] = 0xc1;</yellow>
}

/* called to set cr0 as appropriate for a mov-to-cr0 exit. */
static int handle_set_cr0(struct kvm_vcpu *vcpu, unsigned long val)
{
<blue>	if (is_guest_mode(vcpu)) {</blue>
<blue>		struct vmcs12 *vmcs12 = get_vmcs12(vcpu);</blue>
		unsigned long orig_val = val;

		/*
		 * We get here when L2 changed cr0 in a way that did not change
		 * any of L1&#x27;s shadowed bits (see nested_vmx_exit_handled_cr),
		 * but did change L0 shadowed bits. So we first calculate the
		 * effective cr0 value that L1 would like to write into the
		 * hardware. It consists of the L2-owned bits from the new
		 * value combined with the L1-owned bits from L1&#x27;s guest_cr0.
		 */
		val = (val &amp; ~vmcs12-&gt;cr0_guest_host_mask) |
			(vmcs12-&gt;guest_cr0 &amp; vmcs12-&gt;cr0_guest_host_mask);

<blue>		if (!nested_guest_cr0_valid(vcpu, val))</blue>
			return 1;

<blue>		if (kvm_set_cr0(vcpu, val))</blue>
			return 1;
<blue>		vmcs_writel(CR0_READ_SHADOW, orig_val);</blue>
		return 0;
	} else {
<blue>		if (to_vmx(vcpu)->nested.vmxon &&</blue>
<blue>		    !nested_host_cr0_valid(vcpu, val))</blue>
			return 1;

<blue>		return kvm_set_cr0(vcpu, val);</blue>
	}
}

static int handle_set_cr4(struct kvm_vcpu *vcpu, unsigned long val)
{
<blue>	if (is_guest_mode(vcpu)) {</blue>
<blue>		struct vmcs12 *vmcs12 = get_vmcs12(vcpu);</blue>
		unsigned long orig_val = val;

		/* analogously to handle_set_cr0 */
		val = (val &amp; ~vmcs12-&gt;cr4_guest_host_mask) |
			(vmcs12-&gt;guest_cr4 &amp; vmcs12-&gt;cr4_guest_host_mask);
		if (kvm_set_cr4(vcpu, val))
			return 1;
<yellow>		vmcs_writel(CR4_READ_SHADOW, orig_val);</yellow>
		return 0;
	} else
<blue>		return kvm_set_cr4(vcpu, val);</blue>
}

static int handle_desc(struct kvm_vcpu *vcpu)
<yellow>{</yellow>
<yellow>	WARN_ON(!(vcpu->arch.cr4 & X86_CR4_UMIP));</yellow>
<yellow>	return kvm_emulate_instruction(vcpu, 0);</yellow>
}

static int handle_cr(struct kvm_vcpu *vcpu)
<blue>{</blue>
	unsigned long exit_qualification, val;
	int cr;
	int reg;
	int err;
	int ret;

<blue>	exit_qualification = vmx_get_exit_qual(vcpu);</blue>
	cr = exit_qualification &amp; 15;
	reg = (exit_qualification &gt;&gt; 8) &amp; 15;
	switch ((exit_qualification &gt;&gt; 4) &amp; 3) {
	case 0: /* mov to cr */
<blue>		val = kvm_register_read(vcpu, reg);</blue>
<blue>		trace_kvm_cr_write(cr, val);</blue>
<blue>		switch (cr) {</blue>
		case 0:
<blue>			err = handle_set_cr0(vcpu, val);</blue>
			return kvm_complete_insn_gp(vcpu, err);
		case 3:
<yellow>			WARN_ON_ONCE(enable_unrestricted_guest);</yellow>

<yellow>			err = kvm_set_cr3(vcpu, val);</yellow>
			return kvm_complete_insn_gp(vcpu, err);
		case 4:
<blue>			err = handle_set_cr4(vcpu, val);</blue>
<blue>			return kvm_complete_insn_gp(vcpu, err);</blue>
		case 8: {
<blue>				u8 cr8_prev = kvm_get_cr8(vcpu);</blue>
<yellow>				u8 cr8 = (u8)val;</yellow>
				err = kvm_set_cr8(vcpu, cr8);
				ret = kvm_complete_insn_gp(vcpu, err);
<yellow>				if (lapic_in_kernel(vcpu))</yellow>
					return ret;
				if (cr8_prev &lt;= cr8)
					return ret;
				/*
				 * TODO: we might be squashing a
				 * KVM_GUESTDBG_SINGLESTEP-triggered
				 * KVM_EXIT_DEBUG here.
				 */
<yellow>				vcpu->run->exit_reason = KVM_EXIT_SET_TPR;</yellow>
				return 0;
			}
		}
		break;
	case 2: /* clts */
<yellow>		KVM_BUG(1, vcpu->kvm, "Guest always owns CR0.TS");</yellow>
		return -EIO;
	case 1: /*mov from cr*/
<blue>		switch (cr) {</blue>
		case 3:
<yellow>			WARN_ON_ONCE(enable_unrestricted_guest);</yellow>

<yellow>			val = kvm_read_cr3(vcpu);</yellow>
			kvm_register_write(vcpu, reg, val);
<yellow>			trace_kvm_cr_read(cr, val);</yellow>
			return kvm_skip_emulated_instruction(vcpu);
		case 8:
<blue>			val = kvm_get_cr8(vcpu);</blue>
			kvm_register_write(vcpu, reg, val);
<yellow>			trace_kvm_cr_read(cr, val);</yellow>
<blue>			return kvm_skip_emulated_instruction(vcpu);</blue>
		}
		break;
	case 3: /* lmsw */
<yellow>		val = (exit_qualification >> LMSW_SOURCE_DATA_SHIFT) & 0x0f;</yellow>
<yellow>		trace_kvm_cr_write(0, (kvm_read_cr0(vcpu) & ~0xful) | val);</yellow>
<yellow>		kvm_lmsw(vcpu, val);</yellow>

		return kvm_skip_emulated_instruction(vcpu);
	default:
		break;
	}
<yellow>	vcpu->run->exit_reason = 0;</yellow>
<yellow>	vcpu_unimpl(vcpu, "unhandled control register: op %d cr %d\n",</yellow>
	       (int)(exit_qualification &gt;&gt; 4) &amp; 3, cr);
	return 0;
}

static int handle_dr(struct kvm_vcpu *vcpu)
<blue>{</blue>
	unsigned long exit_qualification;
	int dr, dr7, reg;
	int err = 1;

<blue>	exit_qualification = vmx_get_exit_qual(vcpu);</blue>
	dr = exit_qualification &amp; DEBUG_REG_ACCESS_NUM;

	/* First, if DR does not exist, trigger UD */
	if (!kvm_require_dr(vcpu, dr))
		return 1;

<blue>	if (vmx_get_cpl(vcpu) > 0)</blue>
		goto out;

<blue>	dr7 = vmcs_readl(GUEST_DR7);</blue>
<blue>	if (dr7 & DR7_GD) {</blue>
		/*
		 * As the vm-exit takes precedence over the debug trap, we
		 * need to emulate the latter, either for the host or the
		 * guest debugging itself.
		 */
<blue>		if (vcpu->guest_debug & KVM_GUESTDBG_USE_HW_BP) {</blue>
<yellow>			vcpu->run->debug.arch.dr6 = DR6_BD | DR6_ACTIVE_LOW;</yellow>
			vcpu-&gt;run-&gt;debug.arch.dr7 = dr7;
			vcpu-&gt;run-&gt;debug.arch.pc = kvm_get_linear_rip(vcpu);
			vcpu-&gt;run-&gt;debug.arch.exception = DB_VECTOR;
			vcpu-&gt;run-&gt;exit_reason = KVM_EXIT_DEBUG;
			return 0;
		} else {
<blue>			kvm_queue_exception_p(vcpu, DB_VECTOR, DR6_BD);</blue>
			return 1;
		}
	}

<blue>	if (vcpu->guest_debug == 0) {</blue>
<blue>		exec_controls_clearbit(to_vmx(vcpu), CPU_BASED_MOV_DR_EXITING);</blue>

		/*
		 * No more DR vmexits; force a reload of the debug registers
		 * and reenter on this instruction.  The next vmexit will
		 * retrieve the full state of the debug registers.
		 */
<blue>		vcpu->arch.switch_db_regs |= KVM_DEBUGREG_WONT_EXIT;</blue>
		return 1;
	}

<yellow>	reg = DEBUG_REG_ACCESS_REG(exit_qualification);</yellow>
	if (exit_qualification &amp; TYPE_MOV_FROM_DR) {
		unsigned long val;

<yellow>		kvm_get_dr(vcpu, dr, &val);</yellow>
		kvm_register_write(vcpu, reg, val);
		err = 0;
	} else {
<yellow>		err = kvm_set_dr(vcpu, dr, kvm_register_read(vcpu, reg));</yellow>
	}

out:
<yellow>	return kvm_complete_insn_gp(vcpu, err);</yellow>
}

static void vmx_sync_dirty_debug_regs(struct kvm_vcpu *vcpu)
{
<blue>	get_debugreg(vcpu->arch.db[0], 0);</blue>
	get_debugreg(vcpu-&gt;arch.db[1], 1);
	get_debugreg(vcpu-&gt;arch.db[2], 2);
	get_debugreg(vcpu-&gt;arch.db[3], 3);
	get_debugreg(vcpu-&gt;arch.dr6, 6);
<blue>	vcpu->arch.dr7 = vmcs_readl(GUEST_DR7);</blue>

	vcpu-&gt;arch.switch_db_regs &amp;= ~KVM_DEBUGREG_WONT_EXIT;
<blue>	exec_controls_setbit(to_vmx(vcpu), CPU_BASED_MOV_DR_EXITING);</blue>

	/*
	 * exc_debug expects dr6 to be cleared after it runs, avoid that it sees
	 * a stale dr6 from the guest.
	 */
<blue>	set_debugreg(DR6_RESERVED, 6);</blue>
}

static void vmx_set_dr7(struct kvm_vcpu *vcpu, unsigned long val)
{
<blue>	vmcs_writel(GUEST_DR7, val);</blue>
<blue>}</blue>

static int handle_tpr_below_threshold(struct kvm_vcpu *vcpu)
<yellow>{</yellow>
<yellow>	kvm_apic_update_ppr(vcpu);</yellow>
	return 1;
<yellow>}</yellow>

static int handle_interrupt_window(struct kvm_vcpu *vcpu)
{
<blue>	exec_controls_clearbit(to_vmx(vcpu), CPU_BASED_INTR_WINDOW_EXITING);</blue>

<blue>	kvm_make_request(KVM_REQ_EVENT, vcpu);</blue>

	++vcpu-&gt;stat.irq_window_exits;
	return 1;
}

static int handle_invlpg(struct kvm_vcpu *vcpu)
<yellow>{</yellow>
<yellow>	unsigned long exit_qualification = vmx_get_exit_qual(vcpu);</yellow>

	kvm_mmu_invlpg(vcpu, exit_qualification);
	return kvm_skip_emulated_instruction(vcpu);
<yellow>}</yellow>

static int handle_apic_access(struct kvm_vcpu *vcpu)
<yellow>{</yellow>
<yellow>	if (likely(fasteoi)) {</yellow>
<yellow>		unsigned long exit_qualification = vmx_get_exit_qual(vcpu);</yellow>
		int access_type, offset;

		access_type = exit_qualification &amp; APIC_ACCESS_TYPE;
<yellow>		offset = exit_qualification & APIC_ACCESS_OFFSET;</yellow>
		/*
		 * Sane guest uses MOV to write EOI, with written value
		 * not cared. So make a short-circuit here by avoiding
		 * heavy instruction emulation.
		 */
<yellow>		if ((access_type == TYPE_LINEAR_APIC_INST_WRITE) &&</yellow>
		    (offset == APIC_EOI)) {
<yellow>			kvm_lapic_set_eoi(vcpu);</yellow>
<yellow>			return kvm_skip_emulated_instruction(vcpu);</yellow>
		}
	}
<yellow>	return kvm_emulate_instruction(vcpu, 0);</yellow>
<yellow>}</yellow>

static int handle_apic_eoi_induced(struct kvm_vcpu *vcpu)
<yellow>{</yellow>
<yellow>	unsigned long exit_qualification = vmx_get_exit_qual(vcpu);</yellow>
	int vector = exit_qualification &amp; 0xff;

	/* EOI-induced VM exit is trap-like and thus no need to adjust IP */
	kvm_apic_set_eoi_accelerated(vcpu, vector);
	return 1;
<yellow>}</yellow>

static int handle_apic_write(struct kvm_vcpu *vcpu)
{
<blue>	unsigned long exit_qualification = vmx_get_exit_qual(vcpu);</blue>

	/*
	 * APIC-write VM-Exit is trap-like, KVM doesn&#x27;t need to advance RIP and
	 * hardware has done any necessary aliasing, offset adjustments, etc...
	 * for the access.  I.e. the correct value has already been  written to
	 * the vAPIC page for the correct 16-byte chunk.  KVM needs only to
	 * retrieve the register value and emulate the access.
	 */
	u32 offset = exit_qualification &amp; 0xff0;

	kvm_apic_write_nodecode(vcpu, offset);
	return 1;
<yellow>}</yellow>

static int handle_task_switch(struct kvm_vcpu *vcpu)
{
	struct vcpu_vmx *vmx = to_vmx(vcpu);
	unsigned long exit_qualification;
	bool has_error_code = false;
	u32 error_code = 0;
	u16 tss_selector;
	int reason, type, idt_v, idt_index;

<yellow>	idt_v = (vmx->idt_vectoring_info & VECTORING_INFO_VALID_MASK);</yellow>
<yellow>	idt_index = (vmx->idt_vectoring_info & VECTORING_INFO_VECTOR_MASK);</yellow>
	type = (vmx-&gt;idt_vectoring_info &amp; VECTORING_INFO_TYPE_MASK);

	exit_qualification = vmx_get_exit_qual(vcpu);

	reason = (u32)exit_qualification &gt;&gt; 30;
<yellow>	if (reason == TASK_SWITCH_GATE && idt_v) {</yellow>
<yellow>		switch (type) {</yellow>
		case INTR_TYPE_NMI_INTR:
<yellow>			vcpu->arch.nmi_injected = false;</yellow>
<yellow>			vmx_set_nmi_mask(vcpu, true);</yellow>
			break;
		case INTR_TYPE_EXT_INTR:
		case INTR_TYPE_SOFT_INTR:
<yellow>			kvm_clear_interrupt_queue(vcpu);</yellow>
			break;
		case INTR_TYPE_HARD_EXCEPTION:
<yellow>			if (vmx->idt_vectoring_info &</yellow>
			    VECTORING_INFO_DELIVER_CODE_MASK) {
				has_error_code = true;
				error_code =
<yellow>					vmcs_read32(IDT_VECTORING_ERROR_CODE);</yellow>
			}
			fallthrough;
		case INTR_TYPE_SOFT_EXCEPTION:
<yellow>			kvm_clear_exception_queue(vcpu);</yellow>
			break;
		default:
			break;
		}
	}
	tss_selector = exit_qualification;

<yellow>	if (!idt_v || (type != INTR_TYPE_HARD_EXCEPTION &&</yellow>
		       type != INTR_TYPE_EXT_INTR &amp;&amp;
		       type != INTR_TYPE_NMI_INTR))
<yellow>		WARN_ON(!skip_emulated_instruction(vcpu));</yellow>

	/*
	 * TODO: What about debug traps on tss switch?
	 *       Are we supposed to inject them and update dr6?
	 */
<yellow>	return kvm_task_switch(vcpu, tss_selector,</yellow>
			       type == INTR_TYPE_SOFT_INTR ? idt_index : -1,
			       reason, has_error_code, error_code);
}

static int handle_ept_violation(struct kvm_vcpu *vcpu)
{
	unsigned long exit_qualification;
	gpa_t gpa;
	u64 error_code;

<blue>	exit_qualification = vmx_get_exit_qual(vcpu);</blue>

	/*
	 * EPT violation happened while executing iret from NMI,
	 * &quot;blocked by NMI&quot; bit has to be set before next VM entry.
	 * There are errata that may cause this bit to not be set:
	 * AAK134, BY25.
	 */
<blue>	if (!(to_vmx(vcpu)->idt_vectoring_info & VECTORING_INFO_VALID_MASK) &&</blue>
			enable_vnmi &amp;&amp;
<blue>			(exit_qualification & INTR_INFO_UNBLOCK_NMI))</blue>
<yellow>		vmcs_set_bits(GUEST_INTERRUPTIBILITY_INFO, GUEST_INTR_STATE_NMI);</yellow>

<blue>	gpa = vmcs_read64(GUEST_PHYSICAL_ADDRESS);</blue>
<blue>	trace_kvm_page_fault(vcpu, gpa, exit_qualification);</blue>

	/* Is it a read fault? */
	error_code = (exit_qualification &amp; EPT_VIOLATION_ACC_READ)
		     ? PFERR_USER_MASK : 0;
	/* Is it a write fault? */
	error_code |= (exit_qualification &amp; EPT_VIOLATION_ACC_WRITE)
		      ? PFERR_WRITE_MASK : 0;
	/* Is it a fetch fault? */
	error_code |= (exit_qualification &amp; EPT_VIOLATION_ACC_INSTR)
		      ? PFERR_FETCH_MASK : 0;
	/* ept page table entry is present? */
<blue>	error_code |= (exit_qualification & EPT_VIOLATION_RWX_MASK)</blue>
		      ? PFERR_PRESENT_MASK : 0;

	error_code |= (exit_qualification &amp; EPT_VIOLATION_GVA_TRANSLATED) != 0 ?
	       PFERR_GUEST_FINAL_MASK : PFERR_GUEST_PAGE_MASK;

<blue>	vcpu->arch.exit_qualification = exit_qualification;</blue>

	/*
	 * Check that the GPA doesn&#x27;t exceed physical memory limits, as that is
	 * a guest page fault.  We have to emulate the instruction here, because
	 * if the illegal address is that of a paging structure, then
	 * EPT_VIOLATION_ACC_WRITE bit is set.  Alternatively, if supported we
	 * would also use advanced VM-exit information for EPT violations to
	 * reconstruct the page fault error code.
	 */
<blue>	if (unlikely(allow_smaller_maxphyaddr && kvm_vcpu_is_illegal_gpa(vcpu, gpa)))</blue>
<yellow>		return kvm_emulate_instruction(vcpu, 0);</yellow>

<blue>	return kvm_mmu_page_fault(vcpu, gpa, error_code, NULL, 0);</blue>
<blue>}</blue>

static int handle_ept_misconfig(struct kvm_vcpu *vcpu)
{
	gpa_t gpa;

<blue>	if (!vmx_can_emulate_instruction(vcpu, EMULTYPE_PF, NULL, 0))</blue>
<yellow>		return 1;</yellow>

	/*
	 * A nested guest cannot optimize MMIO vmexits, because we have an
	 * nGPA here instead of the required GPA.
	 */
<blue>	gpa = vmcs_read64(GUEST_PHYSICAL_ADDRESS);</blue>
<blue>	if (!is_guest_mode(vcpu) &&</blue>
<blue>	    !kvm_io_bus_write(vcpu, KVM_FAST_MMIO_BUS, gpa, 0, NULL)) {</blue>
<yellow>		trace_kvm_fast_mmio(gpa);</yellow>
<yellow>		return kvm_skip_emulated_instruction(vcpu);</yellow>
	}

<blue>	return kvm_mmu_page_fault(vcpu, gpa, PFERR_RSVD_MASK, NULL, 0);</blue>
<blue>}</blue>

static int handle_nmi_window(struct kvm_vcpu *vcpu)
{
<yellow>	if (KVM_BUG_ON(!enable_vnmi, vcpu->kvm))</yellow>
		return -EIO;

<yellow>	exec_controls_clearbit(to_vmx(vcpu), CPU_BASED_NMI_WINDOW_EXITING);</yellow>
<yellow>	++vcpu->stat.nmi_window_exits;</yellow>
	kvm_make_request(KVM_REQ_EVENT, vcpu);

	return 1;
<yellow>}</yellow>

static bool vmx_emulation_required_with_pending_exception(struct kvm_vcpu *vcpu)
<yellow>{</yellow>
	struct vcpu_vmx *vmx = to_vmx(vcpu);

<blue>	return vmx->emulation_required && !vmx->rmode.vm86_active &&</blue>
<yellow>	       (kvm_is_exception_pending(vcpu) || vcpu->arch.exception.injected);</yellow>
<blue>}</blue>

static int handle_invalid_guest_state(struct kvm_vcpu *vcpu)
{
	struct vcpu_vmx *vmx = to_vmx(vcpu);
	bool intr_window_requested;
	unsigned count = 130;

<yellow>	intr_window_requested = exec_controls_get(vmx) &</yellow>
				CPU_BASED_INTR_WINDOW_EXITING;

<yellow>	while (vmx->emulation_required && count-- != 0) {</yellow>
<yellow>		if (intr_window_requested && !vmx_interrupt_blocked(vcpu))</yellow>
			return handle_interrupt_window(&amp;vmx-&gt;vcpu);

<yellow>		if (kvm_test_request(KVM_REQ_EVENT, vcpu))</yellow>
			return 1;

<yellow>		if (!kvm_emulate_instruction(vcpu, 0))</yellow>
			return 0;

<yellow>		if (vmx_emulation_required_with_pending_exception(vcpu)) {</yellow>
<yellow>			kvm_prepare_emulation_failure_exit(vcpu);</yellow>
			return 0;
		}

<yellow>		if (vcpu->arch.halt_request) {</yellow>
			vcpu-&gt;arch.halt_request = 0;
<yellow>			return kvm_emulate_halt_noskip(vcpu);</yellow>
		}

		/*
		 * Note, return 1 and not 0, vcpu_run() will invoke
		 * xfer_to_guest_mode() which will create a proper return
		 * code.
		 */
<yellow>		if (__xfer_to_guest_mode_work_pending())</yellow>
			return 1;
	}

	return 1;
}

static int vmx_vcpu_pre_run(struct kvm_vcpu *vcpu)
<yellow>{</yellow>
<blue>	if (vmx_emulation_required_with_pending_exception(vcpu)) {</blue>
<yellow>		kvm_prepare_emulation_failure_exit(vcpu);</yellow>
		return 0;
	}

	return 1;
<blue>}</blue>

static void grow_ple_window(struct kvm_vcpu *vcpu)
{
	struct vcpu_vmx *vmx = to_vmx(vcpu);
<blue>	unsigned int old = vmx->ple_window;</blue>

<blue>	vmx->ple_window = __grow_ple_window(old, ple_window,</blue>
					    ple_window_grow,
					    ple_window_max);

<yellow>	if (vmx->ple_window != old) {</yellow>
<blue>		vmx->ple_window_dirty = true;</blue>
<yellow>		trace_kvm_ple_window_update(vcpu->vcpu_id,</yellow>
					    vmx-&gt;ple_window, old);
	}
}

static void shrink_ple_window(struct kvm_vcpu *vcpu)
{
	struct vcpu_vmx *vmx = to_vmx(vcpu);
<blue>	unsigned int old = vmx->ple_window;</blue>

<blue>	vmx->ple_window = __shrink_ple_window(old, ple_window,</blue>
					      ple_window_shrink,
					      ple_window);

<yellow>	if (vmx->ple_window != old) {</yellow>
<blue>		vmx->ple_window_dirty = true;</blue>
<yellow>		trace_kvm_ple_window_update(vcpu->vcpu_id,</yellow>
					    vmx-&gt;ple_window, old);
	}
}

/*
 * Indicate a busy-waiting vcpu in spinlock. We do not enable the PAUSE
 * exiting, so only get here on cpu with PAUSE-Loop-Exiting.
 */
static int handle_pause(struct kvm_vcpu *vcpu)
{
<blue>	if (!kvm_pause_in_guest(vcpu->kvm))</blue>
<blue>		grow_ple_window(vcpu);</blue>

	/*
	 * Intel sdm vol3 ch-25.1.3 says: The &quot;PAUSE-loop exiting&quot;
	 * VM-execution control is ignored if CPL &gt; 0. OTOH, KVM
	 * never set PAUSE_EXITING and just set PLE if supported,
	 * so the vcpu must be CPL=0 if it gets a PAUSE exit.
	 */
<blue>	kvm_vcpu_on_spin(vcpu, true);</blue>
<yellow>	return kvm_skip_emulated_instruction(vcpu);</yellow>
<yellow>}</yellow>

static int handle_monitor_trap(struct kvm_vcpu *vcpu)
{
	return 1;
}

<yellow>static int handle_invpcid(struct kvm_vcpu *vcpu)</yellow>
<yellow>{</yellow>
	u32 vmx_instruction_info;
	unsigned long type;
	gva_t gva;
	struct {
		u64 pcid;
		u64 gla;
	} operand;
	int gpr_index;

<yellow>	if (!guest_cpuid_has(vcpu, X86_FEATURE_INVPCID)) {</yellow>
<yellow>		kvm_queue_exception(vcpu, UD_VECTOR);</yellow>
		return 1;
	}

<yellow>	vmx_instruction_info = vmcs_read32(VMX_INSTRUCTION_INFO);</yellow>
<yellow>	gpr_index = vmx_get_instr_info_reg2(vmx_instruction_info);</yellow>
<yellow>	type = kvm_register_read(vcpu, gpr_index);</yellow>

	/* According to the Intel instruction reference, the memory operand
	 * is read even if it isn&#x27;t needed (e.g., for type==all)
	 */
<yellow>	if (get_vmx_mem_address(vcpu, vmx_get_exit_qual(vcpu),</yellow>
				vmx_instruction_info, false,
				sizeof(operand), &amp;gva))
		return 1;

<yellow>	return kvm_handle_invpcid(vcpu, type, gva);</yellow>
<yellow>}</yellow>

<yellow>static int handle_pml_full(struct kvm_vcpu *vcpu)</yellow>
{
	unsigned long exit_qualification;

<yellow>	trace_kvm_pml_full(vcpu->vcpu_id);</yellow>

<yellow>	exit_qualification = vmx_get_exit_qual(vcpu);</yellow>

	/*
	 * PML buffer FULL happened while executing iret from NMI,
	 * &quot;blocked by NMI&quot; bit has to be set before next VM entry.
	 */
<yellow>	if (!(to_vmx(vcpu)->idt_vectoring_info & VECTORING_INFO_VALID_MASK) &&</yellow>
			enable_vnmi &amp;&amp;
<yellow>			(exit_qualification & INTR_INFO_UNBLOCK_NMI))</yellow>
<yellow>		vmcs_set_bits(GUEST_INTERRUPTIBILITY_INFO,</yellow>
				GUEST_INTR_STATE_NMI);

	/*
	 * PML buffer already flushed at beginning of VMEXIT. Nothing to do
	 * here.., and there&#x27;s no userspace involvement needed for PML.
	 */
	return 1;
<yellow>}</yellow>

<yellow>static fastpath_t handle_fastpath_preemption_timer(struct kvm_vcpu *vcpu)</yellow>
<yellow>{</yellow>
	struct vcpu_vmx *vmx = to_vmx(vcpu);

<blue>	if (!vmx->req_immediate_exit &&</blue>
<yellow>	    !unlikely(vmx->loaded_vmcs->hv_timer_soft_disabled)) {</yellow>
<yellow>		kvm_lapic_expired_hv_timer(vcpu);</yellow>
<yellow>		return EXIT_FASTPATH_REENTER_GUEST;</yellow>
	}

<blue>	return EXIT_FASTPATH_NONE;</blue>
<yellow>}</yellow>

static int handle_preemption_timer(struct kvm_vcpu *vcpu)
<yellow>{</yellow>
<blue>	handle_fastpath_preemption_timer(vcpu);</blue>
	return 1;
<yellow>}</yellow>

/*
 * When nested=0, all VMX instruction VM Exits filter here.  The handlers
 * are overwritten by nested_vmx_setup() when nested=1.
 */
static int handle_vmx_instruction(struct kvm_vcpu *vcpu)
<yellow>{</yellow>
<yellow>	kvm_queue_exception(vcpu, UD_VECTOR);</yellow>
	return 1;
}

#ifndef CONFIG_X86_SGX_KVM
static int handle_encls(struct kvm_vcpu *vcpu)
{
	/*
	 * SGX virtualization is disabled.  There is no software enable bit for
	 * SGX, so KVM intercepts all ENCLS leafs and injects a #UD to prevent
	 * the guest from executing ENCLS (when SGX is supported by hardware).
	 */
	kvm_queue_exception(vcpu, UD_VECTOR);
	return 1;
}
#endif /* CONFIG_X86_SGX_KVM */

static int handle_bus_lock_vmexit(struct kvm_vcpu *vcpu)
<yellow>{</yellow>
	/*
	 * Hardware may or may not set the BUS_LOCK_DETECTED flag on BUS_LOCK
	 * VM-Exits. Unconditionally set the flag here and leave the handling to
	 * vmx_handle_exit().
	 */
<yellow>	to_vmx(vcpu)->exit_reason.bus_lock_detected = true;</yellow>
	return 1;
}

static int handle_notify(struct kvm_vcpu *vcpu)
{
<yellow>	unsigned long exit_qual = vmx_get_exit_qual(vcpu);</yellow>
	bool context_invalid = exit_qual &amp; NOTIFY_VM_CONTEXT_INVALID;

	++vcpu-&gt;stat.notify_window_exits;

	/*
	 * Notify VM exit happened while executing iret from NMI,
	 * &quot;blocked by NMI&quot; bit has to be set before next VM entry.
	 */
<yellow>	if (enable_vnmi && (exit_qual & INTR_INFO_UNBLOCK_NMI))</yellow>
<yellow>		vmcs_set_bits(GUEST_INTERRUPTIBILITY_INFO,</yellow>
			      GUEST_INTR_STATE_NMI);

<yellow>	if (vcpu->kvm->arch.notify_vmexit_flags & KVM_X86_NOTIFY_VMEXIT_USER ||</yellow>
	    context_invalid) {
<yellow>		vcpu->run->exit_reason = KVM_EXIT_NOTIFY;</yellow>
		vcpu-&gt;run-&gt;notify.flags = context_invalid ?
					  KVM_NOTIFY_CONTEXT_INVALID : 0;
		return 0;
	}

	return 1;
<yellow>}</yellow>

/*
 * The exit handlers return 1 if the exit was handled fully and guest execution
 * may resume.  Otherwise they set the kvm_run parameter to indicate what needs
 * to be done to userspace and return 0.
 */
static int (*kvm_vmx_exit_handlers[])(struct kvm_vcpu *vcpu) = {
	[EXIT_REASON_EXCEPTION_NMI]           = handle_exception_nmi,
	[EXIT_REASON_EXTERNAL_INTERRUPT]      = handle_external_interrupt,
	[EXIT_REASON_TRIPLE_FAULT]            = handle_triple_fault,
	[EXIT_REASON_NMI_WINDOW]	      = handle_nmi_window,
	[EXIT_REASON_IO_INSTRUCTION]          = handle_io,
	[EXIT_REASON_CR_ACCESS]               = handle_cr,
	[EXIT_REASON_DR_ACCESS]               = handle_dr,
	[EXIT_REASON_CPUID]                   = kvm_emulate_cpuid,
	[EXIT_REASON_MSR_READ]                = kvm_emulate_rdmsr,
	[EXIT_REASON_MSR_WRITE]               = kvm_emulate_wrmsr,
	[EXIT_REASON_INTERRUPT_WINDOW]        = handle_interrupt_window,
	[EXIT_REASON_HLT]                     = kvm_emulate_halt,
	[EXIT_REASON_INVD]		      = kvm_emulate_invd,
	[EXIT_REASON_INVLPG]		      = handle_invlpg,
	[EXIT_REASON_RDPMC]                   = kvm_emulate_rdpmc,
	[EXIT_REASON_VMCALL]                  = kvm_emulate_hypercall,
	[EXIT_REASON_VMCLEAR]		      = handle_vmx_instruction,
	[EXIT_REASON_VMLAUNCH]		      = handle_vmx_instruction,
	[EXIT_REASON_VMPTRLD]		      = handle_vmx_instruction,
	[EXIT_REASON_VMPTRST]		      = handle_vmx_instruction,
	[EXIT_REASON_VMREAD]		      = handle_vmx_instruction,
	[EXIT_REASON_VMRESUME]		      = handle_vmx_instruction,
	[EXIT_REASON_VMWRITE]		      = handle_vmx_instruction,
	[EXIT_REASON_VMOFF]		      = handle_vmx_instruction,
	[EXIT_REASON_VMON]		      = handle_vmx_instruction,
	[EXIT_REASON_TPR_BELOW_THRESHOLD]     = handle_tpr_below_threshold,
	[EXIT_REASON_APIC_ACCESS]             = handle_apic_access,
	[EXIT_REASON_APIC_WRITE]              = handle_apic_write,
	[EXIT_REASON_EOI_INDUCED]             = handle_apic_eoi_induced,
	[EXIT_REASON_WBINVD]                  = kvm_emulate_wbinvd,
	[EXIT_REASON_XSETBV]                  = kvm_emulate_xsetbv,
	[EXIT_REASON_TASK_SWITCH]             = handle_task_switch,
	[EXIT_REASON_MCE_DURING_VMENTRY]      = handle_machine_check,
	[EXIT_REASON_GDTR_IDTR]		      = handle_desc,
	[EXIT_REASON_LDTR_TR]		      = handle_desc,
	[EXIT_REASON_EPT_VIOLATION]	      = handle_ept_violation,
	[EXIT_REASON_EPT_MISCONFIG]           = handle_ept_misconfig,
	[EXIT_REASON_PAUSE_INSTRUCTION]       = handle_pause,
	[EXIT_REASON_MWAIT_INSTRUCTION]	      = kvm_emulate_mwait,
	[EXIT_REASON_MONITOR_TRAP_FLAG]       = handle_monitor_trap,
	[EXIT_REASON_MONITOR_INSTRUCTION]     = kvm_emulate_monitor,
	[EXIT_REASON_INVEPT]                  = handle_vmx_instruction,
	[EXIT_REASON_INVVPID]                 = handle_vmx_instruction,
	[EXIT_REASON_RDRAND]                  = kvm_handle_invalid_op,
	[EXIT_REASON_RDSEED]                  = kvm_handle_invalid_op,
	[EXIT_REASON_PML_FULL]		      = handle_pml_full,
	[EXIT_REASON_INVPCID]                 = handle_invpcid,
	[EXIT_REASON_VMFUNC]		      = handle_vmx_instruction,
	[EXIT_REASON_PREEMPTION_TIMER]	      = handle_preemption_timer,
	[EXIT_REASON_ENCLS]		      = handle_encls,
	[EXIT_REASON_BUS_LOCK]                = handle_bus_lock_vmexit,
	[EXIT_REASON_NOTIFY]		      = handle_notify,
};

static const int kvm_vmx_max_exit_handlers =
	ARRAY_SIZE(kvm_vmx_exit_handlers);

<blue>static void vmx_get_exit_info(struct kvm_vcpu *vcpu, u32 *reason,</blue>
			      u64 *info1, u64 *info2,
			      u32 *intr_info, u32 *error_code)
<yellow>{</yellow>
	struct vcpu_vmx *vmx = to_vmx(vcpu);

<blue>	*reason = vmx->exit_reason.full;</blue>
<yellow>	*info1 = vmx_get_exit_qual(vcpu);</yellow>
<yellow>	if (!(vmx->exit_reason.failed_vmentry)) {</yellow>
<blue>		*info2 = vmx->idt_vectoring_info;</blue>
<yellow>		*intr_info = vmx_get_intr_info(vcpu);</yellow>
<yellow>		if (is_exception_with_error_code(*intr_info))</yellow>
<yellow>			*error_code = vmcs_read32(VM_EXIT_INTR_ERROR_CODE);</yellow>
		else
<blue>			*error_code = 0;</blue>
	} else {
<yellow>		*info2 = 0;</yellow>
<yellow>		*intr_info = 0;</yellow>
		*error_code = 0;
	}
}

static void vmx_destroy_pml_buffer(struct vcpu_vmx *vmx)
{
<yellow>	if (vmx->pml_pg) {</yellow>
<yellow>		__free_page(vmx->pml_pg);</yellow>
		vmx-&gt;pml_pg = NULL;
	}
}

static void vmx_flush_pml_buffer(struct kvm_vcpu *vcpu)
{
	struct vcpu_vmx *vmx = to_vmx(vcpu);
	u64 *pml_buf;
	u16 pml_idx;

<yellow>	pml_idx = vmcs_read16(GUEST_PML_INDEX);</yellow>

	/* Do nothing if PML buffer is empty */
<yellow>	if (pml_idx == (PML_ENTITY_NUM - 1))</yellow>
		return;

	/* PML index always points to next available PML buffer entity */
<yellow>	if (pml_idx >= PML_ENTITY_NUM)</yellow>
		pml_idx = 0;
	else
<yellow>		pml_idx++;</yellow>

<yellow>	pml_buf = page_address(vmx->pml_pg);</yellow>
	for (; pml_idx &lt; PML_ENTITY_NUM; pml_idx++) {
		u64 gpa;

<yellow>		gpa = pml_buf[pml_idx];</yellow>
<yellow>		WARN_ON(gpa & (PAGE_SIZE - 1));</yellow>
<yellow>		kvm_vcpu_mark_page_dirty(vcpu, gpa >> PAGE_SHIFT);</yellow>
	}

	/* reset PML index */
<yellow>	vmcs_write16(GUEST_PML_INDEX, PML_ENTITY_NUM - 1);</yellow>
}

static void vmx_dump_sel(char *name, uint32_t sel)
{
	pr_err(&quot;%s sel=0x%04x, attr=0x%05x, limit=0x%08x, base=0x%016lx\n&quot;,
	       name, vmcs_read16(sel),
	       vmcs_read32(sel + GUEST_ES_AR_BYTES - GUEST_ES_SELECTOR),
	       vmcs_read32(sel + GUEST_ES_LIMIT - GUEST_ES_SELECTOR),
	       vmcs_readl(sel + GUEST_ES_BASE - GUEST_ES_SELECTOR));
}

static void vmx_dump_dtsel(char *name, uint32_t limit)
{
	pr_err(&quot;%s                           limit=0x%08x, base=0x%016lx\n&quot;,
	       name, vmcs_read32(limit),
	       vmcs_readl(limit + GUEST_GDTR_BASE - GUEST_GDTR_LIMIT));
}

static void vmx_dump_msrs(char *name, struct vmx_msrs *m)
{
	unsigned int i;
	struct vmx_msr_entry *e;

	pr_err(&quot;MSR %s:\n&quot;, name);
	for (i = 0, e = m-&gt;val; i &lt; m-&gt;nr; ++i, ++e)
		pr_err(&quot;  %2d: msr=0x%08x value=0x%016llx\n&quot;, i, e-&gt;index, e-&gt;value);
}

void dump_vmcs(struct kvm_vcpu *vcpu)
{
	struct vcpu_vmx *vmx = to_vmx(vcpu);
	u32 vmentry_ctl, vmexit_ctl;
	u32 cpu_based_exec_ctrl, pin_based_exec_ctrl, secondary_exec_control;
	u64 tertiary_exec_control;
	unsigned long cr4;
	int efer_slot;

<blue>	if (!dump_invalid_vmcs) {</blue>
<yellow>		pr_warn_ratelimited("set kvm_intel.dump_invalid_vmcs=1 to dump internal KVM state.\n");</yellow>
		return;
	}

<blue>	vmentry_ctl = vmcs_read32(VM_ENTRY_CONTROLS);</blue>
<blue>	vmexit_ctl = vmcs_read32(VM_EXIT_CONTROLS);</blue>
<blue>	cpu_based_exec_ctrl = vmcs_read32(CPU_BASED_VM_EXEC_CONTROL);</blue>
<blue>	pin_based_exec_ctrl = vmcs_read32(PIN_BASED_VM_EXEC_CONTROL);</blue>
<blue>	cr4 = vmcs_readl(GUEST_CR4);</blue>

<blue>	if (cpu_has_secondary_exec_ctrls())</blue>
<blue>		secondary_exec_control = vmcs_read32(SECONDARY_VM_EXEC_CONTROL);</blue>
	else
		secondary_exec_control = 0;

<blue>	if (cpu_has_tertiary_exec_ctrls())</blue>
<blue>		tertiary_exec_control = vmcs_read64(TERTIARY_VM_EXEC_CONTROL);</blue>
	else
		tertiary_exec_control = 0;

<blue>	pr_err("VMCS %p, last attempted VM-entry on CPU %d\n",</blue>
	       vmx-&gt;loaded_vmcs-&gt;vmcs, vcpu-&gt;arch.last_vmentry_cpu);
	pr_err(&quot;*** Guest State ***\n&quot;);
	pr_err(&quot;CR0: actual=0x%016lx, shadow=0x%016lx, gh_mask=%016lx\n&quot;,
	       vmcs_readl(GUEST_CR0), vmcs_readl(CR0_READ_SHADOW),
	       vmcs_readl(CR0_GUEST_HOST_MASK));
	pr_err(&quot;CR4: actual=0x%016lx, shadow=0x%016lx, gh_mask=%016lx\n&quot;,
	       cr4, vmcs_readl(CR4_READ_SHADOW), vmcs_readl(CR4_GUEST_HOST_MASK));
	pr_err(&quot;CR3 = 0x%016lx\n&quot;, vmcs_readl(GUEST_CR3));
	if (cpu_has_vmx_ept()) {
		pr_err(&quot;PDPTR0 = 0x%016llx  PDPTR1 = 0x%016llx\n&quot;,
		       vmcs_read64(GUEST_PDPTR0), vmcs_read64(GUEST_PDPTR1));
		pr_err(&quot;PDPTR2 = 0x%016llx  PDPTR3 = 0x%016llx\n&quot;,
		       vmcs_read64(GUEST_PDPTR2), vmcs_read64(GUEST_PDPTR3));
	}
	pr_err(&quot;RSP = 0x%016lx  RIP = 0x%016lx\n&quot;,
	       vmcs_readl(GUEST_RSP), vmcs_readl(GUEST_RIP));
	pr_err(&quot;RFLAGS=0x%08lx         DR7 = 0x%016lx\n&quot;,
	       vmcs_readl(GUEST_RFLAGS), vmcs_readl(GUEST_DR7));
	pr_err(&quot;Sysenter RSP=%016lx CS:RIP=%04x:%016lx\n&quot;,
	       vmcs_readl(GUEST_SYSENTER_ESP),
	       vmcs_read32(GUEST_SYSENTER_CS), vmcs_readl(GUEST_SYSENTER_EIP));
	vmx_dump_sel(&quot;CS:  &quot;, GUEST_CS_SELECTOR);
	vmx_dump_sel(&quot;DS:  &quot;, GUEST_DS_SELECTOR);
	vmx_dump_sel(&quot;SS:  &quot;, GUEST_SS_SELECTOR);
	vmx_dump_sel(&quot;ES:  &quot;, GUEST_ES_SELECTOR);
	vmx_dump_sel(&quot;FS:  &quot;, GUEST_FS_SELECTOR);
	vmx_dump_sel(&quot;GS:  &quot;, GUEST_GS_SELECTOR);
	vmx_dump_dtsel(&quot;GDTR:&quot;, GUEST_GDTR_LIMIT);
	vmx_dump_sel(&quot;LDTR:&quot;, GUEST_LDTR_SELECTOR);
	vmx_dump_dtsel(&quot;IDTR:&quot;, GUEST_IDTR_LIMIT);
	vmx_dump_sel(&quot;TR:  &quot;, GUEST_TR_SELECTOR);
	efer_slot = vmx_find_loadstore_msr_slot(&amp;vmx-&gt;msr_autoload.guest, MSR_EFER);
	if (vmentry_ctl &amp; VM_ENTRY_LOAD_IA32_EFER)
		pr_err(&quot;EFER= 0x%016llx\n&quot;, vmcs_read64(GUEST_IA32_EFER));
	else if (efer_slot &gt;= 0)
		pr_err(&quot;EFER= 0x%016llx (autoload)\n&quot;,
		       vmx-&gt;msr_autoload.guest.val[efer_slot].value);
	else if (vmentry_ctl &amp; VM_ENTRY_IA32E_MODE)
		pr_err(&quot;EFER= 0x%016llx (effective)\n&quot;,
		       vcpu-&gt;arch.efer | (EFER_LMA | EFER_LME));
	else
		pr_err(&quot;EFER= 0x%016llx (effective)\n&quot;,
		       vcpu-&gt;arch.efer &amp; ~(EFER_LMA | EFER_LME));
	if (vmentry_ctl &amp; VM_ENTRY_LOAD_IA32_PAT)
		pr_err(&quot;PAT = 0x%016llx\n&quot;, vmcs_read64(GUEST_IA32_PAT));
	pr_err(&quot;DebugCtl = 0x%016llx  DebugExceptions = 0x%016lx\n&quot;,
	       vmcs_read64(GUEST_IA32_DEBUGCTL),
	       vmcs_readl(GUEST_PENDING_DBG_EXCEPTIONS));
	if (cpu_has_load_perf_global_ctrl() &amp;&amp;
	    vmentry_ctl &amp; VM_ENTRY_LOAD_IA32_PERF_GLOBAL_CTRL)
		pr_err(&quot;PerfGlobCtl = 0x%016llx\n&quot;,
		       vmcs_read64(GUEST_IA32_PERF_GLOBAL_CTRL));
	if (vmentry_ctl &amp; VM_ENTRY_LOAD_BNDCFGS)
		pr_err(&quot;BndCfgS = 0x%016llx\n&quot;, vmcs_read64(GUEST_BNDCFGS));
	pr_err(&quot;Interruptibility = %08x  ActivityState = %08x\n&quot;,
	       vmcs_read32(GUEST_INTERRUPTIBILITY_INFO),
	       vmcs_read32(GUEST_ACTIVITY_STATE));
	if (secondary_exec_control &amp; SECONDARY_EXEC_VIRTUAL_INTR_DELIVERY)
		pr_err(&quot;InterruptStatus = %04x\n&quot;,
		       vmcs_read16(GUEST_INTR_STATUS));
	if (vmcs_read32(VM_ENTRY_MSR_LOAD_COUNT) &gt; 0)
		vmx_dump_msrs(&quot;guest autoload&quot;, &amp;vmx-&gt;msr_autoload.guest);
	if (vmcs_read32(VM_EXIT_MSR_STORE_COUNT) &gt; 0)
		vmx_dump_msrs(&quot;guest autostore&quot;, &amp;vmx-&gt;msr_autostore.guest);

	pr_err(&quot;*** Host State ***\n&quot;);
	pr_err(&quot;RIP = 0x%016lx  RSP = 0x%016lx\n&quot;,
	       vmcs_readl(HOST_RIP), vmcs_readl(HOST_RSP));
	pr_err(&quot;CS=%04x SS=%04x DS=%04x ES=%04x FS=%04x GS=%04x TR=%04x\n&quot;,
	       vmcs_read16(HOST_CS_SELECTOR), vmcs_read16(HOST_SS_SELECTOR),
	       vmcs_read16(HOST_DS_SELECTOR), vmcs_read16(HOST_ES_SELECTOR),
	       vmcs_read16(HOST_FS_SELECTOR), vmcs_read16(HOST_GS_SELECTOR),
	       vmcs_read16(HOST_TR_SELECTOR));
	pr_err(&quot;FSBase=%016lx GSBase=%016lx TRBase=%016lx\n&quot;,
	       vmcs_readl(HOST_FS_BASE), vmcs_readl(HOST_GS_BASE),
	       vmcs_readl(HOST_TR_BASE));
	pr_err(&quot;GDTBase=%016lx IDTBase=%016lx\n&quot;,
	       vmcs_readl(HOST_GDTR_BASE), vmcs_readl(HOST_IDTR_BASE));
	pr_err(&quot;CR0=%016lx CR3=%016lx CR4=%016lx\n&quot;,
	       vmcs_readl(HOST_CR0), vmcs_readl(HOST_CR3),
	       vmcs_readl(HOST_CR4));
	pr_err(&quot;Sysenter RSP=%016lx CS:RIP=%04x:%016lx\n&quot;,
	       vmcs_readl(HOST_IA32_SYSENTER_ESP),
	       vmcs_read32(HOST_IA32_SYSENTER_CS),
	       vmcs_readl(HOST_IA32_SYSENTER_EIP));
	if (vmexit_ctl &amp; VM_EXIT_LOAD_IA32_EFER)
		pr_err(&quot;EFER= 0x%016llx\n&quot;, vmcs_read64(HOST_IA32_EFER));
	if (vmexit_ctl &amp; VM_EXIT_LOAD_IA32_PAT)
		pr_err(&quot;PAT = 0x%016llx\n&quot;, vmcs_read64(HOST_IA32_PAT));
	if (cpu_has_load_perf_global_ctrl() &amp;&amp;
	    vmexit_ctl &amp; VM_EXIT_LOAD_IA32_PERF_GLOBAL_CTRL)
		pr_err(&quot;PerfGlobCtl = 0x%016llx\n&quot;,
		       vmcs_read64(HOST_IA32_PERF_GLOBAL_CTRL));
	if (vmcs_read32(VM_EXIT_MSR_LOAD_COUNT) &gt; 0)
		vmx_dump_msrs(&quot;host autoload&quot;, &amp;vmx-&gt;msr_autoload.host);

	pr_err(&quot;*** Control State ***\n&quot;);
	pr_err(&quot;CPUBased=0x%08x SecondaryExec=0x%08x TertiaryExec=0x%016llx\n&quot;,
	       cpu_based_exec_ctrl, secondary_exec_control, tertiary_exec_control);
	pr_err(&quot;PinBased=0x%08x EntryControls=%08x ExitControls=%08x\n&quot;,
	       pin_based_exec_ctrl, vmentry_ctl, vmexit_ctl);
	pr_err(&quot;ExceptionBitmap=%08x PFECmask=%08x PFECmatch=%08x\n&quot;,
	       vmcs_read32(EXCEPTION_BITMAP),
	       vmcs_read32(PAGE_FAULT_ERROR_CODE_MASK),
	       vmcs_read32(PAGE_FAULT_ERROR_CODE_MATCH));
	pr_err(&quot;VMEntry: intr_info=%08x errcode=%08x ilen=%08x\n&quot;,
	       vmcs_read32(VM_ENTRY_INTR_INFO_FIELD),
	       vmcs_read32(VM_ENTRY_EXCEPTION_ERROR_CODE),
	       vmcs_read32(VM_ENTRY_INSTRUCTION_LEN));
	pr_err(&quot;VMExit: intr_info=%08x errcode=%08x ilen=%08x\n&quot;,
	       vmcs_read32(VM_EXIT_INTR_INFO),
	       vmcs_read32(VM_EXIT_INTR_ERROR_CODE),
	       vmcs_read32(VM_EXIT_INSTRUCTION_LEN));
	pr_err(&quot;        reason=%08x qualification=%016lx\n&quot;,
	       vmcs_read32(VM_EXIT_REASON), vmcs_readl(EXIT_QUALIFICATION));
	pr_err(&quot;IDTVectoring: info=%08x errcode=%08x\n&quot;,
	       vmcs_read32(IDT_VECTORING_INFO_FIELD),
	       vmcs_read32(IDT_VECTORING_ERROR_CODE));
	pr_err(&quot;TSC Offset = 0x%016llx\n&quot;, vmcs_read64(TSC_OFFSET));
	if (secondary_exec_control &amp; SECONDARY_EXEC_TSC_SCALING)
		pr_err(&quot;TSC Multiplier = 0x%016llx\n&quot;,
		       vmcs_read64(TSC_MULTIPLIER));
	if (cpu_based_exec_ctrl &amp; CPU_BASED_TPR_SHADOW) {
		if (secondary_exec_control &amp; SECONDARY_EXEC_VIRTUAL_INTR_DELIVERY) {
			u16 status = vmcs_read16(GUEST_INTR_STATUS);
			pr_err(&quot;SVI|RVI = %02x|%02x &quot;, status &gt;&gt; 8, status &amp; 0xff);
		}
		pr_cont(&quot;TPR Threshold = 0x%02x\n&quot;, vmcs_read32(TPR_THRESHOLD));
		if (secondary_exec_control &amp; SECONDARY_EXEC_VIRTUALIZE_APIC_ACCESSES)
			pr_err(&quot;APIC-access addr = 0x%016llx &quot;, vmcs_read64(APIC_ACCESS_ADDR));
		pr_cont(&quot;virt-APIC addr = 0x%016llx\n&quot;, vmcs_read64(VIRTUAL_APIC_PAGE_ADDR));
	}
	if (pin_based_exec_ctrl &amp; PIN_BASED_POSTED_INTR)
		pr_err(&quot;PostedIntrVec = 0x%02x\n&quot;, vmcs_read16(POSTED_INTR_NV));
	if ((secondary_exec_control &amp; SECONDARY_EXEC_ENABLE_EPT))
		pr_err(&quot;EPT pointer = 0x%016llx\n&quot;, vmcs_read64(EPT_POINTER));
	if (secondary_exec_control &amp; SECONDARY_EXEC_PAUSE_LOOP_EXITING)
		pr_err(&quot;PLE Gap=%08x Window=%08x\n&quot;,
		       vmcs_read32(PLE_GAP), vmcs_read32(PLE_WINDOW));
	if (secondary_exec_control &amp; SECONDARY_EXEC_ENABLE_VPID)
		pr_err(&quot;Virtual processor ID = 0x%04x\n&quot;,
		       vmcs_read16(VIRTUAL_PROCESSOR_ID));
<blue>}</blue>

/*
 * The guest has exited.  See if we can fix it or if we need userspace
 * assistance.
 */
static int __vmx_handle_exit(struct kvm_vcpu *vcpu, fastpath_t exit_fastpath)
{
	struct vcpu_vmx *vmx = to_vmx(vcpu);
<blue>	union vmx_exit_reason exit_reason = vmx->exit_reason;</blue>
	u32 vectoring_info = vmx-&gt;idt_vectoring_info;
	u16 exit_handler_index;

	/*
	 * Flush logged GPAs PML buffer, this will make dirty_bitmap more
	 * updated. Another good is, in kvm_vm_ioctl_get_dirty_log, before
	 * querying dirty_bitmap, we only need to kick all vcpus out of guest
	 * mode as if vcpus is in root mode, the PML buffer must has been
	 * flushed already.  Note, PML is never enabled in hardware while
	 * running L2.
	 */
<blue>	if (enable_pml && !is_guest_mode(vcpu))</blue>
<yellow>		vmx_flush_pml_buffer(vcpu);</yellow>

	/*
	 * KVM should never reach this point with a pending nested VM-Enter.
	 * More specifically, short-circuiting VM-Entry to emulate L2 due to
	 * invalid guest state should never happen as that means KVM knowingly
	 * allowed a nested VM-Enter with an invalid vmcs12.  More below.
	 */
<blue>	if (KVM_BUG_ON(vmx->nested.nested_run_pending, vcpu->kvm))</blue>
		return -EIO;

<blue>	if (is_guest_mode(vcpu)) {</blue>
		/*
		 * PML is never enabled when running L2, bail immediately if a
		 * PML full exit occurs as something is horribly wrong.
		 */
<blue>		if (exit_reason.basic == EXIT_REASON_PML_FULL)</blue>
			goto unexpected_vmexit;

		/*
		 * The host physical addresses of some pages of guest memory
		 * are loaded into the vmcs02 (e.g. vmcs12&#x27;s Virtual APIC
		 * Page). The CPU may write to these pages via their host
		 * physical address while L2 is running, bypassing any
		 * address-translation-based dirty tracking (e.g. EPT write
		 * protection).
		 *
		 * Mark them dirty on every exit from L2 to prevent them from
		 * getting out of sync with dirty tracking.
		 */
		nested_mark_vmcs12_pages_dirty(vcpu);

		/*
		 * Synthesize a triple fault if L2 state is invalid.  In normal
		 * operation, nested VM-Enter rejects any attempt to enter L2
		 * with invalid state.  However, those checks are skipped if
		 * state is being stuffed via RSM or KVM_SET_NESTED_STATE.  If
		 * L2 state is invalid, it means either L1 modified SMRAM state
		 * or userspace provided bad state.  Synthesize TRIPLE_FAULT as
		 * doing so is architecturally allowed in the RSM case, and is
		 * the least awful solution for the userspace case without
		 * risking false positives.
		 */
<blue>		if (vmx->emulation_required) {</blue>
<yellow>			nested_vmx_vmexit(vcpu, EXIT_REASON_TRIPLE_FAULT, 0, 0);</yellow>
			return 1;
		}

<blue>		if (nested_vmx_reflect_vmexit(vcpu))</blue>
			return 1;
	}

	/* If guest state is invalid, start emulating.  L2 is handled above. */
<blue>	if (vmx->emulation_required)</blue>
<yellow>		return handle_invalid_guest_state(vcpu);</yellow>

<blue>	if (exit_reason.failed_vmentry) {</blue>
		dump_vmcs(vcpu);
<blue>		vcpu->run->exit_reason = KVM_EXIT_FAIL_ENTRY;</blue>
		vcpu-&gt;run-&gt;fail_entry.hardware_entry_failure_reason
			= exit_reason.full;
		vcpu-&gt;run-&gt;fail_entry.cpu = vcpu-&gt;arch.last_vmentry_cpu;
		return 0;
	}

<blue>	if (unlikely(vmx->fail)) {</blue>
		dump_vmcs(vcpu);
<yellow>		vcpu->run->exit_reason = KVM_EXIT_FAIL_ENTRY;</yellow>
<yellow>		vcpu->run->fail_entry.hardware_entry_failure_reason</yellow>
<yellow>			= vmcs_read32(VM_INSTRUCTION_ERROR);</yellow>
		vcpu-&gt;run-&gt;fail_entry.cpu = vcpu-&gt;arch.last_vmentry_cpu;
		return 0;
	}

	/*
	 * Note:
	 * Do not try to fix EXIT_REASON_EPT_MISCONFIG if it caused by
	 * delivery event since it indicates guest is accessing MMIO.
	 * The vm-exit can be triggered again after return to guest that
	 * will cause infinite loop.
	 */
<blue>	if ((vectoring_info & VECTORING_INFO_VALID_MASK) &&</blue>
	    (exit_reason.basic != EXIT_REASON_EXCEPTION_NMI &amp;&amp;
	     exit_reason.basic != EXIT_REASON_EPT_VIOLATION &amp;&amp;
	     exit_reason.basic != EXIT_REASON_PML_FULL &amp;&amp;
	     exit_reason.basic != EXIT_REASON_APIC_ACCESS &amp;&amp;
	     exit_reason.basic != EXIT_REASON_TASK_SWITCH &amp;&amp;
	     exit_reason.basic != EXIT_REASON_NOTIFY)) {
		int ndata = 3;

<blue>		vcpu->run->exit_reason = KVM_EXIT_INTERNAL_ERROR;</blue>
		vcpu-&gt;run-&gt;internal.suberror = KVM_INTERNAL_ERROR_DELIVERY_EV;
		vcpu-&gt;run-&gt;internal.data[0] = vectoring_info;
		vcpu-&gt;run-&gt;internal.data[1] = exit_reason.full;
		vcpu-&gt;run-&gt;internal.data[2] = vcpu-&gt;arch.exit_qualification;
		if (exit_reason.basic == EXIT_REASON_EPT_MISCONFIG) {
<blue>			vcpu->run->internal.data[ndata++] =</blue>
<blue>				vmcs_read64(GUEST_PHYSICAL_ADDRESS);</blue>
		}
<blue>		vcpu->run->internal.data[ndata++] = vcpu->arch.last_vmentry_cpu;</blue>
		vcpu-&gt;run-&gt;internal.ndata = ndata;
		return 0;
	}

<blue>	if (unlikely(!enable_vnmi &&</blue>
		     vmx-&gt;loaded_vmcs-&gt;soft_vnmi_blocked)) {
<yellow>		if (!vmx_interrupt_blocked(vcpu)) {</yellow>
<yellow>			vmx->loaded_vmcs->soft_vnmi_blocked = 0;</yellow>
<yellow>		} else if (vmx->loaded_vmcs->vnmi_blocked_time > 1000000000LL &&</yellow>
<yellow>			   vcpu->arch.nmi_pending) {</yellow>
			/*
			 * This CPU don&#x27;t support us in finding the end of an
			 * NMI-blocked window if the guest runs with IRQs
			 * disabled. So we pull the trigger after 1 s of
			 * futile waiting, but inform the user about this.
			 */
			printk(KERN_WARNING &quot;%s: Breaking out of NMI-blocked &quot;
			       &quot;state on VCPU %d after 1 s timeout\n&quot;,
			       __func__, vcpu-&gt;vcpu_id);
			vmx-&gt;loaded_vmcs-&gt;soft_vnmi_blocked = 0;
		}
	}

<blue>	if (exit_fastpath != EXIT_FASTPATH_NONE)</blue>
		return 1;

<blue>	if (exit_reason.basic >= kvm_vmx_max_exit_handlers)</blue>
		goto unexpected_vmexit;
#ifdef CONFIG_RETPOLINE
<blue>	if (exit_reason.basic == EXIT_REASON_MSR_WRITE)</blue>
<blue>		return kvm_emulate_wrmsr(vcpu);</blue>
<blue>	else if (exit_reason.basic == EXIT_REASON_PREEMPTION_TIMER)</blue>
<blue>		return handle_preemption_timer(vcpu);</blue>
<blue>	else if (exit_reason.basic == EXIT_REASON_INTERRUPT_WINDOW)</blue>
<blue>		return handle_interrupt_window(vcpu);</blue>
<blue>	else if (exit_reason.basic == EXIT_REASON_EXTERNAL_INTERRUPT)</blue>
<blue>		return handle_external_interrupt(vcpu);</blue>
<blue>	else if (exit_reason.basic == EXIT_REASON_HLT)</blue>
<blue>		return kvm_emulate_halt(vcpu);</blue>
<blue>	else if (exit_reason.basic == EXIT_REASON_EPT_MISCONFIG)</blue>
<blue>		return handle_ept_misconfig(vcpu);</blue>
#endif

<blue>	exit_handler_index = array_index_nospec((u16)exit_reason.basic,</blue>
						kvm_vmx_max_exit_handlers);
	if (!kvm_vmx_exit_handlers[exit_handler_index])
		goto unexpected_vmexit;

<blue>	return kvm_vmx_exit_handlers[exit_handler_index](vcpu);</blue>

unexpected_vmexit:
<yellow>	vcpu_unimpl(vcpu, "vmx: unexpected exit reason 0x%x\n",</yellow>
		    exit_reason.full);
	dump_vmcs(vcpu);
<yellow>	vcpu->run->exit_reason = KVM_EXIT_INTERNAL_ERROR;</yellow>
	vcpu-&gt;run-&gt;internal.suberror =
			KVM_INTERNAL_ERROR_UNEXPECTED_EXIT_REASON;
	vcpu-&gt;run-&gt;internal.ndata = 2;
	vcpu-&gt;run-&gt;internal.data[0] = exit_reason.full;
	vcpu-&gt;run-&gt;internal.data[1] = vcpu-&gt;arch.last_vmentry_cpu;
	return 0;
}

static int vmx_handle_exit(struct kvm_vcpu *vcpu, fastpath_t exit_fastpath)
{
<blue>	int ret = __vmx_handle_exit(vcpu, exit_fastpath);</blue>

	/*
	 * Exit to user space when bus lock detected to inform that there is
	 * a bus lock in guest.
	 */
<blue>	if (to_vmx(vcpu)->exit_reason.bus_lock_detected) {</blue>
<yellow>		if (ret > 0)</yellow>
<yellow>			vcpu->run->exit_reason = KVM_EXIT_X86_BUS_LOCK;</yellow>

		vcpu-&gt;run-&gt;flags |= KVM_RUN_X86_BUS_LOCK;
		return 0;
	}
	return ret;
<blue>}</blue>

/*
 * Software based L1D cache flush which is used when microcode providing
 * the cache control MSR is not loaded.
 *
 * The L1D cache is 32 KiB on Nehalem and later microarchitectures, but to
 * flush it is required to read in 64 KiB because the replacement algorithm
 * is not exactly LRU. This could be sized at runtime via topology
 * information but as all relevant affected CPUs have 32KiB L1D cache size
 * there is no point in doing so.
 */
static noinstr void vmx_l1d_flush(struct kvm_vcpu *vcpu)
{
	int size = PAGE_SIZE &lt;&lt; L1D_CACHE_ORDER;

	/*
	 * This code is only executed when the flush mode is &#x27;cond&#x27; or
	 * &#x27;always&#x27;
	 */
	if (static_branch_likely(&amp;vmx_l1d_flush_cond)) {
		bool flush_l1d;

		/*
		 * Clear the per-vcpu flush bit, it gets set again
		 * either from vcpu_run() or from one of the unsafe
		 * VMEXIT handlers.
		 */
		flush_l1d = vcpu-&gt;arch.l1tf_flush_l1d;
		vcpu-&gt;arch.l1tf_flush_l1d = false;

		/*
		 * Clear the per-cpu flush bit, it gets set again from
		 * the interrupt handlers.
		 */
		flush_l1d |= kvm_get_cpu_l1tf_flush_l1d();
		kvm_clear_cpu_l1tf_flush_l1d();

		if (!flush_l1d)
			return;
	}

	vcpu-&gt;stat.l1d_flush++;

	if (static_cpu_has(X86_FEATURE_FLUSH_L1D)) {
		native_wrmsrl(MSR_IA32_FLUSH_CMD, L1D_FLUSH);
		return;
	}

	asm volatile(
		/* First ensure the pages are in the TLB */
		&quot;xorl	%%eax, %%eax\n&quot;
		&quot;.Lpopulate_tlb:\n\t&quot;
		&quot;movzbl	(%[flush_pages], %%&quot; _ASM_AX &quot;), %%ecx\n\t&quot;
		&quot;addl	$4096, %%eax\n\t&quot;
		&quot;cmpl	%%eax, %[size]\n\t&quot;
		&quot;jne	.Lpopulate_tlb\n\t&quot;
		&quot;xorl	%%eax, %%eax\n\t&quot;
		&quot;cpuid\n\t&quot;
		/* Now fill the cache */
		&quot;xorl	%%eax, %%eax\n&quot;
		&quot;.Lfill_cache:\n&quot;
		&quot;movzbl	(%[flush_pages], %%&quot; _ASM_AX &quot;), %%ecx\n\t&quot;
		&quot;addl	$64, %%eax\n\t&quot;
		&quot;cmpl	%%eax, %[size]\n\t&quot;
		&quot;jne	.Lfill_cache\n\t&quot;
		&quot;lfence\n&quot;
		:: [flush_pages] &quot;r&quot; (vmx_l1d_flush_pages),
		    [size] &quot;r&quot; (size)
		: &quot;eax&quot;, &quot;ebx&quot;, &quot;ecx&quot;, &quot;edx&quot;);
}

static void vmx_update_cr8_intercept(struct kvm_vcpu *vcpu, int tpr, int irr)
{
<yellow>	struct vmcs12 *vmcs12 = get_vmcs12(vcpu);</yellow>
	int tpr_threshold;

	if (is_guest_mode(vcpu) &amp;&amp;
<yellow>		nested_cpu_has(vmcs12, CPU_BASED_TPR_SHADOW))</yellow>
		return;

<yellow>	tpr_threshold = (irr == -1 || tpr < irr) ? 0 : irr;</yellow>
<yellow>	if (is_guest_mode(vcpu))</yellow>
<yellow>		to_vmx(vcpu)->nested.l1_tpr_threshold = tpr_threshold;</yellow>
	else
<yellow>		vmcs_write32(TPR_THRESHOLD, tpr_threshold);</yellow>
<yellow>}</yellow>

<yellow>void vmx_set_virtual_apic_mode(struct kvm_vcpu *vcpu)</yellow>
{
	struct vcpu_vmx *vmx = to_vmx(vcpu);
	u32 sec_exec_control;

<yellow>	if (!lapic_in_kernel(vcpu))</yellow>
		return;

<yellow>	if (!flexpriority_enabled &&</yellow>
<yellow>	    !cpu_has_vmx_virtualize_x2apic_mode())</yellow>
		return;

	/* Postpone execution until vmcs01 is the current VMCS. */
<yellow>	if (is_guest_mode(vcpu)) {</yellow>
<yellow>		vmx->nested.change_vmcs01_virtual_apic_mode = true;</yellow>
		return;
	}

<yellow>	sec_exec_control = secondary_exec_controls_get(vmx);</yellow>
	sec_exec_control &amp;= ~(SECONDARY_EXEC_VIRTUALIZE_APIC_ACCESSES |
			      SECONDARY_EXEC_VIRTUALIZE_X2APIC_MODE);

	switch (kvm_get_apic_mode(vcpu)) {
	case LAPIC_MODE_INVALID:
<yellow>		WARN_ONCE(true, "Invalid local APIC state");</yellow>
		break;
	case LAPIC_MODE_DISABLED:
		break;
	case LAPIC_MODE_XAPIC:
<yellow>		if (flexpriority_enabled) {</yellow>
<yellow>			sec_exec_control |=</yellow>
				SECONDARY_EXEC_VIRTUALIZE_APIC_ACCESSES;
			kvm_make_request(KVM_REQ_APIC_PAGE_RELOAD, vcpu);

			/*
			 * Flush the TLB, reloading the APIC access page will
			 * only do so if its physical address has changed, but
			 * the guest may have inserted a non-APIC mapping into
			 * the TLB while the APIC access page was disabled.
			 */
			kvm_make_request(KVM_REQ_TLB_FLUSH_CURRENT, vcpu);
		}
		break;
	case LAPIC_MODE_X2APIC:
<yellow>		if (cpu_has_vmx_virtualize_x2apic_mode())</yellow>
<yellow>			sec_exec_control |=</yellow>
				SECONDARY_EXEC_VIRTUALIZE_X2APIC_MODE;
		break;
	}
<yellow>	secondary_exec_controls_set(vmx, sec_exec_control);</yellow>

<yellow>	vmx_update_msr_bitmap_x2apic(vcpu);</yellow>
<yellow>}</yellow>

static void vmx_set_apic_access_page_addr(struct kvm_vcpu *vcpu)
{
	struct page *page;

	/* Defer reload until vmcs01 is the current VMCS. */
<blue>	if (is_guest_mode(vcpu)) {</blue>
<blue>		to_vmx(vcpu)->nested.reload_vmcs01_apic_access_page = true;</blue>
		return;
	}

<blue>	if (!(secondary_exec_controls_get(to_vmx(vcpu)) &</blue>
	    SECONDARY_EXEC_VIRTUALIZE_APIC_ACCESSES))
		return;

<blue>	page = gfn_to_page(vcpu->kvm, APIC_DEFAULT_PHYS_BASE >> PAGE_SHIFT);</blue>
	if (is_error_page(page))
		return;

<blue>	vmcs_write64(APIC_ACCESS_ADDR, page_to_phys(page));</blue>
<blue>	vmx_flush_tlb_current(vcpu);</blue>

	/*
	 * Do not pin apic access page in memory, the MMU notifier
	 * will call us again if it is migrated or swapped out.
	 */
	put_page(page);
<blue>}</blue>

static void vmx_hwapic_isr_update(int max_isr)
{
	u16 status;
	u8 old;

<blue>	if (max_isr == -1)</blue>
		max_isr = 0;

<blue>	status = vmcs_read16(GUEST_INTR_STATUS);</blue>
	old = status &gt;&gt; 8;
<blue>	if (max_isr != old) {</blue>
<yellow>		status &= 0xff;</yellow>
		status |= max_isr &lt;&lt; 8;
<yellow>		vmcs_write16(GUEST_INTR_STATUS, status);</yellow>
	}
<blue>}</blue>

static void vmx_set_rvi(int vector)
{
	u16 status;
	u8 old;

<blue>	if (vector == -1)</blue>
		vector = 0;

<blue>	status = vmcs_read16(GUEST_INTR_STATUS);</blue>
	old = (u8)status &amp; 0xff;
<blue>	if ((u8)vector != old) {</blue>
<yellow>		status &= ~0xff;</yellow>
		status |= (u8)vector;
<yellow>		vmcs_write16(GUEST_INTR_STATUS, status);</yellow>
	}
<blue>}</blue>

static void vmx_hwapic_irr_update(struct kvm_vcpu *vcpu, int max_irr)
{
	/*
	 * When running L2, updating RVI is only relevant when
	 * vmcs12 virtual-interrupt-delivery enabled.
	 * However, it can be enabled only when L1 also
	 * intercepts external-interrupts and in that case
	 * we should not update vmcs02 RVI but instead intercept
	 * interrupt. Therefore, do nothing when running L2.
	 */
<blue>	if (!is_guest_mode(vcpu))</blue>
<blue>		vmx_set_rvi(max_irr);</blue>
<blue>}</blue>

static int vmx_sync_pir_to_irr(struct kvm_vcpu *vcpu)
<blue>{</blue>
	struct vcpu_vmx *vmx = to_vmx(vcpu);
	int max_irr;
	bool got_posted_interrupt;

<blue>	if (KVM_BUG_ON(!enable_apicv, vcpu->kvm))</blue>
		return -EIO;

<blue>	if (pi_test_on(&vmx->pi_desc)) {</blue>
<yellow>		pi_clear_on(&vmx->pi_desc);</yellow>
		/*
		 * IOMMU can write to PID.ON, so the barrier matters even on UP.
		 * But on x86 this is just a compiler barrier anyway.
		 */
		smp_mb__after_atomic();
		got_posted_interrupt =
			kvm_apic_update_irr(vcpu, vmx-&gt;pi_desc.pir, &amp;max_irr);
	} else {
<blue>		max_irr = kvm_lapic_find_highest_irr(vcpu);</blue>
		got_posted_interrupt = false;
	}

	/*
	 * Newly recognized interrupts are injected via either virtual interrupt
	 * delivery (RVI) or KVM_REQ_EVENT.  Virtual interrupt delivery is
	 * disabled in two cases:
	 *
	 * 1) If L2 is running and the vCPU has a new pending interrupt.  If L1
	 * wants to exit on interrupts, KVM_REQ_EVENT is needed to synthesize a
	 * VM-Exit to L1.  If L1 doesn&#x27;t want to exit, the interrupt is injected
	 * into L2, but KVM doesn&#x27;t use virtual interrupt delivery to inject
	 * interrupts into L2, and so KVM_REQ_EVENT is again needed.
	 *
	 * 2) If APICv is disabled for this vCPU, assigned devices may still
	 * attempt to post interrupts.  The posted interrupt vector will cause
	 * a VM-Exit and the subsequent entry will call sync_pir_to_irr.
	 */
<blue>	if (!is_guest_mode(vcpu) && kvm_vcpu_apicv_active(vcpu))</blue>
<blue>		vmx_set_rvi(max_irr);</blue>
<yellow>	else if (got_posted_interrupt)</yellow>
<yellow>		kvm_make_request(KVM_REQ_EVENT, vcpu);</yellow>

<yellow>	return max_irr;</yellow>
}

static void vmx_load_eoi_exitmap(struct kvm_vcpu *vcpu, u64 *eoi_exit_bitmap)
{
<blue>	if (!kvm_vcpu_apicv_active(vcpu))</blue>
		return;

<blue>	vmcs_write64(EOI_EXIT_BITMAP0, eoi_exit_bitmap[0]);</blue>
<blue>	vmcs_write64(EOI_EXIT_BITMAP1, eoi_exit_bitmap[1]);</blue>
<blue>	vmcs_write64(EOI_EXIT_BITMAP2, eoi_exit_bitmap[2]);</blue>
<blue>	vmcs_write64(EOI_EXIT_BITMAP3, eoi_exit_bitmap[3]);</blue>
<blue>}</blue>

static void vmx_apicv_post_state_restore(struct kvm_vcpu *vcpu)
<yellow>{</yellow>
	struct vcpu_vmx *vmx = to_vmx(vcpu);

<blue>	pi_clear_on(&vmx->pi_desc);</blue>
<yellow>	memset(vmx->pi_desc.pir, 0, sizeof(vmx->pi_desc.pir));</yellow>
<yellow>}</yellow>

void vmx_do_interrupt_nmi_irqoff(unsigned long entry);

static void handle_interrupt_nmi_irqoff(struct kvm_vcpu *vcpu,
					unsigned long entry)
{
	bool is_nmi = entry == (unsigned long)asm_exc_nmi_noist;

<blue>	kvm_before_interrupt(vcpu, is_nmi ? KVM_HANDLING_NMI : KVM_HANDLING_IRQ);</blue>
<yellow>	vmx_do_interrupt_nmi_irqoff(entry);</yellow>
<yellow>	kvm_after_interrupt(vcpu);</yellow>
}

static void handle_nm_fault_irqoff(struct kvm_vcpu *vcpu)
{
	/*
	 * Save xfd_err to guest_fpu before interrupt is enabled, so the
	 * MSR value is not clobbered by the host activity before the guest
	 * has chance to consume it.
	 *
	 * Do not blindly read xfd_err here, since this exception might
	 * be caused by L1 interception on a platform which doesn&#x27;t
	 * support xfd at all.
	 *
	 * Do it conditionally upon guest_fpu::xfd. xfd_err matters
	 * only when xfd contains a non-zero value.
	 *
	 * Queuing exception is done in vmx_handle_exit. See comment there.
	 */
<blue>	if (vcpu->arch.guest_fpu.fpstate->xfd)</blue>
<yellow>		rdmsrl(MSR_IA32_XFD_ERR, vcpu->arch.guest_fpu.xfd_err);</yellow>
}

static void handle_exception_nmi_irqoff(struct vcpu_vmx *vmx)
{
	const unsigned long nmi_entry = (unsigned long)asm_exc_nmi_noist;
<blue>	u32 intr_info = vmx_get_intr_info(&vmx->vcpu);</blue>

	/* if exit due to PF check for async PF */
<yellow>	if (is_page_fault(intr_info))</yellow>
<blue>		vmx->vcpu.arch.apf.host_apf_flags = kvm_read_and_reset_apf_flags();</blue>
	/* if exit due to NM, handle before interrupts are enabled */
<blue>	else if (is_nm_fault(intr_info))</blue>
<blue>		handle_nm_fault_irqoff(&vmx->vcpu);</blue>
	/* Handle machine checks before interrupts are enabled */
<blue>	else if (is_machine_check(intr_info))</blue>
<yellow>		kvm_machine_check();</yellow>
	/* We need to handle NMIs before interrupts are enabled */
<blue>	else if (is_nmi(intr_info))</blue>
<blue>		handle_interrupt_nmi_irqoff(&vmx->vcpu, nmi_entry);</blue>
}

static void handle_external_interrupt_irqoff(struct kvm_vcpu *vcpu)
{
<blue>	u32 intr_info = vmx_get_intr_info(vcpu);</blue>
	unsigned int vector = intr_info &amp; INTR_INFO_VECTOR_MASK;
	gate_desc *desc = (gate_desc *)host_idt_base + vector;

<yellow>	if (KVM_BUG(!is_external_intr(intr_info), vcpu->kvm,</yellow>
	    &quot;KVM: unexpected VM-Exit interrupt info: 0x%x&quot;, intr_info))
		return;

<blue>	handle_interrupt_nmi_irqoff(vcpu, gate_offset(desc));</blue>
<yellow>	vcpu->arch.at_instruction_boundary = true;</yellow>
}

<blue>static void vmx_handle_exit_irqoff(struct kvm_vcpu *vcpu)</blue>
<yellow>{</yellow>
	struct vcpu_vmx *vmx = to_vmx(vcpu);

<blue>	if (vmx->emulation_required)</blue>
		return;

<blue>	if (vmx->exit_reason.basic == EXIT_REASON_EXTERNAL_INTERRUPT)</blue>
<blue>		handle_external_interrupt_irqoff(vcpu);</blue>
<blue>	else if (vmx->exit_reason.basic == EXIT_REASON_EXCEPTION_NMI)</blue>
<blue>		handle_exception_nmi_irqoff(vmx);</blue>
<blue>}</blue>

/*
 * The kvm parameter can be NULL (module initialization, or invocation before
 * VM creation). Be sure to check the kvm parameter before using it.
 */
<blue>static bool vmx_has_emulated_msr(struct kvm *kvm, u32 index)</blue>
<yellow>{</yellow>
<blue>	switch (index) {</blue>
	case MSR_IA32_SMBASE:
		/*
		 * We cannot do SMM unless we can run the guest in big
		 * real mode.
		 */
<blue>		return enable_unrestricted_guest || emulate_invalid_guest_state;</blue>
	case MSR_IA32_VMX_BASIC ... MSR_IA32_VMX_VMFUNC:
<yellow>		return nested;</yellow>
	case MSR_AMD64_VIRT_SPEC_CTRL:
	case MSR_AMD64_TSC_RATIO:
		/* This is AMD only.  */
		return false;
	default:
		return true;
	}
<blue>}</blue>

static void vmx_recover_nmi_blocking(struct vcpu_vmx *vmx)
{
	u32 exit_intr_info;
	bool unblock_nmi;
	u8 vector;
	bool idtv_info_valid;

	idtv_info_valid = vmx-&gt;idt_vectoring_info &amp; VECTORING_INFO_VALID_MASK;

	if (enable_vnmi) {
<blue>		if (vmx->loaded_vmcs->nmi_known_unmasked)</blue>
			return;

<blue>		exit_intr_info = vmx_get_intr_info(&vmx->vcpu);</blue>
<blue>		unblock_nmi = (exit_intr_info & INTR_INFO_UNBLOCK_NMI) != 0;</blue>
<blue>		vector = exit_intr_info & INTR_INFO_VECTOR_MASK;</blue>
		/*
		 * SDM 3: 27.7.1.2 (September 2008)
		 * Re-set bit &quot;block by NMI&quot; before VM entry if vmexit caused by
		 * a guest IRET fault.
		 * SDM 3: 23.2.2 (September 2008)
		 * Bit 12 is undefined in any of the following cases:
		 *  If the VM exit sets the valid bit in the IDT-vectoring
		 *   information field.
		 *  If the VM exit is due to a double fault.
		 */
		if ((exit_intr_info &amp; INTR_INFO_VALID_MASK) &amp;&amp; unblock_nmi &amp;&amp;
<blue>		    vector != DF_VECTOR && !idtv_info_valid)</blue>
<blue>			vmcs_set_bits(GUEST_INTERRUPTIBILITY_INFO,</blue>
				      GUEST_INTR_STATE_NMI);
		else
<blue>			vmx->loaded_vmcs->nmi_known_unmasked =</blue>
<blue>				!(vmcs_read32(GUEST_INTERRUPTIBILITY_INFO)</blue>
<blue>				  & GUEST_INTR_STATE_NMI);</blue>
<yellow>	} else if (unlikely(vmx->loaded_vmcs->soft_vnmi_blocked))</yellow>
		vmx-&gt;loaded_vmcs-&gt;vnmi_blocked_time +=
<yellow>			ktime_to_ns(ktime_sub(ktime_get(),</yellow>
					      vmx-&gt;loaded_vmcs-&gt;entry_time));
}

static void __vmx_complete_interrupts(struct kvm_vcpu *vcpu,
				      u32 idt_vectoring_info,
				      int instr_len_field,
				      int error_code_field)
{
	u8 vector;
	int type;
	bool idtv_info_valid;

	idtv_info_valid = idt_vectoring_info &amp; VECTORING_INFO_VALID_MASK;

<blue>	vcpu->arch.nmi_injected = false;</blue>
	kvm_clear_exception_queue(vcpu);
	kvm_clear_interrupt_queue(vcpu);

	if (!idtv_info_valid)
		return;

<blue>	kvm_make_request(KVM_REQ_EVENT, vcpu);</blue>

	vector = idt_vectoring_info &amp; VECTORING_INFO_VECTOR_MASK;
	type = idt_vectoring_info &amp; VECTORING_INFO_TYPE_MASK;

	switch (type) {
	case INTR_TYPE_NMI_INTR:
<blue>		vcpu->arch.nmi_injected = true;</blue>
		/*
		 * SDM 3: 27.7.1.2 (September 2008)
		 * Clear bit &quot;block by NMI&quot; before VM entry if a NMI
		 * delivery faulted.
		 */
<blue>		vmx_set_nmi_mask(vcpu, false);</blue>
		break;
	case INTR_TYPE_SOFT_EXCEPTION:
<blue>		vcpu->arch.event_exit_inst_len = vmcs_read32(instr_len_field);</blue>
		fallthrough;
	case INTR_TYPE_HARD_EXCEPTION:
<blue>		if (idt_vectoring_info & VECTORING_INFO_DELIVER_CODE_MASK) {</blue>
<blue>			u32 err = vmcs_read32(error_code_field);</blue>
<blue>			kvm_requeue_exception_e(vcpu, vector, err);</blue>
		} else
<blue>			kvm_requeue_exception(vcpu, vector);</blue>
		break;
	case INTR_TYPE_SOFT_INTR:
<blue>		vcpu->arch.event_exit_inst_len = vmcs_read32(instr_len_field);</blue>
		fallthrough;
	case INTR_TYPE_EXT_INTR:
<blue>		kvm_queue_interrupt(vcpu, vector, type == INTR_TYPE_SOFT_INTR);</blue>
		break;
	default:
		break;
	}
<blue>}</blue>

static void vmx_complete_interrupts(struct vcpu_vmx *vmx)
{
<blue>	__vmx_complete_interrupts(&vmx->vcpu, vmx->idt_vectoring_info,</blue>
				  VM_EXIT_INSTRUCTION_LEN,
				  IDT_VECTORING_ERROR_CODE);
}

static void vmx_cancel_injection(struct kvm_vcpu *vcpu)
{
<blue>	__vmx_complete_interrupts(vcpu,</blue>
				  vmcs_read32(VM_ENTRY_INTR_INFO_FIELD),
				  VM_ENTRY_INSTRUCTION_LEN,
				  VM_ENTRY_EXCEPTION_ERROR_CODE);

<blue>	vmcs_write32(VM_ENTRY_INTR_INFO_FIELD, 0);</blue>
<blue>}</blue>

static void atomic_switch_perf_msrs(struct vcpu_vmx *vmx)
{
	int i, nr_msrs;
	struct perf_guest_switch_msr *msrs;
	struct kvm_pmu *pmu = vcpu_to_pmu(&amp;vmx-&gt;vcpu);

<blue>	pmu->host_cross_mapped_mask = 0;</blue>
	if (pmu-&gt;pebs_enable &amp; pmu-&gt;global_ctrl)
<yellow>		intel_pmu_cross_mapped_check(pmu);</yellow>

	/* Note, nr_msrs may be garbage if perf_guest_get_msrs() returns NULL. */
<blue>	msrs = perf_guest_get_msrs(&nr_msrs, (void *)pmu);</blue>
	if (!msrs)
		return;

<blue>	for (i = 0; i < nr_msrs; i++)</blue>
<blue>		if (msrs[i].host == msrs[i].guest)</blue>
<blue>			clear_atomic_switch_msr(vmx, msrs[i].msr);</blue>
		else
<yellow>			add_atomic_switch_msr(vmx, msrs[i].msr, msrs[i].guest,</yellow>
					msrs[i].host, false);
}

static void vmx_update_hv_timer(struct kvm_vcpu *vcpu)
{
	struct vcpu_vmx *vmx = to_vmx(vcpu);
	u64 tscl;
	u32 delta_tsc;

<blue>	if (vmx->req_immediate_exit) {</blue>
<blue>		vmcs_write32(VMX_PREEMPTION_TIMER_VALUE, 0);</blue>
<blue>		vmx->loaded_vmcs->hv_timer_soft_disabled = false;</blue>
<blue>	} else if (vmx->hv_deadline_tsc != -1) {</blue>
<yellow>		tscl = rdtsc();</yellow>
		if (vmx-&gt;hv_deadline_tsc &gt; tscl)
			/* set_hv_timer ensures the delta fits in 32-bits */
<yellow>			delta_tsc = (u32)((vmx->hv_deadline_tsc - tscl) >></yellow>
				cpu_preemption_timer_multi);
		else
			delta_tsc = 0;

<yellow>		vmcs_write32(VMX_PREEMPTION_TIMER_VALUE, delta_tsc);</yellow>
<yellow>		vmx->loaded_vmcs->hv_timer_soft_disabled = false;</yellow>
<blue>	} else if (!vmx->loaded_vmcs->hv_timer_soft_disabled) {</blue>
<blue>		vmcs_write32(VMX_PREEMPTION_TIMER_VALUE, -1);</blue>
<blue>		vmx->loaded_vmcs->hv_timer_soft_disabled = true;</blue>
	}
}

void noinstr vmx_update_host_rsp(struct vcpu_vmx *vmx, unsigned long host_rsp)
{
	if (unlikely(host_rsp != vmx-&gt;loaded_vmcs-&gt;host_state.rsp)) {
		vmx-&gt;loaded_vmcs-&gt;host_state.rsp = host_rsp;
		vmcs_writel(HOST_RSP, host_rsp);
	}
}

void noinstr vmx_spec_ctrl_restore_host(struct vcpu_vmx *vmx,
					unsigned int flags)
{
	u64 hostval = this_cpu_read(x86_spec_ctrl_current);

	if (!cpu_feature_enabled(X86_FEATURE_MSR_SPEC_CTRL))
		return;

	if (flags &amp; VMX_RUN_SAVE_SPEC_CTRL)
		vmx-&gt;spec_ctrl = __rdmsr(MSR_IA32_SPEC_CTRL);

	/*
	 * If the guest/host SPEC_CTRL values differ, restore the host value.
	 *
	 * For legacy IBRS, the IBRS bit always needs to be written after
	 * transitioning from a less privileged predictor mode, regardless of
	 * whether the guest/host values differ.
	 */
	if (cpu_feature_enabled(X86_FEATURE_KERNEL_IBRS) ||
	    vmx-&gt;spec_ctrl != hostval)
		native_wrmsrl(MSR_IA32_SPEC_CTRL, hostval);

	barrier_nospec();
}

static fastpath_t vmx_exit_handlers_fastpath(struct kvm_vcpu *vcpu)
{
<blue>	switch (to_vmx(vcpu)->exit_reason.basic) {</blue>
	case EXIT_REASON_MSR_WRITE:
<blue>		return handle_fastpath_set_msr_irqoff(vcpu);</blue>
	case EXIT_REASON_PREEMPTION_TIMER:
<blue>		return handle_fastpath_preemption_timer(vcpu);</blue>
	default:
		return EXIT_FASTPATH_NONE;
	}
}

static noinstr void vmx_vcpu_enter_exit(struct kvm_vcpu *vcpu,
					struct vcpu_vmx *vmx,
					unsigned long flags)
{
	guest_state_enter_irqoff();

	/* L1D Flush includes CPU buffer clear to mitigate MDS */
	if (static_branch_unlikely(&amp;vmx_l1d_should_flush))
		vmx_l1d_flush(vcpu);
	else if (static_branch_unlikely(&amp;mds_user_clear))
		mds_clear_cpu_buffers();
	else if (static_branch_unlikely(&amp;mmio_stale_data_clear) &amp;&amp;
		 kvm_arch_has_assigned_device(vcpu-&gt;kvm))
		mds_clear_cpu_buffers();

	vmx_disable_fb_clear(vmx);

	if (vcpu-&gt;arch.cr2 != native_read_cr2())
		native_write_cr2(vcpu-&gt;arch.cr2);

	vmx-&gt;fail = __vmx_vcpu_run(vmx, (unsigned long *)&amp;vcpu-&gt;arch.regs,
				   flags);

	vcpu-&gt;arch.cr2 = native_read_cr2();

	vmx_enable_fb_clear(vmx);

	guest_state_exit_irqoff();
}

static fastpath_t vmx_vcpu_run(struct kvm_vcpu *vcpu)
<blue>{</blue>
	struct vcpu_vmx *vmx = to_vmx(vcpu);
	unsigned long cr3, cr4;

	/* Record the guest&#x27;s net vcpu time for enforced NMI injections. */
<blue>	if (unlikely(!enable_vnmi &&</blue>
		     vmx-&gt;loaded_vmcs-&gt;soft_vnmi_blocked))
<yellow>		vmx->loaded_vmcs->entry_time = ktime_get();</yellow>

	/*
	 * Don&#x27;t enter VMX if guest state is invalid, let the exit handler
	 * start emulation until we arrive back to a valid state.  Synthesize a
	 * consistency check VM-Exit due to invalid guest state and bail.
	 */
<blue>	if (unlikely(vmx->emulation_required)) {</blue>
<yellow>		vmx->fail = 0;</yellow>

		vmx-&gt;exit_reason.full = EXIT_REASON_INVALID_STATE;
		vmx-&gt;exit_reason.failed_vmentry = 1;
		kvm_register_mark_available(vcpu, VCPU_EXREG_EXIT_INFO_1);
		vmx-&gt;exit_qualification = ENTRY_FAIL_DEFAULT;
		kvm_register_mark_available(vcpu, VCPU_EXREG_EXIT_INFO_2);
		vmx-&gt;exit_intr_info = 0;
		return EXIT_FASTPATH_NONE;
	}

<blue>	trace_kvm_entry(vcpu);</blue>

<blue>	if (vmx->ple_window_dirty) {</blue>
<blue>		vmx->ple_window_dirty = false;</blue>
<blue>		vmcs_write32(PLE_WINDOW, vmx->ple_window);</blue>
	}

	/*
	 * We did this in prepare_switch_to_guest, because it needs to
	 * be within srcu_read_lock.
	 */
<blue>	WARN_ON_ONCE(vmx->nested.need_vmcs12_to_shadow_sync);</blue>

<blue>	if (kvm_register_is_dirty(vcpu, VCPU_REGS_RSP))</blue>
<blue>		vmcs_writel(GUEST_RSP, vcpu->arch.regs[VCPU_REGS_RSP]);</blue>
<blue>	if (kvm_register_is_dirty(vcpu, VCPU_REGS_RIP))</blue>
<blue>		vmcs_writel(GUEST_RIP, vcpu->arch.regs[VCPU_REGS_RIP]);</blue>
<blue>	vcpu->arch.regs_dirty = 0;</blue>

	/*
	 * Refresh vmcs.HOST_CR3 if necessary.  This must be done immediately
	 * prior to VM-Enter, as the kernel may load a new ASID (PCID) any time
	 * it switches back to the current-&gt;mm, which can occur in KVM context
	 * when switching to a temporary mm to patch kernel code, e.g. if KVM
	 * toggles a static key while handling a VM-Exit.
	 */
	cr3 = __get_current_cr3_fast();
	if (unlikely(cr3 != vmx-&gt;loaded_vmcs-&gt;host_state.cr3)) {
<blue>		vmcs_writel(HOST_CR3, cr3);</blue>
<blue>		vmx->loaded_vmcs->host_state.cr3 = cr3;</blue>
	}

<blue>	cr4 = cr4_read_shadow();</blue>
	if (unlikely(cr4 != vmx-&gt;loaded_vmcs-&gt;host_state.cr4)) {
<blue>		vmcs_writel(HOST_CR4, cr4);</blue>
<blue>		vmx->loaded_vmcs->host_state.cr4 = cr4;</blue>
	}

	/* When KVM_DEBUGREG_WONT_EXIT, dr6 is accessible in guest. */
<blue>	if (unlikely(vcpu->arch.switch_db_regs & KVM_DEBUGREG_WONT_EXIT))</blue>
<blue>		set_debugreg(vcpu->arch.dr6, 6);</blue>

	/* When single-stepping over STI and MOV SS, we must clear the
	 * corresponding interruptibility bits in the guest state. Otherwise
	 * vmentry fails as it then expects bit 14 (BS) in pending debug
	 * exceptions being set, but that&#x27;s not correct for the guest debugging
	 * case. */
<blue>	if (vcpu->guest_debug & KVM_GUESTDBG_SINGLESTEP)</blue>
<yellow>		vmx_set_interrupt_shadow(vcpu, 0);</yellow>

<blue>	kvm_load_guest_xsave_state(vcpu);</blue>

<yellow>	pt_guest_enter(vmx);</yellow>

<blue>	atomic_switch_perf_msrs(vmx);</blue>
<blue>	if (intel_pmu_lbr_is_enabled(vcpu))</blue>
<yellow>		vmx_passthrough_lbr_msrs(vcpu);</yellow>

<blue>	if (enable_preemption_timer)</blue>
<blue>		vmx_update_hv_timer(vcpu);</blue>

<blue>	kvm_wait_lapic_expire(vcpu);</blue>

	/* The actual VMENTER/EXIT is in the .noinstr.text section. */
	vmx_vcpu_enter_exit(vcpu, vmx, __vmx_vcpu_run_flags(vmx));

	/* All fields are clean at this point */
	if (static_branch_unlikely(&amp;enable_evmcs)) {
<yellow>		current_evmcs->hv_clean_fields |=</yellow>
			HV_VMX_ENLIGHTENED_CLEAN_FIELD_ALL;

<yellow>		current_evmcs->hv_vp_id = kvm_hv_get_vpindex(vcpu);</yellow>
	}

	/* MSR_IA32_DEBUGCTLMSR is zeroed on vmexit. Restore it if needed */
<blue>	if (vmx->host_debugctlmsr)</blue>
<blue>		update_debugctlmsr(vmx->host_debugctlmsr);</blue>

#ifndef CONFIG_X86_64
	/*
	 * The sysexit path does not restore ds/es, so we must set them to
	 * a reasonable value ourselves.
	 *
	 * We can&#x27;t defer this to vmx_prepare_switch_to_host() since that
	 * function may be executed in interrupt context, which saves and
	 * restore segments around it, nullifying its effect.
	 */
	loadsegment(ds, __USER_DS);
	loadsegment(es, __USER_DS);
#endif

<blue>	vcpu->arch.regs_avail &= ~VMX_REGS_LAZY_LOAD_SET;</blue>

<yellow>	pt_guest_exit(vmx);</yellow>

	kvm_load_host_xsave_state(vcpu);

<blue>	if (is_guest_mode(vcpu)) {</blue>
		/*
		 * Track VMLAUNCH/VMRESUME that have made past guest state
		 * checking.
		 */
<blue>		if (vmx->nested.nested_run_pending &&</blue>
<blue>		    !vmx->exit_reason.failed_vmentry)</blue>
<blue>			++vcpu->stat.nested_run;</blue>

<blue>		vmx->nested.nested_run_pending = 0;</blue>
	}

<blue>	vmx->idt_vectoring_info = 0;</blue>

	if (unlikely(vmx-&gt;fail)) {
<blue>		vmx->exit_reason.full = 0xdead;</blue>
		return EXIT_FASTPATH_NONE;
	}

<blue>	vmx->exit_reason.full = vmcs_read32(VM_EXIT_REASON);</blue>
	if (unlikely((u16)vmx-&gt;exit_reason.basic == EXIT_REASON_MCE_DURING_VMENTRY))
		kvm_machine_check();

<blue>	if (likely(!vmx->exit_reason.failed_vmentry))</blue>
<blue>		vmx->idt_vectoring_info = vmcs_read32(IDT_VECTORING_INFO_FIELD);</blue>

<blue>	trace_kvm_exit(vcpu, KVM_ISA_VMX);</blue>

<blue>	if (unlikely(vmx->exit_reason.failed_vmentry))</blue>
		return EXIT_FASTPATH_NONE;

<blue>	vmx->loaded_vmcs->launched = 1;</blue>

<blue>	vmx_recover_nmi_blocking(vmx);</blue>
<blue>	vmx_complete_interrupts(vmx);</blue>

	if (is_guest_mode(vcpu))
		return EXIT_FASTPATH_NONE;

<blue>	return vmx_exit_handlers_fastpath(vcpu);</blue>
}

static void vmx_vcpu_free(struct kvm_vcpu *vcpu)
{
	struct vcpu_vmx *vmx = to_vmx(vcpu);

<yellow>	if (enable_pml)</yellow>
<yellow>		vmx_destroy_pml_buffer(vmx);</yellow>
<yellow>	free_vpid(vmx->vpid);</yellow>
	nested_vmx_free_vcpu(vcpu);
<yellow>	free_loaded_vmcs(vmx->loaded_vmcs);</yellow>
<yellow>}</yellow>

static int vmx_vcpu_create(struct kvm_vcpu *vcpu)
<blue>{</blue>
	struct vmx_uret_msr *tsx_ctrl;
	struct vcpu_vmx *vmx;
	int i, err;

	BUILD_BUG_ON(offsetof(struct vcpu_vmx, vcpu) != 0);
	vmx = to_vmx(vcpu);

<blue>	INIT_LIST_HEAD(&vmx->pi_wakeup_list);</blue>

	err = -ENOMEM;

	vmx-&gt;vpid = allocate_vpid();

	/*
	 * If PML is turned on, failure on enabling PML just results in failure
	 * of creating the vcpu, therefore we can simplify PML logic (by
	 * avoiding dealing with cases, such as enabling PML partially on vcpus
	 * for the guest), etc.
	 */
<blue>	if (enable_pml) {</blue>
<yellow>		vmx->pml_pg = alloc_page(GFP_KERNEL_ACCOUNT | __GFP_ZERO);</yellow>
		if (!vmx-&gt;pml_pg)
			goto free_vpid;
	}

<blue>	for (i = 0; i < kvm_nr_uret_msrs; ++i)</blue>
<blue>		vmx->guest_uret_msrs[i].mask = -1ull;</blue>
<blue>	if (boot_cpu_has(X86_FEATURE_RTM)) {</blue>
		/*
		 * TSX_CTRL_CPUID_CLEAR is handled in the CPUID interception.
		 * Keep the host value unchanged to avoid changing CPUID bits
		 * under the host kernel&#x27;s feet.
		 */
<yellow>		tsx_ctrl = vmx_find_uret_msr(vmx, MSR_IA32_TSX_CTRL);</yellow>
		if (tsx_ctrl)
<yellow>			tsx_ctrl->mask = ~(u64)TSX_CTRL_CPUID_CLEAR;</yellow>
	}

<blue>	err = alloc_loaded_vmcs(&vmx->vmcs01);</blue>
	if (err &lt; 0)
		goto free_pml;

	/*
	 * Use Hyper-V &#x27;Enlightened MSR Bitmap&#x27; feature when KVM runs as a
	 * nested (L1) hypervisor and Hyper-V in L0 supports it. Enable the
	 * feature only for vmcs01, KVM currently isn&#x27;t equipped to realize any
	 * performance benefits from enabling it for vmcs02.
	 */
<blue>	if (IS_ENABLED(CONFIG_HYPERV) && static_branch_unlikely(&enable_evmcs) &&</blue>
<yellow>	    (ms_hyperv.nested_features & HV_X64_NESTED_MSR_BITMAP)) {</yellow>
<yellow>		struct hv_enlightened_vmcs *evmcs = (void *)vmx->vmcs01.vmcs;</yellow>

		evmcs-&gt;hv_enlightenments_control.msr_bitmap = 1;
	}

	/* The MSR bitmap starts with all ones */
<blue>	bitmap_fill(vmx->shadow_msr_intercept.read, MAX_POSSIBLE_PASSTHROUGH_MSRS);</blue>
	bitmap_fill(vmx-&gt;shadow_msr_intercept.write, MAX_POSSIBLE_PASSTHROUGH_MSRS);

	vmx_disable_intercept_for_msr(vcpu, MSR_IA32_TSC, MSR_TYPE_R);
#ifdef CONFIG_X86_64
	vmx_disable_intercept_for_msr(vcpu, MSR_FS_BASE, MSR_TYPE_RW);
	vmx_disable_intercept_for_msr(vcpu, MSR_GS_BASE, MSR_TYPE_RW);
	vmx_disable_intercept_for_msr(vcpu, MSR_KERNEL_GS_BASE, MSR_TYPE_RW);
#endif
	vmx_disable_intercept_for_msr(vcpu, MSR_IA32_SYSENTER_CS, MSR_TYPE_RW);
	vmx_disable_intercept_for_msr(vcpu, MSR_IA32_SYSENTER_ESP, MSR_TYPE_RW);
	vmx_disable_intercept_for_msr(vcpu, MSR_IA32_SYSENTER_EIP, MSR_TYPE_RW);
<blue>	if (kvm_cstate_in_guest(vcpu->kvm)) {</blue>
<yellow>		vmx_disable_intercept_for_msr(vcpu, MSR_CORE_C1_RES, MSR_TYPE_R);</yellow>
		vmx_disable_intercept_for_msr(vcpu, MSR_CORE_C3_RESIDENCY, MSR_TYPE_R);
		vmx_disable_intercept_for_msr(vcpu, MSR_CORE_C6_RESIDENCY, MSR_TYPE_R);
		vmx_disable_intercept_for_msr(vcpu, MSR_CORE_C7_RESIDENCY, MSR_TYPE_R);
	}

<blue>	vmx->loaded_vmcs = &vmx->vmcs01;</blue>

<blue>	if (cpu_need_virtualize_apic_accesses(vcpu)) {</blue>
<blue>		err = alloc_apic_access_page(vcpu->kvm);</blue>
		if (err)
			goto free_vmcs;
	}

<blue>	if (enable_ept && !enable_unrestricted_guest) {</blue>
<yellow>		err = init_rmode_identity_map(vcpu->kvm);</yellow>
		if (err)
			goto free_vmcs;
	}

<blue>	if (vmx_can_use_ipiv(vcpu))</blue>
<yellow>		WRITE_ONCE(to_kvm_vmx(vcpu->kvm)->pid_table[vcpu->vcpu_id],</yellow>
			   __pa(&amp;vmx-&gt;pi_desc) | PID_TABLE_ENTRY_VALID);

	return 0;

free_vmcs:
<yellow>	free_loaded_vmcs(vmx->loaded_vmcs);</yellow>
free_pml:
<yellow>	vmx_destroy_pml_buffer(vmx);</yellow>
free_vpid:
<yellow>	free_vpid(vmx->vpid);</yellow>
	return err;
}

#define L1TF_MSG_SMT &quot;L1TF CPU bug present and SMT on, data leak possible. See CVE-2018-3646 and https://www.kernel.org/doc/html/latest/admin-guide/hw-vuln/l1tf.html for details.\n&quot;
#define L1TF_MSG_L1D &quot;L1TF CPU bug present and virtualization mitigation disabled, data leak possible. See CVE-2018-3646 and https://www.kernel.org/doc/html/latest/admin-guide/hw-vuln/l1tf.html for details.\n&quot;

<yellow>static int vmx_vm_init(struct kvm *kvm)</yellow>
<yellow>{</yellow>
<blue>	if (!ple_gap)</blue>
<yellow>		kvm->arch.pause_in_guest = true;</yellow>

<blue>	if (boot_cpu_has(X86_BUG_L1TF) && enable_ept) {</blue>
<yellow>		switch (l1tf_mitigation) {</yellow>
		case L1TF_MITIGATION_OFF:
		case L1TF_MITIGATION_FLUSH_NOWARN:
			/* &#x27;I explicitly don&#x27;t care&#x27; is set */
			break;
		case L1TF_MITIGATION_FLUSH:
		case L1TF_MITIGATION_FLUSH_NOSMT:
		case L1TF_MITIGATION_FULL:
			/*
			 * Warn upon starting the first VM in a potentially
			 * insecure environment.
			 */
<yellow>			if (sched_smt_active())</yellow>
<yellow>				pr_warn_once(L1TF_MSG_SMT);</yellow>
<yellow>			if (l1tf_vmx_mitigation == VMENTER_L1D_FLUSH_NEVER)</yellow>
<yellow>				pr_warn_once(L1TF_MSG_L1D);</yellow>
			break;
		case L1TF_MITIGATION_FULL_FORCE:
			/* Flush is enforced */
			break;
		}
	}
	return 0;
<blue>}</blue>

static int __init vmx_check_processor_compat(void)
{
	struct vmcs_config vmcs_conf;
	struct vmx_capability vmx_cap;

	if (!this_cpu_has(X86_FEATURE_MSR_IA32_FEAT_CTL) ||
	    !this_cpu_has(X86_FEATURE_VMX)) {
		pr_err(&quot;kvm: VMX is disabled on CPU %d\n&quot;, smp_processor_id());
		return -EIO;
	}

	if (setup_vmcs_config(&amp;vmcs_conf, &amp;vmx_cap) &lt; 0)
		return -EIO;
	if (nested)
		nested_vmx_setup_ctls_msrs(&amp;vmcs_conf, vmx_cap.ept);
	if (memcmp(&amp;vmcs_config, &amp;vmcs_conf, sizeof(struct vmcs_config)) != 0) {
		printk(KERN_ERR &quot;kvm: CPU %d feature inconsistency!\n&quot;,
				smp_processor_id());
		return -EIO;
	}
	return 0;
}

<yellow>static u8 vmx_get_mt_mask(struct kvm_vcpu *vcpu, gfn_t gfn, bool is_mmio)</yellow>
{
	u8 cache;

	/* We wanted to honor guest CD/MTRR/PAT, but doing so could result in
	 * memory aliases with conflicting memory types and sometimes MCEs.
	 * We have to be careful as to what are honored and when.
	 *
	 * For MMIO, guest CD/MTRR are ignored.  The EPT memory type is set to
	 * UC.  The effective memory type is UC or WC depending on guest PAT.
	 * This was historically the source of MCEs and we want to be
	 * conservative.
	 *
	 * When there is no need to deal with noncoherent DMA (e.g., no VT-d
	 * or VT-d has snoop control), guest CD/MTRR/PAT are all ignored.  The
	 * EPT memory type is set to WB.  The effective memory type is forced
	 * WB.
	 *
	 * Otherwise, we trust guest.  Guest CD/MTRR/PAT are all honored.  The
	 * EPT memory type is used to emulate guest CD/MTRR.
	 */

<blue>	if (is_mmio)</blue>
		return MTRR_TYPE_UNCACHABLE &lt;&lt; VMX_EPT_MT_EPTE_SHIFT;

<blue>	if (!kvm_arch_has_noncoherent_dma(vcpu->kvm))</blue>
		return (MTRR_TYPE_WRBACK &lt;&lt; VMX_EPT_MT_EPTE_SHIFT) | VMX_EPT_IPAT_BIT;

<yellow>	if (kvm_read_cr0(vcpu) & X86_CR0_CD) {</yellow>
<yellow>		if (kvm_check_has_quirk(vcpu->kvm, KVM_X86_QUIRK_CD_NW_CLEARED))</yellow>
			cache = MTRR_TYPE_WRBACK;
		else
			cache = MTRR_TYPE_UNCACHABLE;

		return (cache &lt;&lt; VMX_EPT_MT_EPTE_SHIFT) | VMX_EPT_IPAT_BIT;
	}

<yellow>	return kvm_mtrr_get_guest_memory_type(vcpu, gfn) << VMX_EPT_MT_EPTE_SHIFT;</yellow>
<blue>}</blue>

static void vmcs_set_secondary_exec_control(struct vcpu_vmx *vmx, u32 new_ctl)
{
	/*
	 * These bits in the secondary execution controls field
	 * are dynamic, the others are mostly based on the hypervisor
	 * architecture and the guest&#x27;s CPUID.  Do not touch the
	 * dynamic bits.
	 */
	u32 mask =
		SECONDARY_EXEC_SHADOW_VMCS |
		SECONDARY_EXEC_VIRTUALIZE_X2APIC_MODE |
		SECONDARY_EXEC_VIRTUALIZE_APIC_ACCESSES |
		SECONDARY_EXEC_DESC;

<blue>	u32 cur_ctl = secondary_exec_controls_get(vmx);</blue>

<blue>	secondary_exec_controls_set(vmx, (new_ctl & ~mask) | (cur_ctl & mask));</blue>
}

/*
 * Generate MSR_IA32_VMX_CR{0,4}_FIXED1 according to CPUID. Only set bits
 * (indicating &quot;allowed-1&quot;) if they are supported in the guest&#x27;s CPUID.
 */
static void nested_vmx_cr_fixed1_bits_update(struct kvm_vcpu *vcpu)
{
	struct vcpu_vmx *vmx = to_vmx(vcpu);
	struct kvm_cpuid_entry2 *entry;

<blue>	vmx->nested.msrs.cr0_fixed1 = 0xffffffff;</blue>
	vmx-&gt;nested.msrs.cr4_fixed1 = X86_CR4_PCE;

#define cr4_fixed1_update(_cr4_mask, _reg, _cpuid_mask) do {		\
	if (entry &amp;&amp; (entry-&gt;_reg &amp; (_cpuid_mask)))			\
		vmx-&gt;nested.msrs.cr4_fixed1 |= (_cr4_mask);	\
} while (0)

	entry = kvm_find_cpuid_entry(vcpu, 0x1);
<blue>	cr4_fixed1_update(X86_CR4_VME,        edx, feature_bit(VME));</blue>
<blue>	cr4_fixed1_update(X86_CR4_PVI,        edx, feature_bit(VME));</blue>
<blue>	cr4_fixed1_update(X86_CR4_TSD,        edx, feature_bit(TSC));</blue>
<blue>	cr4_fixed1_update(X86_CR4_DE,         edx, feature_bit(DE));</blue>
<blue>	cr4_fixed1_update(X86_CR4_PSE,        edx, feature_bit(PSE));</blue>
<blue>	cr4_fixed1_update(X86_CR4_PAE,        edx, feature_bit(PAE));</blue>
<blue>	cr4_fixed1_update(X86_CR4_MCE,        edx, feature_bit(MCE));</blue>
<blue>	cr4_fixed1_update(X86_CR4_PGE,        edx, feature_bit(PGE));</blue>
<blue>	cr4_fixed1_update(X86_CR4_OSFXSR,     edx, feature_bit(FXSR));</blue>
<blue>	cr4_fixed1_update(X86_CR4_OSXMMEXCPT, edx, feature_bit(XMM));</blue>
<blue>	cr4_fixed1_update(X86_CR4_VMXE,       ecx, feature_bit(VMX));</blue>
<blue>	cr4_fixed1_update(X86_CR4_SMXE,       ecx, feature_bit(SMX));</blue>
<blue>	cr4_fixed1_update(X86_CR4_PCIDE,      ecx, feature_bit(PCID));</blue>
<blue>	cr4_fixed1_update(X86_CR4_OSXSAVE,    ecx, feature_bit(XSAVE));</blue>

<blue>	entry = kvm_find_cpuid_entry_index(vcpu, 0x7, 0);</blue>
<blue>	cr4_fixed1_update(X86_CR4_FSGSBASE,   ebx, feature_bit(FSGSBASE));</blue>
<blue>	cr4_fixed1_update(X86_CR4_SMEP,       ebx, feature_bit(SMEP));</blue>
<blue>	cr4_fixed1_update(X86_CR4_SMAP,       ebx, feature_bit(SMAP));</blue>
<blue>	cr4_fixed1_update(X86_CR4_PKE,        ecx, feature_bit(PKU));</blue>
<blue>	cr4_fixed1_update(X86_CR4_UMIP,       ecx, feature_bit(UMIP));</blue>
<blue>	cr4_fixed1_update(X86_CR4_LA57,       ecx, feature_bit(LA57));</blue>

#undef cr4_fixed1_update
}

static void update_intel_pt_cfg(struct kvm_vcpu *vcpu)
{
	struct vcpu_vmx *vmx = to_vmx(vcpu);
	struct kvm_cpuid_entry2 *best = NULL;
	int i;

	for (i = 0; i &lt; PT_CPUID_LEAVES; i++) {
<yellow>		best = kvm_find_cpuid_entry_index(vcpu, 0x14, i);</yellow>
		if (!best)
			return;
<yellow>		vmx->pt_desc.caps[CPUID_EAX + i*PT_CPUID_REGS_NUM] = best->eax;</yellow>
		vmx-&gt;pt_desc.caps[CPUID_EBX + i*PT_CPUID_REGS_NUM] = best-&gt;ebx;
		vmx-&gt;pt_desc.caps[CPUID_ECX + i*PT_CPUID_REGS_NUM] = best-&gt;ecx;
		vmx-&gt;pt_desc.caps[CPUID_EDX + i*PT_CPUID_REGS_NUM] = best-&gt;edx;
	}

	/* Get the number of configurable Address Ranges for filtering */
	vmx-&gt;pt_desc.num_address_ranges = intel_pt_validate_cap(vmx-&gt;pt_desc.caps,
						PT_CAP_num_address_ranges);

	/* Initialize and clear the no dependency bits */
	vmx-&gt;pt_desc.ctl_bitmask = ~(RTIT_CTL_TRACEEN | RTIT_CTL_OS |
			RTIT_CTL_USR | RTIT_CTL_TSC_EN | RTIT_CTL_DISRETC |
			RTIT_CTL_BRANCH_EN);

	/*
	 * If CPUID.(EAX=14H,ECX=0):EBX[0]=1 CR3Filter can be set otherwise
	 * will inject an #GP
	 */
	if (intel_pt_validate_cap(vmx-&gt;pt_desc.caps, PT_CAP_cr3_filtering))
<yellow>		vmx->pt_desc.ctl_bitmask &= ~RTIT_CTL_CR3EN;</yellow>

	/*
	 * If CPUID.(EAX=14H,ECX=0):EBX[1]=1 CYCEn, CycThresh and
	 * PSBFreq can be set
	 */
<yellow>	if (intel_pt_validate_cap(vmx->pt_desc.caps, PT_CAP_psb_cyc))</yellow>
<yellow>		vmx->pt_desc.ctl_bitmask &= ~(RTIT_CTL_CYCLEACC |</yellow>
				RTIT_CTL_CYC_THRESH | RTIT_CTL_PSB_FREQ);

	/*
	 * If CPUID.(EAX=14H,ECX=0):EBX[3]=1 MTCEn and MTCFreq can be set
	 */
<yellow>	if (intel_pt_validate_cap(vmx->pt_desc.caps, PT_CAP_mtc))</yellow>
<yellow>		vmx->pt_desc.ctl_bitmask &= ~(RTIT_CTL_MTC_EN |</yellow>
					      RTIT_CTL_MTC_RANGE);

	/* If CPUID.(EAX=14H,ECX=0):EBX[4]=1 FUPonPTW and PTWEn can be set */
<yellow>	if (intel_pt_validate_cap(vmx->pt_desc.caps, PT_CAP_ptwrite))</yellow>
<yellow>		vmx->pt_desc.ctl_bitmask &= ~(RTIT_CTL_FUP_ON_PTW |</yellow>
							RTIT_CTL_PTW_EN);

	/* If CPUID.(EAX=14H,ECX=0):EBX[5]=1 PwrEvEn can be set */
<yellow>	if (intel_pt_validate_cap(vmx->pt_desc.caps, PT_CAP_power_event_trace))</yellow>
<yellow>		vmx->pt_desc.ctl_bitmask &= ~RTIT_CTL_PWR_EVT_EN;</yellow>

	/* If CPUID.(EAX=14H,ECX=0):ECX[0]=1 ToPA can be set */
<yellow>	if (intel_pt_validate_cap(vmx->pt_desc.caps, PT_CAP_topa_output))</yellow>
<yellow>		vmx->pt_desc.ctl_bitmask &= ~RTIT_CTL_TOPA;</yellow>

	/* If CPUID.(EAX=14H,ECX=0):ECX[3]=1 FabricEn can be set */
<yellow>	if (intel_pt_validate_cap(vmx->pt_desc.caps, PT_CAP_output_subsys))</yellow>
<yellow>		vmx->pt_desc.ctl_bitmask &= ~RTIT_CTL_FABRIC_EN;</yellow>

	/* unmask address range configure area */
<yellow>	for (i = 0; i < vmx->pt_desc.num_address_ranges; i++)</yellow>
<yellow>		vmx->pt_desc.ctl_bitmask &= ~(0xfULL << (32 + i * 4));</yellow>
}

static void vmx_vcpu_after_set_cpuid(struct kvm_vcpu *vcpu)
{
	struct vcpu_vmx *vmx = to_vmx(vcpu);

	/* xsaves_enabled is recomputed in vmx_compute_secondary_exec_control(). */
<blue>	vcpu->arch.xsaves_enabled = false;</blue>

	vmx_setup_uret_msrs(vmx);

	if (cpu_has_secondary_exec_ctrls())
<blue>		vmcs_set_secondary_exec_control(vmx,</blue>
						vmx_secondary_exec_control(vmx));

<blue>	if (nested_vmx_allowed(vcpu))</blue>
<blue>		vmx->msr_ia32_feature_control_valid_bits |=</blue>
			FEAT_CTL_VMX_ENABLED_INSIDE_SMX |
			FEAT_CTL_VMX_ENABLED_OUTSIDE_SMX;
	else
<blue>		vmx->msr_ia32_feature_control_valid_bits &=</blue>
			~(FEAT_CTL_VMX_ENABLED_INSIDE_SMX |
			  FEAT_CTL_VMX_ENABLED_OUTSIDE_SMX);

	if (nested_vmx_allowed(vcpu))
<blue>		nested_vmx_cr_fixed1_bits_update(vcpu);</blue>

<blue>	if (boot_cpu_has(X86_FEATURE_INTEL_PT) &&</blue>
<blue>			guest_cpuid_has(vcpu, X86_FEATURE_INTEL_PT))</blue>
<yellow>		update_intel_pt_cfg(vcpu);</yellow>

<blue>	if (boot_cpu_has(X86_FEATURE_RTM)) {</blue>
		struct vmx_uret_msr *msr;
<yellow>		msr = vmx_find_uret_msr(vmx, MSR_IA32_TSX_CTRL);</yellow>
		if (msr) {
<yellow>			bool enabled = guest_cpuid_has(vcpu, X86_FEATURE_RTM);</yellow>
<yellow>			vmx_set_guest_uret_msr(vmx, msr, enabled ? 0 : TSX_CTRL_RTM_DISABLE);</yellow>
		}
	}

<blue>	if (kvm_cpu_cap_has(X86_FEATURE_XFD))</blue>
<yellow>		vmx_set_intercept_for_msr(vcpu, MSR_IA32_XFD_ERR, MSR_TYPE_R,</yellow>
<yellow>					  !guest_cpuid_has(vcpu, X86_FEATURE_XFD));</yellow>


<blue>	set_cr4_guest_host_mask(vmx);</blue>

	vmx_write_encls_bitmap(vcpu, NULL);
<blue>	if (guest_cpuid_has(vcpu, X86_FEATURE_SGX))</blue>
<yellow>		vmx->msr_ia32_feature_control_valid_bits |= FEAT_CTL_SGX_ENABLED;</yellow>
	else
<blue>		vmx->msr_ia32_feature_control_valid_bits &= ~FEAT_CTL_SGX_ENABLED;</blue>

<blue>	if (guest_cpuid_has(vcpu, X86_FEATURE_SGX_LC))</blue>
<yellow>		vmx->msr_ia32_feature_control_valid_bits |=</yellow>
			FEAT_CTL_SGX_LC_ENABLED;
	else
<blue>		vmx->msr_ia32_feature_control_valid_bits &=</blue>
			~FEAT_CTL_SGX_LC_ENABLED;

	/* Refresh #PF interception to account for MAXPHYADDR changes. */
	vmx_update_exception_bitmap(vcpu);
}

static __init void vmx_set_cpu_caps(void)
{
	kvm_set_cpu_caps();

	/* CPUID 0x1 */
	if (nested)
		kvm_cpu_cap_set(X86_FEATURE_VMX);

	/* CPUID 0x7 */
	if (kvm_mpx_supported())
		kvm_cpu_cap_check_and_set(X86_FEATURE_MPX);
	if (!cpu_has_vmx_invpcid())
		kvm_cpu_cap_clear(X86_FEATURE_INVPCID);
	if (vmx_pt_mode_is_host_guest())
		kvm_cpu_cap_check_and_set(X86_FEATURE_INTEL_PT);
	if (vmx_pebs_supported()) {
		kvm_cpu_cap_check_and_set(X86_FEATURE_DS);
		kvm_cpu_cap_check_and_set(X86_FEATURE_DTES64);
	}

	if (!enable_pmu)
		kvm_cpu_cap_clear(X86_FEATURE_PDCM);

	if (!enable_sgx) {
		kvm_cpu_cap_clear(X86_FEATURE_SGX);
		kvm_cpu_cap_clear(X86_FEATURE_SGX_LC);
		kvm_cpu_cap_clear(X86_FEATURE_SGX1);
		kvm_cpu_cap_clear(X86_FEATURE_SGX2);
	}

	if (vmx_umip_emulated())
		kvm_cpu_cap_set(X86_FEATURE_UMIP);

	/* CPUID 0xD.1 */
	kvm_caps.supported_xss = 0;
	if (!cpu_has_vmx_xsaves())
		kvm_cpu_cap_clear(X86_FEATURE_XSAVES);

	/* CPUID 0x80000001 and 0x7 (RDPID) */
	if (!cpu_has_vmx_rdtscp()) {
		kvm_cpu_cap_clear(X86_FEATURE_RDTSCP);
		kvm_cpu_cap_clear(X86_FEATURE_RDPID);
	}

	if (cpu_has_vmx_waitpkg())
		kvm_cpu_cap_check_and_set(X86_FEATURE_WAITPKG);
}

static void vmx_request_immediate_exit(struct kvm_vcpu *vcpu)
<yellow>{</yellow>
<blue>	to_vmx(vcpu)->req_immediate_exit = true;</blue>
}

static int vmx_check_intercept_io(struct kvm_vcpu *vcpu,
				  struct x86_instruction_info *info)
{
	struct vmcs12 *vmcs12 = get_vmcs12(vcpu);
	unsigned short port;
	bool intercept;
	int size;

<blue>	if (info->intercept == x86_intercept_in ||</blue>
	    info-&gt;intercept == x86_intercept_ins) {
<blue>		port = info->src_val;</blue>
<yellow>		size = info->dst_bytes;</yellow>
	} else {
<blue>		port = info->dst_val;</blue>
<yellow>		size = info->src_bytes;</yellow>
	}

	/*
	 * If the &#x27;use IO bitmaps&#x27; VM-execution control is 0, IO instruction
	 * VM-exits depend on the &#x27;unconditional IO exiting&#x27; VM-execution
	 * control.
	 *
	 * Otherwise, IO instruction VM-exits are controlled by the IO bitmaps.
	 */
<blue>	if (!nested_cpu_has(vmcs12, CPU_BASED_USE_IO_BITMAPS))</blue>
<blue>		intercept = nested_cpu_has(vmcs12,</blue>
					   CPU_BASED_UNCOND_IO_EXITING);
	else
<blue>		intercept = nested_vmx_check_io_bitmaps(vcpu, port, size);</blue>

	/* FIXME: produce nested vmexit and return X86EMUL_INTERCEPTED.  */
<blue>	return intercept ? X86EMUL_UNHANDLEABLE : X86EMUL_CONTINUE;</blue>
}

static int vmx_check_intercept(struct kvm_vcpu *vcpu,
			       struct x86_instruction_info *info,
			       enum x86_intercept_stage stage,
			       struct x86_exception *exception)
<yellow>{</yellow>
<blue>	struct vmcs12 *vmcs12 = get_vmcs12(vcpu);</blue>

<yellow>	switch (info->intercept) {</yellow>
	/*
	 * RDPID causes #UD if disabled through secondary execution controls.
	 * Because it is marked as EmulateOnUD, we need to intercept it here.
	 * Note, RDPID is hidden behind ENABLE_RDTSCP.
	 */
	case x86_intercept_rdpid:
<yellow>		if (!nested_cpu_has2(vmcs12, SECONDARY_EXEC_ENABLE_RDTSCP)) {</yellow>
<yellow>			exception->vector = UD_VECTOR;</yellow>
<yellow>			exception->error_code_valid = false;</yellow>
<yellow>			return X86EMUL_PROPAGATE_FAULT;</yellow>
		}
		break;

	case x86_intercept_in:
	case x86_intercept_ins:
	case x86_intercept_out:
	case x86_intercept_outs:
<blue>		return vmx_check_intercept_io(vcpu, info);</blue>

	case x86_intercept_lgdt:
	case x86_intercept_lidt:
	case x86_intercept_lldt:
	case x86_intercept_ltr:
	case x86_intercept_sgdt:
	case x86_intercept_sidt:
	case x86_intercept_sldt:
	case x86_intercept_str:
<blue>		if (!nested_cpu_has2(vmcs12, SECONDARY_EXEC_DESC))</blue>
			return X86EMUL_CONTINUE;

		/* FIXME: produce nested vmexit and return X86EMUL_INTERCEPTED.  */
		break;

	/* TODO: check more intercepts... */
	default:
		break;
	}

	return X86EMUL_UNHANDLEABLE;
<yellow>}</yellow>

#ifdef CONFIG_X86_64
/* (a &lt;&lt; shift) / divisor, return 1 if overflow otherwise 0 */
static inline int u64_shl_div_u64(u64 a, unsigned int shift,
				  u64 divisor, u64 *result)
{
<yellow>	u64 low = a << shift, high = a >> (64 - shift);</yellow>

	/* To avoid the overflow on divq */
<yellow>	if (high >= divisor)</yellow>
		return 1;

	/* Low hold the result, high hold rem which is discarded */
	asm(&quot;divq %2\n\t&quot; : &quot;=a&quot; (low), &quot;=d&quot; (high) :
	    &quot;rm&quot; (divisor), &quot;0&quot; (low), &quot;1&quot; (high));
	*result = low;

	return 0;
}

static int vmx_set_hv_timer(struct kvm_vcpu *vcpu, u64 guest_deadline_tsc,
			    bool *expired)
{
	struct vcpu_vmx *vmx;
	u64 tscl, guest_tscl, delta_tsc, lapic_timer_advance_cycles;
<yellow>	struct kvm_timer *ktimer = &vcpu->arch.apic->lapic_timer;</yellow>

	vmx = to_vmx(vcpu);
	tscl = rdtsc();
<yellow>	guest_tscl = kvm_read_l1_tsc(vcpu, tscl);</yellow>
	delta_tsc = max(guest_deadline_tsc, guest_tscl) - guest_tscl;
<yellow>	lapic_timer_advance_cycles = nsec_to_cycles(vcpu,</yellow>
<yellow>						    ktimer->timer_advance_ns);</yellow>

<yellow>	if (delta_tsc > lapic_timer_advance_cycles)</yellow>
<yellow>		delta_tsc -= lapic_timer_advance_cycles;</yellow>
	else
		delta_tsc = 0;

	/* Convert to host delta tsc if tsc scaling is enabled */
<yellow>	if (vcpu->arch.l1_tsc_scaling_ratio != kvm_caps.default_tsc_scaling_ratio &&</yellow>
<yellow>	    delta_tsc && u64_shl_div_u64(delta_tsc,</yellow>
<yellow>				kvm_caps.tsc_scaling_ratio_frac_bits,</yellow>
				vcpu-&gt;arch.l1_tsc_scaling_ratio, &amp;delta_tsc))
		return -ERANGE;

	/*
	 * If the delta tsc can&#x27;t fit in the 32 bit after the multi shift,
	 * we can&#x27;t use the preemption timer.
	 * It&#x27;s possible that it fits on later vmentries, but checking
	 * on every vmentry is costly so we just use an hrtimer.
	 */
<yellow>	if (delta_tsc >> (cpu_preemption_timer_multi + 32))</yellow>
		return -ERANGE;

<yellow>	vmx->hv_deadline_tsc = tscl + delta_tsc;</yellow>
<yellow>	*expired = !delta_tsc;</yellow>
	return 0;
<yellow>}</yellow>

static void vmx_cancel_hv_timer(struct kvm_vcpu *vcpu)
<yellow>{</yellow>
<yellow>	to_vmx(vcpu)->hv_deadline_tsc = -1;</yellow>
}
#endif

static void vmx_sched_in(struct kvm_vcpu *vcpu, int cpu)
<yellow>{</yellow>
<blue>	if (!kvm_pause_in_guest(vcpu->kvm))</blue>
<blue>		shrink_ple_window(vcpu);</blue>
<blue>}</blue>

<yellow>void vmx_update_cpu_dirty_logging(struct kvm_vcpu *vcpu)</yellow>
{
	struct vcpu_vmx *vmx = to_vmx(vcpu);

<yellow>	if (is_guest_mode(vcpu)) {</yellow>
<yellow>		vmx->nested.update_vmcs01_cpu_dirty_logging = true;</yellow>
		return;
	}

	/*
	 * Note, cpu_dirty_logging_count can be changed concurrent with this
	 * code, but in that case another update request will be made and so
	 * the guest will never run with a stale PML value.
	 */
<yellow>	if (vcpu->kvm->arch.cpu_dirty_logging_count)</yellow>
<yellow>		secondary_exec_controls_setbit(vmx, SECONDARY_EXEC_ENABLE_PML);</yellow>
	else
<yellow>		secondary_exec_controls_clearbit(vmx, SECONDARY_EXEC_ENABLE_PML);</yellow>
<yellow>}</yellow>

static void vmx_setup_mce(struct kvm_vcpu *vcpu)
<yellow>{</yellow>
<blue>	if (vcpu->arch.mcg_cap & MCG_LMCE_P)</blue>
<blue>		to_vmx(vcpu)->msr_ia32_feature_control_valid_bits |=</blue>
			FEAT_CTL_LMCE_ENABLED;
	else
<blue>		to_vmx(vcpu)->msr_ia32_feature_control_valid_bits &=</blue>
			~FEAT_CTL_LMCE_ENABLED;
<yellow>}</yellow>

static int vmx_smi_allowed(struct kvm_vcpu *vcpu, bool for_injection)
<yellow>{</yellow>
	/* we need a nested vmexit to enter SMM, postpone if run is pending */
<yellow>	if (to_vmx(vcpu)->nested.nested_run_pending)</yellow>
<yellow>		return -EBUSY;</yellow>
<yellow>	return !is_smm(vcpu);</yellow>
<yellow>}</yellow>

static int vmx_enter_smm(struct kvm_vcpu *vcpu, char *smstate)
{
	struct vcpu_vmx *vmx = to_vmx(vcpu);

	/*
	 * TODO: Implement custom flows for forcing the vCPU out/in of L2 on
	 * SMI and RSM.  Using the common VM-Exit + VM-Enter routines is wrong
	 * SMI and RSM only modify state that is saved and restored via SMRAM.
	 * E.g. most MSRs are left untouched, but many are modified by VM-Exit
	 * and VM-Enter, and thus L2&#x27;s values may be corrupted on SMI+RSM.
	 */
<yellow>	vmx->nested.smm.guest_mode = is_guest_mode(vcpu);</yellow>
<yellow>	if (vmx->nested.smm.guest_mode)</yellow>
<yellow>		nested_vmx_vmexit(vcpu, -1, 0, 0);</yellow>

<yellow>	vmx->nested.smm.vmxon = vmx->nested.vmxon;</yellow>
	vmx-&gt;nested.vmxon = false;
<yellow>	vmx_clear_hlt(vcpu);</yellow>
	return 0;
<yellow>}</yellow>

<yellow>static int vmx_leave_smm(struct kvm_vcpu *vcpu, const char *smstate)</yellow>
<yellow>{</yellow>
	struct vcpu_vmx *vmx = to_vmx(vcpu);
	int ret;

<yellow>	if (vmx->nested.smm.vmxon) {</yellow>
<yellow>		vmx->nested.vmxon = true;</yellow>
<yellow>		vmx->nested.smm.vmxon = false;</yellow>
	}

<yellow>	if (vmx->nested.smm.guest_mode) {</yellow>
<yellow>		ret = nested_vmx_enter_non_root_mode(vcpu, false);</yellow>
<yellow>		if (ret)</yellow>
			return ret;

<yellow>		vmx->nested.nested_run_pending = 1;</yellow>
<yellow>		vmx->nested.smm.guest_mode = false;</yellow>
	}
	return 0;
<yellow>}</yellow>

static void vmx_enable_smi_window(struct kvm_vcpu *vcpu)
{
	/* RSM will cause a vmexit anyway.  */
<yellow>}</yellow>

static bool vmx_apic_init_signal_blocked(struct kvm_vcpu *vcpu)
<yellow>{</yellow>
<blue>	return to_vmx(vcpu)->nested.vmxon && !is_guest_mode(vcpu);</blue>
<blue>}</blue>

<blue>static void vmx_migrate_timers(struct kvm_vcpu *vcpu)</blue>
<yellow>{</yellow>
<blue>	if (is_guest_mode(vcpu)) {</blue>
<blue>		struct hrtimer *timer = &to_vmx(vcpu)->nested.preemption_timer;</blue>

<yellow>		if (hrtimer_try_to_cancel(timer) == 1)</yellow>
<blue>			hrtimer_start_expires(timer, HRTIMER_MODE_ABS_PINNED);</blue>
	}
<blue>}</blue>

static void vmx_hardware_unsetup(void)
<yellow>{</yellow>
<yellow>	kvm_set_posted_intr_wakeup_handler(NULL);</yellow>

<yellow>	if (nested)</yellow>
<yellow>		nested_vmx_hardware_unsetup();</yellow>

<yellow>	free_kvm_area();</yellow>
}

static bool vmx_check_apicv_inhibit_reasons(enum kvm_apicv_inhibit reason)
{
	ulong supported = BIT(APICV_INHIBIT_REASON_DISABLE) |
			  BIT(APICV_INHIBIT_REASON_ABSENT) |
			  BIT(APICV_INHIBIT_REASON_HYPERV) |
			  BIT(APICV_INHIBIT_REASON_BLOCKIRQ) |
			  BIT(APICV_INHIBIT_REASON_APIC_ID_MODIFIED) |
			  BIT(APICV_INHIBIT_REASON_APIC_BASE_MODIFIED);

<blue>	return supported & BIT(reason);</blue>
}

static void vmx_vm_destroy(struct kvm *kvm)
<yellow>{</yellow>
	struct kvm_vmx *kvm_vmx = to_kvm_vmx(kvm);

<yellow>	free_pages((unsigned long)kvm_vmx->pid_table, vmx_get_pid_table_order(kvm));</yellow>
}

static struct kvm_x86_ops vmx_x86_ops __initdata = {
	.name = &quot;kvm_intel&quot;,

	.hardware_unsetup = vmx_hardware_unsetup,

	.hardware_enable = vmx_hardware_enable,
	.hardware_disable = vmx_hardware_disable,
	.has_emulated_msr = vmx_has_emulated_msr,

	.vm_size = sizeof(struct kvm_vmx),
	.vm_init = vmx_vm_init,
	.vm_destroy = vmx_vm_destroy,

	.vcpu_precreate = vmx_vcpu_precreate,
	.vcpu_create = vmx_vcpu_create,
	.vcpu_free = vmx_vcpu_free,
	.vcpu_reset = vmx_vcpu_reset,

	.prepare_switch_to_guest = vmx_prepare_switch_to_guest,
	.vcpu_load = vmx_vcpu_load,
	.vcpu_put = vmx_vcpu_put,

	.update_exception_bitmap = vmx_update_exception_bitmap,
	.get_msr_feature = vmx_get_msr_feature,
	.get_msr = vmx_get_msr,
	.set_msr = vmx_set_msr,
	.get_segment_base = vmx_get_segment_base,
	.get_segment = vmx_get_segment,
	.set_segment = vmx_set_segment,
	.get_cpl = vmx_get_cpl,
	.get_cs_db_l_bits = vmx_get_cs_db_l_bits,
	.set_cr0 = vmx_set_cr0,
	.is_valid_cr4 = vmx_is_valid_cr4,
	.set_cr4 = vmx_set_cr4,
	.set_efer = vmx_set_efer,
	.get_idt = vmx_get_idt,
	.set_idt = vmx_set_idt,
	.get_gdt = vmx_get_gdt,
	.set_gdt = vmx_set_gdt,
	.set_dr7 = vmx_set_dr7,
	.sync_dirty_debug_regs = vmx_sync_dirty_debug_regs,
	.cache_reg = vmx_cache_reg,
	.get_rflags = vmx_get_rflags,
	.set_rflags = vmx_set_rflags,
	.get_if_flag = vmx_get_if_flag,

	.flush_tlb_all = vmx_flush_tlb_all,
	.flush_tlb_current = vmx_flush_tlb_current,
	.flush_tlb_gva = vmx_flush_tlb_gva,
	.flush_tlb_guest = vmx_flush_tlb_guest,

	.vcpu_pre_run = vmx_vcpu_pre_run,
	.vcpu_run = vmx_vcpu_run,
	.handle_exit = vmx_handle_exit,
	.skip_emulated_instruction = vmx_skip_emulated_instruction,
	.update_emulated_instruction = vmx_update_emulated_instruction,
	.set_interrupt_shadow = vmx_set_interrupt_shadow,
	.get_interrupt_shadow = vmx_get_interrupt_shadow,
	.patch_hypercall = vmx_patch_hypercall,
	.inject_irq = vmx_inject_irq,
	.inject_nmi = vmx_inject_nmi,
	.inject_exception = vmx_inject_exception,
	.cancel_injection = vmx_cancel_injection,
	.interrupt_allowed = vmx_interrupt_allowed,
	.nmi_allowed = vmx_nmi_allowed,
	.get_nmi_mask = vmx_get_nmi_mask,
	.set_nmi_mask = vmx_set_nmi_mask,
	.enable_nmi_window = vmx_enable_nmi_window,
	.enable_irq_window = vmx_enable_irq_window,
	.update_cr8_intercept = vmx_update_cr8_intercept,
	.set_virtual_apic_mode = vmx_set_virtual_apic_mode,
	.set_apic_access_page_addr = vmx_set_apic_access_page_addr,
	.refresh_apicv_exec_ctrl = vmx_refresh_apicv_exec_ctrl,
	.load_eoi_exitmap = vmx_load_eoi_exitmap,
	.apicv_post_state_restore = vmx_apicv_post_state_restore,
	.check_apicv_inhibit_reasons = vmx_check_apicv_inhibit_reasons,
	.hwapic_irr_update = vmx_hwapic_irr_update,
	.hwapic_isr_update = vmx_hwapic_isr_update,
	.guest_apic_has_interrupt = vmx_guest_apic_has_interrupt,
	.sync_pir_to_irr = vmx_sync_pir_to_irr,
	.deliver_interrupt = vmx_deliver_interrupt,
	.dy_apicv_has_pending_interrupt = pi_has_pending_interrupt,

	.set_tss_addr = vmx_set_tss_addr,
	.set_identity_map_addr = vmx_set_identity_map_addr,
	.get_mt_mask = vmx_get_mt_mask,

	.get_exit_info = vmx_get_exit_info,

	.vcpu_after_set_cpuid = vmx_vcpu_after_set_cpuid,

	.has_wbinvd_exit = cpu_has_vmx_wbinvd_exit,

	.get_l2_tsc_offset = vmx_get_l2_tsc_offset,
	.get_l2_tsc_multiplier = vmx_get_l2_tsc_multiplier,
	.write_tsc_offset = vmx_write_tsc_offset,
	.write_tsc_multiplier = vmx_write_tsc_multiplier,

	.load_mmu_pgd = vmx_load_mmu_pgd,

	.check_intercept = vmx_check_intercept,
	.handle_exit_irqoff = vmx_handle_exit_irqoff,

	.request_immediate_exit = vmx_request_immediate_exit,

	.sched_in = vmx_sched_in,

	.cpu_dirty_log_size = PML_ENTITY_NUM,
	.update_cpu_dirty_logging = vmx_update_cpu_dirty_logging,

	.nested_ops = &amp;vmx_nested_ops,

	.pi_update_irte = vmx_pi_update_irte,
	.pi_start_assignment = vmx_pi_start_assignment,

#ifdef CONFIG_X86_64
	.set_hv_timer = vmx_set_hv_timer,
	.cancel_hv_timer = vmx_cancel_hv_timer,
#endif

	.setup_mce = vmx_setup_mce,

	.smi_allowed = vmx_smi_allowed,
	.enter_smm = vmx_enter_smm,
	.leave_smm = vmx_leave_smm,
	.enable_smi_window = vmx_enable_smi_window,

	.can_emulate_instruction = vmx_can_emulate_instruction,
	.apic_init_signal_blocked = vmx_apic_init_signal_blocked,
	.migrate_timers = vmx_migrate_timers,

	.msr_filter_changed = vmx_msr_filter_changed,
	.complete_emulated_msr = kvm_complete_insn_gp,

	.vcpu_deliver_sipi_vector = kvm_vcpu_deliver_sipi_vector,
};

static unsigned int vmx_handle_intel_pt_intr(void)
{
<yellow>	struct kvm_vcpu *vcpu = kvm_get_running_vcpu();</yellow>

	/* &#x27;0&#x27; on failure so that the !PT case can use a RET0 static call. */
<yellow>	if (!vcpu || !kvm_handling_nmi_from_guest(vcpu))</yellow>
<yellow>		return 0;</yellow>

<yellow>	kvm_make_request(KVM_REQ_PMI, vcpu);</yellow>
<yellow>	__set_bit(MSR_CORE_PERF_GLOBAL_OVF_CTRL_TRACE_TOPA_PMI_BIT,</yellow>
		  (unsigned long *)&amp;vcpu-&gt;arch.pmu.global_status);
<yellow>	return 1;</yellow>
}

static __init void vmx_setup_user_return_msrs(void)
{

	/*
	 * Though SYSCALL is only supported in 64-bit mode on Intel CPUs, kvm
	 * will emulate SYSCALL in legacy mode if the vendor string in guest
	 * CPUID.0:{EBX,ECX,EDX} is &quot;AuthenticAMD&quot; or &quot;AMDisbetter!&quot; To
	 * support this emulation, MSR_STAR is included in the list for i386,
	 * but is never loaded into hardware.  MSR_CSTAR is also never loaded
	 * into hardware and is here purely for emulation purposes.
	 */
	const u32 vmx_uret_msrs_list[] = {
	#ifdef CONFIG_X86_64
		MSR_SYSCALL_MASK, MSR_LSTAR, MSR_CSTAR,
	#endif
		MSR_EFER, MSR_TSC_AUX, MSR_STAR,
		MSR_IA32_TSX_CTRL,
	};
	int i;

	BUILD_BUG_ON(ARRAY_SIZE(vmx_uret_msrs_list) != MAX_NR_USER_RETURN_MSRS);

	for (i = 0; i &lt; ARRAY_SIZE(vmx_uret_msrs_list); ++i)
		kvm_add_user_return_msr(vmx_uret_msrs_list[i]);
}

static void __init vmx_setup_me_spte_mask(void)
{
	u64 me_mask = 0;

	/*
	 * kvm_get_shadow_phys_bits() returns shadow_phys_bits.  Use
	 * the former to avoid exposing shadow_phys_bits.
	 *
	 * On pre-MKTME system, boot_cpu_data.x86_phys_bits equals to
	 * shadow_phys_bits.  On MKTME and/or TDX capable systems,
	 * boot_cpu_data.x86_phys_bits holds the actual physical address
	 * w/o the KeyID bits, and shadow_phys_bits equals to MAXPHYADDR
	 * reported by CPUID.  Those bits between are KeyID bits.
	 */
	if (boot_cpu_data.x86_phys_bits != kvm_get_shadow_phys_bits())
		me_mask = rsvd_bits(boot_cpu_data.x86_phys_bits,
			kvm_get_shadow_phys_bits() - 1);
	/*
	 * Unlike SME, host kernel doesn&#x27;t support setting up any
	 * MKTME KeyID on Intel platforms.  No memory encryption
	 * bits should be included into the SPTE.
	 */
	kvm_mmu_set_me_spte_mask(0, me_mask);
}

static struct kvm_x86_init_ops vmx_init_ops __initdata;

static __init int hardware_setup(void)
{
	unsigned long host_bndcfgs;
	struct desc_ptr dt;
	int r;

	store_idt(&amp;dt);
	host_idt_base = dt.address;

	vmx_setup_user_return_msrs();

	if (setup_vmcs_config(&amp;vmcs_config, &amp;vmx_capability) &lt; 0)
		return -EIO;

	if (cpu_has_perf_global_ctrl_bug())
		pr_warn_once(&quot;kvm: VM_EXIT_LOAD_IA32_PERF_GLOBAL_CTRL &quot;
			     &quot;does not work properly. Using workaround\n&quot;);

	if (boot_cpu_has(X86_FEATURE_NX))
		kvm_enable_efer_bits(EFER_NX);

	if (boot_cpu_has(X86_FEATURE_MPX)) {
		rdmsrl(MSR_IA32_BNDCFGS, host_bndcfgs);
		WARN_ONCE(host_bndcfgs, &quot;KVM: BNDCFGS in host will be lost&quot;);
	}

	if (!cpu_has_vmx_mpx())
		kvm_caps.supported_xcr0 &amp;= ~(XFEATURE_MASK_BNDREGS |
					     XFEATURE_MASK_BNDCSR);

	if (!cpu_has_vmx_vpid() || !cpu_has_vmx_invvpid() ||
	    !(cpu_has_vmx_invvpid_single() || cpu_has_vmx_invvpid_global()))
		enable_vpid = 0;

	if (!cpu_has_vmx_ept() ||
	    !cpu_has_vmx_ept_4levels() ||
	    !cpu_has_vmx_ept_mt_wb() ||
	    !cpu_has_vmx_invept_global())
		enable_ept = 0;

	/* NX support is required for shadow paging. */
	if (!enable_ept &amp;&amp; !boot_cpu_has(X86_FEATURE_NX)) {
		pr_err_ratelimited(&quot;kvm: NX (Execute Disable) not supported\n&quot;);
		return -EOPNOTSUPP;
	}

	if (!cpu_has_vmx_ept_ad_bits() || !enable_ept)
		enable_ept_ad_bits = 0;

	if (!cpu_has_vmx_unrestricted_guest() || !enable_ept)
		enable_unrestricted_guest = 0;

	if (!cpu_has_vmx_flexpriority())
		flexpriority_enabled = 0;

	if (!cpu_has_virtual_nmis())
		enable_vnmi = 0;

#ifdef CONFIG_X86_SGX_KVM
	if (!cpu_has_vmx_encls_vmexit())
		enable_sgx = false;
#endif

	/*
	 * set_apic_access_page_addr() is used to reload apic access
	 * page upon invalidation.  No need to do anything if not
	 * using the APIC_ACCESS_ADDR VMCS field.
	 */
	if (!flexpriority_enabled)
		vmx_x86_ops.set_apic_access_page_addr = NULL;

	if (!cpu_has_vmx_tpr_shadow())
		vmx_x86_ops.update_cr8_intercept = NULL;

#if IS_ENABLED(CONFIG_HYPERV)
	if (ms_hyperv.nested_features &amp; HV_X64_NESTED_GUEST_MAPPING_FLUSH
	    &amp;&amp; enable_ept) {
		vmx_x86_ops.tlb_remote_flush = hv_remote_flush_tlb;
		vmx_x86_ops.tlb_remote_flush_with_range =
				hv_remote_flush_tlb_with_range;
	}
#endif

	if (!cpu_has_vmx_ple()) {
		ple_gap = 0;
		ple_window = 0;
		ple_window_grow = 0;
		ple_window_max = 0;
		ple_window_shrink = 0;
	}

	if (!cpu_has_vmx_apicv())
		enable_apicv = 0;
	if (!enable_apicv)
		vmx_x86_ops.sync_pir_to_irr = NULL;

	if (!enable_apicv || !cpu_has_vmx_ipiv())
		enable_ipiv = false;

	if (cpu_has_vmx_tsc_scaling())
		kvm_caps.has_tsc_control = true;

	kvm_caps.max_tsc_scaling_ratio = KVM_VMX_TSC_MULTIPLIER_MAX;
	kvm_caps.tsc_scaling_ratio_frac_bits = 48;
	kvm_caps.has_bus_lock_exit = cpu_has_vmx_bus_lock_detection();
	kvm_caps.has_notify_vmexit = cpu_has_notify_vmexit();

	set_bit(0, vmx_vpid_bitmap); /* 0 is reserved for host */

	if (enable_ept)
		kvm_mmu_set_ept_masks(enable_ept_ad_bits,
				      cpu_has_vmx_ept_execute_only());

	/*
	 * Setup shadow_me_value/shadow_me_mask to include MKTME KeyID
	 * bits to shadow_zero_check.
	 */
	vmx_setup_me_spte_mask();

	kvm_configure_mmu(enable_ept, 0, vmx_get_max_tdp_level(),
			  ept_caps_to_lpage_level(vmx_capability.ept));

	/*
	 * Only enable PML when hardware supports PML feature, and both EPT
	 * and EPT A/D bit features are enabled -- PML depends on them to work.
	 */
	if (!enable_ept || !enable_ept_ad_bits || !cpu_has_vmx_pml())
		enable_pml = 0;

	if (!enable_pml)
		vmx_x86_ops.cpu_dirty_log_size = 0;

	if (!cpu_has_vmx_preemption_timer())
		enable_preemption_timer = false;

	if (enable_preemption_timer) {
		u64 use_timer_freq = 5000ULL * 1000 * 1000;

		cpu_preemption_timer_multi =
			vmcs_config.misc &amp; VMX_MISC_PREEMPTION_TIMER_RATE_MASK;

		if (tsc_khz)
			use_timer_freq = (u64)tsc_khz * 1000;
		use_timer_freq &gt;&gt;= cpu_preemption_timer_multi;

		/*
		 * KVM &quot;disables&quot; the preemption timer by setting it to its max
		 * value.  Don&#x27;t use the timer if it might cause spurious exits
		 * at a rate faster than 0.1 Hz (of uninterrupted guest time).
		 */
		if (use_timer_freq &gt; 0xffffffffu / 10)
			enable_preemption_timer = false;
	}

	if (!enable_preemption_timer) {
		vmx_x86_ops.set_hv_timer = NULL;
		vmx_x86_ops.cancel_hv_timer = NULL;
		vmx_x86_ops.request_immediate_exit = __kvm_request_immediate_exit;
	}

	kvm_caps.supported_mce_cap |= MCG_LMCE_P;
	kvm_caps.supported_mce_cap |= MCG_CMCI_P;

	if (pt_mode != PT_MODE_SYSTEM &amp;&amp; pt_mode != PT_MODE_HOST_GUEST)
		return -EINVAL;
	if (!enable_ept || !enable_pmu || !cpu_has_vmx_intel_pt())
		pt_mode = PT_MODE_SYSTEM;
	if (pt_mode == PT_MODE_HOST_GUEST)
		vmx_init_ops.handle_intel_pt_intr = vmx_handle_intel_pt_intr;
	else
		vmx_init_ops.handle_intel_pt_intr = NULL;

	setup_default_sgx_lepubkeyhash();

	if (nested) {
		nested_vmx_setup_ctls_msrs(&amp;vmcs_config, vmx_capability.ept);

		r = nested_vmx_hardware_setup(kvm_vmx_exit_handlers);
		if (r)
			return r;
	}

	vmx_set_cpu_caps();

	r = alloc_kvm_area();
	if (r &amp;&amp; nested)
		nested_vmx_hardware_unsetup();

	kvm_set_posted_intr_wakeup_handler(pi_wakeup_handler);

	return r;
}

static struct kvm_x86_init_ops vmx_init_ops __initdata = {
	.cpu_has_kvm_support = cpu_has_kvm_support,
	.disabled_by_bios = vmx_disabled_by_bios,
	.check_processor_compatibility = vmx_check_processor_compat,
	.hardware_setup = hardware_setup,
	.handle_intel_pt_intr = NULL,

	.runtime_ops = &amp;vmx_x86_ops,
	.pmu_ops = &amp;intel_pmu_ops,
};

static void vmx_cleanup_l1d_flush(void)
{
<yellow>	if (vmx_l1d_flush_pages) {</yellow>
<yellow>		free_pages((unsigned long)vmx_l1d_flush_pages, L1D_CACHE_ORDER);</yellow>
<yellow>		vmx_l1d_flush_pages = NULL;</yellow>
	}
	/* Restore state so sysfs ignores VMX */
<yellow>	l1tf_vmx_mitigation = VMENTER_L1D_FLUSH_AUTO;</yellow>
}

static void vmx_exit(void)
<yellow>{</yellow>
#ifdef CONFIG_KEXEC_CORE
<yellow>	RCU_INIT_POINTER(crash_vmclear_loaded_vmcss, NULL);</yellow>
<yellow>	synchronize_rcu();</yellow>
#endif

	kvm_exit();

#if IS_ENABLED(CONFIG_HYPERV)
	if (static_branch_unlikely(&amp;enable_evmcs)) {
		int cpu;
		struct hv_vp_assist_page *vp_ap;
		/*
		 * Reset everything to support using non-enlightened VMCS
		 * access later (e.g. when we reload the module with
		 * enlightened_vmcs=0)
		 */
<yellow>		for_each_online_cpu(cpu) {</yellow>
<yellow>			vp_ap =	hv_get_vp_assist_page(cpu);</yellow>

			if (!vp_ap)
				continue;

<yellow>			vp_ap->nested_control.features.directhypercall = 0;</yellow>
<yellow>			vp_ap->current_nested_vmcs = 0;</yellow>
<yellow>			vp_ap->enlighten_vmentry = 0;</yellow>
		}

<yellow>		static_branch_disable(&enable_evmcs);</yellow>
	}
#endif
<yellow>	vmx_cleanup_l1d_flush();</yellow>

<yellow>	allow_smaller_maxphyaddr = false;</yellow>
<yellow>}</yellow>
module_exit(vmx_exit);

static int __init vmx_init(void)
{
	int r, cpu;

#if IS_ENABLED(CONFIG_HYPERV)
	/*
	 * Enlightened VMCS usage should be recommended and the host needs
	 * to support eVMCS v1 or above. We can also disable eVMCS support
	 * with module parameter.
	 */
	if (enlightened_vmcs &amp;&amp;
	    ms_hyperv.hints &amp; HV_X64_ENLIGHTENED_VMCS_RECOMMENDED &amp;&amp;
	    (ms_hyperv.nested_features &amp; HV_X64_ENLIGHTENED_VMCS_VERSION) &gt;=
	    KVM_EVMCS_VERSION) {

		/* Check that we have assist pages on all online CPUs */
		for_each_online_cpu(cpu) {
			if (!hv_get_vp_assist_page(cpu)) {
				enlightened_vmcs = false;
				break;
			}
		}

		if (enlightened_vmcs) {
			pr_info(&quot;KVM: vmx: using Hyper-V Enlightened VMCS\n&quot;);
			static_branch_enable(&amp;enable_evmcs);
		}

		if (ms_hyperv.nested_features &amp; HV_X64_NESTED_DIRECT_FLUSH)
			vmx_x86_ops.enable_direct_tlbflush
				= hv_enable_direct_tlbflush;

	} else {
		enlightened_vmcs = false;
	}
#endif

	r = kvm_init(&amp;vmx_init_ops, sizeof(struct vcpu_vmx),
		     __alignof__(struct vcpu_vmx), THIS_MODULE);
	if (r)
		return r;

	/*
	 * Must be called after kvm_init() so enable_ept is properly set
	 * up. Hand the parameter mitigation value in which was stored in
	 * the pre module init parser. If no parameter was given, it will
	 * contain &#x27;auto&#x27; which will be turned into the default &#x27;cond&#x27;
	 * mitigation mode.
	 */
	r = vmx_setup_l1d_flush(vmentry_l1d_flush_param);
	if (r) {
		vmx_exit();
		return r;
	}

	vmx_setup_fb_clear_ctrl();

	for_each_possible_cpu(cpu) {
		INIT_LIST_HEAD(&amp;per_cpu(loaded_vmcss_on_cpu, cpu));

		pi_init_cpu(cpu);
	}

#ifdef CONFIG_KEXEC_CORE
	rcu_assign_pointer(crash_vmclear_loaded_vmcss,
			   crash_vmclear_local_loaded_vmcss);
#endif
	vmx_check_vmcs12_offsets();

	/*
	 * Shadow paging doesn&#x27;t have a (further) performance penalty
	 * from GUEST_MAXPHYADDR &lt; HOST_MAXPHYADDR so enable it
	 * by default
	 */
	if (!enable_ept)
		allow_smaller_maxphyaddr = true;

	return 0;
}
module_init(vmx_init);


</code></pre></td></tr></table>
</body>
</html>
