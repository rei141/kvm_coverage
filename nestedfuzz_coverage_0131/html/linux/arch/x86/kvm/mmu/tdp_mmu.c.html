<doctype html>
<html lang="ja">
<head>
<meta charset="utf-8">
<script src="https://cdn.rawgit.com/google/code-prettify/master/loader/run_prettify.js"></script>
<style>
    code{
        font-family:Monaco, Menlo, Consolas, 'Courier New', Courier, monospace, sans-serif;
        font-size: 14px;
        line-height: 18px;
        overflow: auto;
        resize: horizontal;
    }
    code_line{
        font-family: Monaco, Menlo, Consolas, 'Courier New', Courier, monospace, sans-serif;;
        font-size: 14px;
        line-height: 18px;
        overflow: auto;
        resize: horizontal;
        color:#303134;
    }
    blue{
        background-color:#BEEDE8;
    }
    yellow{
        background-color:#FFFF99;
    }
    red{
        background-color:#FF99AC;
    }
</style>

</head>
<body>
<table summary='blob content' class='blob' cellspacing="15">
<tr><td align="right"><pre><code_line>1.
2.
3.
4.
5.
6.
7.
8.
9.
10.
11.
12.
13.
14.
15.
16.
17.
18.
19.
20.
21.
22.
23.
24.
25.
26.
27.
28.
29.
30.
31.
32.
33.
34.
35.
36.
37.
38.
39.
40.
41.
42.
43.
44.
45.
46.
47.
48.
49.
50.
51.
52.
53.
54.
55.
56.
57.
58.
59.
60.
61.
62.
63.
64.
65.
66.
67.
68.
69.
70.
71.
72.
73.
74.
75.
76.
77.
78.
79.
80.
81.
82.
83.
84.
85.
86.
87.
88.
89.
90.
91.
92.
93.
94.
95.
96.
97.
98.
99.
100.
101.
102.
103.
104.
105.
106.
107.
108.
109.
110.
111.
112.
113.
114.
115.
116.
117.
118.
119.
120.
121.
122.
123.
124.
125.
126.
127.
128.
129.
130.
131.
132.
133.
134.
135.
136.
137.
138.
139.
140.
141.
142.
143.
144.
145.
146.
147.
148.
149.
150.
151.
152.
153.
154.
155.
156.
157.
158.
159.
160.
161.
162.
163.
164.
165.
166.
167.
168.
169.
170.
171.
172.
173.
174.
175.
176.
177.
178.
179.
180.
181.
182.
183.
184.
185.
186.
187.
188.
189.
190.
191.
192.
193.
194.
195.
196.
197.
198.
199.
200.
201.
202.
203.
204.
205.
206.
207.
208.
209.
210.
211.
212.
213.
214.
215.
216.
217.
218.
219.
220.
221.
222.
223.
224.
225.
226.
227.
228.
229.
230.
231.
232.
233.
234.
235.
236.
237.
238.
239.
240.
241.
242.
243.
244.
245.
246.
247.
248.
249.
250.
251.
252.
253.
254.
255.
256.
257.
258.
259.
260.
261.
262.
263.
264.
265.
266.
267.
268.
269.
270.
271.
272.
273.
274.
275.
276.
277.
278.
279.
280.
281.
282.
283.
284.
285.
286.
287.
288.
289.
290.
291.
292.
293.
294.
295.
296.
297.
298.
299.
300.
301.
302.
303.
304.
305.
306.
307.
308.
309.
310.
311.
312.
313.
314.
315.
316.
317.
318.
319.
320.
321.
322.
323.
324.
325.
326.
327.
328.
329.
330.
331.
332.
333.
334.
335.
336.
337.
338.
339.
340.
341.
342.
343.
344.
345.
346.
347.
348.
349.
350.
351.
352.
353.
354.
355.
356.
357.
358.
359.
360.
361.
362.
363.
364.
365.
366.
367.
368.
369.
370.
371.
372.
373.
374.
375.
376.
377.
378.
379.
380.
381.
382.
383.
384.
385.
386.
387.
388.
389.
390.
391.
392.
393.
394.
395.
396.
397.
398.
399.
400.
401.
402.
403.
404.
405.
406.
407.
408.
409.
410.
411.
412.
413.
414.
415.
416.
417.
418.
419.
420.
421.
422.
423.
424.
425.
426.
427.
428.
429.
430.
431.
432.
433.
434.
435.
436.
437.
438.
439.
440.
441.
442.
443.
444.
445.
446.
447.
448.
449.
450.
451.
452.
453.
454.
455.
456.
457.
458.
459.
460.
461.
462.
463.
464.
465.
466.
467.
468.
469.
470.
471.
472.
473.
474.
475.
476.
477.
478.
479.
480.
481.
482.
483.
484.
485.
486.
487.
488.
489.
490.
491.
492.
493.
494.
495.
496.
497.
498.
499.
500.
501.
502.
503.
504.
505.
506.
507.
508.
509.
510.
511.
512.
513.
514.
515.
516.
517.
518.
519.
520.
521.
522.
523.
524.
525.
526.
527.
528.
529.
530.
531.
532.
533.
534.
535.
536.
537.
538.
539.
540.
541.
542.
543.
544.
545.
546.
547.
548.
549.
550.
551.
552.
553.
554.
555.
556.
557.
558.
559.
560.
561.
562.
563.
564.
565.
566.
567.
568.
569.
570.
571.
572.
573.
574.
575.
576.
577.
578.
579.
580.
581.
582.
583.
584.
585.
586.
587.
588.
589.
590.
591.
592.
593.
594.
595.
596.
597.
598.
599.
600.
601.
602.
603.
604.
605.
606.
607.
608.
609.
610.
611.
612.
613.
614.
615.
616.
617.
618.
619.
620.
621.
622.
623.
624.
625.
626.
627.
628.
629.
630.
631.
632.
633.
634.
635.
636.
637.
638.
639.
640.
641.
642.
643.
644.
645.
646.
647.
648.
649.
650.
651.
652.
653.
654.
655.
656.
657.
658.
659.
660.
661.
662.
663.
664.
665.
666.
667.
668.
669.
670.
671.
672.
673.
674.
675.
676.
677.
678.
679.
680.
681.
682.
683.
684.
685.
686.
687.
688.
689.
690.
691.
692.
693.
694.
695.
696.
697.
698.
699.
700.
701.
702.
703.
704.
705.
706.
707.
708.
709.
710.
711.
712.
713.
714.
715.
716.
717.
718.
719.
720.
721.
722.
723.
724.
725.
726.
727.
728.
729.
730.
731.
732.
733.
734.
735.
736.
737.
738.
739.
740.
741.
742.
743.
744.
745.
746.
747.
748.
749.
750.
751.
752.
753.
754.
755.
756.
757.
758.
759.
760.
761.
762.
763.
764.
765.
766.
767.
768.
769.
770.
771.
772.
773.
774.
775.
776.
777.
778.
779.
780.
781.
782.
783.
784.
785.
786.
787.
788.
789.
790.
791.
792.
793.
794.
795.
796.
797.
798.
799.
800.
801.
802.
803.
804.
805.
806.
807.
808.
809.
810.
811.
812.
813.
814.
815.
816.
817.
818.
819.
820.
821.
822.
823.
824.
825.
826.
827.
828.
829.
830.
831.
832.
833.
834.
835.
836.
837.
838.
839.
840.
841.
842.
843.
844.
845.
846.
847.
848.
849.
850.
851.
852.
853.
854.
855.
856.
857.
858.
859.
860.
861.
862.
863.
864.
865.
866.
867.
868.
869.
870.
871.
872.
873.
874.
875.
876.
877.
878.
879.
880.
881.
882.
883.
884.
885.
886.
887.
888.
889.
890.
891.
892.
893.
894.
895.
896.
897.
898.
899.
900.
901.
902.
903.
904.
905.
906.
907.
908.
909.
910.
911.
912.
913.
914.
915.
916.
917.
918.
919.
920.
921.
922.
923.
924.
925.
926.
927.
928.
929.
930.
931.
932.
933.
934.
935.
936.
937.
938.
939.
940.
941.
942.
943.
944.
945.
946.
947.
948.
949.
950.
951.
952.
953.
954.
955.
956.
957.
958.
959.
960.
961.
962.
963.
964.
965.
966.
967.
968.
969.
970.
971.
972.
973.
974.
975.
976.
977.
978.
979.
980.
981.
982.
983.
984.
985.
986.
987.
988.
989.
990.
991.
992.
993.
994.
995.
996.
997.
998.
999.
1000.
1001.
1002.
1003.
1004.
1005.
1006.
1007.
1008.
1009.
1010.
1011.
1012.
1013.
1014.
1015.
1016.
1017.
1018.
1019.
1020.
1021.
1022.
1023.
1024.
1025.
1026.
1027.
1028.
1029.
1030.
1031.
1032.
1033.
1034.
1035.
1036.
1037.
1038.
1039.
1040.
1041.
1042.
1043.
1044.
1045.
1046.
1047.
1048.
1049.
1050.
1051.
1052.
1053.
1054.
1055.
1056.
1057.
1058.
1059.
1060.
1061.
1062.
1063.
1064.
1065.
1066.
1067.
1068.
1069.
1070.
1071.
1072.
1073.
1074.
1075.
1076.
1077.
1078.
1079.
1080.
1081.
1082.
1083.
1084.
1085.
1086.
1087.
1088.
1089.
1090.
1091.
1092.
1093.
1094.
1095.
1096.
1097.
1098.
1099.
1100.
1101.
1102.
1103.
1104.
1105.
1106.
1107.
1108.
1109.
1110.
1111.
1112.
1113.
1114.
1115.
1116.
1117.
1118.
1119.
1120.
1121.
1122.
1123.
1124.
1125.
1126.
1127.
1128.
1129.
1130.
1131.
1132.
1133.
1134.
1135.
1136.
1137.
1138.
1139.
1140.
1141.
1142.
1143.
1144.
1145.
1146.
1147.
1148.
1149.
1150.
1151.
1152.
1153.
1154.
1155.
1156.
1157.
1158.
1159.
1160.
1161.
1162.
1163.
1164.
1165.
1166.
1167.
1168.
1169.
1170.
1171.
1172.
1173.
1174.
1175.
1176.
1177.
1178.
1179.
1180.
1181.
1182.
1183.
1184.
1185.
1186.
1187.
1188.
1189.
1190.
1191.
1192.
1193.
1194.
1195.
1196.
1197.
1198.
1199.
1200.
1201.
1202.
1203.
1204.
1205.
1206.
1207.
1208.
1209.
1210.
1211.
1212.
1213.
1214.
1215.
1216.
1217.
1218.
1219.
1220.
1221.
1222.
1223.
1224.
1225.
1226.
1227.
1228.
1229.
1230.
1231.
1232.
1233.
1234.
1235.
1236.
1237.
1238.
1239.
1240.
1241.
1242.
1243.
1244.
1245.
1246.
1247.
1248.
1249.
1250.
1251.
1252.
1253.
1254.
1255.
1256.
1257.
1258.
1259.
1260.
1261.
1262.
1263.
1264.
1265.
1266.
1267.
1268.
1269.
1270.
1271.
1272.
1273.
1274.
1275.
1276.
1277.
1278.
1279.
1280.
1281.
1282.
1283.
1284.
1285.
1286.
1287.
1288.
1289.
1290.
1291.
1292.
1293.
1294.
1295.
1296.
1297.
1298.
1299.
1300.
1301.
1302.
1303.
1304.
1305.
1306.
1307.
1308.
1309.
1310.
1311.
1312.
1313.
1314.
1315.
1316.
1317.
1318.
1319.
1320.
1321.
1322.
1323.
1324.
1325.
1326.
1327.
1328.
1329.
1330.
1331.
1332.
1333.
1334.
1335.
1336.
1337.
1338.
1339.
1340.
1341.
1342.
1343.
1344.
1345.
1346.
1347.
1348.
1349.
1350.
1351.
1352.
1353.
1354.
1355.
1356.
1357.
1358.
1359.
1360.
1361.
1362.
1363.
1364.
1365.
1366.
1367.
1368.
1369.
1370.
1371.
1372.
1373.
1374.
1375.
1376.
1377.
1378.
1379.
1380.
1381.
1382.
1383.
1384.
1385.
1386.
1387.
1388.
1389.
1390.
1391.
1392.
1393.
1394.
1395.
1396.
1397.
1398.
1399.
1400.
1401.
1402.
1403.
1404.
1405.
1406.
1407.
1408.
1409.
1410.
1411.
1412.
1413.
1414.
1415.
1416.
1417.
1418.
1419.
1420.
1421.
1422.
1423.
1424.
1425.
1426.
1427.
1428.
1429.
1430.
1431.
1432.
1433.
1434.
1435.
1436.
1437.
1438.
1439.
1440.
1441.
1442.
1443.
1444.
1445.
1446.
1447.
1448.
1449.
1450.
1451.
1452.
1453.
1454.
1455.
1456.
1457.
1458.
1459.
1460.
1461.
1462.
1463.
1464.
1465.
1466.
1467.
1468.
1469.
1470.
1471.
1472.
1473.
1474.
1475.
1476.
1477.
1478.
1479.
1480.
1481.
1482.
1483.
1484.
1485.
1486.
1487.
1488.
1489.
1490.
1491.
1492.
1493.
1494.
1495.
1496.
1497.
1498.
1499.
1500.
1501.
1502.
1503.
1504.
1505.
1506.
1507.
1508.
1509.
1510.
1511.
1512.
1513.
1514.
1515.
1516.
1517.
1518.
1519.
1520.
1521.
1522.
1523.
1524.
1525.
1526.
1527.
1528.
1529.
1530.
1531.
1532.
1533.
1534.
1535.
1536.
1537.
1538.
1539.
1540.
1541.
1542.
1543.
1544.
1545.
1546.
1547.
1548.
1549.
1550.
1551.
1552.
1553.
1554.
1555.
1556.
1557.
1558.
1559.
1560.
1561.
1562.
1563.
1564.
1565.
1566.
1567.
1568.
1569.
1570.
1571.
1572.
1573.
1574.
1575.
1576.
1577.
1578.
1579.
1580.
1581.
1582.
1583.
1584.
1585.
1586.
1587.
1588.
1589.
1590.
1591.
1592.
1593.
1594.
1595.
1596.
1597.
1598.
1599.
1600.
1601.
1602.
1603.
1604.
1605.
1606.
1607.
1608.
1609.
1610.
1611.
1612.
1613.
1614.
1615.
1616.
1617.
1618.
1619.
1620.
1621.
1622.
1623.
1624.
1625.
1626.
1627.
1628.
1629.
1630.
1631.
1632.
1633.
1634.
1635.
1636.
1637.
1638.
1639.
1640.
1641.
1642.
1643.
1644.
1645.
1646.
1647.
1648.
1649.
1650.
1651.
1652.
1653.
1654.
1655.
1656.
1657.
1658.
1659.
1660.
1661.
1662.
1663.
1664.
1665.
1666.
1667.
1668.
1669.
1670.
1671.
1672.
1673.
1674.
1675.
1676.
1677.
1678.
1679.
1680.
1681.
1682.
1683.
1684.
1685.
1686.
1687.
1688.
1689.
1690.
1691.
1692.
1693.
1694.
1695.
1696.
1697.
1698.
1699.
1700.
1701.
1702.
1703.
1704.
1705.
1706.
1707.
1708.
1709.
1710.
1711.
1712.
1713.
1714.
1715.
1716.
1717.
1718.
1719.
1720.
1721.
1722.
1723.
1724.
1725.
1726.
1727.
1728.
1729.
1730.
1731.
1732.
1733.
1734.
1735.
1736.
1737.
1738.
1739.
1740.
1741.
1742.
1743.
1744.
1745.
1746.
1747.
1748.
1749.
1750.
1751.
1752.
1753.
1754.
1755.
1756.
1757.
1758.
1759.
1760.
1761.
1762.
1763.
1764.
1765.
1766.
1767.
1768.
1769.
1770.
1771.
1772.
1773.
1774.
1775.
1776.
1777.
1778.
1779.
1780.
1781.
1782.
1783.
1784.
1785.
1786.
1787.
1788.
1789.
1790.
1791.
1792.
1793.
1794.
1795.
1796.
1797.
1798.
1799.
1800.
1801.
1802.
1803.
1804.
1805.
1806.
1807.
1808.
1809.
1810.
1811.
1812.
1813.
1814.
1815.
1816.
1817.
1818.
1819.
1820.
1821.
1822.
1823.
1824.
1825.
1826.
1827.
1828.
1829.
1830.
1831.
1832.
1833.
1834.
1835.
1836.
1837.
1838.
1839.
1840.
1841.
1842.
1843.
1844.
1845.
1846.
1847.
1848.
1849.
1850.
1851.
1852.
1853.
1854.
1855.
1856.
1857.
1858.
1859.
1860.
1861.
1862.
1863.
1864.
1865.
1866.
1867.
1868.
1869.
1870.
1871.
1872.
1873.
1874.
1875.
1876.
1877.
1878.
1879.
1880.
1881.
1882.
1883.
1884.
1885.
1886.
1887.
1888.
1889.
1890.
1891.
1892.
1893.
1894.
1895.
1896.
1897.
1898.
1899.
1900.
1901.
1902.
1903.
1904.
1905.
1906.
1907.
1908.
1909.
1910.
1911.
1912.
1913.
</code_line></pre></td>
<td class='lines'><pre><code class="prettyprint">// SPDX-License-Identifier: GPL-2.0

#include &quot;mmu.h&quot;
#include &quot;mmu_internal.h&quot;
#include &quot;mmutrace.h&quot;
#include &quot;tdp_iter.h&quot;
#include &quot;tdp_mmu.h&quot;
#include &quot;spte.h&quot;

#include &lt;asm/cmpxchg.h&gt;
#include &lt;trace/events/kvm.h&gt;

static bool __read_mostly tdp_mmu_enabled = true;
module_param_named(tdp_mmu, tdp_mmu_enabled, bool, 0644);

/* Initializes the TDP MMU for the VM, if enabled. */
int kvm_mmu_init_tdp_mmu(struct kvm *kvm)
{
	struct workqueue_struct *wq;

<blue>	if (!tdp_enabled || !READ_ONCE(tdp_mmu_enabled))</blue>
		return 0;

<blue>	wq = alloc_workqueue("kvm", WQ_UNBOUND|WQ_MEM_RECLAIM|WQ_CPU_INTENSIVE, 0);</blue>
	if (!wq)
		return -ENOMEM;

	/* This should not be changed for the lifetime of the VM. */
<blue>	kvm->arch.tdp_mmu_enabled = true;</blue>
	INIT_LIST_HEAD(&amp;kvm-&gt;arch.tdp_mmu_roots);
	spin_lock_init(&amp;kvm-&gt;arch.tdp_mmu_pages_lock);
	INIT_LIST_HEAD(&amp;kvm-&gt;arch.tdp_mmu_pages);
	kvm-&gt;arch.tdp_mmu_zap_wq = wq;
	return 1;
<blue>}</blue>

/* Arbitrarily returns true so that this may be used in if statements. */
static __always_inline bool kvm_lockdep_assert_mmu_lock_held(struct kvm *kvm,
							     bool shared)
{
	if (shared)
		lockdep_assert_held_read(&amp;kvm-&gt;mmu_lock);
	else
		lockdep_assert_held_write(&amp;kvm-&gt;mmu_lock);

	return true;
}

void kvm_mmu_uninit_tdp_mmu(struct kvm *kvm)
{
<yellow>	if (!kvm->arch.tdp_mmu_enabled)</yellow>
		return;

	/* Also waits for any queued work items.  */
<yellow>	destroy_workqueue(kvm->arch.tdp_mmu_zap_wq);</yellow>

<yellow>	WARN_ON(!list_empty(&kvm->arch.tdp_mmu_pages));</yellow>
<yellow>	WARN_ON(!list_empty(&kvm->arch.tdp_mmu_roots));</yellow>

	/*
	 * Ensure that all the outstanding RCU callbacks to free shadow pages
	 * can run before the VM is torn down.  Work items on tdp_mmu_zap_wq
	 * can call kvm_tdp_mmu_put_root and create new callbacks.
	 */
<yellow>	rcu_barrier();</yellow>
<yellow>}</yellow>

static void tdp_mmu_free_sp(struct kvm_mmu_page *sp)
{
<yellow>	free_page((unsigned long)sp->spt);</yellow>
	kmem_cache_free(mmu_page_header_cache, sp);
}

/*
 * This is called through call_rcu in order to free TDP page table memory
 * safely with respect to other kernel threads that may be operating on
 * the memory.
 * By only accessing TDP MMU page table memory in an RCU read critical
 * section, and freeing it after a grace period, lockless access to that
 * memory won&#x27;t use it after it is freed.
 */
static void tdp_mmu_free_sp_rcu_callback(struct rcu_head *head)
{
	struct kvm_mmu_page *sp = container_of(head, struct kvm_mmu_page,
					       rcu_head);

<yellow>	tdp_mmu_free_sp(sp);</yellow>
}

static void tdp_mmu_zap_root(struct kvm *kvm, struct kvm_mmu_page *root,
			     bool shared);

static void tdp_mmu_zap_root_work(struct work_struct *work)
{
	struct kvm_mmu_page *root = container_of(work, struct kvm_mmu_page,
						 tdp_mmu_async_work);
<yellow>	struct kvm *kvm = root->tdp_mmu_async_data;</yellow>

	read_lock(&amp;kvm-&gt;mmu_lock);

	/*
	 * A TLB flush is not necessary as KVM performs a local TLB flush when
	 * allocating a new root (see kvm_mmu_load()), and when migrating vCPU
	 * to a different pCPU.  Note, the local TLB flush on reuse also
	 * invalidates any paging-structure-cache entries, i.e. TLB entries for
	 * intermediate paging structures, that may be zapped, as such entries
	 * are associated with the ASID on both VMX and SVM.
	 */
	tdp_mmu_zap_root(kvm, root, true);

	/*
	 * Drop the refcount using kvm_tdp_mmu_put_root() to test its logic for
	 * avoiding an infinite loop.  By design, the root is reachable while
	 * it&#x27;s being asynchronously zapped, thus a different task can put its
	 * last reference, i.e. flowing through kvm_tdp_mmu_put_root() for an
	 * asynchronously zapped root is unavoidable.
	 */
	kvm_tdp_mmu_put_root(kvm, root, true);

	read_unlock(&amp;kvm-&gt;mmu_lock);
}

static void tdp_mmu_schedule_zap_root(struct kvm *kvm, struct kvm_mmu_page *root)
{
	root-&gt;tdp_mmu_async_data = kvm;
	INIT_WORK(&amp;root-&gt;tdp_mmu_async_work, tdp_mmu_zap_root_work);
	queue_work(kvm-&gt;arch.tdp_mmu_zap_wq, &amp;root-&gt;tdp_mmu_async_work);
}

static inline bool kvm_tdp_root_mark_invalid(struct kvm_mmu_page *page)
{
<blue>	union kvm_mmu_page_role role = page->role;</blue>
	role.invalid = true;

	/* No need to use cmpxchg, only the invalid bit can change.  */
	role.word = xchg(&amp;page-&gt;role.word, role.word);
	return role.invalid;
}

<blue>void kvm_tdp_mmu_put_root(struct kvm *kvm, struct kvm_mmu_page *root,</blue>
			  bool shared)
{
	kvm_lockdep_assert_mmu_lock_held(kvm, shared);

<blue>	if (!refcount_dec_and_test(&root->tdp_mmu_root_count))</blue>
		return;

<blue>	WARN_ON(!root->tdp_mmu_page);</blue>

	/*
	 * The root now has refcount=0.  It is valid, but readers already
	 * cannot acquire a reference to it because kvm_tdp_mmu_get_root()
	 * rejects it.  This remains true for the rest of the execution
	 * of this function, because readers visit valid roots only
	 * (except for tdp_mmu_zap_root_work(), which however
	 * does not acquire any reference itself).
	 *
	 * Even though there are flows that need to visit all roots for
	 * correctness, they all take mmu_lock for write, so they cannot yet
	 * run concurrently. The same is true after kvm_tdp_root_mark_invalid,
	 * since the root still has refcount=0.
	 *
	 * However, tdp_mmu_zap_root can yield, and writers do not expect to
	 * see refcount=0 (see for example kvm_tdp_mmu_invalidate_all_roots()).
	 * So the root temporarily gets an extra reference, going to refcount=1
	 * while staying invalid.  Readers still cannot acquire any reference;
	 * but writers are now allowed to run if tdp_mmu_zap_root yields and
	 * they might take an extra reference if they themselves yield.
	 * Therefore, when the reference is given back by the worker,
	 * there is no guarantee that the refcount is still 1.  If not, whoever
	 * puts the last reference will free the page, but they will not have to
	 * zap the root because a root cannot go from invalid to valid.
	 */
<blue>	if (!kvm_tdp_root_mark_invalid(root)) {</blue>
<blue>		refcount_set(&root->tdp_mmu_root_count, 1);</blue>

		/*
		 * Zapping the root in a worker is not just &quot;nice to have&quot;;
		 * it is required because kvm_tdp_mmu_invalidate_all_roots()
		 * skips already-invalid roots.  If kvm_tdp_mmu_put_root() did
		 * not add the root to the workqueue, kvm_tdp_mmu_zap_all_fast()
		 * might return with some roots not zapped yet.
		 */
		tdp_mmu_schedule_zap_root(kvm, root);
		return;
	}

<blue>	spin_lock(&kvm->arch.tdp_mmu_pages_lock);</blue>
	list_del_rcu(&amp;root-&gt;link);
	spin_unlock(&amp;kvm-&gt;arch.tdp_mmu_pages_lock);
	call_rcu(&amp;root-&gt;rcu_head, tdp_mmu_free_sp_rcu_callback);
<blue>}</blue>

/*
 * Returns the next root after @prev_root (or the first root if @prev_root is
 * NULL).  A reference to the returned root is acquired, and the reference to
 * @prev_root is released (the caller obviously must hold a reference to
 * @prev_root if it&#x27;s non-NULL).
 *
 * If @only_valid is true, invalid roots are skipped.
 *
 * Returns NULL if the end of tdp_mmu_roots was reached.
 */
static struct kvm_mmu_page *tdp_mmu_next_root(struct kvm *kvm,
					      struct kvm_mmu_page *prev_root,
					      bool shared, bool only_valid)
<blue>{</blue>
	struct kvm_mmu_page *next_root;

<blue>	rcu_read_lock();</blue>

	if (prev_root)
<blue>		next_root = list_next_or_null_rcu(&kvm->arch.tdp_mmu_roots,</blue>
						  &amp;prev_root-&gt;link,
						  typeof(*prev_root), link);
	else
<blue>		next_root = list_first_or_null_rcu(&kvm->arch.tdp_mmu_roots,</blue>
						   typeof(*next_root), link);

<blue>	while (next_root) {</blue>
<blue>		if ((!only_valid || !next_root->role.invalid) &&</blue>
<blue>		    kvm_tdp_mmu_get_root(next_root))</blue>
			break;

<yellow>		next_root = list_next_or_null_rcu(&kvm->arch.tdp_mmu_roots,</yellow>
				&amp;next_root-&gt;link, typeof(*next_root), link);
	}

<blue>	rcu_read_unlock();</blue>

	if (prev_root)
<blue>		kvm_tdp_mmu_put_root(kvm, prev_root, shared);</blue>

	return next_root;
}

/*
 * Note: this iterator gets and puts references to the roots it iterates over.
 * This makes it safe to release the MMU lock and yield within the loop, but
 * if exiting the loop early, the caller must drop the reference to the most
 * recent root. (Unless keeping a live reference is desirable.)
 *
 * If shared is set, this function is operating under the MMU lock in read
 * mode. In the unlikely event that this thread must free a root, the lock
 * will be temporarily dropped and reacquired in write mode.
 */
#define __for_each_tdp_mmu_root_yield_safe(_kvm, _root, _as_id, _shared, _only_valid)\
	for (_root = tdp_mmu_next_root(_kvm, NULL, _shared, _only_valid);	\
	     _root;								\
	     _root = tdp_mmu_next_root(_kvm, _root, _shared, _only_valid))	\
		if (kvm_lockdep_assert_mmu_lock_held(_kvm, _shared) &amp;&amp;		\
		    kvm_mmu_page_as_id(_root) != _as_id) {			\
		} else

#define for_each_valid_tdp_mmu_root_yield_safe(_kvm, _root, _as_id, _shared)	\
	__for_each_tdp_mmu_root_yield_safe(_kvm, _root, _as_id, _shared, true)

#define for_each_tdp_mmu_root_yield_safe(_kvm, _root, _as_id)			\
	__for_each_tdp_mmu_root_yield_safe(_kvm, _root, _as_id, false, false)

/*
 * Iterate over all TDP MMU roots.  Requires that mmu_lock be held for write,
 * the implication being that any flow that holds mmu_lock for read is
 * inherently yield-friendly and should use the yield-safe variant above.
 * Holding mmu_lock for write obviates the need for RCU protection as the list
 * is guaranteed to be stable.
 */
#define for_each_tdp_mmu_root(_kvm, _root, _as_id)			\
	list_for_each_entry(_root, &amp;_kvm-&gt;arch.tdp_mmu_roots, link)	\
		if (kvm_lockdep_assert_mmu_lock_held(_kvm, false) &amp;&amp;	\
		    kvm_mmu_page_as_id(_root) != _as_id) {		\
		} else

static struct kvm_mmu_page *tdp_mmu_alloc_sp(struct kvm_vcpu *vcpu)
{
	struct kvm_mmu_page *sp;

<blue>	sp = kvm_mmu_memory_cache_alloc(&vcpu->arch.mmu_page_header_cache);</blue>
	sp-&gt;spt = kvm_mmu_memory_cache_alloc(&amp;vcpu-&gt;arch.mmu_shadow_page_cache);

	return sp;
}

static void tdp_mmu_init_sp(struct kvm_mmu_page *sp, tdp_ptep_t sptep,
			    gfn_t gfn, union kvm_mmu_page_role role)
{
<blue>	set_page_private(virt_to_page(sp->spt), (unsigned long)sp);</blue>

	sp-&gt;role = role;
	sp-&gt;gfn = gfn;
	sp-&gt;ptep = sptep;
	sp-&gt;tdp_mmu_page = true;

<yellow>	trace_kvm_mmu_get_page(sp, true);</yellow>
<blue>}</blue>

static void tdp_mmu_init_child_sp(struct kvm_mmu_page *child_sp,
				  struct tdp_iter *iter)
{
	struct kvm_mmu_page *parent_sp;
	union kvm_mmu_page_role role;

<blue>	parent_sp = sptep_to_sp(rcu_dereference(iter->sptep));</blue>

	role = parent_sp-&gt;role;
	role.level--;

	tdp_mmu_init_sp(child_sp, iter-&gt;sptep, iter-&gt;gfn, role);
}

hpa_t kvm_tdp_mmu_get_vcpu_root_hpa(struct kvm_vcpu *vcpu)
<blue>{</blue>
<blue>	union kvm_mmu_page_role role = vcpu->arch.mmu->root_role;</blue>
	struct kvm *kvm = vcpu-&gt;kvm;
	struct kvm_mmu_page *root;

	lockdep_assert_held_write(&amp;kvm-&gt;mmu_lock);

	/*
	 * Check for an existing root before allocating a new one.  Note, the
	 * role check prevents consuming an invalid root.
	 */
<blue>	for_each_tdp_mmu_root(kvm, root, kvm_mmu_role_as_id(role)) {</blue>
<blue>		if (root->role.word == role.word &&</blue>
<yellow>		    kvm_tdp_mmu_get_root(root))</yellow>
			goto out;
	}

<blue>	root = tdp_mmu_alloc_sp(vcpu);</blue>
	tdp_mmu_init_sp(root, NULL, 0, role);

	refcount_set(&amp;root-&gt;tdp_mmu_root_count, 1);

	spin_lock(&amp;kvm-&gt;arch.tdp_mmu_pages_lock);
	list_add_rcu(&amp;root-&gt;link, &amp;kvm-&gt;arch.tdp_mmu_roots);
	spin_unlock(&amp;kvm-&gt;arch.tdp_mmu_pages_lock);

out:
<blue>	return __pa(root->spt);</blue>
}

static void handle_changed_spte(struct kvm *kvm, int as_id, gfn_t gfn,
				u64 old_spte, u64 new_spte, int level,
				bool shared);

<blue>static void handle_changed_spte_acc_track(u64 old_spte, u64 new_spte, int level)</blue>
{
<blue>	if (!is_shadow_present_pte(old_spte) || !is_last_spte(old_spte, level))</blue>
		return;

<blue>	if (is_accessed_spte(old_spte) &&</blue>
<blue>	    (!is_shadow_present_pte(new_spte) || !is_accessed_spte(new_spte) ||</blue>
<blue>	     spte_to_pfn(old_spte) != spte_to_pfn(new_spte)))</blue>
<blue>		kvm_set_pfn_accessed(spte_to_pfn(old_spte));</blue>
<blue>}</blue>

<yellow>static void handle_changed_spte_dirty_log(struct kvm *kvm, int as_id, gfn_t gfn,</yellow>
					  u64 old_spte, u64 new_spte, int level)
{
	bool pfn_changed;
	struct kvm_memory_slot *slot;

<blue>	if (level > PG_LEVEL_4K)</blue>
		return;

<blue>	pfn_changed = spte_to_pfn(old_spte) != spte_to_pfn(new_spte);</blue>

	if ((!is_writable_pte(old_spte) || pfn_changed) &amp;&amp;
<blue>	    is_writable_pte(new_spte)) {</blue>
<yellow>		slot = __gfn_to_memslot(__kvm_memslots(kvm, as_id), gfn);</yellow>
<yellow>		mark_page_dirty_in_slot(kvm, slot, gfn);</yellow>
	}
}

static void tdp_account_mmu_page(struct kvm *kvm, struct kvm_mmu_page *sp)
{
<blue>	kvm_account_pgtable_pages((void *)sp->spt, +1);</blue>
}

static void tdp_unaccount_mmu_page(struct kvm *kvm, struct kvm_mmu_page *sp)
{
<blue>	kvm_account_pgtable_pages((void *)sp->spt, -1);</blue>
}

/**
 * tdp_mmu_unlink_sp() - Remove a shadow page from the list of used pages
 *
 * @kvm: kvm instance
 * @sp: the page to be removed
 * @shared: This operation may not be running under the exclusive use of
 *	    the MMU lock and the operation must synchronize with other
 *	    threads that might be adding or removing pages.
 */
static void tdp_mmu_unlink_sp(struct kvm *kvm, struct kvm_mmu_page *sp,
			      bool shared)
{
<blue>	tdp_unaccount_mmu_page(kvm, sp);</blue>
	if (shared)
<blue>		spin_lock(&kvm->arch.tdp_mmu_pages_lock);</blue>
	else
		lockdep_assert_held_write(&amp;kvm-&gt;mmu_lock);

<blue>	list_del(&sp->link);</blue>
<blue>	if (sp->lpage_disallowed)</blue>
<yellow>		unaccount_huge_nx_page(kvm, sp);</yellow>

<blue>	if (shared)</blue>
<blue>		spin_unlock(&kvm->arch.tdp_mmu_pages_lock);</blue>
}

/**
 * handle_removed_pt() - handle a page table removed from the TDP structure
 *
 * @kvm: kvm instance
 * @pt: the page removed from the paging structure
 * @shared: This operation may not be running under the exclusive use
 *	    of the MMU lock and the operation must synchronize with other
 *	    threads that might be modifying SPTEs.
 *
 * Given a page table that has been removed from the TDP paging structure,
 * iterates through the page table to clear SPTEs and free child page tables.
 *
 * Note that pt is passed in as a tdp_ptep_t, but it does not need RCU
 * protection. Since this thread removed it from the paging structure,
 * this thread will be responsible for ensuring the page is freed. Hence the
 * early rcu_dereferences in the function.
 */
static void handle_removed_pt(struct kvm *kvm, tdp_ptep_t pt, bool shared)
{
<blue>	struct kvm_mmu_page *sp = sptep_to_sp(rcu_dereference(pt));</blue>
	int level = sp-&gt;role.level;
	gfn_t base_gfn = sp-&gt;gfn;
	int i;

<yellow>	trace_kvm_mmu_prepare_zap_page(sp);</yellow>

<blue>	tdp_mmu_unlink_sp(kvm, sp, shared);</blue>

<blue>	for (i = 0; i < SPTE_ENT_PER_PAGE; i++) {</blue>
<blue>		tdp_ptep_t sptep = pt + i;</blue>
<blue>		gfn_t gfn = base_gfn + i * KVM_PAGES_PER_HPAGE(level);</blue>
		u64 old_spte;

<blue>		if (shared) {</blue>
			/*
			 * Set the SPTE to a nonpresent value that other
			 * threads will not overwrite. If the SPTE was
			 * already marked as removed then another thread
			 * handling a page fault could overwrite it, so
			 * set the SPTE until it is set from some other
			 * value to the removed SPTE value.
			 */
			for (;;) {
<blue>				old_spte = kvm_tdp_mmu_write_spte_atomic(sptep, REMOVED_SPTE);</blue>
				if (!is_removed_spte(old_spte))
					break;
<yellow>				cpu_relax();</yellow>
			}
		} else {
			/*
			 * If the SPTE is not MMU-present, there is no backing
			 * page associated with the SPTE and so no side effects
			 * that need to be recorded, and exclusive ownership of
			 * mmu_lock ensures the SPTE can&#x27;t be made present.
			 * Note, zapping MMIO SPTEs is also unnecessary as they
			 * are guarded by the memslots generation, not by being
			 * unreachable.
			 */
<yellow>			old_spte = kvm_tdp_mmu_read_spte(sptep);</yellow>
			if (!is_shadow_present_pte(old_spte))
				continue;

			/*
			 * Use the common helper instead of a raw WRITE_ONCE as
			 * the SPTE needs to be updated atomically if it can be
			 * modified by a different vCPU outside of mmu_lock.
			 * Even though the parent SPTE is !PRESENT, the TLB
			 * hasn&#x27;t yet been flushed, and both Intel and AMD
			 * document that A/D assists can use upper-level PxE
			 * entries that are cached in the TLB, i.e. the CPU can
			 * still access the page and mark it dirty.
			 *
			 * No retry is needed in the atomic update path as the
			 * sole concern is dropping a Dirty bit, i.e. no other
			 * task can zap/remove the SPTE as mmu_lock is held for
			 * write.  Marking the SPTE as a removed SPTE is not
			 * strictly necessary for the same reason, but using
			 * the remove SPTE value keeps the shared/exclusive
			 * paths consistent and allows the handle_changed_spte()
			 * call below to hardcode the new value to REMOVED_SPTE.
			 *
			 * Note, even though dropping a Dirty bit is the only
			 * scenario where a non-atomic update could result in a
			 * functional bug, simply checking the Dirty bit isn&#x27;t
			 * sufficient as a fast page fault could read the upper
			 * level SPTE before it is zapped, and then make this
			 * target SPTE writable, resume the guest, and set the
			 * Dirty bit between reading the SPTE above and writing
			 * it here.
			 */
<yellow>			old_spte = kvm_tdp_mmu_write_spte(sptep, old_spte,</yellow>
							  REMOVED_SPTE, level);
		}
<blue>		handle_changed_spte(kvm, kvm_mmu_page_as_id(sp), gfn,</blue>
				    old_spte, REMOVED_SPTE, level, shared);
	}

<blue>	call_rcu(&sp->rcu_head, tdp_mmu_free_sp_rcu_callback);</blue>
}

/**
 * __handle_changed_spte - handle bookkeeping associated with an SPTE change
 * @kvm: kvm instance
 * @as_id: the address space of the paging structure the SPTE was a part of
 * @gfn: the base GFN that was mapped by the SPTE
 * @old_spte: The value of the SPTE before the change
 * @new_spte: The value of the SPTE after the change
 * @level: the level of the PT the SPTE is part of in the paging structure
 * @shared: This operation may not be running under the exclusive use of
 *	    the MMU lock and the operation must synchronize with other
 *	    threads that might be modifying SPTEs.
 *
 * Handle bookkeeping that might result from the modification of a SPTE.
 * This function must be called for all TDP SPTE modifications.
 */
static void __handle_changed_spte(struct kvm *kvm, int as_id, gfn_t gfn,
				  u64 old_spte, u64 new_spte, int level,
				  bool shared)
{
<blue>	bool was_present = is_shadow_present_pte(old_spte);</blue>
	bool is_present = is_shadow_present_pte(new_spte);
<blue>	bool was_leaf = was_present && is_last_spte(old_spte, level);</blue>
<blue>	bool is_leaf = is_present && is_last_spte(new_spte, level);</blue>
<blue>	bool pfn_changed = spte_to_pfn(old_spte) != spte_to_pfn(new_spte);</blue>

<yellow>	WARN_ON(level > PT64_ROOT_MAX_LEVEL);</yellow>
<blue>	WARN_ON(level < PG_LEVEL_4K);</blue>
<blue>	WARN_ON(gfn & (KVM_PAGES_PER_HPAGE(level) - 1));</blue>

	/*
	 * If this warning were to trigger it would indicate that there was a
	 * missing MMU notifier or a race with some notifier handler.
	 * A present, leaf SPTE should never be directly replaced with another
	 * present leaf SPTE pointing to a different PFN. A notifier handler
	 * should be zapping the SPTE before the main MM&#x27;s page table is
	 * changed, or the SPTE should be zeroed, and the TLBs flushed by the
	 * thread before replacement.
	 */
<blue>	if (was_leaf && is_leaf && pfn_changed) {</blue>
		pr_err(&quot;Invalid SPTE change: cannot replace a present leaf\n&quot;
		       &quot;SPTE with another present leaf SPTE mapping a\n&quot;
		       &quot;different PFN!\n&quot;
		       &quot;as_id: %d gfn: %llx old_spte: %llx new_spte: %llx level: %d&quot;,
		       as_id, gfn, old_spte, new_spte, level);

		/*
		 * Crash the host to prevent error propagation and guest data
		 * corruption.
		 */
		BUG();
	}

<blue>	if (old_spte == new_spte)</blue>
		return;

<blue>	trace_kvm_tdp_mmu_spte_changed(as_id, gfn, level, old_spte, new_spte);</blue>

<blue>	if (is_leaf)</blue>
<blue>		check_spte_writable_invariants(new_spte);</blue>

	/*
	 * The only times a SPTE should be changed from a non-present to
	 * non-present state is when an MMIO entry is installed/modified/
	 * removed. In that case, there is nothing to do here.
	 */
<blue>	if (!was_present && !is_present) {</blue>
		/*
		 * If this change does not involve a MMIO SPTE or removed SPTE,
		 * it is unexpected. Log the change, though it should not
		 * impact the guest since both the former and current SPTEs
		 * are nonpresent.
		 */
<blue>		if (WARN_ON(!is_mmio_spte(old_spte) &&</blue>
			    !is_mmio_spte(new_spte) &amp;&amp;
			    !is_removed_spte(new_spte)))
			pr_err(&quot;Unexpected SPTE change! Nonpresent SPTEs\n&quot;
			       &quot;should not be replaced with another,\n&quot;
			       &quot;different nonpresent SPTE, unless one or both\n&quot;
			       &quot;are MMIO SPTEs, or the new SPTE is\n&quot;
			       &quot;a temporary removed SPTE.\n&quot;
			       &quot;as_id: %d gfn: %llx old_spte: %llx new_spte: %llx level: %d&quot;,
			       as_id, gfn, old_spte, new_spte, level);
		return;
	}

<blue>	if (is_leaf != was_leaf)</blue>
<blue>		kvm_update_page_stats(kvm, level, is_leaf ? 1 : -1);</blue>

<blue>	if (was_leaf && is_dirty_spte(old_spte) &&</blue>
<blue>	    (!is_present || !is_dirty_spte(new_spte) || pfn_changed))</blue>
<blue>		kvm_set_pfn_dirty(spte_to_pfn(old_spte));</blue>

	/*
	 * Recursively handle child PTs if the change removed a subtree from
	 * the paging structure.  Note the WARN on the PFN changing without the
	 * SPTE being converted to a hugepage (leaf) or being zapped.  Shadow
	 * pages are kernel allocations and should never be migrated.
	 */
<blue>	if (was_present && !was_leaf &&</blue>
<yellow>	    (is_leaf || !is_present || WARN_ON_ONCE(pfn_changed)))</yellow>
<blue>		handle_removed_pt(kvm, spte_to_child_pt(old_spte, level), shared);</blue>
<blue>}</blue>

static void handle_changed_spte(struct kvm *kvm, int as_id, gfn_t gfn,
				u64 old_spte, u64 new_spte, int level,
				bool shared)
{
	__handle_changed_spte(kvm, as_id, gfn, old_spte, new_spte, level,
			      shared);
	handle_changed_spte_acc_track(old_spte, new_spte, level);
	handle_changed_spte_dirty_log(kvm, as_id, gfn, old_spte,
				      new_spte, level);
}

/*
 * tdp_mmu_set_spte_atomic - Set a TDP MMU SPTE atomically
 * and handle the associated bookkeeping.  Do not mark the page dirty
 * in KVM&#x27;s dirty bitmaps.
 *
 * If setting the SPTE fails because it has changed, iter-&gt;old_spte will be
 * refreshed to the current value of the spte.
 *
 * @kvm: kvm instance
 * @iter: a tdp_iter instance currently on the SPTE that should be set
 * @new_spte: The value the SPTE should be set to
 * Return:
 * * 0      - If the SPTE was set.
 * * -EBUSY - If the SPTE cannot be set. In this case this function will have
 *            no side-effects other than setting iter-&gt;old_spte to the last
 *            known value of the spte.
 */
static inline int tdp_mmu_set_spte_atomic(struct kvm *kvm,
					  struct tdp_iter *iter,
					  u64 new_spte)
{
<blue>	u64 *sptep = rcu_dereference(iter->sptep);</blue>

	/*
	 * The caller is responsible for ensuring the old SPTE is not a REMOVED
	 * SPTE.  KVM should never attempt to zap or manipulate a REMOVED SPTE,
	 * and pre-checking before inserting a new SPTE is advantageous as it
	 * avoids unnecessary work.
	 */
<blue>	WARN_ON_ONCE(iter->yielded || is_removed_spte(iter->old_spte));</blue>

	lockdep_assert_held_read(&amp;kvm-&gt;mmu_lock);

	/*
	 * Note, fast_pf_fix_direct_spte() can also modify TDP MMU SPTEs and
	 * does not hold the mmu_lock.
	 */
<blue>	if (!try_cmpxchg64(sptep, &iter->old_spte, new_spte))</blue>
		return -EBUSY;

<blue>	__handle_changed_spte(kvm, iter->as_id, iter->gfn, iter->old_spte,</blue>
			      new_spte, iter-&gt;level, true);
	handle_changed_spte_acc_track(iter-&gt;old_spte, new_spte, iter-&gt;level);

	return 0;
}

<blue>static inline int tdp_mmu_zap_spte_atomic(struct kvm *kvm,</blue>
					  struct tdp_iter *iter)
{
	int ret;

	/*
	 * Freeze the SPTE by setting it to a special,
	 * non-present value. This will stop other threads from
	 * immediately installing a present entry in its place
	 * before the TLBs are flushed.
	 */
<blue>	ret = tdp_mmu_set_spte_atomic(kvm, iter, REMOVED_SPTE);</blue>
	if (ret)
		return ret;

	kvm_flush_remote_tlbs_with_address(kvm, iter-&gt;gfn,
<blue>					   KVM_PAGES_PER_HPAGE(iter->level));</blue>

	/*
	 * No other thread can overwrite the removed SPTE as they must either
	 * wait on the MMU lock or use tdp_mmu_set_spte_atomic() which will not
	 * overwrite the special removed SPTE value. No bookkeeping is needed
	 * here since the SPTE is going from non-present to non-present.  Use
	 * the raw write helper to avoid an unnecessary check on volatile bits.
	 */
	__kvm_tdp_mmu_write_spte(iter-&gt;sptep, 0);

	return 0;
}


/*
 * __tdp_mmu_set_spte - Set a TDP MMU SPTE and handle the associated bookkeeping
 * @kvm:	      KVM instance
 * @as_id:	      Address space ID, i.e. regular vs. SMM
 * @sptep:	      Pointer to the SPTE
 * @old_spte:	      The current value of the SPTE
 * @new_spte:	      The new value that will be set for the SPTE
 * @gfn:	      The base GFN that was (or will be) mapped by the SPTE
 * @level:	      The level _containing_ the SPTE (its parent PT&#x27;s level)
 * @record_acc_track: Notify the MM subsystem of changes to the accessed state
 *		      of the page. Should be set unless handling an MMU
 *		      notifier for access tracking. Leaving record_acc_track
 *		      unset in that case prevents page accesses from being
 *		      double counted.
 * @record_dirty_log: Record the page as dirty in the dirty bitmap if
 *		      appropriate for the change being made. Should be set
 *		      unless performing certain dirty logging operations.
 *		      Leaving record_dirty_log unset in that case prevents page
 *		      writes from being double counted.
 *
 * Returns the old SPTE value, which _may_ be different than @old_spte if the
 * SPTE had voldatile bits.
 */
static u64 __tdp_mmu_set_spte(struct kvm *kvm, int as_id, tdp_ptep_t sptep,
			      u64 old_spte, u64 new_spte, gfn_t gfn, int level,
			      bool record_acc_track, bool record_dirty_log)
{
	lockdep_assert_held_write(&amp;kvm-&gt;mmu_lock);

	/*
	 * No thread should be using this function to set SPTEs to or from the
	 * temporary removed SPTE value.
	 * If operating under the MMU lock in read mode, tdp_mmu_set_spte_atomic
	 * should be used. If operating under the MMU lock in write mode, the
	 * use of the removed SPTE should not be necessary.
	 */
<blue>	WARN_ON(is_removed_spte(old_spte) || is_removed_spte(new_spte));</blue>

<blue>	old_spte = kvm_tdp_mmu_write_spte(sptep, old_spte, new_spte, level);</blue>

<blue>	__handle_changed_spte(kvm, as_id, gfn, old_spte, new_spte, level, false);</blue>

	if (record_acc_track)
<blue>		handle_changed_spte_acc_track(old_spte, new_spte, level);</blue>
<blue>	if (record_dirty_log)</blue>
<blue>		handle_changed_spte_dirty_log(kvm, as_id, gfn, old_spte,</blue>
					      new_spte, level);
	return old_spte;
<blue>}</blue>

static inline void _tdp_mmu_set_spte(struct kvm *kvm, struct tdp_iter *iter,
				     u64 new_spte, bool record_acc_track,
				     bool record_dirty_log)
{
<blue>	WARN_ON_ONCE(iter->yielded);</blue>

<blue>	iter->old_spte = __tdp_mmu_set_spte(kvm, iter->as_id, iter->sptep,</blue>
					    iter-&gt;old_spte, new_spte,
					    iter-&gt;gfn, iter-&gt;level,
					    record_acc_track, record_dirty_log);
}

static inline void tdp_mmu_set_spte(struct kvm *kvm, struct tdp_iter *iter,
				    u64 new_spte)
{
<blue>	_tdp_mmu_set_spte(kvm, iter, new_spte, true, true);</blue>
}

static inline void tdp_mmu_set_spte_no_acc_track(struct kvm *kvm,
						 struct tdp_iter *iter,
						 u64 new_spte)
{
<blue>	_tdp_mmu_set_spte(kvm, iter, new_spte, false, true);</blue>
}

static inline void tdp_mmu_set_spte_no_dirty_log(struct kvm *kvm,
						 struct tdp_iter *iter,
						 u64 new_spte)
{
<yellow>	_tdp_mmu_set_spte(kvm, iter, new_spte, true, false);</yellow>
}

#define tdp_root_for_each_pte(_iter, _root, _start, _end) \
	for_each_tdp_pte(_iter, _root, _start, _end)

#define tdp_root_for_each_leaf_pte(_iter, _root, _start, _end)	\
	tdp_root_for_each_pte(_iter, _root, _start, _end)		\
		if (!is_shadow_present_pte(_iter.old_spte) ||		\
		    !is_last_spte(_iter.old_spte, _iter.level))		\
			continue;					\
		else

#define tdp_mmu_for_each_pte(_iter, _mmu, _start, _end)		\
	for_each_tdp_pte(_iter, to_shadow_page(_mmu-&gt;root.hpa), _start, _end)

/*
 * Yield if the MMU lock is contended or this thread needs to return control
 * to the scheduler.
 *
 * If this function should yield and flush is set, it will perform a remote
 * TLB flush before yielding.
 *
 * If this function yields, iter-&gt;yielded is set and the caller must skip to
 * the next iteration, where tdp_iter_next() will reset the tdp_iter&#x27;s walk
 * over the paging structures to allow the iterator to continue its traversal
 * from the paging structure root.
 *
 * Returns true if this function yielded.
 */
<yellow>static inline bool __must_check tdp_mmu_iter_cond_resched(struct kvm *kvm,</yellow>
							  struct tdp_iter *iter,
							  bool flush, bool shared)
{
<blue>	WARN_ON(iter->yielded);</blue>

	/* Ensure forward progress has been made before yielding. */
<blue>	if (iter->next_last_level_gfn == iter->yielded_gfn)</blue>
		return false;

<yellow>	if (need_resched() || rwlock_needbreak(&kvm->mmu_lock)) {</yellow>
<yellow>		if (flush)</yellow>
<yellow>			kvm_flush_remote_tlbs(kvm);</yellow>

<yellow>		rcu_read_unlock();</yellow>

		if (shared)
<yellow>			cond_resched_rwlock_read(&kvm->mmu_lock);</yellow>
		else
<yellow>			cond_resched_rwlock_write(&kvm->mmu_lock);</yellow>

<yellow>		rcu_read_lock();</yellow>

<yellow>		WARN_ON(iter->gfn > iter->next_last_level_gfn);</yellow>

<yellow>		iter->yielded = true;</yellow>
	}

<yellow>	return iter->yielded;</yellow>
}

static inline gfn_t tdp_mmu_max_gfn_exclusive(void)
{
	/*
	 * Bound TDP MMU walks at host.MAXPHYADDR.  KVM disallows memslots with
	 * a gpa range that would exceed the max gfn, and KVM does not create
	 * MMIO SPTEs for &quot;impossible&quot; gfns, instead sending such accesses down
	 * the slow emulation path every time.
	 */
<blue>	return kvm_mmu_max_gfn() + 1;</blue>
}

static void __tdp_mmu_zap_root(struct kvm *kvm, struct kvm_mmu_page *root,
			       bool shared, int zap_level)
<yellow>{</yellow>
	struct tdp_iter iter;

<yellow>	gfn_t end = tdp_mmu_max_gfn_exclusive();</yellow>
	gfn_t start = 0;

<yellow>	for_each_tdp_pte_min_level(iter, root, zap_level, start, end) {</yellow>
retry:
<yellow>		if (tdp_mmu_iter_cond_resched(kvm, &iter, false, shared))</yellow>
			continue;

<yellow>		if (!is_shadow_present_pte(iter.old_spte))</yellow>
			continue;

<yellow>		if (iter.level > zap_level)</yellow>
			continue;

		if (!shared)
<yellow>			tdp_mmu_set_spte(kvm, &iter, 0);</yellow>
<yellow>		else if (tdp_mmu_set_spte_atomic(kvm, &iter, 0))</yellow>
			goto retry;
	}
}

static void tdp_mmu_zap_root(struct kvm *kvm, struct kvm_mmu_page *root,
			     bool shared)
{

	/*
	 * The root must have an elevated refcount so that it&#x27;s reachable via
	 * mmu_notifier callbacks, which allows this path to yield and drop
	 * mmu_lock.  When handling an unmap/release mmu_notifier command, KVM
	 * must drop all references to relevant pages prior to completing the
	 * callback.  Dropping mmu_lock with an unreachable root would result
	 * in zapping SPTEs after a relevant mmu_notifier callback completes
	 * and lead to use-after-free as zapping a SPTE triggers &quot;writeback&quot; of
	 * dirty accessed bits to the SPTE&#x27;s associated struct page.
	 */
<yellow>	WARN_ON_ONCE(!refcount_read(&root->tdp_mmu_root_count));</yellow>

<yellow>	kvm_lockdep_assert_mmu_lock_held(kvm, shared);</yellow>

	rcu_read_lock();

	/*
	 * To avoid RCU stalls due to recursively removing huge swaths of SPs,
	 * split the zap into two passes.  On the first pass, zap at the 1gb
	 * level, and then zap top-level SPs on the second pass.  &quot;1gb&quot; is not
	 * arbitrary, as KVM must be able to zap a 1gb shadow page without
	 * inducing a stall to allow in-place replacement with a 1gb hugepage.
	 *
	 * Because zapping a SP recurses on its children, stepping down to
	 * PG_LEVEL_4K in the iterator itself is unnecessary.
	 */
	__tdp_mmu_zap_root(kvm, root, shared, PG_LEVEL_1G);
	__tdp_mmu_zap_root(kvm, root, shared, root-&gt;role.level);

	rcu_read_unlock();
}

bool kvm_tdp_mmu_zap_sp(struct kvm *kvm, struct kvm_mmu_page *sp)
{
	u64 old_spte;

	/*
	 * This helper intentionally doesn&#x27;t allow zapping a root shadow page,
	 * which doesn&#x27;t have a parent page table and thus no associated entry.
	 */
<yellow>	if (WARN_ON_ONCE(!sp->ptep))</yellow>
		return false;

<yellow>	old_spte = kvm_tdp_mmu_read_spte(sp->ptep);</yellow>
<yellow>	if (WARN_ON_ONCE(!is_shadow_present_pte(old_spte)))</yellow>
		return false;

	__tdp_mmu_set_spte(kvm, kvm_mmu_page_as_id(sp), sp-&gt;ptep, old_spte, 0,
<yellow>			   sp->gfn, sp->role.level + 1, true, true);</yellow>

	return true;
<yellow>}</yellow>

/*
 * If can_yield is true, will release the MMU lock and reschedule if the
 * scheduler needs the CPU or there is contention on the MMU lock. If this
 * function cannot yield, it will not release the MMU lock or reschedule and
 * the caller must ensure it does not supply too large a GFN range, or the
 * operation can cause a soft lockup.
 */
static bool tdp_mmu_zap_leafs(struct kvm *kvm, struct kvm_mmu_page *root,
			      gfn_t start, gfn_t end, bool can_yield, bool flush)
{
	struct tdp_iter iter;

<blue>	end = min(end, tdp_mmu_max_gfn_exclusive());</blue>

	lockdep_assert_held_write(&amp;kvm-&gt;mmu_lock);

	rcu_read_lock();

<blue>	for_each_tdp_pte_min_level(iter, root, PG_LEVEL_4K, start, end) {</blue>
<blue>		if (can_yield &&</blue>
<blue>		    tdp_mmu_iter_cond_resched(kvm, &iter, flush, false)) {</blue>
			flush = false;
			continue;
		}

<blue>		if (!is_shadow_present_pte(iter.old_spte) ||</blue>
<blue>		    !is_last_spte(iter.old_spte, iter.level))</blue>
			continue;

<blue>		tdp_mmu_set_spte(kvm, &iter, 0);</blue>
		flush = true;
	}

<blue>	rcu_read_unlock();</blue>

	/*
	 * Because this flow zaps _only_ leaf SPTEs, the caller doesn&#x27;t need
	 * to provide RCU protection as no &#x27;struct kvm_mmu_page&#x27; will be freed.
	 */
	return flush;
}

/*
 * Zap leaf SPTEs for the range of gfns, [start, end), for all roots. Returns
 * true if a TLB flush is needed before releasing the MMU lock, i.e. if one or
 * more SPTEs were zapped since the MMU lock was last acquired.
 */
bool kvm_tdp_mmu_zap_leafs(struct kvm *kvm, int as_id, gfn_t start, gfn_t end,
			   bool can_yield, bool flush)
{
	struct kvm_mmu_page *root;

<blue>	for_each_tdp_mmu_root_yield_safe(kvm, root, as_id)</blue>
<blue>		flush = tdp_mmu_zap_leafs(kvm, root, start, end, can_yield, flush);</blue>

	return flush;
<blue>}</blue>

void kvm_tdp_mmu_zap_all(struct kvm *kvm)
{
	struct kvm_mmu_page *root;
	int i;

	/*
	 * Zap all roots, including invalid roots, as all SPTEs must be dropped
	 * before returning to the caller.  Zap directly even if the root is
	 * also being zapped by a worker.  Walking zapped top-level SPTEs isn&#x27;t
	 * all that expensive and mmu_lock is already held, which means the
	 * worker has yielded, i.e. flushing the work instead of zapping here
	 * isn&#x27;t guaranteed to be any faster.
	 *
	 * A TLB flush is unnecessary, KVM zaps everything if and only the VM
	 * is being destroyed or the userspace VMM has exited.  In both cases,
	 * KVM_RUN is unreachable, i.e. no vCPUs will ever service the request.
	 */
<yellow>	for (i = 0; i < KVM_ADDRESS_SPACE_NUM; i++) {</yellow>
<yellow>		for_each_tdp_mmu_root_yield_safe(kvm, root, i)</yellow>
<yellow>			tdp_mmu_zap_root(kvm, root, false);</yellow>
	}
<yellow>}</yellow>

/*
 * Zap all invalidated roots to ensure all SPTEs are dropped before the &quot;fast
 * zap&quot; completes.
 */
void kvm_tdp_mmu_zap_invalidated_roots(struct kvm *kvm)
{
<blue>	flush_workqueue(kvm->arch.tdp_mmu_zap_wq);</blue>
}

/*
 * Mark each TDP MMU root as invalid to prevent vCPUs from reusing a root that
 * is about to be zapped, e.g. in response to a memslots update.  The actual
 * zapping is performed asynchronously, so a reference is taken on all roots.
 * Using a separate workqueue makes it easy to ensure that the destruction is
 * performed before the &quot;fast zap&quot; completes, without keeping a separate list
 * of invalidated roots; the list is effectively the list of work items in
 * the workqueue.
 *
 * Get a reference even if the root is already invalid, the asynchronous worker
 * assumes it was gifted a reference to the root it processes.  Because mmu_lock
 * is held for write, it should be impossible to observe a root with zero refcount,
 * i.e. the list of roots cannot be stale.
 *
 * This has essentially the same effect for the TDP MMU
 * as updating mmu_valid_gen does for the shadow MMU.
 */
void kvm_tdp_mmu_invalidate_all_roots(struct kvm *kvm)
<blue>{</blue>
	struct kvm_mmu_page *root;

	lockdep_assert_held_write(&amp;kvm-&gt;mmu_lock);
<blue>	list_for_each_entry(root, &kvm->arch.tdp_mmu_roots, link) {</blue>
<blue>		if (!root->role.invalid &&</blue>
<blue>		    !WARN_ON_ONCE(!kvm_tdp_mmu_get_root(root))) {</blue>
<blue>			root->role.invalid = true;</blue>
			tdp_mmu_schedule_zap_root(kvm, root);
		}
	}
}

/*
 * Installs a last-level SPTE to handle a TDP page fault.
 * (NPT/EPT violation/misconfiguration)
 */
static int tdp_mmu_map_handle_target_level(struct kvm_vcpu *vcpu,
					  struct kvm_page_fault *fault,
					  struct tdp_iter *iter)
{
<blue>	struct kvm_mmu_page *sp = sptep_to_sp(rcu_dereference(iter->sptep));</blue>
	u64 new_spte;
	int ret = RET_PF_FIXED;
	bool wrprot = false;

<yellow>	WARN_ON(sp->role.level != fault->goal_level);</yellow>
<blue>	if (unlikely(!fault->slot))</blue>
<blue>		new_spte = make_mmio_spte(vcpu, iter->gfn, ACC_ALL);</blue>
	else
<blue>		wrprot = make_spte(vcpu, sp, fault->slot, ACC_ALL, iter->gfn,</blue>
<blue>					 fault->pfn, iter->old_spte, fault->prefetch, true,</blue>
<blue>					 fault->map_writable, &new_spte);</blue>

	if (new_spte == iter-&gt;old_spte)
		ret = RET_PF_SPURIOUS;
<blue>	else if (tdp_mmu_set_spte_atomic(vcpu->kvm, iter, new_spte))</blue>
		return RET_PF_RETRY;
	else if (is_shadow_present_pte(iter-&gt;old_spte) &amp;&amp;
<blue>		 !is_last_spte(iter->old_spte, iter->level))</blue>
		kvm_flush_remote_tlbs_with_address(vcpu-&gt;kvm, sp-&gt;gfn,
<blue>						   KVM_PAGES_PER_HPAGE(iter->level + 1));</blue>

	/*
	 * If the page fault was caused by a write but the page is write
	 * protected, emulation is needed. If the emulation was skipped,
	 * the vCPU would have the same fault again.
	 */
<blue>	if (wrprot) {</blue>
<blue>		if (fault->write)</blue>
			ret = RET_PF_EMULATE;
	}

	/* If a MMIO SPTE is installed, the MMIO will need to be emulated. */
<blue>	if (unlikely(is_mmio_spte(new_spte))) {</blue>
<blue>		vcpu->stat.pf_mmio_spte_created++;</blue>
<yellow>		trace_mark_mmio_spte(rcu_dereference(iter->sptep), iter->gfn,</yellow>
				     new_spte);
		ret = RET_PF_EMULATE;
	} else {
<yellow>		trace_kvm_mmu_set_spte(iter->level, iter->gfn,</yellow>
<blue>				       rcu_dereference(iter->sptep));</blue>
	}

	return ret;
}

/*
 * tdp_mmu_link_sp - Replace the given spte with an spte pointing to the
 * provided page table.
 *
 * @kvm: kvm instance
 * @iter: a tdp_iter instance currently on the SPTE that should be set
 * @sp: The new TDP page table to install.
 * @account_nx: True if this page table is being installed to split a
 *              non-executable huge page.
 * @shared: This operation is running under the MMU lock in read mode.
 *
 * Returns: 0 if the new page table was installed. Non-0 if the page table
 *          could not be installed (e.g. the atomic compare-exchange failed).
 */
static int tdp_mmu_link_sp(struct kvm *kvm, struct tdp_iter *iter,
			   struct kvm_mmu_page *sp, bool account_nx,
			   bool shared)
{
<blue>	u64 spte = make_nonleaf_spte(sp->spt, !kvm_ad_enabled());</blue>
	int ret = 0;

	if (shared) {
<blue>		ret = tdp_mmu_set_spte_atomic(kvm, iter, spte);</blue>
		if (ret)
			return ret;
	} else {
<yellow>		tdp_mmu_set_spte(kvm, iter, spte);</yellow>
	}

<blue>	spin_lock(&kvm->arch.tdp_mmu_pages_lock);</blue>
	list_add(&amp;sp-&gt;link, &amp;kvm-&gt;arch.tdp_mmu_pages);
	if (account_nx)
<yellow>		account_huge_nx_page(kvm, sp);</yellow>
<blue>	spin_unlock(&kvm->arch.tdp_mmu_pages_lock);</blue>
<blue>	tdp_account_mmu_page(kvm, sp);</blue>

	return 0;
<blue>}</blue>

/*
 * Handle a TDP page fault (NPT/EPT violation/misconfiguration) by installing
 * page tables and SPTEs to translate the faulting guest physical address.
 */
int kvm_tdp_mmu_map(struct kvm_vcpu *vcpu, struct kvm_page_fault *fault)
<blue>{</blue>
<blue>	struct kvm_mmu *mmu = vcpu->arch.mmu;</blue>
	struct tdp_iter iter;
	struct kvm_mmu_page *sp;
	int ret;

	kvm_mmu_hugepage_adjust(vcpu, fault);

<yellow>	trace_kvm_mmu_spte_requested(fault);</yellow>

<blue>	rcu_read_lock();</blue>

<blue>	tdp_mmu_for_each_pte(iter, mmu, fault->gfn, fault->gfn + 1) {</blue>
<blue>		if (fault->nx_huge_page_workaround_enabled)</blue>
<yellow>			disallowed_hugepage_adjust(fault, iter.old_spte, iter.level);</yellow>

<blue>		if (iter.level == fault->goal_level)</blue>
			break;

		/*
		 * If there is an SPTE mapping a large page at a higher level
		 * than the target, that SPTE must be cleared and replaced
		 * with a non-leaf SPTE.
		 */
<blue>		if (is_shadow_present_pte(iter.old_spte) &&</blue>
		    is_large_pte(iter.old_spte)) {
<blue>			if (tdp_mmu_zap_spte_atomic(vcpu->kvm, &iter))</blue>
				break;

			/*
			 * The iter must explicitly re-read the spte here
			 * because the new value informs the !present
			 * path below.
			 */
			iter.old_spte = kvm_tdp_mmu_read_spte(iter.sptep);
		}

<blue>		if (!is_shadow_present_pte(iter.old_spte)) {</blue>
<blue>			bool account_nx = fault->huge_page_disallowed &&</blue>
<yellow>					  fault->req_level >= iter.level;</yellow>

			/*
			 * If SPTE has been frozen by another thread, just
			 * give up and retry, avoiding unnecessary page table
			 * allocation and free.
			 */
<blue>			if (is_removed_spte(iter.old_spte))</blue>
				break;

<blue>			sp = tdp_mmu_alloc_sp(vcpu);</blue>
			tdp_mmu_init_child_sp(sp, &amp;iter);

			if (tdp_mmu_link_sp(vcpu-&gt;kvm, &amp;iter, sp, account_nx, true)) {
<yellow>				tdp_mmu_free_sp(sp);</yellow>
				break;
			}
		}
	}

	/*
	 * Force the guest to retry the access if the upper level SPTEs aren&#x27;t
	 * in place, or if the target leaf SPTE is frozen by another CPU.
	 */
<blue>	if (iter.level != fault->goal_level || is_removed_spte(iter.old_spte)) {</blue>
		rcu_read_unlock();
<yellow>		return RET_PF_RETRY;</yellow>
	}

<blue>	ret = tdp_mmu_map_handle_target_level(vcpu, fault, &iter);</blue>
<blue>	rcu_read_unlock();</blue>

	return ret;
}

bool kvm_tdp_mmu_unmap_gfn_range(struct kvm *kvm, struct kvm_gfn_range *range,
				 bool flush)
{
<blue>	return kvm_tdp_mmu_zap_leafs(kvm, range->slot->as_id, range->start,</blue>
<blue>				     range->end, range->may_block, flush);</blue>
}

typedef bool (*tdp_handler_t)(struct kvm *kvm, struct tdp_iter *iter,
			      struct kvm_gfn_range *range);

static __always_inline bool kvm_tdp_mmu_handle_gfn(struct kvm *kvm,
						   struct kvm_gfn_range *range,
						   tdp_handler_t handler)
{
	struct kvm_mmu_page *root;
	struct tdp_iter iter;
	bool ret = false;

	/*
	 * Don&#x27;t support rescheduling, none of the MMU notifiers that funnel
	 * into this helper allow blocking; it&#x27;d be dead, wasteful code.
	 */
<blue>	for_each_tdp_mmu_root(kvm, root, range->slot->as_id) {</blue>
<blue>		rcu_read_lock();</blue>

<blue>		tdp_root_for_each_leaf_pte(iter, root, range->start, range->end)</blue>
<blue>			ret |= handler(kvm, &iter, range);</blue>

<blue>		rcu_read_unlock();</blue>
	}

	return ret;
}

/*
 * Mark the SPTEs range of GFNs [start, end) unaccessed and return non-zero
 * if any of the GFNs in the range have been accessed.
 */
static bool age_gfn_range(struct kvm *kvm, struct tdp_iter *iter,
			  struct kvm_gfn_range *range)
{
	u64 new_spte = 0;

	/* If we have a non-accessed entry we don&#x27;t need to change the pte. */
<blue>	if (!is_accessed_spte(iter->old_spte))</blue>
		return false;

	new_spte = iter-&gt;old_spte;

	if (spte_ad_enabled(new_spte)) {
<blue>		new_spte &= ~shadow_accessed_mask;</blue>
	} else {
		/*
		 * Capture the dirty status of the page, so that it doesn&#x27;t get
		 * lost when the SPTE is marked for access tracking.
		 */
<yellow>		if (is_writable_pte(new_spte))</yellow>
<yellow>			kvm_set_pfn_dirty(spte_to_pfn(new_spte));</yellow>

<yellow>		new_spte = mark_spte_for_access_track(new_spte);</yellow>
	}

<blue>	tdp_mmu_set_spte_no_acc_track(kvm, iter, new_spte);</blue>

	return true;
}

bool kvm_tdp_mmu_age_gfn_range(struct kvm *kvm, struct kvm_gfn_range *range)
<blue>{</blue>
<blue>	return kvm_tdp_mmu_handle_gfn(kvm, range, age_gfn_range);</blue>
}

static bool test_age_gfn(struct kvm *kvm, struct tdp_iter *iter,
			 struct kvm_gfn_range *range)
{
<yellow>	return is_accessed_spte(iter->old_spte);</yellow>
}

bool kvm_tdp_mmu_test_age_gfn(struct kvm *kvm, struct kvm_gfn_range *range)
<yellow>{</yellow>
<yellow>	return kvm_tdp_mmu_handle_gfn(kvm, range, test_age_gfn);</yellow>
}

static bool set_spte_gfn(struct kvm *kvm, struct tdp_iter *iter,
			 struct kvm_gfn_range *range)
{
	u64 new_spte;

	/* Huge pages aren&#x27;t expected to be modified without first being zapped. */
<yellow>	WARN_ON(pte_huge(range->pte) || range->start + 1 != range->end);</yellow>

<yellow>	if (iter->level != PG_LEVEL_4K ||</yellow>
	    !is_shadow_present_pte(iter-&gt;old_spte))
		return false;

	/*
	 * Note, when changing a read-only SPTE, it&#x27;s not strictly necessary to
	 * zero the SPTE before setting the new PFN, but doing so preserves the
	 * invariant that the PFN of a present * leaf SPTE can never change.
	 * See __handle_changed_spte().
	 */
<yellow>	tdp_mmu_set_spte(kvm, iter, 0);</yellow>

	if (!pte_write(range-&gt;pte)) {
		new_spte = kvm_mmu_changed_pte_notifier_make_spte(iter-&gt;old_spte,
<yellow>								  pte_pfn(range->pte));</yellow>

<yellow>		tdp_mmu_set_spte(kvm, iter, new_spte);</yellow>
	}

	return true;
}

/*
 * Handle the changed_pte MMU notifier for the TDP MMU.
 * data is a pointer to the new pte_t mapping the HVA specified by the MMU
 * notifier.
 * Returns non-zero if a flush is needed before releasing the MMU lock.
 */
bool kvm_tdp_mmu_set_spte_gfn(struct kvm *kvm, struct kvm_gfn_range *range)
<blue>{</blue>
	/*
	 * No need to handle the remote TLB flush under RCU protection, the
	 * target SPTE _must_ be a leaf SPTE, i.e. cannot result in freeing a
	 * shadow page.  See the WARN on pfn_changed in __handle_changed_spte().
	 */
<blue>	return kvm_tdp_mmu_handle_gfn(kvm, range, set_spte_gfn);</blue>
}

/*
 * Remove write access from all SPTEs at or above min_level that map GFNs
 * [start, end). Returns true if an SPTE has been changed and the TLBs need to
 * be flushed.
 */
static bool wrprot_gfn_range(struct kvm *kvm, struct kvm_mmu_page *root,
			     gfn_t start, gfn_t end, int min_level)
{
	struct tdp_iter iter;
	u64 new_spte;
	bool spte_set = false;

<yellow>	rcu_read_lock();</yellow>

<yellow>	BUG_ON(min_level > KVM_MAX_HUGEPAGE_LEVEL);</yellow>

<yellow>	for_each_tdp_pte_min_level(iter, root, min_level, start, end) {</yellow>
retry:
<yellow>		if (tdp_mmu_iter_cond_resched(kvm, &iter, false, true))</yellow>
			continue;

<yellow>		if (!is_shadow_present_pte(iter.old_spte) ||</yellow>
<yellow>		    !is_last_spte(iter.old_spte, iter.level) ||</yellow>
<yellow>		    !(iter.old_spte & PT_WRITABLE_MASK))</yellow>
			continue;

		new_spte = iter.old_spte &amp; ~PT_WRITABLE_MASK;

<yellow>		if (tdp_mmu_set_spte_atomic(kvm, &iter, new_spte))</yellow>
			goto retry;

		spte_set = true;
	}

<yellow>	rcu_read_unlock();</yellow>
	return spte_set;
}

/*
 * Remove write access from all the SPTEs mapping GFNs in the memslot. Will
 * only affect leaf SPTEs down to min_level.
 * Returns true if an SPTE has been changed and the TLBs need to be flushed.
 */
bool kvm_tdp_mmu_wrprot_slot(struct kvm *kvm,
			     const struct kvm_memory_slot *slot, int min_level)
{
	struct kvm_mmu_page *root;
	bool spte_set = false;

	lockdep_assert_held_read(&amp;kvm-&gt;mmu_lock);

<yellow>	for_each_valid_tdp_mmu_root_yield_safe(kvm, root, slot->as_id, true)</yellow>
		spte_set |= wrprot_gfn_range(kvm, root, slot-&gt;base_gfn,
<yellow>			     slot->base_gfn + slot->npages, min_level);</yellow>

	return spte_set;
<yellow>}</yellow>

static struct kvm_mmu_page *__tdp_mmu_alloc_sp_for_split(gfp_t gfp)
{
	struct kvm_mmu_page *sp;

	gfp |= __GFP_ZERO;

<yellow>	sp = kmem_cache_alloc(mmu_page_header_cache, gfp);</yellow>
	if (!sp)
		return NULL;

<yellow>	sp->spt = (void *)__get_free_page(gfp);</yellow>
	if (!sp-&gt;spt) {
<yellow>		kmem_cache_free(mmu_page_header_cache, sp);</yellow>
		return NULL;
	}

	return sp;
<yellow>}</yellow>

static struct kvm_mmu_page *tdp_mmu_alloc_sp_for_split(struct kvm *kvm,
						       struct tdp_iter *iter,
						       bool shared)
{
	struct kvm_mmu_page *sp;

	/*
	 * Since we are allocating while under the MMU lock we have to be
	 * careful about GFP flags. Use GFP_NOWAIT to avoid blocking on direct
	 * reclaim and to avoid making any filesystem callbacks (which can end
	 * up invoking KVM MMU notifiers, resulting in a deadlock).
	 *
	 * If this allocation fails we drop the lock and retry with reclaim
	 * allowed.
	 */
<yellow>	sp = __tdp_mmu_alloc_sp_for_split(GFP_NOWAIT | __GFP_ACCOUNT);</yellow>
	if (sp)
		return sp;

<yellow>	rcu_read_unlock();</yellow>

	if (shared)
<yellow>		read_unlock(&kvm->mmu_lock);</yellow>
	else
<yellow>		write_unlock(&kvm->mmu_lock);</yellow>

	iter-&gt;yielded = true;
	sp = __tdp_mmu_alloc_sp_for_split(GFP_KERNEL_ACCOUNT);

	if (shared)
		read_lock(&amp;kvm-&gt;mmu_lock);
	else
		write_lock(&amp;kvm-&gt;mmu_lock);

<yellow>	rcu_read_lock();</yellow>

	return sp;
}

static int tdp_mmu_split_huge_page(struct kvm *kvm, struct tdp_iter *iter,
				   struct kvm_mmu_page *sp, bool shared)
{
<yellow>	const u64 huge_spte = iter->old_spte;</yellow>
<yellow>	const int level = iter->level;</yellow>
	int ret, i;

	tdp_mmu_init_child_sp(sp, iter);

	/*
	 * No need for atomics when writing to sp-&gt;spt since the page table has
	 * not been linked in yet and thus is not reachable from any other CPU.
	 */
	for (i = 0; i &lt; SPTE_ENT_PER_PAGE; i++)
<yellow>		sp->spt[i] = make_huge_page_split_spte(kvm, huge_spte, sp->role, i);</yellow>

	/*
	 * Replace the huge spte with a pointer to the populated lower level
	 * page table. Since we are making this change without a TLB flush vCPUs
	 * will see a mix of the split mappings and the original huge mapping,
	 * depending on what&#x27;s currently in their TLB. This is fine from a
	 * correctness standpoint since the translation will be the same either
	 * way.
	 */
<yellow>	ret = tdp_mmu_link_sp(kvm, iter, sp, false, shared);</yellow>
	if (ret)
		goto out;

	/*
	 * tdp_mmu_link_sp_atomic() will handle subtracting the huge page we
	 * are overwriting from the page stats. But we have to manually update
	 * the page stats with the new present child pages.
	 */
<yellow>	kvm_update_page_stats(kvm, level - 1, SPTE_ENT_PER_PAGE);</yellow>

out:
<yellow>	trace_kvm_mmu_split_huge_page(iter->gfn, huge_spte, level, ret);</yellow>
	return ret;
}

static int tdp_mmu_split_huge_pages_root(struct kvm *kvm,
					 struct kvm_mmu_page *root,
					 gfn_t start, gfn_t end,
					 int target_level, bool shared)
<yellow>{</yellow>
	struct kvm_mmu_page *sp = NULL;
	struct tdp_iter iter;
	int ret = 0;

<yellow>	rcu_read_lock();</yellow>

	/*
	 * Traverse the page table splitting all huge pages above the target
	 * level into one lower level. For example, if we encounter a 1GB page
	 * we split it into 512 2MB pages.
	 *
	 * Since the TDP iterator uses a pre-order traversal, we are guaranteed
	 * to visit an SPTE before ever visiting its children, which means we
	 * will correctly recursively split huge pages that are more than one
	 * level above the target level (e.g. splitting a 1GB to 512 2MB pages,
	 * and then splitting each of those to 512 4KB pages).
	 */
<yellow>	for_each_tdp_pte_min_level(iter, root, target_level + 1, start, end) {</yellow>
retry:
<yellow>		if (tdp_mmu_iter_cond_resched(kvm, &iter, false, shared))</yellow>
			continue;

<yellow>		if (!is_shadow_present_pte(iter.old_spte) || !is_large_pte(iter.old_spte))</yellow>
			continue;

<yellow>		if (!sp) {</yellow>
<yellow>			sp = tdp_mmu_alloc_sp_for_split(kvm, &iter, shared);</yellow>
			if (!sp) {
<yellow>				ret = -ENOMEM;</yellow>
<yellow>				trace_kvm_mmu_split_huge_page(iter.gfn,</yellow>
							      iter.old_spte,
							      iter.level, ret);
				break;
			}

<yellow>			if (iter.yielded)</yellow>
				continue;
		}

<yellow>		if (tdp_mmu_split_huge_page(kvm, &iter, sp, shared))</yellow>
			goto retry;

		sp = NULL;
	}

	rcu_read_unlock();

	/*
	 * It&#x27;s possible to exit the loop having never used the last sp if, for
	 * example, a vCPU doing HugePage NX splitting wins the race and
	 * installs its own sp in place of the last sp we tried to split.
	 */
	if (sp)
<yellow>		tdp_mmu_free_sp(sp);</yellow>

	return ret;
}


/*
 * Try to split all huge pages mapped by the TDP MMU down to the target level.
 */
void kvm_tdp_mmu_try_split_huge_pages(struct kvm *kvm,
				      const struct kvm_memory_slot *slot,
				      gfn_t start, gfn_t end,
				      int target_level, bool shared)
{
	struct kvm_mmu_page *root;
	int r = 0;

	kvm_lockdep_assert_mmu_lock_held(kvm, shared);

<yellow>	for_each_valid_tdp_mmu_root_yield_safe(kvm, root, slot->as_id, shared) {</yellow>
<yellow>		r = tdp_mmu_split_huge_pages_root(kvm, root, start, end, target_level, shared);</yellow>
		if (r) {
<yellow>			kvm_tdp_mmu_put_root(kvm, root, shared);</yellow>
			break;
		}
	}
<yellow>}</yellow>

/*
 * Clear the dirty status of all the SPTEs mapping GFNs in the memslot. If
 * AD bits are enabled, this will involve clearing the dirty bit on each SPTE.
 * If AD bits are not enabled, this will require clearing the writable bit on
 * each SPTE. Returns true if an SPTE has been changed and the TLBs need to
 * be flushed.
 */
static bool clear_dirty_gfn_range(struct kvm *kvm, struct kvm_mmu_page *root,
			   gfn_t start, gfn_t end)
{
	struct tdp_iter iter;
	u64 new_spte;
	bool spte_set = false;

<yellow>	rcu_read_lock();</yellow>

<yellow>	tdp_root_for_each_leaf_pte(iter, root, start, end) {</yellow>
retry:
<yellow>		if (tdp_mmu_iter_cond_resched(kvm, &iter, false, true))</yellow>
			continue;

<yellow>		if (!is_shadow_present_pte(iter.old_spte))</yellow>
			continue;

<yellow>		if (spte_ad_need_write_protect(iter.old_spte)) {</yellow>
<yellow>			if (is_writable_pte(iter.old_spte))</yellow>
<yellow>				new_spte = iter.old_spte & ~PT_WRITABLE_MASK;</yellow>
			else
				continue;
		} else {
<yellow>			if (iter.old_spte & shadow_dirty_mask)</yellow>
<yellow>				new_spte = iter.old_spte & ~shadow_dirty_mask;</yellow>
			else
				continue;
		}

<yellow>		if (tdp_mmu_set_spte_atomic(kvm, &iter, new_spte))</yellow>
			goto retry;

		spte_set = true;
	}

<yellow>	rcu_read_unlock();</yellow>
	return spte_set;
}

/*
 * Clear the dirty status of all the SPTEs mapping GFNs in the memslot. If
 * AD bits are enabled, this will involve clearing the dirty bit on each SPTE.
 * If AD bits are not enabled, this will require clearing the writable bit on
 * each SPTE. Returns true if an SPTE has been changed and the TLBs need to
 * be flushed.
 */
bool kvm_tdp_mmu_clear_dirty_slot(struct kvm *kvm,
				  const struct kvm_memory_slot *slot)
{
	struct kvm_mmu_page *root;
	bool spte_set = false;

	lockdep_assert_held_read(&amp;kvm-&gt;mmu_lock);

<yellow>	for_each_valid_tdp_mmu_root_yield_safe(kvm, root, slot->as_id, true)</yellow>
		spte_set |= clear_dirty_gfn_range(kvm, root, slot-&gt;base_gfn,
<yellow>				slot->base_gfn + slot->npages);</yellow>

	return spte_set;
<yellow>}</yellow>

/*
 * Clears the dirty status of all the 4k SPTEs mapping GFNs for which a bit is
 * set in mask, starting at gfn. The given memslot is expected to contain all
 * the GFNs represented by set bits in the mask. If AD bits are enabled,
 * clearing the dirty status will involve clearing the dirty bit on each SPTE
 * or, if AD bits are not enabled, clearing the writable bit on each SPTE.
 */
static void clear_dirty_pt_masked(struct kvm *kvm, struct kvm_mmu_page *root,
				  gfn_t gfn, unsigned long mask, bool wrprot)
{
	struct tdp_iter iter;
	u64 new_spte;

<yellow>	rcu_read_lock();</yellow>

<yellow>	tdp_root_for_each_leaf_pte(iter, root, gfn + __ffs(mask),</yellow>
				    gfn + BITS_PER_LONG) {
<yellow>		if (!mask)</yellow>
			break;

<yellow>		if (iter.level > PG_LEVEL_4K ||</yellow>
<yellow>		    !(mask & (1UL << (iter.gfn - gfn))))</yellow>
			continue;

		mask &amp;= ~(1UL &lt;&lt; (iter.gfn - gfn));

<yellow>		if (wrprot || spte_ad_need_write_protect(iter.old_spte)) {</yellow>
<yellow>			if (is_writable_pte(iter.old_spte))</yellow>
<yellow>				new_spte = iter.old_spte & ~PT_WRITABLE_MASK;</yellow>
			else
				continue;
		} else {
<yellow>			if (iter.old_spte & shadow_dirty_mask)</yellow>
<yellow>				new_spte = iter.old_spte & ~shadow_dirty_mask;</yellow>
			else
				continue;
		}

<yellow>		tdp_mmu_set_spte_no_dirty_log(kvm, &iter, new_spte);</yellow>
	}

<yellow>	rcu_read_unlock();</yellow>
}

/*
 * Clears the dirty status of all the 4k SPTEs mapping GFNs for which a bit is
 * set in mask, starting at gfn. The given memslot is expected to contain all
 * the GFNs represented by set bits in the mask. If AD bits are enabled,
 * clearing the dirty status will involve clearing the dirty bit on each SPTE
 * or, if AD bits are not enabled, clearing the writable bit on each SPTE.
 */
void kvm_tdp_mmu_clear_dirty_pt_masked(struct kvm *kvm,
				       struct kvm_memory_slot *slot,
				       gfn_t gfn, unsigned long mask,
				       bool wrprot)
{
	struct kvm_mmu_page *root;

	lockdep_assert_held_write(&amp;kvm-&gt;mmu_lock);
<yellow>	for_each_tdp_mmu_root(kvm, root, slot->as_id)</yellow>
<yellow>		clear_dirty_pt_masked(kvm, root, gfn, mask, wrprot);</yellow>
<yellow>}</yellow>

static void zap_collapsible_spte_range(struct kvm *kvm,
				       struct kvm_mmu_page *root,
				       const struct kvm_memory_slot *slot)
{
<yellow>	gfn_t start = slot->base_gfn;</yellow>
	gfn_t end = start + slot-&gt;npages;
	struct tdp_iter iter;
	int max_mapping_level;

	rcu_read_lock();

<yellow>	for_each_tdp_pte_min_level(iter, root, PG_LEVEL_2M, start, end) {</yellow>
retry:
<yellow>		if (tdp_mmu_iter_cond_resched(kvm, &iter, false, true))</yellow>
			continue;

<yellow>		if (iter.level > KVM_MAX_HUGEPAGE_LEVEL ||</yellow>
<yellow>		    !is_shadow_present_pte(iter.old_spte))</yellow>
			continue;

		/*
		 * Don&#x27;t zap leaf SPTEs, if a leaf SPTE could be replaced with
		 * a large page size, then its parent would have been zapped
		 * instead of stepping down.
		 */
<yellow>		if (is_last_spte(iter.old_spte, iter.level))</yellow>
			continue;

		/*
		 * If iter.gfn resides outside of the slot, i.e. the page for
		 * the current level overlaps but is not contained by the slot,
		 * then the SPTE can&#x27;t be made huge.  More importantly, trying
		 * to query that info from slot-&gt;arch.lpage_info will cause an
		 * out-of-bounds access.
		 */
<yellow>		if (iter.gfn < start || iter.gfn >= end)</yellow>
			continue;

<yellow>		max_mapping_level = kvm_mmu_max_mapping_level(kvm, slot,</yellow>
							      iter.gfn, PG_LEVEL_NUM);
		if (max_mapping_level &lt; iter.level)
			continue;

		/* Note, a successful atomic zap also does a remote TLB flush. */
<yellow>		if (tdp_mmu_zap_spte_atomic(kvm, &iter))</yellow>
			goto retry;
	}

<yellow>	rcu_read_unlock();</yellow>
}

/*
 * Zap non-leaf SPTEs (and free their associated page tables) which could
 * be replaced by huge pages, for GFNs within the slot.
 */
void kvm_tdp_mmu_zap_collapsible_sptes(struct kvm *kvm,
				       const struct kvm_memory_slot *slot)
{
	struct kvm_mmu_page *root;

	lockdep_assert_held_read(&amp;kvm-&gt;mmu_lock);

<yellow>	for_each_valid_tdp_mmu_root_yield_safe(kvm, root, slot->as_id, true)</yellow>
<yellow>		zap_collapsible_spte_range(kvm, root, slot);</yellow>
<yellow>}</yellow>

/*
 * Removes write access on the last level SPTE mapping this GFN and unsets the
 * MMU-writable bit to ensure future writes continue to be intercepted.
 * Returns true if an SPTE was set and a TLB flush is needed.
 */
static bool write_protect_gfn(struct kvm *kvm, struct kvm_mmu_page *root,
			      gfn_t gfn, int min_level)
{
	struct tdp_iter iter;
	u64 new_spte;
	bool spte_set = false;

<blue>	BUG_ON(min_level > KVM_MAX_HUGEPAGE_LEVEL);</blue>

<blue>	rcu_read_lock();</blue>

<blue>	for_each_tdp_pte_min_level(iter, root, min_level, gfn, gfn + 1) {</blue>
<blue>		if (!is_shadow_present_pte(iter.old_spte) ||</blue>
<blue>		    !is_last_spte(iter.old_spte, iter.level))</blue>
			continue;

		new_spte = iter.old_spte &amp;
<blue>			~(PT_WRITABLE_MASK | shadow_mmu_writable_mask);</blue>

		if (new_spte == iter.old_spte)
			break;

<blue>		tdp_mmu_set_spte(kvm, &iter, new_spte);</blue>
		spte_set = true;
	}

<blue>	rcu_read_unlock();</blue>

	return spte_set;
}

/*
 * Removes write access on the last level SPTE mapping this GFN and unsets the
 * MMU-writable bit to ensure future writes continue to be intercepted.
 * Returns true if an SPTE was set and a TLB flush is needed.
 */
bool kvm_tdp_mmu_write_protect_gfn(struct kvm *kvm,
				   struct kvm_memory_slot *slot, gfn_t gfn,
				   int min_level)
{
	struct kvm_mmu_page *root;
	bool spte_set = false;

	lockdep_assert_held_write(&amp;kvm-&gt;mmu_lock);
<blue>	for_each_tdp_mmu_root(kvm, root, slot->as_id)</blue>
<blue>		spte_set |= write_protect_gfn(kvm, root, gfn, min_level);</blue>

	return spte_set;
<blue>}</blue>

/*
 * Return the level of the lowest level SPTE added to sptes.
 * That SPTE may be non-present.
 *
 * Must be called between kvm_tdp_mmu_walk_lockless_{begin,end}.
 */
int kvm_tdp_mmu_get_walk(struct kvm_vcpu *vcpu, u64 addr, u64 *sptes,
			 int *root_level)
<blue>{</blue>
	struct tdp_iter iter;
<blue>	struct kvm_mmu *mmu = vcpu->arch.mmu;</blue>
	gfn_t gfn = addr &gt;&gt; PAGE_SHIFT;
	int leaf = -1;

	*root_level = vcpu-&gt;arch.mmu-&gt;root_role.level;

<blue>	tdp_mmu_for_each_pte(iter, mmu, gfn, gfn + 1) {</blue>
<blue>		leaf = iter.level;</blue>
		sptes[leaf] = iter.old_spte;
	}

	return leaf;
}

/*
 * Returns the last level spte pointer of the shadow page walk for the given
 * gpa, and sets *spte to the spte value. This spte may be non-preset. If no
 * walk could be performed, returns NULL and *spte does not contain valid data.
 *
 * Contract:
 *  - Must be called between kvm_tdp_mmu_walk_lockless_{begin,end}.
 *  - The returned sptep must not be used after kvm_tdp_mmu_walk_lockless_end.
 *
 * WARNING: This function is only intended to be called during fast_page_fault.
 */
u64 *kvm_tdp_mmu_fast_pf_get_last_sptep(struct kvm_vcpu *vcpu, u64 addr,
					u64 *spte)
<blue>{</blue>
	struct tdp_iter iter;
<blue>	struct kvm_mmu *mmu = vcpu->arch.mmu;</blue>
	gfn_t gfn = addr &gt;&gt; PAGE_SHIFT;
	tdp_ptep_t sptep = NULL;

<blue>	tdp_mmu_for_each_pte(iter, mmu, gfn, gfn + 1) {</blue>
<blue>		*spte = iter.old_spte;</blue>
		sptep = iter.sptep;
	}

	/*
	 * Perform the rcu_dereference to get the raw spte pointer value since
	 * we are passing it up to fast_page_fault, which is shared with the
	 * legacy MMU and thus does not retain the TDP MMU-specific __rcu
	 * annotation.
	 *
	 * This is safe since fast_page_fault obeys the contracts of this
	 * function as well as all TDP MMU contracts around modifying SPTEs
	 * outside of mmu_lock.
	 */
	return rcu_dereference(sptep);
}


</code></pre></td></tr></table>
</body>
</html>
