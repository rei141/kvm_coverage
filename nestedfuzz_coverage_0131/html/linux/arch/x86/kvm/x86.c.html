<doctype html>
<html lang="ja">
<head>
<meta charset="utf-8">
<script src="https://cdn.rawgit.com/google/code-prettify/master/loader/run_prettify.js"></script>
<style>
    code{
        font-family:Monaco, Menlo, Consolas, 'Courier New', Courier, monospace, sans-serif;
        font-size: 14px;
        line-height: 18px;
        overflow: auto;
        resize: horizontal;
    }
    code_line{
        font-family: Monaco, Menlo, Consolas, 'Courier New', Courier, monospace, sans-serif;;
        font-size: 14px;
        line-height: 18px;
        overflow: auto;
        resize: horizontal;
        color:#303134;
    }
    blue{
        background-color:#BEEDE8;
    }
    yellow{
        background-color:#FFFF99;
    }
    red{
        background-color:#FF99AC;
    }
</style>

</head>
<body>
<table summary='blob content' class='blob' cellspacing="15">
<tr><td align="right"><pre><code_line>1.
2.
3.
4.
5.
6.
7.
8.
9.
10.
11.
12.
13.
14.
15.
16.
17.
18.
19.
20.
21.
22.
23.
24.
25.
26.
27.
28.
29.
30.
31.
32.
33.
34.
35.
36.
37.
38.
39.
40.
41.
42.
43.
44.
45.
46.
47.
48.
49.
50.
51.
52.
53.
54.
55.
56.
57.
58.
59.
60.
61.
62.
63.
64.
65.
66.
67.
68.
69.
70.
71.
72.
73.
74.
75.
76.
77.
78.
79.
80.
81.
82.
83.
84.
85.
86.
87.
88.
89.
90.
91.
92.
93.
94.
95.
96.
97.
98.
99.
100.
101.
102.
103.
104.
105.
106.
107.
108.
109.
110.
111.
112.
113.
114.
115.
116.
117.
118.
119.
120.
121.
122.
123.
124.
125.
126.
127.
128.
129.
130.
131.
132.
133.
134.
135.
136.
137.
138.
139.
140.
141.
142.
143.
144.
145.
146.
147.
148.
149.
150.
151.
152.
153.
154.
155.
156.
157.
158.
159.
160.
161.
162.
163.
164.
165.
166.
167.
168.
169.
170.
171.
172.
173.
174.
175.
176.
177.
178.
179.
180.
181.
182.
183.
184.
185.
186.
187.
188.
189.
190.
191.
192.
193.
194.
195.
196.
197.
198.
199.
200.
201.
202.
203.
204.
205.
206.
207.
208.
209.
210.
211.
212.
213.
214.
215.
216.
217.
218.
219.
220.
221.
222.
223.
224.
225.
226.
227.
228.
229.
230.
231.
232.
233.
234.
235.
236.
237.
238.
239.
240.
241.
242.
243.
244.
245.
246.
247.
248.
249.
250.
251.
252.
253.
254.
255.
256.
257.
258.
259.
260.
261.
262.
263.
264.
265.
266.
267.
268.
269.
270.
271.
272.
273.
274.
275.
276.
277.
278.
279.
280.
281.
282.
283.
284.
285.
286.
287.
288.
289.
290.
291.
292.
293.
294.
295.
296.
297.
298.
299.
300.
301.
302.
303.
304.
305.
306.
307.
308.
309.
310.
311.
312.
313.
314.
315.
316.
317.
318.
319.
320.
321.
322.
323.
324.
325.
326.
327.
328.
329.
330.
331.
332.
333.
334.
335.
336.
337.
338.
339.
340.
341.
342.
343.
344.
345.
346.
347.
348.
349.
350.
351.
352.
353.
354.
355.
356.
357.
358.
359.
360.
361.
362.
363.
364.
365.
366.
367.
368.
369.
370.
371.
372.
373.
374.
375.
376.
377.
378.
379.
380.
381.
382.
383.
384.
385.
386.
387.
388.
389.
390.
391.
392.
393.
394.
395.
396.
397.
398.
399.
400.
401.
402.
403.
404.
405.
406.
407.
408.
409.
410.
411.
412.
413.
414.
415.
416.
417.
418.
419.
420.
421.
422.
423.
424.
425.
426.
427.
428.
429.
430.
431.
432.
433.
434.
435.
436.
437.
438.
439.
440.
441.
442.
443.
444.
445.
446.
447.
448.
449.
450.
451.
452.
453.
454.
455.
456.
457.
458.
459.
460.
461.
462.
463.
464.
465.
466.
467.
468.
469.
470.
471.
472.
473.
474.
475.
476.
477.
478.
479.
480.
481.
482.
483.
484.
485.
486.
487.
488.
489.
490.
491.
492.
493.
494.
495.
496.
497.
498.
499.
500.
501.
502.
503.
504.
505.
506.
507.
508.
509.
510.
511.
512.
513.
514.
515.
516.
517.
518.
519.
520.
521.
522.
523.
524.
525.
526.
527.
528.
529.
530.
531.
532.
533.
534.
535.
536.
537.
538.
539.
540.
541.
542.
543.
544.
545.
546.
547.
548.
549.
550.
551.
552.
553.
554.
555.
556.
557.
558.
559.
560.
561.
562.
563.
564.
565.
566.
567.
568.
569.
570.
571.
572.
573.
574.
575.
576.
577.
578.
579.
580.
581.
582.
583.
584.
585.
586.
587.
588.
589.
590.
591.
592.
593.
594.
595.
596.
597.
598.
599.
600.
601.
602.
603.
604.
605.
606.
607.
608.
609.
610.
611.
612.
613.
614.
615.
616.
617.
618.
619.
620.
621.
622.
623.
624.
625.
626.
627.
628.
629.
630.
631.
632.
633.
634.
635.
636.
637.
638.
639.
640.
641.
642.
643.
644.
645.
646.
647.
648.
649.
650.
651.
652.
653.
654.
655.
656.
657.
658.
659.
660.
661.
662.
663.
664.
665.
666.
667.
668.
669.
670.
671.
672.
673.
674.
675.
676.
677.
678.
679.
680.
681.
682.
683.
684.
685.
686.
687.
688.
689.
690.
691.
692.
693.
694.
695.
696.
697.
698.
699.
700.
701.
702.
703.
704.
705.
706.
707.
708.
709.
710.
711.
712.
713.
714.
715.
716.
717.
718.
719.
720.
721.
722.
723.
724.
725.
726.
727.
728.
729.
730.
731.
732.
733.
734.
735.
736.
737.
738.
739.
740.
741.
742.
743.
744.
745.
746.
747.
748.
749.
750.
751.
752.
753.
754.
755.
756.
757.
758.
759.
760.
761.
762.
763.
764.
765.
766.
767.
768.
769.
770.
771.
772.
773.
774.
775.
776.
777.
778.
779.
780.
781.
782.
783.
784.
785.
786.
787.
788.
789.
790.
791.
792.
793.
794.
795.
796.
797.
798.
799.
800.
801.
802.
803.
804.
805.
806.
807.
808.
809.
810.
811.
812.
813.
814.
815.
816.
817.
818.
819.
820.
821.
822.
823.
824.
825.
826.
827.
828.
829.
830.
831.
832.
833.
834.
835.
836.
837.
838.
839.
840.
841.
842.
843.
844.
845.
846.
847.
848.
849.
850.
851.
852.
853.
854.
855.
856.
857.
858.
859.
860.
861.
862.
863.
864.
865.
866.
867.
868.
869.
870.
871.
872.
873.
874.
875.
876.
877.
878.
879.
880.
881.
882.
883.
884.
885.
886.
887.
888.
889.
890.
891.
892.
893.
894.
895.
896.
897.
898.
899.
900.
901.
902.
903.
904.
905.
906.
907.
908.
909.
910.
911.
912.
913.
914.
915.
916.
917.
918.
919.
920.
921.
922.
923.
924.
925.
926.
927.
928.
929.
930.
931.
932.
933.
934.
935.
936.
937.
938.
939.
940.
941.
942.
943.
944.
945.
946.
947.
948.
949.
950.
951.
952.
953.
954.
955.
956.
957.
958.
959.
960.
961.
962.
963.
964.
965.
966.
967.
968.
969.
970.
971.
972.
973.
974.
975.
976.
977.
978.
979.
980.
981.
982.
983.
984.
985.
986.
987.
988.
989.
990.
991.
992.
993.
994.
995.
996.
997.
998.
999.
1000.
1001.
1002.
1003.
1004.
1005.
1006.
1007.
1008.
1009.
1010.
1011.
1012.
1013.
1014.
1015.
1016.
1017.
1018.
1019.
1020.
1021.
1022.
1023.
1024.
1025.
1026.
1027.
1028.
1029.
1030.
1031.
1032.
1033.
1034.
1035.
1036.
1037.
1038.
1039.
1040.
1041.
1042.
1043.
1044.
1045.
1046.
1047.
1048.
1049.
1050.
1051.
1052.
1053.
1054.
1055.
1056.
1057.
1058.
1059.
1060.
1061.
1062.
1063.
1064.
1065.
1066.
1067.
1068.
1069.
1070.
1071.
1072.
1073.
1074.
1075.
1076.
1077.
1078.
1079.
1080.
1081.
1082.
1083.
1084.
1085.
1086.
1087.
1088.
1089.
1090.
1091.
1092.
1093.
1094.
1095.
1096.
1097.
1098.
1099.
1100.
1101.
1102.
1103.
1104.
1105.
1106.
1107.
1108.
1109.
1110.
1111.
1112.
1113.
1114.
1115.
1116.
1117.
1118.
1119.
1120.
1121.
1122.
1123.
1124.
1125.
1126.
1127.
1128.
1129.
1130.
1131.
1132.
1133.
1134.
1135.
1136.
1137.
1138.
1139.
1140.
1141.
1142.
1143.
1144.
1145.
1146.
1147.
1148.
1149.
1150.
1151.
1152.
1153.
1154.
1155.
1156.
1157.
1158.
1159.
1160.
1161.
1162.
1163.
1164.
1165.
1166.
1167.
1168.
1169.
1170.
1171.
1172.
1173.
1174.
1175.
1176.
1177.
1178.
1179.
1180.
1181.
1182.
1183.
1184.
1185.
1186.
1187.
1188.
1189.
1190.
1191.
1192.
1193.
1194.
1195.
1196.
1197.
1198.
1199.
1200.
1201.
1202.
1203.
1204.
1205.
1206.
1207.
1208.
1209.
1210.
1211.
1212.
1213.
1214.
1215.
1216.
1217.
1218.
1219.
1220.
1221.
1222.
1223.
1224.
1225.
1226.
1227.
1228.
1229.
1230.
1231.
1232.
1233.
1234.
1235.
1236.
1237.
1238.
1239.
1240.
1241.
1242.
1243.
1244.
1245.
1246.
1247.
1248.
1249.
1250.
1251.
1252.
1253.
1254.
1255.
1256.
1257.
1258.
1259.
1260.
1261.
1262.
1263.
1264.
1265.
1266.
1267.
1268.
1269.
1270.
1271.
1272.
1273.
1274.
1275.
1276.
1277.
1278.
1279.
1280.
1281.
1282.
1283.
1284.
1285.
1286.
1287.
1288.
1289.
1290.
1291.
1292.
1293.
1294.
1295.
1296.
1297.
1298.
1299.
1300.
1301.
1302.
1303.
1304.
1305.
1306.
1307.
1308.
1309.
1310.
1311.
1312.
1313.
1314.
1315.
1316.
1317.
1318.
1319.
1320.
1321.
1322.
1323.
1324.
1325.
1326.
1327.
1328.
1329.
1330.
1331.
1332.
1333.
1334.
1335.
1336.
1337.
1338.
1339.
1340.
1341.
1342.
1343.
1344.
1345.
1346.
1347.
1348.
1349.
1350.
1351.
1352.
1353.
1354.
1355.
1356.
1357.
1358.
1359.
1360.
1361.
1362.
1363.
1364.
1365.
1366.
1367.
1368.
1369.
1370.
1371.
1372.
1373.
1374.
1375.
1376.
1377.
1378.
1379.
1380.
1381.
1382.
1383.
1384.
1385.
1386.
1387.
1388.
1389.
1390.
1391.
1392.
1393.
1394.
1395.
1396.
1397.
1398.
1399.
1400.
1401.
1402.
1403.
1404.
1405.
1406.
1407.
1408.
1409.
1410.
1411.
1412.
1413.
1414.
1415.
1416.
1417.
1418.
1419.
1420.
1421.
1422.
1423.
1424.
1425.
1426.
1427.
1428.
1429.
1430.
1431.
1432.
1433.
1434.
1435.
1436.
1437.
1438.
1439.
1440.
1441.
1442.
1443.
1444.
1445.
1446.
1447.
1448.
1449.
1450.
1451.
1452.
1453.
1454.
1455.
1456.
1457.
1458.
1459.
1460.
1461.
1462.
1463.
1464.
1465.
1466.
1467.
1468.
1469.
1470.
1471.
1472.
1473.
1474.
1475.
1476.
1477.
1478.
1479.
1480.
1481.
1482.
1483.
1484.
1485.
1486.
1487.
1488.
1489.
1490.
1491.
1492.
1493.
1494.
1495.
1496.
1497.
1498.
1499.
1500.
1501.
1502.
1503.
1504.
1505.
1506.
1507.
1508.
1509.
1510.
1511.
1512.
1513.
1514.
1515.
1516.
1517.
1518.
1519.
1520.
1521.
1522.
1523.
1524.
1525.
1526.
1527.
1528.
1529.
1530.
1531.
1532.
1533.
1534.
1535.
1536.
1537.
1538.
1539.
1540.
1541.
1542.
1543.
1544.
1545.
1546.
1547.
1548.
1549.
1550.
1551.
1552.
1553.
1554.
1555.
1556.
1557.
1558.
1559.
1560.
1561.
1562.
1563.
1564.
1565.
1566.
1567.
1568.
1569.
1570.
1571.
1572.
1573.
1574.
1575.
1576.
1577.
1578.
1579.
1580.
1581.
1582.
1583.
1584.
1585.
1586.
1587.
1588.
1589.
1590.
1591.
1592.
1593.
1594.
1595.
1596.
1597.
1598.
1599.
1600.
1601.
1602.
1603.
1604.
1605.
1606.
1607.
1608.
1609.
1610.
1611.
1612.
1613.
1614.
1615.
1616.
1617.
1618.
1619.
1620.
1621.
1622.
1623.
1624.
1625.
1626.
1627.
1628.
1629.
1630.
1631.
1632.
1633.
1634.
1635.
1636.
1637.
1638.
1639.
1640.
1641.
1642.
1643.
1644.
1645.
1646.
1647.
1648.
1649.
1650.
1651.
1652.
1653.
1654.
1655.
1656.
1657.
1658.
1659.
1660.
1661.
1662.
1663.
1664.
1665.
1666.
1667.
1668.
1669.
1670.
1671.
1672.
1673.
1674.
1675.
1676.
1677.
1678.
1679.
1680.
1681.
1682.
1683.
1684.
1685.
1686.
1687.
1688.
1689.
1690.
1691.
1692.
1693.
1694.
1695.
1696.
1697.
1698.
1699.
1700.
1701.
1702.
1703.
1704.
1705.
1706.
1707.
1708.
1709.
1710.
1711.
1712.
1713.
1714.
1715.
1716.
1717.
1718.
1719.
1720.
1721.
1722.
1723.
1724.
1725.
1726.
1727.
1728.
1729.
1730.
1731.
1732.
1733.
1734.
1735.
1736.
1737.
1738.
1739.
1740.
1741.
1742.
1743.
1744.
1745.
1746.
1747.
1748.
1749.
1750.
1751.
1752.
1753.
1754.
1755.
1756.
1757.
1758.
1759.
1760.
1761.
1762.
1763.
1764.
1765.
1766.
1767.
1768.
1769.
1770.
1771.
1772.
1773.
1774.
1775.
1776.
1777.
1778.
1779.
1780.
1781.
1782.
1783.
1784.
1785.
1786.
1787.
1788.
1789.
1790.
1791.
1792.
1793.
1794.
1795.
1796.
1797.
1798.
1799.
1800.
1801.
1802.
1803.
1804.
1805.
1806.
1807.
1808.
1809.
1810.
1811.
1812.
1813.
1814.
1815.
1816.
1817.
1818.
1819.
1820.
1821.
1822.
1823.
1824.
1825.
1826.
1827.
1828.
1829.
1830.
1831.
1832.
1833.
1834.
1835.
1836.
1837.
1838.
1839.
1840.
1841.
1842.
1843.
1844.
1845.
1846.
1847.
1848.
1849.
1850.
1851.
1852.
1853.
1854.
1855.
1856.
1857.
1858.
1859.
1860.
1861.
1862.
1863.
1864.
1865.
1866.
1867.
1868.
1869.
1870.
1871.
1872.
1873.
1874.
1875.
1876.
1877.
1878.
1879.
1880.
1881.
1882.
1883.
1884.
1885.
1886.
1887.
1888.
1889.
1890.
1891.
1892.
1893.
1894.
1895.
1896.
1897.
1898.
1899.
1900.
1901.
1902.
1903.
1904.
1905.
1906.
1907.
1908.
1909.
1910.
1911.
1912.
1913.
1914.
1915.
1916.
1917.
1918.
1919.
1920.
1921.
1922.
1923.
1924.
1925.
1926.
1927.
1928.
1929.
1930.
1931.
1932.
1933.
1934.
1935.
1936.
1937.
1938.
1939.
1940.
1941.
1942.
1943.
1944.
1945.
1946.
1947.
1948.
1949.
1950.
1951.
1952.
1953.
1954.
1955.
1956.
1957.
1958.
1959.
1960.
1961.
1962.
1963.
1964.
1965.
1966.
1967.
1968.
1969.
1970.
1971.
1972.
1973.
1974.
1975.
1976.
1977.
1978.
1979.
1980.
1981.
1982.
1983.
1984.
1985.
1986.
1987.
1988.
1989.
1990.
1991.
1992.
1993.
1994.
1995.
1996.
1997.
1998.
1999.
2000.
2001.
2002.
2003.
2004.
2005.
2006.
2007.
2008.
2009.
2010.
2011.
2012.
2013.
2014.
2015.
2016.
2017.
2018.
2019.
2020.
2021.
2022.
2023.
2024.
2025.
2026.
2027.
2028.
2029.
2030.
2031.
2032.
2033.
2034.
2035.
2036.
2037.
2038.
2039.
2040.
2041.
2042.
2043.
2044.
2045.
2046.
2047.
2048.
2049.
2050.
2051.
2052.
2053.
2054.
2055.
2056.
2057.
2058.
2059.
2060.
2061.
2062.
2063.
2064.
2065.
2066.
2067.
2068.
2069.
2070.
2071.
2072.
2073.
2074.
2075.
2076.
2077.
2078.
2079.
2080.
2081.
2082.
2083.
2084.
2085.
2086.
2087.
2088.
2089.
2090.
2091.
2092.
2093.
2094.
2095.
2096.
2097.
2098.
2099.
2100.
2101.
2102.
2103.
2104.
2105.
2106.
2107.
2108.
2109.
2110.
2111.
2112.
2113.
2114.
2115.
2116.
2117.
2118.
2119.
2120.
2121.
2122.
2123.
2124.
2125.
2126.
2127.
2128.
2129.
2130.
2131.
2132.
2133.
2134.
2135.
2136.
2137.
2138.
2139.
2140.
2141.
2142.
2143.
2144.
2145.
2146.
2147.
2148.
2149.
2150.
2151.
2152.
2153.
2154.
2155.
2156.
2157.
2158.
2159.
2160.
2161.
2162.
2163.
2164.
2165.
2166.
2167.
2168.
2169.
2170.
2171.
2172.
2173.
2174.
2175.
2176.
2177.
2178.
2179.
2180.
2181.
2182.
2183.
2184.
2185.
2186.
2187.
2188.
2189.
2190.
2191.
2192.
2193.
2194.
2195.
2196.
2197.
2198.
2199.
2200.
2201.
2202.
2203.
2204.
2205.
2206.
2207.
2208.
2209.
2210.
2211.
2212.
2213.
2214.
2215.
2216.
2217.
2218.
2219.
2220.
2221.
2222.
2223.
2224.
2225.
2226.
2227.
2228.
2229.
2230.
2231.
2232.
2233.
2234.
2235.
2236.
2237.
2238.
2239.
2240.
2241.
2242.
2243.
2244.
2245.
2246.
2247.
2248.
2249.
2250.
2251.
2252.
2253.
2254.
2255.
2256.
2257.
2258.
2259.
2260.
2261.
2262.
2263.
2264.
2265.
2266.
2267.
2268.
2269.
2270.
2271.
2272.
2273.
2274.
2275.
2276.
2277.
2278.
2279.
2280.
2281.
2282.
2283.
2284.
2285.
2286.
2287.
2288.
2289.
2290.
2291.
2292.
2293.
2294.
2295.
2296.
2297.
2298.
2299.
2300.
2301.
2302.
2303.
2304.
2305.
2306.
2307.
2308.
2309.
2310.
2311.
2312.
2313.
2314.
2315.
2316.
2317.
2318.
2319.
2320.
2321.
2322.
2323.
2324.
2325.
2326.
2327.
2328.
2329.
2330.
2331.
2332.
2333.
2334.
2335.
2336.
2337.
2338.
2339.
2340.
2341.
2342.
2343.
2344.
2345.
2346.
2347.
2348.
2349.
2350.
2351.
2352.
2353.
2354.
2355.
2356.
2357.
2358.
2359.
2360.
2361.
2362.
2363.
2364.
2365.
2366.
2367.
2368.
2369.
2370.
2371.
2372.
2373.
2374.
2375.
2376.
2377.
2378.
2379.
2380.
2381.
2382.
2383.
2384.
2385.
2386.
2387.
2388.
2389.
2390.
2391.
2392.
2393.
2394.
2395.
2396.
2397.
2398.
2399.
2400.
2401.
2402.
2403.
2404.
2405.
2406.
2407.
2408.
2409.
2410.
2411.
2412.
2413.
2414.
2415.
2416.
2417.
2418.
2419.
2420.
2421.
2422.
2423.
2424.
2425.
2426.
2427.
2428.
2429.
2430.
2431.
2432.
2433.
2434.
2435.
2436.
2437.
2438.
2439.
2440.
2441.
2442.
2443.
2444.
2445.
2446.
2447.
2448.
2449.
2450.
2451.
2452.
2453.
2454.
2455.
2456.
2457.
2458.
2459.
2460.
2461.
2462.
2463.
2464.
2465.
2466.
2467.
2468.
2469.
2470.
2471.
2472.
2473.
2474.
2475.
2476.
2477.
2478.
2479.
2480.
2481.
2482.
2483.
2484.
2485.
2486.
2487.
2488.
2489.
2490.
2491.
2492.
2493.
2494.
2495.
2496.
2497.
2498.
2499.
2500.
2501.
2502.
2503.
2504.
2505.
2506.
2507.
2508.
2509.
2510.
2511.
2512.
2513.
2514.
2515.
2516.
2517.
2518.
2519.
2520.
2521.
2522.
2523.
2524.
2525.
2526.
2527.
2528.
2529.
2530.
2531.
2532.
2533.
2534.
2535.
2536.
2537.
2538.
2539.
2540.
2541.
2542.
2543.
2544.
2545.
2546.
2547.
2548.
2549.
2550.
2551.
2552.
2553.
2554.
2555.
2556.
2557.
2558.
2559.
2560.
2561.
2562.
2563.
2564.
2565.
2566.
2567.
2568.
2569.
2570.
2571.
2572.
2573.
2574.
2575.
2576.
2577.
2578.
2579.
2580.
2581.
2582.
2583.
2584.
2585.
2586.
2587.
2588.
2589.
2590.
2591.
2592.
2593.
2594.
2595.
2596.
2597.
2598.
2599.
2600.
2601.
2602.
2603.
2604.
2605.
2606.
2607.
2608.
2609.
2610.
2611.
2612.
2613.
2614.
2615.
2616.
2617.
2618.
2619.
2620.
2621.
2622.
2623.
2624.
2625.
2626.
2627.
2628.
2629.
2630.
2631.
2632.
2633.
2634.
2635.
2636.
2637.
2638.
2639.
2640.
2641.
2642.
2643.
2644.
2645.
2646.
2647.
2648.
2649.
2650.
2651.
2652.
2653.
2654.
2655.
2656.
2657.
2658.
2659.
2660.
2661.
2662.
2663.
2664.
2665.
2666.
2667.
2668.
2669.
2670.
2671.
2672.
2673.
2674.
2675.
2676.
2677.
2678.
2679.
2680.
2681.
2682.
2683.
2684.
2685.
2686.
2687.
2688.
2689.
2690.
2691.
2692.
2693.
2694.
2695.
2696.
2697.
2698.
2699.
2700.
2701.
2702.
2703.
2704.
2705.
2706.
2707.
2708.
2709.
2710.
2711.
2712.
2713.
2714.
2715.
2716.
2717.
2718.
2719.
2720.
2721.
2722.
2723.
2724.
2725.
2726.
2727.
2728.
2729.
2730.
2731.
2732.
2733.
2734.
2735.
2736.
2737.
2738.
2739.
2740.
2741.
2742.
2743.
2744.
2745.
2746.
2747.
2748.
2749.
2750.
2751.
2752.
2753.
2754.
2755.
2756.
2757.
2758.
2759.
2760.
2761.
2762.
2763.
2764.
2765.
2766.
2767.
2768.
2769.
2770.
2771.
2772.
2773.
2774.
2775.
2776.
2777.
2778.
2779.
2780.
2781.
2782.
2783.
2784.
2785.
2786.
2787.
2788.
2789.
2790.
2791.
2792.
2793.
2794.
2795.
2796.
2797.
2798.
2799.
2800.
2801.
2802.
2803.
2804.
2805.
2806.
2807.
2808.
2809.
2810.
2811.
2812.
2813.
2814.
2815.
2816.
2817.
2818.
2819.
2820.
2821.
2822.
2823.
2824.
2825.
2826.
2827.
2828.
2829.
2830.
2831.
2832.
2833.
2834.
2835.
2836.
2837.
2838.
2839.
2840.
2841.
2842.
2843.
2844.
2845.
2846.
2847.
2848.
2849.
2850.
2851.
2852.
2853.
2854.
2855.
2856.
2857.
2858.
2859.
2860.
2861.
2862.
2863.
2864.
2865.
2866.
2867.
2868.
2869.
2870.
2871.
2872.
2873.
2874.
2875.
2876.
2877.
2878.
2879.
2880.
2881.
2882.
2883.
2884.
2885.
2886.
2887.
2888.
2889.
2890.
2891.
2892.
2893.
2894.
2895.
2896.
2897.
2898.
2899.
2900.
2901.
2902.
2903.
2904.
2905.
2906.
2907.
2908.
2909.
2910.
2911.
2912.
2913.
2914.
2915.
2916.
2917.
2918.
2919.
2920.
2921.
2922.
2923.
2924.
2925.
2926.
2927.
2928.
2929.
2930.
2931.
2932.
2933.
2934.
2935.
2936.
2937.
2938.
2939.
2940.
2941.
2942.
2943.
2944.
2945.
2946.
2947.
2948.
2949.
2950.
2951.
2952.
2953.
2954.
2955.
2956.
2957.
2958.
2959.
2960.
2961.
2962.
2963.
2964.
2965.
2966.
2967.
2968.
2969.
2970.
2971.
2972.
2973.
2974.
2975.
2976.
2977.
2978.
2979.
2980.
2981.
2982.
2983.
2984.
2985.
2986.
2987.
2988.
2989.
2990.
2991.
2992.
2993.
2994.
2995.
2996.
2997.
2998.
2999.
3000.
3001.
3002.
3003.
3004.
3005.
3006.
3007.
3008.
3009.
3010.
3011.
3012.
3013.
3014.
3015.
3016.
3017.
3018.
3019.
3020.
3021.
3022.
3023.
3024.
3025.
3026.
3027.
3028.
3029.
3030.
3031.
3032.
3033.
3034.
3035.
3036.
3037.
3038.
3039.
3040.
3041.
3042.
3043.
3044.
3045.
3046.
3047.
3048.
3049.
3050.
3051.
3052.
3053.
3054.
3055.
3056.
3057.
3058.
3059.
3060.
3061.
3062.
3063.
3064.
3065.
3066.
3067.
3068.
3069.
3070.
3071.
3072.
3073.
3074.
3075.
3076.
3077.
3078.
3079.
3080.
3081.
3082.
3083.
3084.
3085.
3086.
3087.
3088.
3089.
3090.
3091.
3092.
3093.
3094.
3095.
3096.
3097.
3098.
3099.
3100.
3101.
3102.
3103.
3104.
3105.
3106.
3107.
3108.
3109.
3110.
3111.
3112.
3113.
3114.
3115.
3116.
3117.
3118.
3119.
3120.
3121.
3122.
3123.
3124.
3125.
3126.
3127.
3128.
3129.
3130.
3131.
3132.
3133.
3134.
3135.
3136.
3137.
3138.
3139.
3140.
3141.
3142.
3143.
3144.
3145.
3146.
3147.
3148.
3149.
3150.
3151.
3152.
3153.
3154.
3155.
3156.
3157.
3158.
3159.
3160.
3161.
3162.
3163.
3164.
3165.
3166.
3167.
3168.
3169.
3170.
3171.
3172.
3173.
3174.
3175.
3176.
3177.
3178.
3179.
3180.
3181.
3182.
3183.
3184.
3185.
3186.
3187.
3188.
3189.
3190.
3191.
3192.
3193.
3194.
3195.
3196.
3197.
3198.
3199.
3200.
3201.
3202.
3203.
3204.
3205.
3206.
3207.
3208.
3209.
3210.
3211.
3212.
3213.
3214.
3215.
3216.
3217.
3218.
3219.
3220.
3221.
3222.
3223.
3224.
3225.
3226.
3227.
3228.
3229.
3230.
3231.
3232.
3233.
3234.
3235.
3236.
3237.
3238.
3239.
3240.
3241.
3242.
3243.
3244.
3245.
3246.
3247.
3248.
3249.
3250.
3251.
3252.
3253.
3254.
3255.
3256.
3257.
3258.
3259.
3260.
3261.
3262.
3263.
3264.
3265.
3266.
3267.
3268.
3269.
3270.
3271.
3272.
3273.
3274.
3275.
3276.
3277.
3278.
3279.
3280.
3281.
3282.
3283.
3284.
3285.
3286.
3287.
3288.
3289.
3290.
3291.
3292.
3293.
3294.
3295.
3296.
3297.
3298.
3299.
3300.
3301.
3302.
3303.
3304.
3305.
3306.
3307.
3308.
3309.
3310.
3311.
3312.
3313.
3314.
3315.
3316.
3317.
3318.
3319.
3320.
3321.
3322.
3323.
3324.
3325.
3326.
3327.
3328.
3329.
3330.
3331.
3332.
3333.
3334.
3335.
3336.
3337.
3338.
3339.
3340.
3341.
3342.
3343.
3344.
3345.
3346.
3347.
3348.
3349.
3350.
3351.
3352.
3353.
3354.
3355.
3356.
3357.
3358.
3359.
3360.
3361.
3362.
3363.
3364.
3365.
3366.
3367.
3368.
3369.
3370.
3371.
3372.
3373.
3374.
3375.
3376.
3377.
3378.
3379.
3380.
3381.
3382.
3383.
3384.
3385.
3386.
3387.
3388.
3389.
3390.
3391.
3392.
3393.
3394.
3395.
3396.
3397.
3398.
3399.
3400.
3401.
3402.
3403.
3404.
3405.
3406.
3407.
3408.
3409.
3410.
3411.
3412.
3413.
3414.
3415.
3416.
3417.
3418.
3419.
3420.
3421.
3422.
3423.
3424.
3425.
3426.
3427.
3428.
3429.
3430.
3431.
3432.
3433.
3434.
3435.
3436.
3437.
3438.
3439.
3440.
3441.
3442.
3443.
3444.
3445.
3446.
3447.
3448.
3449.
3450.
3451.
3452.
3453.
3454.
3455.
3456.
3457.
3458.
3459.
3460.
3461.
3462.
3463.
3464.
3465.
3466.
3467.
3468.
3469.
3470.
3471.
3472.
3473.
3474.
3475.
3476.
3477.
3478.
3479.
3480.
3481.
3482.
3483.
3484.
3485.
3486.
3487.
3488.
3489.
3490.
3491.
3492.
3493.
3494.
3495.
3496.
3497.
3498.
3499.
3500.
3501.
3502.
3503.
3504.
3505.
3506.
3507.
3508.
3509.
3510.
3511.
3512.
3513.
3514.
3515.
3516.
3517.
3518.
3519.
3520.
3521.
3522.
3523.
3524.
3525.
3526.
3527.
3528.
3529.
3530.
3531.
3532.
3533.
3534.
3535.
3536.
3537.
3538.
3539.
3540.
3541.
3542.
3543.
3544.
3545.
3546.
3547.
3548.
3549.
3550.
3551.
3552.
3553.
3554.
3555.
3556.
3557.
3558.
3559.
3560.
3561.
3562.
3563.
3564.
3565.
3566.
3567.
3568.
3569.
3570.
3571.
3572.
3573.
3574.
3575.
3576.
3577.
3578.
3579.
3580.
3581.
3582.
3583.
3584.
3585.
3586.
3587.
3588.
3589.
3590.
3591.
3592.
3593.
3594.
3595.
3596.
3597.
3598.
3599.
3600.
3601.
3602.
3603.
3604.
3605.
3606.
3607.
3608.
3609.
3610.
3611.
3612.
3613.
3614.
3615.
3616.
3617.
3618.
3619.
3620.
3621.
3622.
3623.
3624.
3625.
3626.
3627.
3628.
3629.
3630.
3631.
3632.
3633.
3634.
3635.
3636.
3637.
3638.
3639.
3640.
3641.
3642.
3643.
3644.
3645.
3646.
3647.
3648.
3649.
3650.
3651.
3652.
3653.
3654.
3655.
3656.
3657.
3658.
3659.
3660.
3661.
3662.
3663.
3664.
3665.
3666.
3667.
3668.
3669.
3670.
3671.
3672.
3673.
3674.
3675.
3676.
3677.
3678.
3679.
3680.
3681.
3682.
3683.
3684.
3685.
3686.
3687.
3688.
3689.
3690.
3691.
3692.
3693.
3694.
3695.
3696.
3697.
3698.
3699.
3700.
3701.
3702.
3703.
3704.
3705.
3706.
3707.
3708.
3709.
3710.
3711.
3712.
3713.
3714.
3715.
3716.
3717.
3718.
3719.
3720.
3721.
3722.
3723.
3724.
3725.
3726.
3727.
3728.
3729.
3730.
3731.
3732.
3733.
3734.
3735.
3736.
3737.
3738.
3739.
3740.
3741.
3742.
3743.
3744.
3745.
3746.
3747.
3748.
3749.
3750.
3751.
3752.
3753.
3754.
3755.
3756.
3757.
3758.
3759.
3760.
3761.
3762.
3763.
3764.
3765.
3766.
3767.
3768.
3769.
3770.
3771.
3772.
3773.
3774.
3775.
3776.
3777.
3778.
3779.
3780.
3781.
3782.
3783.
3784.
3785.
3786.
3787.
3788.
3789.
3790.
3791.
3792.
3793.
3794.
3795.
3796.
3797.
3798.
3799.
3800.
3801.
3802.
3803.
3804.
3805.
3806.
3807.
3808.
3809.
3810.
3811.
3812.
3813.
3814.
3815.
3816.
3817.
3818.
3819.
3820.
3821.
3822.
3823.
3824.
3825.
3826.
3827.
3828.
3829.
3830.
3831.
3832.
3833.
3834.
3835.
3836.
3837.
3838.
3839.
3840.
3841.
3842.
3843.
3844.
3845.
3846.
3847.
3848.
3849.
3850.
3851.
3852.
3853.
3854.
3855.
3856.
3857.
3858.
3859.
3860.
3861.
3862.
3863.
3864.
3865.
3866.
3867.
3868.
3869.
3870.
3871.
3872.
3873.
3874.
3875.
3876.
3877.
3878.
3879.
3880.
3881.
3882.
3883.
3884.
3885.
3886.
3887.
3888.
3889.
3890.
3891.
3892.
3893.
3894.
3895.
3896.
3897.
3898.
3899.
3900.
3901.
3902.
3903.
3904.
3905.
3906.
3907.
3908.
3909.
3910.
3911.
3912.
3913.
3914.
3915.
3916.
3917.
3918.
3919.
3920.
3921.
3922.
3923.
3924.
3925.
3926.
3927.
3928.
3929.
3930.
3931.
3932.
3933.
3934.
3935.
3936.
3937.
3938.
3939.
3940.
3941.
3942.
3943.
3944.
3945.
3946.
3947.
3948.
3949.
3950.
3951.
3952.
3953.
3954.
3955.
3956.
3957.
3958.
3959.
3960.
3961.
3962.
3963.
3964.
3965.
3966.
3967.
3968.
3969.
3970.
3971.
3972.
3973.
3974.
3975.
3976.
3977.
3978.
3979.
3980.
3981.
3982.
3983.
3984.
3985.
3986.
3987.
3988.
3989.
3990.
3991.
3992.
3993.
3994.
3995.
3996.
3997.
3998.
3999.
4000.
4001.
4002.
4003.
4004.
4005.
4006.
4007.
4008.
4009.
4010.
4011.
4012.
4013.
4014.
4015.
4016.
4017.
4018.
4019.
4020.
4021.
4022.
4023.
4024.
4025.
4026.
4027.
4028.
4029.
4030.
4031.
4032.
4033.
4034.
4035.
4036.
4037.
4038.
4039.
4040.
4041.
4042.
4043.
4044.
4045.
4046.
4047.
4048.
4049.
4050.
4051.
4052.
4053.
4054.
4055.
4056.
4057.
4058.
4059.
4060.
4061.
4062.
4063.
4064.
4065.
4066.
4067.
4068.
4069.
4070.
4071.
4072.
4073.
4074.
4075.
4076.
4077.
4078.
4079.
4080.
4081.
4082.
4083.
4084.
4085.
4086.
4087.
4088.
4089.
4090.
4091.
4092.
4093.
4094.
4095.
4096.
4097.
4098.
4099.
4100.
4101.
4102.
4103.
4104.
4105.
4106.
4107.
4108.
4109.
4110.
4111.
4112.
4113.
4114.
4115.
4116.
4117.
4118.
4119.
4120.
4121.
4122.
4123.
4124.
4125.
4126.
4127.
4128.
4129.
4130.
4131.
4132.
4133.
4134.
4135.
4136.
4137.
4138.
4139.
4140.
4141.
4142.
4143.
4144.
4145.
4146.
4147.
4148.
4149.
4150.
4151.
4152.
4153.
4154.
4155.
4156.
4157.
4158.
4159.
4160.
4161.
4162.
4163.
4164.
4165.
4166.
4167.
4168.
4169.
4170.
4171.
4172.
4173.
4174.
4175.
4176.
4177.
4178.
4179.
4180.
4181.
4182.
4183.
4184.
4185.
4186.
4187.
4188.
4189.
4190.
4191.
4192.
4193.
4194.
4195.
4196.
4197.
4198.
4199.
4200.
4201.
4202.
4203.
4204.
4205.
4206.
4207.
4208.
4209.
4210.
4211.
4212.
4213.
4214.
4215.
4216.
4217.
4218.
4219.
4220.
4221.
4222.
4223.
4224.
4225.
4226.
4227.
4228.
4229.
4230.
4231.
4232.
4233.
4234.
4235.
4236.
4237.
4238.
4239.
4240.
4241.
4242.
4243.
4244.
4245.
4246.
4247.
4248.
4249.
4250.
4251.
4252.
4253.
4254.
4255.
4256.
4257.
4258.
4259.
4260.
4261.
4262.
4263.
4264.
4265.
4266.
4267.
4268.
4269.
4270.
4271.
4272.
4273.
4274.
4275.
4276.
4277.
4278.
4279.
4280.
4281.
4282.
4283.
4284.
4285.
4286.
4287.
4288.
4289.
4290.
4291.
4292.
4293.
4294.
4295.
4296.
4297.
4298.
4299.
4300.
4301.
4302.
4303.
4304.
4305.
4306.
4307.
4308.
4309.
4310.
4311.
4312.
4313.
4314.
4315.
4316.
4317.
4318.
4319.
4320.
4321.
4322.
4323.
4324.
4325.
4326.
4327.
4328.
4329.
4330.
4331.
4332.
4333.
4334.
4335.
4336.
4337.
4338.
4339.
4340.
4341.
4342.
4343.
4344.
4345.
4346.
4347.
4348.
4349.
4350.
4351.
4352.
4353.
4354.
4355.
4356.
4357.
4358.
4359.
4360.
4361.
4362.
4363.
4364.
4365.
4366.
4367.
4368.
4369.
4370.
4371.
4372.
4373.
4374.
4375.
4376.
4377.
4378.
4379.
4380.
4381.
4382.
4383.
4384.
4385.
4386.
4387.
4388.
4389.
4390.
4391.
4392.
4393.
4394.
4395.
4396.
4397.
4398.
4399.
4400.
4401.
4402.
4403.
4404.
4405.
4406.
4407.
4408.
4409.
4410.
4411.
4412.
4413.
4414.
4415.
4416.
4417.
4418.
4419.
4420.
4421.
4422.
4423.
4424.
4425.
4426.
4427.
4428.
4429.
4430.
4431.
4432.
4433.
4434.
4435.
4436.
4437.
4438.
4439.
4440.
4441.
4442.
4443.
4444.
4445.
4446.
4447.
4448.
4449.
4450.
4451.
4452.
4453.
4454.
4455.
4456.
4457.
4458.
4459.
4460.
4461.
4462.
4463.
4464.
4465.
4466.
4467.
4468.
4469.
4470.
4471.
4472.
4473.
4474.
4475.
4476.
4477.
4478.
4479.
4480.
4481.
4482.
4483.
4484.
4485.
4486.
4487.
4488.
4489.
4490.
4491.
4492.
4493.
4494.
4495.
4496.
4497.
4498.
4499.
4500.
4501.
4502.
4503.
4504.
4505.
4506.
4507.
4508.
4509.
4510.
4511.
4512.
4513.
4514.
4515.
4516.
4517.
4518.
4519.
4520.
4521.
4522.
4523.
4524.
4525.
4526.
4527.
4528.
4529.
4530.
4531.
4532.
4533.
4534.
4535.
4536.
4537.
4538.
4539.
4540.
4541.
4542.
4543.
4544.
4545.
4546.
4547.
4548.
4549.
4550.
4551.
4552.
4553.
4554.
4555.
4556.
4557.
4558.
4559.
4560.
4561.
4562.
4563.
4564.
4565.
4566.
4567.
4568.
4569.
4570.
4571.
4572.
4573.
4574.
4575.
4576.
4577.
4578.
4579.
4580.
4581.
4582.
4583.
4584.
4585.
4586.
4587.
4588.
4589.
4590.
4591.
4592.
4593.
4594.
4595.
4596.
4597.
4598.
4599.
4600.
4601.
4602.
4603.
4604.
4605.
4606.
4607.
4608.
4609.
4610.
4611.
4612.
4613.
4614.
4615.
4616.
4617.
4618.
4619.
4620.
4621.
4622.
4623.
4624.
4625.
4626.
4627.
4628.
4629.
4630.
4631.
4632.
4633.
4634.
4635.
4636.
4637.
4638.
4639.
4640.
4641.
4642.
4643.
4644.
4645.
4646.
4647.
4648.
4649.
4650.
4651.
4652.
4653.
4654.
4655.
4656.
4657.
4658.
4659.
4660.
4661.
4662.
4663.
4664.
4665.
4666.
4667.
4668.
4669.
4670.
4671.
4672.
4673.
4674.
4675.
4676.
4677.
4678.
4679.
4680.
4681.
4682.
4683.
4684.
4685.
4686.
4687.
4688.
4689.
4690.
4691.
4692.
4693.
4694.
4695.
4696.
4697.
4698.
4699.
4700.
4701.
4702.
4703.
4704.
4705.
4706.
4707.
4708.
4709.
4710.
4711.
4712.
4713.
4714.
4715.
4716.
4717.
4718.
4719.
4720.
4721.
4722.
4723.
4724.
4725.
4726.
4727.
4728.
4729.
4730.
4731.
4732.
4733.
4734.
4735.
4736.
4737.
4738.
4739.
4740.
4741.
4742.
4743.
4744.
4745.
4746.
4747.
4748.
4749.
4750.
4751.
4752.
4753.
4754.
4755.
4756.
4757.
4758.
4759.
4760.
4761.
4762.
4763.
4764.
4765.
4766.
4767.
4768.
4769.
4770.
4771.
4772.
4773.
4774.
4775.
4776.
4777.
4778.
4779.
4780.
4781.
4782.
4783.
4784.
4785.
4786.
4787.
4788.
4789.
4790.
4791.
4792.
4793.
4794.
4795.
4796.
4797.
4798.
4799.
4800.
4801.
4802.
4803.
4804.
4805.
4806.
4807.
4808.
4809.
4810.
4811.
4812.
4813.
4814.
4815.
4816.
4817.
4818.
4819.
4820.
4821.
4822.
4823.
4824.
4825.
4826.
4827.
4828.
4829.
4830.
4831.
4832.
4833.
4834.
4835.
4836.
4837.
4838.
4839.
4840.
4841.
4842.
4843.
4844.
4845.
4846.
4847.
4848.
4849.
4850.
4851.
4852.
4853.
4854.
4855.
4856.
4857.
4858.
4859.
4860.
4861.
4862.
4863.
4864.
4865.
4866.
4867.
4868.
4869.
4870.
4871.
4872.
4873.
4874.
4875.
4876.
4877.
4878.
4879.
4880.
4881.
4882.
4883.
4884.
4885.
4886.
4887.
4888.
4889.
4890.
4891.
4892.
4893.
4894.
4895.
4896.
4897.
4898.
4899.
4900.
4901.
4902.
4903.
4904.
4905.
4906.
4907.
4908.
4909.
4910.
4911.
4912.
4913.
4914.
4915.
4916.
4917.
4918.
4919.
4920.
4921.
4922.
4923.
4924.
4925.
4926.
4927.
4928.
4929.
4930.
4931.
4932.
4933.
4934.
4935.
4936.
4937.
4938.
4939.
4940.
4941.
4942.
4943.
4944.
4945.
4946.
4947.
4948.
4949.
4950.
4951.
4952.
4953.
4954.
4955.
4956.
4957.
4958.
4959.
4960.
4961.
4962.
4963.
4964.
4965.
4966.
4967.
4968.
4969.
4970.
4971.
4972.
4973.
4974.
4975.
4976.
4977.
4978.
4979.
4980.
4981.
4982.
4983.
4984.
4985.
4986.
4987.
4988.
4989.
4990.
4991.
4992.
4993.
4994.
4995.
4996.
4997.
4998.
4999.
5000.
5001.
5002.
5003.
5004.
5005.
5006.
5007.
5008.
5009.
5010.
5011.
5012.
5013.
5014.
5015.
5016.
5017.
5018.
5019.
5020.
5021.
5022.
5023.
5024.
5025.
5026.
5027.
5028.
5029.
5030.
5031.
5032.
5033.
5034.
5035.
5036.
5037.
5038.
5039.
5040.
5041.
5042.
5043.
5044.
5045.
5046.
5047.
5048.
5049.
5050.
5051.
5052.
5053.
5054.
5055.
5056.
5057.
5058.
5059.
5060.
5061.
5062.
5063.
5064.
5065.
5066.
5067.
5068.
5069.
5070.
5071.
5072.
5073.
5074.
5075.
5076.
5077.
5078.
5079.
5080.
5081.
5082.
5083.
5084.
5085.
5086.
5087.
5088.
5089.
5090.
5091.
5092.
5093.
5094.
5095.
5096.
5097.
5098.
5099.
5100.
5101.
5102.
5103.
5104.
5105.
5106.
5107.
5108.
5109.
5110.
5111.
5112.
5113.
5114.
5115.
5116.
5117.
5118.
5119.
5120.
5121.
5122.
5123.
5124.
5125.
5126.
5127.
5128.
5129.
5130.
5131.
5132.
5133.
5134.
5135.
5136.
5137.
5138.
5139.
5140.
5141.
5142.
5143.
5144.
5145.
5146.
5147.
5148.
5149.
5150.
5151.
5152.
5153.
5154.
5155.
5156.
5157.
5158.
5159.
5160.
5161.
5162.
5163.
5164.
5165.
5166.
5167.
5168.
5169.
5170.
5171.
5172.
5173.
5174.
5175.
5176.
5177.
5178.
5179.
5180.
5181.
5182.
5183.
5184.
5185.
5186.
5187.
5188.
5189.
5190.
5191.
5192.
5193.
5194.
5195.
5196.
5197.
5198.
5199.
5200.
5201.
5202.
5203.
5204.
5205.
5206.
5207.
5208.
5209.
5210.
5211.
5212.
5213.
5214.
5215.
5216.
5217.
5218.
5219.
5220.
5221.
5222.
5223.
5224.
5225.
5226.
5227.
5228.
5229.
5230.
5231.
5232.
5233.
5234.
5235.
5236.
5237.
5238.
5239.
5240.
5241.
5242.
5243.
5244.
5245.
5246.
5247.
5248.
5249.
5250.
5251.
5252.
5253.
5254.
5255.
5256.
5257.
5258.
5259.
5260.
5261.
5262.
5263.
5264.
5265.
5266.
5267.
5268.
5269.
5270.
5271.
5272.
5273.
5274.
5275.
5276.
5277.
5278.
5279.
5280.
5281.
5282.
5283.
5284.
5285.
5286.
5287.
5288.
5289.
5290.
5291.
5292.
5293.
5294.
5295.
5296.
5297.
5298.
5299.
5300.
5301.
5302.
5303.
5304.
5305.
5306.
5307.
5308.
5309.
5310.
5311.
5312.
5313.
5314.
5315.
5316.
5317.
5318.
5319.
5320.
5321.
5322.
5323.
5324.
5325.
5326.
5327.
5328.
5329.
5330.
5331.
5332.
5333.
5334.
5335.
5336.
5337.
5338.
5339.
5340.
5341.
5342.
5343.
5344.
5345.
5346.
5347.
5348.
5349.
5350.
5351.
5352.
5353.
5354.
5355.
5356.
5357.
5358.
5359.
5360.
5361.
5362.
5363.
5364.
5365.
5366.
5367.
5368.
5369.
5370.
5371.
5372.
5373.
5374.
5375.
5376.
5377.
5378.
5379.
5380.
5381.
5382.
5383.
5384.
5385.
5386.
5387.
5388.
5389.
5390.
5391.
5392.
5393.
5394.
5395.
5396.
5397.
5398.
5399.
5400.
5401.
5402.
5403.
5404.
5405.
5406.
5407.
5408.
5409.
5410.
5411.
5412.
5413.
5414.
5415.
5416.
5417.
5418.
5419.
5420.
5421.
5422.
5423.
5424.
5425.
5426.
5427.
5428.
5429.
5430.
5431.
5432.
5433.
5434.
5435.
5436.
5437.
5438.
5439.
5440.
5441.
5442.
5443.
5444.
5445.
5446.
5447.
5448.
5449.
5450.
5451.
5452.
5453.
5454.
5455.
5456.
5457.
5458.
5459.
5460.
5461.
5462.
5463.
5464.
5465.
5466.
5467.
5468.
5469.
5470.
5471.
5472.
5473.
5474.
5475.
5476.
5477.
5478.
5479.
5480.
5481.
5482.
5483.
5484.
5485.
5486.
5487.
5488.
5489.
5490.
5491.
5492.
5493.
5494.
5495.
5496.
5497.
5498.
5499.
5500.
5501.
5502.
5503.
5504.
5505.
5506.
5507.
5508.
5509.
5510.
5511.
5512.
5513.
5514.
5515.
5516.
5517.
5518.
5519.
5520.
5521.
5522.
5523.
5524.
5525.
5526.
5527.
5528.
5529.
5530.
5531.
5532.
5533.
5534.
5535.
5536.
5537.
5538.
5539.
5540.
5541.
5542.
5543.
5544.
5545.
5546.
5547.
5548.
5549.
5550.
5551.
5552.
5553.
5554.
5555.
5556.
5557.
5558.
5559.
5560.
5561.
5562.
5563.
5564.
5565.
5566.
5567.
5568.
5569.
5570.
5571.
5572.
5573.
5574.
5575.
5576.
5577.
5578.
5579.
5580.
5581.
5582.
5583.
5584.
5585.
5586.
5587.
5588.
5589.
5590.
5591.
5592.
5593.
5594.
5595.
5596.
5597.
5598.
5599.
5600.
5601.
5602.
5603.
5604.
5605.
5606.
5607.
5608.
5609.
5610.
5611.
5612.
5613.
5614.
5615.
5616.
5617.
5618.
5619.
5620.
5621.
5622.
5623.
5624.
5625.
5626.
5627.
5628.
5629.
5630.
5631.
5632.
5633.
5634.
5635.
5636.
5637.
5638.
5639.
5640.
5641.
5642.
5643.
5644.
5645.
5646.
5647.
5648.
5649.
5650.
5651.
5652.
5653.
5654.
5655.
5656.
5657.
5658.
5659.
5660.
5661.
5662.
5663.
5664.
5665.
5666.
5667.
5668.
5669.
5670.
5671.
5672.
5673.
5674.
5675.
5676.
5677.
5678.
5679.
5680.
5681.
5682.
5683.
5684.
5685.
5686.
5687.
5688.
5689.
5690.
5691.
5692.
5693.
5694.
5695.
5696.
5697.
5698.
5699.
5700.
5701.
5702.
5703.
5704.
5705.
5706.
5707.
5708.
5709.
5710.
5711.
5712.
5713.
5714.
5715.
5716.
5717.
5718.
5719.
5720.
5721.
5722.
5723.
5724.
5725.
5726.
5727.
5728.
5729.
5730.
5731.
5732.
5733.
5734.
5735.
5736.
5737.
5738.
5739.
5740.
5741.
5742.
5743.
5744.
5745.
5746.
5747.
5748.
5749.
5750.
5751.
5752.
5753.
5754.
5755.
5756.
5757.
5758.
5759.
5760.
5761.
5762.
5763.
5764.
5765.
5766.
5767.
5768.
5769.
5770.
5771.
5772.
5773.
5774.
5775.
5776.
5777.
5778.
5779.
5780.
5781.
5782.
5783.
5784.
5785.
5786.
5787.
5788.
5789.
5790.
5791.
5792.
5793.
5794.
5795.
5796.
5797.
5798.
5799.
5800.
5801.
5802.
5803.
5804.
5805.
5806.
5807.
5808.
5809.
5810.
5811.
5812.
5813.
5814.
5815.
5816.
5817.
5818.
5819.
5820.
5821.
5822.
5823.
5824.
5825.
5826.
5827.
5828.
5829.
5830.
5831.
5832.
5833.
5834.
5835.
5836.
5837.
5838.
5839.
5840.
5841.
5842.
5843.
5844.
5845.
5846.
5847.
5848.
5849.
5850.
5851.
5852.
5853.
5854.
5855.
5856.
5857.
5858.
5859.
5860.
5861.
5862.
5863.
5864.
5865.
5866.
5867.
5868.
5869.
5870.
5871.
5872.
5873.
5874.
5875.
5876.
5877.
5878.
5879.
5880.
5881.
5882.
5883.
5884.
5885.
5886.
5887.
5888.
5889.
5890.
5891.
5892.
5893.
5894.
5895.
5896.
5897.
5898.
5899.
5900.
5901.
5902.
5903.
5904.
5905.
5906.
5907.
5908.
5909.
5910.
5911.
5912.
5913.
5914.
5915.
5916.
5917.
5918.
5919.
5920.
5921.
5922.
5923.
5924.
5925.
5926.
5927.
5928.
5929.
5930.
5931.
5932.
5933.
5934.
5935.
5936.
5937.
5938.
5939.
5940.
5941.
5942.
5943.
5944.
5945.
5946.
5947.
5948.
5949.
5950.
5951.
5952.
5953.
5954.
5955.
5956.
5957.
5958.
5959.
5960.
5961.
5962.
5963.
5964.
5965.
5966.
5967.
5968.
5969.
5970.
5971.
5972.
5973.
5974.
5975.
5976.
5977.
5978.
5979.
5980.
5981.
5982.
5983.
5984.
5985.
5986.
5987.
5988.
5989.
5990.
5991.
5992.
5993.
5994.
5995.
5996.
5997.
5998.
5999.
6000.
6001.
6002.
6003.
6004.
6005.
6006.
6007.
6008.
6009.
6010.
6011.
6012.
6013.
6014.
6015.
6016.
6017.
6018.
6019.
6020.
6021.
6022.
6023.
6024.
6025.
6026.
6027.
6028.
6029.
6030.
6031.
6032.
6033.
6034.
6035.
6036.
6037.
6038.
6039.
6040.
6041.
6042.
6043.
6044.
6045.
6046.
6047.
6048.
6049.
6050.
6051.
6052.
6053.
6054.
6055.
6056.
6057.
6058.
6059.
6060.
6061.
6062.
6063.
6064.
6065.
6066.
6067.
6068.
6069.
6070.
6071.
6072.
6073.
6074.
6075.
6076.
6077.
6078.
6079.
6080.
6081.
6082.
6083.
6084.
6085.
6086.
6087.
6088.
6089.
6090.
6091.
6092.
6093.
6094.
6095.
6096.
6097.
6098.
6099.
6100.
6101.
6102.
6103.
6104.
6105.
6106.
6107.
6108.
6109.
6110.
6111.
6112.
6113.
6114.
6115.
6116.
6117.
6118.
6119.
6120.
6121.
6122.
6123.
6124.
6125.
6126.
6127.
6128.
6129.
6130.
6131.
6132.
6133.
6134.
6135.
6136.
6137.
6138.
6139.
6140.
6141.
6142.
6143.
6144.
6145.
6146.
6147.
6148.
6149.
6150.
6151.
6152.
6153.
6154.
6155.
6156.
6157.
6158.
6159.
6160.
6161.
6162.
6163.
6164.
6165.
6166.
6167.
6168.
6169.
6170.
6171.
6172.
6173.
6174.
6175.
6176.
6177.
6178.
6179.
6180.
6181.
6182.
6183.
6184.
6185.
6186.
6187.
6188.
6189.
6190.
6191.
6192.
6193.
6194.
6195.
6196.
6197.
6198.
6199.
6200.
6201.
6202.
6203.
6204.
6205.
6206.
6207.
6208.
6209.
6210.
6211.
6212.
6213.
6214.
6215.
6216.
6217.
6218.
6219.
6220.
6221.
6222.
6223.
6224.
6225.
6226.
6227.
6228.
6229.
6230.
6231.
6232.
6233.
6234.
6235.
6236.
6237.
6238.
6239.
6240.
6241.
6242.
6243.
6244.
6245.
6246.
6247.
6248.
6249.
6250.
6251.
6252.
6253.
6254.
6255.
6256.
6257.
6258.
6259.
6260.
6261.
6262.
6263.
6264.
6265.
6266.
6267.
6268.
6269.
6270.
6271.
6272.
6273.
6274.
6275.
6276.
6277.
6278.
6279.
6280.
6281.
6282.
6283.
6284.
6285.
6286.
6287.
6288.
6289.
6290.
6291.
6292.
6293.
6294.
6295.
6296.
6297.
6298.
6299.
6300.
6301.
6302.
6303.
6304.
6305.
6306.
6307.
6308.
6309.
6310.
6311.
6312.
6313.
6314.
6315.
6316.
6317.
6318.
6319.
6320.
6321.
6322.
6323.
6324.
6325.
6326.
6327.
6328.
6329.
6330.
6331.
6332.
6333.
6334.
6335.
6336.
6337.
6338.
6339.
6340.
6341.
6342.
6343.
6344.
6345.
6346.
6347.
6348.
6349.
6350.
6351.
6352.
6353.
6354.
6355.
6356.
6357.
6358.
6359.
6360.
6361.
6362.
6363.
6364.
6365.
6366.
6367.
6368.
6369.
6370.
6371.
6372.
6373.
6374.
6375.
6376.
6377.
6378.
6379.
6380.
6381.
6382.
6383.
6384.
6385.
6386.
6387.
6388.
6389.
6390.
6391.
6392.
6393.
6394.
6395.
6396.
6397.
6398.
6399.
6400.
6401.
6402.
6403.
6404.
6405.
6406.
6407.
6408.
6409.
6410.
6411.
6412.
6413.
6414.
6415.
6416.
6417.
6418.
6419.
6420.
6421.
6422.
6423.
6424.
6425.
6426.
6427.
6428.
6429.
6430.
6431.
6432.
6433.
6434.
6435.
6436.
6437.
6438.
6439.
6440.
6441.
6442.
6443.
6444.
6445.
6446.
6447.
6448.
6449.
6450.
6451.
6452.
6453.
6454.
6455.
6456.
6457.
6458.
6459.
6460.
6461.
6462.
6463.
6464.
6465.
6466.
6467.
6468.
6469.
6470.
6471.
6472.
6473.
6474.
6475.
6476.
6477.
6478.
6479.
6480.
6481.
6482.
6483.
6484.
6485.
6486.
6487.
6488.
6489.
6490.
6491.
6492.
6493.
6494.
6495.
6496.
6497.
6498.
6499.
6500.
6501.
6502.
6503.
6504.
6505.
6506.
6507.
6508.
6509.
6510.
6511.
6512.
6513.
6514.
6515.
6516.
6517.
6518.
6519.
6520.
6521.
6522.
6523.
6524.
6525.
6526.
6527.
6528.
6529.
6530.
6531.
6532.
6533.
6534.
6535.
6536.
6537.
6538.
6539.
6540.
6541.
6542.
6543.
6544.
6545.
6546.
6547.
6548.
6549.
6550.
6551.
6552.
6553.
6554.
6555.
6556.
6557.
6558.
6559.
6560.
6561.
6562.
6563.
6564.
6565.
6566.
6567.
6568.
6569.
6570.
6571.
6572.
6573.
6574.
6575.
6576.
6577.
6578.
6579.
6580.
6581.
6582.
6583.
6584.
6585.
6586.
6587.
6588.
6589.
6590.
6591.
6592.
6593.
6594.
6595.
6596.
6597.
6598.
6599.
6600.
6601.
6602.
6603.
6604.
6605.
6606.
6607.
6608.
6609.
6610.
6611.
6612.
6613.
6614.
6615.
6616.
6617.
6618.
6619.
6620.
6621.
6622.
6623.
6624.
6625.
6626.
6627.
6628.
6629.
6630.
6631.
6632.
6633.
6634.
6635.
6636.
6637.
6638.
6639.
6640.
6641.
6642.
6643.
6644.
6645.
6646.
6647.
6648.
6649.
6650.
6651.
6652.
6653.
6654.
6655.
6656.
6657.
6658.
6659.
6660.
6661.
6662.
6663.
6664.
6665.
6666.
6667.
6668.
6669.
6670.
6671.
6672.
6673.
6674.
6675.
6676.
6677.
6678.
6679.
6680.
6681.
6682.
6683.
6684.
6685.
6686.
6687.
6688.
6689.
6690.
6691.
6692.
6693.
6694.
6695.
6696.
6697.
6698.
6699.
6700.
6701.
6702.
6703.
6704.
6705.
6706.
6707.
6708.
6709.
6710.
6711.
6712.
6713.
6714.
6715.
6716.
6717.
6718.
6719.
6720.
6721.
6722.
6723.
6724.
6725.
6726.
6727.
6728.
6729.
6730.
6731.
6732.
6733.
6734.
6735.
6736.
6737.
6738.
6739.
6740.
6741.
6742.
6743.
6744.
6745.
6746.
6747.
6748.
6749.
6750.
6751.
6752.
6753.
6754.
6755.
6756.
6757.
6758.
6759.
6760.
6761.
6762.
6763.
6764.
6765.
6766.
6767.
6768.
6769.
6770.
6771.
6772.
6773.
6774.
6775.
6776.
6777.
6778.
6779.
6780.
6781.
6782.
6783.
6784.
6785.
6786.
6787.
6788.
6789.
6790.
6791.
6792.
6793.
6794.
6795.
6796.
6797.
6798.
6799.
6800.
6801.
6802.
6803.
6804.
6805.
6806.
6807.
6808.
6809.
6810.
6811.
6812.
6813.
6814.
6815.
6816.
6817.
6818.
6819.
6820.
6821.
6822.
6823.
6824.
6825.
6826.
6827.
6828.
6829.
6830.
6831.
6832.
6833.
6834.
6835.
6836.
6837.
6838.
6839.
6840.
6841.
6842.
6843.
6844.
6845.
6846.
6847.
6848.
6849.
6850.
6851.
6852.
6853.
6854.
6855.
6856.
6857.
6858.
6859.
6860.
6861.
6862.
6863.
6864.
6865.
6866.
6867.
6868.
6869.
6870.
6871.
6872.
6873.
6874.
6875.
6876.
6877.
6878.
6879.
6880.
6881.
6882.
6883.
6884.
6885.
6886.
6887.
6888.
6889.
6890.
6891.
6892.
6893.
6894.
6895.
6896.
6897.
6898.
6899.
6900.
6901.
6902.
6903.
6904.
6905.
6906.
6907.
6908.
6909.
6910.
6911.
6912.
6913.
6914.
6915.
6916.
6917.
6918.
6919.
6920.
6921.
6922.
6923.
6924.
6925.
6926.
6927.
6928.
6929.
6930.
6931.
6932.
6933.
6934.
6935.
6936.
6937.
6938.
6939.
6940.
6941.
6942.
6943.
6944.
6945.
6946.
6947.
6948.
6949.
6950.
6951.
6952.
6953.
6954.
6955.
6956.
6957.
6958.
6959.
6960.
6961.
6962.
6963.
6964.
6965.
6966.
6967.
6968.
6969.
6970.
6971.
6972.
6973.
6974.
6975.
6976.
6977.
6978.
6979.
6980.
6981.
6982.
6983.
6984.
6985.
6986.
6987.
6988.
6989.
6990.
6991.
6992.
6993.
6994.
6995.
6996.
6997.
6998.
6999.
7000.
7001.
7002.
7003.
7004.
7005.
7006.
7007.
7008.
7009.
7010.
7011.
7012.
7013.
7014.
7015.
7016.
7017.
7018.
7019.
7020.
7021.
7022.
7023.
7024.
7025.
7026.
7027.
7028.
7029.
7030.
7031.
7032.
7033.
7034.
7035.
7036.
7037.
7038.
7039.
7040.
7041.
7042.
7043.
7044.
7045.
7046.
7047.
7048.
7049.
7050.
7051.
7052.
7053.
7054.
7055.
7056.
7057.
7058.
7059.
7060.
7061.
7062.
7063.
7064.
7065.
7066.
7067.
7068.
7069.
7070.
7071.
7072.
7073.
7074.
7075.
7076.
7077.
7078.
7079.
7080.
7081.
7082.
7083.
7084.
7085.
7086.
7087.
7088.
7089.
7090.
7091.
7092.
7093.
7094.
7095.
7096.
7097.
7098.
7099.
7100.
7101.
7102.
7103.
7104.
7105.
7106.
7107.
7108.
7109.
7110.
7111.
7112.
7113.
7114.
7115.
7116.
7117.
7118.
7119.
7120.
7121.
7122.
7123.
7124.
7125.
7126.
7127.
7128.
7129.
7130.
7131.
7132.
7133.
7134.
7135.
7136.
7137.
7138.
7139.
7140.
7141.
7142.
7143.
7144.
7145.
7146.
7147.
7148.
7149.
7150.
7151.
7152.
7153.
7154.
7155.
7156.
7157.
7158.
7159.
7160.
7161.
7162.
7163.
7164.
7165.
7166.
7167.
7168.
7169.
7170.
7171.
7172.
7173.
7174.
7175.
7176.
7177.
7178.
7179.
7180.
7181.
7182.
7183.
7184.
7185.
7186.
7187.
7188.
7189.
7190.
7191.
7192.
7193.
7194.
7195.
7196.
7197.
7198.
7199.
7200.
7201.
7202.
7203.
7204.
7205.
7206.
7207.
7208.
7209.
7210.
7211.
7212.
7213.
7214.
7215.
7216.
7217.
7218.
7219.
7220.
7221.
7222.
7223.
7224.
7225.
7226.
7227.
7228.
7229.
7230.
7231.
7232.
7233.
7234.
7235.
7236.
7237.
7238.
7239.
7240.
7241.
7242.
7243.
7244.
7245.
7246.
7247.
7248.
7249.
7250.
7251.
7252.
7253.
7254.
7255.
7256.
7257.
7258.
7259.
7260.
7261.
7262.
7263.
7264.
7265.
7266.
7267.
7268.
7269.
7270.
7271.
7272.
7273.
7274.
7275.
7276.
7277.
7278.
7279.
7280.
7281.
7282.
7283.
7284.
7285.
7286.
7287.
7288.
7289.
7290.
7291.
7292.
7293.
7294.
7295.
7296.
7297.
7298.
7299.
7300.
7301.
7302.
7303.
7304.
7305.
7306.
7307.
7308.
7309.
7310.
7311.
7312.
7313.
7314.
7315.
7316.
7317.
7318.
7319.
7320.
7321.
7322.
7323.
7324.
7325.
7326.
7327.
7328.
7329.
7330.
7331.
7332.
7333.
7334.
7335.
7336.
7337.
7338.
7339.
7340.
7341.
7342.
7343.
7344.
7345.
7346.
7347.
7348.
7349.
7350.
7351.
7352.
7353.
7354.
7355.
7356.
7357.
7358.
7359.
7360.
7361.
7362.
7363.
7364.
7365.
7366.
7367.
7368.
7369.
7370.
7371.
7372.
7373.
7374.
7375.
7376.
7377.
7378.
7379.
7380.
7381.
7382.
7383.
7384.
7385.
7386.
7387.
7388.
7389.
7390.
7391.
7392.
7393.
7394.
7395.
7396.
7397.
7398.
7399.
7400.
7401.
7402.
7403.
7404.
7405.
7406.
7407.
7408.
7409.
7410.
7411.
7412.
7413.
7414.
7415.
7416.
7417.
7418.
7419.
7420.
7421.
7422.
7423.
7424.
7425.
7426.
7427.
7428.
7429.
7430.
7431.
7432.
7433.
7434.
7435.
7436.
7437.
7438.
7439.
7440.
7441.
7442.
7443.
7444.
7445.
7446.
7447.
7448.
7449.
7450.
7451.
7452.
7453.
7454.
7455.
7456.
7457.
7458.
7459.
7460.
7461.
7462.
7463.
7464.
7465.
7466.
7467.
7468.
7469.
7470.
7471.
7472.
7473.
7474.
7475.
7476.
7477.
7478.
7479.
7480.
7481.
7482.
7483.
7484.
7485.
7486.
7487.
7488.
7489.
7490.
7491.
7492.
7493.
7494.
7495.
7496.
7497.
7498.
7499.
7500.
7501.
7502.
7503.
7504.
7505.
7506.
7507.
7508.
7509.
7510.
7511.
7512.
7513.
7514.
7515.
7516.
7517.
7518.
7519.
7520.
7521.
7522.
7523.
7524.
7525.
7526.
7527.
7528.
7529.
7530.
7531.
7532.
7533.
7534.
7535.
7536.
7537.
7538.
7539.
7540.
7541.
7542.
7543.
7544.
7545.
7546.
7547.
7548.
7549.
7550.
7551.
7552.
7553.
7554.
7555.
7556.
7557.
7558.
7559.
7560.
7561.
7562.
7563.
7564.
7565.
7566.
7567.
7568.
7569.
7570.
7571.
7572.
7573.
7574.
7575.
7576.
7577.
7578.
7579.
7580.
7581.
7582.
7583.
7584.
7585.
7586.
7587.
7588.
7589.
7590.
7591.
7592.
7593.
7594.
7595.
7596.
7597.
7598.
7599.
7600.
7601.
7602.
7603.
7604.
7605.
7606.
7607.
7608.
7609.
7610.
7611.
7612.
7613.
7614.
7615.
7616.
7617.
7618.
7619.
7620.
7621.
7622.
7623.
7624.
7625.
7626.
7627.
7628.
7629.
7630.
7631.
7632.
7633.
7634.
7635.
7636.
7637.
7638.
7639.
7640.
7641.
7642.
7643.
7644.
7645.
7646.
7647.
7648.
7649.
7650.
7651.
7652.
7653.
7654.
7655.
7656.
7657.
7658.
7659.
7660.
7661.
7662.
7663.
7664.
7665.
7666.
7667.
7668.
7669.
7670.
7671.
7672.
7673.
7674.
7675.
7676.
7677.
7678.
7679.
7680.
7681.
7682.
7683.
7684.
7685.
7686.
7687.
7688.
7689.
7690.
7691.
7692.
7693.
7694.
7695.
7696.
7697.
7698.
7699.
7700.
7701.
7702.
7703.
7704.
7705.
7706.
7707.
7708.
7709.
7710.
7711.
7712.
7713.
7714.
7715.
7716.
7717.
7718.
7719.
7720.
7721.
7722.
7723.
7724.
7725.
7726.
7727.
7728.
7729.
7730.
7731.
7732.
7733.
7734.
7735.
7736.
7737.
7738.
7739.
7740.
7741.
7742.
7743.
7744.
7745.
7746.
7747.
7748.
7749.
7750.
7751.
7752.
7753.
7754.
7755.
7756.
7757.
7758.
7759.
7760.
7761.
7762.
7763.
7764.
7765.
7766.
7767.
7768.
7769.
7770.
7771.
7772.
7773.
7774.
7775.
7776.
7777.
7778.
7779.
7780.
7781.
7782.
7783.
7784.
7785.
7786.
7787.
7788.
7789.
7790.
7791.
7792.
7793.
7794.
7795.
7796.
7797.
7798.
7799.
7800.
7801.
7802.
7803.
7804.
7805.
7806.
7807.
7808.
7809.
7810.
7811.
7812.
7813.
7814.
7815.
7816.
7817.
7818.
7819.
7820.
7821.
7822.
7823.
7824.
7825.
7826.
7827.
7828.
7829.
7830.
7831.
7832.
7833.
7834.
7835.
7836.
7837.
7838.
7839.
7840.
7841.
7842.
7843.
7844.
7845.
7846.
7847.
7848.
7849.
7850.
7851.
7852.
7853.
7854.
7855.
7856.
7857.
7858.
7859.
7860.
7861.
7862.
7863.
7864.
7865.
7866.
7867.
7868.
7869.
7870.
7871.
7872.
7873.
7874.
7875.
7876.
7877.
7878.
7879.
7880.
7881.
7882.
7883.
7884.
7885.
7886.
7887.
7888.
7889.
7890.
7891.
7892.
7893.
7894.
7895.
7896.
7897.
7898.
7899.
7900.
7901.
7902.
7903.
7904.
7905.
7906.
7907.
7908.
7909.
7910.
7911.
7912.
7913.
7914.
7915.
7916.
7917.
7918.
7919.
7920.
7921.
7922.
7923.
7924.
7925.
7926.
7927.
7928.
7929.
7930.
7931.
7932.
7933.
7934.
7935.
7936.
7937.
7938.
7939.
7940.
7941.
7942.
7943.
7944.
7945.
7946.
7947.
7948.
7949.
7950.
7951.
7952.
7953.
7954.
7955.
7956.
7957.
7958.
7959.
7960.
7961.
7962.
7963.
7964.
7965.
7966.
7967.
7968.
7969.
7970.
7971.
7972.
7973.
7974.
7975.
7976.
7977.
7978.
7979.
7980.
7981.
7982.
7983.
7984.
7985.
7986.
7987.
7988.
7989.
7990.
7991.
7992.
7993.
7994.
7995.
7996.
7997.
7998.
7999.
8000.
8001.
8002.
8003.
8004.
8005.
8006.
8007.
8008.
8009.
8010.
8011.
8012.
8013.
8014.
8015.
8016.
8017.
8018.
8019.
8020.
8021.
8022.
8023.
8024.
8025.
8026.
8027.
8028.
8029.
8030.
8031.
8032.
8033.
8034.
8035.
8036.
8037.
8038.
8039.
8040.
8041.
8042.
8043.
8044.
8045.
8046.
8047.
8048.
8049.
8050.
8051.
8052.
8053.
8054.
8055.
8056.
8057.
8058.
8059.
8060.
8061.
8062.
8063.
8064.
8065.
8066.
8067.
8068.
8069.
8070.
8071.
8072.
8073.
8074.
8075.
8076.
8077.
8078.
8079.
8080.
8081.
8082.
8083.
8084.
8085.
8086.
8087.
8088.
8089.
8090.
8091.
8092.
8093.
8094.
8095.
8096.
8097.
8098.
8099.
8100.
8101.
8102.
8103.
8104.
8105.
8106.
8107.
8108.
8109.
8110.
8111.
8112.
8113.
8114.
8115.
8116.
8117.
8118.
8119.
8120.
8121.
8122.
8123.
8124.
8125.
8126.
8127.
8128.
8129.
8130.
8131.
8132.
8133.
8134.
8135.
8136.
8137.
8138.
8139.
8140.
8141.
8142.
8143.
8144.
8145.
8146.
8147.
8148.
8149.
8150.
8151.
8152.
8153.
8154.
8155.
8156.
8157.
8158.
8159.
8160.
8161.
8162.
8163.
8164.
8165.
8166.
8167.
8168.
8169.
8170.
8171.
8172.
8173.
8174.
8175.
8176.
8177.
8178.
8179.
8180.
8181.
8182.
8183.
8184.
8185.
8186.
8187.
8188.
8189.
8190.
8191.
8192.
8193.
8194.
8195.
8196.
8197.
8198.
8199.
8200.
8201.
8202.
8203.
8204.
8205.
8206.
8207.
8208.
8209.
8210.
8211.
8212.
8213.
8214.
8215.
8216.
8217.
8218.
8219.
8220.
8221.
8222.
8223.
8224.
8225.
8226.
8227.
8228.
8229.
8230.
8231.
8232.
8233.
8234.
8235.
8236.
8237.
8238.
8239.
8240.
8241.
8242.
8243.
8244.
8245.
8246.
8247.
8248.
8249.
8250.
8251.
8252.
8253.
8254.
8255.
8256.
8257.
8258.
8259.
8260.
8261.
8262.
8263.
8264.
8265.
8266.
8267.
8268.
8269.
8270.
8271.
8272.
8273.
8274.
8275.
8276.
8277.
8278.
8279.
8280.
8281.
8282.
8283.
8284.
8285.
8286.
8287.
8288.
8289.
8290.
8291.
8292.
8293.
8294.
8295.
8296.
8297.
8298.
8299.
8300.
8301.
8302.
8303.
8304.
8305.
8306.
8307.
8308.
8309.
8310.
8311.
8312.
8313.
8314.
8315.
8316.
8317.
8318.
8319.
8320.
8321.
8322.
8323.
8324.
8325.
8326.
8327.
8328.
8329.
8330.
8331.
8332.
8333.
8334.
8335.
8336.
8337.
8338.
8339.
8340.
8341.
8342.
8343.
8344.
8345.
8346.
8347.
8348.
8349.
8350.
8351.
8352.
8353.
8354.
8355.
8356.
8357.
8358.
8359.
8360.
8361.
8362.
8363.
8364.
8365.
8366.
8367.
8368.
8369.
8370.
8371.
8372.
8373.
8374.
8375.
8376.
8377.
8378.
8379.
8380.
8381.
8382.
8383.
8384.
8385.
8386.
8387.
8388.
8389.
8390.
8391.
8392.
8393.
8394.
8395.
8396.
8397.
8398.
8399.
8400.
8401.
8402.
8403.
8404.
8405.
8406.
8407.
8408.
8409.
8410.
8411.
8412.
8413.
8414.
8415.
8416.
8417.
8418.
8419.
8420.
8421.
8422.
8423.
8424.
8425.
8426.
8427.
8428.
8429.
8430.
8431.
8432.
8433.
8434.
8435.
8436.
8437.
8438.
8439.
8440.
8441.
8442.
8443.
8444.
8445.
8446.
8447.
8448.
8449.
8450.
8451.
8452.
8453.
8454.
8455.
8456.
8457.
8458.
8459.
8460.
8461.
8462.
8463.
8464.
8465.
8466.
8467.
8468.
8469.
8470.
8471.
8472.
8473.
8474.
8475.
8476.
8477.
8478.
8479.
8480.
8481.
8482.
8483.
8484.
8485.
8486.
8487.
8488.
8489.
8490.
8491.
8492.
8493.
8494.
8495.
8496.
8497.
8498.
8499.
8500.
8501.
8502.
8503.
8504.
8505.
8506.
8507.
8508.
8509.
8510.
8511.
8512.
8513.
8514.
8515.
8516.
8517.
8518.
8519.
8520.
8521.
8522.
8523.
8524.
8525.
8526.
8527.
8528.
8529.
8530.
8531.
8532.
8533.
8534.
8535.
8536.
8537.
8538.
8539.
8540.
8541.
8542.
8543.
8544.
8545.
8546.
8547.
8548.
8549.
8550.
8551.
8552.
8553.
8554.
8555.
8556.
8557.
8558.
8559.
8560.
8561.
8562.
8563.
8564.
8565.
8566.
8567.
8568.
8569.
8570.
8571.
8572.
8573.
8574.
8575.
8576.
8577.
8578.
8579.
8580.
8581.
8582.
8583.
8584.
8585.
8586.
8587.
8588.
8589.
8590.
8591.
8592.
8593.
8594.
8595.
8596.
8597.
8598.
8599.
8600.
8601.
8602.
8603.
8604.
8605.
8606.
8607.
8608.
8609.
8610.
8611.
8612.
8613.
8614.
8615.
8616.
8617.
8618.
8619.
8620.
8621.
8622.
8623.
8624.
8625.
8626.
8627.
8628.
8629.
8630.
8631.
8632.
8633.
8634.
8635.
8636.
8637.
8638.
8639.
8640.
8641.
8642.
8643.
8644.
8645.
8646.
8647.
8648.
8649.
8650.
8651.
8652.
8653.
8654.
8655.
8656.
8657.
8658.
8659.
8660.
8661.
8662.
8663.
8664.
8665.
8666.
8667.
8668.
8669.
8670.
8671.
8672.
8673.
8674.
8675.
8676.
8677.
8678.
8679.
8680.
8681.
8682.
8683.
8684.
8685.
8686.
8687.
8688.
8689.
8690.
8691.
8692.
8693.
8694.
8695.
8696.
8697.
8698.
8699.
8700.
8701.
8702.
8703.
8704.
8705.
8706.
8707.
8708.
8709.
8710.
8711.
8712.
8713.
8714.
8715.
8716.
8717.
8718.
8719.
8720.
8721.
8722.
8723.
8724.
8725.
8726.
8727.
8728.
8729.
8730.
8731.
8732.
8733.
8734.
8735.
8736.
8737.
8738.
8739.
8740.
8741.
8742.
8743.
8744.
8745.
8746.
8747.
8748.
8749.
8750.
8751.
8752.
8753.
8754.
8755.
8756.
8757.
8758.
8759.
8760.
8761.
8762.
8763.
8764.
8765.
8766.
8767.
8768.
8769.
8770.
8771.
8772.
8773.
8774.
8775.
8776.
8777.
8778.
8779.
8780.
8781.
8782.
8783.
8784.
8785.
8786.
8787.
8788.
8789.
8790.
8791.
8792.
8793.
8794.
8795.
8796.
8797.
8798.
8799.
8800.
8801.
8802.
8803.
8804.
8805.
8806.
8807.
8808.
8809.
8810.
8811.
8812.
8813.
8814.
8815.
8816.
8817.
8818.
8819.
8820.
8821.
8822.
8823.
8824.
8825.
8826.
8827.
8828.
8829.
8830.
8831.
8832.
8833.
8834.
8835.
8836.
8837.
8838.
8839.
8840.
8841.
8842.
8843.
8844.
8845.
8846.
8847.
8848.
8849.
8850.
8851.
8852.
8853.
8854.
8855.
8856.
8857.
8858.
8859.
8860.
8861.
8862.
8863.
8864.
8865.
8866.
8867.
8868.
8869.
8870.
8871.
8872.
8873.
8874.
8875.
8876.
8877.
8878.
8879.
8880.
8881.
8882.
8883.
8884.
8885.
8886.
8887.
8888.
8889.
8890.
8891.
8892.
8893.
8894.
8895.
8896.
8897.
8898.
8899.
8900.
8901.
8902.
8903.
8904.
8905.
8906.
8907.
8908.
8909.
8910.
8911.
8912.
8913.
8914.
8915.
8916.
8917.
8918.
8919.
8920.
8921.
8922.
8923.
8924.
8925.
8926.
8927.
8928.
8929.
8930.
8931.
8932.
8933.
8934.
8935.
8936.
8937.
8938.
8939.
8940.
8941.
8942.
8943.
8944.
8945.
8946.
8947.
8948.
8949.
8950.
8951.
8952.
8953.
8954.
8955.
8956.
8957.
8958.
8959.
8960.
8961.
8962.
8963.
8964.
8965.
8966.
8967.
8968.
8969.
8970.
8971.
8972.
8973.
8974.
8975.
8976.
8977.
8978.
8979.
8980.
8981.
8982.
8983.
8984.
8985.
8986.
8987.
8988.
8989.
8990.
8991.
8992.
8993.
8994.
8995.
8996.
8997.
8998.
8999.
9000.
9001.
9002.
9003.
9004.
9005.
9006.
9007.
9008.
9009.
9010.
9011.
9012.
9013.
9014.
9015.
9016.
9017.
9018.
9019.
9020.
9021.
9022.
9023.
9024.
9025.
9026.
9027.
9028.
9029.
9030.
9031.
9032.
9033.
9034.
9035.
9036.
9037.
9038.
9039.
9040.
9041.
9042.
9043.
9044.
9045.
9046.
9047.
9048.
9049.
9050.
9051.
9052.
9053.
9054.
9055.
9056.
9057.
9058.
9059.
9060.
9061.
9062.
9063.
9064.
9065.
9066.
9067.
9068.
9069.
9070.
9071.
9072.
9073.
9074.
9075.
9076.
9077.
9078.
9079.
9080.
9081.
9082.
9083.
9084.
9085.
9086.
9087.
9088.
9089.
9090.
9091.
9092.
9093.
9094.
9095.
9096.
9097.
9098.
9099.
9100.
9101.
9102.
9103.
9104.
9105.
9106.
9107.
9108.
9109.
9110.
9111.
9112.
9113.
9114.
9115.
9116.
9117.
9118.
9119.
9120.
9121.
9122.
9123.
9124.
9125.
9126.
9127.
9128.
9129.
9130.
9131.
9132.
9133.
9134.
9135.
9136.
9137.
9138.
9139.
9140.
9141.
9142.
9143.
9144.
9145.
9146.
9147.
9148.
9149.
9150.
9151.
9152.
9153.
9154.
9155.
9156.
9157.
9158.
9159.
9160.
9161.
9162.
9163.
9164.
9165.
9166.
9167.
9168.
9169.
9170.
9171.
9172.
9173.
9174.
9175.
9176.
9177.
9178.
9179.
9180.
9181.
9182.
9183.
9184.
9185.
9186.
9187.
9188.
9189.
9190.
9191.
9192.
9193.
9194.
9195.
9196.
9197.
9198.
9199.
9200.
9201.
9202.
9203.
9204.
9205.
9206.
9207.
9208.
9209.
9210.
9211.
9212.
9213.
9214.
9215.
9216.
9217.
9218.
9219.
9220.
9221.
9222.
9223.
9224.
9225.
9226.
9227.
9228.
9229.
9230.
9231.
9232.
9233.
9234.
9235.
9236.
9237.
9238.
9239.
9240.
9241.
9242.
9243.
9244.
9245.
9246.
9247.
9248.
9249.
9250.
9251.
9252.
9253.
9254.
9255.
9256.
9257.
9258.
9259.
9260.
9261.
9262.
9263.
9264.
9265.
9266.
9267.
9268.
9269.
9270.
9271.
9272.
9273.
9274.
9275.
9276.
9277.
9278.
9279.
9280.
9281.
9282.
9283.
9284.
9285.
9286.
9287.
9288.
9289.
9290.
9291.
9292.
9293.
9294.
9295.
9296.
9297.
9298.
9299.
9300.
9301.
9302.
9303.
9304.
9305.
9306.
9307.
9308.
9309.
9310.
9311.
9312.
9313.
9314.
9315.
9316.
9317.
9318.
9319.
9320.
9321.
9322.
9323.
9324.
9325.
9326.
9327.
9328.
9329.
9330.
9331.
9332.
9333.
9334.
9335.
9336.
9337.
9338.
9339.
9340.
9341.
9342.
9343.
9344.
9345.
9346.
9347.
9348.
9349.
9350.
9351.
9352.
9353.
9354.
9355.
9356.
9357.
9358.
9359.
9360.
9361.
9362.
9363.
9364.
9365.
9366.
9367.
9368.
9369.
9370.
9371.
9372.
9373.
9374.
9375.
9376.
9377.
9378.
9379.
9380.
9381.
9382.
9383.
9384.
9385.
9386.
9387.
9388.
9389.
9390.
9391.
9392.
9393.
9394.
9395.
9396.
9397.
9398.
9399.
9400.
9401.
9402.
9403.
9404.
9405.
9406.
9407.
9408.
9409.
9410.
9411.
9412.
9413.
9414.
9415.
9416.
9417.
9418.
9419.
9420.
9421.
9422.
9423.
9424.
9425.
9426.
9427.
9428.
9429.
9430.
9431.
9432.
9433.
9434.
9435.
9436.
9437.
9438.
9439.
9440.
9441.
9442.
9443.
9444.
9445.
9446.
9447.
9448.
9449.
9450.
9451.
9452.
9453.
9454.
9455.
9456.
9457.
9458.
9459.
9460.
9461.
9462.
9463.
9464.
9465.
9466.
9467.
9468.
9469.
9470.
9471.
9472.
9473.
9474.
9475.
9476.
9477.
9478.
9479.
9480.
9481.
9482.
9483.
9484.
9485.
9486.
9487.
9488.
9489.
9490.
9491.
9492.
9493.
9494.
9495.
9496.
9497.
9498.
9499.
9500.
9501.
9502.
9503.
9504.
9505.
9506.
9507.
9508.
9509.
9510.
9511.
9512.
9513.
9514.
9515.
9516.
9517.
9518.
9519.
9520.
9521.
9522.
9523.
9524.
9525.
9526.
9527.
9528.
9529.
9530.
9531.
9532.
9533.
9534.
9535.
9536.
9537.
9538.
9539.
9540.
9541.
9542.
9543.
9544.
9545.
9546.
9547.
9548.
9549.
9550.
9551.
9552.
9553.
9554.
9555.
9556.
9557.
9558.
9559.
9560.
9561.
9562.
9563.
9564.
9565.
9566.
9567.
9568.
9569.
9570.
9571.
9572.
9573.
9574.
9575.
9576.
9577.
9578.
9579.
9580.
9581.
9582.
9583.
9584.
9585.
9586.
9587.
9588.
9589.
9590.
9591.
9592.
9593.
9594.
9595.
9596.
9597.
9598.
9599.
9600.
9601.
9602.
9603.
9604.
9605.
9606.
9607.
9608.
9609.
9610.
9611.
9612.
9613.
9614.
9615.
9616.
9617.
9618.
9619.
9620.
9621.
9622.
9623.
9624.
9625.
9626.
9627.
9628.
9629.
9630.
9631.
9632.
9633.
9634.
9635.
9636.
9637.
9638.
9639.
9640.
9641.
9642.
9643.
9644.
9645.
9646.
9647.
9648.
9649.
9650.
9651.
9652.
9653.
9654.
9655.
9656.
9657.
9658.
9659.
9660.
9661.
9662.
9663.
9664.
9665.
9666.
9667.
9668.
9669.
9670.
9671.
9672.
9673.
9674.
9675.
9676.
9677.
9678.
9679.
9680.
9681.
9682.
9683.
9684.
9685.
9686.
9687.
9688.
9689.
9690.
9691.
9692.
9693.
9694.
9695.
9696.
9697.
9698.
9699.
9700.
9701.
9702.
9703.
9704.
9705.
9706.
9707.
9708.
9709.
9710.
9711.
9712.
9713.
9714.
9715.
9716.
9717.
9718.
9719.
9720.
9721.
9722.
9723.
9724.
9725.
9726.
9727.
9728.
9729.
9730.
9731.
9732.
9733.
9734.
9735.
9736.
9737.
9738.
9739.
9740.
9741.
9742.
9743.
9744.
9745.
9746.
9747.
9748.
9749.
9750.
9751.
9752.
9753.
9754.
9755.
9756.
9757.
9758.
9759.
9760.
9761.
9762.
9763.
9764.
9765.
9766.
9767.
9768.
9769.
9770.
9771.
9772.
9773.
9774.
9775.
9776.
9777.
9778.
9779.
9780.
9781.
9782.
9783.
9784.
9785.
9786.
9787.
9788.
9789.
9790.
9791.
9792.
9793.
9794.
9795.
9796.
9797.
9798.
9799.
9800.
9801.
9802.
9803.
9804.
9805.
9806.
9807.
9808.
9809.
9810.
9811.
9812.
9813.
9814.
9815.
9816.
9817.
9818.
9819.
9820.
9821.
9822.
9823.
9824.
9825.
9826.
9827.
9828.
9829.
9830.
9831.
9832.
9833.
9834.
9835.
9836.
9837.
9838.
9839.
9840.
9841.
9842.
9843.
9844.
9845.
9846.
9847.
9848.
9849.
9850.
9851.
9852.
9853.
9854.
9855.
9856.
9857.
9858.
9859.
9860.
9861.
9862.
9863.
9864.
9865.
9866.
9867.
9868.
9869.
9870.
9871.
9872.
9873.
9874.
9875.
9876.
9877.
9878.
9879.
9880.
9881.
9882.
9883.
9884.
9885.
9886.
9887.
9888.
9889.
9890.
9891.
9892.
9893.
9894.
9895.
9896.
9897.
9898.
9899.
9900.
9901.
9902.
9903.
9904.
9905.
9906.
9907.
9908.
9909.
9910.
9911.
9912.
9913.
9914.
9915.
9916.
9917.
9918.
9919.
9920.
9921.
9922.
9923.
9924.
9925.
9926.
9927.
9928.
9929.
9930.
9931.
9932.
9933.
9934.
9935.
9936.
9937.
9938.
9939.
9940.
9941.
9942.
9943.
9944.
9945.
9946.
9947.
9948.
9949.
9950.
9951.
9952.
9953.
9954.
9955.
9956.
9957.
9958.
9959.
9960.
9961.
9962.
9963.
9964.
9965.
9966.
9967.
9968.
9969.
9970.
9971.
9972.
9973.
9974.
9975.
9976.
9977.
9978.
9979.
9980.
9981.
9982.
9983.
9984.
9985.
9986.
9987.
9988.
9989.
9990.
9991.
9992.
9993.
9994.
9995.
9996.
9997.
9998.
9999.
10000.
10001.
10002.
10003.
10004.
10005.
10006.
10007.
10008.
10009.
10010.
10011.
10012.
10013.
10014.
10015.
10016.
10017.
10018.
10019.
10020.
10021.
10022.
10023.
10024.
10025.
10026.
10027.
10028.
10029.
10030.
10031.
10032.
10033.
10034.
10035.
10036.
10037.
10038.
10039.
10040.
10041.
10042.
10043.
10044.
10045.
10046.
10047.
10048.
10049.
10050.
10051.
10052.
10053.
10054.
10055.
10056.
10057.
10058.
10059.
10060.
10061.
10062.
10063.
10064.
10065.
10066.
10067.
10068.
10069.
10070.
10071.
10072.
10073.
10074.
10075.
10076.
10077.
10078.
10079.
10080.
10081.
10082.
10083.
10084.
10085.
10086.
10087.
10088.
10089.
10090.
10091.
10092.
10093.
10094.
10095.
10096.
10097.
10098.
10099.
10100.
10101.
10102.
10103.
10104.
10105.
10106.
10107.
10108.
10109.
10110.
10111.
10112.
10113.
10114.
10115.
10116.
10117.
10118.
10119.
10120.
10121.
10122.
10123.
10124.
10125.
10126.
10127.
10128.
10129.
10130.
10131.
10132.
10133.
10134.
10135.
10136.
10137.
10138.
10139.
10140.
10141.
10142.
10143.
10144.
10145.
10146.
10147.
10148.
10149.
10150.
10151.
10152.
10153.
10154.
10155.
10156.
10157.
10158.
10159.
10160.
10161.
10162.
10163.
10164.
10165.
10166.
10167.
10168.
10169.
10170.
10171.
10172.
10173.
10174.
10175.
10176.
10177.
10178.
10179.
10180.
10181.
10182.
10183.
10184.
10185.
10186.
10187.
10188.
10189.
10190.
10191.
10192.
10193.
10194.
10195.
10196.
10197.
10198.
10199.
10200.
10201.
10202.
10203.
10204.
10205.
10206.
10207.
10208.
10209.
10210.
10211.
10212.
10213.
10214.
10215.
10216.
10217.
10218.
10219.
10220.
10221.
10222.
10223.
10224.
10225.
10226.
10227.
10228.
10229.
10230.
10231.
10232.
10233.
10234.
10235.
10236.
10237.
10238.
10239.
10240.
10241.
10242.
10243.
10244.
10245.
10246.
10247.
10248.
10249.
10250.
10251.
10252.
10253.
10254.
10255.
10256.
10257.
10258.
10259.
10260.
10261.
10262.
10263.
10264.
10265.
10266.
10267.
10268.
10269.
10270.
10271.
10272.
10273.
10274.
10275.
10276.
10277.
10278.
10279.
10280.
10281.
10282.
10283.
10284.
10285.
10286.
10287.
10288.
10289.
10290.
10291.
10292.
10293.
10294.
10295.
10296.
10297.
10298.
10299.
10300.
10301.
10302.
10303.
10304.
10305.
10306.
10307.
10308.
10309.
10310.
10311.
10312.
10313.
10314.
10315.
10316.
10317.
10318.
10319.
10320.
10321.
10322.
10323.
10324.
10325.
10326.
10327.
10328.
10329.
10330.
10331.
10332.
10333.
10334.
10335.
10336.
10337.
10338.
10339.
10340.
10341.
10342.
10343.
10344.
10345.
10346.
10347.
10348.
10349.
10350.
10351.
10352.
10353.
10354.
10355.
10356.
10357.
10358.
10359.
10360.
10361.
10362.
10363.
10364.
10365.
10366.
10367.
10368.
10369.
10370.
10371.
10372.
10373.
10374.
10375.
10376.
10377.
10378.
10379.
10380.
10381.
10382.
10383.
10384.
10385.
10386.
10387.
10388.
10389.
10390.
10391.
10392.
10393.
10394.
10395.
10396.
10397.
10398.
10399.
10400.
10401.
10402.
10403.
10404.
10405.
10406.
10407.
10408.
10409.
10410.
10411.
10412.
10413.
10414.
10415.
10416.
10417.
10418.
10419.
10420.
10421.
10422.
10423.
10424.
10425.
10426.
10427.
10428.
10429.
10430.
10431.
10432.
10433.
10434.
10435.
10436.
10437.
10438.
10439.
10440.
10441.
10442.
10443.
10444.
10445.
10446.
10447.
10448.
10449.
10450.
10451.
10452.
10453.
10454.
10455.
10456.
10457.
10458.
10459.
10460.
10461.
10462.
10463.
10464.
10465.
10466.
10467.
10468.
10469.
10470.
10471.
10472.
10473.
10474.
10475.
10476.
10477.
10478.
10479.
10480.
10481.
10482.
10483.
10484.
10485.
10486.
10487.
10488.
10489.
10490.
10491.
10492.
10493.
10494.
10495.
10496.
10497.
10498.
10499.
10500.
10501.
10502.
10503.
10504.
10505.
10506.
10507.
10508.
10509.
10510.
10511.
10512.
10513.
10514.
10515.
10516.
10517.
10518.
10519.
10520.
10521.
10522.
10523.
10524.
10525.
10526.
10527.
10528.
10529.
10530.
10531.
10532.
10533.
10534.
10535.
10536.
10537.
10538.
10539.
10540.
10541.
10542.
10543.
10544.
10545.
10546.
10547.
10548.
10549.
10550.
10551.
10552.
10553.
10554.
10555.
10556.
10557.
10558.
10559.
10560.
10561.
10562.
10563.
10564.
10565.
10566.
10567.
10568.
10569.
10570.
10571.
10572.
10573.
10574.
10575.
10576.
10577.
10578.
10579.
10580.
10581.
10582.
10583.
10584.
10585.
10586.
10587.
10588.
10589.
10590.
10591.
10592.
10593.
10594.
10595.
10596.
10597.
10598.
10599.
10600.
10601.
10602.
10603.
10604.
10605.
10606.
10607.
10608.
10609.
10610.
10611.
10612.
10613.
10614.
10615.
10616.
10617.
10618.
10619.
10620.
10621.
10622.
10623.
10624.
10625.
10626.
10627.
10628.
10629.
10630.
10631.
10632.
10633.
10634.
10635.
10636.
10637.
10638.
10639.
10640.
10641.
10642.
10643.
10644.
10645.
10646.
10647.
10648.
10649.
10650.
10651.
10652.
10653.
10654.
10655.
10656.
10657.
10658.
10659.
10660.
10661.
10662.
10663.
10664.
10665.
10666.
10667.
10668.
10669.
10670.
10671.
10672.
10673.
10674.
10675.
10676.
10677.
10678.
10679.
10680.
10681.
10682.
10683.
10684.
10685.
10686.
10687.
10688.
10689.
10690.
10691.
10692.
10693.
10694.
10695.
10696.
10697.
10698.
10699.
10700.
10701.
10702.
10703.
10704.
10705.
10706.
10707.
10708.
10709.
10710.
10711.
10712.
10713.
10714.
10715.
10716.
10717.
10718.
10719.
10720.
10721.
10722.
10723.
10724.
10725.
10726.
10727.
10728.
10729.
10730.
10731.
10732.
10733.
10734.
10735.
10736.
10737.
10738.
10739.
10740.
10741.
10742.
10743.
10744.
10745.
10746.
10747.
10748.
10749.
10750.
10751.
10752.
10753.
10754.
10755.
10756.
10757.
10758.
10759.
10760.
10761.
10762.
10763.
10764.
10765.
10766.
10767.
10768.
10769.
10770.
10771.
10772.
10773.
10774.
10775.
10776.
10777.
10778.
10779.
10780.
10781.
10782.
10783.
10784.
10785.
10786.
10787.
10788.
10789.
10790.
10791.
10792.
10793.
10794.
10795.
10796.
10797.
10798.
10799.
10800.
10801.
10802.
10803.
10804.
10805.
10806.
10807.
10808.
10809.
10810.
10811.
10812.
10813.
10814.
10815.
10816.
10817.
10818.
10819.
10820.
10821.
10822.
10823.
10824.
10825.
10826.
10827.
10828.
10829.
10830.
10831.
10832.
10833.
10834.
10835.
10836.
10837.
10838.
10839.
10840.
10841.
10842.
10843.
10844.
10845.
10846.
10847.
10848.
10849.
10850.
10851.
10852.
10853.
10854.
10855.
10856.
10857.
10858.
10859.
10860.
10861.
10862.
10863.
10864.
10865.
10866.
10867.
10868.
10869.
10870.
10871.
10872.
10873.
10874.
10875.
10876.
10877.
10878.
10879.
10880.
10881.
10882.
10883.
10884.
10885.
10886.
10887.
10888.
10889.
10890.
10891.
10892.
10893.
10894.
10895.
10896.
10897.
10898.
10899.
10900.
10901.
10902.
10903.
10904.
10905.
10906.
10907.
10908.
10909.
10910.
10911.
10912.
10913.
10914.
10915.
10916.
10917.
10918.
10919.
10920.
10921.
10922.
10923.
10924.
10925.
10926.
10927.
10928.
10929.
10930.
10931.
10932.
10933.
10934.
10935.
10936.
10937.
10938.
10939.
10940.
10941.
10942.
10943.
10944.
10945.
10946.
10947.
10948.
10949.
10950.
10951.
10952.
10953.
10954.
10955.
10956.
10957.
10958.
10959.
10960.
10961.
10962.
10963.
10964.
10965.
10966.
10967.
10968.
10969.
10970.
10971.
10972.
10973.
10974.
10975.
10976.
10977.
10978.
10979.
10980.
10981.
10982.
10983.
10984.
10985.
10986.
10987.
10988.
10989.
10990.
10991.
10992.
10993.
10994.
10995.
10996.
10997.
10998.
10999.
11000.
11001.
11002.
11003.
11004.
11005.
11006.
11007.
11008.
11009.
11010.
11011.
11012.
11013.
11014.
11015.
11016.
11017.
11018.
11019.
11020.
11021.
11022.
11023.
11024.
11025.
11026.
11027.
11028.
11029.
11030.
11031.
11032.
11033.
11034.
11035.
11036.
11037.
11038.
11039.
11040.
11041.
11042.
11043.
11044.
11045.
11046.
11047.
11048.
11049.
11050.
11051.
11052.
11053.
11054.
11055.
11056.
11057.
11058.
11059.
11060.
11061.
11062.
11063.
11064.
11065.
11066.
11067.
11068.
11069.
11070.
11071.
11072.
11073.
11074.
11075.
11076.
11077.
11078.
11079.
11080.
11081.
11082.
11083.
11084.
11085.
11086.
11087.
11088.
11089.
11090.
11091.
11092.
11093.
11094.
11095.
11096.
11097.
11098.
11099.
11100.
11101.
11102.
11103.
11104.
11105.
11106.
11107.
11108.
11109.
11110.
11111.
11112.
11113.
11114.
11115.
11116.
11117.
11118.
11119.
11120.
11121.
11122.
11123.
11124.
11125.
11126.
11127.
11128.
11129.
11130.
11131.
11132.
11133.
11134.
11135.
11136.
11137.
11138.
11139.
11140.
11141.
11142.
11143.
11144.
11145.
11146.
11147.
11148.
11149.
11150.
11151.
11152.
11153.
11154.
11155.
11156.
11157.
11158.
11159.
11160.
11161.
11162.
11163.
11164.
11165.
11166.
11167.
11168.
11169.
11170.
11171.
11172.
11173.
11174.
11175.
11176.
11177.
11178.
11179.
11180.
11181.
11182.
11183.
11184.
11185.
11186.
11187.
11188.
11189.
11190.
11191.
11192.
11193.
11194.
11195.
11196.
11197.
11198.
11199.
11200.
11201.
11202.
11203.
11204.
11205.
11206.
11207.
11208.
11209.
11210.
11211.
11212.
11213.
11214.
11215.
11216.
11217.
11218.
11219.
11220.
11221.
11222.
11223.
11224.
11225.
11226.
11227.
11228.
11229.
11230.
11231.
11232.
11233.
11234.
11235.
11236.
11237.
11238.
11239.
11240.
11241.
11242.
11243.
11244.
11245.
11246.
11247.
11248.
11249.
11250.
11251.
11252.
11253.
11254.
11255.
11256.
11257.
11258.
11259.
11260.
11261.
11262.
11263.
11264.
11265.
11266.
11267.
11268.
11269.
11270.
11271.
11272.
11273.
11274.
11275.
11276.
11277.
11278.
11279.
11280.
11281.
11282.
11283.
11284.
11285.
11286.
11287.
11288.
11289.
11290.
11291.
11292.
11293.
11294.
11295.
11296.
11297.
11298.
11299.
11300.
11301.
11302.
11303.
11304.
11305.
11306.
11307.
11308.
11309.
11310.
11311.
11312.
11313.
11314.
11315.
11316.
11317.
11318.
11319.
11320.
11321.
11322.
11323.
11324.
11325.
11326.
11327.
11328.
11329.
11330.
11331.
11332.
11333.
11334.
11335.
11336.
11337.
11338.
11339.
11340.
11341.
11342.
11343.
11344.
11345.
11346.
11347.
11348.
11349.
11350.
11351.
11352.
11353.
11354.
11355.
11356.
11357.
11358.
11359.
11360.
11361.
11362.
11363.
11364.
11365.
11366.
11367.
11368.
11369.
11370.
11371.
11372.
11373.
11374.
11375.
11376.
11377.
11378.
11379.
11380.
11381.
11382.
11383.
11384.
11385.
11386.
11387.
11388.
11389.
11390.
11391.
11392.
11393.
11394.
11395.
11396.
11397.
11398.
11399.
11400.
11401.
11402.
11403.
11404.
11405.
11406.
11407.
11408.
11409.
11410.
11411.
11412.
11413.
11414.
11415.
11416.
11417.
11418.
11419.
11420.
11421.
11422.
11423.
11424.
11425.
11426.
11427.
11428.
11429.
11430.
11431.
11432.
11433.
11434.
11435.
11436.
11437.
11438.
11439.
11440.
11441.
11442.
11443.
11444.
11445.
11446.
11447.
11448.
11449.
11450.
11451.
11452.
11453.
11454.
11455.
11456.
11457.
11458.
11459.
11460.
11461.
11462.
11463.
11464.
11465.
11466.
11467.
11468.
11469.
11470.
11471.
11472.
11473.
11474.
11475.
11476.
11477.
11478.
11479.
11480.
11481.
11482.
11483.
11484.
11485.
11486.
11487.
11488.
11489.
11490.
11491.
11492.
11493.
11494.
11495.
11496.
11497.
11498.
11499.
11500.
11501.
11502.
11503.
11504.
11505.
11506.
11507.
11508.
11509.
11510.
11511.
11512.
11513.
11514.
11515.
11516.
11517.
11518.
11519.
11520.
11521.
11522.
11523.
11524.
11525.
11526.
11527.
11528.
11529.
11530.
11531.
11532.
11533.
11534.
11535.
11536.
11537.
11538.
11539.
11540.
11541.
11542.
11543.
11544.
11545.
11546.
11547.
11548.
11549.
11550.
11551.
11552.
11553.
11554.
11555.
11556.
11557.
11558.
11559.
11560.
11561.
11562.
11563.
11564.
11565.
11566.
11567.
11568.
11569.
11570.
11571.
11572.
11573.
11574.
11575.
11576.
11577.
11578.
11579.
11580.
11581.
11582.
11583.
11584.
11585.
11586.
11587.
11588.
11589.
11590.
11591.
11592.
11593.
11594.
11595.
11596.
11597.
11598.
11599.
11600.
11601.
11602.
11603.
11604.
11605.
11606.
11607.
11608.
11609.
11610.
11611.
11612.
11613.
11614.
11615.
11616.
11617.
11618.
11619.
11620.
11621.
11622.
11623.
11624.
11625.
11626.
11627.
11628.
11629.
11630.
11631.
11632.
11633.
11634.
11635.
11636.
11637.
11638.
11639.
11640.
11641.
11642.
11643.
11644.
11645.
11646.
11647.
11648.
11649.
11650.
11651.
11652.
11653.
11654.
11655.
11656.
11657.
11658.
11659.
11660.
11661.
11662.
11663.
11664.
11665.
11666.
11667.
11668.
11669.
11670.
11671.
11672.
11673.
11674.
11675.
11676.
11677.
11678.
11679.
11680.
11681.
11682.
11683.
11684.
11685.
11686.
11687.
11688.
11689.
11690.
11691.
11692.
11693.
11694.
11695.
11696.
11697.
11698.
11699.
11700.
11701.
11702.
11703.
11704.
11705.
11706.
11707.
11708.
11709.
11710.
11711.
11712.
11713.
11714.
11715.
11716.
11717.
11718.
11719.
11720.
11721.
11722.
11723.
11724.
11725.
11726.
11727.
11728.
11729.
11730.
11731.
11732.
11733.
11734.
11735.
11736.
11737.
11738.
11739.
11740.
11741.
11742.
11743.
11744.
11745.
11746.
11747.
11748.
11749.
11750.
11751.
11752.
11753.
11754.
11755.
11756.
11757.
11758.
11759.
11760.
11761.
11762.
11763.
11764.
11765.
11766.
11767.
11768.
11769.
11770.
11771.
11772.
11773.
11774.
11775.
11776.
11777.
11778.
11779.
11780.
11781.
11782.
11783.
11784.
11785.
11786.
11787.
11788.
11789.
11790.
11791.
11792.
11793.
11794.
11795.
11796.
11797.
11798.
11799.
11800.
11801.
11802.
11803.
11804.
11805.
11806.
11807.
11808.
11809.
11810.
11811.
11812.
11813.
11814.
11815.
11816.
11817.
11818.
11819.
11820.
11821.
11822.
11823.
11824.
11825.
11826.
11827.
11828.
11829.
11830.
11831.
11832.
11833.
11834.
11835.
11836.
11837.
11838.
11839.
11840.
11841.
11842.
11843.
11844.
11845.
11846.
11847.
11848.
11849.
11850.
11851.
11852.
11853.
11854.
11855.
11856.
11857.
11858.
11859.
11860.
11861.
11862.
11863.
11864.
11865.
11866.
11867.
11868.
11869.
11870.
11871.
11872.
11873.
11874.
11875.
11876.
11877.
11878.
11879.
11880.
11881.
11882.
11883.
11884.
11885.
11886.
11887.
11888.
11889.
11890.
11891.
11892.
11893.
11894.
11895.
11896.
11897.
11898.
11899.
11900.
11901.
11902.
11903.
11904.
11905.
11906.
11907.
11908.
11909.
11910.
11911.
11912.
11913.
11914.
11915.
11916.
11917.
11918.
11919.
11920.
11921.
11922.
11923.
11924.
11925.
11926.
11927.
11928.
11929.
11930.
11931.
11932.
11933.
11934.
11935.
11936.
11937.
11938.
11939.
11940.
11941.
11942.
11943.
11944.
11945.
11946.
11947.
11948.
11949.
11950.
11951.
11952.
11953.
11954.
11955.
11956.
11957.
11958.
11959.
11960.
11961.
11962.
11963.
11964.
11965.
11966.
11967.
11968.
11969.
11970.
11971.
11972.
11973.
11974.
11975.
11976.
11977.
11978.
11979.
11980.
11981.
11982.
11983.
11984.
11985.
11986.
11987.
11988.
11989.
11990.
11991.
11992.
11993.
11994.
11995.
11996.
11997.
11998.
11999.
12000.
12001.
12002.
12003.
12004.
12005.
12006.
12007.
12008.
12009.
12010.
12011.
12012.
12013.
12014.
12015.
12016.
12017.
12018.
12019.
12020.
12021.
12022.
12023.
12024.
12025.
12026.
12027.
12028.
12029.
12030.
12031.
12032.
12033.
12034.
12035.
12036.
12037.
12038.
12039.
12040.
12041.
12042.
12043.
12044.
12045.
12046.
12047.
12048.
12049.
12050.
12051.
12052.
12053.
12054.
12055.
12056.
12057.
12058.
12059.
12060.
12061.
12062.
12063.
12064.
12065.
12066.
12067.
12068.
12069.
12070.
12071.
12072.
12073.
12074.
12075.
12076.
12077.
12078.
12079.
12080.
12081.
12082.
12083.
12084.
12085.
12086.
12087.
12088.
12089.
12090.
12091.
12092.
12093.
12094.
12095.
12096.
12097.
12098.
12099.
12100.
12101.
12102.
12103.
12104.
12105.
12106.
12107.
12108.
12109.
12110.
12111.
12112.
12113.
12114.
12115.
12116.
12117.
12118.
12119.
12120.
12121.
12122.
12123.
12124.
12125.
12126.
12127.
12128.
12129.
12130.
12131.
12132.
12133.
12134.
12135.
12136.
12137.
12138.
12139.
12140.
12141.
12142.
12143.
12144.
12145.
12146.
12147.
12148.
12149.
12150.
12151.
12152.
12153.
12154.
12155.
12156.
12157.
12158.
12159.
12160.
12161.
12162.
12163.
12164.
12165.
12166.
12167.
12168.
12169.
12170.
12171.
12172.
12173.
12174.
12175.
12176.
12177.
12178.
12179.
12180.
12181.
12182.
12183.
12184.
12185.
12186.
12187.
12188.
12189.
12190.
12191.
12192.
12193.
12194.
12195.
12196.
12197.
12198.
12199.
12200.
12201.
12202.
12203.
12204.
12205.
12206.
12207.
12208.
12209.
12210.
12211.
12212.
12213.
12214.
12215.
12216.
12217.
12218.
12219.
12220.
12221.
12222.
12223.
12224.
12225.
12226.
12227.
12228.
12229.
12230.
12231.
12232.
12233.
12234.
12235.
12236.
12237.
12238.
12239.
12240.
12241.
12242.
12243.
12244.
12245.
12246.
12247.
12248.
12249.
12250.
12251.
12252.
12253.
12254.
12255.
12256.
12257.
12258.
12259.
12260.
12261.
12262.
12263.
12264.
12265.
12266.
12267.
12268.
12269.
12270.
12271.
12272.
12273.
12274.
12275.
12276.
12277.
12278.
12279.
12280.
12281.
12282.
12283.
12284.
12285.
12286.
12287.
12288.
12289.
12290.
12291.
12292.
12293.
12294.
12295.
12296.
12297.
12298.
12299.
12300.
12301.
12302.
12303.
12304.
12305.
12306.
12307.
12308.
12309.
12310.
12311.
12312.
12313.
12314.
12315.
12316.
12317.
12318.
12319.
12320.
12321.
12322.
12323.
12324.
12325.
12326.
12327.
12328.
12329.
12330.
12331.
12332.
12333.
12334.
12335.
12336.
12337.
12338.
12339.
12340.
12341.
12342.
12343.
12344.
12345.
12346.
12347.
12348.
12349.
12350.
12351.
12352.
12353.
12354.
12355.
12356.
12357.
12358.
12359.
12360.
12361.
12362.
12363.
12364.
12365.
12366.
12367.
12368.
12369.
12370.
12371.
12372.
12373.
12374.
12375.
12376.
12377.
12378.
12379.
12380.
12381.
12382.
12383.
12384.
12385.
12386.
12387.
12388.
12389.
12390.
12391.
12392.
12393.
12394.
12395.
12396.
12397.
12398.
12399.
12400.
12401.
12402.
12403.
12404.
12405.
12406.
12407.
12408.
12409.
12410.
12411.
12412.
12413.
12414.
12415.
12416.
12417.
12418.
12419.
12420.
12421.
12422.
12423.
12424.
12425.
12426.
12427.
12428.
12429.
12430.
12431.
12432.
12433.
12434.
12435.
12436.
12437.
12438.
12439.
12440.
12441.
12442.
12443.
12444.
12445.
12446.
12447.
12448.
12449.
12450.
12451.
12452.
12453.
12454.
12455.
12456.
12457.
12458.
12459.
12460.
12461.
12462.
12463.
12464.
12465.
12466.
12467.
12468.
12469.
12470.
12471.
12472.
12473.
12474.
12475.
12476.
12477.
12478.
12479.
12480.
12481.
12482.
12483.
12484.
12485.
12486.
12487.
12488.
12489.
12490.
12491.
12492.
12493.
12494.
12495.
12496.
12497.
12498.
12499.
12500.
12501.
12502.
12503.
12504.
12505.
12506.
12507.
12508.
12509.
12510.
12511.
12512.
12513.
12514.
12515.
12516.
12517.
12518.
12519.
12520.
12521.
12522.
12523.
12524.
12525.
12526.
12527.
12528.
12529.
12530.
12531.
12532.
12533.
12534.
12535.
12536.
12537.
12538.
12539.
12540.
12541.
12542.
12543.
12544.
12545.
12546.
12547.
12548.
12549.
12550.
12551.
12552.
12553.
12554.
12555.
12556.
12557.
12558.
12559.
12560.
12561.
12562.
12563.
12564.
12565.
12566.
12567.
12568.
12569.
12570.
12571.
12572.
12573.
12574.
12575.
12576.
12577.
12578.
12579.
12580.
12581.
12582.
12583.
12584.
12585.
12586.
12587.
12588.
12589.
12590.
12591.
12592.
12593.
12594.
12595.
12596.
12597.
12598.
12599.
12600.
12601.
12602.
12603.
12604.
12605.
12606.
12607.
12608.
12609.
12610.
12611.
12612.
12613.
12614.
12615.
12616.
12617.
12618.
12619.
12620.
12621.
12622.
12623.
12624.
12625.
12626.
12627.
12628.
12629.
12630.
12631.
12632.
12633.
12634.
12635.
12636.
12637.
12638.
12639.
12640.
12641.
12642.
12643.
12644.
12645.
12646.
12647.
12648.
12649.
12650.
12651.
12652.
12653.
12654.
12655.
12656.
12657.
12658.
12659.
12660.
12661.
12662.
12663.
12664.
12665.
12666.
12667.
12668.
12669.
12670.
12671.
12672.
12673.
12674.
12675.
12676.
12677.
12678.
12679.
12680.
12681.
12682.
12683.
12684.
12685.
12686.
12687.
12688.
12689.
12690.
12691.
12692.
12693.
12694.
12695.
12696.
12697.
12698.
12699.
12700.
12701.
12702.
12703.
12704.
12705.
12706.
12707.
12708.
12709.
12710.
12711.
12712.
12713.
12714.
12715.
12716.
12717.
12718.
12719.
12720.
12721.
12722.
12723.
12724.
12725.
12726.
12727.
12728.
12729.
12730.
12731.
12732.
12733.
12734.
12735.
12736.
12737.
12738.
12739.
12740.
12741.
12742.
12743.
12744.
12745.
12746.
12747.
12748.
12749.
12750.
12751.
12752.
12753.
12754.
12755.
12756.
12757.
12758.
12759.
12760.
12761.
12762.
12763.
12764.
12765.
12766.
12767.
12768.
12769.
12770.
12771.
12772.
12773.
12774.
12775.
12776.
12777.
12778.
12779.
12780.
12781.
12782.
12783.
12784.
12785.
12786.
12787.
12788.
12789.
12790.
12791.
12792.
12793.
12794.
12795.
12796.
12797.
12798.
12799.
12800.
12801.
12802.
12803.
12804.
12805.
12806.
12807.
12808.
12809.
12810.
12811.
12812.
12813.
12814.
12815.
12816.
12817.
12818.
12819.
12820.
12821.
12822.
12823.
12824.
12825.
12826.
12827.
12828.
12829.
12830.
12831.
12832.
12833.
12834.
12835.
12836.
12837.
12838.
12839.
12840.
12841.
12842.
12843.
12844.
12845.
12846.
12847.
12848.
12849.
12850.
12851.
12852.
12853.
12854.
12855.
12856.
12857.
12858.
12859.
12860.
12861.
12862.
12863.
12864.
12865.
12866.
12867.
12868.
12869.
12870.
12871.
12872.
12873.
12874.
12875.
12876.
12877.
12878.
12879.
12880.
12881.
12882.
12883.
12884.
12885.
12886.
12887.
12888.
12889.
12890.
12891.
12892.
12893.
12894.
12895.
12896.
12897.
12898.
12899.
12900.
12901.
12902.
12903.
12904.
12905.
12906.
12907.
12908.
12909.
12910.
12911.
12912.
12913.
12914.
12915.
12916.
12917.
12918.
12919.
12920.
12921.
12922.
12923.
12924.
12925.
12926.
12927.
12928.
12929.
12930.
12931.
12932.
12933.
12934.
12935.
12936.
12937.
12938.
12939.
12940.
12941.
12942.
12943.
12944.
12945.
12946.
12947.
12948.
12949.
12950.
12951.
12952.
12953.
12954.
12955.
12956.
12957.
12958.
12959.
12960.
12961.
12962.
12963.
12964.
12965.
12966.
12967.
12968.
12969.
12970.
12971.
12972.
12973.
12974.
12975.
12976.
12977.
12978.
12979.
12980.
12981.
12982.
12983.
12984.
12985.
12986.
12987.
12988.
12989.
12990.
12991.
12992.
12993.
12994.
12995.
12996.
12997.
12998.
12999.
13000.
13001.
13002.
13003.
13004.
13005.
13006.
13007.
13008.
13009.
13010.
13011.
13012.
13013.
13014.
13015.
13016.
13017.
13018.
13019.
13020.
13021.
13022.
13023.
13024.
13025.
13026.
13027.
13028.
13029.
13030.
13031.
13032.
13033.
13034.
13035.
13036.
13037.
13038.
13039.
13040.
13041.
13042.
13043.
13044.
13045.
13046.
13047.
13048.
13049.
13050.
13051.
13052.
13053.
13054.
13055.
13056.
13057.
13058.
13059.
13060.
13061.
13062.
13063.
13064.
13065.
13066.
13067.
13068.
13069.
13070.
13071.
13072.
13073.
13074.
13075.
13076.
13077.
13078.
13079.
13080.
13081.
13082.
13083.
13084.
13085.
13086.
13087.
13088.
13089.
13090.
13091.
13092.
13093.
13094.
13095.
13096.
13097.
13098.
13099.
13100.
13101.
13102.
13103.
13104.
13105.
13106.
13107.
13108.
13109.
13110.
13111.
13112.
13113.
13114.
13115.
13116.
13117.
13118.
13119.
13120.
13121.
13122.
13123.
13124.
13125.
13126.
13127.
13128.
13129.
13130.
13131.
13132.
13133.
13134.
13135.
13136.
13137.
13138.
13139.
13140.
13141.
13142.
13143.
13144.
13145.
13146.
13147.
13148.
13149.
13150.
13151.
13152.
13153.
13154.
13155.
13156.
13157.
13158.
13159.
13160.
13161.
13162.
13163.
13164.
13165.
13166.
13167.
13168.
13169.
13170.
13171.
13172.
13173.
13174.
13175.
13176.
13177.
13178.
13179.
13180.
13181.
13182.
13183.
13184.
13185.
13186.
13187.
13188.
13189.
13190.
13191.
13192.
13193.
13194.
13195.
13196.
13197.
13198.
13199.
13200.
13201.
13202.
13203.
13204.
13205.
13206.
13207.
13208.
13209.
13210.
13211.
13212.
13213.
13214.
13215.
13216.
13217.
13218.
13219.
13220.
13221.
13222.
13223.
13224.
13225.
13226.
13227.
13228.
13229.
13230.
13231.
13232.
13233.
13234.
13235.
13236.
13237.
13238.
13239.
13240.
13241.
13242.
13243.
13244.
13245.
13246.
13247.
13248.
13249.
13250.
13251.
13252.
13253.
13254.
13255.
13256.
13257.
13258.
13259.
13260.
13261.
13262.
13263.
13264.
13265.
13266.
13267.
13268.
13269.
13270.
13271.
13272.
13273.
13274.
13275.
13276.
13277.
13278.
13279.
13280.
13281.
13282.
13283.
13284.
13285.
13286.
13287.
13288.
13289.
13290.
13291.
13292.
13293.
13294.
13295.
13296.
13297.
13298.
13299.
13300.
13301.
13302.
13303.
13304.
13305.
13306.
13307.
13308.
13309.
13310.
13311.
13312.
13313.
13314.
13315.
13316.
13317.
13318.
13319.
13320.
13321.
13322.
13323.
13324.
13325.
13326.
13327.
13328.
13329.
13330.
13331.
13332.
13333.
13334.
13335.
13336.
13337.
13338.
13339.
13340.
13341.
13342.
13343.
13344.
13345.
13346.
13347.
13348.
13349.
13350.
13351.
13352.
13353.
13354.
13355.
13356.
13357.
13358.
13359.
13360.
13361.
13362.
13363.
13364.
13365.
13366.
13367.
13368.
13369.
13370.
13371.
13372.
13373.
13374.
13375.
13376.
13377.
13378.
13379.
13380.
13381.
13382.
13383.
13384.
13385.
13386.
13387.
13388.
13389.
13390.
13391.
13392.
13393.
13394.
13395.
13396.
13397.
13398.
13399.
13400.
13401.
13402.
13403.
13404.
13405.
13406.
13407.
13408.
13409.
13410.
13411.
13412.
13413.
13414.
13415.
13416.
13417.
13418.
13419.
13420.
13421.
13422.
13423.
13424.
13425.
13426.
13427.
13428.
13429.
13430.
13431.
13432.
13433.
13434.
13435.
13436.
13437.
13438.
13439.
13440.
13441.
13442.
13443.
13444.
13445.
13446.
13447.
13448.
13449.
13450.
13451.
13452.
13453.
13454.
13455.
13456.
13457.
13458.
13459.
13460.
13461.
13462.
13463.
13464.
13465.
13466.
13467.
13468.
13469.
13470.
13471.
13472.
13473.
13474.
13475.
13476.
13477.
13478.
13479.
13480.
13481.
13482.
13483.
13484.
13485.
13486.
13487.
13488.
13489.
13490.
13491.
13492.
13493.
13494.
13495.
13496.
13497.
13498.
13499.
13500.
13501.
13502.
13503.
13504.
13505.
13506.
13507.
13508.
13509.
13510.
13511.
13512.
13513.
13514.
13515.
13516.
13517.
13518.
13519.
13520.
13521.
13522.
13523.
13524.
13525.
13526.
13527.
13528.
13529.
13530.
13531.
13532.
13533.
13534.
13535.
13536.
13537.
13538.
13539.
13540.
13541.
13542.
13543.
13544.
13545.
13546.
13547.
13548.
13549.
13550.
13551.
13552.
13553.
13554.
13555.
13556.
13557.
13558.
13559.
13560.
13561.
13562.
13563.
13564.
13565.
13566.
13567.
13568.
13569.
13570.
13571.
13572.
13573.
13574.
13575.
13576.
13577.
13578.
13579.
13580.
13581.
13582.
13583.
13584.
13585.
13586.
13587.
13588.
13589.
13590.
13591.
13592.
13593.
13594.
13595.
13596.
13597.
13598.
13599.
13600.
13601.
13602.
13603.
13604.
13605.
13606.
13607.
13608.
13609.
13610.
13611.
13612.
13613.
13614.
13615.
13616.
13617.
13618.
13619.
13620.
13621.
13622.
13623.
13624.
13625.
13626.
13627.
13628.
13629.
13630.
13631.
13632.
13633.
13634.
13635.
13636.
13637.
13638.
13639.
13640.
13641.
13642.
13643.
13644.
13645.
13646.
13647.
13648.
13649.
13650.
13651.
13652.
13653.
13654.
13655.
13656.
13657.
13658.
13659.
13660.
13661.
13662.
13663.
13664.
13665.
13666.
13667.
13668.
13669.
13670.
13671.
13672.
13673.
13674.
13675.
13676.
13677.
13678.
13679.
13680.
13681.
13682.
13683.
13684.
13685.
13686.
13687.
13688.
13689.
13690.
13691.
13692.
13693.
13694.
13695.
13696.
13697.
13698.
13699.
13700.
13701.
13702.
13703.
13704.
13705.
13706.
13707.
13708.
13709.
13710.
13711.
13712.
13713.
13714.
13715.
13716.
13717.
13718.
13719.
13720.
13721.
13722.
13723.
13724.
13725.
13726.
13727.
13728.
13729.
13730.
13731.
13732.
13733.
13734.
13735.
13736.
13737.
13738.
13739.
13740.
13741.
13742.
13743.
13744.
13745.
</code_line></pre></td>
<td class='lines'><pre><code class="prettyprint">// SPDX-License-Identifier: GPL-2.0-only
/*
 * Kernel-based Virtual Machine driver for Linux
 *
 * derived from drivers/kvm/kvm_main.c
 *
 * Copyright (C) 2006 Qumranet, Inc.
 * Copyright (C) 2008 Qumranet, Inc.
 * Copyright IBM Corporation, 2008
 * Copyright 2010 Red Hat, Inc. and/or its affiliates.
 *
 * Authors:
 *   Avi Kivity   &lt;avi@qumranet.com&gt;
 *   Yaniv Kamay  &lt;yaniv@qumranet.com&gt;
 *   Amit Shah    &lt;amit.shah@qumranet.com&gt;
 *   Ben-Ami Yassour &lt;benami@il.ibm.com&gt;
 */

#include &lt;linux/kvm_host.h&gt;
#include &quot;irq.h&quot;
#include &quot;ioapic.h&quot;
#include &quot;mmu.h&quot;
#include &quot;i8254.h&quot;
#include &quot;tss.h&quot;
#include &quot;kvm_cache_regs.h&quot;
#include &quot;kvm_emulate.h&quot;
#include &quot;x86.h&quot;
#include &quot;cpuid.h&quot;
#include &quot;pmu.h&quot;
#include &quot;hyperv.h&quot;
#include &quot;lapic.h&quot;
#include &quot;xen.h&quot;

#include &lt;linux/clocksource.h&gt;
#include &lt;linux/interrupt.h&gt;
#include &lt;linux/kvm.h&gt;
#include &lt;linux/fs.h&gt;
#include &lt;linux/vmalloc.h&gt;
#include &lt;linux/export.h&gt;
#include &lt;linux/moduleparam.h&gt;
#include &lt;linux/mman.h&gt;
#include &lt;linux/highmem.h&gt;
#include &lt;linux/iommu.h&gt;
#include &lt;linux/cpufreq.h&gt;
#include &lt;linux/user-return-notifier.h&gt;
#include &lt;linux/srcu.h&gt;
#include &lt;linux/slab.h&gt;
#include &lt;linux/perf_event.h&gt;
#include &lt;linux/uaccess.h&gt;
#include &lt;linux/hash.h&gt;
#include &lt;linux/pci.h&gt;
#include &lt;linux/timekeeper_internal.h&gt;
#include &lt;linux/pvclock_gtod.h&gt;
#include &lt;linux/kvm_irqfd.h&gt;
#include &lt;linux/irqbypass.h&gt;
#include &lt;linux/sched/stat.h&gt;
#include &lt;linux/sched/isolation.h&gt;
#include &lt;linux/mem_encrypt.h&gt;
#include &lt;linux/entry-kvm.h&gt;
#include &lt;linux/suspend.h&gt;

#include &lt;trace/events/kvm.h&gt;

#include &lt;asm/debugreg.h&gt;
#include &lt;asm/msr.h&gt;
#include &lt;asm/desc.h&gt;
#include &lt;asm/mce.h&gt;
#include &lt;asm/pkru.h&gt;
#include &lt;linux/kernel_stat.h&gt;
#include &lt;asm/fpu/api.h&gt;
#include &lt;asm/fpu/xcr.h&gt;
#include &lt;asm/fpu/xstate.h&gt;
#include &lt;asm/pvclock.h&gt;
#include &lt;asm/div64.h&gt;
#include &lt;asm/irq_remapping.h&gt;
#include &lt;asm/mshyperv.h&gt;
#include &lt;asm/hypervisor.h&gt;
#include &lt;asm/tlbflush.h&gt;
#include &lt;asm/intel_pt.h&gt;
#include &lt;asm/emulate_prefix.h&gt;
#include &lt;asm/sgx.h&gt;
#include &lt;clocksource/hyperv_timer.h&gt;

#define CREATE_TRACE_POINTS
#include &quot;trace.h&quot;

#define MAX_IO_MSRS 256
#define KVM_MAX_MCE_BANKS 32

struct kvm_caps kvm_caps __read_mostly = {
	.supported_mce_cap = MCG_CTL_P | MCG_SER_P,
};
EXPORT_SYMBOL_GPL(kvm_caps);

#define  ERR_PTR_USR(e)  ((void __user *)ERR_PTR(e))

#define emul_to_vcpu(ctxt) \
	((struct kvm_vcpu *)(ctxt)-&gt;vcpu)

/* EFER defaults:
 * - enable syscall per default because its emulated by KVM
 * - enable LME and LMA per default on 64 bit KVM
 */
#ifdef CONFIG_X86_64
static
u64 __read_mostly efer_reserved_bits = ~((u64)(EFER_SCE | EFER_LME | EFER_LMA));
#else
static u64 __read_mostly efer_reserved_bits = ~((u64)EFER_SCE);
#endif

static u64 __read_mostly cr4_reserved_bits = CR4_RESERVED_BITS;

#define KVM_EXIT_HYPERCALL_VALID_MASK (1 &lt;&lt; KVM_HC_MAP_GPA_RANGE)

#define KVM_CAP_PMU_VALID_MASK KVM_PMU_CAP_DISABLE

#define KVM_X2APIC_API_VALID_FLAGS (KVM_X2APIC_API_USE_32BIT_IDS | \
                                    KVM_X2APIC_API_DISABLE_BROADCAST_QUIRK)

static void update_cr8_intercept(struct kvm_vcpu *vcpu);
static void process_nmi(struct kvm_vcpu *vcpu);
static void process_smi(struct kvm_vcpu *vcpu);
static void enter_smm(struct kvm_vcpu *vcpu);
static void __kvm_set_rflags(struct kvm_vcpu *vcpu, unsigned long rflags);
static void store_regs(struct kvm_vcpu *vcpu);
static int sync_regs(struct kvm_vcpu *vcpu);
static int kvm_vcpu_do_singlestep(struct kvm_vcpu *vcpu);

static int __set_sregs2(struct kvm_vcpu *vcpu, struct kvm_sregs2 *sregs2);
static void __get_sregs2(struct kvm_vcpu *vcpu, struct kvm_sregs2 *sregs2);

struct kvm_x86_ops kvm_x86_ops __read_mostly;

#define KVM_X86_OP(func)					     \
	DEFINE_STATIC_CALL_NULL(kvm_x86_##func,			     \
				*(((struct kvm_x86_ops *)0)-&gt;func));
#define KVM_X86_OP_OPTIONAL KVM_X86_OP
#define KVM_X86_OP_OPTIONAL_RET0 KVM_X86_OP
#include &lt;asm/kvm-x86-ops.h&gt;
EXPORT_STATIC_CALL_GPL(kvm_x86_get_cs_db_l_bits);
EXPORT_STATIC_CALL_GPL(kvm_x86_cache_reg);

static bool __read_mostly ignore_msrs = 0;
module_param(ignore_msrs, bool, S_IRUGO | S_IWUSR);

bool __read_mostly report_ignored_msrs = true;
module_param(report_ignored_msrs, bool, S_IRUGO | S_IWUSR);
EXPORT_SYMBOL_GPL(report_ignored_msrs);

unsigned int min_timer_period_us = 200;
module_param(min_timer_period_us, uint, S_IRUGO | S_IWUSR);

static bool __read_mostly kvmclock_periodic_sync = true;
module_param(kvmclock_periodic_sync, bool, S_IRUGO);

/* tsc tolerance in parts per million - default to 1/2 of the NTP threshold */
static u32 __read_mostly tsc_tolerance_ppm = 250;
module_param(tsc_tolerance_ppm, uint, S_IRUGO | S_IWUSR);

/*
 * lapic timer advance (tscdeadline mode only) in nanoseconds.  &#x27;-1&#x27; enables
 * adaptive tuning starting from default advancement of 1000ns.  &#x27;0&#x27; disables
 * advancement entirely.  Any other value is used as-is and disables adaptive
 * tuning, i.e. allows privileged userspace to set an exact advancement time.
 */
static int __read_mostly lapic_timer_advance_ns = -1;
module_param(lapic_timer_advance_ns, int, S_IRUGO | S_IWUSR);

static bool __read_mostly vector_hashing = true;
module_param(vector_hashing, bool, S_IRUGO);

bool __read_mostly enable_vmware_backdoor = false;
module_param(enable_vmware_backdoor, bool, S_IRUGO);
EXPORT_SYMBOL_GPL(enable_vmware_backdoor);

/*
 * Flags to manipulate forced emulation behavior (any non-zero value will
 * enable forced emulation).
 */
#define KVM_FEP_CLEAR_RFLAGS_RF	BIT(1)
static int __read_mostly force_emulation_prefix;
module_param(force_emulation_prefix, int, 0644);

int __read_mostly pi_inject_timer = -1;
module_param(pi_inject_timer, bint, S_IRUGO | S_IWUSR);

/* Enable/disable PMU virtualization */
bool __read_mostly enable_pmu = true;
EXPORT_SYMBOL_GPL(enable_pmu);
module_param(enable_pmu, bool, 0444);

bool __read_mostly eager_page_split = true;
module_param(eager_page_split, bool, 0644);

/*
 * Restoring the host value for MSRs that are only consumed when running in
 * usermode, e.g. SYSCALL MSRs and TSC_AUX, can be deferred until the CPU
 * returns to userspace, i.e. the kernel can run with the guest&#x27;s value.
 */
#define KVM_MAX_NR_USER_RETURN_MSRS 16

struct kvm_user_return_msrs {
	struct user_return_notifier urn;
	bool registered;
	struct kvm_user_return_msr_values {
		u64 host;
		u64 curr;
	} values[KVM_MAX_NR_USER_RETURN_MSRS];
};

u32 __read_mostly kvm_nr_uret_msrs;
EXPORT_SYMBOL_GPL(kvm_nr_uret_msrs);
static u32 __read_mostly kvm_uret_msrs_list[KVM_MAX_NR_USER_RETURN_MSRS];
static struct kvm_user_return_msrs __percpu *user_return_msrs;

#define KVM_SUPPORTED_XCR0     (XFEATURE_MASK_FP | XFEATURE_MASK_SSE \
				| XFEATURE_MASK_YMM | XFEATURE_MASK_BNDREGS \
				| XFEATURE_MASK_BNDCSR | XFEATURE_MASK_AVX512 \
				| XFEATURE_MASK_PKRU | XFEATURE_MASK_XTILE)

u64 __read_mostly host_efer;
EXPORT_SYMBOL_GPL(host_efer);

bool __read_mostly allow_smaller_maxphyaddr = 0;
EXPORT_SYMBOL_GPL(allow_smaller_maxphyaddr);

bool __read_mostly enable_apicv = true;
EXPORT_SYMBOL_GPL(enable_apicv);

u64 __read_mostly host_xss;
EXPORT_SYMBOL_GPL(host_xss);

const struct _kvm_stats_desc kvm_vm_stats_desc[] = {
	KVM_GENERIC_VM_STATS(),
	STATS_DESC_COUNTER(VM, mmu_shadow_zapped),
	STATS_DESC_COUNTER(VM, mmu_pte_write),
	STATS_DESC_COUNTER(VM, mmu_pde_zapped),
	STATS_DESC_COUNTER(VM, mmu_flooded),
	STATS_DESC_COUNTER(VM, mmu_recycled),
	STATS_DESC_COUNTER(VM, mmu_cache_miss),
	STATS_DESC_ICOUNTER(VM, mmu_unsync),
	STATS_DESC_ICOUNTER(VM, pages_4k),
	STATS_DESC_ICOUNTER(VM, pages_2m),
	STATS_DESC_ICOUNTER(VM, pages_1g),
	STATS_DESC_ICOUNTER(VM, nx_lpage_splits),
	STATS_DESC_PCOUNTER(VM, max_mmu_rmap_size),
	STATS_DESC_PCOUNTER(VM, max_mmu_page_hash_collisions)
};

const struct kvm_stats_header kvm_vm_stats_header = {
	.name_size = KVM_STATS_NAME_SIZE,
	.num_desc = ARRAY_SIZE(kvm_vm_stats_desc),
	.id_offset = sizeof(struct kvm_stats_header),
	.desc_offset = sizeof(struct kvm_stats_header) + KVM_STATS_NAME_SIZE,
	.data_offset = sizeof(struct kvm_stats_header) + KVM_STATS_NAME_SIZE +
		       sizeof(kvm_vm_stats_desc),
};

const struct _kvm_stats_desc kvm_vcpu_stats_desc[] = {
	KVM_GENERIC_VCPU_STATS(),
	STATS_DESC_COUNTER(VCPU, pf_taken),
	STATS_DESC_COUNTER(VCPU, pf_fixed),
	STATS_DESC_COUNTER(VCPU, pf_emulate),
	STATS_DESC_COUNTER(VCPU, pf_spurious),
	STATS_DESC_COUNTER(VCPU, pf_fast),
	STATS_DESC_COUNTER(VCPU, pf_mmio_spte_created),
	STATS_DESC_COUNTER(VCPU, pf_guest),
	STATS_DESC_COUNTER(VCPU, tlb_flush),
	STATS_DESC_COUNTER(VCPU, invlpg),
	STATS_DESC_COUNTER(VCPU, exits),
	STATS_DESC_COUNTER(VCPU, io_exits),
	STATS_DESC_COUNTER(VCPU, mmio_exits),
	STATS_DESC_COUNTER(VCPU, signal_exits),
	STATS_DESC_COUNTER(VCPU, irq_window_exits),
	STATS_DESC_COUNTER(VCPU, nmi_window_exits),
	STATS_DESC_COUNTER(VCPU, l1d_flush),
	STATS_DESC_COUNTER(VCPU, halt_exits),
	STATS_DESC_COUNTER(VCPU, request_irq_exits),
	STATS_DESC_COUNTER(VCPU, irq_exits),
	STATS_DESC_COUNTER(VCPU, host_state_reload),
	STATS_DESC_COUNTER(VCPU, fpu_reload),
	STATS_DESC_COUNTER(VCPU, insn_emulation),
	STATS_DESC_COUNTER(VCPU, insn_emulation_fail),
	STATS_DESC_COUNTER(VCPU, hypercalls),
	STATS_DESC_COUNTER(VCPU, irq_injections),
	STATS_DESC_COUNTER(VCPU, nmi_injections),
	STATS_DESC_COUNTER(VCPU, req_event),
	STATS_DESC_COUNTER(VCPU, nested_run),
	STATS_DESC_COUNTER(VCPU, directed_yield_attempted),
	STATS_DESC_COUNTER(VCPU, directed_yield_successful),
	STATS_DESC_COUNTER(VCPU, preemption_reported),
	STATS_DESC_COUNTER(VCPU, preemption_other),
	STATS_DESC_IBOOLEAN(VCPU, guest_mode),
	STATS_DESC_COUNTER(VCPU, notify_window_exits),
};

const struct kvm_stats_header kvm_vcpu_stats_header = {
	.name_size = KVM_STATS_NAME_SIZE,
	.num_desc = ARRAY_SIZE(kvm_vcpu_stats_desc),
	.id_offset = sizeof(struct kvm_stats_header),
	.desc_offset = sizeof(struct kvm_stats_header) + KVM_STATS_NAME_SIZE,
	.data_offset = sizeof(struct kvm_stats_header) + KVM_STATS_NAME_SIZE +
		       sizeof(kvm_vcpu_stats_desc),
};

u64 __read_mostly host_xcr0;

static struct kmem_cache *x86_emulator_cache;

/*
 * When called, it means the previous get/set msr reached an invalid msr.
 * Return true if we want to ignore/silent this failed msr access.
 */
static bool kvm_msr_ignored_check(u32 msr, u64 data, bool write)
{
<blue>	const char *op = write ? "wrmsr" : "rdmsr";</blue>

<blue>	if (ignore_msrs) {</blue>
<yellow>		if (report_ignored_msrs)</yellow>
<yellow>			kvm_pr_unimpl("ignored %s: 0x%x data 0x%llx\n",</yellow>
				      op, msr, data);
		/* Mask the error */
		return true;
	} else {
<blue>		kvm_debug_ratelimited("unhandled %s: 0x%x data 0x%llx\n",</blue>
				      op, msr, data);
		return false;
	}
<blue>}</blue>

static struct kmem_cache *kvm_alloc_emulator_cache(void)
{
	unsigned int useroffset = offsetof(struct x86_emulate_ctxt, src);
	unsigned int size = sizeof(struct x86_emulate_ctxt);

<yellow>	return kmem_cache_create_usercopy("x86_emulator", size,</yellow>
					  __alignof__(struct x86_emulate_ctxt),
					  SLAB_ACCOUNT, useroffset,
					  size - useroffset, NULL);
}

static int emulator_fix_hypercall(struct x86_emulate_ctxt *ctxt);

static inline void kvm_async_pf_hash_reset(struct kvm_vcpu *vcpu)
{
	int i;
	for (i = 0; i &lt; ASYNC_PF_PER_VCPU; i++)
<blue>		vcpu->arch.apf.gfns[i] = ~0;</blue>
}

static void kvm_on_user_return(struct user_return_notifier *urn)
{
	unsigned slot;
	struct kvm_user_return_msrs *msrs
		= container_of(urn, struct kvm_user_return_msrs, urn);
	struct kvm_user_return_msr_values *values;
	unsigned long flags;

	/*
	 * Disabling irqs at this point since the following code could be
	 * interrupted and executed through kvm_arch_hardware_disable()
	 */
<blue>	local_irq_save(flags);</blue>
<blue>	if (msrs->registered) {</blue>
<blue>		msrs->registered = false;</blue>
		user_return_notifier_unregister(urn);
	}
<blue>	local_irq_restore(flags);</blue>
<blue>	for (slot = 0; slot < kvm_nr_uret_msrs; ++slot) {</blue>
		values = &amp;msrs-&gt;values[slot];
<blue>		if (values->host != values->curr) {</blue>
<blue>			wrmsrl(kvm_uret_msrs_list[slot], values->host);</blue>
			values-&gt;curr = values-&gt;host;
		}
	}
<blue>}</blue>

static int kvm_probe_user_return_msr(u32 msr)
{
	u64 val;
	int ret;

<yellow>	preempt_disable();</yellow>
	ret = rdmsrl_safe(msr, &amp;val);
	if (ret)
		goto out;
<yellow>	ret = wrmsrl_safe(msr, val);</yellow>
out:
<yellow>	preempt_enable();</yellow>
	return ret;
}

int kvm_add_user_return_msr(u32 msr)
<yellow>{</yellow>
<yellow>	BUG_ON(kvm_nr_uret_msrs >= KVM_MAX_NR_USER_RETURN_MSRS);</yellow>

<yellow>	if (kvm_probe_user_return_msr(msr))</yellow>
		return -1;

<yellow>	kvm_uret_msrs_list[kvm_nr_uret_msrs] = msr;</yellow>
	return kvm_nr_uret_msrs++;
}
EXPORT_SYMBOL_GPL(kvm_add_user_return_msr);

int kvm_find_user_return_msr(u32 msr)
{
	int i;

<blue>	for (i = 0; i < kvm_nr_uret_msrs; ++i) {</blue>
<blue>		if (kvm_uret_msrs_list[i] == msr)</blue>
			return i;
	}
	return -1;
<blue>}</blue>
EXPORT_SYMBOL_GPL(kvm_find_user_return_msr);

static void kvm_user_return_msr_cpu_online(void)
{
<blue>	unsigned int cpu = smp_processor_id();</blue>
	struct kvm_user_return_msrs *msrs = per_cpu_ptr(user_return_msrs, cpu);
	u64 value;
	int i;

	for (i = 0; i &lt; kvm_nr_uret_msrs; ++i) {
<blue>		rdmsrl_safe(kvm_uret_msrs_list[i], &value);</blue>
		msrs-&gt;values[i].host = value;
		msrs-&gt;values[i].curr = value;
	}
}

int kvm_set_user_return_msr(unsigned slot, u64 value, u64 mask)
{
<blue>	unsigned int cpu = smp_processor_id();</blue>
	struct kvm_user_return_msrs *msrs = per_cpu_ptr(user_return_msrs, cpu);
	int err;

	value = (value &amp; mask) | (msrs-&gt;values[slot].host &amp; ~mask);
	if (value == msrs-&gt;values[slot].curr)
		return 0;
<blue>	err = wrmsrl_safe(kvm_uret_msrs_list[slot], value);</blue>
	if (err)
		return 1;

<blue>	msrs->values[slot].curr = value;</blue>
<blue>	if (!msrs->registered) {</blue>
<blue>		msrs->urn.on_user_return = kvm_on_user_return;</blue>
		user_return_notifier_register(&amp;msrs-&gt;urn);
		msrs-&gt;registered = true;
	}
	return 0;
<blue>}</blue>
EXPORT_SYMBOL_GPL(kvm_set_user_return_msr);

static void drop_user_return_notifiers(void)
{
	unsigned int cpu = smp_processor_id();
	struct kvm_user_return_msrs *msrs = per_cpu_ptr(user_return_msrs, cpu);

<yellow>	if (msrs->registered)</yellow>
<yellow>		kvm_on_user_return(&msrs->urn);</yellow>
}

u64 kvm_get_apic_base(struct kvm_vcpu *vcpu)
{
<blue>	return vcpu->arch.apic_base;</blue>
}
EXPORT_SYMBOL_GPL(kvm_get_apic_base);

enum lapic_mode kvm_get_apic_mode(struct kvm_vcpu *vcpu)
{
<blue>	return kvm_apic_mode(kvm_get_apic_base(vcpu));</blue>
}
EXPORT_SYMBOL_GPL(kvm_get_apic_mode);

int kvm_set_apic_base(struct kvm_vcpu *vcpu, struct msr_data *msr_info)
{
<blue>	enum lapic_mode old_mode = kvm_get_apic_mode(vcpu);</blue>
<blue>	enum lapic_mode new_mode = kvm_apic_mode(msr_info->data);</blue>
	u64 reserved_bits = kvm_vcpu_reserved_gpa_bits_raw(vcpu) | 0x2ff |
<blue>		(guest_cpuid_has(vcpu, X86_FEATURE_X2APIC) ? 0 : X2APIC_ENABLE);</blue>

<blue>	if ((msr_info->data & reserved_bits) != 0 || new_mode == LAPIC_MODE_INVALID)</blue>
		return 1;
<blue>	if (!msr_info->host_initiated) {</blue>
<yellow>		if (old_mode == LAPIC_MODE_X2APIC && new_mode == LAPIC_MODE_XAPIC)</yellow>
			return 1;
<yellow>		if (old_mode == LAPIC_MODE_DISABLED && new_mode == LAPIC_MODE_X2APIC)</yellow>
			return 1;
	}

<blue>	kvm_lapic_set_base(vcpu, msr_info->data);</blue>
	kvm_recalculate_apic_map(vcpu-&gt;kvm);
	return 0;
<blue>}</blue>
EXPORT_SYMBOL_GPL(kvm_set_apic_base);

/*
 * Handle a fault on a hardware virtualization (VMX or SVM) instruction.
 *
 * Hardware virtualization extension instructions may fault if a reboot turns
 * off virtualization while processes are running.  Usually after catching the
 * fault we just panic; during reboot instead the instruction is ignored.
 */
noinstr void kvm_spurious_fault(void)
{
	/* Fault while not rebooting.  We want the trace. */
	BUG_ON(!kvm_rebooting);
}
EXPORT_SYMBOL_GPL(kvm_spurious_fault);

#define EXCPT_BENIGN		0
#define EXCPT_CONTRIBUTORY	1
#define EXCPT_PF		2

static int exception_class(int vector)
{
<yellow>	switch (vector) {</yellow>
	case PF_VECTOR:
		return EXCPT_PF;
	case DE_VECTOR:
	case TS_VECTOR:
	case NP_VECTOR:
	case SS_VECTOR:
	case GP_VECTOR:
		return EXCPT_CONTRIBUTORY;
	default:
		break;
	}
	return EXCPT_BENIGN;
}

#define EXCPT_FAULT		0
#define EXCPT_TRAP		1
#define EXCPT_ABORT		2
#define EXCPT_INTERRUPT		3
#define EXCPT_DB		4

static int exception_type(int vector)
{
	unsigned int mask;

<blue>	if (WARN_ON(vector > 31 || vector == NMI_VECTOR))</blue>
<yellow>		return EXCPT_INTERRUPT;</yellow>

<blue>	mask = 1 << vector;</blue>

	/*
	 * #DBs can be trap-like or fault-like, the caller must check other CPU
	 * state, e.g. DR6, to determine whether a #DB is a trap or fault.
	 */
	if (mask &amp; (1 &lt;&lt; DB_VECTOR))
		return EXCPT_DB;

<blue>	if (mask & ((1 << BP_VECTOR) | (1 << OF_VECTOR)))</blue>
		return EXCPT_TRAP;

<blue>	if (mask & ((1 << DF_VECTOR) | (1 << MC_VECTOR)))</blue>
		return EXCPT_ABORT;

	/* Reserved exceptions will result in fault */
	return EXCPT_FAULT;
<blue>}</blue>

<blue>void kvm_deliver_exception_payload(struct kvm_vcpu *vcpu,</blue>
				   struct kvm_queued_exception *ex)
{
<blue>	if (!ex->has_payload)</blue>
		return;

<blue>	switch (ex->vector) {</blue>
	case DB_VECTOR:
		/*
		 * &quot;Certain debug exceptions may clear bit 0-3.  The
		 * remaining contents of the DR6 register are never
		 * cleared by the processor&quot;.
		 */
<blue>		vcpu->arch.dr6 &= ~DR_TRAP_BITS;</blue>
		/*
		 * In order to reflect the #DB exception payload in guest
		 * dr6, three components need to be considered: active low
		 * bit, FIXED_1 bits and active high bits (e.g. DR6_BD,
		 * DR6_BS and DR6_BT)
		 * DR6_ACTIVE_LOW contains the FIXED_1 and active low bits.
		 * In the target guest dr6:
		 * FIXED_1 bits should always be set.
		 * Active low bits should be cleared if 1-setting in payload.
		 * Active high bits should be set if 1-setting in payload.
		 *
		 * Note, the payload is compatible with the pending debug
		 * exceptions/exit qualification under VMX, that active_low bits
		 * are active high in payload.
		 * So they need to be flipped for DR6.
		 */
		vcpu-&gt;arch.dr6 |= DR6_ACTIVE_LOW;
		vcpu-&gt;arch.dr6 |= ex-&gt;payload;
		vcpu-&gt;arch.dr6 ^= ex-&gt;payload &amp; DR6_ACTIVE_LOW;

		/*
		 * The #DB payload is defined as compatible with the &#x27;pending
		 * debug exceptions&#x27; field under VMX, not DR6. While bit 12 is
		 * defined in the &#x27;pending debug exceptions&#x27; field (enabled
		 * breakpoint), it is reserved and must be zero in DR6.
		 */
		vcpu-&gt;arch.dr6 &amp;= ~BIT(12);
		break;
	case PF_VECTOR:
<blue>		vcpu->arch.cr2 = ex->payload;</blue>
		break;
	}

<blue>	ex->has_payload = false;</blue>
	ex-&gt;payload = 0;
<blue>}</blue>
EXPORT_SYMBOL_GPL(kvm_deliver_exception_payload);

static void kvm_queue_exception_vmexit(struct kvm_vcpu *vcpu, unsigned int vector,
				       bool has_error_code, u32 error_code,
				       bool has_payload, unsigned long payload)
{
	struct kvm_queued_exception *ex = &amp;vcpu-&gt;arch.exception_vmexit;

<blue>	ex->vector = vector;</blue>
	ex-&gt;injected = false;
	ex-&gt;pending = true;
	ex-&gt;has_error_code = has_error_code;
	ex-&gt;error_code = error_code;
	ex-&gt;has_payload = has_payload;
	ex-&gt;payload = payload;
}

/* Forcibly leave the nested mode in cases like a vCPU reset */
static void kvm_leave_nested(struct kvm_vcpu *vcpu)
{
<blue>	kvm_x86_ops.nested_ops->leave_nested(vcpu);</blue>
}

static void kvm_multiple_exception(struct kvm_vcpu *vcpu,
		unsigned nr, bool has_error, u32 error_code,
	        bool has_payload, unsigned long payload, bool reinject)
{
	u32 prev_nr;
	int class1, class2;

<blue>	kvm_make_request(KVM_REQ_EVENT, vcpu);</blue>

	/*
	 * If the exception is destined for L2 and isn&#x27;t being reinjected,
	 * morph it to a VM-Exit if L1 wants to intercept the exception.  A
	 * previously injected exception is not checked because it was checked
	 * when it was original queued, and re-checking is incorrect if _L1_
	 * injected the exception, in which case it&#x27;s exempt from interception.
	 */
<blue>	if (!reinject && is_guest_mode(vcpu) &&</blue>
<blue>	    kvm_x86_ops.nested_ops->is_exception_vmexit(vcpu, nr, error_code)) {</blue>
<blue>		kvm_queue_exception_vmexit(vcpu, nr, has_error, error_code,</blue>
					   has_payload, payload);
		return;
	}

<blue>	if (!vcpu->arch.exception.pending && !vcpu->arch.exception.injected) {</blue>
	queue:
<blue>		if (reinject) {</blue>
			/*
			 * On VM-Entry, an exception can be pending if and only
			 * if event injection was blocked by nested_run_pending.
			 * In that case, however, vcpu_enter_guest() requests an
			 * immediate exit, and the guest shouldn&#x27;t proceed far
			 * enough to need reinjection.
			 */
<blue>			WARN_ON_ONCE(kvm_is_exception_pending(vcpu));</blue>
<blue>			vcpu->arch.exception.injected = true;</blue>
<blue>			if (WARN_ON_ONCE(has_payload)) {</blue>
				/*
				 * A reinjected event has already
				 * delivered its payload.
				 */
				has_payload = false;
				payload = 0;
			}
		} else {
<blue>			vcpu->arch.exception.pending = true;</blue>
			vcpu-&gt;arch.exception.injected = false;
		}
		vcpu-&gt;arch.exception.has_error_code = has_error;
		vcpu-&gt;arch.exception.vector = nr;
		vcpu-&gt;arch.exception.error_code = error_code;
		vcpu-&gt;arch.exception.has_payload = has_payload;
		vcpu-&gt;arch.exception.payload = payload;
		if (!is_guest_mode(vcpu))
<blue>			kvm_deliver_exception_payload(vcpu,</blue>
						      &amp;vcpu-&gt;arch.exception);
		return;
	}

	/* to check exception */
<yellow>	prev_nr = vcpu->arch.exception.vector;</yellow>
	if (prev_nr == DF_VECTOR) {
		/* triple fault -&gt; shutdown */
<yellow>		kvm_make_request(KVM_REQ_TRIPLE_FAULT, vcpu);</yellow>
		return;
	}
<yellow>	class1 = exception_class(prev_nr);</yellow>
<yellow>	class2 = exception_class(nr);</yellow>
<yellow>	if ((class1 == EXCPT_CONTRIBUTORY && class2 == EXCPT_CONTRIBUTORY) ||</yellow>
	    (class1 == EXCPT_PF &amp;&amp; class2 != EXCPT_BENIGN)) {
		/*
		 * Synthesize #DF.  Clear the previously injected or pending
		 * exception so as not to incorrectly trigger shutdown.
		 */
<yellow>		vcpu->arch.exception.injected = false;</yellow>
		vcpu-&gt;arch.exception.pending = false;

		kvm_queue_exception_e(vcpu, DF_VECTOR, 0);
	} else {
		/* replace previous exception with a new one in a hope
		   that instruction re-execution will regenerate lost
		   exception */
		goto queue;
	}
<blue>}</blue>

void kvm_queue_exception(struct kvm_vcpu *vcpu, unsigned nr)
{
<blue>	kvm_multiple_exception(vcpu, nr, false, 0, false, 0, false);</blue>
}
EXPORT_SYMBOL_GPL(kvm_queue_exception);

void kvm_requeue_exception(struct kvm_vcpu *vcpu, unsigned nr)
{
<blue>	kvm_multiple_exception(vcpu, nr, false, 0, false, 0, true);</blue>
}
EXPORT_SYMBOL_GPL(kvm_requeue_exception);

void kvm_queue_exception_p(struct kvm_vcpu *vcpu, unsigned nr,
			   unsigned long payload)
{
<blue>	kvm_multiple_exception(vcpu, nr, false, 0, true, payload, false);</blue>
}
EXPORT_SYMBOL_GPL(kvm_queue_exception_p);

static void kvm_queue_exception_e_p(struct kvm_vcpu *vcpu, unsigned nr,
				    u32 error_code, unsigned long payload)
{
	kvm_multiple_exception(vcpu, nr, true, error_code,
			       true, payload, false);
}

<blue>int kvm_complete_insn_gp(struct kvm_vcpu *vcpu, int err)</blue>
{
<blue>	if (err)</blue>
<blue>		kvm_inject_gp(vcpu, 0);</blue>
	else
<blue>		return kvm_skip_emulated_instruction(vcpu);</blue>

	return 1;
<blue>}</blue>
EXPORT_SYMBOL_GPL(kvm_complete_insn_gp);

static int complete_emulated_insn_gp(struct kvm_vcpu *vcpu, int err)
{
	if (err) {
<yellow>		kvm_inject_gp(vcpu, 0);</yellow>
		return 1;
	}

<yellow>	return kvm_emulate_instruction(vcpu, EMULTYPE_NO_DECODE | EMULTYPE_SKIP |</yellow>
				       EMULTYPE_COMPLETE_USER_EXIT);
}

void kvm_inject_page_fault(struct kvm_vcpu *vcpu, struct x86_exception *fault)
{
<blue>	++vcpu->stat.pf_guest;</blue>

	/*
	 * Async #PF in L2 is always forwarded to L1 as a VM-Exit regardless of
	 * whether or not L1 wants to intercept &quot;regular&quot; #PF.
	 */
<blue>	if (is_guest_mode(vcpu) && fault->async_page_fault)</blue>
		kvm_queue_exception_vmexit(vcpu, PF_VECTOR,
<yellow>					   true, fault->error_code,</yellow>
					   true, fault-&gt;address);
	else
		kvm_queue_exception_e_p(vcpu, PF_VECTOR, fault-&gt;error_code,
					fault-&gt;address);
<blue>}</blue>
EXPORT_SYMBOL_GPL(kvm_inject_page_fault);

void kvm_inject_emulated_page_fault(struct kvm_vcpu *vcpu,
				    struct x86_exception *fault)
{
	struct kvm_mmu *fault_mmu;
<blue>	WARN_ON_ONCE(fault->vector != PF_VECTOR);</blue>

<blue>	fault_mmu = fault->nested_page_fault ? vcpu->arch.mmu :</blue>
					       vcpu-&gt;arch.walk_mmu;

	/*
	 * Invalidate the TLB entry for the faulting address, if it exists,
	 * else the access will fault indefinitely (and to emulate hardware).
	 */
<blue>	if ((fault->error_code & PFERR_PRESENT_MASK) &&</blue>
	    !(fault-&gt;error_code &amp; PFERR_RSVD_MASK))
<yellow>		kvm_mmu_invalidate_gva(vcpu, fault_mmu, fault->address,</yellow>
				       fault_mmu-&gt;root.hpa);

<blue>	fault_mmu->inject_page_fault(vcpu, fault);</blue>
}
EXPORT_SYMBOL_GPL(kvm_inject_emulated_page_fault);

void kvm_inject_nmi(struct kvm_vcpu *vcpu)
{
<yellow>	atomic_inc(&vcpu->arch.nmi_queued);</yellow>
	kvm_make_request(KVM_REQ_NMI, vcpu);
}
EXPORT_SYMBOL_GPL(kvm_inject_nmi);

void kvm_queue_exception_e(struct kvm_vcpu *vcpu, unsigned nr, u32 error_code)
{
<blue>	kvm_multiple_exception(vcpu, nr, true, error_code, false, 0, false);</blue>
}
EXPORT_SYMBOL_GPL(kvm_queue_exception_e);

void kvm_requeue_exception_e(struct kvm_vcpu *vcpu, unsigned nr, u32 error_code)
{
<blue>	kvm_multiple_exception(vcpu, nr, true, error_code, false, 0, true);</blue>
}
EXPORT_SYMBOL_GPL(kvm_requeue_exception_e);

/*
 * Checks if cpl &lt;= required_cpl; if true, return true.  Otherwise queue
 * a #GP and return false.
 */
<yellow>bool kvm_require_cpl(struct kvm_vcpu *vcpu, int required_cpl)</yellow>
{
<yellow>	if (static_call(kvm_x86_get_cpl)(vcpu) <= required_cpl)</yellow>
		return true;
<yellow>	kvm_queue_exception_e(vcpu, GP_VECTOR, 0);</yellow>
	return false;
<yellow>}</yellow>
EXPORT_SYMBOL_GPL(kvm_require_cpl);

bool kvm_require_dr(struct kvm_vcpu *vcpu, int dr)
{
<blue>	if ((dr != 4 && dr != 5) || !kvm_read_cr4_bits(vcpu, X86_CR4_DE))</blue>
		return true;

<yellow>	kvm_queue_exception(vcpu, UD_VECTOR);</yellow>
	return false;
<blue>}</blue>
EXPORT_SYMBOL_GPL(kvm_require_dr);

static inline u64 pdptr_rsvd_bits(struct kvm_vcpu *vcpu)
{
	return vcpu-&gt;arch.reserved_gpa_bits | rsvd_bits(5, 8) | rsvd_bits(1, 2);
}

/*
 * Load the pae pdptrs.  Return 1 if they are all valid, 0 otherwise.
 */
int load_pdptrs(struct kvm_vcpu *vcpu, unsigned long cr3)
<blue>{</blue>
<blue>	struct kvm_mmu *mmu = vcpu->arch.walk_mmu;</blue>
	gfn_t pdpt_gfn = cr3 &gt;&gt; PAGE_SHIFT;
	gpa_t real_gpa;
	int i;
	int ret;
	u64 pdpte[ARRAY_SIZE(mmu-&gt;pdptrs)];

	/*
	 * If the MMU is nested, CR3 holds an L2 GPA and needs to be translated
	 * to an L1 GPA.
	 */
<yellow>	real_gpa = kvm_translate_gpa(vcpu, mmu, gfn_to_gpa(pdpt_gfn),</yellow>
				     PFERR_USER_MASK | PFERR_WRITE_MASK, NULL);
	if (real_gpa == INVALID_GPA)
		return 0;

	/* Note the offset, PDPTRs are 32 byte aligned when using PAE paging. */
<blue>	ret = kvm_vcpu_read_guest_page(vcpu, gpa_to_gfn(real_gpa), pdpte,</blue>
				       cr3 &amp; GENMASK(11, 5), sizeof(pdpte));
	if (ret &lt; 0)
		return 0;

<yellow>	for (i = 0; i < ARRAY_SIZE(pdpte); ++i) {</yellow>
<blue>		if ((pdpte[i] & PT_PRESENT_MASK) &&</blue>
<blue>		    (pdpte[i] & pdptr_rsvd_bits(vcpu))) {</blue>
			return 0;
		}
	}

	/*
	 * Marking VCPU_EXREG_PDPTR dirty doesn&#x27;t work for !tdp_enabled.
	 * Shadow page roots need to be reconstructed instead.
	 */
<yellow>	if (!tdp_enabled && memcmp(mmu->pdptrs, pdpte, sizeof(mmu->pdptrs)))</yellow>
<yellow>		kvm_mmu_free_roots(vcpu->kvm, mmu, KVM_MMU_ROOT_CURRENT);</yellow>

<yellow>	memcpy(mmu->pdptrs, pdpte, sizeof(mmu->pdptrs));</yellow>
	kvm_register_mark_dirty(vcpu, VCPU_EXREG_PDPTR);
	kvm_make_request(KVM_REQ_LOAD_MMU_PGD, vcpu);
	vcpu-&gt;arch.pdptrs_from_userspace = false;

	return 1;
}
EXPORT_SYMBOL_GPL(load_pdptrs);

void kvm_post_set_cr0(struct kvm_vcpu *vcpu, unsigned long old_cr0, unsigned long cr0)
{
<blue>	if ((cr0 ^ old_cr0) & X86_CR0_PG) {</blue>
<blue>		kvm_clear_async_pf_completion_queue(vcpu);</blue>
<blue>		kvm_async_pf_hash_reset(vcpu);</blue>

		/*
		 * Clearing CR0.PG is defined to flush the TLB from the guest&#x27;s
		 * perspective.
		 */
<blue>		if (!(cr0 & X86_CR0_PG))</blue>
<yellow>			kvm_make_request(KVM_REQ_TLB_FLUSH_GUEST, vcpu);</yellow>
	}

<blue>	if ((cr0 ^ old_cr0) & KVM_MMU_CR0_ROLE_BITS)</blue>
<blue>		kvm_mmu_reset_context(vcpu);</blue>

<blue>	if (((cr0 ^ old_cr0) & X86_CR0_CD) &&</blue>
<blue>	    kvm_arch_has_noncoherent_dma(vcpu->kvm) &&</blue>
<yellow>	    !kvm_check_has_quirk(vcpu->kvm, KVM_X86_QUIRK_CD_NW_CLEARED))</yellow>
<yellow>		kvm_zap_gfn_range(vcpu->kvm, 0, ~0ULL);</yellow>
<blue>}</blue>
EXPORT_SYMBOL_GPL(kvm_post_set_cr0);

int kvm_set_cr0(struct kvm_vcpu *vcpu, unsigned long cr0)
<blue>{</blue>
<blue>	unsigned long old_cr0 = kvm_read_cr0(vcpu);</blue>

	cr0 |= X86_CR0_ET;

#ifdef CONFIG_X86_64
	if (cr0 &amp; 0xffffffff00000000UL)
		return 1;
#endif

	cr0 &amp;= ~CR0_RESERVED_BITS;

<blue>	if ((cr0 & X86_CR0_NW) && !(cr0 & X86_CR0_CD))</blue>
		return 1;

<blue>	if ((cr0 & X86_CR0_PG) && !(cr0 & X86_CR0_PE))</blue>
		return 1;

#ifdef CONFIG_X86_64
<blue>	if ((vcpu->arch.efer & EFER_LME) && !is_paging(vcpu) &&</blue>
	    (cr0 &amp; X86_CR0_PG)) {
		int cs_db, cs_l;

<blue>		if (!is_pae(vcpu))</blue>
<yellow>			return 1;</yellow>
<blue>		static_call(kvm_x86_get_cs_db_l_bits)(vcpu, &cs_db, &cs_l);</blue>
		if (cs_l)
			return 1;
	}
#endif
<blue>	if (!(vcpu->arch.efer & EFER_LME) && (cr0 & X86_CR0_PG) &&</blue>
<yellow>	    is_pae(vcpu) && ((cr0 ^ old_cr0) & X86_CR0_PDPTR_BITS) &&</yellow>
<yellow>	    !load_pdptrs(vcpu, kvm_read_cr3(vcpu)))</yellow>
		return 1;

<blue>	if (!(cr0 & X86_CR0_PG) &&</blue>
<blue>	    (is_64_bit_mode(vcpu) || kvm_read_cr4_bits(vcpu, X86_CR4_PCIDE)))</blue>
		return 1;

<blue>	static_call(kvm_x86_set_cr0)(vcpu, cr0);</blue>

	kvm_post_set_cr0(vcpu, old_cr0, cr0);

	return 0;
}
EXPORT_SYMBOL_GPL(kvm_set_cr0);

void kvm_lmsw(struct kvm_vcpu *vcpu, unsigned long msw)
{
<yellow>	(void)kvm_set_cr0(vcpu, kvm_read_cr0_bits(vcpu, ~0x0eul) | (msw & 0x0f));</yellow>
}
EXPORT_SYMBOL_GPL(kvm_lmsw);

<blue>void kvm_load_guest_xsave_state(struct kvm_vcpu *vcpu)</blue>
{
<blue>	if (vcpu->arch.guest_state_protected)</blue>
		return;

<blue>	if (kvm_read_cr4_bits(vcpu, X86_CR4_OSXSAVE)) {</blue>

<blue>		if (vcpu->arch.xcr0 != host_xcr0)</blue>
<blue>			xsetbv(XCR_XFEATURE_ENABLED_MASK, vcpu->arch.xcr0);</blue>

<blue>		if (vcpu->arch.xsaves_enabled &&</blue>
<blue>		    vcpu->arch.ia32_xss != host_xss)</blue>
<blue>			wrmsrl(MSR_IA32_XSS, vcpu->arch.ia32_xss);</blue>
	}

#ifdef CONFIG_X86_INTEL_MEMORY_PROTECTION_KEYS
<blue>	if (static_cpu_has(X86_FEATURE_PKU) &&</blue>
<blue>	    vcpu->arch.pkru != vcpu->arch.host_pkru &&</blue>
<blue>	    ((vcpu->arch.xcr0 & XFEATURE_MASK_PKRU) ||</blue>
<blue>	     kvm_read_cr4_bits(vcpu, X86_CR4_PKE)))</blue>
<blue>		write_pkru(vcpu->arch.pkru);</blue>
#endif /* CONFIG_X86_INTEL_MEMORY_PROTECTION_KEYS */
<blue>}</blue>
EXPORT_SYMBOL_GPL(kvm_load_guest_xsave_state);

<blue>void kvm_load_host_xsave_state(struct kvm_vcpu *vcpu)</blue>
{
<blue>	if (vcpu->arch.guest_state_protected)</blue>
		return;

#ifdef CONFIG_X86_INTEL_MEMORY_PROTECTION_KEYS
<blue>	if (static_cpu_has(X86_FEATURE_PKU) &&</blue>
<blue>	    ((vcpu->arch.xcr0 & XFEATURE_MASK_PKRU) ||</blue>
<blue>	     kvm_read_cr4_bits(vcpu, X86_CR4_PKE))) {</blue>
<blue>		vcpu->arch.pkru = rdpkru();</blue>
		if (vcpu-&gt;arch.pkru != vcpu-&gt;arch.host_pkru)
<blue>			write_pkru(vcpu->arch.host_pkru);</blue>
	}
#endif /* CONFIG_X86_INTEL_MEMORY_PROTECTION_KEYS */

<blue>	if (kvm_read_cr4_bits(vcpu, X86_CR4_OSXSAVE)) {</blue>

<blue>		if (vcpu->arch.xcr0 != host_xcr0)</blue>
<blue>			xsetbv(XCR_XFEATURE_ENABLED_MASK, host_xcr0);</blue>

<blue>		if (vcpu->arch.xsaves_enabled &&</blue>
<blue>		    vcpu->arch.ia32_xss != host_xss)</blue>
<blue>			wrmsrl(MSR_IA32_XSS, host_xss);</blue>
	}

<blue>}</blue>
EXPORT_SYMBOL_GPL(kvm_load_host_xsave_state);

#ifdef CONFIG_X86_64
static inline u64 kvm_guest_supported_xfd(struct kvm_vcpu *vcpu)
{
<yellow>	return vcpu->arch.guest_supported_xcr0 & XFEATURE_MASK_USER_DYNAMIC;</yellow>
}
#endif

static int __kvm_set_xcr(struct kvm_vcpu *vcpu, u32 index, u64 xcr)
{
	u64 xcr0 = xcr;
<blue>	u64 old_xcr0 = vcpu->arch.xcr0;</blue>
	u64 valid_bits;

	/* Only support XCR_XFEATURE_ENABLED_MASK(xcr0) now  */
<blue>	if (index != XCR_XFEATURE_ENABLED_MASK)</blue>
		return 1;
<blue>	if (!(xcr0 & XFEATURE_MASK_FP))</blue>
		return 1;
<blue>	if ((xcr0 & XFEATURE_MASK_YMM) && !(xcr0 & XFEATURE_MASK_SSE))</blue>
		return 1;

	/*
	 * Do not allow the guest to set bits that we do not support
	 * saving.  However, xcr0 bit 0 is always set, even if the
	 * emulated CPU does not support XSAVE (see kvm_vcpu_reset()).
	 */
<blue>	valid_bits = vcpu->arch.guest_supported_xcr0 | XFEATURE_MASK_FP;</blue>
	if (xcr0 &amp; ~valid_bits)
		return 1;

<blue>	if ((!(xcr0 & XFEATURE_MASK_BNDREGS)) !=</blue>
	    (!(xcr0 &amp; XFEATURE_MASK_BNDCSR)))
		return 1;

<blue>	if (xcr0 & XFEATURE_MASK_AVX512) {</blue>
<yellow>		if (!(xcr0 & XFEATURE_MASK_YMM))</yellow>
			return 1;
<yellow>		if ((xcr0 & XFEATURE_MASK_AVX512) != XFEATURE_MASK_AVX512)</yellow>
			return 1;
	}

<blue>	if ((xcr0 & XFEATURE_MASK_XTILE) &&</blue>
	    ((xcr0 &amp; XFEATURE_MASK_XTILE) != XFEATURE_MASK_XTILE))
		return 1;

	vcpu-&gt;arch.xcr0 = xcr0;

	if ((xcr0 ^ old_xcr0) &amp; XFEATURE_MASK_EXTEND)
<yellow>		kvm_update_cpuid_runtime(vcpu);</yellow>
	return 0;
<blue>}</blue>

int kvm_emulate_xsetbv(struct kvm_vcpu *vcpu)
{
	/* Note, #UD due to CR4.OSXSAVE=0 has priority over the intercept. */
<yellow>	if (static_call(kvm_x86_get_cpl)(vcpu) != 0 ||</yellow>
<yellow>	    __kvm_set_xcr(vcpu, kvm_rcx_read(vcpu), kvm_read_edx_eax(vcpu))) {</yellow>
<yellow>		kvm_inject_gp(vcpu, 0);</yellow>
		return 1;
	}

<yellow>	return kvm_skip_emulated_instruction(vcpu);</yellow>
<yellow>}</yellow>
EXPORT_SYMBOL_GPL(kvm_emulate_xsetbv);

bool __kvm_is_valid_cr4(struct kvm_vcpu *vcpu, unsigned long cr4)
{
<blue>	if (cr4 & cr4_reserved_bits)</blue>
		return false;

<blue>	if (cr4 & vcpu->arch.cr4_guest_rsvd_bits)</blue>
		return false;

	return true;
<blue>}</blue>
EXPORT_SYMBOL_GPL(__kvm_is_valid_cr4);

static bool kvm_is_valid_cr4(struct kvm_vcpu *vcpu, unsigned long cr4)
{
<blue>	return __kvm_is_valid_cr4(vcpu, cr4) &&</blue>
<blue>	       static_call(kvm_x86_is_valid_cr4)(vcpu, cr4);</blue>
}

void kvm_post_set_cr4(struct kvm_vcpu *vcpu, unsigned long old_cr4, unsigned long cr4)
{
<blue>	if ((cr4 ^ old_cr4) & KVM_MMU_CR4_ROLE_BITS)</blue>
<blue>		kvm_mmu_reset_context(vcpu);</blue>

	/*
	 * If CR4.PCIDE is changed 0 -&gt; 1, there is no need to flush the TLB
	 * according to the SDM; however, stale prev_roots could be reused
	 * incorrectly in the future after a MOV to CR3 with NOFLUSH=1, so we
	 * free them all.  This is *not* a superset of KVM_REQ_TLB_FLUSH_GUEST
	 * or KVM_REQ_TLB_FLUSH_CURRENT, because the hardware TLB is not flushed,
	 * so fall through.
	 */
<blue>	if (!tdp_enabled &&</blue>
<yellow>	    (cr4 & X86_CR4_PCIDE) && !(old_cr4 & X86_CR4_PCIDE))</yellow>
<yellow>		kvm_mmu_unload(vcpu);</yellow>

	/*
	 * The TLB has to be flushed for all PCIDs if any of the following
	 * (architecturally required) changes happen:
	 * - CR4.PCIDE is changed from 1 to 0
	 * - CR4.PGE is toggled
	 *
	 * This is a superset of KVM_REQ_TLB_FLUSH_CURRENT.
	 */
<blue>	if (((cr4 ^ old_cr4) & X86_CR4_PGE) ||</blue>
<blue>	    (!(cr4 & X86_CR4_PCIDE) && (old_cr4 & X86_CR4_PCIDE)))</blue>
<yellow>		kvm_make_request(KVM_REQ_TLB_FLUSH_GUEST, vcpu);</yellow>

	/*
	 * The TLB has to be flushed for the current PCID if any of the
	 * following (architecturally required) changes happen:
	 * - CR4.SMEP is changed from 0 to 1
	 * - CR4.PAE is toggled
	 */
<blue>	else if (((cr4 ^ old_cr4) & X86_CR4_PAE) ||</blue>
<blue>		 ((cr4 & X86_CR4_SMEP) && !(old_cr4 & X86_CR4_SMEP)))</blue>
<blue>		kvm_make_request(KVM_REQ_TLB_FLUSH_CURRENT, vcpu);</blue>

<blue>}</blue>
EXPORT_SYMBOL_GPL(kvm_post_set_cr4);

int kvm_set_cr4(struct kvm_vcpu *vcpu, unsigned long cr4)
{
<blue>	unsigned long old_cr4 = kvm_read_cr4(vcpu);</blue>

<blue>	if (!kvm_is_valid_cr4(vcpu, cr4))</blue>
		return 1;

<blue>	if (is_long_mode(vcpu)) {</blue>
<blue>		if (!(cr4 & X86_CR4_PAE))</blue>
			return 1;
<blue>		if ((cr4 ^ old_cr4) & X86_CR4_LA57)</blue>
			return 1;
<blue>	} else if (is_paging(vcpu) && (cr4 & X86_CR4_PAE)</blue>
<yellow>		   && ((cr4 ^ old_cr4) & X86_CR4_PDPTR_BITS)</yellow>
<yellow>		   && !load_pdptrs(vcpu, kvm_read_cr3(vcpu)))</yellow>
		return 1;

<blue>	if ((cr4 & X86_CR4_PCIDE) && !(old_cr4 & X86_CR4_PCIDE)) {</blue>
<yellow>		if (!guest_cpuid_has(vcpu, X86_FEATURE_PCID))</yellow>
			return 1;

		/* PCID can not be enabled when cr3[11:0]!=000H or EFER.LMA=0 */
<yellow>		if ((kvm_read_cr3(vcpu) & X86_CR3_PCID_MASK) || !is_long_mode(vcpu))</yellow>
			return 1;
	}

<blue>	static_call(kvm_x86_set_cr4)(vcpu, cr4);</blue>

	kvm_post_set_cr4(vcpu, old_cr4, cr4);

	return 0;
<blue>}</blue>
EXPORT_SYMBOL_GPL(kvm_set_cr4);

static void kvm_invalidate_pcid(struct kvm_vcpu *vcpu, unsigned long pcid)
{
<yellow>	struct kvm_mmu *mmu = vcpu->arch.mmu;</yellow>
	unsigned long roots_to_free = 0;
	int i;

	/*
	 * MOV CR3 and INVPCID are usually not intercepted when using TDP, but
	 * this is reachable when running EPT=1 and unrestricted_guest=0,  and
	 * also via the emulator.  KVM&#x27;s TDP page tables are not in the scope of
	 * the invalidation, but the guest&#x27;s TLB entries need to be flushed as
	 * the CPU may have cached entries in its TLB for the target PCID.
	 */
<yellow>	if (unlikely(tdp_enabled)) {</yellow>
<yellow>		kvm_make_request(KVM_REQ_TLB_FLUSH_GUEST, vcpu);</yellow>
		return;
	}

	/*
	 * If neither the current CR3 nor any of the prev_roots use the given
	 * PCID, then nothing needs to be done here because a resync will
	 * happen anyway before switching to any other CR3.
	 */
<yellow>	if (kvm_get_active_pcid(vcpu) == pcid) {</yellow>
<yellow>		kvm_make_request(KVM_REQ_MMU_SYNC, vcpu);</yellow>
		kvm_make_request(KVM_REQ_TLB_FLUSH_CURRENT, vcpu);
	}

	/*
	 * If PCID is disabled, there is no need to free prev_roots even if the
	 * PCIDs for them are also 0, because MOV to CR3 always flushes the TLB
	 * with PCIDE=0.
	 */
<yellow>	if (!kvm_read_cr4_bits(vcpu, X86_CR4_PCIDE))</yellow>
		return;

<yellow>	for (i = 0; i < KVM_MMU_NUM_PREV_ROOTS; i++)</yellow>
<yellow>		if (kvm_get_pcid(vcpu, mmu->prev_roots[i].pgd) == pcid)</yellow>
<yellow>			roots_to_free |= KVM_MMU_ROOT_PREVIOUS(i);</yellow>

<yellow>	kvm_mmu_free_roots(vcpu->kvm, mmu, roots_to_free);</yellow>
<yellow>}</yellow>

int kvm_set_cr3(struct kvm_vcpu *vcpu, unsigned long cr3)
{
	bool skip_tlb_flush = false;
	unsigned long pcid = 0;
#ifdef CONFIG_X86_64
<yellow>	bool pcid_enabled = kvm_read_cr4_bits(vcpu, X86_CR4_PCIDE);</yellow>

	if (pcid_enabled) {
<yellow>		skip_tlb_flush = cr3 & X86_CR3_PCID_NOFLUSH;</yellow>
		cr3 &amp;= ~X86_CR3_PCID_NOFLUSH;
		pcid = cr3 &amp; X86_CR3_PCID_MASK;
	}
#endif

	/* PDPTRs are always reloaded for PAE paging. */
<yellow>	if (cr3 == kvm_read_cr3(vcpu) && !is_pae_paging(vcpu))</yellow>
		goto handle_tlb_flush;

	/*
	 * Do not condition the GPA check on long mode, this helper is used to
	 * stuff CR3, e.g. for RSM emulation, and there is no guarantee that
	 * the current vCPU mode is accurate.
	 */
<yellow>	if (kvm_vcpu_is_illegal_gpa(vcpu, cr3))</yellow>
		return 1;

<yellow>	if (is_pae_paging(vcpu) && !load_pdptrs(vcpu, cr3))</yellow>
		return 1;

<yellow>	if (cr3 != kvm_read_cr3(vcpu))</yellow>
<yellow>		kvm_mmu_new_pgd(vcpu, cr3);</yellow>

<yellow>	vcpu->arch.cr3 = cr3;</yellow>
	kvm_register_mark_dirty(vcpu, VCPU_EXREG_CR3);
	/* Do not call post_set_cr3, we do not get here for confidential guests.  */

handle_tlb_flush:
	/*
	 * A load of CR3 that flushes the TLB flushes only the current PCID,
	 * even if PCID is disabled, in which case PCID=0 is flushed.  It&#x27;s a
	 * moot point in the end because _disabling_ PCID will flush all PCIDs,
	 * and it&#x27;s impossible to use a non-zero PCID when PCID is disabled,
	 * i.e. only PCID=0 can be relevant.
	 */
<yellow>	if (!skip_tlb_flush)</yellow>
<yellow>		kvm_invalidate_pcid(vcpu, pcid);</yellow>

	return 0;
<yellow>}</yellow>
EXPORT_SYMBOL_GPL(kvm_set_cr3);

<blue>int kvm_set_cr8(struct kvm_vcpu *vcpu, unsigned long cr8)</blue>
{
<blue>	if (cr8 & CR8_RESERVED_BITS)</blue>
		return 1;
<blue>	if (lapic_in_kernel(vcpu))</blue>
<blue>		kvm_lapic_set_tpr(vcpu, cr8);</blue>
	else
<yellow>		vcpu->arch.cr8 = cr8;</yellow>
	return 0;
<blue>}</blue>
EXPORT_SYMBOL_GPL(kvm_set_cr8);

unsigned long kvm_get_cr8(struct kvm_vcpu *vcpu)
{
<blue>	if (lapic_in_kernel(vcpu))</blue>
<blue>		return kvm_lapic_get_cr8(vcpu);</blue>
	else
<yellow>		return vcpu->arch.cr8;</yellow>
<blue>}</blue>
EXPORT_SYMBOL_GPL(kvm_get_cr8);

<blue>static void kvm_update_dr0123(struct kvm_vcpu *vcpu)</blue>
{
	int i;

	if (!(vcpu-&gt;guest_debug &amp; KVM_GUESTDBG_USE_HW_BP)) {
		for (i = 0; i &lt; KVM_NR_DB_REGS; i++)
<blue>			vcpu->arch.eff_db[i] = vcpu->arch.db[i];</blue>
	}
}

void kvm_update_dr7(struct kvm_vcpu *vcpu)
{
	unsigned long dr7;

<blue>	if (vcpu->guest_debug & KVM_GUESTDBG_USE_HW_BP)</blue>
<yellow>		dr7 = vcpu->arch.guest_debug_dr7;</yellow>
	else
<yellow>		dr7 = vcpu->arch.dr7;</yellow>
<blue>	static_call(kvm_x86_set_dr7)(vcpu, dr7);</blue>
<blue>	vcpu->arch.switch_db_regs &= ~KVM_DEBUGREG_BP_ENABLED;</blue>
	if (dr7 &amp; DR7_BP_EN_MASK)
<blue>		vcpu->arch.switch_db_regs |= KVM_DEBUGREG_BP_ENABLED;</blue>
<yellow>}</yellow>
EXPORT_SYMBOL_GPL(kvm_update_dr7);

static u64 kvm_dr6_fixed(struct kvm_vcpu *vcpu)
{
	u64 fixed = DR6_FIXED_1;

<yellow>	if (!guest_cpuid_has(vcpu, X86_FEATURE_RTM))</yellow>
		fixed |= DR6_RTM;

<yellow>	if (!guest_cpuid_has(vcpu, X86_FEATURE_BUS_LOCK_DETECT))</yellow>
<yellow>		fixed |= DR6_BUS_LOCK;</yellow>
	return fixed;
}

int kvm_set_dr(struct kvm_vcpu *vcpu, int dr, unsigned long val)
{
	size_t size = ARRAY_SIZE(vcpu-&gt;arch.db);

<blue>	switch (dr) {</blue>
	case 0 ... 3:
<yellow>		vcpu->arch.db[array_index_nospec(dr, size)] = val;</yellow>
		if (!(vcpu-&gt;guest_debug &amp; KVM_GUESTDBG_USE_HW_BP))
<yellow>			vcpu->arch.eff_db[dr] = val;</yellow>
		break;
	case 4:
	case 6:
<yellow>		if (!kvm_dr6_valid(val))</yellow>
			return 1; /* #GP */
<yellow>		vcpu->arch.dr6 = (val & DR6_VOLATILE) | kvm_dr6_fixed(vcpu);</yellow>
		break;
	case 5:
	default: /* 7 */
<blue>		if (!kvm_dr7_valid(val))</blue>
			return 1; /* #GP */
<blue>		vcpu->arch.dr7 = (val & DR7_VOLATILE) | DR7_FIXED_1;</blue>
<blue>		kvm_update_dr7(vcpu);</blue>
		break;
	}

	return 0;
<blue>}</blue>
EXPORT_SYMBOL_GPL(kvm_set_dr);

<blue>void kvm_get_dr(struct kvm_vcpu *vcpu, int dr, unsigned long *val)</blue>
{
	size_t size = ARRAY_SIZE(vcpu-&gt;arch.db);

<blue>	switch (dr) {</blue>
	case 0 ... 3:
<blue>		*val = vcpu->arch.db[array_index_nospec(dr, size)];</blue>
		break;
	case 4:
	case 6:
<yellow>		*val = vcpu->arch.dr6;</yellow>
		break;
	case 5:
	default: /* 7 */
<blue>		*val = vcpu->arch.dr7;</blue>
		break;
	}
}
EXPORT_SYMBOL_GPL(kvm_get_dr);

<blue>int kvm_emulate_rdpmc(struct kvm_vcpu *vcpu)</blue>
<blue>{</blue>
<blue>	u32 ecx = kvm_rcx_read(vcpu);</blue>
	u64 data;

	if (kvm_pmu_rdpmc(vcpu, ecx, &amp;data)) {
<blue>		kvm_inject_gp(vcpu, 0);</blue>
		return 1;
	}

<yellow>	kvm_rax_write(vcpu, (u32)data);</yellow>
	kvm_rdx_write(vcpu, data &gt;&gt; 32);
<yellow>	return kvm_skip_emulated_instruction(vcpu);</yellow>
}
EXPORT_SYMBOL_GPL(kvm_emulate_rdpmc);

/*
 * List of msr numbers which we expose to userspace through KVM_GET_MSRS
 * and KVM_SET_MSRS, and KVM_GET_MSR_INDEX_LIST.
 *
 * The three MSR lists(msrs_to_save, emulated_msrs, msr_based_features)
 * extract the supported MSRs from the related const lists.
 * msrs_to_save is selected from the msrs_to_save_all to reflect the
 * capabilities of the host cpu. This capabilities test skips MSRs that are
 * kvm-specific. Those are put in emulated_msrs_all; filtering of emulated_msrs
 * may depend on host virtualization features rather than host cpu features.
 */

static const u32 msrs_to_save_all[] = {
	MSR_IA32_SYSENTER_CS, MSR_IA32_SYSENTER_ESP, MSR_IA32_SYSENTER_EIP,
	MSR_STAR,
#ifdef CONFIG_X86_64
	MSR_CSTAR, MSR_KERNEL_GS_BASE, MSR_SYSCALL_MASK, MSR_LSTAR,
#endif
	MSR_IA32_TSC, MSR_IA32_CR_PAT, MSR_VM_HSAVE_PA,
	MSR_IA32_FEAT_CTL, MSR_IA32_BNDCFGS, MSR_TSC_AUX,
	MSR_IA32_SPEC_CTRL,
	MSR_IA32_RTIT_CTL, MSR_IA32_RTIT_STATUS, MSR_IA32_RTIT_CR3_MATCH,
	MSR_IA32_RTIT_OUTPUT_BASE, MSR_IA32_RTIT_OUTPUT_MASK,
	MSR_IA32_RTIT_ADDR0_A, MSR_IA32_RTIT_ADDR0_B,
	MSR_IA32_RTIT_ADDR1_A, MSR_IA32_RTIT_ADDR1_B,
	MSR_IA32_RTIT_ADDR2_A, MSR_IA32_RTIT_ADDR2_B,
	MSR_IA32_RTIT_ADDR3_A, MSR_IA32_RTIT_ADDR3_B,
	MSR_IA32_UMWAIT_CONTROL,

	MSR_ARCH_PERFMON_FIXED_CTR0, MSR_ARCH_PERFMON_FIXED_CTR1,
	MSR_ARCH_PERFMON_FIXED_CTR0 + 2,
	MSR_CORE_PERF_FIXED_CTR_CTRL, MSR_CORE_PERF_GLOBAL_STATUS,
	MSR_CORE_PERF_GLOBAL_CTRL, MSR_CORE_PERF_GLOBAL_OVF_CTRL,
	MSR_IA32_PEBS_ENABLE, MSR_IA32_DS_AREA, MSR_PEBS_DATA_CFG,

	/* This part of MSRs should match KVM_INTEL_PMC_MAX_GENERIC. */
	MSR_ARCH_PERFMON_PERFCTR0, MSR_ARCH_PERFMON_PERFCTR1,
	MSR_ARCH_PERFMON_PERFCTR0 + 2, MSR_ARCH_PERFMON_PERFCTR0 + 3,
	MSR_ARCH_PERFMON_PERFCTR0 + 4, MSR_ARCH_PERFMON_PERFCTR0 + 5,
	MSR_ARCH_PERFMON_PERFCTR0 + 6, MSR_ARCH_PERFMON_PERFCTR0 + 7,
	MSR_ARCH_PERFMON_EVENTSEL0, MSR_ARCH_PERFMON_EVENTSEL1,
	MSR_ARCH_PERFMON_EVENTSEL0 + 2, MSR_ARCH_PERFMON_EVENTSEL0 + 3,
	MSR_ARCH_PERFMON_EVENTSEL0 + 4, MSR_ARCH_PERFMON_EVENTSEL0 + 5,
	MSR_ARCH_PERFMON_EVENTSEL0 + 6, MSR_ARCH_PERFMON_EVENTSEL0 + 7,

	MSR_K7_EVNTSEL0, MSR_K7_EVNTSEL1, MSR_K7_EVNTSEL2, MSR_K7_EVNTSEL3,
	MSR_K7_PERFCTR0, MSR_K7_PERFCTR1, MSR_K7_PERFCTR2, MSR_K7_PERFCTR3,

	/* This part of MSRs should match KVM_AMD_PMC_MAX_GENERIC. */
	MSR_F15H_PERF_CTL0, MSR_F15H_PERF_CTL1, MSR_F15H_PERF_CTL2,
	MSR_F15H_PERF_CTL3, MSR_F15H_PERF_CTL4, MSR_F15H_PERF_CTL5,
	MSR_F15H_PERF_CTR0, MSR_F15H_PERF_CTR1, MSR_F15H_PERF_CTR2,
	MSR_F15H_PERF_CTR3, MSR_F15H_PERF_CTR4, MSR_F15H_PERF_CTR5,

	MSR_IA32_XFD, MSR_IA32_XFD_ERR,
};

static u32 msrs_to_save[ARRAY_SIZE(msrs_to_save_all)];
static unsigned num_msrs_to_save;

static const u32 emulated_msrs_all[] = {
	MSR_KVM_SYSTEM_TIME, MSR_KVM_WALL_CLOCK,
	MSR_KVM_SYSTEM_TIME_NEW, MSR_KVM_WALL_CLOCK_NEW,
	HV_X64_MSR_GUEST_OS_ID, HV_X64_MSR_HYPERCALL,
	HV_X64_MSR_TIME_REF_COUNT, HV_X64_MSR_REFERENCE_TSC,
	HV_X64_MSR_TSC_FREQUENCY, HV_X64_MSR_APIC_FREQUENCY,
	HV_X64_MSR_CRASH_P0, HV_X64_MSR_CRASH_P1, HV_X64_MSR_CRASH_P2,
	HV_X64_MSR_CRASH_P3, HV_X64_MSR_CRASH_P4, HV_X64_MSR_CRASH_CTL,
	HV_X64_MSR_RESET,
	HV_X64_MSR_VP_INDEX,
	HV_X64_MSR_VP_RUNTIME,
	HV_X64_MSR_SCONTROL,
	HV_X64_MSR_STIMER0_CONFIG,
	HV_X64_MSR_VP_ASSIST_PAGE,
	HV_X64_MSR_REENLIGHTENMENT_CONTROL, HV_X64_MSR_TSC_EMULATION_CONTROL,
	HV_X64_MSR_TSC_EMULATION_STATUS,
	HV_X64_MSR_SYNDBG_OPTIONS,
	HV_X64_MSR_SYNDBG_CONTROL, HV_X64_MSR_SYNDBG_STATUS,
	HV_X64_MSR_SYNDBG_SEND_BUFFER, HV_X64_MSR_SYNDBG_RECV_BUFFER,
	HV_X64_MSR_SYNDBG_PENDING_BUFFER,

	MSR_KVM_ASYNC_PF_EN, MSR_KVM_STEAL_TIME,
	MSR_KVM_PV_EOI_EN, MSR_KVM_ASYNC_PF_INT, MSR_KVM_ASYNC_PF_ACK,

	MSR_IA32_TSC_ADJUST,
	MSR_IA32_TSC_DEADLINE,
	MSR_IA32_ARCH_CAPABILITIES,
	MSR_IA32_PERF_CAPABILITIES,
	MSR_IA32_MISC_ENABLE,
	MSR_IA32_MCG_STATUS,
	MSR_IA32_MCG_CTL,
	MSR_IA32_MCG_EXT_CTL,
	MSR_IA32_SMBASE,
	MSR_SMI_COUNT,
	MSR_PLATFORM_INFO,
	MSR_MISC_FEATURES_ENABLES,
	MSR_AMD64_VIRT_SPEC_CTRL,
	MSR_AMD64_TSC_RATIO,
	MSR_IA32_POWER_CTL,
	MSR_IA32_UCODE_REV,

	/*
	 * The following list leaves out MSRs whose values are determined
	 * by arch/x86/kvm/vmx/nested.c based on CPUID or other MSRs.
	 * We always support the &quot;true&quot; VMX control MSRs, even if the host
	 * processor does not, so I am putting these registers here rather
	 * than in msrs_to_save_all.
	 */
	MSR_IA32_VMX_BASIC,
	MSR_IA32_VMX_TRUE_PINBASED_CTLS,
	MSR_IA32_VMX_TRUE_PROCBASED_CTLS,
	MSR_IA32_VMX_TRUE_EXIT_CTLS,
	MSR_IA32_VMX_TRUE_ENTRY_CTLS,
	MSR_IA32_VMX_MISC,
	MSR_IA32_VMX_CR0_FIXED0,
	MSR_IA32_VMX_CR4_FIXED0,
	MSR_IA32_VMX_VMCS_ENUM,
	MSR_IA32_VMX_PROCBASED_CTLS2,
	MSR_IA32_VMX_EPT_VPID_CAP,
	MSR_IA32_VMX_VMFUNC,

	MSR_K7_HWCR,
	MSR_KVM_POLL_CONTROL,
};

static u32 emulated_msrs[ARRAY_SIZE(emulated_msrs_all)];
static unsigned num_emulated_msrs;

/*
 * List of msr numbers which are used to expose MSR-based features that
 * can be used by a hypervisor to validate requested CPU features.
 */
static const u32 msr_based_features_all[] = {
	MSR_IA32_VMX_BASIC,
	MSR_IA32_VMX_TRUE_PINBASED_CTLS,
	MSR_IA32_VMX_PINBASED_CTLS,
	MSR_IA32_VMX_TRUE_PROCBASED_CTLS,
	MSR_IA32_VMX_PROCBASED_CTLS,
	MSR_IA32_VMX_TRUE_EXIT_CTLS,
	MSR_IA32_VMX_EXIT_CTLS,
	MSR_IA32_VMX_TRUE_ENTRY_CTLS,
	MSR_IA32_VMX_ENTRY_CTLS,
	MSR_IA32_VMX_MISC,
	MSR_IA32_VMX_CR0_FIXED0,
	MSR_IA32_VMX_CR0_FIXED1,
	MSR_IA32_VMX_CR4_FIXED0,
	MSR_IA32_VMX_CR4_FIXED1,
	MSR_IA32_VMX_VMCS_ENUM,
	MSR_IA32_VMX_PROCBASED_CTLS2,
	MSR_IA32_VMX_EPT_VPID_CAP,
	MSR_IA32_VMX_VMFUNC,

	MSR_AMD64_DE_CFG,
	MSR_IA32_UCODE_REV,
	MSR_IA32_ARCH_CAPABILITIES,
	MSR_IA32_PERF_CAPABILITIES,
};

static u32 msr_based_features[ARRAY_SIZE(msr_based_features_all)];
static unsigned int num_msr_based_features;

/*
 * Some IA32_ARCH_CAPABILITIES bits have dependencies on MSRs that KVM
 * does not yet virtualize. These include:
 *   10 - MISC_PACKAGE_CTRLS
 *   11 - ENERGY_FILTERING_CTL
 *   12 - DOITM
 *   18 - FB_CLEAR_CTRL
 *   21 - XAPIC_DISABLE_STATUS
 *   23 - OVERCLOCKING_STATUS
 */

#define KVM_SUPPORTED_ARCH_CAP \
	(ARCH_CAP_RDCL_NO | ARCH_CAP_IBRS_ALL | ARCH_CAP_RSBA | \
	 ARCH_CAP_SKIP_VMENTRY_L1DFLUSH | ARCH_CAP_SSB_NO | ARCH_CAP_MDS_NO | \
	 ARCH_CAP_PSCHANGE_MC_NO | ARCH_CAP_TSX_CTRL_MSR | ARCH_CAP_TAA_NO | \
	 ARCH_CAP_SBDR_SSDP_NO | ARCH_CAP_FBSDP_NO | ARCH_CAP_PSDP_NO | \
	 ARCH_CAP_FB_CLEAR | ARCH_CAP_RRSBA | ARCH_CAP_PBRSB_NO)

static u64 kvm_get_arch_capabilities(void)
{
	u64 data = 0;

<blue>	if (boot_cpu_has(X86_FEATURE_ARCH_CAPABILITIES)) {</blue>
<blue>		rdmsrl(MSR_IA32_ARCH_CAPABILITIES, data);</blue>
		data &amp;= KVM_SUPPORTED_ARCH_CAP;
	}

	/*
	 * If nx_huge_pages is enabled, KVM&#x27;s shadow paging will ensure that
	 * the nested hypervisor runs with NX huge pages.  If it is not,
	 * L1 is anyway vulnerable to ITLB_MULTIHIT exploits from other
	 * L1 guests, so it need not worry about its own (L2) guests.
	 */
	data |= ARCH_CAP_PSCHANGE_MC_NO;

	/*
	 * If we&#x27;re doing cache flushes (either &quot;always&quot; or &quot;cond&quot;)
	 * we will do one whenever the guest does a vmlaunch/vmresume.
	 * If an outer hypervisor is doing the cache flush for us
	 * (VMENTER_L1D_FLUSH_NESTED_VM), we can safely pass that
	 * capability to the guest too, and if EPT is disabled we&#x27;re not
	 * vulnerable.  Overall, only VMENTER_L1D_FLUSH_NEVER will
	 * require a nested hypervisor to do a flush of its own.
	 */
<blue>	if (l1tf_vmx_mitigation != VMENTER_L1D_FLUSH_NEVER)</blue>
<blue>		data |= ARCH_CAP_SKIP_VMENTRY_L1DFLUSH;</blue>

<blue>	if (!boot_cpu_has_bug(X86_BUG_CPU_MELTDOWN))</blue>
<blue>		data |= ARCH_CAP_RDCL_NO;</blue>
<blue>	if (!boot_cpu_has_bug(X86_BUG_SPEC_STORE_BYPASS))</blue>
<yellow>		data |= ARCH_CAP_SSB_NO;</yellow>
<blue>	if (!boot_cpu_has_bug(X86_BUG_MDS))</blue>
<blue>		data |= ARCH_CAP_MDS_NO;</blue>

<blue>	if (!boot_cpu_has(X86_FEATURE_RTM)) {</blue>
		/*
		 * If RTM=0 because the kernel has disabled TSX, the host might
		 * have TAA_NO or TSX_CTRL.  Clear TAA_NO (the guest sees RTM=0
		 * and therefore knows that there cannot be TAA) but keep
		 * TSX_CTRL: some buggy userspaces leave it set on tsx=on hosts,
		 * and we want to allow migrating those guests to tsx=off hosts.
		 */
<blue>		data &= ~ARCH_CAP_TAA_NO;</blue>
<yellow>	} else if (!boot_cpu_has_bug(X86_BUG_TAA)) {</yellow>
<yellow>		data |= ARCH_CAP_TAA_NO;</yellow>
	} else {
		/*
		 * Nothing to do here; we emulate TSX_CTRL if present on the
		 * host so the guest can choose between disabling TSX or
		 * using VERW to clear CPU buffers.
		 */
	}

	return data;
<blue>}</blue>

<blue>static int kvm_get_msr_feature(struct kvm_msr_entry *msr)</blue>
{
<blue>	switch (msr->index) {</blue>
	case MSR_IA32_ARCH_CAPABILITIES:
<blue>		msr->data = kvm_get_arch_capabilities();</blue>
		break;
	case MSR_IA32_UCODE_REV:
<blue>		rdmsrl_safe(msr->index, &msr->data);</blue>
		break;
	default:
<blue>		return static_call(kvm_x86_get_msr_feature)(msr);</blue>
	}
	return 0;
}

static int do_get_msr_feature(struct kvm_vcpu *vcpu, unsigned index, u64 *data)
<blue>{</blue>
	struct kvm_msr_entry msr;
	int r;

	msr.index = index;
<blue>	r = kvm_get_msr_feature(&msr);</blue>

	if (r == KVM_MSR_RET_INVALID) {
		/* Unconditionally clear the output for simplicity */
<yellow>		*data = 0;</yellow>
		if (kvm_msr_ignored_check(index, 0, false))
			r = 0;
	}

<blue>	if (r)</blue>
		return r;

<blue>	*data = msr.data;</blue>

	return 0;
}

static bool __kvm_valid_efer(struct kvm_vcpu *vcpu, u64 efer)
{
<blue>	if (efer & EFER_FFXSR && !guest_cpuid_has(vcpu, X86_FEATURE_FXSR_OPT))</blue>
		return false;

<blue>	if (efer & EFER_SVME && !guest_cpuid_has(vcpu, X86_FEATURE_SVM))</blue>
		return false;

<blue>	if (efer & (EFER_LME | EFER_LMA) &&</blue>
<blue>	    !guest_cpuid_has(vcpu, X86_FEATURE_LM))</blue>
		return false;

<blue>	if (efer & EFER_NX && !guest_cpuid_has(vcpu, X86_FEATURE_NX))</blue>
		return false;

	return true;

<blue>}</blue>
bool kvm_valid_efer(struct kvm_vcpu *vcpu, u64 efer)
{
<blue>	if (efer & efer_reserved_bits)</blue>
		return false;

<blue>	return __kvm_valid_efer(vcpu, efer);</blue>
<blue>}</blue>
EXPORT_SYMBOL_GPL(kvm_valid_efer);

static int set_efer(struct kvm_vcpu *vcpu, struct msr_data *msr_info)
{
<blue>	u64 old_efer = vcpu->arch.efer;</blue>
	u64 efer = msr_info-&gt;data;
	int r;

	if (efer &amp; efer_reserved_bits)
		return 1;

<blue>	if (!msr_info->host_initiated) {</blue>
<blue>		if (!__kvm_valid_efer(vcpu, efer))</blue>
			return 1;

<blue>		if (is_paging(vcpu) &&</blue>
<blue>		    (vcpu->arch.efer & EFER_LME) != (efer & EFER_LME))</blue>
			return 1;
	}

<blue>	efer &= ~EFER_LMA;</blue>
<yellow>	efer |= vcpu->arch.efer & EFER_LMA;</yellow>

	r = static_call(kvm_x86_set_efer)(vcpu, efer);
	if (r) {
<yellow>		WARN_ON(r > 0);</yellow>
		return r;
	}

<blue>	if ((efer ^ old_efer) & KVM_MMU_EFER_ROLE_BITS)</blue>
<blue>		kvm_mmu_reset_context(vcpu);</blue>

	return 0;
}

void kvm_enable_efer_bits(u64 mask)
{
<yellow>       efer_reserved_bits &= ~mask;</yellow>
}
EXPORT_SYMBOL_GPL(kvm_enable_efer_bits);

bool kvm_msr_allowed(struct kvm_vcpu *vcpu, u32 index, u32 type)
{
	struct kvm_x86_msr_filter *msr_filter;
	struct msr_bitmap_range *ranges;
<blue>	struct kvm *kvm = vcpu->kvm;</blue>
	bool allowed;
	int idx;
	u32 i;

	/* x2APIC MSRs do not support filtering. */
<blue>	if (index >= 0x800 && index <= 0x8ff)</blue>
		return true;

	idx = srcu_read_lock(&amp;kvm-&gt;srcu);

	msr_filter = srcu_dereference(kvm-&gt;arch.msr_filter, &amp;kvm-&gt;srcu);
	if (!msr_filter) {
		allowed = true;
		goto out;
	}

<yellow>	allowed = msr_filter->default_allow;</yellow>
	ranges = msr_filter-&gt;ranges;

<yellow>	for (i = 0; i < msr_filter->count; i++) {</yellow>
<yellow>		u32 start = ranges[i].base;</yellow>
<yellow>		u32 end = start + ranges[i].nmsrs;</yellow>
<yellow>		u32 flags = ranges[i].flags;</yellow>
<yellow>		unsigned long *bitmap = ranges[i].bitmap;</yellow>

		if ((index &gt;= start) &amp;&amp; (index &lt; end) &amp;&amp; (flags &amp; type)) {
			allowed = !!test_bit(index - start, bitmap);
			break;
		}
	}

out:
<blue>	srcu_read_unlock(&kvm->srcu, idx);</blue>

	return allowed;
<blue>}</blue>
EXPORT_SYMBOL_GPL(kvm_msr_allowed);

/*
 * Write @data into the MSR specified by @index.  Select MSR specific fault
 * checks are bypassed if @host_initiated is %true.
 * Returns 0 on success, non-0 otherwise.
 * Assumes vcpu_load() was already called.
 */
static int __kvm_set_msr(struct kvm_vcpu *vcpu, u32 index, u64 data,
			 bool host_initiated)
<blue>{</blue>
	struct msr_data msr;

<blue>	switch (index) {</blue>
	case MSR_FS_BASE:
	case MSR_GS_BASE:
	case MSR_KERNEL_GS_BASE:
	case MSR_CSTAR:
	case MSR_LSTAR:
<blue>		if (is_noncanonical_address(data, vcpu))</blue>
			return 1;
		break;
	case MSR_IA32_SYSENTER_EIP:
	case MSR_IA32_SYSENTER_ESP:
		/*
		 * IA32_SYSENTER_ESP and IA32_SYSENTER_EIP cause #GP if
		 * non-canonical address is written on Intel but not on
		 * AMD (which ignores the top 32-bits, because it does
		 * not implement 64-bit SYSENTER).
		 *
		 * 64-bit code should hence be able to write a non-canonical
		 * value on AMD.  Making the address canonical ensures that
		 * vmentry does not fail on Intel after writing a non-canonical
		 * value, and that something deterministic happens if the guest
		 * invokes 64-bit SYSENTER.
		 */
<blue>		data = __canonical_address(data, vcpu_virt_addr_bits(vcpu));</blue>
		break;
	case MSR_TSC_AUX:
<blue>		if (!kvm_is_supported_user_return_msr(MSR_TSC_AUX))</blue>
			return 1;

<blue>		if (!host_initiated &&</blue>
<yellow>		    !guest_cpuid_has(vcpu, X86_FEATURE_RDTSCP) &&</yellow>
<yellow>		    !guest_cpuid_has(vcpu, X86_FEATURE_RDPID))</yellow>
			return 1;

		/*
		 * Per Intel&#x27;s SDM, bits 63:32 are reserved, but AMD&#x27;s APM has
		 * incomplete and conflicting architectural behavior.  Current
		 * AMD CPUs completely ignore bits 63:32, i.e. they aren&#x27;t
		 * reserved and always read as zeros.  Enforce Intel&#x27;s reserved
		 * bits check if and only if the guest CPU is Intel, and clear
		 * the bits in all other cases.  This ensures cross-vendor
		 * migration will provide consistent behavior for the guest.
		 */
<blue>		if (guest_cpuid_is_intel(vcpu) && (data >> 32) != 0)</blue>
			return 1;

<blue>		data = (u32)data;</blue>
		break;
	}

<blue>	msr.data = data;</blue>
	msr.index = index;
	msr.host_initiated = host_initiated;

<blue>	return static_call(kvm_x86_set_msr)(vcpu, &msr);</blue>
}

<blue>static int kvm_set_msr_ignored_check(struct kvm_vcpu *vcpu,</blue>
				     u32 index, u64 data, bool host_initiated)
{
<blue>	int ret = __kvm_set_msr(vcpu, index, data, host_initiated);</blue>

	if (ret == KVM_MSR_RET_INVALID)
<blue>		if (kvm_msr_ignored_check(index, data, true))</blue>
			ret = 0;

	return ret;
}

/*
 * Read the MSR specified by @index into @data.  Select MSR specific fault
 * checks are bypassed if @host_initiated is %true.
 * Returns 0 on success, non-0 otherwise.
 * Assumes vcpu_load() was already called.
 */
int __kvm_get_msr(struct kvm_vcpu *vcpu, u32 index, u64 *data,
		  bool host_initiated)
<blue>{</blue>
	struct msr_data msr;
	int ret;

<blue>	switch (index) {</blue>
	case MSR_TSC_AUX:
<blue>		if (!kvm_is_supported_user_return_msr(MSR_TSC_AUX))</blue>
			return 1;

<blue>		if (!host_initiated &&</blue>
<yellow>		    !guest_cpuid_has(vcpu, X86_FEATURE_RDTSCP) &&</yellow>
<yellow>		    !guest_cpuid_has(vcpu, X86_FEATURE_RDPID))</yellow>
			return 1;
		break;
	}

<blue>	msr.index = index;</blue>
	msr.host_initiated = host_initiated;

	ret = static_call(kvm_x86_get_msr)(vcpu, &amp;msr);
	if (!ret)
<blue>		*data = msr.data;</blue>
	return ret;
}

<blue>static int kvm_get_msr_ignored_check(struct kvm_vcpu *vcpu,</blue>
				     u32 index, u64 *data, bool host_initiated)
{
<blue>	int ret = __kvm_get_msr(vcpu, index, data, host_initiated);</blue>

	if (ret == KVM_MSR_RET_INVALID) {
		/* Unconditionally clear *data for simplicity */
<blue>		*data = 0;</blue>
<blue>		if (kvm_msr_ignored_check(index, 0, false))</blue>
			ret = 0;
	}

	return ret;
}

<blue>static int kvm_get_msr_with_filter(struct kvm_vcpu *vcpu, u32 index, u64 *data)</blue>
{
	if (!kvm_msr_allowed(vcpu, index, KVM_MSR_FILTER_READ))
		return KVM_MSR_RET_FILTERED;
<blue>	return kvm_get_msr_ignored_check(vcpu, index, data, false);</blue>
}

<blue>static int kvm_set_msr_with_filter(struct kvm_vcpu *vcpu, u32 index, u64 data)</blue>
{
	if (!kvm_msr_allowed(vcpu, index, KVM_MSR_FILTER_WRITE))
		return KVM_MSR_RET_FILTERED;
<blue>	return kvm_set_msr_ignored_check(vcpu, index, data, false);</blue>
}

int kvm_get_msr(struct kvm_vcpu *vcpu, u32 index, u64 *data)
{
<blue>	return kvm_get_msr_ignored_check(vcpu, index, data, false);</blue>
<blue>}</blue>
EXPORT_SYMBOL_GPL(kvm_get_msr);

int kvm_set_msr(struct kvm_vcpu *vcpu, u32 index, u64 data)
{
<blue>	return kvm_set_msr_ignored_check(vcpu, index, data, false);</blue>
<blue>}</blue>
EXPORT_SYMBOL_GPL(kvm_set_msr);

static void complete_userspace_rdmsr(struct kvm_vcpu *vcpu)
{
<yellow>	if (!vcpu->run->msr.error) {</yellow>
<yellow>		kvm_rax_write(vcpu, (u32)vcpu->run->msr.data);</yellow>
		kvm_rdx_write(vcpu, vcpu-&gt;run-&gt;msr.data &gt;&gt; 32);
	}
}

static int complete_emulated_msr_access(struct kvm_vcpu *vcpu)
{
<yellow>	return complete_emulated_insn_gp(vcpu, vcpu->run->msr.error);</yellow>
<yellow>}</yellow>

static int complete_emulated_rdmsr(struct kvm_vcpu *vcpu)
{
<yellow>	complete_userspace_rdmsr(vcpu);</yellow>
<yellow>	return complete_emulated_msr_access(vcpu);</yellow>
<yellow>}</yellow>

static int complete_fast_msr_access(struct kvm_vcpu *vcpu)
{
<yellow>	return static_call(kvm_x86_complete_emulated_msr)(vcpu, vcpu->run->msr.error);</yellow>
}

static int complete_fast_rdmsr(struct kvm_vcpu *vcpu)
{
<yellow>	complete_userspace_rdmsr(vcpu);</yellow>
<yellow>	return complete_fast_msr_access(vcpu);</yellow>
}

static u64 kvm_msr_reason(int r)
{
<blue>	switch (r) {</blue>
	case KVM_MSR_RET_INVALID:
		return KVM_MSR_EXIT_REASON_UNKNOWN;
	case KVM_MSR_RET_FILTERED:
		return KVM_MSR_EXIT_REASON_FILTER;
	default:
		return KVM_MSR_EXIT_REASON_INVAL;
	}
}

static int kvm_msr_user_space(struct kvm_vcpu *vcpu, u32 index,
			      u32 exit_reason, u64 data,
			      int (*completion)(struct kvm_vcpu *vcpu),
			      int r)
{
<blue>	u64 msr_reason = kvm_msr_reason(r);</blue>

	/* Check if the user wanted to know about this MSR fault */
<blue>	if (!(vcpu->kvm->arch.user_space_msr_mask & msr_reason))</blue>
		return 0;

<yellow>	vcpu->run->exit_reason = exit_reason;</yellow>
	vcpu-&gt;run-&gt;msr.error = 0;
	memset(vcpu-&gt;run-&gt;msr.pad, 0, sizeof(vcpu-&gt;run-&gt;msr.pad));
	vcpu-&gt;run-&gt;msr.reason = msr_reason;
	vcpu-&gt;run-&gt;msr.index = index;
	vcpu-&gt;run-&gt;msr.data = data;
	vcpu-&gt;arch.complete_userspace_io = completion;

	return 1;
<blue>}</blue>

int kvm_emulate_rdmsr(struct kvm_vcpu *vcpu)
<blue>{</blue>
<blue>	u32 ecx = kvm_rcx_read(vcpu);</blue>
	u64 data;
	int r;

<blue>	r = kvm_get_msr_with_filter(vcpu, ecx, &data);</blue>

<blue>	if (!r) {</blue>
<blue>		trace_kvm_msr_read(ecx, data);</blue>

<blue>		kvm_rax_write(vcpu, data & -1u);</blue>
		kvm_rdx_write(vcpu, (data &gt;&gt; 32) &amp; -1u);
	} else {
		/* MSR read failed? See if we should ask user space */
<blue>		if (kvm_msr_user_space(vcpu, ecx, KVM_EXIT_X86_RDMSR, 0,</blue>
				       complete_fast_rdmsr, r))
			return 0;
<blue>		trace_kvm_msr_read_ex(ecx);</blue>
	}

<blue>	return static_call(kvm_x86_complete_emulated_msr)(vcpu, r);</blue>
}
EXPORT_SYMBOL_GPL(kvm_emulate_rdmsr);

int kvm_emulate_wrmsr(struct kvm_vcpu *vcpu)
{
<blue>	u32 ecx = kvm_rcx_read(vcpu);</blue>
	u64 data = kvm_read_edx_eax(vcpu);
	int r;

<blue>	r = kvm_set_msr_with_filter(vcpu, ecx, data);</blue>

<blue>	if (!r) {</blue>
<blue>		trace_kvm_msr_write(ecx, data);</blue>
	} else {
		/* MSR write failed? See if we should ask user space */
<blue>		if (kvm_msr_user_space(vcpu, ecx, KVM_EXIT_X86_WRMSR, data,</blue>
				       complete_fast_msr_access, r))
			return 0;
		/* Signal all other negative errors to userspace */
<blue>		if (r < 0)</blue>
			return r;
<blue>		trace_kvm_msr_write_ex(ecx, data);</blue>
	}

<blue>	return static_call(kvm_x86_complete_emulated_msr)(vcpu, r);</blue>
<blue>}</blue>
EXPORT_SYMBOL_GPL(kvm_emulate_wrmsr);

int kvm_emulate_as_nop(struct kvm_vcpu *vcpu)
{
<blue>	return kvm_skip_emulated_instruction(vcpu);</blue>
<yellow>}</yellow>
EXPORT_SYMBOL_GPL(kvm_emulate_as_nop);

int kvm_emulate_invd(struct kvm_vcpu *vcpu)
{
	/* Treat an INVD instruction as a NOP and just skip it. */
	return kvm_emulate_as_nop(vcpu);
}
EXPORT_SYMBOL_GPL(kvm_emulate_invd);

int kvm_handle_invalid_op(struct kvm_vcpu *vcpu)
{
<yellow>	kvm_queue_exception(vcpu, UD_VECTOR);</yellow>
	return 1;
}
EXPORT_SYMBOL_GPL(kvm_handle_invalid_op);


static int kvm_emulate_monitor_mwait(struct kvm_vcpu *vcpu, const char *insn)
{
<blue>	if (!kvm_check_has_quirk(vcpu->kvm, KVM_X86_QUIRK_MWAIT_NEVER_UD_FAULTS) &&</blue>
<yellow>	    !guest_cpuid_has(vcpu, X86_FEATURE_MWAIT))</yellow>
<yellow>		return kvm_handle_invalid_op(vcpu);</yellow>

<blue>	pr_warn_once("kvm: %s instruction emulated as NOP!\n", insn);</blue>
<blue>	return kvm_emulate_as_nop(vcpu);</blue>
<blue>}</blue>
int kvm_emulate_mwait(struct kvm_vcpu *vcpu)
{
<blue>	return kvm_emulate_monitor_mwait(vcpu, "MWAIT");</blue>
}
EXPORT_SYMBOL_GPL(kvm_emulate_mwait);

int kvm_emulate_monitor(struct kvm_vcpu *vcpu)
{
<blue>	return kvm_emulate_monitor_mwait(vcpu, "MONITOR");</blue>
}
EXPORT_SYMBOL_GPL(kvm_emulate_monitor);

static inline bool kvm_vcpu_exit_request(struct kvm_vcpu *vcpu)
{
<blue>	xfer_to_guest_mode_prepare();</blue>
<blue>	return vcpu->mode == EXITING_GUEST_MODE || kvm_request_pending(vcpu) ||</blue>
<blue>		xfer_to_guest_mode_work_pending();</blue>
}

/*
 * The fast path for frequent and performance sensitive wrmsr emulation,
 * i.e. the sending of IPI, sending IPI early in the VM-Exit flow reduces
 * the latency of virtual IPI by avoiding the expensive bits of transitioning
 * from guest to host, e.g. reacquiring KVM&#x27;s SRCU lock. In contrast to the
 * other cases which must be called after interrupts are enabled on the host.
 */
static int handle_fastpath_set_x2apic_icr_irqoff(struct kvm_vcpu *vcpu, u64 data)
{
<yellow>	if (!lapic_in_kernel(vcpu) || !apic_x2apic_mode(vcpu->arch.apic))</yellow>
		return 1;

	if (((data &amp; APIC_SHORT_MASK) == APIC_DEST_NOSHORT) &amp;&amp;
	    ((data &amp; APIC_DEST_MASK) == APIC_DEST_PHYSICAL) &amp;&amp;
	    ((data &amp; APIC_MODE_MASK) == APIC_DM_FIXED) &amp;&amp;
<yellow>	    ((u32)(data >> 32) != X2APIC_BROADCAST))</yellow>
<yellow>		return kvm_x2apic_icr_write(vcpu->arch.apic, data);</yellow>

	return 1;
}

static int handle_fastpath_set_tscdeadline(struct kvm_vcpu *vcpu, u64 data)
{
	if (!kvm_can_use_hv_timer(vcpu))
		return 1;

	kvm_set_lapic_tscdeadline_msr(vcpu, data);
	return 0;
}

fastpath_t handle_fastpath_set_msr_irqoff(struct kvm_vcpu *vcpu)
{
<blue>	u32 msr = kvm_rcx_read(vcpu);</blue>
	u64 data;
	fastpath_t ret = EXIT_FASTPATH_NONE;

	switch (msr) {
	case APIC_BASE_MSR + (APIC_ICR &gt;&gt; 4):
<yellow>		data = kvm_read_edx_eax(vcpu);</yellow>
<yellow>		if (!handle_fastpath_set_x2apic_icr_irqoff(vcpu, data)) {</yellow>
<yellow>			kvm_skip_emulated_instruction(vcpu);</yellow>
			ret = EXIT_FASTPATH_EXIT_HANDLED;
		}
		break;
	case MSR_IA32_TSC_DEADLINE:
<yellow>		data = kvm_read_edx_eax(vcpu);</yellow>
		if (!handle_fastpath_set_tscdeadline(vcpu, data)) {
			kvm_skip_emulated_instruction(vcpu);
			ret = EXIT_FASTPATH_REENTER_GUEST;
		}
		break;
	default:
		break;
	}

	if (ret != EXIT_FASTPATH_NONE)
<yellow>		trace_kvm_msr_write(msr, data);</yellow>

	return ret;
<blue>}</blue>
EXPORT_SYMBOL_GPL(handle_fastpath_set_msr_irqoff);

/*
 * Adapt set_msr() to msr_io()&#x27;s calling convention
 */
static int do_get_msr(struct kvm_vcpu *vcpu, unsigned index, u64 *data)
{
<blue>	return kvm_get_msr_ignored_check(vcpu, index, data, true);</blue>
<blue>}</blue>

static int do_set_msr(struct kvm_vcpu *vcpu, unsigned index, u64 *data)
{
<blue>	return kvm_set_msr_ignored_check(vcpu, index, *data, true);</blue>
}

#ifdef CONFIG_X86_64
struct pvclock_clock {
	int vclock_mode;
	u64 cycle_last;
	u64 mask;
	u32 mult;
	u32 shift;
	u64 base_cycles;
	u64 offset;
};

struct pvclock_gtod_data {
	seqcount_t	seq;

	struct pvclock_clock clock; /* extract of a clocksource struct */
	struct pvclock_clock raw_clock; /* extract of a clocksource struct */

	ktime_t		offs_boot;
	u64		wall_time_sec;
};

static struct pvclock_gtod_data pvclock_gtod_data;

static void update_pvclock_gtod(struct timekeeper *tk)
{
	struct pvclock_gtod_data *vdata = &amp;pvclock_gtod_data;

<yellow>	write_seqcount_begin(&vdata->seq);</yellow>

	/* copy pvclock gtod data */
	vdata-&gt;clock.vclock_mode	= tk-&gt;tkr_mono.clock-&gt;vdso_clock_mode;
	vdata-&gt;clock.cycle_last		= tk-&gt;tkr_mono.cycle_last;
	vdata-&gt;clock.mask		= tk-&gt;tkr_mono.mask;
	vdata-&gt;clock.mult		= tk-&gt;tkr_mono.mult;
	vdata-&gt;clock.shift		= tk-&gt;tkr_mono.shift;
	vdata-&gt;clock.base_cycles	= tk-&gt;tkr_mono.xtime_nsec;
	vdata-&gt;clock.offset		= tk-&gt;tkr_mono.base;

	vdata-&gt;raw_clock.vclock_mode	= tk-&gt;tkr_raw.clock-&gt;vdso_clock_mode;
	vdata-&gt;raw_clock.cycle_last	= tk-&gt;tkr_raw.cycle_last;
	vdata-&gt;raw_clock.mask		= tk-&gt;tkr_raw.mask;
	vdata-&gt;raw_clock.mult		= tk-&gt;tkr_raw.mult;
	vdata-&gt;raw_clock.shift		= tk-&gt;tkr_raw.shift;
	vdata-&gt;raw_clock.base_cycles	= tk-&gt;tkr_raw.xtime_nsec;
	vdata-&gt;raw_clock.offset		= tk-&gt;tkr_raw.base;

	vdata-&gt;wall_time_sec            = tk-&gt;xtime_sec;

	vdata-&gt;offs_boot		= tk-&gt;offs_boot;

	write_seqcount_end(&amp;vdata-&gt;seq);
}

static s64 get_kvmclock_base_ns(void)
{
	/* Count up from boot time, but with the frequency of the raw clock.  */
<blue>	return ktime_to_ns(ktime_add(ktime_get_raw(), pvclock_gtod_data.offs_boot));</blue>
}
#else
static s64 get_kvmclock_base_ns(void)
{
	/* Master clock not used, so we can just use CLOCK_BOOTTIME.  */
	return ktime_get_boottime_ns();
}
#endif

<blue>static void kvm_write_wall_clock(struct kvm *kvm, gpa_t wall_clock, int sec_hi_ofs)</blue>
{
	int version;
	int r;
	struct pvclock_wall_clock wc;
	u32 wc_sec_hi;
	u64 wall_nsec;

<blue>	if (!wall_clock)</blue>
		return;

<blue>	r = kvm_read_guest(kvm, wall_clock, &version, sizeof(version));</blue>
	if (r)
		return;

<blue>	if (version & 1)</blue>
<yellow>		++version;  /* first time write, random junk */</yellow>

<blue>	++version;</blue>

	if (kvm_write_guest(kvm, wall_clock, &amp;version, sizeof(version)))
		return;

	/*
	 * The guest calculates current wall clock time by adding
	 * system time (updated by kvm_guest_time_update below) to the
	 * wall clock specified here.  We do the reverse here.
	 */
<blue>	wall_nsec = ktime_get_real_ns() - get_kvmclock_ns(kvm);</blue>

	wc.nsec = do_div(wall_nsec, 1000000000);
	wc.sec = (u32)wall_nsec; /* overflow in 2106 guest time */
	wc.version = version;

	kvm_write_guest(kvm, wall_clock, &amp;wc, sizeof(wc));

	if (sec_hi_ofs) {
		wc_sec_hi = wall_nsec &gt;&gt; 32;
		kvm_write_guest(kvm, wall_clock + sec_hi_ofs,
				&amp;wc_sec_hi, sizeof(wc_sec_hi));
	}

	version++;
	kvm_write_guest(kvm, wall_clock, &amp;version, sizeof(version));
}

static void kvm_write_system_time(struct kvm_vcpu *vcpu, gpa_t system_time,
				  bool old_msr, bool host_initiated)
{
<yellow>	struct kvm_arch *ka = &vcpu->kvm->arch;</yellow>

<blue>	if (vcpu->vcpu_id == 0 && !host_initiated) {</blue>
<yellow>		if (ka->boot_vcpu_runs_old_kvmclock != old_msr)</yellow>
<yellow>			kvm_make_request(KVM_REQ_MASTERCLOCK_UPDATE, vcpu);</yellow>

<yellow>		ka->boot_vcpu_runs_old_kvmclock = old_msr;</yellow>
	}

<blue>	vcpu->arch.time = system_time;</blue>
	kvm_make_request(KVM_REQ_GLOBAL_CLOCK_UPDATE, vcpu);

	/* we verify if the enable bit is set... */
	if (system_time &amp; 1) {
<yellow>		kvm_gpc_activate(vcpu->kvm, &vcpu->arch.pv_time, vcpu,</yellow>
				 KVM_HOST_USES_PFN, system_time &amp; ~1ULL,
				 sizeof(struct pvclock_vcpu_time_info));
	} else {
<blue>		kvm_gpc_deactivate(vcpu->kvm, &vcpu->arch.pv_time);</blue>
	}

	return;
<blue>}</blue>

static uint32_t div_frac(uint32_t dividend, uint32_t divisor)
{
<blue>	do_shl32_div32(dividend, divisor);</blue>
	return dividend;
}

static void kvm_get_time_scale(uint64_t scaled_hz, uint64_t base_hz,
			       s8 *pshift, u32 *pmultiplier)
{
	uint64_t scaled64;
	int32_t  shift = 0;
	uint64_t tps64;
	uint32_t tps32;

	tps64 = base_hz;
	scaled64 = scaled_hz;
<blue>	while (tps64 > scaled64*2 || tps64 & 0xffffffff00000000ULL) {</blue>
<blue>		tps64 >>= 1;</blue>
		shift--;
	}

<yellow>	tps32 = (uint32_t)tps64;</yellow>
<blue>	while (tps32 <= scaled64 || scaled64 & 0xffffffff00000000ULL) {</blue>
<blue>		if (scaled64 & 0xffffffff00000000ULL || tps32 & 0x80000000)</blue>
<yellow>			scaled64 >>= 1;</yellow>
		else
<blue>			tps32 <<= 1;</blue>
		shift++;
	}

<blue>	*pshift = shift;</blue>
<blue>	*pmultiplier = div_frac(scaled64, tps32);</blue>
}

#ifdef CONFIG_X86_64
static atomic_t kvm_guest_has_master_clock = ATOMIC_INIT(0);
#endif

static DEFINE_PER_CPU(unsigned long, cpu_tsc_khz);
static unsigned long max_tsc_khz;

static u32 adjust_tsc_khz(u32 khz, s32 ppm)
{
	u64 v = (u64)khz * (1000000 + ppm);
	do_div(v, 1000000);
	return v;
}

static void kvm_vcpu_write_tsc_multiplier(struct kvm_vcpu *vcpu, u64 l1_multiplier);

static int set_tsc_khz(struct kvm_vcpu *vcpu, u32 user_tsc_khz, bool scale)
{
	u64 ratio;

	/* Guest TSC same frequency as host TSC? */
	if (!scale) {
<blue>		kvm_vcpu_write_tsc_multiplier(vcpu, kvm_caps.default_tsc_scaling_ratio);</blue>
		return 0;
	}

	/* TSC scaling supported? */
<yellow>	if (!kvm_caps.has_tsc_control) {</yellow>
<yellow>		if (user_tsc_khz > tsc_khz) {</yellow>
<yellow>			vcpu->arch.tsc_catchup = 1;</yellow>
			vcpu-&gt;arch.tsc_always_catchup = 1;
			return 0;
		} else {
<yellow>			pr_warn_ratelimited("user requested TSC rate below hardware speed\n");</yellow>
			return -1;
		}
	}

	/* TSC scaling required  - calculate ratio */
<yellow>	ratio = mul_u64_u32_div(1ULL << kvm_caps.tsc_scaling_ratio_frac_bits,</yellow>
				user_tsc_khz, tsc_khz);

<yellow>	if (ratio == 0 || ratio >= kvm_caps.max_tsc_scaling_ratio) {</yellow>
<yellow>		pr_warn_ratelimited("Invalid TSC scaling ratio - virtual-tsc-khz=%u\n",</yellow>
			            user_tsc_khz);
		return -1;
	}

<yellow>	kvm_vcpu_write_tsc_multiplier(vcpu, ratio);</yellow>
	return 0;
}

static int kvm_set_tsc_khz(struct kvm_vcpu *vcpu, u32 user_tsc_khz)
{
	u32 thresh_lo, thresh_hi;
	int use_scaling = 0;

	/* tsc_khz can be zero if TSC calibration fails */
<blue>	if (user_tsc_khz == 0) {</blue>
		/* set tsc_scaling_ratio to a safe value */
<yellow>		kvm_vcpu_write_tsc_multiplier(vcpu, kvm_caps.default_tsc_scaling_ratio);</yellow>
		return -1;
	}

	/* Compute a scale to convert nanoseconds in TSC cycles */
<blue>	kvm_get_time_scale(user_tsc_khz * 1000LL, NSEC_PER_SEC,</blue>
			   &amp;vcpu-&gt;arch.virtual_tsc_shift,
			   &amp;vcpu-&gt;arch.virtual_tsc_mult);
	vcpu-&gt;arch.virtual_tsc_khz = user_tsc_khz;

	/*
	 * Compute the variation in TSC rate which is acceptable
	 * within the range of tolerance and decide if the
	 * rate being applied is within that bounds of the hardware
	 * rate.  If so, no scaling or compensation need be done.
	 */
	thresh_lo = adjust_tsc_khz(tsc_khz, -tsc_tolerance_ppm);
	thresh_hi = adjust_tsc_khz(tsc_khz, tsc_tolerance_ppm);
<blue>	if (user_tsc_khz < thresh_lo || user_tsc_khz > thresh_hi) {</blue>
<yellow>		pr_debug("kvm: requested TSC rate %u falls outside tolerance [%u,%u]\n", user_tsc_khz, thresh_lo, thresh_hi);</yellow>
		use_scaling = 1;
	}
<blue>	return set_tsc_khz(vcpu, user_tsc_khz, use_scaling);</blue>
<blue>}</blue>

static u64 compute_guest_tsc(struct kvm_vcpu *vcpu, s64 kernel_ns)
{
<yellow>	u64 tsc = pvclock_scale_delta(kernel_ns-vcpu->arch.this_tsc_nsec,</yellow>
				      vcpu-&gt;arch.virtual_tsc_mult,
<yellow>				      vcpu->arch.virtual_tsc_shift);</yellow>
<yellow>	tsc += vcpu->arch.this_tsc_write;</yellow>
	return tsc;
}

#ifdef CONFIG_X86_64
static inline int gtod_is_based_on_tsc(int mode)
{
<blue>	return mode == VDSO_CLOCKMODE_TSC || mode == VDSO_CLOCKMODE_HVCLOCK;</blue>
}
#endif

static void kvm_track_tsc_matching(struct kvm_vcpu *vcpu)
{
#ifdef CONFIG_X86_64
	bool vcpus_matched;
	struct kvm_arch *ka = &amp;vcpu-&gt;kvm-&gt;arch;
	struct pvclock_gtod_data *gtod = &amp;pvclock_gtod_data;

<blue>	vcpus_matched = (ka->nr_vcpus_matched_tsc + 1 ==</blue>
			 atomic_read(&amp;vcpu-&gt;kvm-&gt;online_vcpus));

	/*
	 * Once the masterclock is enabled, always perform request in
	 * order to update it.
	 *
	 * In order to enable masterclock, the host clocksource must be TSC
	 * and the vcpus need to have matched TSCs.  When that happens,
	 * perform request to enable masterclock.
	 */
<blue>	if (ka->use_master_clock ||</blue>
<blue>	    (gtod_is_based_on_tsc(gtod->clock.vclock_mode) && vcpus_matched))</blue>
<blue>		kvm_make_request(KVM_REQ_MASTERCLOCK_UPDATE, vcpu);</blue>

<yellow>	trace_kvm_track_tsc(vcpu->vcpu_id, ka->nr_vcpus_matched_tsc,</yellow>
<blue>			    atomic_read(&vcpu->kvm->online_vcpus),</blue>
<blue>		            ka->use_master_clock, gtod->clock.vclock_mode);</blue>
#endif
}

/*
 * Multiply tsc by a fixed point number represented by ratio.
 *
 * The most significant 64-N bits (mult) of ratio represent the
 * integral part of the fixed point number; the remaining N bits
 * (frac) represent the fractional part, ie. ratio represents a fixed
 * point number (mult + frac * 2^(-N)).
 *
 * N equals to kvm_caps.tsc_scaling_ratio_frac_bits.
 */
static inline u64 __scale_tsc(u64 ratio, u64 tsc)
{
<yellow>	return mul_u64_u64_shr(tsc, ratio, kvm_caps.tsc_scaling_ratio_frac_bits);</yellow>
}

<yellow>u64 kvm_scale_tsc(u64 tsc, u64 ratio)</yellow>
{
	u64 _tsc = tsc;

<yellow>	if (ratio != kvm_caps.default_tsc_scaling_ratio)</yellow>
<yellow>		_tsc = __scale_tsc(ratio, tsc);</yellow>

	return _tsc;
<yellow>}</yellow>
EXPORT_SYMBOL_GPL(kvm_scale_tsc);

static u64 kvm_compute_l1_tsc_offset(struct kvm_vcpu *vcpu, u64 target_tsc)
{
	u64 tsc;

<blue>	tsc = kvm_scale_tsc(rdtsc(), vcpu->arch.l1_tsc_scaling_ratio);</blue>

<blue>	return target_tsc - tsc;</blue>
}

u64 kvm_read_l1_tsc(struct kvm_vcpu *vcpu, u64 host_tsc)
{
<blue>	return vcpu->arch.l1_tsc_offset +</blue>
<yellow>		kvm_scale_tsc(host_tsc, vcpu->arch.l1_tsc_scaling_ratio);</yellow>
}
EXPORT_SYMBOL_GPL(kvm_read_l1_tsc);

u64 kvm_calc_nested_tsc_offset(u64 l1_offset, u64 l2_offset, u64 l2_multiplier)
{
	u64 nested_offset;

<blue>	if (l2_multiplier == kvm_caps.default_tsc_scaling_ratio)</blue>
		nested_offset = l1_offset;
	else
<blue>		nested_offset = mul_s64_u64_shr((s64) l1_offset, l2_multiplier,</blue>
						kvm_caps.tsc_scaling_ratio_frac_bits);

<blue>	nested_offset += l2_offset;</blue>
	return nested_offset;
}
EXPORT_SYMBOL_GPL(kvm_calc_nested_tsc_offset);

<blue>u64 kvm_calc_nested_tsc_multiplier(u64 l1_multiplier, u64 l2_multiplier)</blue>
{
<blue>	if (l2_multiplier != kvm_caps.default_tsc_scaling_ratio)</blue>
<blue>		return mul_u64_u64_shr(l1_multiplier, l2_multiplier,</blue>
				       kvm_caps.tsc_scaling_ratio_frac_bits);

	return l1_multiplier;
<blue>}</blue>
EXPORT_SYMBOL_GPL(kvm_calc_nested_tsc_multiplier);

static void kvm_vcpu_write_tsc_offset(struct kvm_vcpu *vcpu, u64 l1_offset)
{
<blue>	trace_kvm_write_tsc_offset(vcpu->vcpu_id,</blue>
				   vcpu-&gt;arch.l1_tsc_offset,
				   l1_offset);

<blue>	vcpu->arch.l1_tsc_offset = l1_offset;</blue>

	/*
	 * If we are here because L1 chose not to trap WRMSR to TSC then
	 * according to the spec this should set L1&#x27;s TSC (as opposed to
	 * setting L1&#x27;s offset for L2).
	 */
	if (is_guest_mode(vcpu))
<blue>		vcpu->arch.tsc_offset = kvm_calc_nested_tsc_offset(</blue>
			l1_offset,
			static_call(kvm_x86_get_l2_tsc_offset)(vcpu),
			static_call(kvm_x86_get_l2_tsc_multiplier)(vcpu));
	else
		vcpu-&gt;arch.tsc_offset = l1_offset;

	static_call(kvm_x86_write_tsc_offset)(vcpu, vcpu-&gt;arch.tsc_offset);
}

static void kvm_vcpu_write_tsc_multiplier(struct kvm_vcpu *vcpu, u64 l1_multiplier)
{
<blue>	vcpu->arch.l1_tsc_scaling_ratio = l1_multiplier;</blue>

	/* Userspace is changing the multiplier while L2 is active */
	if (is_guest_mode(vcpu))
<blue>		vcpu->arch.tsc_scaling_ratio = kvm_calc_nested_tsc_multiplier(</blue>
			l1_multiplier,
			static_call(kvm_x86_get_l2_tsc_multiplier)(vcpu));
	else
		vcpu-&gt;arch.tsc_scaling_ratio = l1_multiplier;

<blue>	if (kvm_caps.has_tsc_control)</blue>
<blue>		static_call(kvm_x86_write_tsc_multiplier)(</blue>
			vcpu, vcpu-&gt;arch.tsc_scaling_ratio);
<blue>}</blue>

<blue>static inline bool kvm_check_tsc_unstable(void)</blue>
{
#ifdef CONFIG_X86_64
	/*
	 * TSC is marked unstable when we&#x27;re running on Hyper-V,
	 * &#x27;TSC page&#x27; clocksource is good.
	 */
<blue>	if (pvclock_gtod_data.clock.vclock_mode == VDSO_CLOCKMODE_HVCLOCK)</blue>
		return false;
#endif
<blue>	return check_tsc_unstable();</blue>
}

/*
 * Infers attempts to synchronize the guest&#x27;s tsc from host writes. Sets the
 * offset for the vcpu and tracks the TSC matching generation that the vcpu
 * participates in.
 */
static void __kvm_synchronize_tsc(struct kvm_vcpu *vcpu, u64 offset, u64 tsc,
				  u64 ns, bool matched)
{
<blue>	struct kvm *kvm = vcpu->kvm;</blue>

	lockdep_assert_held(&amp;kvm-&gt;arch.tsc_write_lock);

	/*
	 * We also track th most recent recorded KHZ, write and time to
	 * allow the matching interval to be extended at each write.
	 */
	kvm-&gt;arch.last_tsc_nsec = ns;
	kvm-&gt;arch.last_tsc_write = tsc;
	kvm-&gt;arch.last_tsc_khz = vcpu-&gt;arch.virtual_tsc_khz;
	kvm-&gt;arch.last_tsc_offset = offset;

	vcpu-&gt;arch.last_guest_tsc = tsc;

	kvm_vcpu_write_tsc_offset(vcpu, offset);

	if (!matched) {
		/*
		 * We split periods of matched TSC writes into generations.
		 * For each generation, we track the original measured
		 * nanosecond time, offset, and write, so if TSCs are in
		 * sync, we can match exact offset, and if not, we can match
		 * exact software computation in compute_guest_tsc()
		 *
		 * These values are tracked in kvm-&gt;arch.cur_xxx variables.
		 */
<blue>		kvm->arch.cur_tsc_generation++;</blue>
		kvm-&gt;arch.cur_tsc_nsec = ns;
		kvm-&gt;arch.cur_tsc_write = tsc;
		kvm-&gt;arch.cur_tsc_offset = offset;
		kvm-&gt;arch.nr_vcpus_matched_tsc = 0;
<blue>	} else if (vcpu->arch.this_tsc_generation != kvm->arch.cur_tsc_generation) {</blue>
<yellow>		kvm->arch.nr_vcpus_matched_tsc++;</yellow>
	}

	/* Keep track of which generation this VCPU has synchronized to */
<blue>	vcpu->arch.this_tsc_generation = kvm->arch.cur_tsc_generation;</blue>
	vcpu-&gt;arch.this_tsc_nsec = kvm-&gt;arch.cur_tsc_nsec;
	vcpu-&gt;arch.this_tsc_write = kvm-&gt;arch.cur_tsc_write;

<blue>	kvm_track_tsc_matching(vcpu);</blue>
<blue>}</blue>

static void kvm_synchronize_tsc(struct kvm_vcpu *vcpu, u64 data)
{
<blue>	struct kvm *kvm = vcpu->kvm;</blue>
	u64 offset, ns, elapsed;
	unsigned long flags;
	bool matched = false;
	bool synchronizing = false;

	raw_spin_lock_irqsave(&amp;kvm-&gt;arch.tsc_write_lock, flags);
	offset = kvm_compute_l1_tsc_offset(vcpu, data);
	ns = get_kvmclock_base_ns();
<blue>	elapsed = ns - kvm->arch.last_tsc_nsec;</blue>

	if (vcpu-&gt;arch.virtual_tsc_khz) {
		if (data == 0) {
			/*
			 * detection of vcpu initialization -- need to sync
			 * with other vCPUs. This particularly helps to keep
			 * kvm_clock stable after CPU hotplug
			 */
			synchronizing = true;
		} else {
<blue>			u64 tsc_exp = kvm->arch.last_tsc_write +</blue>
<blue>						nsec_to_cycles(vcpu, elapsed);</blue>
			u64 tsc_hz = vcpu-&gt;arch.virtual_tsc_khz * 1000LL;
			/*
			 * Special case: TSC write with a small delta (1 second)
			 * of virtual cycle time against real time is
			 * interpreted as an attempt to synchronize the CPU.
			 */
			synchronizing = data &lt; tsc_exp + tsc_hz &amp;&amp;
<blue>					data + tsc_hz > tsc_exp;</blue>
		}
	}

	/*
	 * For a reliable TSC, we can match TSC offsets, and for an unstable
	 * TSC, we add elapsed time in this computation.  We could let the
	 * compensation code attempt to catch up if we fall behind, but
	 * it&#x27;s better to try to match offsets from the beginning.
         */
	if (synchronizing &amp;&amp;
<blue>	    vcpu->arch.virtual_tsc_khz == kvm->arch.last_tsc_khz) {</blue>
<blue>		if (!kvm_check_tsc_unstable()) {</blue>
<blue>			offset = kvm->arch.cur_tsc_offset;</blue>
		} else {
<yellow>			u64 delta = nsec_to_cycles(vcpu, elapsed);</yellow>
			data += delta;
			offset = kvm_compute_l1_tsc_offset(vcpu, data);
		}
		matched = true;
	}

<blue>	__kvm_synchronize_tsc(vcpu, offset, data, ns, matched);</blue>
	raw_spin_unlock_irqrestore(&amp;kvm-&gt;arch.tsc_write_lock, flags);
}

static inline void adjust_tsc_offset_guest(struct kvm_vcpu *vcpu,
					   s64 adjustment)
{
<yellow>	u64 tsc_offset = vcpu->arch.l1_tsc_offset;</yellow>
	kvm_vcpu_write_tsc_offset(vcpu, tsc_offset + adjustment);
}

static inline void adjust_tsc_offset_host(struct kvm_vcpu *vcpu, s64 adjustment)
{
<yellow>	if (vcpu->arch.l1_tsc_scaling_ratio != kvm_caps.default_tsc_scaling_ratio)</yellow>
<yellow>		WARN_ON(adjustment < 0);</yellow>
<yellow>	adjustment = kvm_scale_tsc((u64) adjustment,</yellow>
				   vcpu-&gt;arch.l1_tsc_scaling_ratio);
<yellow>	adjust_tsc_offset_guest(vcpu, adjustment);</yellow>
}

#ifdef CONFIG_X86_64

static u64 read_tsc(void)
{
	u64 ret = (u64)rdtsc_ordered();
	u64 last = pvclock_gtod_data.clock.cycle_last;

	if (likely(ret &gt;= last))
		return ret;

	/*
	 * GCC likes to generate cmov here, but this branch is extremely
	 * predictable (it&#x27;s just a function of time and the likely is
	 * very likely) and there&#x27;s a data dependence, so force GCC
	 * to generate a branch instead.  I don&#x27;t barrier() because
	 * we don&#x27;t actually need a barrier, and if this function
	 * ever gets inlined it will generate worse code.
	 */
	asm volatile (&quot;&quot;);
<yellow>	return last;</yellow>
}

static inline u64 vgettsc(struct pvclock_clock *clock, u64 *tsc_timestamp,
			  int *mode)
{
	long v;
	u64 tsc_pg_val;

<blue>	switch (clock->vclock_mode) {</blue>
	case VDSO_CLOCKMODE_HVCLOCK:
<yellow>		tsc_pg_val = hv_read_tsc_page_tsc(hv_get_tsc_page(),</yellow>
						  tsc_timestamp);
		if (tsc_pg_val != U64_MAX) {
			/* TSC page valid */
<yellow>			*mode = VDSO_CLOCKMODE_HVCLOCK;</yellow>
			v = (tsc_pg_val - clock-&gt;cycle_last) &amp;
				clock-&gt;mask;
		} else {
			/* TSC page invalid */
<yellow>			*mode = VDSO_CLOCKMODE_NONE;</yellow>
		}
		break;
	case VDSO_CLOCKMODE_TSC:
<blue>		*mode = VDSO_CLOCKMODE_TSC;</blue>
<blue>		*tsc_timestamp = read_tsc();</blue>
		v = (*tsc_timestamp - clock-&gt;cycle_last) &amp;
			clock-&gt;mask;
		break;
	default:
<yellow>		*mode = VDSO_CLOCKMODE_NONE;</yellow>
	}

	if (*mode == VDSO_CLOCKMODE_NONE)
<yellow>		*tsc_timestamp = v = 0;</yellow>

<blue>	return v * clock->mult;</blue>
}

static int do_monotonic_raw(s64 *t, u64 *tsc_timestamp)
{
	struct pvclock_gtod_data *gtod = &amp;pvclock_gtod_data;
	unsigned long seq;
	int mode;
	u64 ns;

	do {
<blue>		seq = read_seqcount_begin(&gtod->seq);</blue>
		ns = gtod-&gt;raw_clock.base_cycles;
<blue>		ns += vgettsc(&gtod->raw_clock, tsc_timestamp, &mode);</blue>
<blue>		ns >>= gtod->raw_clock.shift;</blue>
<blue>		ns += ktime_to_ns(ktime_add(gtod->raw_clock.offset, gtod->offs_boot));</blue>
	} while (unlikely(read_seqcount_retry(&amp;gtod-&gt;seq, seq)));
	*t = ns;

	return mode;
}

static int do_realtime(struct timespec64 *ts, u64 *tsc_timestamp)
{
	struct pvclock_gtod_data *gtod = &amp;pvclock_gtod_data;
	unsigned long seq;
	int mode;
	u64 ns;

	do {
<blue>		seq = read_seqcount_begin(&gtod->seq);</blue>
<blue>		ts->tv_sec = gtod->wall_time_sec;</blue>
		ns = gtod-&gt;clock.base_cycles;
		ns += vgettsc(&amp;gtod-&gt;clock, tsc_timestamp, &amp;mode);
<blue>		ns >>= gtod->clock.shift;</blue>
<blue>	} while (unlikely(read_seqcount_retry(&gtod->seq, seq)));</blue>

<blue>	ts->tv_sec += __iter_div_u64_rem(ns, NSEC_PER_SEC, &ns);</blue>
	ts-&gt;tv_nsec = ns;

	return mode;
}

/* returns true if host is using TSC based clocksource */
static bool kvm_get_time_and_clockread(s64 *kernel_ns, u64 *tsc_timestamp)
{
	/* checked again under seqlock below */
	if (!gtod_is_based_on_tsc(pvclock_gtod_data.clock.vclock_mode))
		return false;

<blue>	return gtod_is_based_on_tsc(do_monotonic_raw(kernel_ns,</blue>
						      tsc_timestamp));
}

/* returns true if host is using TSC based clocksource */
<yellow>static bool kvm_get_walltime_and_clockread(struct timespec64 *ts,</yellow>
					   u64 *tsc_timestamp)
{
	/* checked again under seqlock below */
<blue>	if (!gtod_is_based_on_tsc(pvclock_gtod_data.clock.vclock_mode))</blue>
		return false;

<yellow>	return gtod_is_based_on_tsc(do_realtime(ts, tsc_timestamp));</yellow>
}
#endif

/*
 *
 * Assuming a stable TSC across physical CPUS, and a stable TSC
 * across virtual CPUs, the following condition is possible.
 * Each numbered line represents an event visible to both
 * CPUs at the next numbered event.
 *
 * &quot;timespecX&quot; represents host monotonic time. &quot;tscX&quot; represents
 * RDTSC value.
 *
 * 		VCPU0 on CPU0		|	VCPU1 on CPU1
 *
 * 1.  read timespec0,tsc0
 * 2.					| timespec1 = timespec0 + N
 * 					| tsc1 = tsc0 + M
 * 3. transition to guest		| transition to guest
 * 4. ret0 = timespec0 + (rdtsc - tsc0) |
 * 5.				        | ret1 = timespec1 + (rdtsc - tsc1)
 * 				        | ret1 = timespec0 + N + (rdtsc - (tsc0 + M))
 *
 * Since ret0 update is visible to VCPU1 at time 5, to obey monotonicity:
 *
 * 	- ret0 &lt; ret1
 *	- timespec0 + (rdtsc - tsc0) &lt; timespec0 + N + (rdtsc - (tsc0 + M))
 *		...
 *	- 0 &lt; N - M =&gt; M &lt; N
 *
 * That is, when timespec0 != timespec1, M &lt; N. Unfortunately that is not
 * always the case (the difference between two distinct xtime instances
 * might be smaller then the difference between corresponding TSC reads,
 * when updating guest vcpus pvclock areas).
 *
 * To avoid that problem, do not allow visibility of distinct
 * system_timestamp/tsc_timestamp values simultaneously: use a master
 * copy of host monotonic time values. Update that master copy
 * in lockstep.
 *
 * Rely on synchronization of host TSCs and guest TSCs for monotonicity.
 *
 */

static void pvclock_update_vm_gtod_copy(struct kvm *kvm)
<blue>{</blue>
#ifdef CONFIG_X86_64
	struct kvm_arch *ka = &amp;kvm-&gt;arch;
	int vclock_mode;
	bool host_tsc_clocksource, vcpus_matched;

	lockdep_assert_held(&amp;kvm-&gt;arch.tsc_write_lock);
<blue>	vcpus_matched = (ka->nr_vcpus_matched_tsc + 1 ==</blue>
			atomic_read(&amp;kvm-&gt;online_vcpus));

	/*
	 * If the host uses TSC clock, then passthrough TSC as stable
	 * to the guest.
	 */
<blue>	host_tsc_clocksource = kvm_get_time_and_clockread(</blue>
					&amp;ka-&gt;master_kernel_ns,
					&amp;ka-&gt;master_cycle_now);

<blue>	ka->use_master_clock = host_tsc_clocksource && vcpus_matched</blue>
<blue>				&& !ka->backwards_tsc_observed</blue>
<blue>				&& !ka->boot_vcpu_runs_old_kvmclock;</blue>

	if (ka-&gt;use_master_clock)
<blue>		atomic_set(&kvm_guest_has_master_clock, 1);</blue>

<blue>	vclock_mode = pvclock_gtod_data.clock.vclock_mode;</blue>
<blue>	trace_kvm_update_master_clock(ka->use_master_clock, vclock_mode,</blue>
					vcpus_matched);
#endif
}

static void kvm_make_mclock_inprogress_request(struct kvm *kvm)
{
<yellow>	kvm_make_all_cpus_request(kvm, KVM_REQ_MCLOCK_INPROGRESS);</yellow>
}

static void __kvm_start_pvclock_update(struct kvm *kvm)
{
<yellow>	raw_spin_lock_irq(&kvm->arch.tsc_write_lock);</yellow>
	write_seqcount_begin(&amp;kvm-&gt;arch.pvclock_sc);
}

static void kvm_start_pvclock_update(struct kvm *kvm)
{
	kvm_make_mclock_inprogress_request(kvm);

	/* no guest entries from this point */
	__kvm_start_pvclock_update(kvm);
}

static void kvm_end_pvclock_update(struct kvm *kvm)
<blue>{</blue>
	struct kvm_arch *ka = &amp;kvm-&gt;arch;
	struct kvm_vcpu *vcpu;
	unsigned long i;

<blue>	write_seqcount_end(&ka->pvclock_sc);</blue>
	raw_spin_unlock_irq(&amp;ka-&gt;tsc_write_lock);
	kvm_for_each_vcpu(i, vcpu, kvm)
<blue>		kvm_make_request(KVM_REQ_CLOCK_UPDATE, vcpu);</blue>

	/* guest entries allowed */
<blue>	kvm_for_each_vcpu(i, vcpu, kvm)</blue>
<blue>		kvm_clear_request(KVM_REQ_MCLOCK_INPROGRESS, vcpu);</blue>
}

static void kvm_update_masterclock(struct kvm *kvm)
{
	kvm_hv_request_tsc_page_update(kvm);
	kvm_start_pvclock_update(kvm);
	pvclock_update_vm_gtod_copy(kvm);
	kvm_end_pvclock_update(kvm);
}

/* Called within read_seqcount_begin/retry for kvm-&gt;pvclock_sc.  */
static void __get_kvmclock(struct kvm *kvm, struct kvm_clock_data *data)
<blue>{</blue>
	struct kvm_arch *ka = &amp;kvm-&gt;arch;
	struct pvclock_vcpu_time_info hv_clock;

	/* both __this_cpu_read() and rdtsc() should be on the same cpu */
<blue>	get_cpu();</blue>

	data-&gt;flags = 0;
<blue>	if (ka->use_master_clock && __this_cpu_read(cpu_tsc_khz)) {</blue>
#ifdef CONFIG_X86_64
		struct timespec64 ts;

<blue>		if (kvm_get_walltime_and_clockread(&ts, &data->host_tsc)) {</blue>
<blue>			data->realtime = ts.tv_nsec + NSEC_PER_SEC * ts.tv_sec;</blue>
			data-&gt;flags |= KVM_CLOCK_REALTIME | KVM_CLOCK_HOST_TSC;
		} else
#endif
<yellow>		data->host_tsc = rdtsc();</yellow>

<blue>		data->flags |= KVM_CLOCK_TSC_STABLE;</blue>
		hv_clock.tsc_timestamp = ka-&gt;master_cycle_now;
		hv_clock.system_time = ka-&gt;master_kernel_ns + ka-&gt;kvmclock_offset;
<blue>		kvm_get_time_scale(NSEC_PER_SEC, __this_cpu_read(cpu_tsc_khz) * 1000LL,</blue>
				   &amp;hv_clock.tsc_shift,
				   &amp;hv_clock.tsc_to_system_mul);
<blue>		data->clock = __pvclock_read_cycles(&hv_clock, data->host_tsc);</blue>
	} else {
<blue>		data->clock = get_kvmclock_base_ns() + ka->kvmclock_offset;</blue>
	}

<blue>	put_cpu();</blue>
}

static void get_kvmclock(struct kvm *kvm, struct kvm_clock_data *data)
{
	struct kvm_arch *ka = &amp;kvm-&gt;arch;
	unsigned seq;

	do {
<blue>		seq = read_seqcount_begin(&ka->pvclock_sc);</blue>
<blue>		__get_kvmclock(kvm, data);</blue>
	} while (read_seqcount_retry(&amp;ka-&gt;pvclock_sc, seq));
}

u64 get_kvmclock_ns(struct kvm *kvm)
{
	struct kvm_clock_data data;

<blue>	get_kvmclock(kvm, &data);</blue>
<yellow>	return data.clock;</yellow>
}

static void kvm_setup_guest_pvclock(struct kvm_vcpu *v,
				    struct gfn_to_pfn_cache *gpc,
				    unsigned int offset)
{
	struct kvm_vcpu_arch *vcpu = &amp;v-&gt;arch;
	struct pvclock_vcpu_time_info *guest_hv_clock;
	unsigned long flags;

<yellow>	read_lock_irqsave(&gpc->lock, flags);</yellow>
<yellow>	while (!kvm_gfn_to_pfn_cache_check(v->kvm, gpc, gpc->gpa,</yellow>
					   offset + sizeof(*guest_hv_clock))) {
<yellow>		read_unlock_irqrestore(&gpc->lock, flags);</yellow>

		if (kvm_gfn_to_pfn_cache_refresh(v-&gt;kvm, gpc, gpc-&gt;gpa,
						 offset + sizeof(*guest_hv_clock)))
			return;

<yellow>		read_lock_irqsave(&gpc->lock, flags);</yellow>
	}

<yellow>	guest_hv_clock = (void *)(gpc->khva + offset);</yellow>

	/*
	 * This VCPU is paused, but it&#x27;s legal for a guest to read another
	 * VCPU&#x27;s kvmclock, so we really have to follow the specification where
	 * it says that version is odd if data is being modified, and even after
	 * it is consistent.
	 */

	guest_hv_clock-&gt;version = vcpu-&gt;hv_clock.version = (guest_hv_clock-&gt;version + 1) | 1;
	smp_wmb();

	/* retain PVCLOCK_GUEST_STOPPED if set in guest copy */
	vcpu-&gt;hv_clock.flags |= (guest_hv_clock-&gt;flags &amp; PVCLOCK_GUEST_STOPPED);

<yellow>	if (vcpu->pvclock_set_guest_stopped_request) {</yellow>
<yellow>		vcpu->hv_clock.flags |= PVCLOCK_GUEST_STOPPED;</yellow>
		vcpu-&gt;pvclock_set_guest_stopped_request = false;
	}

<yellow>	memcpy(guest_hv_clock, &vcpu->hv_clock, sizeof(*guest_hv_clock));</yellow>
	smp_wmb();

	guest_hv_clock-&gt;version = ++vcpu-&gt;hv_clock.version;

	mark_page_dirty_in_slot(v-&gt;kvm, gpc-&gt;memslot, gpc-&gt;gpa &gt;&gt; PAGE_SHIFT);
	read_unlock_irqrestore(&amp;gpc-&gt;lock, flags);

<yellow>	trace_kvm_pvclock_update(v->vcpu_id, &vcpu->hv_clock);</yellow>
<yellow>}</yellow>

static int kvm_guest_time_update(struct kvm_vcpu *v)
{
	unsigned long flags, tgt_tsc_khz;
	unsigned seq;
	struct kvm_vcpu_arch *vcpu = &amp;v-&gt;arch;
<blue>	struct kvm_arch *ka = &v->kvm->arch;</blue>
	s64 kernel_ns;
	u64 tsc_timestamp, host_tsc;
	u8 pvclock_flags;
	bool use_master_clock;

	kernel_ns = 0;
	host_tsc = 0;

	/*
	 * If the host uses TSC clock, then passthrough TSC as stable
	 * to the guest.
	 */
	do {
<blue>		seq = read_seqcount_begin(&ka->pvclock_sc);</blue>
<blue>		use_master_clock = ka->use_master_clock;</blue>
		if (use_master_clock) {
<blue>			host_tsc = ka->master_cycle_now;</blue>
			kernel_ns = ka-&gt;master_kernel_ns;
		}
<blue>	} while (read_seqcount_retry(&ka->pvclock_sc, seq));</blue>

	/* Keep irq disabled to prevent changes to the clock */
<blue>	local_irq_save(flags);</blue>
	tgt_tsc_khz = __this_cpu_read(cpu_tsc_khz);
	if (unlikely(tgt_tsc_khz == 0)) {
<yellow>		local_irq_restore(flags);</yellow>
<yellow>		kvm_make_request(KVM_REQ_CLOCK_UPDATE, v);</yellow>
		return 1;
	}
<blue>	if (!use_master_clock) {</blue>
<yellow>		host_tsc = rdtsc();</yellow>
		kernel_ns = get_kvmclock_base_ns();
	}

<blue>	tsc_timestamp = kvm_read_l1_tsc(v, host_tsc);</blue>

	/*
	 * We may have to catch up the TSC to match elapsed wall clock
	 * time for two reasons, even if kvmclock is used.
	 *   1) CPU could have been running below the maximum TSC rate
	 *   2) Broken TSC compensation resets the base at each VCPU
	 *      entry to avoid unknown leaps of TSC even when running
	 *      again on the same CPU.  This may cause apparent elapsed
	 *      time to disappear, and the guest to stand still or run
	 *	very slowly.
	 */
<blue>	if (vcpu->tsc_catchup) {</blue>
<yellow>		u64 tsc = compute_guest_tsc(v, kernel_ns);</yellow>
		if (tsc &gt; tsc_timestamp) {
<yellow>			adjust_tsc_offset_guest(v, tsc - tsc_timestamp);</yellow>
			tsc_timestamp = tsc;
		}
	}

<blue>	local_irq_restore(flags);</blue>

	/* With all the info we got, fill in the values */

<blue>	if (kvm_caps.has_tsc_control)</blue>
<blue>		tgt_tsc_khz = kvm_scale_tsc(tgt_tsc_khz,</blue>
					    v-&gt;arch.l1_tsc_scaling_ratio);

<blue>	if (unlikely(vcpu->hw_tsc_khz != tgt_tsc_khz)) {</blue>
<blue>		kvm_get_time_scale(NSEC_PER_SEC, tgt_tsc_khz * 1000LL,</blue>
				   &amp;vcpu-&gt;hv_clock.tsc_shift,
				   &amp;vcpu-&gt;hv_clock.tsc_to_system_mul);
		vcpu-&gt;hw_tsc_khz = tgt_tsc_khz;
	}

<blue>	vcpu->hv_clock.tsc_timestamp = tsc_timestamp;</blue>
	vcpu-&gt;hv_clock.system_time = kernel_ns + v-&gt;kvm-&gt;arch.kvmclock_offset;
	vcpu-&gt;last_guest_tsc = tsc_timestamp;

	/* If the host uses TSC clocksource, then it is stable */
	pvclock_flags = 0;
	if (use_master_clock)
		pvclock_flags |= PVCLOCK_TSC_STABLE_BIT;

	vcpu-&gt;hv_clock.flags = pvclock_flags;

<blue>	if (vcpu->pv_time.active)</blue>
<yellow>		kvm_setup_guest_pvclock(v, &vcpu->pv_time, 0);</yellow>
<blue>	if (vcpu->xen.vcpu_info_cache.active)</blue>
<yellow>		kvm_setup_guest_pvclock(v, &vcpu->xen.vcpu_info_cache,</yellow>
					offsetof(struct compat_vcpu_info, time));
<blue>	if (vcpu->xen.vcpu_time_info_cache.active)</blue>
<yellow>		kvm_setup_guest_pvclock(v, &vcpu->xen.vcpu_time_info_cache, 0);</yellow>
<blue>	kvm_hv_setup_tsc_page(v->kvm, &vcpu->hv_clock);</blue>
	return 0;
<blue>}</blue>

/*
 * kvmclock updates which are isolated to a given vcpu, such as
 * vcpu-&gt;cpu migration, should not allow system_timestamp from
 * the rest of the vcpus to remain static. Otherwise ntp frequency
 * correction applies to one vcpu&#x27;s system_timestamp but not
 * the others.
 *
 * So in those cases, request a kvmclock update for all vcpus.
 * We need to rate-limit these requests though, as they can
 * considerably slow guests that have a large number of vcpus.
 * The time for a remote vcpu to update its kvmclock is bound
 * by the delay we use to rate-limit the updates.
 */

#define KVMCLOCK_UPDATE_DELAY msecs_to_jiffies(100)

static void kvmclock_update_fn(struct work_struct *work)
<yellow>{</yellow>
	unsigned long i;
	struct delayed_work *dwork = to_delayed_work(work);
	struct kvm_arch *ka = container_of(dwork, struct kvm_arch,
					   kvmclock_update_work);
	struct kvm *kvm = container_of(ka, struct kvm, arch);
	struct kvm_vcpu *vcpu;

<yellow>	kvm_for_each_vcpu(i, vcpu, kvm) {</yellow>
<yellow>		kvm_make_request(KVM_REQ_CLOCK_UPDATE, vcpu);</yellow>
		kvm_vcpu_kick(vcpu);
	}
}

static void kvm_gen_kvmclock_update(struct kvm_vcpu *v)
{
	struct kvm *kvm = v-&gt;kvm;

	kvm_make_request(KVM_REQ_CLOCK_UPDATE, v);
	schedule_delayed_work(&amp;kvm-&gt;arch.kvmclock_update_work,
					KVMCLOCK_UPDATE_DELAY);
}

#define KVMCLOCK_SYNC_PERIOD (300 * HZ)

<yellow>static void kvmclock_sync_fn(struct work_struct *work)</yellow>
{
	struct delayed_work *dwork = to_delayed_work(work);
	struct kvm_arch *ka = container_of(dwork, struct kvm_arch,
					   kvmclock_sync_work);
	struct kvm *kvm = container_of(ka, struct kvm, arch);

<yellow>	if (!kvmclock_periodic_sync)</yellow>
		return;

<yellow>	schedule_delayed_work(&kvm->arch.kvmclock_update_work, 0);</yellow>
	schedule_delayed_work(&amp;kvm-&gt;arch.kvmclock_sync_work,
					KVMCLOCK_SYNC_PERIOD);
<yellow>}</yellow>

/* These helpers are safe iff @msr is known to be an MCx bank MSR. */
static bool is_mci_control_msr(u32 msr)
{
<blue>	return (msr & 3) == 0;</blue>
}
static bool is_mci_status_msr(u32 msr)
{
	return (msr &amp; 3) == 1;
}

/*
 * On AMD, HWCR[McStatusWrEn] controls whether setting MCi_STATUS results in #GP.
 */
static bool can_set_mci_status(struct kvm_vcpu *vcpu)
{
	/* McStatusWrEn enabled? */
<yellow>	if (guest_cpuid_is_amd_or_hygon(vcpu))</yellow>
<yellow>		return !!(vcpu->arch.msr_hwcr & BIT_ULL(18));</yellow>

	return false;
}

static int set_msr_mce(struct kvm_vcpu *vcpu, struct msr_data *msr_info)
{
<blue>	u64 mcg_cap = vcpu->arch.mcg_cap;</blue>
	unsigned bank_num = mcg_cap &amp; 0xff;
	u32 msr = msr_info-&gt;index;
	u64 data = msr_info-&gt;data;
	u32 offset, last_msr;

	switch (msr) {
	case MSR_IA32_MCG_STATUS:
<blue>		vcpu->arch.mcg_status = data;</blue>
		break;
	case MSR_IA32_MCG_CTL:
<blue>		if (!(mcg_cap & MCG_CTL_P) &&</blue>
<yellow>		    (data || !msr_info->host_initiated))</yellow>
			return 1;
<blue>		if (data != 0 && data != ~(u64)0)</blue>
			return 1;
<blue>		vcpu->arch.mcg_ctl = data;</blue>
		break;
	case MSR_IA32_MC0_CTL2 ... MSR_IA32_MCx_CTL2(KVM_MAX_MCE_BANKS) - 1:
<yellow>		last_msr = MSR_IA32_MCx_CTL2(bank_num) - 1;</yellow>
		if (msr &gt; last_msr)
			return 1;

<yellow>		if (!(mcg_cap & MCG_CMCI_P) && (data || !msr_info->host_initiated))</yellow>
			return 1;
		/* An attempt to write a 1 to a reserved bit raises #GP */
<yellow>		if (data & ~(MCI_CTL2_CMCI_EN | MCI_CTL2_CMCI_THRESHOLD_MASK))</yellow>
			return 1;
<yellow>		offset = array_index_nospec(msr - MSR_IA32_MC0_CTL2,</yellow>
					    last_msr + 1 - MSR_IA32_MC0_CTL2);
		vcpu-&gt;arch.mci_ctl2_banks[offset] = data;
		break;
	case MSR_IA32_MC0_CTL ... MSR_IA32_MCx_CTL(KVM_MAX_MCE_BANKS) - 1:
<blue>		last_msr = MSR_IA32_MCx_CTL(bank_num) - 1;</blue>
		if (msr &gt; last_msr)
			return 1;

		/*
		 * Only 0 or all 1s can be written to IA32_MCi_CTL, all other
		 * values are architecturally undefined.  But, some Linux
		 * kernels clear bit 10 in bank 4 to workaround a BIOS/GART TLB
		 * issue on AMD K8s, allow bit 10 to be clear when setting all
		 * other bits in order to avoid an uncaught #GP in the guest.
		 *
		 * UNIXWARE clears bit 0 of MC1_CTL to ignore correctable,
		 * single-bit ECC data errors.
		 */
<blue>		if (is_mci_control_msr(msr) &&</blue>
<blue>		    data != 0 && (data | (1 << 10) | 1) != ~(u64)0)</blue>
			return 1;

		/*
		 * All CPUs allow writing 0 to MCi_STATUS MSRs to clear the MSR.
		 * AMD-based CPUs allow non-zero values, but if and only if
		 * HWCR[McStatusWrEn] is set.
		 */
<blue>		if (!msr_info->host_initiated && is_mci_status_msr(msr) &&</blue>
<yellow>		    data != 0 && !can_set_mci_status(vcpu))</yellow>
			return 1;

<blue>		offset = array_index_nospec(msr - MSR_IA32_MC0_CTL,</blue>
					    last_msr + 1 - MSR_IA32_MC0_CTL);
		vcpu-&gt;arch.mce_banks[offset] = data;
		break;
	default:
		return 1;
	}
	return 0;
}

static inline bool kvm_pv_async_pf_enabled(struct kvm_vcpu *vcpu)
{
	u64 mask = KVM_ASYNC_PF_ENABLED | KVM_ASYNC_PF_DELIVERY_AS_INT;

<yellow>	return (vcpu->arch.apf.msr_en_val & mask) == mask;</yellow>
}

static int kvm_pv_enable_async_pf(struct kvm_vcpu *vcpu, u64 data)
{
	gpa_t gpa = data &amp; ~0x3f;

	/* Bits 4:5 are reserved, Should be zero */
<blue>	if (data & 0x30)</blue>
		return 1;

<blue>	if (!guest_pv_has(vcpu, KVM_FEATURE_ASYNC_PF_VMEXIT) &&</blue>
<yellow>	    (data & KVM_ASYNC_PF_DELIVERY_AS_PF_VMEXIT))</yellow>
		return 1;

<blue>	if (!guest_pv_has(vcpu, KVM_FEATURE_ASYNC_PF_INT) &&</blue>
<yellow>	    (data & KVM_ASYNC_PF_DELIVERY_AS_INT))</yellow>
		return 1;

<blue>	if (!lapic_in_kernel(vcpu))</blue>
		return data ? 1 : 0;

<blue>	vcpu->arch.apf.msr_en_val = data;</blue>

	if (!kvm_pv_async_pf_enabled(vcpu)) {
<blue>		kvm_clear_async_pf_completion_queue(vcpu);</blue>
<blue>		kvm_async_pf_hash_reset(vcpu);</blue>
		return 0;
	}

<yellow>	if (kvm_gfn_to_hva_cache_init(vcpu->kvm, &vcpu->arch.apf.data, gpa,</yellow>
					sizeof(u64)))
		return 1;

<yellow>	vcpu->arch.apf.send_user_only = !(data & KVM_ASYNC_PF_SEND_ALWAYS);</yellow>
	vcpu-&gt;arch.apf.delivery_as_pf_vmexit = data &amp; KVM_ASYNC_PF_DELIVERY_AS_PF_VMEXIT;

	kvm_async_pf_wakeup_all(vcpu);

	return 0;
}

static int kvm_pv_enable_async_pf_int(struct kvm_vcpu *vcpu, u64 data)
{
	/* Bits 8-63 are reserved */
<blue>	if (data >> 8)</blue>
		return 1;

<blue>	if (!lapic_in_kernel(vcpu))</blue>
		return 1;

<blue>	vcpu->arch.apf.msr_int_val = data;</blue>

	vcpu-&gt;arch.apf.vec = data &amp; KVM_ASYNC_PF_VEC_MASK;

	return 0;
}

static void kvmclock_reset(struct kvm_vcpu *vcpu)
{
<yellow>	kvm_gpc_deactivate(vcpu->kvm, &vcpu->arch.pv_time);</yellow>
	vcpu-&gt;arch.time = 0;
}

static void kvm_vcpu_flush_tlb_all(struct kvm_vcpu *vcpu)
{
	++vcpu-&gt;stat.tlb_flush;
	static_call(kvm_x86_flush_tlb_all)(vcpu);
}

static void kvm_vcpu_flush_tlb_guest(struct kvm_vcpu *vcpu)
{
<yellow>	++vcpu->stat.tlb_flush;</yellow>

<blue>	if (!tdp_enabled) {</blue>
		/*
		 * A TLB flush on behalf of the guest is equivalent to
		 * INVPCID(all), toggling CR4.PGE, etc., which requires
		 * a forced sync of the shadow page tables.  Ensure all the
		 * roots are synced and the guest TLB in hardware is clean.
		 */
<yellow>		kvm_mmu_sync_roots(vcpu);</yellow>
		kvm_mmu_sync_prev_roots(vcpu);
	}

<blue>	static_call(kvm_x86_flush_tlb_guest)(vcpu);</blue>
}


static inline void kvm_vcpu_flush_tlb_current(struct kvm_vcpu *vcpu)
{
	++vcpu-&gt;stat.tlb_flush;
	static_call(kvm_x86_flush_tlb_current)(vcpu);
}

/*
 * Service &quot;local&quot; TLB flush requests, which are specific to the current MMU
 * context.  In addition to the generic event handling in vcpu_enter_guest(),
 * TLB flushes that are targeted at an MMU context also need to be serviced
 * prior before nested VM-Enter/VM-Exit.
 */
void kvm_service_local_tlb_flush_requests(struct kvm_vcpu *vcpu)
{
<blue>	if (kvm_check_request(KVM_REQ_TLB_FLUSH_CURRENT, vcpu))</blue>
		kvm_vcpu_flush_tlb_current(vcpu);

<blue>	if (kvm_check_request(KVM_REQ_TLB_FLUSH_GUEST, vcpu))</blue>
<blue>		kvm_vcpu_flush_tlb_guest(vcpu);</blue>
<blue>}</blue>
EXPORT_SYMBOL_GPL(kvm_service_local_tlb_flush_requests);

static void record_steal_time(struct kvm_vcpu *vcpu)
{
	struct gfn_to_hva_cache *ghc = &amp;vcpu-&gt;arch.st.cache;
	struct kvm_steal_time __user *st;
	struct kvm_memslots *slots;
<blue>	gpa_t gpa = vcpu->arch.st.msr_val & KVM_STEAL_VALID_BITS;</blue>
	u64 steal;
	u32 version;

<yellow>	if (kvm_xen_msr_enabled(vcpu->kvm)) {</yellow>
<yellow>		kvm_xen_runstate_set_running(vcpu);</yellow>
		return;
	}

<blue>	if (!(vcpu->arch.st.msr_val & KVM_MSR_ENABLED))</blue>
		return;

<yellow>	if (WARN_ON_ONCE(current->mm != vcpu->kvm->mm))</yellow>
		return;

	slots = kvm_memslots(vcpu-&gt;kvm);

<yellow>	if (unlikely(slots->generation != ghc->generation ||</yellow>
		     gpa != ghc-&gt;gpa ||
		     kvm_is_error_hva(ghc-&gt;hva) || !ghc-&gt;memslot)) {
		/* We rely on the fact that it fits in a single page. */
		BUILD_BUG_ON((sizeof(*st) - 1) &amp; KVM_STEAL_VALID_BITS);

<yellow>		if (kvm_gfn_to_hva_cache_init(vcpu->kvm, ghc, gpa, sizeof(*st)) ||</yellow>
<yellow>		    kvm_is_error_hva(ghc->hva) || !ghc->memslot)</yellow>
			return;
	}

	st = (struct kvm_steal_time __user *)ghc-&gt;hva;
	/*
	 * Doing a TLB flush here, on the guest&#x27;s behalf, can avoid
	 * expensive IPIs.
	 */
<yellow>	if (guest_pv_has(vcpu, KVM_FEATURE_PV_TLB_FLUSH)) {</yellow>
		u8 st_preempted = 0;
		int err = -EFAULT;

<yellow>		if (!user_access_begin(st, sizeof(*st)))</yellow>
			return;

		asm volatile(&quot;1: xchgb %0, %2\n&quot;
			     &quot;xor %1, %1\n&quot;
			     &quot;2:\n&quot;
			     _ASM_EXTABLE_UA(1b, 2b)
			     : &quot;+q&quot; (st_preempted),
			       &quot;+&amp;r&quot; (err),
			       &quot;+m&quot; (st-&gt;preempted));
		if (err)
			goto out;

<yellow>		user_access_end();</yellow>

		vcpu-&gt;arch.st.preempted = 0;

<yellow>		trace_kvm_pv_tlb_flush(vcpu->vcpu_id,</yellow>
				       st_preempted &amp; KVM_VCPU_FLUSH_TLB);
<yellow>		if (st_preempted & KVM_VCPU_FLUSH_TLB)</yellow>
<yellow>			kvm_vcpu_flush_tlb_guest(vcpu);</yellow>

<yellow>		if (!user_access_begin(st, sizeof(*st)))</yellow>
			goto dirty;
	} else {
<yellow>		if (!user_access_begin(st, sizeof(*st)))</yellow>
			return;

		unsafe_put_user(0, &amp;st-&gt;preempted, out);
<yellow>		vcpu->arch.st.preempted = 0;</yellow>
	}

<yellow>	unsafe_get_user(version, &st->version, out);</yellow>
<yellow>	if (version & 1)</yellow>
<yellow>		version += 1;  /* first time write, random junk */</yellow>

<yellow>	version += 1;</yellow>
	unsafe_put_user(version, &amp;st-&gt;version, out);

	smp_wmb();

<yellow>	unsafe_get_user(steal, &st->steal, out);</yellow>
<yellow>	steal += current->sched_info.run_delay -</yellow>
		vcpu-&gt;arch.st.last_steal;
	vcpu-&gt;arch.st.last_steal = current-&gt;sched_info.run_delay;
	unsafe_put_user(steal, &amp;st-&gt;steal, out);

<yellow>	version += 1;</yellow>
	unsafe_put_user(version, &amp;st-&gt;version, out);

 out:
<yellow>	user_access_end();</yellow>
 dirty:
<yellow>	mark_page_dirty_in_slot(vcpu->kvm, ghc->memslot, gpa_to_gfn(ghc->gpa));</yellow>
<blue>}</blue>

int kvm_set_msr_common(struct kvm_vcpu *vcpu, struct msr_data *msr_info)
<blue>{</blue>
	bool pr = false;
<blue>	u32 msr = msr_info->index;</blue>
	u64 data = msr_info-&gt;data;

<blue>	if (msr && msr == vcpu->kvm->arch.xen_hvm_config.msr)</blue>
<yellow>		return kvm_xen_write_hypercall_page(vcpu, data);</yellow>

<blue>	switch (msr) {</blue>
	case MSR_AMD64_NB_CFG:
	case MSR_IA32_UCODE_WRITE:
	case MSR_VM_HSAVE_PA:
	case MSR_AMD64_PATCH_LOADER:
	case MSR_AMD64_BU_CFG2:
	case MSR_AMD64_DC_CFG:
	case MSR_F15H_EX_CFG:
		break;

	case MSR_IA32_UCODE_REV:
<blue>		if (msr_info->host_initiated)</blue>
<blue>			vcpu->arch.microcode_version = data;</blue>
		break;
	case MSR_IA32_ARCH_CAPABILITIES:
<blue>		if (!msr_info->host_initiated)</blue>
			return 1;
<blue>		vcpu->arch.arch_capabilities = data;</blue>
		break;
	case MSR_IA32_PERF_CAPABILITIES: {
		struct kvm_msr_entry msr_ent = {.index = msr, .data = 0};

<blue>		if (!msr_info->host_initiated)</blue>
<blue>			return 1;</blue>
<blue>		if (kvm_get_msr_feature(&msr_ent))</blue>
			return 1;
<blue>		if (data & ~msr_ent.data)</blue>
			return 1;

<blue>		vcpu->arch.perf_capabilities = data;</blue>
		kvm_pmu_refresh(vcpu);
		return 0;
	}
	case MSR_EFER:
<blue>		return set_efer(vcpu, msr_info);</blue>
	case MSR_K7_HWCR:
		data &amp;= ~(u64)0x40;	/* ignore flush filter disable */
		data &amp;= ~(u64)0x100;	/* ignore ignne emulation enable */
<yellow>		data &= ~(u64)0x8;	/* ignore TLB cache disable */</yellow>

		/* Handle McStatusWrEn */
		if (data == BIT_ULL(18)) {
<yellow>			vcpu->arch.msr_hwcr = data;</yellow>
<yellow>		} else if (data != 0) {</yellow>
<yellow>			vcpu_unimpl(vcpu, "unimplemented HWCR wrmsr: 0x%llx\n",</yellow>
				    data);
			return 1;
		}
		break;
	case MSR_FAM10H_MMIO_CONF_BASE:
<yellow>		if (data != 0) {</yellow>
<yellow>			vcpu_unimpl(vcpu, "unimplemented MMIO_CONF_BASE wrmsr: "</yellow>
				    &quot;0x%llx\n&quot;, data);
			return 1;
		}
		break;
	case 0x200 ... MSR_IA32_MC0_CTL2 - 1:
	case MSR_IA32_MCx_CTL2(KVM_MAX_MCE_BANKS) ... 0x2ff:
<blue>		return kvm_mtrr_set_msr(vcpu, msr, data);</blue>
	case MSR_IA32_APICBASE:
<blue>		return kvm_set_apic_base(vcpu, msr_info);</blue>
	case APIC_BASE_MSR ... APIC_BASE_MSR + 0xff:
<blue>		return kvm_x2apic_msr_write(vcpu, msr, data);</blue>
	case MSR_IA32_TSC_DEADLINE:
<blue>		kvm_set_lapic_tscdeadline_msr(vcpu, data);</blue>
		break;
	case MSR_IA32_TSC_ADJUST:
<blue>		if (guest_cpuid_has(vcpu, X86_FEATURE_TSC_ADJUST)) {</blue>
<blue>			if (!msr_info->host_initiated) {</blue>
<yellow>				s64 adj = data - vcpu->arch.ia32_tsc_adjust_msr;</yellow>
				adjust_tsc_offset_guest(vcpu, adj);
				/* Before back to guest, tsc_timestamp must be adjusted
				 * as well, otherwise guest&#x27;s percpu pvclock time could jump.
				 */
				kvm_make_request(KVM_REQ_CLOCK_UPDATE, vcpu);
			}
<blue>			vcpu->arch.ia32_tsc_adjust_msr = data;</blue>
		}
		break;
	case MSR_IA32_MISC_ENABLE: {
<blue>		u64 old_val = vcpu->arch.ia32_misc_enable_msr;</blue>

<blue>		if (!msr_info->host_initiated) {</blue>
			/* RO bits */
<yellow>			if ((old_val ^ data) & MSR_IA32_MISC_ENABLE_PMU_RO_MASK)</yellow>
				return 1;

			/* R bits, i.e. writes are ignored, but don&#x27;t fault. */
<yellow>			data = data & ~MSR_IA32_MISC_ENABLE_EMON;</yellow>
			data |= old_val &amp; MSR_IA32_MISC_ENABLE_EMON;
		}

<blue>		if (!kvm_check_has_quirk(vcpu->kvm, KVM_X86_QUIRK_MISC_ENABLE_NO_MWAIT) &&</blue>
<yellow>		    ((old_val ^ data)  & MSR_IA32_MISC_ENABLE_MWAIT)) {</yellow>
<yellow>			if (!guest_cpuid_has(vcpu, X86_FEATURE_XMM3))</yellow>
				return 1;
<yellow>			vcpu->arch.ia32_misc_enable_msr = data;</yellow>
			kvm_update_cpuid_runtime(vcpu);
		} else {
<blue>			vcpu->arch.ia32_misc_enable_msr = data;</blue>
		}
		break;
	}
	case MSR_IA32_SMBASE:
<blue>		if (!msr_info->host_initiated)</blue>
			return 1;
<blue>		vcpu->arch.smbase = data;</blue>
		break;
	case MSR_IA32_POWER_CTL:
<yellow>		vcpu->arch.msr_ia32_power_ctl = data;</yellow>
		break;
	case MSR_IA32_TSC:
<blue>		if (msr_info->host_initiated) {</blue>
<blue>			kvm_synchronize_tsc(vcpu, data);</blue>
		} else {
<blue>			u64 adj = kvm_compute_l1_tsc_offset(vcpu, data) - vcpu->arch.l1_tsc_offset;</blue>
			adjust_tsc_offset_guest(vcpu, adj);
			vcpu-&gt;arch.ia32_tsc_adjust_msr += adj;
		}
		break;
	case MSR_IA32_XSS:
<blue>		if (!msr_info->host_initiated &&</blue>
<yellow>		    !guest_cpuid_has(vcpu, X86_FEATURE_XSAVES))</yellow>
			return 1;
		/*
		 * KVM supports exposing PT to the guest, but does not support
		 * IA32_XSS[bit 8]. Guests have to use RDMSR/WRMSR rather than
		 * XSAVES/XRSTORS to save/restore PT MSRs.
		 */
<blue>		if (data & ~kvm_caps.supported_xss)</blue>
			return 1;
<blue>		vcpu->arch.ia32_xss = data;</blue>
		kvm_update_cpuid_runtime(vcpu);
		break;
	case MSR_SMI_COUNT:
<blue>		if (!msr_info->host_initiated)</blue>
			return 1;
<blue>		vcpu->arch.smi_count = data;</blue>
		break;
	case MSR_KVM_WALL_CLOCK_NEW:
<yellow>		if (!guest_pv_has(vcpu, KVM_FEATURE_CLOCKSOURCE2))</yellow>
			return 1;

<yellow>		vcpu->kvm->arch.wall_clock = data;</yellow>
		kvm_write_wall_clock(vcpu-&gt;kvm, data, 0);
		break;
	case MSR_KVM_WALL_CLOCK:
<blue>		if (!guest_pv_has(vcpu, KVM_FEATURE_CLOCKSOURCE))</blue>
			return 1;

<blue>		vcpu->kvm->arch.wall_clock = data;</blue>
		kvm_write_wall_clock(vcpu-&gt;kvm, data, 0);
		break;
	case MSR_KVM_SYSTEM_TIME_NEW:
<yellow>		if (!guest_pv_has(vcpu, KVM_FEATURE_CLOCKSOURCE2))</yellow>
			return 1;

<yellow>		kvm_write_system_time(vcpu, data, false, msr_info->host_initiated);</yellow>
		break;
	case MSR_KVM_SYSTEM_TIME:
<blue>		if (!guest_pv_has(vcpu, KVM_FEATURE_CLOCKSOURCE))</blue>
			return 1;

<blue>		kvm_write_system_time(vcpu, data, true,  msr_info->host_initiated);</blue>
		break;
	case MSR_KVM_ASYNC_PF_EN:
<blue>		if (!guest_pv_has(vcpu, KVM_FEATURE_ASYNC_PF))</blue>
			return 1;

<blue>		if (kvm_pv_enable_async_pf(vcpu, data))</blue>
			return 1;
		break;
	case MSR_KVM_ASYNC_PF_INT:
<blue>		if (!guest_pv_has(vcpu, KVM_FEATURE_ASYNC_PF_INT))</blue>
			return 1;

<blue>		if (kvm_pv_enable_async_pf_int(vcpu, data))</blue>
			return 1;
		break;
	case MSR_KVM_ASYNC_PF_ACK:
<yellow>		if (!guest_pv_has(vcpu, KVM_FEATURE_ASYNC_PF_INT))</yellow>
			return 1;
<yellow>		if (data & 0x1) {</yellow>
<yellow>			vcpu->arch.apf.pageready_pending = false;</yellow>
			kvm_check_async_pf_completion(vcpu);
		}
		break;
	case MSR_KVM_STEAL_TIME:
<blue>		if (!guest_pv_has(vcpu, KVM_FEATURE_STEAL_TIME))</blue>
			return 1;

		if (unlikely(!sched_info_on()))
			return 1;

<blue>		if (data & KVM_STEAL_RESERVED_MASK)</blue>
			return 1;

<blue>		vcpu->arch.st.msr_val = data;</blue>

		if (!(data &amp; KVM_MSR_ENABLED))
			break;

<yellow>		kvm_make_request(KVM_REQ_STEAL_UPDATE, vcpu);</yellow>

		break;
	case MSR_KVM_PV_EOI_EN:
<blue>		if (!guest_pv_has(vcpu, KVM_FEATURE_PV_EOI))</blue>
			return 1;

<blue>		if (kvm_lapic_set_pv_eoi(vcpu, data, sizeof(u8)))</blue>
			return 1;
		break;

	case MSR_KVM_POLL_CONTROL:
<blue>		if (!guest_pv_has(vcpu, KVM_FEATURE_POLL_CONTROL))</blue>
			return 1;

		/* only enable bit supported */
<blue>		if (data & (-1ULL << 1))</blue>
			return 1;

<blue>		vcpu->arch.msr_kvm_poll_control = data;</blue>
		break;

	case MSR_IA32_MCG_CTL:
	case MSR_IA32_MCG_STATUS:
	case MSR_IA32_MC0_CTL ... MSR_IA32_MCx_CTL(KVM_MAX_MCE_BANKS) - 1:
	case MSR_IA32_MC0_CTL2 ... MSR_IA32_MCx_CTL2(KVM_MAX_MCE_BANKS) - 1:
<blue>		return set_msr_mce(vcpu, msr_info);</blue>

	case MSR_K7_PERFCTR0 ... MSR_K7_PERFCTR3:
	case MSR_P6_PERFCTR0 ... MSR_P6_PERFCTR1:
		pr = true;
		fallthrough;
	case MSR_K7_EVNTSEL0 ... MSR_K7_EVNTSEL3:
	case MSR_P6_EVNTSEL0 ... MSR_P6_EVNTSEL1:
<blue>		if (kvm_pmu_is_valid_msr(vcpu, msr))</blue>
			return kvm_pmu_set_msr(vcpu, msr_info);

<yellow>		if (pr || data != 0)</yellow>
<yellow>			vcpu_unimpl(vcpu, "disabled perfctr wrmsr: "</yellow>
				    &quot;0x%x data 0x%llx\n&quot;, msr, data);
		break;
	case MSR_K7_CLK_CTL:
		/*
		 * Ignore all writes to this no longer documented MSR.
		 * Writes are only relevant for old K7 processors,
		 * all pre-dating SVM, but a recommended workaround from
		 * AMD for these chips. It is possible to specify the
		 * affected processor models on the command line, hence
		 * the need to ignore the workaround.
		 */
		break;
	case HV_X64_MSR_GUEST_OS_ID ... HV_X64_MSR_SINT15:
	case HV_X64_MSR_SYNDBG_CONTROL ... HV_X64_MSR_SYNDBG_PENDING_BUFFER:
	case HV_X64_MSR_SYNDBG_OPTIONS:
	case HV_X64_MSR_CRASH_P0 ... HV_X64_MSR_CRASH_P4:
	case HV_X64_MSR_CRASH_CTL:
	case HV_X64_MSR_STIMER0_CONFIG ... HV_X64_MSR_STIMER3_COUNT:
	case HV_X64_MSR_REENLIGHTENMENT_CONTROL:
	case HV_X64_MSR_TSC_EMULATION_CONTROL:
	case HV_X64_MSR_TSC_EMULATION_STATUS:
<blue>		return kvm_hv_set_msr_common(vcpu, msr, data,</blue>
<blue>					     msr_info->host_initiated);</blue>
	case MSR_IA32_BBL_CR_CTL3:
		/* Drop writes to this legacy MSR -- see rdmsr
		 * counterpart for further detail.
		 */
<yellow>		if (report_ignored_msrs)</yellow>
<yellow>			vcpu_unimpl(vcpu, "ignored wrmsr: 0x%x data 0x%llx\n",</yellow>
				msr, data);
		break;
	case MSR_AMD64_OSVW_ID_LENGTH:
<yellow>		if (!guest_cpuid_has(vcpu, X86_FEATURE_OSVW))</yellow>
			return 1;
<yellow>		vcpu->arch.osvw.length = data;</yellow>
		break;
	case MSR_AMD64_OSVW_STATUS:
<yellow>		if (!guest_cpuid_has(vcpu, X86_FEATURE_OSVW))</yellow>
			return 1;
<yellow>		vcpu->arch.osvw.status = data;</yellow>
		break;
	case MSR_PLATFORM_INFO:
<yellow>		if (!msr_info->host_initiated ||</yellow>
<yellow>		    (!(data & MSR_PLATFORM_INFO_CPUID_FAULT) &&</yellow>
<yellow>		     cpuid_fault_enabled(vcpu)))</yellow>
			return 1;
<yellow>		vcpu->arch.msr_platform_info = data;</yellow>
		break;
	case MSR_MISC_FEATURES_ENABLES:
<yellow>		if (data & ~MSR_MISC_FEATURES_ENABLES_CPUID_FAULT ||</yellow>
		    (data &amp; MSR_MISC_FEATURES_ENABLES_CPUID_FAULT &amp;&amp;
<yellow>		     !supports_cpuid_fault(vcpu)))</yellow>
			return 1;
<yellow>		vcpu->arch.msr_misc_features_enables = data;</yellow>
		break;
#ifdef CONFIG_X86_64
	case MSR_IA32_XFD:
<yellow>		if (!msr_info->host_initiated &&</yellow>
<yellow>		    !guest_cpuid_has(vcpu, X86_FEATURE_XFD))</yellow>
			return 1;

<yellow>		if (data & ~kvm_guest_supported_xfd(vcpu))</yellow>
			return 1;

<yellow>		fpu_update_guest_xfd(&vcpu->arch.guest_fpu, data);</yellow>
		break;
	case MSR_IA32_XFD_ERR:
<yellow>		if (!msr_info->host_initiated &&</yellow>
<yellow>		    !guest_cpuid_has(vcpu, X86_FEATURE_XFD))</yellow>
			return 1;

<yellow>		if (data & ~kvm_guest_supported_xfd(vcpu))</yellow>
			return 1;

<yellow>		vcpu->arch.guest_fpu.xfd_err = data;</yellow>
		break;
#endif
	case MSR_IA32_PEBS_ENABLE:
	case MSR_IA32_DS_AREA:
	case MSR_PEBS_DATA_CFG:
	case MSR_F15H_PERF_CTL0 ... MSR_F15H_PERF_CTR5:
<yellow>		if (kvm_pmu_is_valid_msr(vcpu, msr))</yellow>
			return kvm_pmu_set_msr(vcpu, msr_info);
		/*
		 * Userspace is allowed to write &#x27;0&#x27; to MSRs that KVM reports
		 * as to-be-saved, even if an MSRs isn&#x27;t fully supported.
		 */
<yellow>		return !msr_info->host_initiated || data;</yellow>
	default:
<blue>		if (kvm_pmu_is_valid_msr(vcpu, msr))</blue>
<blue>			return kvm_pmu_set_msr(vcpu, msr_info);</blue>
		return KVM_MSR_RET_INVALID;
	}
	return 0;
}
EXPORT_SYMBOL_GPL(kvm_set_msr_common);

static int get_msr_mce(struct kvm_vcpu *vcpu, u32 msr, u64 *pdata, bool host)
{
	u64 data;
<blue>	u64 mcg_cap = vcpu->arch.mcg_cap;</blue>
	unsigned bank_num = mcg_cap &amp; 0xff;
	u32 offset, last_msr;

	switch (msr) {
	case MSR_IA32_P5_MC_ADDR:
	case MSR_IA32_P5_MC_TYPE:
		data = 0;
		break;
	case MSR_IA32_MCG_CAP:
		data = vcpu-&gt;arch.mcg_cap;
		break;
	case MSR_IA32_MCG_CTL:
<blue>		if (!(mcg_cap & MCG_CTL_P) && !host)</blue>
			return 1;
<blue>		data = vcpu->arch.mcg_ctl;</blue>
		break;
	case MSR_IA32_MCG_STATUS:
<blue>		data = vcpu->arch.mcg_status;</blue>
		break;
	case MSR_IA32_MC0_CTL2 ... MSR_IA32_MCx_CTL2(KVM_MAX_MCE_BANKS) - 1:
<yellow>		last_msr = MSR_IA32_MCx_CTL2(bank_num) - 1;</yellow>
		if (msr &gt; last_msr)
			return 1;

<yellow>		if (!(mcg_cap & MCG_CMCI_P) && !host)</yellow>
			return 1;
<yellow>		offset = array_index_nospec(msr - MSR_IA32_MC0_CTL2,</yellow>
					    last_msr + 1 - MSR_IA32_MC0_CTL2);
		data = vcpu-&gt;arch.mci_ctl2_banks[offset];
		break;
	case MSR_IA32_MC0_CTL ... MSR_IA32_MCx_CTL(KVM_MAX_MCE_BANKS) - 1:
<blue>		last_msr = MSR_IA32_MCx_CTL(bank_num) - 1;</blue>
		if (msr &gt; last_msr)
			return 1;

<blue>		offset = array_index_nospec(msr - MSR_IA32_MC0_CTL,</blue>
					    last_msr + 1 - MSR_IA32_MC0_CTL);
		data = vcpu-&gt;arch.mce_banks[offset];
		break;
	default:
		return 1;
	}
<blue>	*pdata = data;</blue>
	return 0;
}

int kvm_get_msr_common(struct kvm_vcpu *vcpu, struct msr_data *msr_info)
{
<blue>	switch (msr_info->index) {</blue>
	case MSR_IA32_PLATFORM_ID:
	case MSR_IA32_EBL_CR_POWERON:
	case MSR_IA32_LASTBRANCHFROMIP:
	case MSR_IA32_LASTBRANCHTOIP:
	case MSR_IA32_LASTINTFROMIP:
	case MSR_IA32_LASTINTTOIP:
	case MSR_AMD64_SYSCFG:
	case MSR_K8_TSEG_ADDR:
	case MSR_K8_TSEG_MASK:
	case MSR_VM_HSAVE_PA:
	case MSR_K8_INT_PENDING_MSG:
	case MSR_AMD64_NB_CFG:
	case MSR_FAM10H_MMIO_CONF_BASE:
	case MSR_AMD64_BU_CFG2:
	case MSR_IA32_PERF_CTL:
	case MSR_AMD64_DC_CFG:
	case MSR_F15H_EX_CFG:
	/*
	 * Intel Sandy Bridge CPUs must support the RAPL (running average power
	 * limit) MSRs. Just return 0, as we do not want to expose the host
	 * data here. Do not conditionalize this on CPUID, as KVM does not do
	 * so for existing CPU-specific MSRs.
	 */
	case MSR_RAPL_POWER_UNIT:
	case MSR_PP0_ENERGY_STATUS:	/* Power plane 0 (core) */
	case MSR_PP1_ENERGY_STATUS:	/* Power plane 1 (graphics uncore) */
	case MSR_PKG_ENERGY_STATUS:	/* Total package */
	case MSR_DRAM_ENERGY_STATUS:	/* DRAM controller */
<yellow>		msr_info->data = 0;</yellow>
		break;
	case MSR_IA32_PEBS_ENABLE:
	case MSR_IA32_DS_AREA:
	case MSR_PEBS_DATA_CFG:
	case MSR_F15H_PERF_CTL0 ... MSR_F15H_PERF_CTR5:
<yellow>		if (kvm_pmu_is_valid_msr(vcpu, msr_info->index))</yellow>
			return kvm_pmu_get_msr(vcpu, msr_info);
		/*
		 * Userspace is allowed to read MSRs that KVM reports as
		 * to-be-saved, even if an MSR isn&#x27;t fully supported.
		 */
<yellow>		if (!msr_info->host_initiated)</yellow>
			return 1;
<yellow>		msr_info->data = 0;</yellow>
		break;
	case MSR_K7_EVNTSEL0 ... MSR_K7_EVNTSEL3:
	case MSR_K7_PERFCTR0 ... MSR_K7_PERFCTR3:
	case MSR_P6_PERFCTR0 ... MSR_P6_PERFCTR1:
	case MSR_P6_EVNTSEL0 ... MSR_P6_EVNTSEL1:
<blue>		if (kvm_pmu_is_valid_msr(vcpu, msr_info->index))</blue>
			return kvm_pmu_get_msr(vcpu, msr_info);
		msr_info-&gt;data = 0;
		break;
	case MSR_IA32_UCODE_REV:
<yellow>		msr_info->data = vcpu->arch.microcode_version;</yellow>
		break;
	case MSR_IA32_ARCH_CAPABILITIES:
<yellow>		if (!msr_info->host_initiated &&</yellow>
<yellow>		    !guest_cpuid_has(vcpu, X86_FEATURE_ARCH_CAPABILITIES))</yellow>
			return 1;
<yellow>		msr_info->data = vcpu->arch.arch_capabilities;</yellow>
		break;
	case MSR_IA32_PERF_CAPABILITIES:
<yellow>		if (!msr_info->host_initiated &&</yellow>
<yellow>		    !guest_cpuid_has(vcpu, X86_FEATURE_PDCM))</yellow>
			return 1;
<yellow>		msr_info->data = vcpu->arch.perf_capabilities;</yellow>
		break;
	case MSR_IA32_POWER_CTL:
<yellow>		msr_info->data = vcpu->arch.msr_ia32_power_ctl;</yellow>
		break;
	case MSR_IA32_TSC: {
		/*
		 * Intel SDM states that MSR_IA32_TSC read adds the TSC offset
		 * even when not intercepted. AMD manual doesn&#x27;t explicitly
		 * state this but appears to behave the same.
		 *
		 * On userspace reads and writes, however, we unconditionally
		 * return L1&#x27;s TSC value to ensure backwards-compatible
		 * behavior for migration.
		 */
		u64 offset, ratio;

<blue>		if (msr_info->host_initiated) {</blue>
<blue>			offset = vcpu->arch.l1_tsc_offset;</blue>
			ratio = vcpu-&gt;arch.l1_tsc_scaling_ratio;
		} else {
			offset = vcpu-&gt;arch.tsc_offset;
			ratio = vcpu-&gt;arch.tsc_scaling_ratio;
		}

<blue>		msr_info->data = kvm_scale_tsc(rdtsc(), ratio) + offset;</blue>
		break;
	}
	case MSR_MTRRcap:
	case 0x200 ... MSR_IA32_MC0_CTL2 - 1:
	case MSR_IA32_MCx_CTL2(KVM_MAX_MCE_BANKS) ... 0x2ff:
<blue>		return kvm_mtrr_get_msr(vcpu, msr_info->index, &msr_info->data);</blue>
	case 0xcd: /* fsb frequency */
<yellow>		msr_info->data = 3;</yellow>
		break;
		/*
		 * MSR_EBC_FREQUENCY_ID
		 * Conservative value valid for even the basic CPU models.
		 * Models 0,1: 000 in bits 23:21 indicating a bus speed of
		 * 100MHz, model 2 000 in bits 18:16 indicating 100MHz,
		 * and 266MHz for model 3, or 4. Set Core Clock
		 * Frequency to System Bus Frequency Ratio to 1 (bits
		 * 31:24) even though these are only valid for CPU
		 * models &gt; 2, however guests may end up dividing or
		 * multiplying by zero otherwise.
		 */
	case MSR_EBC_FREQUENCY_ID:
<yellow>		msr_info->data = 1 << 24;</yellow>
		break;
	case MSR_IA32_APICBASE:
<blue>		msr_info->data = kvm_get_apic_base(vcpu);</blue>
		break;
	case APIC_BASE_MSR ... APIC_BASE_MSR + 0xff:
<yellow>		return kvm_x2apic_msr_read(vcpu, msr_info->index, &msr_info->data);</yellow>
	case MSR_IA32_TSC_DEADLINE:
<blue>		msr_info->data = kvm_get_lapic_tscdeadline_msr(vcpu);</blue>
		break;
	case MSR_IA32_TSC_ADJUST:
<blue>		msr_info->data = (u64)vcpu->arch.ia32_tsc_adjust_msr;</blue>
		break;
	case MSR_IA32_MISC_ENABLE:
<blue>		msr_info->data = vcpu->arch.ia32_misc_enable_msr;</blue>
		break;
	case MSR_IA32_SMBASE:
<blue>		if (!msr_info->host_initiated)</blue>
			return 1;
<blue>		msr_info->data = vcpu->arch.smbase;</blue>
		break;
	case MSR_SMI_COUNT:
<blue>		msr_info->data = vcpu->arch.smi_count;</blue>
		break;
	case MSR_IA32_PERF_STATUS:
		/* TSC increment by tick */
		msr_info-&gt;data = 1000ULL;
		/* CPU multiplier */
<yellow>		msr_info->data |= (((uint64_t)4ULL) << 40);</yellow>
		break;
	case MSR_EFER:
<blue>		msr_info->data = vcpu->arch.efer;</blue>
		break;
	case MSR_KVM_WALL_CLOCK:
<blue>		if (!guest_pv_has(vcpu, KVM_FEATURE_CLOCKSOURCE))</blue>
			return 1;

<blue>		msr_info->data = vcpu->kvm->arch.wall_clock;</blue>
		break;
	case MSR_KVM_WALL_CLOCK_NEW:
<yellow>		if (!guest_pv_has(vcpu, KVM_FEATURE_CLOCKSOURCE2))</yellow>
			return 1;

<yellow>		msr_info->data = vcpu->kvm->arch.wall_clock;</yellow>
		break;
	case MSR_KVM_SYSTEM_TIME:
<blue>		if (!guest_pv_has(vcpu, KVM_FEATURE_CLOCKSOURCE))</blue>
			return 1;

<blue>		msr_info->data = vcpu->arch.time;</blue>
		break;
	case MSR_KVM_SYSTEM_TIME_NEW:
<yellow>		if (!guest_pv_has(vcpu, KVM_FEATURE_CLOCKSOURCE2))</yellow>
			return 1;

<yellow>		msr_info->data = vcpu->arch.time;</yellow>
		break;
	case MSR_KVM_ASYNC_PF_EN:
<blue>		if (!guest_pv_has(vcpu, KVM_FEATURE_ASYNC_PF))</blue>
			return 1;

<blue>		msr_info->data = vcpu->arch.apf.msr_en_val;</blue>
		break;
	case MSR_KVM_ASYNC_PF_INT:
<blue>		if (!guest_pv_has(vcpu, KVM_FEATURE_ASYNC_PF_INT))</blue>
			return 1;

<blue>		msr_info->data = vcpu->arch.apf.msr_int_val;</blue>
		break;
	case MSR_KVM_ASYNC_PF_ACK:
<yellow>		if (!guest_pv_has(vcpu, KVM_FEATURE_ASYNC_PF_INT))</yellow>
			return 1;

		msr_info-&gt;data = 0;
		break;
	case MSR_KVM_STEAL_TIME:
<blue>		if (!guest_pv_has(vcpu, KVM_FEATURE_STEAL_TIME))</blue>
			return 1;

<blue>		msr_info->data = vcpu->arch.st.msr_val;</blue>
		break;
	case MSR_KVM_PV_EOI_EN:
<blue>		if (!guest_pv_has(vcpu, KVM_FEATURE_PV_EOI))</blue>
			return 1;

<blue>		msr_info->data = vcpu->arch.pv_eoi.msr_val;</blue>
		break;
	case MSR_KVM_POLL_CONTROL:
<blue>		if (!guest_pv_has(vcpu, KVM_FEATURE_POLL_CONTROL))</blue>
			return 1;

<blue>		msr_info->data = vcpu->arch.msr_kvm_poll_control;</blue>
		break;
	case MSR_IA32_P5_MC_ADDR:
	case MSR_IA32_P5_MC_TYPE:
	case MSR_IA32_MCG_CAP:
	case MSR_IA32_MCG_CTL:
	case MSR_IA32_MCG_STATUS:
	case MSR_IA32_MC0_CTL ... MSR_IA32_MCx_CTL(KVM_MAX_MCE_BANKS) - 1:
	case MSR_IA32_MC0_CTL2 ... MSR_IA32_MCx_CTL2(KVM_MAX_MCE_BANKS) - 1:
<blue>		return get_msr_mce(vcpu, msr_info->index, &msr_info->data,</blue>
<blue>				   msr_info->host_initiated);</blue>
	case MSR_IA32_XSS:
<yellow>		if (!msr_info->host_initiated &&</yellow>
<yellow>		    !guest_cpuid_has(vcpu, X86_FEATURE_XSAVES))</yellow>
			return 1;
<yellow>		msr_info->data = vcpu->arch.ia32_xss;</yellow>
		break;
	case MSR_K7_CLK_CTL:
		/*
		 * Provide expected ramp-up count for K7. All other
		 * are set to zero, indicating minimum divisors for
		 * every field.
		 *
		 * This prevents guest kernels on AMD host with CPU
		 * type 6, model 8 and higher from exploding due to
		 * the rdmsr failing.
		 */
<yellow>		msr_info->data = 0x20000000;</yellow>
		break;
	case HV_X64_MSR_GUEST_OS_ID ... HV_X64_MSR_SINT15:
	case HV_X64_MSR_SYNDBG_CONTROL ... HV_X64_MSR_SYNDBG_PENDING_BUFFER:
	case HV_X64_MSR_SYNDBG_OPTIONS:
	case HV_X64_MSR_CRASH_P0 ... HV_X64_MSR_CRASH_P4:
	case HV_X64_MSR_CRASH_CTL:
	case HV_X64_MSR_STIMER0_CONFIG ... HV_X64_MSR_STIMER3_COUNT:
	case HV_X64_MSR_REENLIGHTENMENT_CONTROL:
	case HV_X64_MSR_TSC_EMULATION_CONTROL:
	case HV_X64_MSR_TSC_EMULATION_STATUS:
<blue>		return kvm_hv_get_msr_common(vcpu,</blue>
					     msr_info-&gt;index, &amp;msr_info-&gt;data,
<blue>					     msr_info->host_initiated);</blue>
	case MSR_IA32_BBL_CR_CTL3:
		/* This legacy MSR exists but isn&#x27;t fully documented in current
		 * silicon.  It is however accessed by winxp in very narrow
		 * scenarios where it sets bit #19, itself documented as
		 * a &quot;reserved&quot; bit.  Best effort attempt to source coherent
		 * read data here should the balance of the register be
		 * interpreted by the guest:
		 *
		 * L2 cache control register 3: 64GB range, 256KB size,
		 * enabled, latency 0x1, configured
		 */
<yellow>		msr_info->data = 0xbe702111;</yellow>
		break;
	case MSR_AMD64_OSVW_ID_LENGTH:
<yellow>		if (!guest_cpuid_has(vcpu, X86_FEATURE_OSVW))</yellow>
			return 1;
<yellow>		msr_info->data = vcpu->arch.osvw.length;</yellow>
		break;
	case MSR_AMD64_OSVW_STATUS:
<yellow>		if (!guest_cpuid_has(vcpu, X86_FEATURE_OSVW))</yellow>
			return 1;
<yellow>		msr_info->data = vcpu->arch.osvw.status;</yellow>
		break;
	case MSR_PLATFORM_INFO:
<yellow>		if (!msr_info->host_initiated &&</yellow>
<yellow>		    !vcpu->kvm->arch.guest_can_read_msr_platform_info)</yellow>
			return 1;
<yellow>		msr_info->data = vcpu->arch.msr_platform_info;</yellow>
		break;
	case MSR_MISC_FEATURES_ENABLES:
<yellow>		msr_info->data = vcpu->arch.msr_misc_features_enables;</yellow>
		break;
	case MSR_K7_HWCR:
<yellow>		msr_info->data = vcpu->arch.msr_hwcr;</yellow>
		break;
#ifdef CONFIG_X86_64
	case MSR_IA32_XFD:
<yellow>		if (!msr_info->host_initiated &&</yellow>
<yellow>		    !guest_cpuid_has(vcpu, X86_FEATURE_XFD))</yellow>
			return 1;

<yellow>		msr_info->data = vcpu->arch.guest_fpu.fpstate->xfd;</yellow>
		break;
	case MSR_IA32_XFD_ERR:
<yellow>		if (!msr_info->host_initiated &&</yellow>
<yellow>		    !guest_cpuid_has(vcpu, X86_FEATURE_XFD))</yellow>
			return 1;

<yellow>		msr_info->data = vcpu->arch.guest_fpu.xfd_err;</yellow>
		break;
#endif
	default:
<blue>		if (kvm_pmu_is_valid_msr(vcpu, msr_info->index))</blue>
<blue>			return kvm_pmu_get_msr(vcpu, msr_info);</blue>
		return KVM_MSR_RET_INVALID;
	}
	return 0;
<blue>}</blue>
EXPORT_SYMBOL_GPL(kvm_get_msr_common);

/*
 * Read or write a bunch of msrs. All parameters are kernel addresses.
 *
 * @return number of msrs set successfully.
 */
static int __msr_io(struct kvm_vcpu *vcpu, struct kvm_msrs *msrs,
		    struct kvm_msr_entry *entries,
		    int (*do_msr)(struct kvm_vcpu *vcpu,
				  unsigned index, u64 *data))
{
	int i;

<blue>	for (i = 0; i < msrs->nmsrs; ++i)</blue>
<blue>		if (do_msr(vcpu, entries[i].index, &entries[i].data))</blue>
			break;

	return i;
}

/*
 * Read or write a bunch of msrs. Parameters are user addresses.
 *
 * @return number of msrs set successfully.
 */
static int msr_io(struct kvm_vcpu *vcpu, struct kvm_msrs __user *user_msrs,
		  int (*do_msr)(struct kvm_vcpu *vcpu,
				unsigned index, u64 *data),
		  int writeback)
<blue>{</blue>
	struct kvm_msrs msrs;
	struct kvm_msr_entry *entries;
	int r, n;
	unsigned size;

	r = -EFAULT;
<blue>	if (copy_from_user(&msrs, user_msrs, sizeof(msrs)))</blue>
		goto out;

	r = -E2BIG;
<blue>	if (msrs.nmsrs >= MAX_IO_MSRS)</blue>
		goto out;

<blue>	size = sizeof(struct kvm_msr_entry) * msrs.nmsrs;</blue>
	entries = memdup_user(user_msrs-&gt;entries, size);
	if (IS_ERR(entries)) {
<yellow>		r = PTR_ERR(entries);</yellow>
		goto out;
	}

<blue>	r = n = __msr_io(vcpu, &msrs, entries, do_msr);</blue>
<blue>	if (r < 0)</blue>
		goto out_free;

	r = -EFAULT;
<blue>	if (writeback && copy_to_user(user_msrs->entries, entries, size))</blue>
		goto out_free;

	r = n;

out_free:
<blue>	kfree(entries);</blue>
out:
	return r;
}

static inline bool kvm_can_mwait_in_guest(void)
{
<yellow>	return boot_cpu_has(X86_FEATURE_MWAIT) &&</yellow>
<yellow>		!boot_cpu_has_bug(X86_BUG_MONITOR) &&</yellow>
<yellow>		boot_cpu_has(X86_FEATURE_ARAT);</yellow>
}

static int kvm_ioctl_get_supported_hv_cpuid(struct kvm_vcpu *vcpu,
					    struct kvm_cpuid2 __user *cpuid_arg)
<blue>{</blue>
	struct kvm_cpuid2 cpuid;
	int r;

	r = -EFAULT;
<blue>	if (copy_from_user(&cpuid, cpuid_arg, sizeof(cpuid)))</blue>
		return r;

<blue>	r = kvm_get_hv_cpuid(vcpu, &cpuid, cpuid_arg->entries);</blue>
	if (r)
		return r;

	r = -EFAULT;
<blue>	if (copy_to_user(cpuid_arg, &cpuid, sizeof(cpuid)))</blue>
		return r;

	return 0;
}

int kvm_vm_ioctl_check_extension(struct kvm *kvm, long ext)
{
	int r = 0;

<blue>	switch (ext) {</blue>
	case KVM_CAP_IRQCHIP:
	case KVM_CAP_HLT:
	case KVM_CAP_MMU_SHADOW_CACHE_CONTROL:
	case KVM_CAP_SET_TSS_ADDR:
	case KVM_CAP_EXT_CPUID:
	case KVM_CAP_EXT_EMUL_CPUID:
	case KVM_CAP_CLOCKSOURCE:
	case KVM_CAP_PIT:
	case KVM_CAP_NOP_IO_DELAY:
	case KVM_CAP_MP_STATE:
	case KVM_CAP_SYNC_MMU:
	case KVM_CAP_USER_NMI:
	case KVM_CAP_REINJECT_CONTROL:
	case KVM_CAP_IRQ_INJECT_STATUS:
	case KVM_CAP_IOEVENTFD:
	case KVM_CAP_IOEVENTFD_NO_LENGTH:
	case KVM_CAP_PIT2:
	case KVM_CAP_PIT_STATE2:
	case KVM_CAP_SET_IDENTITY_MAP_ADDR:
	case KVM_CAP_VCPU_EVENTS:
	case KVM_CAP_HYPERV:
	case KVM_CAP_HYPERV_VAPIC:
	case KVM_CAP_HYPERV_SPIN:
	case KVM_CAP_HYPERV_SYNIC:
	case KVM_CAP_HYPERV_SYNIC2:
	case KVM_CAP_HYPERV_VP_INDEX:
	case KVM_CAP_HYPERV_EVENTFD:
	case KVM_CAP_HYPERV_TLBFLUSH:
	case KVM_CAP_HYPERV_SEND_IPI:
	case KVM_CAP_HYPERV_CPUID:
	case KVM_CAP_HYPERV_ENFORCE_CPUID:
	case KVM_CAP_SYS_HYPERV_CPUID:
	case KVM_CAP_PCI_SEGMENT:
	case KVM_CAP_DEBUGREGS:
	case KVM_CAP_X86_ROBUST_SINGLESTEP:
	case KVM_CAP_XSAVE:
	case KVM_CAP_ASYNC_PF:
	case KVM_CAP_ASYNC_PF_INT:
	case KVM_CAP_GET_TSC_KHZ:
	case KVM_CAP_KVMCLOCK_CTRL:
	case KVM_CAP_READONLY_MEM:
	case KVM_CAP_HYPERV_TIME:
	case KVM_CAP_IOAPIC_POLARITY_IGNORED:
	case KVM_CAP_TSC_DEADLINE_TIMER:
	case KVM_CAP_DISABLE_QUIRKS:
	case KVM_CAP_SET_BOOT_CPU_ID:
 	case KVM_CAP_SPLIT_IRQCHIP:
	case KVM_CAP_IMMEDIATE_EXIT:
	case KVM_CAP_PMU_EVENT_FILTER:
	case KVM_CAP_GET_MSR_FEATURES:
	case KVM_CAP_MSR_PLATFORM_INFO:
	case KVM_CAP_EXCEPTION_PAYLOAD:
	case KVM_CAP_X86_TRIPLE_FAULT_EVENT:
	case KVM_CAP_SET_GUEST_DEBUG:
	case KVM_CAP_LAST_CPU:
	case KVM_CAP_X86_USER_SPACE_MSR:
	case KVM_CAP_X86_MSR_FILTER:
	case KVM_CAP_ENFORCE_PV_FEATURE_CPUID:
#ifdef CONFIG_X86_SGX_KVM
	case KVM_CAP_SGX_ATTRIBUTE:
#endif
	case KVM_CAP_VM_COPY_ENC_CONTEXT_FROM:
	case KVM_CAP_VM_MOVE_ENC_CONTEXT_FROM:
	case KVM_CAP_SREGS2:
	case KVM_CAP_EXIT_ON_EMULATION_FAILURE:
	case KVM_CAP_VCPU_ATTRIBUTES:
	case KVM_CAP_SYS_ATTRIBUTES:
	case KVM_CAP_VAPIC:
	case KVM_CAP_ENABLE_CAP:
	case KVM_CAP_VM_DISABLE_NX_HUGE_PAGES:
		r = 1;
		break;
	case KVM_CAP_EXIT_HYPERCALL:
		r = KVM_EXIT_HYPERCALL_VALID_MASK;
		break;
	case KVM_CAP_SET_GUEST_DEBUG2:
		return KVM_GUESTDBG_VALID_MASK;
#ifdef CONFIG_KVM_XEN
	case KVM_CAP_XEN_HVM:
		r = KVM_XEN_HVM_CONFIG_HYPERCALL_MSR |
		    KVM_XEN_HVM_CONFIG_INTERCEPT_HCALL |
		    KVM_XEN_HVM_CONFIG_SHARED_INFO |
		    KVM_XEN_HVM_CONFIG_EVTCHN_2LEVEL |
		    KVM_XEN_HVM_CONFIG_EVTCHN_SEND;
		if (sched_info_on())
			r |= KVM_XEN_HVM_CONFIG_RUNSTATE;
		break;
#endif
	case KVM_CAP_SYNC_REGS:
		r = KVM_SYNC_X86_VALID_FIELDS;
		break;
	case KVM_CAP_ADJUST_CLOCK:
		r = KVM_CLOCK_VALID_FLAGS;
		break;
	case KVM_CAP_X86_DISABLE_EXITS:
		r |=  KVM_X86_DISABLE_EXITS_HLT | KVM_X86_DISABLE_EXITS_PAUSE |
		      KVM_X86_DISABLE_EXITS_CSTATE;
<yellow>		if(kvm_can_mwait_in_guest())</yellow>
			r |= KVM_X86_DISABLE_EXITS_MWAIT;
		break;
	case KVM_CAP_X86_SMM:
		/* SMBASE is usually relocated above 1M on modern chipsets,
		 * and SMM handlers might indeed rely on 4G segment limits,
		 * so do not report SMM to be available if real mode is
		 * emulated via vm86 mode.  Still, do not go to great lengths
		 * to avoid userspace&#x27;s usage of the feature, because it is a
		 * fringe case that is not enabled except via specific settings
		 * of the module parameters.
		 */
<blue>		r = static_call(kvm_x86_has_emulated_msr)(kvm, MSR_IA32_SMBASE);</blue>
		break;
	case KVM_CAP_NR_VCPUS:
<blue>		r = min_t(unsigned int, num_online_cpus(), KVM_MAX_VCPUS);</blue>
		break;
	case KVM_CAP_MAX_VCPUS:
		r = KVM_MAX_VCPUS;
		break;
	case KVM_CAP_MAX_VCPU_ID:
		r = KVM_MAX_VCPU_IDS;
		break;
	case KVM_CAP_PV_MMU:	/* obsolete */
		r = 0;
		break;
	case KVM_CAP_MCE:
		r = KVM_MAX_MCE_BANKS;
		break;
	case KVM_CAP_XCRS:
<blue>		r = boot_cpu_has(X86_FEATURE_XSAVE);</blue>
		break;
	case KVM_CAP_TSC_CONTROL:
	case KVM_CAP_VM_TSC_CONTROL:
<blue>		r = kvm_caps.has_tsc_control;</blue>
		break;
	case KVM_CAP_X2APIC_API:
		r = KVM_X2APIC_API_VALID_FLAGS;
		break;
	case KVM_CAP_NESTED_STATE:
<blue>		r = kvm_x86_ops.nested_ops->get_state ?</blue>
<blue>			kvm_x86_ops.nested_ops->get_state(NULL, NULL, 0) : 0;</blue>
		break;
	case KVM_CAP_HYPERV_DIRECT_TLBFLUSH:
<yellow>		r = kvm_x86_ops.enable_direct_tlbflush != NULL;</yellow>
		break;
	case KVM_CAP_HYPERV_ENLIGHTENED_VMCS:
<yellow>		r = kvm_x86_ops.nested_ops->enable_evmcs != NULL;</yellow>
		break;
	case KVM_CAP_SMALLER_MAXPHYADDR:
<yellow>		r = (int) allow_smaller_maxphyaddr;</yellow>
		break;
	case KVM_CAP_STEAL_TIME:
		r = sched_info_on();
		break;
	case KVM_CAP_X86_BUS_LOCK_EXIT:
<yellow>		if (kvm_caps.has_bus_lock_exit)</yellow>
			r = KVM_BUS_LOCK_DETECTION_OFF |
			    KVM_BUS_LOCK_DETECTION_EXIT;
		else
			r = 0;
		break;
	case KVM_CAP_XSAVE2: {
		u64 guest_perm = xstate_get_guest_group_perm();

<yellow>		r = xstate_required_size(kvm_caps.supported_xcr0 & guest_perm, false);</yellow>
		if (r &lt; sizeof(struct kvm_xsave))
<blue>			r = sizeof(struct kvm_xsave);</blue>
		break;
	}
	case KVM_CAP_PMU_CAPABILITY:
<yellow>		r = enable_pmu ? KVM_CAP_PMU_VALID_MASK : 0;</yellow>
		break;
	case KVM_CAP_DISABLE_QUIRKS2:
		r = KVM_X86_VALID_QUIRKS;
		break;
	case KVM_CAP_X86_NOTIFY_VMEXIT:
<blue>		r = kvm_caps.has_notify_vmexit;</blue>
		break;
	default:
		break;
	}
	return r;
<blue>}</blue>

static inline void __user *kvm_get_attr_addr(struct kvm_device_attr *attr)
{
<yellow>	void __user *uaddr = (void __user*)(unsigned long)attr->addr;</yellow>

	if ((u64)(unsigned long)uaddr != attr-&gt;addr)
		return ERR_PTR_USR(-EFAULT);
	return uaddr;
}

static int kvm_x86_dev_get_attr(struct kvm_device_attr *attr)
{
	u64 __user *uaddr = kvm_get_attr_addr(attr);

<blue>	if (attr->group)</blue>
		return -ENXIO;

<blue>	if (IS_ERR(uaddr))</blue>
<yellow>		return PTR_ERR(uaddr);</yellow>

<blue>	switch (attr->attr) {</blue>
	case KVM_X86_XCOMP_GUEST_SUPP:
<blue>		if (put_user(kvm_caps.supported_xcr0, uaddr))</blue>
			return -EFAULT;
		return 0;
	default:
		return -ENXIO;
		break;
	}
}

static int kvm_x86_dev_has_attr(struct kvm_device_attr *attr)
{
<yellow>	if (attr->group)</yellow>
		return -ENXIO;

<yellow>	switch (attr->attr) {</yellow>
	case KVM_X86_XCOMP_GUEST_SUPP:
		return 0;
	default:
		return -ENXIO;
	}
}

long kvm_arch_dev_ioctl(struct file *filp,
			unsigned int ioctl, unsigned long arg)
<blue>{</blue>
	void __user *argp = (void __user *)arg;
	long r;

<blue>	switch (ioctl) {</blue>
	case KVM_GET_MSR_INDEX_LIST: {
		struct kvm_msr_list __user *user_msr_list = argp;
		struct kvm_msr_list msr_list;
		unsigned n;

		r = -EFAULT;
<blue>		if (copy_from_user(&msr_list, user_msr_list, sizeof(msr_list)))</blue>
			goto out;
		n = msr_list.nmsrs;
		msr_list.nmsrs = num_msrs_to_save + num_emulated_msrs;
<blue>		if (copy_to_user(user_msr_list, &msr_list, sizeof(msr_list)))</blue>
			goto out;
		r = -E2BIG;
<blue>		if (n < msr_list.nmsrs)</blue>
			goto out;
		r = -EFAULT;
<blue>		if (copy_to_user(user_msr_list->indices, &msrs_to_save,</blue>
				 num_msrs_to_save * sizeof(u32)))
			goto out;
<blue>		if (copy_to_user(user_msr_list->indices + num_msrs_to_save,</blue>
				 &amp;emulated_msrs,
				 num_emulated_msrs * sizeof(u32)))
			goto out;
		r = 0;
		break;
	}
	case KVM_GET_SUPPORTED_CPUID:
	case KVM_GET_EMULATED_CPUID: {
		struct kvm_cpuid2 __user *cpuid_arg = argp;
		struct kvm_cpuid2 cpuid;

		r = -EFAULT;
<blue>		if (copy_from_user(&cpuid, cpuid_arg, sizeof(cpuid)))</blue>
			goto out;

<blue>		r = kvm_dev_ioctl_get_cpuid(&cpuid, cpuid_arg->entries,</blue>
					    ioctl);
		if (r)
			goto out;

		r = -EFAULT;
<blue>		if (copy_to_user(cpuid_arg, &cpuid, sizeof(cpuid)))</blue>
			goto out;
		r = 0;
		break;
	}
	case KVM_X86_GET_MCE_CAP_SUPPORTED:
		r = -EFAULT;
<blue>		if (copy_to_user(argp, &kvm_caps.supported_mce_cap,</blue>
				 sizeof(kvm_caps.supported_mce_cap)))
			goto out;
		r = 0;
		break;
	case KVM_GET_MSR_FEATURE_INDEX_LIST: {
		struct kvm_msr_list __user *user_msr_list = argp;
		struct kvm_msr_list msr_list;
		unsigned int n;

		r = -EFAULT;
<blue>		if (copy_from_user(&msr_list, user_msr_list, sizeof(msr_list)))</blue>
			goto out;
		n = msr_list.nmsrs;
		msr_list.nmsrs = num_msr_based_features;
<blue>		if (copy_to_user(user_msr_list, &msr_list, sizeof(msr_list)))</blue>
			goto out;
		r = -E2BIG;
<blue>		if (n < msr_list.nmsrs)</blue>
			goto out;
		r = -EFAULT;
<blue>		if (copy_to_user(user_msr_list->indices, &msr_based_features,</blue>
				 num_msr_based_features * sizeof(u32)))
			goto out;
<blue>		r = 0;</blue>
		break;
	}
	case KVM_GET_MSRS:
<blue>		r = msr_io(NULL, argp, do_get_msr_feature, 1);</blue>
		break;
	case KVM_GET_SUPPORTED_HV_CPUID:
<blue>		r = kvm_ioctl_get_supported_hv_cpuid(NULL, argp);</blue>
		break;
	case KVM_GET_DEVICE_ATTR: {
		struct kvm_device_attr attr;
		r = -EFAULT;
<blue>		if (copy_from_user(&attr, (void __user *)arg, sizeof(attr)))</blue>
			break;
<blue>		r = kvm_x86_dev_get_attr(&attr);</blue>
		break;
	}
	case KVM_HAS_DEVICE_ATTR: {
		struct kvm_device_attr attr;
		r = -EFAULT;
<yellow>		if (copy_from_user(&attr, (void __user *)arg, sizeof(attr)))</yellow>
			break;
<yellow>		r = kvm_x86_dev_has_attr(&attr);</yellow>
		break;
	}
	default:
		r = -EINVAL;
		break;
	}
out:
<blue>	return r;</blue>
}

static void wbinvd_ipi(void *garbage)
{
<yellow>	wbinvd();</yellow>
}

static bool need_emulate_wbinvd(struct kvm_vcpu *vcpu)
{
<blue>	return kvm_arch_has_noncoherent_dma(vcpu->kvm);</blue>
}

void kvm_arch_vcpu_load(struct kvm_vcpu *vcpu, int cpu)
{
	/* Address WBINVD may be executed by guest */
<blue>	if (need_emulate_wbinvd(vcpu)) {</blue>
<yellow>		if (static_call(kvm_x86_has_wbinvd_exit)())</yellow>
<yellow>			cpumask_set_cpu(cpu, vcpu->arch.wbinvd_dirty_mask);</yellow>
<yellow>		else if (vcpu->cpu != -1 && vcpu->cpu != cpu)</yellow>
<yellow>			smp_call_function_single(vcpu->cpu,</yellow>
					wbinvd_ipi, NULL, 1);
	}

<blue>	static_call(kvm_x86_vcpu_load)(vcpu, cpu);</blue>

	/* Save host pkru register if supported */
<blue>	vcpu->arch.host_pkru = read_pkru();</blue>

	/* Apply any externally detected TSC adjustments (due to suspend) */
	if (unlikely(vcpu-&gt;arch.tsc_offset_adjustment)) {
<yellow>		adjust_tsc_offset_host(vcpu, vcpu->arch.tsc_offset_adjustment);</yellow>
		vcpu-&gt;arch.tsc_offset_adjustment = 0;
		kvm_make_request(KVM_REQ_CLOCK_UPDATE, vcpu);
	}

<blue>	if (unlikely(vcpu->cpu != cpu) || kvm_check_tsc_unstable()) {</blue>
<blue>		s64 tsc_delta = !vcpu->arch.last_host_tsc ? 0 :</blue>
<blue>				rdtsc() - vcpu->arch.last_host_tsc;</blue>
		if (tsc_delta &lt; 0)
<yellow>			mark_tsc_unstable("KVM discovered backwards TSC");</yellow>

<blue>		if (kvm_check_tsc_unstable()) {</blue>
<yellow>			u64 offset = kvm_compute_l1_tsc_offset(vcpu,</yellow>
						vcpu-&gt;arch.last_guest_tsc);
			kvm_vcpu_write_tsc_offset(vcpu, offset);
			vcpu-&gt;arch.tsc_catchup = 1;
		}

<blue>		if (kvm_lapic_hv_timer_in_use(vcpu))</blue>
<yellow>			kvm_lapic_restart_hv_timer(vcpu);</yellow>

		/*
		 * On a host with synchronized TSC, there is no need to update
		 * kvmclock on vcpu-&gt;cpu migration
		 */
<blue>		if (!vcpu->kvm->arch.use_master_clock || vcpu->cpu == -1)</blue>
<blue>			kvm_make_request(KVM_REQ_GLOBAL_CLOCK_UPDATE, vcpu);</blue>
<blue>		if (vcpu->cpu != cpu)</blue>
<blue>			kvm_make_request(KVM_REQ_MIGRATE_TIMER, vcpu);</blue>
<blue>		vcpu->cpu = cpu;</blue>
	}

<blue>	kvm_make_request(KVM_REQ_STEAL_UPDATE, vcpu);</blue>
}

static void kvm_steal_time_set_preempted(struct kvm_vcpu *vcpu)
{
	struct gfn_to_hva_cache *ghc = &amp;vcpu-&gt;arch.st.cache;
	struct kvm_steal_time __user *st;
	struct kvm_memslots *slots;
	static const u8 preempted = KVM_VCPU_PREEMPTED;
<yellow>	gpa_t gpa = vcpu->arch.st.msr_val & KVM_STEAL_VALID_BITS;</yellow>

	/*
	 * The vCPU can be marked preempted if and only if the VM-Exit was on
	 * an instruction boundary and will not trigger guest emulation of any
	 * kind (see vcpu_run).  Vendor specific code controls (conservatively)
	 * when this is true, for example allowing the vCPU to be marked
	 * preempted if and only if the VM-Exit was due to a host interrupt.
	 */
<yellow>	if (!vcpu->arch.at_instruction_boundary) {</yellow>
<yellow>		vcpu->stat.preemption_other++;</yellow>
		return;
	}

<yellow>	vcpu->stat.preemption_reported++;</yellow>
	if (!(vcpu-&gt;arch.st.msr_val &amp; KVM_MSR_ENABLED))
		return;

<yellow>	if (vcpu->arch.st.preempted)</yellow>
		return;

	/* This happens on process exit */
<yellow>	if (unlikely(current->mm != vcpu->kvm->mm))</yellow>
		return;

<yellow>	slots = kvm_memslots(vcpu->kvm);</yellow>

<yellow>	if (unlikely(slots->generation != ghc->generation ||</yellow>
		     gpa != ghc-&gt;gpa ||
		     kvm_is_error_hva(ghc-&gt;hva) || !ghc-&gt;memslot))
		return;

	st = (struct kvm_steal_time __user *)ghc-&gt;hva;
	BUILD_BUG_ON(sizeof(st-&gt;preempted) != sizeof(preempted));

<yellow>	if (!copy_to_user_nofault(&st->preempted, &preempted, sizeof(preempted)))</yellow>
<yellow>		vcpu->arch.st.preempted = KVM_VCPU_PREEMPTED;</yellow>

<yellow>	mark_page_dirty_in_slot(vcpu->kvm, ghc->memslot, gpa_to_gfn(ghc->gpa));</yellow>
}

void kvm_arch_vcpu_put(struct kvm_vcpu *vcpu)
{
	int idx;

<blue>	if (vcpu->preempted) {</blue>
<yellow>		if (!vcpu->arch.guest_state_protected)</yellow>
<yellow>			vcpu->arch.preempted_in_kernel = !static_call(kvm_x86_get_cpl)(vcpu);</yellow>

		/*
		 * Take the srcu lock as memslots will be accessed to check the gfn
		 * cache generation against the memslots generation.
		 */
<yellow>		idx = srcu_read_lock(&vcpu->kvm->srcu);</yellow>
<yellow>		if (kvm_xen_msr_enabled(vcpu->kvm))</yellow>
<yellow>			kvm_xen_runstate_set_preempted(vcpu);</yellow>
		else
<yellow>			kvm_steal_time_set_preempted(vcpu);</yellow>
<yellow>		srcu_read_unlock(&vcpu->kvm->srcu, idx);</yellow>
	}

<blue>	static_call(kvm_x86_vcpu_put)(vcpu);</blue>
	vcpu-&gt;arch.last_host_tsc = rdtsc();
}

static int kvm_vcpu_ioctl_get_lapic(struct kvm_vcpu *vcpu,
				    struct kvm_lapic_state *s)
{
<blue>	static_call_cond(kvm_x86_sync_pir_to_irr)(vcpu);</blue>

	return kvm_apic_get_state(vcpu, s);
}

static int kvm_vcpu_ioctl_set_lapic(struct kvm_vcpu *vcpu,
				    struct kvm_lapic_state *s)
{
	int r;

<blue>	r = kvm_apic_set_state(vcpu, s);</blue>
	if (r)
		return r;
<blue>	update_cr8_intercept(vcpu);</blue>

	return 0;
}

<yellow>static int kvm_cpu_accept_dm_intr(struct kvm_vcpu *vcpu)</yellow>
{
	/*
	 * We can accept userspace&#x27;s request for interrupt injection
	 * as long as we have a place to store the interrupt number.
	 * The actual injection will happen when the CPU is able to
	 * deliver the interrupt.
	 */
<yellow>	if (kvm_cpu_has_extint(vcpu))</yellow>
		return false;

	/* Acknowledging ExtINT does not happen if LINT0 is masked.  */
<yellow>	return (!lapic_in_kernel(vcpu) ||</yellow>
<yellow>		kvm_apic_accept_pic_intr(vcpu));</yellow>
}

<yellow>static int kvm_vcpu_ready_for_interrupt_injection(struct kvm_vcpu *vcpu)</yellow>
{
	/*
	 * Do not cause an interrupt window exit if an exception
	 * is pending or an event needs reinjection; userspace
	 * might want to inject the interrupt manually using KVM_SET_REGS
	 * or KVM_SET_SREGS.  For that to work, we must be at an
	 * instruction boundary and with no events half-injected.
	 */
<yellow>	return (kvm_arch_interrupt_allowed(vcpu) &&</yellow>
<yellow>		kvm_cpu_accept_dm_intr(vcpu) &&</yellow>
<yellow>		!kvm_event_needs_reinjection(vcpu) &&</yellow>
<yellow>		!kvm_is_exception_pending(vcpu));</yellow>
<yellow>}</yellow>

static int kvm_vcpu_ioctl_interrupt(struct kvm_vcpu *vcpu,
				    struct kvm_interrupt *irq)
{
<blue>	if (irq->irq >= KVM_NR_INTERRUPTS)</blue>
		return -EINVAL;

<blue>	if (!irqchip_in_kernel(vcpu->kvm)) {</blue>
<yellow>		kvm_queue_interrupt(vcpu, irq->irq, false);</yellow>
		kvm_make_request(KVM_REQ_EVENT, vcpu);
		return 0;
	}

	/*
	 * With in-kernel LAPIC, we only use this to inject EXTINT, so
	 * fail for in-kernel 8259.
	 */
<blue>	if (pic_in_kernel(vcpu->kvm))</blue>
		return -ENXIO;

<yellow>	if (vcpu->arch.pending_external_vector != -1)</yellow>
		return -EEXIST;

<yellow>	vcpu->arch.pending_external_vector = irq->irq;</yellow>
	kvm_make_request(KVM_REQ_EVENT, vcpu);
	return 0;
}

static int kvm_vcpu_ioctl_nmi(struct kvm_vcpu *vcpu)
{
<yellow>	kvm_inject_nmi(vcpu);</yellow>

	return 0;
}

static int kvm_vcpu_ioctl_smi(struct kvm_vcpu *vcpu)
{
<yellow>	kvm_make_request(KVM_REQ_SMI, vcpu);</yellow>

	return 0;
}

static int vcpu_ioctl_tpr_access_reporting(struct kvm_vcpu *vcpu,
					   struct kvm_tpr_access_ctl *tac)
{
<blue>	if (tac->flags)</blue>
		return -EINVAL;
<blue>	vcpu->arch.tpr_access_reporting = !!tac->enabled;</blue>
	return 0;
}

static int kvm_vcpu_ioctl_x86_setup_mce(struct kvm_vcpu *vcpu,
					u64 mcg_cap)
{
	int r;
	unsigned bank_num = mcg_cap &amp; 0xff, bank;

	r = -EINVAL;
	if (!bank_num || bank_num &gt; KVM_MAX_MCE_BANKS)
		goto out;
<blue>	if (mcg_cap & ~(kvm_caps.supported_mce_cap | 0xff | 0xff0000))</blue>
		goto out;
	r = 0;
<blue>	vcpu->arch.mcg_cap = mcg_cap;</blue>
	/* Init IA32_MCG_CTL to all 1s */
	if (mcg_cap &amp; MCG_CTL_P)
<blue>		vcpu->arch.mcg_ctl = ~(u64)0;</blue>
	/* Init IA32_MCi_CTL to all 1s, IA32_MCi_CTL2 to all 0s */
<blue>	for (bank = 0; bank < bank_num; bank++) {</blue>
<blue>		vcpu->arch.mce_banks[bank*4] = ~(u64)0;</blue>
<blue>		if (mcg_cap & MCG_CMCI_P)</blue>
<yellow>			vcpu->arch.mci_ctl2_banks[bank] = 0;</yellow>
	}

<blue>	kvm_apic_after_set_mcg_cap(vcpu);</blue>

	static_call(kvm_x86_setup_mce)(vcpu);
out:
	return r;
}

/*
 * Validate this is an UCNA (uncorrectable no action) error by checking the
 * MCG_STATUS and MCi_STATUS registers:
 * - none of the bits for Machine Check Exceptions are set
 * - both the VAL (valid) and UC (uncorrectable) bits are set
 * MCI_STATUS_PCC - Processor Context Corrupted
 * MCI_STATUS_S - Signaled as a Machine Check Exception
 * MCI_STATUS_AR - Software recoverable Action Required
 */
static bool is_ucna(struct kvm_x86_mce *mce)
{
	return	!mce-&gt;mcg_status &amp;&amp;
		!(mce-&gt;status &amp; (MCI_STATUS_PCC | MCI_STATUS_S | MCI_STATUS_AR)) &amp;&amp;
<yellow>		(mce->status & MCI_STATUS_VAL) &&</yellow>
		(mce-&gt;status &amp; MCI_STATUS_UC);
}

static int kvm_vcpu_x86_set_ucna(struct kvm_vcpu *vcpu, struct kvm_x86_mce *mce, u64* banks)
{
	u64 mcg_cap = vcpu-&gt;arch.mcg_cap;

<yellow>	banks[1] = mce->status;</yellow>
	banks[2] = mce-&gt;addr;
	banks[3] = mce-&gt;misc;
	vcpu-&gt;arch.mcg_status = mce-&gt;mcg_status;

	if (!(mcg_cap &amp; MCG_CMCI_P) ||
<yellow>	    !(vcpu->arch.mci_ctl2_banks[mce->bank] & MCI_CTL2_CMCI_EN))</yellow>
		return 0;

<yellow>	if (lapic_in_kernel(vcpu))</yellow>
<yellow>		kvm_apic_local_deliver(vcpu->arch.apic, APIC_LVTCMCI);</yellow>

	return 0;
}

static int kvm_vcpu_ioctl_x86_set_mce(struct kvm_vcpu *vcpu,
				      struct kvm_x86_mce *mce)
{
<yellow>	u64 mcg_cap = vcpu->arch.mcg_cap;</yellow>
	unsigned bank_num = mcg_cap &amp; 0xff;
	u64 *banks = vcpu-&gt;arch.mce_banks;

<yellow>	if (mce->bank >= bank_num || !(mce->status & MCI_STATUS_VAL))</yellow>
		return -EINVAL;

<yellow>	banks += array_index_nospec(4 * mce->bank, 4 * bank_num);</yellow>

<yellow>	if (is_ucna(mce))</yellow>
<yellow>		return kvm_vcpu_x86_set_ucna(vcpu, mce, banks);</yellow>

	/*
	 * if IA32_MCG_CTL is not all 1s, the uncorrected error
	 * reporting is disabled
	 */
<yellow>	if ((mce->status & MCI_STATUS_UC) && (mcg_cap & MCG_CTL_P) &&</yellow>
<yellow>	    vcpu->arch.mcg_ctl != ~(u64)0)</yellow>
		return 0;
	/*
	 * if IA32_MCi_CTL is not all 1s, the uncorrected error
	 * reporting is disabled for the bank
	 */
<yellow>	if ((mce->status & MCI_STATUS_UC) && banks[0] != ~(u64)0)</yellow>
		return 0;
	if (mce-&gt;status &amp; MCI_STATUS_UC) {
<yellow>		if ((vcpu->arch.mcg_status & MCG_STATUS_MCIP) ||</yellow>
<yellow>		    !kvm_read_cr4_bits(vcpu, X86_CR4_MCE)) {</yellow>
<yellow>			kvm_make_request(KVM_REQ_TRIPLE_FAULT, vcpu);</yellow>
			return 0;
		}
<yellow>		if (banks[1] & MCI_STATUS_VAL)</yellow>
<yellow>			mce->status |= MCI_STATUS_OVER;</yellow>
<yellow>		banks[2] = mce->addr;</yellow>
		banks[3] = mce-&gt;misc;
		vcpu-&gt;arch.mcg_status = mce-&gt;mcg_status;
		banks[1] = mce-&gt;status;
		kvm_queue_exception(vcpu, MC_VECTOR);
<yellow>	} else if (!(banks[1] & MCI_STATUS_VAL)</yellow>
<yellow>		   || !(banks[1] & MCI_STATUS_UC)) {</yellow>
		if (banks[1] &amp; MCI_STATUS_VAL)
<yellow>			mce->status |= MCI_STATUS_OVER;</yellow>
<yellow>		banks[2] = mce->addr;</yellow>
		banks[3] = mce-&gt;misc;
		banks[1] = mce-&gt;status;
	} else
<yellow>		banks[1] |= MCI_STATUS_OVER;</yellow>
	return 0;
}

static void kvm_vcpu_ioctl_x86_get_vcpu_events(struct kvm_vcpu *vcpu,
					       struct kvm_vcpu_events *events)
{
	struct kvm_queued_exception *ex;

<blue>	process_nmi(vcpu);</blue>

<yellow>	if (kvm_check_request(KVM_REQ_SMI, vcpu))</yellow>
		process_smi(vcpu);

	/*
	 * KVM&#x27;s ABI only allows for one exception to be migrated.  Luckily,
	 * the only time there can be two queued exceptions is if there&#x27;s a
	 * non-exiting _injected_ exception, and a pending exiting exception.
	 * In that case, ignore the VM-Exiting exception as it&#x27;s an extension
	 * of the injected exception.
	 */
<blue>	if (vcpu->arch.exception_vmexit.pending &&</blue>
<yellow>	    !vcpu->arch.exception.pending &&</yellow>
<yellow>	    !vcpu->arch.exception.injected)</yellow>
<yellow>		ex = &vcpu->arch.exception_vmexit;</yellow>
	else
<blue>		ex = &vcpu->arch.exception;</blue>

	/*
	 * In guest mode, payload delivery should be deferred if the exception
	 * will be intercepted by L1, e.g. KVM should not modifying CR2 if L1
	 * intercepts #PF, ditto for DR6 and #DBs.  If the per-VM capability,
	 * KVM_CAP_EXCEPTION_PAYLOAD, is not set, userspace may or may not
	 * propagate the payload and so it cannot be safely deferred.  Deliver
	 * the payload if the capability hasn&#x27;t been requested.
	 */
<blue>	if (!vcpu->kvm->arch.exception_payload_enabled &&</blue>
<yellow>	    ex->pending && ex->has_payload)</yellow>
<yellow>		kvm_deliver_exception_payload(vcpu, ex);</yellow>

	/*
	 * The API doesn&#x27;t provide the instruction length for software
	 * exceptions, so don&#x27;t report them. As long as the guest RIP
	 * isn&#x27;t advanced, we should expect to encounter the exception
	 * again.
	 */
<blue>	if (kvm_exception_is_soft(ex->vector)) {</blue>
<yellow>		events->exception.injected = 0;</yellow>
		events-&gt;exception.pending = 0;
	} else {
<blue>		events->exception.injected = ex->injected;</blue>
<blue>		events->exception.pending = ex->pending;</blue>
		/*
		 * For ABI compatibility, deliberately conflate
		 * pending and injected exceptions when
		 * KVM_CAP_EXCEPTION_PAYLOAD isn&#x27;t enabled.
		 */
<blue>		if (!vcpu->kvm->arch.exception_payload_enabled)</blue>
<yellow>			events->exception.injected |= ex->pending;</yellow>
	}
<blue>	events->exception.nr = ex->vector;</blue>
<blue>	events->exception.has_error_code = ex->has_error_code;</blue>
	events-&gt;exception.error_code = ex-&gt;error_code;
<blue>	events->exception_has_payload = ex->has_payload;</blue>
	events-&gt;exception_payload = ex-&gt;payload;

<blue>	events->interrupt.injected =</blue>
<blue>		vcpu->arch.interrupt.injected && !vcpu->arch.interrupt.soft;</blue>
	events-&gt;interrupt.nr = vcpu-&gt;arch.interrupt.nr;
	events-&gt;interrupt.soft = 0;
	events-&gt;interrupt.shadow = static_call(kvm_x86_get_interrupt_shadow)(vcpu);

<blue>	events->nmi.injected = vcpu->arch.nmi_injected;</blue>
	events-&gt;nmi.pending = vcpu-&gt;arch.nmi_pending != 0;
	events-&gt;nmi.masked = static_call(kvm_x86_get_nmi_mask)(vcpu);
	events-&gt;nmi.pad = 0;

	events-&gt;sipi_vector = 0; /* never valid when reporting to user space */

	events-&gt;smi.smm = is_smm(vcpu);
<blue>	events->smi.pending = vcpu->arch.smi_pending;</blue>
	events-&gt;smi.smm_inside_nmi =
		!!(vcpu-&gt;arch.hflags &amp; HF_SMM_INSIDE_NMI_MASK);
<blue>	events->smi.latched_init = kvm_lapic_latched_init(vcpu);</blue>

	events-&gt;flags = (KVM_VCPUEVENT_VALID_NMI_PENDING
			 | KVM_VCPUEVENT_VALID_SHADOW
			 | KVM_VCPUEVENT_VALID_SMM);
<blue>	if (vcpu->kvm->arch.exception_payload_enabled)</blue>
<blue>		events->flags |= KVM_VCPUEVENT_VALID_PAYLOAD;</blue>
<blue>	if (vcpu->kvm->arch.triple_fault_event) {</blue>
<yellow>		events->triple_fault.pending = kvm_test_request(KVM_REQ_TRIPLE_FAULT, vcpu);</yellow>
		events-&gt;flags |= KVM_VCPUEVENT_VALID_TRIPLE_FAULT;
	}

<blue>	memset(&events->reserved, 0, sizeof(events->reserved));</blue>
}

static void kvm_smm_changed(struct kvm_vcpu *vcpu, bool entering_smm);

static int kvm_vcpu_ioctl_x86_set_vcpu_events(struct kvm_vcpu *vcpu,
					      struct kvm_vcpu_events *events)
{
<blue>	if (events->flags & ~(KVM_VCPUEVENT_VALID_NMI_PENDING</blue>
			      | KVM_VCPUEVENT_VALID_SIPI_VECTOR
			      | KVM_VCPUEVENT_VALID_SHADOW
			      | KVM_VCPUEVENT_VALID_SMM
			      | KVM_VCPUEVENT_VALID_PAYLOAD
			      | KVM_VCPUEVENT_VALID_TRIPLE_FAULT))
		return -EINVAL;

<blue>	if (events->flags & KVM_VCPUEVENT_VALID_PAYLOAD) {</blue>
<blue>		if (!vcpu->kvm->arch.exception_payload_enabled)</blue>
			return -EINVAL;
<blue>		if (events->exception.pending)</blue>
<blue>			events->exception.injected = 0;</blue>
		else
<blue>			events->exception_has_payload = 0;</blue>
	} else {
<blue>		events->exception.pending = 0;</blue>
		events-&gt;exception_has_payload = 0;
	}

<blue>	if ((events->exception.injected || events->exception.pending) &&</blue>
<blue>	    (events->exception.nr > 31 || events->exception.nr == NMI_VECTOR))</blue>
		return -EINVAL;

	/* INITs are latched while in SMM */
<blue>	if (events->flags & KVM_VCPUEVENT_VALID_SMM &&</blue>
<blue>	    (events->smi.smm || events->smi.pending) &&</blue>
<blue>	    vcpu->arch.mp_state == KVM_MP_STATE_INIT_RECEIVED)</blue>
		return -EINVAL;

<blue>	process_nmi(vcpu);</blue>

	/*
	 * Flag that userspace is stuffing an exception, the next KVM_RUN will
	 * morph the exception to a VM-Exit if appropriate.  Do this only for
	 * pending exceptions, already-injected exceptions are not subject to
	 * intercpetion.  Note, userspace that conflates pending and injected
	 * is hosed, and will incorrectly convert an injected exception into a
	 * pending exception, which in turn may cause a spurious VM-Exit.
	 */
	vcpu-&gt;arch.exception_from_userspace = events-&gt;exception.pending;

	vcpu-&gt;arch.exception_vmexit.pending = false;

	vcpu-&gt;arch.exception.injected = events-&gt;exception.injected;
	vcpu-&gt;arch.exception.pending = events-&gt;exception.pending;
	vcpu-&gt;arch.exception.vector = events-&gt;exception.nr;
	vcpu-&gt;arch.exception.has_error_code = events-&gt;exception.has_error_code;
	vcpu-&gt;arch.exception.error_code = events-&gt;exception.error_code;
	vcpu-&gt;arch.exception.has_payload = events-&gt;exception_has_payload;
	vcpu-&gt;arch.exception.payload = events-&gt;exception_payload;

	vcpu-&gt;arch.interrupt.injected = events-&gt;interrupt.injected;
	vcpu-&gt;arch.interrupt.nr = events-&gt;interrupt.nr;
	vcpu-&gt;arch.interrupt.soft = events-&gt;interrupt.soft;
	if (events-&gt;flags &amp; KVM_VCPUEVENT_VALID_SHADOW)
		static_call(kvm_x86_set_interrupt_shadow)(vcpu,
<blue>						events->interrupt.shadow);</blue>

<blue>	vcpu->arch.nmi_injected = events->nmi.injected;</blue>
	if (events-&gt;flags &amp; KVM_VCPUEVENT_VALID_NMI_PENDING)
<blue>		vcpu->arch.nmi_pending = events->nmi.pending;</blue>
<blue>	static_call(kvm_x86_set_nmi_mask)(vcpu, events->nmi.masked);</blue>

	if (events-&gt;flags &amp; KVM_VCPUEVENT_VALID_SIPI_VECTOR &amp;&amp;
<blue>	    lapic_in_kernel(vcpu))</blue>
<blue>		vcpu->arch.apic->sipi_vector = events->sipi_vector;</blue>

<blue>	if (events->flags & KVM_VCPUEVENT_VALID_SMM) {</blue>
<blue>		if (!!(vcpu->arch.hflags & HF_SMM_MASK) != events->smi.smm) {</blue>
<blue>			kvm_leave_nested(vcpu);</blue>
			kvm_smm_changed(vcpu, events-&gt;smi.smm);
		}

<blue>		vcpu->arch.smi_pending = events->smi.pending;</blue>

		if (events-&gt;smi.smm) {
<blue>			if (events->smi.smm_inside_nmi)</blue>
<blue>				vcpu->arch.hflags |= HF_SMM_INSIDE_NMI_MASK;</blue>
			else
<yellow>				vcpu->arch.hflags &= ~HF_SMM_INSIDE_NMI_MASK;</yellow>
		}

<blue>		if (lapic_in_kernel(vcpu)) {</blue>
<blue>			if (events->smi.latched_init)</blue>
<blue>				set_bit(KVM_APIC_INIT, &vcpu->arch.apic->pending_events);</blue>
			else
<blue>				clear_bit(KVM_APIC_INIT, &vcpu->arch.apic->pending_events);</blue>
		}
	}

<blue>	if (events->flags & KVM_VCPUEVENT_VALID_TRIPLE_FAULT) {</blue>
<yellow>		if (!vcpu->kvm->arch.triple_fault_event)</yellow>
			return -EINVAL;
<yellow>		if (events->triple_fault.pending)</yellow>
<blue>			kvm_make_request(KVM_REQ_TRIPLE_FAULT, vcpu);</blue>
		else
<yellow>			kvm_clear_request(KVM_REQ_TRIPLE_FAULT, vcpu);</yellow>
	}

<blue>	kvm_make_request(KVM_REQ_EVENT, vcpu);</blue>

	return 0;
<blue>}</blue>

static void kvm_vcpu_ioctl_x86_get_debugregs(struct kvm_vcpu *vcpu,
					     struct kvm_debugregs *dbgregs)
{
	unsigned long val;

<blue>	memcpy(dbgregs->db, vcpu->arch.db, sizeof(vcpu->arch.db));</blue>
	kvm_get_dr(vcpu, 6, &amp;val);
	dbgregs-&gt;dr6 = val;
	dbgregs-&gt;dr7 = vcpu-&gt;arch.dr7;
	dbgregs-&gt;flags = 0;
	memset(&amp;dbgregs-&gt;reserved, 0, sizeof(dbgregs-&gt;reserved));
}

static int kvm_vcpu_ioctl_x86_set_debugregs(struct kvm_vcpu *vcpu,
					    struct kvm_debugregs *dbgregs)
{
	if (dbgregs-&gt;flags)
		return -EINVAL;

<blue>	if (!kvm_dr6_valid(dbgregs->dr6))</blue>
		return -EINVAL;
	if (!kvm_dr7_valid(dbgregs-&gt;dr7))
		return -EINVAL;

<blue>	memcpy(vcpu->arch.db, dbgregs->db, sizeof(vcpu->arch.db));</blue>
<blue>	kvm_update_dr0123(vcpu);</blue>
<yellow>	vcpu->arch.dr6 = dbgregs->dr6;</yellow>
	vcpu-&gt;arch.dr7 = dbgregs-&gt;dr7;
<blue>	kvm_update_dr7(vcpu);</blue>

	return 0;
}

static void kvm_vcpu_ioctl_x86_get_xsave(struct kvm_vcpu *vcpu,
					 struct kvm_xsave *guest_xsave)
{
<blue>	if (fpstate_is_confidential(&vcpu->arch.guest_fpu))</blue>
		return;

<blue>	fpu_copy_guest_fpstate_to_uabi(&vcpu->arch.guest_fpu,</blue>
				       guest_xsave-&gt;region,
				       sizeof(guest_xsave-&gt;region),
				       vcpu-&gt;arch.pkru);
}

static void kvm_vcpu_ioctl_x86_get_xsave2(struct kvm_vcpu *vcpu,
					  u8 *state, unsigned int size)
{
<blue>	if (fpstate_is_confidential(&vcpu->arch.guest_fpu))</blue>
		return;

<blue>	fpu_copy_guest_fpstate_to_uabi(&vcpu->arch.guest_fpu,</blue>
				       state, size, vcpu-&gt;arch.pkru);
}

static int kvm_vcpu_ioctl_x86_set_xsave(struct kvm_vcpu *vcpu,
					struct kvm_xsave *guest_xsave)
{
<blue>	if (fpstate_is_confidential(&vcpu->arch.guest_fpu))</blue>
		return 0;

<blue>	return fpu_copy_uabi_to_guest_fpstate(&vcpu->arch.guest_fpu,</blue>
					      guest_xsave-&gt;region,
					      kvm_caps.supported_xcr0,
					      &amp;vcpu-&gt;arch.pkru);
}

static void kvm_vcpu_ioctl_x86_get_xcrs(struct kvm_vcpu *vcpu,
					struct kvm_xcrs *guest_xcrs)
{
<blue>	if (!boot_cpu_has(X86_FEATURE_XSAVE)) {</blue>
<yellow>		guest_xcrs->nr_xcrs = 0;</yellow>
		return;
	}

<blue>	guest_xcrs->nr_xcrs = 1;</blue>
	guest_xcrs-&gt;flags = 0;
	guest_xcrs-&gt;xcrs[0].xcr = XCR_XFEATURE_ENABLED_MASK;
	guest_xcrs-&gt;xcrs[0].value = vcpu-&gt;arch.xcr0;
}

static int kvm_vcpu_ioctl_x86_set_xcrs(struct kvm_vcpu *vcpu,
				       struct kvm_xcrs *guest_xcrs)
{
	int i, r = 0;

<blue>	if (!boot_cpu_has(X86_FEATURE_XSAVE))</blue>
		return -EINVAL;

<blue>	if (guest_xcrs->nr_xcrs > KVM_MAX_XCRS || guest_xcrs->flags)</blue>
		return -EINVAL;

<blue>	for (i = 0; i < guest_xcrs->nr_xcrs; i++)</blue>
		/* Only support XCR0 currently */
<blue>		if (guest_xcrs->xcrs[i].xcr == XCR_XFEATURE_ENABLED_MASK) {</blue>
			r = __kvm_set_xcr(vcpu, XCR_XFEATURE_ENABLED_MASK,
<blue>				guest_xcrs->xcrs[i].value);</blue>
			break;
		}
	if (r)
		r = -EINVAL;
	return r;
}

/*
 * kvm_set_guest_paused() indicates to the guest kernel that it has been
 * stopped by the hypervisor.  This function will be called from the host only.
 * EINVAL is returned when the host attempts to set the flag for a guest that
 * does not support pv clocks.
 */
static int kvm_set_guest_paused(struct kvm_vcpu *vcpu)
{
<blue>	if (!vcpu->arch.pv_time.active)</blue>
		return -EINVAL;
<yellow>	vcpu->arch.pvclock_set_guest_stopped_request = true;</yellow>
	kvm_make_request(KVM_REQ_CLOCK_UPDATE, vcpu);
	return 0;
}

static int kvm_arch_tsc_has_attr(struct kvm_vcpu *vcpu,
				 struct kvm_device_attr *attr)
{
	int r;

<yellow>	switch (attr->attr) {</yellow>
	case KVM_VCPU_TSC_OFFSET:
		r = 0;
		break;
	default:
		r = -ENXIO;
	}

	return r;
}

static int kvm_arch_tsc_get_attr(struct kvm_vcpu *vcpu,
				 struct kvm_device_attr *attr)
{
<yellow>	u64 __user *uaddr = kvm_get_attr_addr(attr);</yellow>
	int r;

	if (IS_ERR(uaddr))
		return PTR_ERR(uaddr);

<yellow>	switch (attr->attr) {</yellow>
	case KVM_VCPU_TSC_OFFSET:
		r = -EFAULT;
<yellow>		if (put_user(vcpu->arch.l1_tsc_offset, uaddr))</yellow>
			break;
		r = 0;
		break;
	default:
		r = -ENXIO;
	}

	return r;
}

static int kvm_arch_tsc_set_attr(struct kvm_vcpu *vcpu,
				 struct kvm_device_attr *attr)
{
	u64 __user *uaddr = kvm_get_attr_addr(attr);
<yellow>	struct kvm *kvm = vcpu->kvm;</yellow>
	int r;

	if (IS_ERR(uaddr))
<yellow>		return PTR_ERR(uaddr);</yellow>

<yellow>	switch (attr->attr) {</yellow>
	case KVM_VCPU_TSC_OFFSET: {
		u64 offset, tsc, ns;
		unsigned long flags;
		bool matched;

		r = -EFAULT;
<yellow>		if (get_user(offset, uaddr))</yellow>
			break;

<yellow>		raw_spin_lock_irqsave(&kvm->arch.tsc_write_lock, flags);</yellow>

		matched = (vcpu-&gt;arch.virtual_tsc_khz &amp;&amp;
<yellow>			   kvm->arch.last_tsc_khz == vcpu->arch.virtual_tsc_khz &&</yellow>
<yellow>			   kvm->arch.last_tsc_offset == offset);</yellow>

<yellow>		tsc = kvm_scale_tsc(rdtsc(), vcpu->arch.l1_tsc_scaling_ratio) + offset;</yellow>
		ns = get_kvmclock_base_ns();

		__kvm_synchronize_tsc(vcpu, offset, tsc, ns, matched);
		raw_spin_unlock_irqrestore(&amp;kvm-&gt;arch.tsc_write_lock, flags);

		r = 0;
		break;
	}
	default:
		r = -ENXIO;
	}

	return r;
}

static int kvm_vcpu_ioctl_device_attr(struct kvm_vcpu *vcpu,
				      unsigned int ioctl,
				      void __user *argp)
{
	struct kvm_device_attr attr;
	int r;

<yellow>	if (copy_from_user(&attr, argp, sizeof(attr)))</yellow>
		return -EFAULT;

<yellow>	if (attr.group != KVM_VCPU_TSC_CTRL)</yellow>
		return -ENXIO;

<yellow>	switch (ioctl) {</yellow>
	case KVM_HAS_DEVICE_ATTR:
<yellow>		r = kvm_arch_tsc_has_attr(vcpu, &attr);</yellow>
		break;
	case KVM_GET_DEVICE_ATTR:
<yellow>		r = kvm_arch_tsc_get_attr(vcpu, &attr);</yellow>
		break;
	case KVM_SET_DEVICE_ATTR:
<yellow>		r = kvm_arch_tsc_set_attr(vcpu, &attr);</yellow>
		break;
	}

	return r;
}

static int kvm_vcpu_ioctl_enable_cap(struct kvm_vcpu *vcpu,
				     struct kvm_enable_cap *cap)
{
	int r;
	uint16_t vmcs_version;
	void __user *user_ptr;

<blue>	if (cap->flags)</blue>
		return -EINVAL;

<blue>	switch (cap->cap) {</blue>
	case KVM_CAP_HYPERV_SYNIC2:
<blue>		if (cap->args[0])</blue>
			return -EINVAL;
		fallthrough;

	case KVM_CAP_HYPERV_SYNIC:
<blue>		if (!irqchip_in_kernel(vcpu->kvm))</blue>
			return -EINVAL;
<blue>		return kvm_hv_activate_synic(vcpu, cap->cap ==</blue>
					     KVM_CAP_HYPERV_SYNIC2);
	case KVM_CAP_HYPERV_ENLIGHTENED_VMCS:
<blue>		if (!kvm_x86_ops.nested_ops->enable_evmcs)</blue>
			return -ENOTTY;
<blue>		r = kvm_x86_ops.nested_ops->enable_evmcs(vcpu, &vmcs_version);</blue>
		if (!r) {
			user_ptr = (void __user *)(uintptr_t)cap-&gt;args[0];
<blue>			if (copy_to_user(user_ptr, &vmcs_version,</blue>
					 sizeof(vmcs_version)))
				r = -EFAULT;
		}
		return r;
	case KVM_CAP_HYPERV_DIRECT_TLBFLUSH:
<yellow>		if (!kvm_x86_ops.enable_direct_tlbflush)</yellow>
			return -ENOTTY;

<yellow>		return static_call(kvm_x86_enable_direct_tlbflush)(vcpu);</yellow>

	case KVM_CAP_HYPERV_ENFORCE_CPUID:
<blue>		return kvm_hv_set_enforce_cpuid(vcpu, cap->args[0]);</blue>

	case KVM_CAP_ENFORCE_PV_FEATURE_CPUID:
<yellow>		vcpu->arch.pv_cpuid.enforce = cap->args[0];</yellow>
<yellow>		if (vcpu->arch.pv_cpuid.enforce)</yellow>
<yellow>			kvm_update_pv_runtime(vcpu);</yellow>

		return 0;
	default:
		return -EINVAL;
	}
}

long kvm_arch_vcpu_ioctl(struct file *filp,
			 unsigned int ioctl, unsigned long arg)
{
<blue>	struct kvm_vcpu *vcpu = filp->private_data;</blue>
	void __user *argp = (void __user *)arg;
	int r;
	union {
		struct kvm_sregs2 *sregs2;
		struct kvm_lapic_state *lapic;
		struct kvm_xsave *xsave;
		struct kvm_xcrs *xcrs;
		void *buffer;
	} u;

	vcpu_load(vcpu);

<blue>	u.buffer = NULL;</blue>
	switch (ioctl) {
	case KVM_GET_LAPIC: {
		r = -EINVAL;
<blue>		if (!lapic_in_kernel(vcpu))</blue>
			goto out;
<blue>		u.lapic = kzalloc(sizeof(struct kvm_lapic_state),</blue>
				GFP_KERNEL_ACCOUNT);

		r = -ENOMEM;
		if (!u.lapic)
			goto out;
<blue>		r = kvm_vcpu_ioctl_get_lapic(vcpu, u.lapic);</blue>
		if (r)
			goto out;
		r = -EFAULT;
<blue>		if (copy_to_user(argp, u.lapic, sizeof(struct kvm_lapic_state)))</blue>
			goto out;
		r = 0;
		break;
	}
	case KVM_SET_LAPIC: {
		r = -EINVAL;
<blue>		if (!lapic_in_kernel(vcpu))</blue>
			goto out;
<blue>		u.lapic = memdup_user(argp, sizeof(*u.lapic));</blue>
		if (IS_ERR(u.lapic)) {
			r = PTR_ERR(u.lapic);
			goto out_nofree;
		}

<blue>		r = kvm_vcpu_ioctl_set_lapic(vcpu, u.lapic);</blue>
		break;
	}
	case KVM_INTERRUPT: {
		struct kvm_interrupt irq;

		r = -EFAULT;
<blue>		if (copy_from_user(&irq, argp, sizeof(irq)))</blue>
			goto out;
<blue>		r = kvm_vcpu_ioctl_interrupt(vcpu, &irq);</blue>
		break;
	}
	case KVM_NMI: {
<yellow>		r = kvm_vcpu_ioctl_nmi(vcpu);</yellow>
		break;
	}
	case KVM_SMI: {
<yellow>		r = kvm_vcpu_ioctl_smi(vcpu);</yellow>
		break;
	}
	case KVM_SET_CPUID: {
		struct kvm_cpuid __user *cpuid_arg = argp;
		struct kvm_cpuid cpuid;

		r = -EFAULT;
<yellow>		if (copy_from_user(&cpuid, cpuid_arg, sizeof(cpuid)))</yellow>
			goto out;
<yellow>		r = kvm_vcpu_ioctl_set_cpuid(vcpu, &cpuid, cpuid_arg->entries);</yellow>
		break;
	}
	case KVM_SET_CPUID2: {
		struct kvm_cpuid2 __user *cpuid_arg = argp;
		struct kvm_cpuid2 cpuid;

		r = -EFAULT;
<blue>		if (copy_from_user(&cpuid, cpuid_arg, sizeof(cpuid)))</blue>
			goto out;
<blue>		r = kvm_vcpu_ioctl_set_cpuid2(vcpu, &cpuid,</blue>
					      cpuid_arg-&gt;entries);
		break;
	}
	case KVM_GET_CPUID2: {
		struct kvm_cpuid2 __user *cpuid_arg = argp;
		struct kvm_cpuid2 cpuid;

		r = -EFAULT;
<yellow>		if (copy_from_user(&cpuid, cpuid_arg, sizeof(cpuid)))</yellow>
			goto out;
<yellow>		r = kvm_vcpu_ioctl_get_cpuid2(vcpu, &cpuid,</yellow>
					      cpuid_arg-&gt;entries);
		if (r)
			goto out;
		r = -EFAULT;
<yellow>		if (copy_to_user(cpuid_arg, &cpuid, sizeof(cpuid)))</yellow>
			goto out;
		r = 0;
		break;
	}
	case KVM_GET_MSRS: {
<blue>		int idx = srcu_read_lock(&vcpu->kvm->srcu);</blue>
		r = msr_io(vcpu, argp, do_get_msr, 1);
<blue>		srcu_read_unlock(&vcpu->kvm->srcu, idx);</blue>
		break;
	}
	case KVM_SET_MSRS: {
<blue>		int idx = srcu_read_lock(&vcpu->kvm->srcu);</blue>
<blue>		r = msr_io(vcpu, argp, do_set_msr, 0);</blue>
<blue>		srcu_read_unlock(&vcpu->kvm->srcu, idx);</blue>
		break;
	}
	case KVM_TPR_ACCESS_REPORTING: {
		struct kvm_tpr_access_ctl tac;

		r = -EFAULT;
<blue>		if (copy_from_user(&tac, argp, sizeof(tac)))</blue>
			goto out;
<blue>		r = vcpu_ioctl_tpr_access_reporting(vcpu, &tac);</blue>
		if (r)
			goto out;
		r = -EFAULT;
		if (copy_to_user(argp, &amp;tac, sizeof(tac)))
			goto out;
		r = 0;
<blue>		break;</blue>
	};
	case KVM_SET_VAPIC_ADDR: {
		struct kvm_vapic_addr va;
		int idx;

		r = -EINVAL;
<blue>		if (!lapic_in_kernel(vcpu))</blue>
			goto out;
		r = -EFAULT;
<blue>		if (copy_from_user(&va, argp, sizeof(va)))</blue>
			goto out;
<blue>		idx = srcu_read_lock(&vcpu->kvm->srcu);</blue>
		r = kvm_lapic_set_vapic_addr(vcpu, va.vapic_addr);
<blue>		srcu_read_unlock(&vcpu->kvm->srcu, idx);</blue>
		break;
	}
	case KVM_X86_SETUP_MCE: {
		u64 mcg_cap;

		r = -EFAULT;
<blue>		if (copy_from_user(&mcg_cap, argp, sizeof(mcg_cap)))</blue>
			goto out;
<blue>		r = kvm_vcpu_ioctl_x86_setup_mce(vcpu, mcg_cap);</blue>
		break;
	}
	case KVM_X86_SET_MCE: {
		struct kvm_x86_mce mce;

		r = -EFAULT;
<yellow>		if (copy_from_user(&mce, argp, sizeof(mce)))</yellow>
			goto out;
<yellow>		r = kvm_vcpu_ioctl_x86_set_mce(vcpu, &mce);</yellow>
		break;
	}
	case KVM_GET_VCPU_EVENTS: {
		struct kvm_vcpu_events events;

<blue>		kvm_vcpu_ioctl_x86_get_vcpu_events(vcpu, &events);</blue>

		r = -EFAULT;
		if (copy_to_user(argp, &amp;events, sizeof(struct kvm_vcpu_events)))
			break;
		r = 0;
		break;
	}
	case KVM_SET_VCPU_EVENTS: {
		struct kvm_vcpu_events events;

		r = -EFAULT;
<blue>		if (copy_from_user(&events, argp, sizeof(struct kvm_vcpu_events)))</blue>
			break;

<blue>		r = kvm_vcpu_ioctl_x86_set_vcpu_events(vcpu, &events);</blue>
		break;
	}
	case KVM_GET_DEBUGREGS: {
		struct kvm_debugregs dbgregs;

<blue>		kvm_vcpu_ioctl_x86_get_debugregs(vcpu, &dbgregs);</blue>

		r = -EFAULT;
		if (copy_to_user(argp, &amp;dbgregs,
				 sizeof(struct kvm_debugregs)))
			break;
		r = 0;
		break;
	}
	case KVM_SET_DEBUGREGS: {
		struct kvm_debugregs dbgregs;

		r = -EFAULT;
<blue>		if (copy_from_user(&dbgregs, argp,</blue>
				   sizeof(struct kvm_debugregs)))
			break;

<blue>		r = kvm_vcpu_ioctl_x86_set_debugregs(vcpu, &dbgregs);</blue>
		break;
	}
	case KVM_GET_XSAVE: {
		r = -EINVAL;
<blue>		if (vcpu->arch.guest_fpu.uabi_size > sizeof(struct kvm_xsave))</blue>
			break;

<blue>		u.xsave = kzalloc(sizeof(struct kvm_xsave), GFP_KERNEL_ACCOUNT);</blue>
		r = -ENOMEM;
		if (!u.xsave)
			break;

<blue>		kvm_vcpu_ioctl_x86_get_xsave(vcpu, u.xsave);</blue>

		r = -EFAULT;
<blue>		if (copy_to_user(argp, u.xsave, sizeof(struct kvm_xsave)))</blue>
			break;
		r = 0;
		break;
	}
	case KVM_SET_XSAVE: {
<blue>		int size = vcpu->arch.guest_fpu.uabi_size;</blue>

		u.xsave = memdup_user(argp, size);
		if (IS_ERR(u.xsave)) {
			r = PTR_ERR(u.xsave);
			goto out_nofree;
		}

<blue>		r = kvm_vcpu_ioctl_x86_set_xsave(vcpu, u.xsave);</blue>
		break;
	}

	case KVM_GET_XSAVE2: {
<blue>		int size = vcpu->arch.guest_fpu.uabi_size;</blue>

		u.xsave = kzalloc(size, GFP_KERNEL_ACCOUNT);
		r = -ENOMEM;
		if (!u.xsave)
			break;

<blue>		kvm_vcpu_ioctl_x86_get_xsave2(vcpu, u.buffer, size);</blue>

		r = -EFAULT;
<blue>		if (copy_to_user(argp, u.xsave, size))</blue>
			break;

		r = 0;
		break;
	}

	case KVM_GET_XCRS: {
<blue>		u.xcrs = kzalloc(sizeof(struct kvm_xcrs), GFP_KERNEL_ACCOUNT);</blue>
		r = -ENOMEM;
		if (!u.xcrs)
			break;

<blue>		kvm_vcpu_ioctl_x86_get_xcrs(vcpu, u.xcrs);</blue>

		r = -EFAULT;
<blue>		if (copy_to_user(argp, u.xcrs,</blue>
				 sizeof(struct kvm_xcrs)))
			break;
		r = 0;
		break;
	}
	case KVM_SET_XCRS: {
<blue>		u.xcrs = memdup_user(argp, sizeof(*u.xcrs));</blue>
		if (IS_ERR(u.xcrs)) {
			r = PTR_ERR(u.xcrs);
			goto out_nofree;
		}

<blue>		r = kvm_vcpu_ioctl_x86_set_xcrs(vcpu, u.xcrs);</blue>
		break;
	}
	case KVM_SET_TSC_KHZ: {
		u32 user_tsc_khz;

		r = -EINVAL;
		user_tsc_khz = (u32)arg;

<blue>		if (kvm_caps.has_tsc_control &&</blue>
<blue>		    user_tsc_khz >= kvm_caps.max_guest_tsc_khz)</blue>
			goto out;

<blue>		if (user_tsc_khz == 0)</blue>
<yellow>			user_tsc_khz = tsc_khz;</yellow>

<blue>		if (!kvm_set_tsc_khz(vcpu, user_tsc_khz))</blue>
			r = 0;

		goto out;
	}
	case KVM_GET_TSC_KHZ: {
<blue>		r = vcpu->arch.virtual_tsc_khz;</blue>
		goto out;
	}
	case KVM_KVMCLOCK_CTRL: {
<blue>		r = kvm_set_guest_paused(vcpu);</blue>
		goto out;
	}
	case KVM_ENABLE_CAP: {
		struct kvm_enable_cap cap;

		r = -EFAULT;
<blue>		if (copy_from_user(&cap, argp, sizeof(cap)))</blue>
			goto out;
<blue>		r = kvm_vcpu_ioctl_enable_cap(vcpu, &cap);</blue>
		break;
	}
	case KVM_GET_NESTED_STATE: {
		struct kvm_nested_state __user *user_kvm_nested_state = argp;
		u32 user_data_size;

		r = -EINVAL;
<blue>		if (!kvm_x86_ops.nested_ops->get_state)</blue>
			break;

		BUILD_BUG_ON(sizeof(user_data_size) != sizeof(user_kvm_nested_state-&gt;size));
		r = -EFAULT;
<blue>		if (get_user(user_data_size, &user_kvm_nested_state->size))</blue>
			break;

<blue>		r = kvm_x86_ops.nested_ops->get_state(vcpu, user_kvm_nested_state,</blue>
						     user_data_size);
		if (r &lt; 0)
			break;

<blue>		if (r > user_data_size) {</blue>
<blue>			if (put_user(r, &user_kvm_nested_state->size))</blue>
				r = -EFAULT;
			else
				r = -E2BIG;
			break;
		}

		r = 0;
		break;
	}
	case KVM_SET_NESTED_STATE: {
		struct kvm_nested_state __user *user_kvm_nested_state = argp;
		struct kvm_nested_state kvm_state;
		int idx;

		r = -EINVAL;
<blue>		if (!kvm_x86_ops.nested_ops->set_state)</blue>
			break;

		r = -EFAULT;
<blue>		if (copy_from_user(&kvm_state, user_kvm_nested_state, sizeof(kvm_state)))</blue>
			break;

		r = -EINVAL;
<blue>		if (kvm_state.size < sizeof(kvm_state))</blue>
			break;

<blue>		if (kvm_state.flags &</blue>
		    ~(KVM_STATE_NESTED_RUN_PENDING | KVM_STATE_NESTED_GUEST_MODE
		      | KVM_STATE_NESTED_EVMCS | KVM_STATE_NESTED_MTF_PENDING
		      | KVM_STATE_NESTED_GIF_SET))
			break;

		/* nested_run_pending implies guest_mode.  */
<blue>		if ((kvm_state.flags & KVM_STATE_NESTED_RUN_PENDING)</blue>
		    &amp;&amp; !(kvm_state.flags &amp; KVM_STATE_NESTED_GUEST_MODE))
			break;

<blue>		idx = srcu_read_lock(&vcpu->kvm->srcu);</blue>
		r = kvm_x86_ops.nested_ops-&gt;set_state(vcpu, user_kvm_nested_state, &amp;kvm_state);
<blue>		srcu_read_unlock(&vcpu->kvm->srcu, idx);</blue>
		break;
	}
	case KVM_GET_SUPPORTED_HV_CPUID:
<blue>		r = kvm_ioctl_get_supported_hv_cpuid(vcpu, argp);</blue>
		break;
#ifdef CONFIG_KVM_XEN
	case KVM_XEN_VCPU_GET_ATTR: {
		struct kvm_xen_vcpu_attr xva;

		r = -EFAULT;
<yellow>		if (copy_from_user(&xva, argp, sizeof(xva)))</yellow>
			goto out;
<yellow>		r = kvm_xen_vcpu_get_attr(vcpu, &xva);</yellow>
<yellow>		if (!r && copy_to_user(argp, &xva, sizeof(xva)))</yellow>
			r = -EFAULT;
		break;
	}
	case KVM_XEN_VCPU_SET_ATTR: {
		struct kvm_xen_vcpu_attr xva;

		r = -EFAULT;
<yellow>		if (copy_from_user(&xva, argp, sizeof(xva)))</yellow>
<yellow>			goto out;</yellow>
<yellow>		r = kvm_xen_vcpu_set_attr(vcpu, &xva);</yellow>
		break;
	}
#endif
	case KVM_GET_SREGS2: {
<blue>		u.sregs2 = kzalloc(sizeof(struct kvm_sregs2), GFP_KERNEL);</blue>
		r = -ENOMEM;
		if (!u.sregs2)
			goto out;
<blue>		__get_sregs2(vcpu, u.sregs2);</blue>
		r = -EFAULT;
<blue>		if (copy_to_user(argp, u.sregs2, sizeof(struct kvm_sregs2)))</blue>
			goto out;
		r = 0;
		break;
	}
	case KVM_SET_SREGS2: {
<blue>		u.sregs2 = memdup_user(argp, sizeof(struct kvm_sregs2));</blue>
		if (IS_ERR(u.sregs2)) {
			r = PTR_ERR(u.sregs2);
			u.sregs2 = NULL;
			goto out;
		}
<blue>		r = __set_sregs2(vcpu, u.sregs2);</blue>
<blue>		break;</blue>
	}
	case KVM_HAS_DEVICE_ATTR:
	case KVM_GET_DEVICE_ATTR:
	case KVM_SET_DEVICE_ATTR:
<yellow>		r = kvm_vcpu_ioctl_device_attr(vcpu, ioctl, argp);</yellow>
		break;
	default:
		r = -EINVAL;
	}
out:
<blue>	kfree(u.buffer);</blue>
out_nofree:
<blue>	vcpu_put(vcpu);</blue>
<blue>	return r;</blue>
}

vm_fault_t kvm_arch_vcpu_fault(struct kvm_vcpu *vcpu, struct vm_fault *vmf)
{
	return VM_FAULT_SIGBUS;
<yellow>}</yellow>

static int kvm_vm_ioctl_set_tss_addr(struct kvm *kvm, unsigned long addr)
{
	int ret;

<blue>	if (addr > (unsigned int)(-3 * PAGE_SIZE))</blue>
		return -EINVAL;
<blue>	ret = static_call(kvm_x86_set_tss_addr)(kvm, addr);</blue>
	return ret;
}

static int kvm_vm_ioctl_set_identity_map_addr(struct kvm *kvm,
					      u64 ident_addr)
{
<blue>	return static_call(kvm_x86_set_identity_map_addr)(kvm, ident_addr);</blue>
}

static int kvm_vm_ioctl_set_nr_mmu_pages(struct kvm *kvm,
					 unsigned long kvm_nr_mmu_pages)
{
<yellow>	if (kvm_nr_mmu_pages < KVM_MIN_ALLOC_MMU_PAGES)</yellow>
		return -EINVAL;

<yellow>	mutex_lock(&kvm->slots_lock);</yellow>

	kvm_mmu_change_mmu_pages(kvm, kvm_nr_mmu_pages);
	kvm-&gt;arch.n_requested_mmu_pages = kvm_nr_mmu_pages;

	mutex_unlock(&amp;kvm-&gt;slots_lock);
	return 0;
}

static unsigned long kvm_vm_ioctl_get_nr_mmu_pages(struct kvm *kvm)
{
<yellow>	return kvm->arch.n_max_mmu_pages;</yellow>
}

static int kvm_vm_ioctl_get_irqchip(struct kvm *kvm, struct kvm_irqchip *chip)
{
<yellow>	struct kvm_pic *pic = kvm->arch.vpic;</yellow>
	int r;

	r = 0;
	switch (chip-&gt;chip_id) {
	case KVM_IRQCHIP_PIC_MASTER:
<yellow>		memcpy(&chip->chip.pic, &pic->pics[0],</yellow>
			sizeof(struct kvm_pic_state));
		break;
	case KVM_IRQCHIP_PIC_SLAVE:
<yellow>		memcpy(&chip->chip.pic, &pic->pics[1],</yellow>
			sizeof(struct kvm_pic_state));
		break;
	case KVM_IRQCHIP_IOAPIC:
<yellow>		kvm_get_ioapic(kvm, &chip->chip.ioapic);</yellow>
		break;
	default:
		r = -EINVAL;
		break;
	}
	return r;
}

static int kvm_vm_ioctl_set_irqchip(struct kvm *kvm, struct kvm_irqchip *chip)
{
<blue>	struct kvm_pic *pic = kvm->arch.vpic;</blue>
	int r;

	r = 0;
	switch (chip-&gt;chip_id) {
	case KVM_IRQCHIP_PIC_MASTER:
<blue>		spin_lock(&pic->lock);</blue>
		memcpy(&amp;pic-&gt;pics[0], &amp;chip-&gt;chip.pic,
			sizeof(struct kvm_pic_state));
		spin_unlock(&amp;pic-&gt;lock);
		break;
	case KVM_IRQCHIP_PIC_SLAVE:
<blue>		spin_lock(&pic->lock);</blue>
		memcpy(&amp;pic-&gt;pics[1], &amp;chip-&gt;chip.pic,
			sizeof(struct kvm_pic_state));
		spin_unlock(&amp;pic-&gt;lock);
		break;
	case KVM_IRQCHIP_IOAPIC:
<blue>		kvm_set_ioapic(kvm, &chip->chip.ioapic);</blue>
		break;
	default:
		r = -EINVAL;
		break;
	}
<blue>	kvm_pic_update_irq(pic);</blue>
	return r;
}

static int kvm_vm_ioctl_get_pit(struct kvm *kvm, struct kvm_pit_state *ps)
{
	struct kvm_kpit_state *kps = &amp;kvm-&gt;arch.vpit-&gt;pit_state;

	BUILD_BUG_ON(sizeof(*ps) != sizeof(kps-&gt;channels));

<yellow>	mutex_lock(&kps->lock);</yellow>
	memcpy(ps, &amp;kps-&gt;channels, sizeof(*ps));
	mutex_unlock(&amp;kps-&gt;lock);
	return 0;
}

static int kvm_vm_ioctl_set_pit(struct kvm *kvm, struct kvm_pit_state *ps)
{
	int i;
	struct kvm_pit *pit = kvm-&gt;arch.vpit;

<yellow>	mutex_lock(&pit->pit_state.lock);</yellow>
	memcpy(&amp;pit-&gt;pit_state.channels, ps, sizeof(*ps));
	for (i = 0; i &lt; 3; i++)
<yellow>		kvm_pit_load_count(pit, i, ps->channels[i].count, 0);</yellow>
<yellow>	mutex_unlock(&pit->pit_state.lock);</yellow>
	return 0;
}

static int kvm_vm_ioctl_get_pit2(struct kvm *kvm, struct kvm_pit_state2 *ps)
{
<blue>	mutex_lock(&kvm->arch.vpit->pit_state.lock);</blue>
	memcpy(ps-&gt;channels, &amp;kvm-&gt;arch.vpit-&gt;pit_state.channels,
		sizeof(ps-&gt;channels));
	ps-&gt;flags = kvm-&gt;arch.vpit-&gt;pit_state.flags;
	mutex_unlock(&amp;kvm-&gt;arch.vpit-&gt;pit_state.lock);
	memset(&amp;ps-&gt;reserved, 0, sizeof(ps-&gt;reserved));
	return 0;
}

static int kvm_vm_ioctl_set_pit2(struct kvm *kvm, struct kvm_pit_state2 *ps)
{
	int start = 0;
	int i;
	u32 prev_legacy, cur_legacy;
	struct kvm_pit *pit = kvm-&gt;arch.vpit;

<blue>	mutex_lock(&pit->pit_state.lock);</blue>
	prev_legacy = pit-&gt;pit_state.flags &amp; KVM_PIT_FLAGS_HPET_LEGACY;
<blue>	cur_legacy = ps->flags & KVM_PIT_FLAGS_HPET_LEGACY;</blue>
	if (!prev_legacy &amp;&amp; cur_legacy)
		start = 1;
<blue>	memcpy(&pit->pit_state.channels, &ps->channels,</blue>
	       sizeof(pit-&gt;pit_state.channels));
	pit-&gt;pit_state.flags = ps-&gt;flags;
	for (i = 0; i &lt; 3; i++)
<blue>		kvm_pit_load_count(pit, i, pit->pit_state.channels[i].count,</blue>
				   start &amp;&amp; i == 0);
<blue>	mutex_unlock(&pit->pit_state.lock);</blue>
	return 0;
}

static int kvm_vm_ioctl_reinject(struct kvm *kvm,
				 struct kvm_reinject_control *control)
{
	struct kvm_pit *pit = kvm-&gt;arch.vpit;

	/* pit-&gt;pit_state.lock was overloaded to prevent userspace from getting
	 * an inconsistent state after running multiple KVM_REINJECT_CONTROL
	 * ioctls in parallel.  Use a separate lock if that ioctl isn&#x27;t rare.
	 */
<yellow>	mutex_lock(&pit->pit_state.lock);</yellow>
	kvm_pit_set_reinject(pit, control-&gt;pit_reinject);
	mutex_unlock(&amp;pit-&gt;pit_state.lock);

	return 0;
}

void kvm_arch_sync_dirty_log(struct kvm *kvm, struct kvm_memory_slot *memslot)
<yellow>{</yellow>

	/*
	 * Flush all CPUs&#x27; dirty log buffers to the  dirty_bitmap.  Called
	 * before reporting dirty_bitmap to userspace.  KVM flushes the buffers
	 * on all VM-Exits, thus we only need to kick running vCPUs to force a
	 * VM-Exit.
	 */
	struct kvm_vcpu *vcpu;
	unsigned long i;

<yellow>	kvm_for_each_vcpu(i, vcpu, kvm)</yellow>
<yellow>		kvm_vcpu_kick(vcpu);</yellow>
}

int kvm_vm_ioctl_irq_line(struct kvm *kvm, struct kvm_irq_level *irq_event,
			bool line_status)
{
<blue>	if (!irqchip_in_kernel(kvm))</blue>
		return -ENXIO;

	irq_event-&gt;status = kvm_set_irq(kvm, KVM_USERSPACE_IRQ_SOURCE_ID,
<blue>					irq_event->irq, irq_event->level,</blue>
					line_status);
	return 0;
<blue>}</blue>

int kvm_vm_ioctl_enable_cap(struct kvm *kvm,
			    struct kvm_enable_cap *cap)
<blue>{</blue>
	int r;

<blue>	if (cap->flags)</blue>
		return -EINVAL;

<blue>	switch (cap->cap) {</blue>
	case KVM_CAP_DISABLE_QUIRKS2:
		r = -EINVAL;
<yellow>		if (cap->args[0] & ~KVM_X86_VALID_QUIRKS)</yellow>
			break;
		fallthrough;
	case KVM_CAP_DISABLE_QUIRKS:
<yellow>		kvm->arch.disabled_quirks = cap->args[0];</yellow>
		r = 0;
		break;
	case KVM_CAP_SPLIT_IRQCHIP: {
<yellow>		mutex_lock(&kvm->lock);</yellow>
		r = -EINVAL;
		if (cap-&gt;args[0] &gt; MAX_NR_RESERVED_IOAPIC_PINS)
			goto split_irqchip_unlock;
		r = -EEXIST;
<yellow>		if (irqchip_in_kernel(kvm))</yellow>
			goto split_irqchip_unlock;
<yellow>		if (kvm->created_vcpus)</yellow>
			goto split_irqchip_unlock;
<yellow>		r = kvm_setup_empty_irq_routing(kvm);</yellow>
		if (r)
			goto split_irqchip_unlock;
		/* Pairs with irqchip_in_kernel. */
		smp_wmb();
<yellow>		kvm->arch.irqchip_mode = KVM_IRQCHIP_SPLIT;</yellow>
		kvm-&gt;arch.nr_reserved_ioapic_pins = cap-&gt;args[0];
		kvm_clear_apicv_inhibit(kvm, APICV_INHIBIT_REASON_ABSENT);
		r = 0;
split_irqchip_unlock:
		mutex_unlock(&amp;kvm-&gt;lock);
		break;
	}
	case KVM_CAP_X2APIC_API:
		r = -EINVAL;
<yellow>		if (cap->args[0] & ~KVM_X2APIC_API_VALID_FLAGS)</yellow>
			break;

<yellow>		if (cap->args[0] & KVM_X2APIC_API_USE_32BIT_IDS)</yellow>
<yellow>			kvm->arch.x2apic_format = true;</yellow>
<yellow>		if (cap->args[0] & KVM_X2APIC_API_DISABLE_BROADCAST_QUIRK)</yellow>
<yellow>			kvm->arch.x2apic_broadcast_quirk_disabled = true;</yellow>

		r = 0;
		break;
	case KVM_CAP_X86_DISABLE_EXITS:
		r = -EINVAL;
<yellow>		if (cap->args[0] & ~KVM_X86_DISABLE_VALID_EXITS)</yellow>
			break;

<yellow>		if ((cap->args[0] & KVM_X86_DISABLE_EXITS_MWAIT) &&</yellow>
<yellow>			kvm_can_mwait_in_guest())</yellow>
<yellow>			kvm->arch.mwait_in_guest = true;</yellow>
<yellow>		if (cap->args[0] & KVM_X86_DISABLE_EXITS_HLT)</yellow>
<yellow>			kvm->arch.hlt_in_guest = true;</yellow>
<yellow>		if (cap->args[0] & KVM_X86_DISABLE_EXITS_PAUSE)</yellow>
<yellow>			kvm->arch.pause_in_guest = true;</yellow>
<yellow>		if (cap->args[0] & KVM_X86_DISABLE_EXITS_CSTATE)</yellow>
<yellow>			kvm->arch.cstate_in_guest = true;</yellow>
		r = 0;
		break;
	case KVM_CAP_MSR_PLATFORM_INFO:
<yellow>		kvm->arch.guest_can_read_msr_platform_info = cap->args[0];</yellow>
		r = 0;
		break;
	case KVM_CAP_EXCEPTION_PAYLOAD:
<blue>		kvm->arch.exception_payload_enabled = cap->args[0];</blue>
		r = 0;
		break;
	case KVM_CAP_X86_TRIPLE_FAULT_EVENT:
<yellow>		kvm->arch.triple_fault_event = cap->args[0];</yellow>
		r = 0;
		break;
	case KVM_CAP_X86_USER_SPACE_MSR:
		r = -EINVAL;
<yellow>		if (cap->args[0] & ~(KVM_MSR_EXIT_REASON_INVAL |</yellow>
				     KVM_MSR_EXIT_REASON_UNKNOWN |
				     KVM_MSR_EXIT_REASON_FILTER))
			break;
<yellow>		kvm->arch.user_space_msr_mask = cap->args[0];</yellow>
		r = 0;
		break;
	case KVM_CAP_X86_BUS_LOCK_EXIT:
		r = -EINVAL;
<yellow>		if (cap->args[0] & ~KVM_BUS_LOCK_DETECTION_VALID_MODE)</yellow>
			break;

<yellow>		if ((cap->args[0] & KVM_BUS_LOCK_DETECTION_OFF) &&</yellow>
		    (cap-&gt;args[0] &amp; KVM_BUS_LOCK_DETECTION_EXIT))
			break;

<yellow>		if (kvm_caps.has_bus_lock_exit &&</yellow>
<yellow>		    cap->args[0] & KVM_BUS_LOCK_DETECTION_EXIT)</yellow>
<yellow>			kvm->arch.bus_lock_detection_enabled = true;</yellow>
		r = 0;
		break;
#ifdef CONFIG_X86_SGX_KVM
	case KVM_CAP_SGX_ATTRIBUTE: {
		unsigned long allowed_attributes = 0;

<yellow>		r = sgx_set_attribute(&allowed_attributes, cap->args[0]);</yellow>
		if (r)
			break;

		/* KVM only supports the PROVISIONKEY privileged attribute. */
<yellow>		if ((allowed_attributes & SGX_ATTR_PROVISIONKEY) &&</yellow>
		    !(allowed_attributes &amp; ~SGX_ATTR_PROVISIONKEY))
<yellow>			kvm->arch.sgx_provisioning_allowed = true;</yellow>
		else
<yellow>			r = -EINVAL;</yellow>
		break;
	}
#endif
	case KVM_CAP_VM_COPY_ENC_CONTEXT_FROM:
		r = -EINVAL;
<yellow>		if (!kvm_x86_ops.vm_copy_enc_context_from)</yellow>
			break;

<yellow>		r = static_call(kvm_x86_vm_copy_enc_context_from)(kvm, cap->args[0]);</yellow>
		break;
	case KVM_CAP_VM_MOVE_ENC_CONTEXT_FROM:
		r = -EINVAL;
<yellow>		if (!kvm_x86_ops.vm_move_enc_context_from)</yellow>
			break;

<yellow>		r = static_call(kvm_x86_vm_move_enc_context_from)(kvm, cap->args[0]);</yellow>
		break;
	case KVM_CAP_EXIT_HYPERCALL:
<yellow>		if (cap->args[0] & ~KVM_EXIT_HYPERCALL_VALID_MASK) {</yellow>
			r = -EINVAL;
			break;
		}
<yellow>		kvm->arch.hypercall_exit_enabled = cap->args[0];</yellow>
		r = 0;
		break;
	case KVM_CAP_EXIT_ON_EMULATION_FAILURE:
		r = -EINVAL;
<yellow>		if (cap->args[0] & ~1)</yellow>
			break;
<yellow>		kvm->arch.exit_on_emulation_error = cap->args[0];</yellow>
		r = 0;
		break;
	case KVM_CAP_PMU_CAPABILITY:
		r = -EINVAL;
<yellow>		if (!enable_pmu || (cap->args[0] & ~KVM_CAP_PMU_VALID_MASK))</yellow>
			break;

<yellow>		mutex_lock(&kvm->lock);</yellow>
		if (!kvm-&gt;created_vcpus) {
<yellow>			kvm->arch.enable_pmu = !(cap->args[0] & KVM_PMU_CAP_DISABLE);</yellow>
			r = 0;
		}
		mutex_unlock(&amp;kvm-&gt;lock);
		break;
	case KVM_CAP_MAX_VCPU_ID:
		r = -EINVAL;
<yellow>		if (cap->args[0] > KVM_MAX_VCPU_IDS)</yellow>
			break;

<yellow>		mutex_lock(&kvm->lock);</yellow>
		if (kvm-&gt;arch.max_vcpu_ids == cap-&gt;args[0]) {
			r = 0;
<yellow>		} else if (!kvm->arch.max_vcpu_ids) {</yellow>
			kvm-&gt;arch.max_vcpu_ids = cap-&gt;args[0];
<yellow>			r = 0;</yellow>
		}
		mutex_unlock(&amp;kvm-&gt;lock);
		break;
	case KVM_CAP_X86_NOTIFY_VMEXIT:
		r = -EINVAL;
<yellow>		if ((u32)cap->args[0] & ~KVM_X86_NOTIFY_VMEXIT_VALID_BITS)</yellow>
			break;
<yellow>		if (!kvm_caps.has_notify_vmexit)</yellow>
			break;
<yellow>		if (!((u32)cap->args[0] & KVM_X86_NOTIFY_VMEXIT_ENABLED))</yellow>
			break;
<yellow>		mutex_lock(&kvm->lock);</yellow>
		if (!kvm-&gt;created_vcpus) {
<yellow>			kvm->arch.notify_window = cap->args[0] >> 32;</yellow>
			kvm-&gt;arch.notify_vmexit_flags = (u32)cap-&gt;args[0];
			r = 0;
		}
		mutex_unlock(&amp;kvm-&gt;lock);
		break;
	case KVM_CAP_VM_DISABLE_NX_HUGE_PAGES:
		r = -EINVAL;

		/*
		 * Since the risk of disabling NX hugepages is a guest crashing
		 * the system, ensure the userspace process has permission to
		 * reboot the system.
		 *
		 * Note that unlike the reboot() syscall, the process must have
		 * this capability in the root namespace because exposing
		 * /dev/kvm into a container does not limit the scope of the
		 * iTLB multihit bug to that container. In other words,
		 * this must use capable(), not ns_capable().
		 */
<yellow>		if (!capable(CAP_SYS_BOOT)) {</yellow>
			r = -EPERM;
			break;
		}

<yellow>		if (cap->args[0])</yellow>
			break;

<yellow>		mutex_lock(&kvm->lock);</yellow>
		if (!kvm-&gt;created_vcpus) {
<yellow>			kvm->arch.disable_nx_huge_pages = true;</yellow>
			r = 0;
		}
<yellow>		mutex_unlock(&kvm->lock);</yellow>
		break;
	default:
		r = -EINVAL;
		break;
	}
	return r;
}

static struct kvm_x86_msr_filter *kvm_alloc_msr_filter(bool default_allow)
{
	struct kvm_x86_msr_filter *msr_filter;

<yellow>	msr_filter = kzalloc(sizeof(*msr_filter), GFP_KERNEL_ACCOUNT);</yellow>
	if (!msr_filter)
		return NULL;

<yellow>	msr_filter->default_allow = default_allow;</yellow>
	return msr_filter;
}

<yellow>static void kvm_free_msr_filter(struct kvm_x86_msr_filter *msr_filter)</yellow>
{
	u32 i;

	if (!msr_filter)
		return;

<yellow>	for (i = 0; i < msr_filter->count; i++)</yellow>
<yellow>		kfree(msr_filter->ranges[i].bitmap);</yellow>

<yellow>	kfree(msr_filter);</yellow>
}

static int kvm_add_msr_filter(struct kvm_x86_msr_filter *msr_filter,
			      struct kvm_msr_filter_range *user_range)
{
	unsigned long *bitmap = NULL;
	size_t bitmap_size;

<yellow>	if (!user_range->nmsrs)</yellow>
		return 0;

<yellow>	if (user_range->flags & ~(KVM_MSR_FILTER_READ | KVM_MSR_FILTER_WRITE))</yellow>
		return -EINVAL;

<yellow>	if (!user_range->flags)</yellow>
		return -EINVAL;

<yellow>	bitmap_size = BITS_TO_LONGS(user_range->nmsrs) * sizeof(long);</yellow>
	if (!bitmap_size || bitmap_size &gt; KVM_MSR_FILTER_MAX_BITMAP_SIZE)
		return -EINVAL;

<yellow>	bitmap = memdup_user((__user u8*)user_range->bitmap, bitmap_size);</yellow>
	if (IS_ERR(bitmap))
		return PTR_ERR(bitmap);

<yellow>	msr_filter->ranges[msr_filter->count] = (struct msr_bitmap_range) {</yellow>
		.flags = user_range-&gt;flags,
		.base = user_range-&gt;base,
		.nmsrs = user_range-&gt;nmsrs,
		.bitmap = bitmap,
	};

	msr_filter-&gt;count++;
	return 0;
}

static int kvm_vm_ioctl_set_msr_filter(struct kvm *kvm,
				       struct kvm_msr_filter *filter)
{
	struct kvm_x86_msr_filter *new_filter, *old_filter;
	bool default_allow;
	bool empty = true;
	int r = 0;
	u32 i;

<yellow>	if (filter->flags & ~KVM_MSR_FILTER_DEFAULT_DENY)</yellow>
		return -EINVAL;

	for (i = 0; i &lt; ARRAY_SIZE(filter-&gt;ranges); i++)
<yellow>		empty &= !filter->ranges[i].nmsrs;</yellow>

<yellow>	default_allow = !(filter->flags & KVM_MSR_FILTER_DEFAULT_DENY);</yellow>
<yellow>	if (empty && !default_allow)</yellow>
		return -EINVAL;

<yellow>	new_filter = kvm_alloc_msr_filter(default_allow);</yellow>
	if (!new_filter)
		return -ENOMEM;

<yellow>	for (i = 0; i < ARRAY_SIZE(filter->ranges); i++) {</yellow>
<yellow>		r = kvm_add_msr_filter(new_filter, &filter->ranges[i]);</yellow>
<yellow>		if (r) {</yellow>
<yellow>			kvm_free_msr_filter(new_filter);</yellow>
			return r;
		}
	}

<yellow>	mutex_lock(&kvm->lock);</yellow>

	/* The per-VM filter is protected by kvm-&gt;lock... */
	old_filter = srcu_dereference_check(kvm-&gt;arch.msr_filter, &amp;kvm-&gt;srcu, 1);

	rcu_assign_pointer(kvm-&gt;arch.msr_filter, new_filter);
	synchronize_srcu(&amp;kvm-&gt;srcu);

<yellow>	kvm_free_msr_filter(old_filter);</yellow>

<yellow>	kvm_make_all_cpus_request(kvm, KVM_REQ_MSR_FILTER_CHANGED);</yellow>
	mutex_unlock(&amp;kvm-&gt;lock);

	return 0;
<yellow>}</yellow>

#ifdef CONFIG_KVM_COMPAT
/* for KVM_X86_SET_MSR_FILTER */
struct kvm_msr_filter_range_compat {
	__u32 flags;
	__u32 nmsrs;
	__u32 base;
	__u32 bitmap;
};

struct kvm_msr_filter_compat {
	__u32 flags;
	struct kvm_msr_filter_range_compat ranges[KVM_MSR_FILTER_MAX_RANGES];
};

#define KVM_X86_SET_MSR_FILTER_COMPAT _IOW(KVMIO, 0xc6, struct kvm_msr_filter_compat)

long kvm_arch_vm_compat_ioctl(struct file *filp, unsigned int ioctl,
			      unsigned long arg)
<yellow>{</yellow>
	void __user *argp = (void __user *)arg;
<yellow>	struct kvm *kvm = filp->private_data;</yellow>
	long r = -ENOTTY;

	switch (ioctl) {
	case KVM_X86_SET_MSR_FILTER_COMPAT: {
		struct kvm_msr_filter __user *user_msr_filter = argp;
		struct kvm_msr_filter_compat filter_compat;
		struct kvm_msr_filter filter;
		int i;

<yellow>		if (copy_from_user(&filter_compat, user_msr_filter,</yellow>
				   sizeof(filter_compat)))
<yellow>			return -EFAULT;</yellow>

<yellow>		filter.flags = filter_compat.flags;</yellow>
		for (i = 0; i &lt; ARRAY_SIZE(filter.ranges); i++) {
			struct kvm_msr_filter_range_compat *cr;

<yellow>			cr = &filter_compat.ranges[i];</yellow>
			filter.ranges[i] = (struct kvm_msr_filter_range) {
				.flags = cr-&gt;flags,
				.nmsrs = cr-&gt;nmsrs,
				.base = cr-&gt;base,
				.bitmap = (__u8 *)(ulong)cr-&gt;bitmap,
			};
		}

<yellow>		r = kvm_vm_ioctl_set_msr_filter(kvm, &filter);</yellow>
		break;
	}
	}

	return r;
}
#endif

#ifdef CONFIG_HAVE_KVM_PM_NOTIFIER
static int kvm_arch_suspend_notifier(struct kvm *kvm)
{
	struct kvm_vcpu *vcpu;
	unsigned long i;
	int ret = 0;

<yellow>	mutex_lock(&kvm->lock);</yellow>
<yellow>	kvm_for_each_vcpu(i, vcpu, kvm) {</yellow>
<yellow>		if (!vcpu->arch.pv_time.active)</yellow>
			continue;

<yellow>		ret = kvm_set_guest_paused(vcpu);</yellow>
		if (ret) {
			kvm_err(&quot;Failed to pause guest VCPU%d: %d\n&quot;,
				vcpu-&gt;vcpu_id, ret);
			break;
		}
	}
<yellow>	mutex_unlock(&kvm->lock);</yellow>

	return ret ? NOTIFY_BAD : NOTIFY_DONE;
}

int kvm_arch_pm_notifier(struct kvm *kvm, unsigned long state)
<yellow>{</yellow>
<yellow>	switch (state) {</yellow>
	case PM_HIBERNATION_PREPARE:
	case PM_SUSPEND_PREPARE:
<yellow>		return kvm_arch_suspend_notifier(kvm);</yellow>
	}

	return NOTIFY_DONE;
}
#endif /* CONFIG_HAVE_KVM_PM_NOTIFIER */

static int kvm_vm_ioctl_get_clock(struct kvm *kvm, void __user *argp)
{
<blue>	struct kvm_clock_data data = { 0 };</blue>

<blue>	get_kvmclock(kvm, &data);</blue>
<blue>	if (copy_to_user(argp, &data, sizeof(data)))</blue>
		return -EFAULT;

	return 0;
}

static int kvm_vm_ioctl_set_clock(struct kvm *kvm, void __user *argp)
{
	struct kvm_arch *ka = &amp;kvm-&gt;arch;
	struct kvm_clock_data data;
	u64 now_raw_ns;

<blue>	if (copy_from_user(&data, argp, sizeof(data)))</blue>
		return -EFAULT;

	/*
	 * Only KVM_CLOCK_REALTIME is used, but allow passing the
	 * result of KVM_GET_CLOCK back to KVM_SET_CLOCK.
	 */
<blue>	if (data.flags & ~KVM_CLOCK_VALID_FLAGS)</blue>
		return -EINVAL;

<blue>	kvm_hv_request_tsc_page_update(kvm);</blue>
	kvm_start_pvclock_update(kvm);
	pvclock_update_vm_gtod_copy(kvm);

	/*
	 * This pairs with kvm_guest_time_update(): when masterclock is
	 * in use, we use master_kernel_ns + kvmclock_offset to set
	 * unsigned &#x27;system_time&#x27; so if we use get_kvmclock_ns() (which
	 * is slightly ahead) here we risk going negative on unsigned
	 * &#x27;system_time&#x27; when &#x27;data.clock&#x27; is very small.
	 */
	if (data.flags &amp; KVM_CLOCK_REALTIME) {
<yellow>		u64 now_real_ns = ktime_get_real_ns();</yellow>

		/*
		 * Avoid stepping the kvmclock backwards.
		 */
		if (now_real_ns &gt; data.realtime)
<yellow>			data.clock += now_real_ns - data.realtime;</yellow>
	}

<blue>	if (ka->use_master_clock)</blue>
<blue>		now_raw_ns = ka->master_kernel_ns;</blue>
	else
<yellow>		now_raw_ns = get_kvmclock_base_ns();</yellow>
<blue>	ka->kvmclock_offset = data.clock - now_raw_ns;</blue>
	kvm_end_pvclock_update(kvm);
	return 0;
}

long kvm_arch_vm_ioctl(struct file *filp,
		       unsigned int ioctl, unsigned long arg)
<blue>{</blue>
<blue>	struct kvm *kvm = filp->private_data;</blue>
	void __user *argp = (void __user *)arg;
	int r = -ENOTTY;
	/*
	 * This union makes it completely explicit to gcc-3.x
	 * that these two variables&#x27; stack usage should be
	 * combined, not added together.
	 */
	union {
		struct kvm_pit_state ps;
		struct kvm_pit_state2 ps2;
		struct kvm_pit_config pit_config;
	} u;

	switch (ioctl) {
	case KVM_SET_TSS_ADDR:
<blue>		r = kvm_vm_ioctl_set_tss_addr(kvm, arg);</blue>
		break;
	case KVM_SET_IDENTITY_MAP_ADDR: {
		u64 ident_addr;

<blue>		mutex_lock(&kvm->lock);</blue>
		r = -EINVAL;
		if (kvm-&gt;created_vcpus)
			goto set_identity_unlock;
		r = -EFAULT;
<blue>		if (copy_from_user(&ident_addr, argp, sizeof(ident_addr)))</blue>
			goto set_identity_unlock;
<blue>		r = kvm_vm_ioctl_set_identity_map_addr(kvm, ident_addr);</blue>
set_identity_unlock:
<blue>		mutex_unlock(&kvm->lock);</blue>
		break;
	}
	case KVM_SET_NR_MMU_PAGES:
<yellow>		r = kvm_vm_ioctl_set_nr_mmu_pages(kvm, arg);</yellow>
		break;
	case KVM_GET_NR_MMU_PAGES:
<yellow>		r = kvm_vm_ioctl_get_nr_mmu_pages(kvm);</yellow>
		break;
	case KVM_CREATE_IRQCHIP: {
<blue>		mutex_lock(&kvm->lock);</blue>

		r = -EEXIST;
		if (irqchip_in_kernel(kvm))
			goto create_irqchip_unlock;

		r = -EINVAL;
<blue>		if (kvm->created_vcpus)</blue>
			goto create_irqchip_unlock;

<blue>		r = kvm_pic_init(kvm);</blue>
		if (r)
			goto create_irqchip_unlock;

<blue>		r = kvm_ioapic_init(kvm);</blue>
		if (r) {
<yellow>			kvm_pic_destroy(kvm);</yellow>
			goto create_irqchip_unlock;
		}

<blue>		r = kvm_setup_default_irq_routing(kvm);</blue>
		if (r) {
<yellow>			kvm_ioapic_destroy(kvm);</yellow>
			kvm_pic_destroy(kvm);
			goto create_irqchip_unlock;
		}
		/* Write kvm-&gt;irq_routing before enabling irqchip_in_kernel. */
		smp_wmb();
<blue>		kvm->arch.irqchip_mode = KVM_IRQCHIP_KERNEL;</blue>
		kvm_clear_apicv_inhibit(kvm, APICV_INHIBIT_REASON_ABSENT);
	create_irqchip_unlock:
		mutex_unlock(&amp;kvm-&gt;lock);
		break;
	}
	case KVM_CREATE_PIT:
<yellow>		u.pit_config.flags = KVM_PIT_SPEAKER_DUMMY;</yellow>
		goto create_pit;
	case KVM_CREATE_PIT2:
		r = -EFAULT;
<blue>		if (copy_from_user(&u.pit_config, argp,</blue>
				   sizeof(struct kvm_pit_config)))
			goto out;
	create_pit:
<blue>		mutex_lock(&kvm->lock);</blue>
		r = -EEXIST;
		if (kvm-&gt;arch.vpit)
			goto create_pit_unlock;
		r = -ENOMEM;
<blue>		kvm->arch.vpit = kvm_create_pit(kvm, u.pit_config.flags);</blue>
		if (kvm-&gt;arch.vpit)
			r = 0;
	create_pit_unlock:
<blue>		mutex_unlock(&kvm->lock);</blue>
		break;
	case KVM_GET_IRQCHIP: {
		/* 0: PIC master, 1: PIC slave, 2: IOAPIC */
		struct kvm_irqchip *chip;

<yellow>		chip = memdup_user(argp, sizeof(*chip));</yellow>
		if (IS_ERR(chip)) {
			r = PTR_ERR(chip);
			goto out;
		}

		r = -ENXIO;
<yellow>		if (!irqchip_kernel(kvm))</yellow>
			goto get_irqchip_out;
<yellow>		r = kvm_vm_ioctl_get_irqchip(kvm, chip);</yellow>
		if (r)
			goto get_irqchip_out;
		r = -EFAULT;
<yellow>		if (copy_to_user(argp, chip, sizeof(*chip)))</yellow>
			goto get_irqchip_out;
		r = 0;
	get_irqchip_out:
<yellow>		kfree(chip);</yellow>
		break;
	}
	case KVM_SET_IRQCHIP: {
		/* 0: PIC master, 1: PIC slave, 2: IOAPIC */
		struct kvm_irqchip *chip;

<blue>		chip = memdup_user(argp, sizeof(*chip));</blue>
		if (IS_ERR(chip)) {
			r = PTR_ERR(chip);
			goto out;
		}

		r = -ENXIO;
<blue>		if (!irqchip_kernel(kvm))</blue>
			goto set_irqchip_out;
<blue>		r = kvm_vm_ioctl_set_irqchip(kvm, chip);</blue>
	set_irqchip_out:
<blue>		kfree(chip);</blue>
		break;
	}
	case KVM_GET_PIT: {
		r = -EFAULT;
<yellow>		if (copy_from_user(&u.ps, argp, sizeof(struct kvm_pit_state)))</yellow>
			goto out;
		r = -ENXIO;
<yellow>		if (!kvm->arch.vpit)</yellow>
			goto out;
<yellow>		r = kvm_vm_ioctl_get_pit(kvm, &u.ps);</yellow>
		if (r)
			goto out;
		r = -EFAULT;
		if (copy_to_user(argp, &amp;u.ps, sizeof(struct kvm_pit_state)))
			goto out;
		r = 0;
		break;
	}
	case KVM_SET_PIT: {
		r = -EFAULT;
<yellow>		if (copy_from_user(&u.ps, argp, sizeof(u.ps)))</yellow>
			goto out;
<yellow>		mutex_lock(&kvm->lock);</yellow>
		r = -ENXIO;
		if (!kvm-&gt;arch.vpit)
			goto set_pit_out;
<yellow>		r = kvm_vm_ioctl_set_pit(kvm, &u.ps);</yellow>
set_pit_out:
		mutex_unlock(&amp;kvm-&gt;lock);
		break;
	}
	case KVM_GET_PIT2: {
		r = -ENXIO;
<blue>		if (!kvm->arch.vpit)</blue>
			goto out;
<blue>		r = kvm_vm_ioctl_get_pit2(kvm, &u.ps2);</blue>
		if (r)
			goto out;
		r = -EFAULT;
		if (copy_to_user(argp, &amp;u.ps2, sizeof(u.ps2)))
			goto out;
		r = 0;
		break;
	}
	case KVM_SET_PIT2: {
		r = -EFAULT;
<blue>		if (copy_from_user(&u.ps2, argp, sizeof(u.ps2)))</blue>
			goto out;
<blue>		mutex_lock(&kvm->lock);</blue>
		r = -ENXIO;
		if (!kvm-&gt;arch.vpit)
			goto set_pit2_out;
<blue>		r = kvm_vm_ioctl_set_pit2(kvm, &u.ps2);</blue>
set_pit2_out:
<blue>		mutex_unlock(&kvm->lock);</blue>
		break;
	}
	case KVM_REINJECT_CONTROL: {
		struct kvm_reinject_control control;
		r =  -EFAULT;
<yellow>		if (copy_from_user(&control, argp, sizeof(control)))</yellow>
			goto out;
		r = -ENXIO;
<yellow>		if (!kvm->arch.vpit)</yellow>
			goto out;
<yellow>		r = kvm_vm_ioctl_reinject(kvm, &control);</yellow>
		break;
	}
	case KVM_SET_BOOT_CPU_ID:
		r = 0;
<yellow>		mutex_lock(&kvm->lock);</yellow>
		if (kvm-&gt;created_vcpus)
			r = -EBUSY;
		else
<yellow>			kvm->arch.bsp_vcpu_id = arg;</yellow>
<blue>		mutex_unlock(&kvm->lock);</blue>
		break;
#ifdef CONFIG_KVM_XEN
	case KVM_XEN_HVM_CONFIG: {
		struct kvm_xen_hvm_config xhc;
		r = -EFAULT;
<yellow>		if (copy_from_user(&xhc, argp, sizeof(xhc)))</yellow>
			goto out;
<yellow>		r = kvm_xen_hvm_config(kvm, &xhc);</yellow>
		break;
	}
	case KVM_XEN_HVM_GET_ATTR: {
		struct kvm_xen_hvm_attr xha;

		r = -EFAULT;
<yellow>		if (copy_from_user(&xha, argp, sizeof(xha)))</yellow>
			goto out;
<yellow>		r = kvm_xen_hvm_get_attr(kvm, &xha);</yellow>
<yellow>		if (!r && copy_to_user(argp, &xha, sizeof(xha)))</yellow>
			r = -EFAULT;
		break;
	}
	case KVM_XEN_HVM_SET_ATTR: {
		struct kvm_xen_hvm_attr xha;

		r = -EFAULT;
<yellow>		if (copy_from_user(&xha, argp, sizeof(xha)))</yellow>
			goto out;
<yellow>		r = kvm_xen_hvm_set_attr(kvm, &xha);</yellow>
		break;
	}
	case KVM_XEN_HVM_EVTCHN_SEND: {
		struct kvm_irq_routing_xen_evtchn uxe;

		r = -EFAULT;
<yellow>		if (copy_from_user(&uxe, argp, sizeof(uxe)))</yellow>
			goto out;
<yellow>		r = kvm_xen_hvm_evtchn_send(kvm, &uxe);</yellow>
		break;
	}
#endif
	case KVM_SET_CLOCK:
<blue>		r = kvm_vm_ioctl_set_clock(kvm, argp);</blue>
		break;
	case KVM_GET_CLOCK:
<blue>		r = kvm_vm_ioctl_get_clock(kvm, argp);</blue>
<blue>		break;</blue>
	case KVM_SET_TSC_KHZ: {
		u32 user_tsc_khz;

		r = -EINVAL;
		user_tsc_khz = (u32)arg;

<yellow>		if (kvm_caps.has_tsc_control &&</yellow>
<yellow>		    user_tsc_khz >= kvm_caps.max_guest_tsc_khz)</yellow>
			goto out;

<yellow>		if (user_tsc_khz == 0)</yellow>
<yellow>			user_tsc_khz = tsc_khz;</yellow>

<yellow>		WRITE_ONCE(kvm->arch.default_tsc_khz, user_tsc_khz);</yellow>
		r = 0;

		goto out;
	}
	case KVM_GET_TSC_KHZ: {
<yellow>		r = READ_ONCE(kvm->arch.default_tsc_khz);</yellow>
		goto out;
	}
	case KVM_MEMORY_ENCRYPT_OP: {
		r = -ENOTTY;
<yellow>		if (!kvm_x86_ops.mem_enc_ioctl)</yellow>
			goto out;

<yellow>		r = static_call(kvm_x86_mem_enc_ioctl)(kvm, argp);</yellow>
		break;
	}
	case KVM_MEMORY_ENCRYPT_REG_REGION: {
		struct kvm_enc_region region;

		r = -EFAULT;
<yellow>		if (copy_from_user(&region, argp, sizeof(region)))</yellow>
			goto out;

		r = -ENOTTY;
<yellow>		if (!kvm_x86_ops.mem_enc_register_region)</yellow>
			goto out;

<yellow>		r = static_call(kvm_x86_mem_enc_register_region)(kvm, &region);</yellow>
		break;
	}
	case KVM_MEMORY_ENCRYPT_UNREG_REGION: {
		struct kvm_enc_region region;

		r = -EFAULT;
<yellow>		if (copy_from_user(&region, argp, sizeof(region)))</yellow>
<blue>			goto out;</blue>

		r = -ENOTTY;
<yellow>		if (!kvm_x86_ops.mem_enc_unregister_region)</yellow>
			goto out;

<yellow>		r = static_call(kvm_x86_mem_enc_unregister_region)(kvm, &region);</yellow>
		break;
	}
	case KVM_HYPERV_EVENTFD: {
		struct kvm_hyperv_eventfd hvevfd;

		r = -EFAULT;
<yellow>		if (copy_from_user(&hvevfd, argp, sizeof(hvevfd)))</yellow>
			goto out;
<yellow>		r = kvm_vm_ioctl_hv_eventfd(kvm, &hvevfd);</yellow>
		break;
	}
	case KVM_SET_PMU_EVENT_FILTER:
<yellow>		r = kvm_vm_ioctl_set_pmu_event_filter(kvm, argp);</yellow>
		break;
	case KVM_X86_SET_MSR_FILTER: {
		struct kvm_msr_filter __user *user_msr_filter = argp;
		struct kvm_msr_filter filter;

<yellow>		if (copy_from_user(&filter, user_msr_filter, sizeof(filter)))</yellow>
<yellow>			return -EFAULT;</yellow>

<yellow>		r = kvm_vm_ioctl_set_msr_filter(kvm, &filter);</yellow>
		break;
	}
	default:
		r = -ENOTTY;
	}
out:
<yellow>	return r;</yellow>
}

static void kvm_init_msr_list(void)
{
	u32 dummy[2];
	unsigned i;

	BUILD_BUG_ON_MSG(KVM_PMC_MAX_FIXED != 3,
			 &quot;Please update the fixed PMCs in msrs_to_saved_all[]&quot;);

	num_msrs_to_save = 0;
	num_emulated_msrs = 0;
	num_msr_based_features = 0;

<yellow>	for (i = 0; i < ARRAY_SIZE(msrs_to_save_all); i++) {</yellow>
<yellow>		if (rdmsr_safe(msrs_to_save_all[i], &dummy[0], &dummy[1]) < 0)</yellow>
			continue;

		/*
		 * Even MSRs that are valid in the host may not be exposed
		 * to the guests in some cases.
		 */
<yellow>		switch (msrs_to_save_all[i]) {</yellow>
		case MSR_IA32_BNDCFGS:
<yellow>			if (!kvm_mpx_supported())</yellow>
				continue;
			break;
		case MSR_TSC_AUX:
<yellow>			if (!kvm_cpu_cap_has(X86_FEATURE_RDTSCP) &&</yellow>
			    !kvm_cpu_cap_has(X86_FEATURE_RDPID))
				continue;
			break;
		case MSR_IA32_UMWAIT_CONTROL:
<yellow>			if (!kvm_cpu_cap_has(X86_FEATURE_WAITPKG))</yellow>
				continue;
			break;
		case MSR_IA32_RTIT_CTL:
		case MSR_IA32_RTIT_STATUS:
<yellow>			if (!kvm_cpu_cap_has(X86_FEATURE_INTEL_PT))</yellow>
				continue;
			break;
		case MSR_IA32_RTIT_CR3_MATCH:
<yellow>			if (!kvm_cpu_cap_has(X86_FEATURE_INTEL_PT) ||</yellow>
<yellow>			    !intel_pt_validate_hw_cap(PT_CAP_cr3_filtering))</yellow>
				continue;
			break;
		case MSR_IA32_RTIT_OUTPUT_BASE:
		case MSR_IA32_RTIT_OUTPUT_MASK:
<yellow>			if (!kvm_cpu_cap_has(X86_FEATURE_INTEL_PT) ||</yellow>
<yellow>				(!intel_pt_validate_hw_cap(PT_CAP_topa_output) &&</yellow>
<yellow>				 !intel_pt_validate_hw_cap(PT_CAP_single_range_output)))</yellow>
				continue;
			break;
		case MSR_IA32_RTIT_ADDR0_A ... MSR_IA32_RTIT_ADDR3_B:
<yellow>			if (!kvm_cpu_cap_has(X86_FEATURE_INTEL_PT) ||</yellow>
<yellow>				msrs_to_save_all[i] - MSR_IA32_RTIT_ADDR0_A >=</yellow>
				intel_pt_validate_hw_cap(PT_CAP_num_address_ranges) * 2)
				continue;
			break;
		case MSR_ARCH_PERFMON_PERFCTR0 ... MSR_ARCH_PERFMON_PERFCTR_MAX:
<yellow>			if (msrs_to_save_all[i] - MSR_ARCH_PERFMON_PERFCTR0 >=</yellow>
			    min(KVM_INTEL_PMC_MAX_GENERIC, kvm_pmu_cap.num_counters_gp))
				continue;
			break;
		case MSR_ARCH_PERFMON_EVENTSEL0 ... MSR_ARCH_PERFMON_EVENTSEL_MAX:
<yellow>			if (msrs_to_save_all[i] - MSR_ARCH_PERFMON_EVENTSEL0 >=</yellow>
			    min(KVM_INTEL_PMC_MAX_GENERIC, kvm_pmu_cap.num_counters_gp))
				continue;
			break;
		case MSR_IA32_XFD:
		case MSR_IA32_XFD_ERR:
<yellow>			if (!kvm_cpu_cap_has(X86_FEATURE_XFD))</yellow>
				continue;
			break;
		default:
			break;
		}

<yellow>		msrs_to_save[num_msrs_to_save++] = msrs_to_save_all[i];</yellow>
	}

<yellow>	for (i = 0; i < ARRAY_SIZE(emulated_msrs_all); i++) {</yellow>
<yellow>		if (!static_call(kvm_x86_has_emulated_msr)(NULL, emulated_msrs_all[i]))</yellow>
			continue;

<yellow>		emulated_msrs[num_emulated_msrs++] = emulated_msrs_all[i];</yellow>
	}

<yellow>	for (i = 0; i < ARRAY_SIZE(msr_based_features_all); i++) {</yellow>
		struct kvm_msr_entry msr;

<yellow>		msr.index = msr_based_features_all[i];</yellow>
<yellow>		if (kvm_get_msr_feature(&msr))</yellow>
			continue;

<yellow>		msr_based_features[num_msr_based_features++] = msr_based_features_all[i];</yellow>
	}
}

static int vcpu_mmio_write(struct kvm_vcpu *vcpu, gpa_t addr, int len,
			   const void *v)
{
	int handled = 0;
	int n;

	do {
<blue>		n = min(len, 8);</blue>
<yellow>		if (!(lapic_in_kernel(vcpu) &&</yellow>
<blue>		      !kvm_iodevice_write(vcpu, &vcpu->arch.apic->dev, addr, n, v))</blue>
<blue>		    && kvm_io_bus_write(vcpu, KVM_MMIO_BUS, addr, n, v))</blue>
			break;
		handled += n;
		addr += n;
<yellow>		len -= n;</yellow>
		v += n;
	} while (len);

	return handled;
}

static int vcpu_mmio_read(struct kvm_vcpu *vcpu, gpa_t addr, int len, void *v)
{
	int handled = 0;
	int n;

	do {
<blue>		n = min(len, 8);</blue>
<yellow>		if (!(lapic_in_kernel(vcpu) &&</yellow>
<blue>		      !kvm_iodevice_read(vcpu, &vcpu->arch.apic->dev,</blue>
					 addr, n, v))
<blue>		    && kvm_io_bus_read(vcpu, KVM_MMIO_BUS, addr, n, v))</blue>
			break;
<yellow>		trace_kvm_mmio(KVM_TRACE_MMIO_READ, n, addr, v);</yellow>
		handled += n;
		addr += n;
<yellow>		len -= n;</yellow>
		v += n;
	} while (len);

	return handled;
<blue>}</blue>

static void kvm_set_segment(struct kvm_vcpu *vcpu,
			struct kvm_segment *var, int seg)
{
<blue>	static_call(kvm_x86_set_segment)(vcpu, var, seg);</blue>
}

void kvm_get_segment(struct kvm_vcpu *vcpu,
		     struct kvm_segment *var, int seg)
{
<blue>	static_call(kvm_x86_get_segment)(vcpu, var, seg);</blue>
}

gpa_t translate_nested_gpa(struct kvm_vcpu *vcpu, gpa_t gpa, u64 access,
			   struct x86_exception *exception)
{
<blue>	struct kvm_mmu *mmu = vcpu->arch.mmu;</blue>
	gpa_t t_gpa;

<yellow>	BUG_ON(!mmu_is_nested(vcpu));</yellow>

	/* NPT walks are always user-walks */
	access |= PFERR_USER_MASK;
<blue>	t_gpa  = mmu->gva_to_gpa(vcpu, mmu, gpa, access, exception);</blue>

	return t_gpa;
}

gpa_t kvm_mmu_gva_to_gpa_read(struct kvm_vcpu *vcpu, gva_t gva,
			      struct x86_exception *exception)
{
<yellow>	struct kvm_mmu *mmu = vcpu->arch.walk_mmu;</yellow>

	u64 access = (static_call(kvm_x86_get_cpl)(vcpu) == 3) ? PFERR_USER_MASK : 0;
	return mmu-&gt;gva_to_gpa(vcpu, mmu, gva, access, exception);
}
EXPORT_SYMBOL_GPL(kvm_mmu_gva_to_gpa_read);

 gpa_t kvm_mmu_gva_to_gpa_fetch(struct kvm_vcpu *vcpu, gva_t gva,
				struct x86_exception *exception)
{
<yellow>	struct kvm_mmu *mmu = vcpu->arch.walk_mmu;</yellow>

	u64 access = (static_call(kvm_x86_get_cpl)(vcpu) == 3) ? PFERR_USER_MASK : 0;
	access |= PFERR_FETCH_MASK;
	return mmu-&gt;gva_to_gpa(vcpu, mmu, gva, access, exception);
}

gpa_t kvm_mmu_gva_to_gpa_write(struct kvm_vcpu *vcpu, gva_t gva,
			       struct x86_exception *exception)
{
<yellow>	struct kvm_mmu *mmu = vcpu->arch.walk_mmu;</yellow>

	u64 access = (static_call(kvm_x86_get_cpl)(vcpu) == 3) ? PFERR_USER_MASK : 0;
	access |= PFERR_WRITE_MASK;
	return mmu-&gt;gva_to_gpa(vcpu, mmu, gva, access, exception);
}
EXPORT_SYMBOL_GPL(kvm_mmu_gva_to_gpa_write);

/* uses this to access any guest&#x27;s mapped memory without checking CPL */
gpa_t kvm_mmu_gva_to_gpa_system(struct kvm_vcpu *vcpu, gva_t gva,
				struct x86_exception *exception)
{
<yellow>	struct kvm_mmu *mmu = vcpu->arch.walk_mmu;</yellow>

	return mmu-&gt;gva_to_gpa(vcpu, mmu, gva, 0, exception);
}

static int kvm_read_guest_virt_helper(gva_t addr, void *val, unsigned int bytes,
				      struct kvm_vcpu *vcpu, u64 access,
				      struct x86_exception *exception)
{
<blue>	struct kvm_mmu *mmu = vcpu->arch.walk_mmu;</blue>
	void *data = val;
	int r = X86EMUL_CONTINUE;

	while (bytes) {
<blue>		gpa_t gpa = mmu->gva_to_gpa(vcpu, mmu, addr, access, exception);</blue>
		unsigned offset = addr &amp; (PAGE_SIZE-1);
		unsigned toread = min(bytes, (unsigned)PAGE_SIZE - offset);
		int ret;

		if (gpa == INVALID_GPA)
			return X86EMUL_PROPAGATE_FAULT;
<blue>		ret = kvm_vcpu_read_guest_page(vcpu, gpa >> PAGE_SHIFT, data,</blue>
					       offset, toread);
		if (ret &lt; 0) {
			r = X86EMUL_IO_NEEDED;
			goto out;
		}

<blue>		bytes -= toread;</blue>
		data += toread;
		addr += toread;
	}
out:
	return r;
<blue>}</blue>

/* used for instruction fetching */
static int kvm_fetch_guest_virt(struct x86_emulate_ctxt *ctxt,
				gva_t addr, void *val, unsigned int bytes,
				struct x86_exception *exception)
{
<blue>	struct kvm_vcpu *vcpu = emul_to_vcpu(ctxt);</blue>
	struct kvm_mmu *mmu = vcpu-&gt;arch.walk_mmu;
	u64 access = (static_call(kvm_x86_get_cpl)(vcpu) == 3) ? PFERR_USER_MASK : 0;
	unsigned offset;
	int ret;

	/* Inline kvm_read_guest_virt_helper for speed.  */
	gpa_t gpa = mmu-&gt;gva_to_gpa(vcpu, mmu, addr, access|PFERR_FETCH_MASK,
				    exception);
	if (unlikely(gpa == INVALID_GPA))
		return X86EMUL_PROPAGATE_FAULT;

<blue>	offset = addr & (PAGE_SIZE-1);</blue>
<yellow>	if (WARN_ON(offset + bytes > PAGE_SIZE))</yellow>
		bytes = (unsigned)PAGE_SIZE - offset;
<blue>	ret = kvm_vcpu_read_guest_page(vcpu, gpa >> PAGE_SHIFT, val,</blue>
				       offset, bytes);
	if (unlikely(ret &lt; 0))
		return X86EMUL_IO_NEEDED;

	return X86EMUL_CONTINUE;
<blue>}</blue>

int kvm_read_guest_virt(struct kvm_vcpu *vcpu,
			       gva_t addr, void *val, unsigned int bytes,
			       struct x86_exception *exception)
{
<blue>	u64 access = (static_call(kvm_x86_get_cpl)(vcpu) == 3) ? PFERR_USER_MASK : 0;</blue>

	/*
	 * FIXME: this should call handle_emulation_failure if X86EMUL_IO_NEEDED
	 * is returned, but our callers are not ready for that and they blindly
	 * call kvm_inject_page_fault.  Ensure that they at least do not leak
	 * uninitialized kernel stack memory into cr2 and error code.
	 */
	memset(exception, 0, sizeof(*exception));
	return kvm_read_guest_virt_helper(addr, val, bytes, vcpu, access,
					  exception);
}
EXPORT_SYMBOL_GPL(kvm_read_guest_virt);

static int emulator_read_std(struct x86_emulate_ctxt *ctxt,
			     gva_t addr, void *val, unsigned int bytes,
			     struct x86_exception *exception, bool system)
{
<yellow>	struct kvm_vcpu *vcpu = emul_to_vcpu(ctxt);</yellow>
	u64 access = 0;

	if (system)
		access |= PFERR_IMPLICIT_ACCESS;
<yellow>	else if (static_call(kvm_x86_get_cpl)(vcpu) == 3)</yellow>
		access |= PFERR_USER_MASK;

<yellow>	return kvm_read_guest_virt_helper(addr, val, bytes, vcpu, access, exception);</yellow>
}

static int kvm_read_guest_phys_system(struct x86_emulate_ctxt *ctxt,
		unsigned long addr, void *val, unsigned int bytes)
{
<yellow>	struct kvm_vcpu *vcpu = emul_to_vcpu(ctxt);</yellow>
	int r = kvm_vcpu_read_guest(vcpu, addr, val, bytes);

<yellow>	return r < 0 ? X86EMUL_IO_NEEDED : X86EMUL_CONTINUE;</yellow>
}

static int kvm_write_guest_virt_helper(gva_t addr, void *val, unsigned int bytes,
				      struct kvm_vcpu *vcpu, u64 access,
				      struct x86_exception *exception)
{
<blue>	struct kvm_mmu *mmu = vcpu->arch.walk_mmu;</blue>
	void *data = val;
	int r = X86EMUL_CONTINUE;

	while (bytes) {
<blue>		gpa_t gpa = mmu->gva_to_gpa(vcpu, mmu, addr, access, exception);</blue>
		unsigned offset = addr &amp; (PAGE_SIZE-1);
		unsigned towrite = min(bytes, (unsigned)PAGE_SIZE - offset);
		int ret;

		if (gpa == INVALID_GPA)
			return X86EMUL_PROPAGATE_FAULT;
<blue>		ret = kvm_vcpu_write_guest(vcpu, gpa, data, towrite);</blue>
		if (ret &lt; 0) {
			r = X86EMUL_IO_NEEDED;
			goto out;
		}

<blue>		bytes -= towrite;</blue>
		data += towrite;
		addr += towrite;
	}
out:
	return r;
<blue>}</blue>

static int emulator_write_std(struct x86_emulate_ctxt *ctxt, gva_t addr, void *val,
			      unsigned int bytes, struct x86_exception *exception,
			      bool system)
{
<yellow>	struct kvm_vcpu *vcpu = emul_to_vcpu(ctxt);</yellow>
	u64 access = PFERR_WRITE_MASK;

	if (system)
		access |= PFERR_IMPLICIT_ACCESS;
<yellow>	else if (static_call(kvm_x86_get_cpl)(vcpu) == 3)</yellow>
		access |= PFERR_USER_MASK;

<yellow>	return kvm_write_guest_virt_helper(addr, val, bytes, vcpu,</yellow>
					   access, exception);
}

int kvm_write_guest_virt_system(struct kvm_vcpu *vcpu, gva_t addr, void *val,
				unsigned int bytes, struct x86_exception *exception)
{
	/* kvm_write_guest_virt_system can pull in tons of pages. */
<blue>	vcpu->arch.l1tf_flush_l1d = true;</blue>

	return kvm_write_guest_virt_helper(addr, val, bytes, vcpu,
					   PFERR_WRITE_MASK, exception);
}
EXPORT_SYMBOL_GPL(kvm_write_guest_virt_system);

static int kvm_can_emulate_insn(struct kvm_vcpu *vcpu, int emul_type,
				void *insn, int insn_len)
{
<blue>	return static_call(kvm_x86_can_emulate_instruction)(vcpu, emul_type,</blue>
							    insn, insn_len);
}

int handle_ud(struct kvm_vcpu *vcpu)
<blue>{</blue>
	static const char kvm_emulate_prefix[] = { __KVM_EMULATE_PREFIX };
	int fep_flags = READ_ONCE(force_emulation_prefix);
	int emul_type = EMULTYPE_TRAP_UD;
	char sig[5]; /* ud2; .ascii &quot;kvm&quot; */
	struct x86_exception e;

<blue>	if (unlikely(!kvm_can_emulate_insn(vcpu, emul_type, NULL, 0)))</blue>
		return 1;

<blue>	if (fep_flags &&</blue>
<yellow>	    kvm_read_guest_virt(vcpu, kvm_get_linear_rip(vcpu),</yellow>
				sig, sizeof(sig), &amp;e) == 0 &amp;&amp;
<yellow>	    memcmp(sig, kvm_emulate_prefix, sizeof(sig)) == 0) {</yellow>
<yellow>		if (fep_flags & KVM_FEP_CLEAR_RFLAGS_RF)</yellow>
<yellow>			kvm_set_rflags(vcpu, kvm_get_rflags(vcpu) & ~X86_EFLAGS_RF);</yellow>
<yellow>		kvm_rip_write(vcpu, kvm_rip_read(vcpu) + sizeof(sig));</yellow>
		emul_type = EMULTYPE_TRAP_UD_FORCED;
	}

<blue>	return kvm_emulate_instruction(vcpu, emul_type);</blue>
}
EXPORT_SYMBOL_GPL(handle_ud);

static int vcpu_is_mmio_gpa(struct kvm_vcpu *vcpu, unsigned long gva,
			    gpa_t gpa, bool write)
{
	/* For APIC access vmexit */
<blue>	if ((gpa & PAGE_MASK) == APIC_DEFAULT_PHYS_BASE)</blue>
		return 1;

<blue>	if (vcpu_match_mmio_gpa(vcpu, gpa)) {</blue>
<blue>		trace_vcpu_match_mmio(gva, gpa, write, true);</blue>
		return 1;
	}

	return 0;
<blue>}</blue>

static int vcpu_mmio_gva_to_gpa(struct kvm_vcpu *vcpu, unsigned long gva,
				gpa_t *gpa, struct x86_exception *exception,
				bool write)
{
<blue>	struct kvm_mmu *mmu = vcpu->arch.walk_mmu;</blue>
	u64 access = ((static_call(kvm_x86_get_cpl)(vcpu) == 3) ? PFERR_USER_MASK : 0)
		| (write ? PFERR_WRITE_MASK : 0);

	/*
	 * currently PKRU is only applied to ept enabled guest so
	 * there is no pkey in EPT page table for L1 guest or EPT
	 * shadow page table for L2 guest.
	 */
<blue>	if (vcpu_match_mmio_gva(vcpu, gva) && (!is_paging(vcpu) ||</blue>
<yellow>	    !permission_fault(vcpu, vcpu->arch.walk_mmu,</yellow>
			      vcpu-&gt;arch.mmio_access, 0, access))) {
<yellow>		*gpa = vcpu->arch.mmio_gfn << PAGE_SHIFT |</yellow>
					(gva &amp; (PAGE_SIZE - 1));
<yellow>		trace_vcpu_match_mmio(gva, *gpa, write, false);</yellow>
		return 1;
	}

<blue>	*gpa = mmu->gva_to_gpa(vcpu, mmu, gva, access, exception);</blue>

	if (*gpa == INVALID_GPA)
		return -1;

<blue>	return vcpu_is_mmio_gpa(vcpu, gva, *gpa, write);</blue>
}

int emulator_write_phys(struct kvm_vcpu *vcpu, gpa_t gpa,
			const void *val, int bytes)
{
	int ret;

<blue>	ret = kvm_vcpu_write_guest(vcpu, gpa, val, bytes);</blue>
	if (ret &lt; 0)
		return 0;
<blue>	kvm_page_track_write(vcpu, gpa, val, bytes);</blue>
	return 1;
<yellow>}</yellow>

struct read_write_emulator_ops {
	int (*read_write_prepare)(struct kvm_vcpu *vcpu, void *val,
				  int bytes);
	int (*read_write_emulate)(struct kvm_vcpu *vcpu, gpa_t gpa,
				  void *val, int bytes);
	int (*read_write_mmio)(struct kvm_vcpu *vcpu, gpa_t gpa,
			       int bytes, void *val);
	int (*read_write_exit_mmio)(struct kvm_vcpu *vcpu, gpa_t gpa,
				    void *val, int bytes);
	bool write;
};

<blue>static int read_prepare(struct kvm_vcpu *vcpu, void *val, int bytes)</blue>
{
<blue>	if (vcpu->mmio_read_completed) {</blue>
<blue>		trace_kvm_mmio(KVM_TRACE_MMIO_READ, bytes,</blue>
			       vcpu-&gt;mmio_fragments[0].gpa, val);
<blue>		vcpu->mmio_read_completed = 0;</blue>
		return 1;
	}

	return 0;
<blue>}</blue>

static int read_emulate(struct kvm_vcpu *vcpu, gpa_t gpa,
			void *val, int bytes)
{
<blue>	return !kvm_vcpu_read_guest(vcpu, gpa, val, bytes);</blue>
}

static int write_emulate(struct kvm_vcpu *vcpu, gpa_t gpa,
			 void *val, int bytes)
{
<blue>	return emulator_write_phys(vcpu, gpa, val, bytes);</blue>
<blue>}</blue>

static int write_mmio(struct kvm_vcpu *vcpu, gpa_t gpa, int bytes, void *val)
{
<blue>	trace_kvm_mmio(KVM_TRACE_MMIO_WRITE, bytes, gpa, val);</blue>
<blue>	return vcpu_mmio_write(vcpu, gpa, bytes, val);</blue>
<blue>}</blue>

static int read_exit_mmio(struct kvm_vcpu *vcpu, gpa_t gpa,
			  void *val, int bytes)
{
<blue>	trace_kvm_mmio(KVM_TRACE_MMIO_READ_UNSATISFIED, bytes, gpa, NULL);</blue>
	return X86EMUL_IO_NEEDED;
<blue>}</blue>

static int write_exit_mmio(struct kvm_vcpu *vcpu, gpa_t gpa,
			   void *val, int bytes)
{
	struct kvm_mmio_fragment *frag = &amp;vcpu-&gt;mmio_fragments[0];

<blue>	memcpy(vcpu->run->mmio.data, frag->data, min(8u, frag->len));</blue>
	return X86EMUL_CONTINUE;
}

static const struct read_write_emulator_ops read_emultor = {
	.read_write_prepare = read_prepare,
	.read_write_emulate = read_emulate,
	.read_write_mmio = vcpu_mmio_read,
	.read_write_exit_mmio = read_exit_mmio,
};

static const struct read_write_emulator_ops write_emultor = {
	.read_write_emulate = write_emulate,
	.read_write_mmio = write_mmio,
	.read_write_exit_mmio = write_exit_mmio,
	.write = true,
};

static int emulator_read_write_onepage(unsigned long addr, void *val,
				       unsigned int bytes,
				       struct x86_exception *exception,
				       struct kvm_vcpu *vcpu,
				       const struct read_write_emulator_ops *ops)
{
	gpa_t gpa;
	int handled, ret;
<blue>	bool write = ops->write;</blue>
	struct kvm_mmio_fragment *frag;
<blue>	struct x86_emulate_ctxt *ctxt = vcpu->arch.emulate_ctxt;</blue>

	/*
	 * If the exit was due to a NPF we may already have a GPA.
	 * If the GPA is present, use it to avoid the GVA to GPA table walk.
	 * Note, this cannot be used on string operations since string
	 * operation using rep will only have the initial GPA from the NPF
	 * occurred.
	 */
<blue>	if (ctxt->gpa_available && emulator_can_use_gpa(ctxt) &&</blue>
<blue>	    (addr & ~PAGE_MASK) == (ctxt->gpa_val & ~PAGE_MASK)) {</blue>
		gpa = ctxt-&gt;gpa_val;
<blue>		ret = vcpu_is_mmio_gpa(vcpu, addr, gpa, write);</blue>
	} else {
<blue>		ret = vcpu_mmio_gva_to_gpa(vcpu, addr, &gpa, exception, write);</blue>
		if (ret &lt; 0)
			return X86EMUL_PROPAGATE_FAULT;
	}

<blue>	if (!ret && ops->read_write_emulate(vcpu, gpa, val, bytes))</blue>
		return X86EMUL_CONTINUE;

	/*
	 * Is this MMIO handled locally?
	 */
<blue>	handled = ops->read_write_mmio(vcpu, gpa, bytes, val);</blue>
	if (handled == bytes)
		return X86EMUL_CONTINUE;

<blue>	gpa += handled;</blue>
	bytes -= handled;
	val += handled;

<yellow>	WARN_ON(vcpu->mmio_nr_fragments >= KVM_MAX_MMIO_FRAGMENTS);</yellow>
<blue>	frag = &vcpu->mmio_fragments[vcpu->mmio_nr_fragments++];</blue>
	frag-&gt;gpa = gpa;
	frag-&gt;data = val;
	frag-&gt;len = bytes;
	return X86EMUL_CONTINUE;
<blue>}</blue>

static int emulator_read_write(struct x86_emulate_ctxt *ctxt,
			unsigned long addr,
			void *val, unsigned int bytes,
			struct x86_exception *exception,
			const struct read_write_emulator_ops *ops)
{
<blue>	struct kvm_vcpu *vcpu = emul_to_vcpu(ctxt);</blue>
	gpa_t gpa;
	int rc;

	if (ops-&gt;read_write_prepare &amp;&amp;
<blue>		  ops->read_write_prepare(vcpu, val, bytes))</blue>
		return X86EMUL_CONTINUE;

<blue>	vcpu->mmio_nr_fragments = 0;</blue>

	/* Crossing a page boundary? */
	if (((addr + bytes - 1) ^ addr) &amp; PAGE_MASK) {
		int now;

<blue>		now = -addr & ~PAGE_MASK;</blue>
		rc = emulator_read_write_onepage(addr, val, now, exception,
						 vcpu, ops);

		if (rc != X86EMUL_CONTINUE)
			return rc;
<blue>		addr += now;</blue>
		if (ctxt-&gt;mode != X86EMUL_MODE_PROT64)
<yellow>			addr = (u32)addr;</yellow>
<blue>		val += now;</blue>
		bytes -= now;
	}

<blue>	rc = emulator_read_write_onepage(addr, val, bytes, exception,</blue>
					 vcpu, ops);
	if (rc != X86EMUL_CONTINUE)
		return rc;

<blue>	if (!vcpu->mmio_nr_fragments)</blue>
		return rc;

<blue>	gpa = vcpu->mmio_fragments[0].gpa;</blue>

	vcpu-&gt;mmio_needed = 1;
	vcpu-&gt;mmio_cur_fragment = 0;

	vcpu-&gt;run-&gt;mmio.len = min(8u, vcpu-&gt;mmio_fragments[0].len);
<blue>	vcpu->run->mmio.is_write = vcpu->mmio_is_write = ops->write;</blue>
	vcpu-&gt;run-&gt;exit_reason = KVM_EXIT_MMIO;
	vcpu-&gt;run-&gt;mmio.phys_addr = gpa;

	return ops-&gt;read_write_exit_mmio(vcpu, gpa, val, bytes);
<blue>}</blue>

static int emulator_read_emulated(struct x86_emulate_ctxt *ctxt,
				  unsigned long addr,
				  void *val,
				  unsigned int bytes,
				  struct x86_exception *exception)
{
<blue>	return emulator_read_write(ctxt, addr, val, bytes,</blue>
				   exception, &amp;read_emultor);
}

static int emulator_write_emulated(struct x86_emulate_ctxt *ctxt,
			    unsigned long addr,
			    const void *val,
			    unsigned int bytes,
			    struct x86_exception *exception)
{
<blue>	return emulator_read_write(ctxt, addr, (void *)val, bytes,</blue>
				   exception, &amp;write_emultor);
}

#define emulator_try_cmpxchg_user(t, ptr, old, new) \
	(__try_cmpxchg_user((t __user *)(ptr), (t *)(old), *(t *)(new), efault ## t))

static int emulator_cmpxchg_emulated(struct x86_emulate_ctxt *ctxt,
				     unsigned long addr,
				     const void *old,
				     const void *new,
				     unsigned int bytes,
				     struct x86_exception *exception)
{
<yellow>	struct kvm_vcpu *vcpu = emul_to_vcpu(ctxt);</yellow>
	u64 page_line_mask;
	unsigned long hva;
	gpa_t gpa;
	int r;

	/* guests cmpxchg8b have to be emulated atomically */
<yellow>	if (bytes > 8 || (bytes & (bytes - 1)))</yellow>
		goto emul_write;

<yellow>	gpa = kvm_mmu_gva_to_gpa_write(vcpu, addr, NULL);</yellow>

	if (gpa == INVALID_GPA ||
<yellow>	    (gpa & PAGE_MASK) == APIC_DEFAULT_PHYS_BASE)</yellow>
		goto emul_write;

	/*
	 * Emulate the atomic as a straight write to avoid #AC if SLD is
	 * enabled in the host and the access splits a cache line.
	 */
<yellow>	if (boot_cpu_has(X86_FEATURE_SPLIT_LOCK_DETECT))</yellow>
<yellow>		page_line_mask = ~(cache_line_size() - 1);</yellow>
	else
		page_line_mask = PAGE_MASK;

<yellow>	if (((gpa + bytes - 1) & page_line_mask) != (gpa & page_line_mask))</yellow>
		goto emul_write;

<yellow>	hva = kvm_vcpu_gfn_to_hva(vcpu, gpa_to_gfn(gpa));</yellow>
	if (kvm_is_error_hva(hva))
		goto emul_write;

<yellow>	hva += offset_in_page(gpa);</yellow>

	switch (bytes) {
	case 1:
<yellow>		r = emulator_try_cmpxchg_user(u8, hva, old, new);</yellow>
		break;
	case 2:
<yellow>		r = emulator_try_cmpxchg_user(u16, hva, old, new);</yellow>
		break;
	case 4:
<yellow>		r = emulator_try_cmpxchg_user(u32, hva, old, new);</yellow>
		break;
	case 8:
<yellow>		r = emulator_try_cmpxchg_user(u64, hva, old, new);</yellow>
		break;
	default:
<yellow>		BUG();</yellow>
	}

	if (r &lt; 0)
		return X86EMUL_UNHANDLEABLE;
<yellow>	if (r)</yellow>
		return X86EMUL_CMPXCHG_FAILED;

<yellow>	kvm_page_track_write(vcpu, gpa, new, bytes);</yellow>

	return X86EMUL_CONTINUE;

emul_write:
<yellow>	printk_once(KERN_WARNING "kvm: emulating exchange as write\n");</yellow>

<yellow>	return emulator_write_emulated(ctxt, addr, new, bytes, exception);</yellow>
<yellow>}</yellow>

static int emulator_pio_in_out(struct kvm_vcpu *vcpu, int size,
			       unsigned short port, void *data,
			       unsigned int count, bool in)
{
	unsigned i;
	int r;

<blue>	WARN_ON_ONCE(vcpu->arch.pio.count);</blue>
<blue>	for (i = 0; i < count; i++) {</blue>
<blue>		if (in)</blue>
<blue>			r = kvm_io_bus_read(vcpu, KVM_PIO_BUS, port, size, data);</blue>
		else
<blue>			r = kvm_io_bus_write(vcpu, KVM_PIO_BUS, port, size, data);</blue>

<blue>		if (r) {</blue>
<blue>			if (i == 0)</blue>
				goto userspace_io;

			/*
			 * Userspace must have unregistered the device while PIO
			 * was running.  Drop writes / read as 0.
			 */
<yellow>			if (in)</yellow>
<yellow>				memset(data, 0, size * (count - i));</yellow>
			break;
		}

		data += size;
	}
	return 1;

userspace_io:
<blue>	vcpu->arch.pio.port = port;</blue>
	vcpu-&gt;arch.pio.in = in;
	vcpu-&gt;arch.pio.count = count;
	vcpu-&gt;arch.pio.size = size;

	if (in)
<blue>		memset(vcpu->arch.pio_data, 0, size * count);</blue>
	else
<blue>		memcpy(vcpu->arch.pio_data, data, size * count);</blue>

<blue>	vcpu->run->exit_reason = KVM_EXIT_IO;</blue>
	vcpu-&gt;run-&gt;io.direction = in ? KVM_EXIT_IO_IN : KVM_EXIT_IO_OUT;
	vcpu-&gt;run-&gt;io.size = size;
	vcpu-&gt;run-&gt;io.data_offset = KVM_PIO_PAGE_OFFSET * PAGE_SIZE;
	vcpu-&gt;run-&gt;io.count = count;
	vcpu-&gt;run-&gt;io.port = port;
	return 0;
<blue>}</blue>

static int emulator_pio_in(struct kvm_vcpu *vcpu, int size,
      			   unsigned short port, void *val, unsigned int count)
{
	int r = emulator_pio_in_out(vcpu, size, port, val, count, true);
	if (r)
<blue>		trace_kvm_pio(KVM_PIO_IN, port, size, count, val);</blue>

	return r;
}

static void complete_emulator_pio_in(struct kvm_vcpu *vcpu, void *val)
{
<blue>	int size = vcpu->arch.pio.size;</blue>
	unsigned int count = vcpu-&gt;arch.pio.count;
	memcpy(val, vcpu-&gt;arch.pio_data, size * count);
<yellow>	trace_kvm_pio(KVM_PIO_IN, vcpu->arch.pio.port, size, count, vcpu->arch.pio_data);</yellow>
<blue>	vcpu->arch.pio.count = 0;</blue>
}

static int emulator_pio_in_emulated(struct x86_emulate_ctxt *ctxt,
				    int size, unsigned short port, void *val,
				    unsigned int count)
{
<blue>	struct kvm_vcpu *vcpu = emul_to_vcpu(ctxt);</blue>
	if (vcpu-&gt;arch.pio.count) {
		/*
		 * Complete a previous iteration that required userspace I/O.
		 * Note, @count isn&#x27;t guaranteed to match pio.count as userspace
		 * can modify ECX before rerunning the vCPU.  Ignore any such
		 * shenanigans as KVM doesn&#x27;t support modifying the rep count,
		 * and the emulator ensures @count doesn&#x27;t overflow the buffer.
		 */
<blue>		complete_emulator_pio_in(vcpu, val);</blue>
		return 1;
	}

<blue>	return emulator_pio_in(vcpu, size, port, val, count);</blue>
<blue>}</blue>

static int emulator_pio_out(struct kvm_vcpu *vcpu, int size,
			    unsigned short port, const void *val,
			    unsigned int count)
{
<yellow>	trace_kvm_pio(KVM_PIO_OUT, port, size, count, val);</yellow>
<blue>	return emulator_pio_in_out(vcpu, size, port, (void *)val, count, false);</blue>
}

static int emulator_pio_out_emulated(struct x86_emulate_ctxt *ctxt,
				     int size, unsigned short port,
				     const void *val, unsigned int count)
{
<blue>	return emulator_pio_out(emul_to_vcpu(ctxt), size, port, val, count);</blue>
}

static unsigned long get_segment_base(struct kvm_vcpu *vcpu, int seg)
{
<yellow>	return static_call(kvm_x86_get_segment_base)(vcpu, seg);</yellow>
}

static void emulator_invlpg(struct x86_emulate_ctxt *ctxt, ulong address)
{
<yellow>	kvm_mmu_invlpg(emul_to_vcpu(ctxt), address);</yellow>
}

<yellow>static int kvm_emulate_wbinvd_noskip(struct kvm_vcpu *vcpu)</yellow>
{
<blue>	if (!need_emulate_wbinvd(vcpu))</blue>
		return X86EMUL_CONTINUE;

<yellow>	if (static_call(kvm_x86_has_wbinvd_exit)()) {</yellow>
<yellow>		int cpu = get_cpu();</yellow>

		cpumask_set_cpu(cpu, vcpu-&gt;arch.wbinvd_dirty_mask);
		on_each_cpu_mask(vcpu-&gt;arch.wbinvd_dirty_mask,
				wbinvd_ipi, NULL, 1);
<yellow>		put_cpu();</yellow>
<yellow>		cpumask_clear(vcpu->arch.wbinvd_dirty_mask);</yellow>
	} else
<yellow>		wbinvd();</yellow>
	return X86EMUL_CONTINUE;
<blue>}</blue>

int kvm_emulate_wbinvd(struct kvm_vcpu *vcpu)
{
<blue>	kvm_emulate_wbinvd_noskip(vcpu);</blue>
<blue>	return kvm_skip_emulated_instruction(vcpu);</blue>
<blue>}</blue>
EXPORT_SYMBOL_GPL(kvm_emulate_wbinvd);



static void emulator_wbinvd(struct x86_emulate_ctxt *ctxt)
{
<yellow>	kvm_emulate_wbinvd_noskip(emul_to_vcpu(ctxt));</yellow>
}

static void emulator_get_dr(struct x86_emulate_ctxt *ctxt, int dr,
			    unsigned long *dest)
{
<yellow>	kvm_get_dr(emul_to_vcpu(ctxt), dr, dest);</yellow>
}

static int emulator_set_dr(struct x86_emulate_ctxt *ctxt, int dr,
			   unsigned long value)
{

<yellow>	return kvm_set_dr(emul_to_vcpu(ctxt), dr, value);</yellow>
}

static u64 mk_cr_64(u64 curr_cr, u32 new_val)
{
	return (curr_cr &amp; ~((1ULL &lt;&lt; 32) - 1)) | new_val;
}

static unsigned long emulator_get_cr(struct x86_emulate_ctxt *ctxt, int cr)
{
<blue>	struct kvm_vcpu *vcpu = emul_to_vcpu(ctxt);</blue>
	unsigned long value;

	switch (cr) {
	case 0:
<yellow>		value = kvm_read_cr0(vcpu);</yellow>
		break;
	case 2:
<yellow>		value = vcpu->arch.cr2;</yellow>
		break;
	case 3:
<yellow>		value = kvm_read_cr3(vcpu);</yellow>
		break;
	case 4:
<blue>		value = kvm_read_cr4(vcpu);</blue>
		break;
	case 8:
<yellow>		value = kvm_get_cr8(vcpu);</yellow>
		break;
	default:
		kvm_err(&quot;%s: unexpected cr %u\n&quot;, __func__, cr);
		return 0;
	}

	return value;
<blue>}</blue>

static int emulator_set_cr(struct x86_emulate_ctxt *ctxt, int cr, ulong val)
{
<yellow>	struct kvm_vcpu *vcpu = emul_to_vcpu(ctxt);</yellow>
	int res = 0;

	switch (cr) {
	case 0:
<yellow>		res = kvm_set_cr0(vcpu, mk_cr_64(kvm_read_cr0(vcpu), val));</yellow>
		break;
	case 2:
<yellow>		vcpu->arch.cr2 = val;</yellow>
		break;
	case 3:
<yellow>		res = kvm_set_cr3(vcpu, val);</yellow>
		break;
	case 4:
<yellow>		res = kvm_set_cr4(vcpu, mk_cr_64(kvm_read_cr4(vcpu), val));</yellow>
		break;
	case 8:
<yellow>		res = kvm_set_cr8(vcpu, val);</yellow>
		break;
	default:
		kvm_err(&quot;%s: unexpected cr %u\n&quot;, __func__, cr);
		res = -1;
	}

	return res;
<yellow>}</yellow>

static int emulator_get_cpl(struct x86_emulate_ctxt *ctxt)
{
<blue>	return static_call(kvm_x86_get_cpl)(emul_to_vcpu(ctxt));</blue>
}

static void emulator_get_gdt(struct x86_emulate_ctxt *ctxt, struct desc_ptr *dt)
{
<yellow>	static_call(kvm_x86_get_gdt)(emul_to_vcpu(ctxt), dt);</yellow>
}

static void emulator_get_idt(struct x86_emulate_ctxt *ctxt, struct desc_ptr *dt)
{
<yellow>	static_call(kvm_x86_get_idt)(emul_to_vcpu(ctxt), dt);</yellow>
}

static void emulator_set_gdt(struct x86_emulate_ctxt *ctxt, struct desc_ptr *dt)
{
<yellow>	static_call(kvm_x86_set_gdt)(emul_to_vcpu(ctxt), dt);</yellow>
}

static void emulator_set_idt(struct x86_emulate_ctxt *ctxt, struct desc_ptr *dt)
{
<yellow>	static_call(kvm_x86_set_idt)(emul_to_vcpu(ctxt), dt);</yellow>
}

static unsigned long emulator_get_cached_segment_base(
	struct x86_emulate_ctxt *ctxt, int seg)
{
<blue>	return get_segment_base(emul_to_vcpu(ctxt), seg);</blue>
}

static bool emulator_get_segment(struct x86_emulate_ctxt *ctxt, u16 *selector,
				 struct desc_struct *desc, u32 *base3,
				 int seg)
<blue>{</blue>
	struct kvm_segment var;

<blue>	kvm_get_segment(emul_to_vcpu(ctxt), &var, seg);</blue>
	*selector = var.selector;

	if (var.unusable) {
<yellow>		memset(desc, 0, sizeof(*desc));</yellow>
		if (base3)
<yellow>			*base3 = 0;</yellow>
		return false;
	}

<blue>	if (var.g)</blue>
<blue>		var.limit >>= 12;</blue>
<blue>	set_desc_limit(desc, var.limit);</blue>
	set_desc_base(desc, (unsigned long)var.base);
#ifdef CONFIG_X86_64
	if (base3)
<yellow>		*base3 = var.base >> 32;</yellow>
#endif
<blue>	desc->type = var.type;</blue>
	desc-&gt;s = var.s;
	desc-&gt;dpl = var.dpl;
	desc-&gt;p = var.present;
	desc-&gt;avl = var.avl;
	desc-&gt;l = var.l;
	desc-&gt;d = var.db;
	desc-&gt;g = var.g;

	return true;
}

static void emulator_set_segment(struct x86_emulate_ctxt *ctxt, u16 selector,
				 struct desc_struct *desc, u32 base3,
				 int seg)
{
<yellow>	struct kvm_vcpu *vcpu = emul_to_vcpu(ctxt);</yellow>
	struct kvm_segment var;

	var.selector = selector;
	var.base = get_desc_base(desc);
#ifdef CONFIG_X86_64
	var.base |= ((u64)base3) &lt;&lt; 32;
#endif
	var.limit = get_desc_limit(desc);
	if (desc-&gt;g)
<yellow>		var.limit = (var.limit << 12) | 0xfff;</yellow>
<yellow>	var.type = desc->type;</yellow>
	var.dpl = desc-&gt;dpl;
	var.db = desc-&gt;d;
	var.s = desc-&gt;s;
	var.l = desc-&gt;l;
	var.g = desc-&gt;g;
	var.avl = desc-&gt;avl;
	var.present = desc-&gt;p;
	var.unusable = !var.present;
	var.padding = 0;

	kvm_set_segment(vcpu, &amp;var, seg);
	return;
}

static int emulator_get_msr_with_filter(struct x86_emulate_ctxt *ctxt,
					u32 msr_index, u64 *pdata)
{
<yellow>	struct kvm_vcpu *vcpu = emul_to_vcpu(ctxt);</yellow>
	int r;

<yellow>	r = kvm_get_msr_with_filter(vcpu, msr_index, pdata);</yellow>
<yellow>	if (r < 0)</yellow>
		return X86EMUL_UNHANDLEABLE;

<yellow>	if (r) {</yellow>
<yellow>		if (kvm_msr_user_space(vcpu, msr_index, KVM_EXIT_X86_RDMSR, 0,</yellow>
				       complete_emulated_rdmsr, r))
			return X86EMUL_IO_NEEDED;

<yellow>		trace_kvm_msr_read_ex(msr_index);</yellow>
		return X86EMUL_PROPAGATE_FAULT;
	}

<yellow>	trace_kvm_msr_read(msr_index, *pdata);</yellow>
	return X86EMUL_CONTINUE;
<yellow>}</yellow>

static int emulator_set_msr_with_filter(struct x86_emulate_ctxt *ctxt,
					u32 msr_index, u64 data)
{
<yellow>	struct kvm_vcpu *vcpu = emul_to_vcpu(ctxt);</yellow>
	int r;

<yellow>	r = kvm_set_msr_with_filter(vcpu, msr_index, data);</yellow>
<yellow>	if (r < 0)</yellow>
		return X86EMUL_UNHANDLEABLE;

<yellow>	if (r) {</yellow>
<yellow>		if (kvm_msr_user_space(vcpu, msr_index, KVM_EXIT_X86_WRMSR, data,</yellow>
				       complete_emulated_msr_access, r))
			return X86EMUL_IO_NEEDED;

<yellow>		trace_kvm_msr_write_ex(msr_index, data);</yellow>
		return X86EMUL_PROPAGATE_FAULT;
	}

<yellow>	trace_kvm_msr_write(msr_index, data);</yellow>
	return X86EMUL_CONTINUE;
<yellow>}</yellow>

static int emulator_get_msr(struct x86_emulate_ctxt *ctxt,
			    u32 msr_index, u64 *pdata)
{
<yellow>	return kvm_get_msr(emul_to_vcpu(ctxt), msr_index, pdata);</yellow>
<yellow>}</yellow>

static int emulator_set_msr(struct x86_emulate_ctxt *ctxt,
			    u32 msr_index, u64 data)
{
<yellow>	return kvm_set_msr(emul_to_vcpu(ctxt), msr_index, data);</yellow>
<yellow>}</yellow>

static u64 emulator_get_smbase(struct x86_emulate_ctxt *ctxt)
{
<yellow>	struct kvm_vcpu *vcpu = emul_to_vcpu(ctxt);</yellow>

	return vcpu-&gt;arch.smbase;
}

static void emulator_set_smbase(struct x86_emulate_ctxt *ctxt, u64 smbase)
{
<yellow>	struct kvm_vcpu *vcpu = emul_to_vcpu(ctxt);</yellow>

	vcpu-&gt;arch.smbase = smbase;
}

static int emulator_check_pmc(struct x86_emulate_ctxt *ctxt,
			      u32 pmc)
{
<yellow>	if (kvm_pmu_is_valid_rdpmc_ecx(emul_to_vcpu(ctxt), pmc))</yellow>
<yellow>		return 0;</yellow>
	return -EINVAL;
}

static int emulator_read_pmc(struct x86_emulate_ctxt *ctxt,
			     u32 pmc, u64 *pdata)
{
<yellow>	return kvm_pmu_rdpmc(emul_to_vcpu(ctxt), pmc, pdata);</yellow>
}

static void emulator_halt(struct x86_emulate_ctxt *ctxt)
{
<yellow>	emul_to_vcpu(ctxt)->arch.halt_request = 1;</yellow>
}

static int emulator_intercept(struct x86_emulate_ctxt *ctxt,
			      struct x86_instruction_info *info,
			      enum x86_intercept_stage stage)
{
<blue>	return static_call(kvm_x86_check_intercept)(emul_to_vcpu(ctxt), info, stage,</blue>
					    &amp;ctxt-&gt;exception);
}

static bool emulator_get_cpuid(struct x86_emulate_ctxt *ctxt,
			      u32 *eax, u32 *ebx, u32 *ecx, u32 *edx,
			      bool exact_only)
{
<yellow>	return kvm_cpuid(emul_to_vcpu(ctxt), eax, ebx, ecx, edx, exact_only);</yellow>
}

static bool emulator_guest_has_long_mode(struct x86_emulate_ctxt *ctxt)
{
<yellow>	return guest_cpuid_has(emul_to_vcpu(ctxt), X86_FEATURE_LM);</yellow>
<yellow>}</yellow>

static bool emulator_guest_has_movbe(struct x86_emulate_ctxt *ctxt)
{
<yellow>	return guest_cpuid_has(emul_to_vcpu(ctxt), X86_FEATURE_MOVBE);</yellow>
<yellow>}</yellow>

static bool emulator_guest_has_fxsr(struct x86_emulate_ctxt *ctxt)
{
<yellow>	return guest_cpuid_has(emul_to_vcpu(ctxt), X86_FEATURE_FXSR);</yellow>
<yellow>}</yellow>

static bool emulator_guest_has_rdpid(struct x86_emulate_ctxt *ctxt)
{
<yellow>	return guest_cpuid_has(emul_to_vcpu(ctxt), X86_FEATURE_RDPID);</yellow>
<yellow>}</yellow>

static ulong emulator_read_gpr(struct x86_emulate_ctxt *ctxt, unsigned reg)
{
<blue>	return kvm_register_read_raw(emul_to_vcpu(ctxt), reg);</blue>
<blue>}</blue>

static void emulator_write_gpr(struct x86_emulate_ctxt *ctxt, unsigned reg, ulong val)
{
<blue>	kvm_register_write_raw(emul_to_vcpu(ctxt), reg, val);</blue>
<blue>}</blue>

static void emulator_set_nmi_mask(struct x86_emulate_ctxt *ctxt, bool masked)
{
<yellow>	static_call(kvm_x86_set_nmi_mask)(emul_to_vcpu(ctxt), masked);</yellow>
}

static unsigned emulator_get_hflags(struct x86_emulate_ctxt *ctxt)
{
<blue>	return emul_to_vcpu(ctxt)->arch.hflags;</blue>
}

static void emulator_exiting_smm(struct x86_emulate_ctxt *ctxt)
{
<yellow>	struct kvm_vcpu *vcpu = emul_to_vcpu(ctxt);</yellow>

	kvm_smm_changed(vcpu, false);
}

static int emulator_leave_smm(struct x86_emulate_ctxt *ctxt,
				  const char *smstate)
{
<yellow>	return static_call(kvm_x86_leave_smm)(emul_to_vcpu(ctxt), smstate);</yellow>
}

static void emulator_triple_fault(struct x86_emulate_ctxt *ctxt)
{
<yellow>	kvm_make_request(KVM_REQ_TRIPLE_FAULT, emul_to_vcpu(ctxt));</yellow>
}

static int emulator_set_xcr(struct x86_emulate_ctxt *ctxt, u32 index, u64 xcr)
{
<yellow>	return __kvm_set_xcr(emul_to_vcpu(ctxt), index, xcr);</yellow>
}

static void emulator_vm_bugged(struct x86_emulate_ctxt *ctxt)
{
<yellow>	struct kvm *kvm = emul_to_vcpu(ctxt)->kvm;</yellow>

<yellow>	if (!kvm->vm_bugged)</yellow>
<yellow>		kvm_vm_bugged(kvm);</yellow>
<yellow>}</yellow>

static const struct x86_emulate_ops emulate_ops = {
	.vm_bugged           = emulator_vm_bugged,
	.read_gpr            = emulator_read_gpr,
	.write_gpr           = emulator_write_gpr,
	.read_std            = emulator_read_std,
	.write_std           = emulator_write_std,
	.read_phys           = kvm_read_guest_phys_system,
	.fetch               = kvm_fetch_guest_virt,
	.read_emulated       = emulator_read_emulated,
	.write_emulated      = emulator_write_emulated,
	.cmpxchg_emulated    = emulator_cmpxchg_emulated,
	.invlpg              = emulator_invlpg,
	.pio_in_emulated     = emulator_pio_in_emulated,
	.pio_out_emulated    = emulator_pio_out_emulated,
	.get_segment         = emulator_get_segment,
	.set_segment         = emulator_set_segment,
	.get_cached_segment_base = emulator_get_cached_segment_base,
	.get_gdt             = emulator_get_gdt,
	.get_idt	     = emulator_get_idt,
	.set_gdt             = emulator_set_gdt,
	.set_idt	     = emulator_set_idt,
	.get_cr              = emulator_get_cr,
	.set_cr              = emulator_set_cr,
	.cpl                 = emulator_get_cpl,
	.get_dr              = emulator_get_dr,
	.set_dr              = emulator_set_dr,
	.get_smbase          = emulator_get_smbase,
	.set_smbase          = emulator_set_smbase,
	.set_msr_with_filter = emulator_set_msr_with_filter,
	.get_msr_with_filter = emulator_get_msr_with_filter,
	.set_msr             = emulator_set_msr,
	.get_msr             = emulator_get_msr,
	.check_pmc	     = emulator_check_pmc,
	.read_pmc            = emulator_read_pmc,
	.halt                = emulator_halt,
	.wbinvd              = emulator_wbinvd,
	.fix_hypercall       = emulator_fix_hypercall,
	.intercept           = emulator_intercept,
	.get_cpuid           = emulator_get_cpuid,
	.guest_has_long_mode = emulator_guest_has_long_mode,
	.guest_has_movbe     = emulator_guest_has_movbe,
	.guest_has_fxsr      = emulator_guest_has_fxsr,
	.guest_has_rdpid     = emulator_guest_has_rdpid,
	.set_nmi_mask        = emulator_set_nmi_mask,
	.get_hflags          = emulator_get_hflags,
	.exiting_smm         = emulator_exiting_smm,
	.leave_smm           = emulator_leave_smm,
	.triple_fault        = emulator_triple_fault,
	.set_xcr             = emulator_set_xcr,
};

static void toggle_interruptibility(struct kvm_vcpu *vcpu, u32 mask)
{
	u32 int_shadow = static_call(kvm_x86_get_interrupt_shadow)(vcpu);
	/*
	 * an sti; sti; sequence only disable interrupts for the first
	 * instruction. So, if the last instruction, be it emulated or
	 * not, left the system with the INT_STI flag enabled, it
	 * means that the last instruction is an sti. We should not
	 * leave the flag on in this case. The same goes for mov ss
	 */
	if (int_shadow &amp; mask)
		mask = 0;
<blue>	if (unlikely(int_shadow || mask)) {</blue>
<blue>		static_call(kvm_x86_set_interrupt_shadow)(vcpu, mask);</blue>
		if (!mask)
<blue>			kvm_make_request(KVM_REQ_EVENT, vcpu);</blue>
	}
}

static void inject_emulated_exception(struct kvm_vcpu *vcpu)
{
<blue>	struct x86_emulate_ctxt *ctxt = vcpu->arch.emulate_ctxt;</blue>

	if (ctxt-&gt;exception.vector == PF_VECTOR)
<blue>		kvm_inject_emulated_page_fault(vcpu, &ctxt->exception);</blue>
<blue>	else if (ctxt->exception.error_code_valid)</blue>
		kvm_queue_exception_e(vcpu, ctxt-&gt;exception.vector,
<blue>				      ctxt->exception.error_code);</blue>
	else
<blue>		kvm_queue_exception(vcpu, ctxt->exception.vector);</blue>
<blue>}</blue>

static struct x86_emulate_ctxt *alloc_emulate_ctxt(struct kvm_vcpu *vcpu)
{
	struct x86_emulate_ctxt *ctxt;

<blue>	ctxt = kmem_cache_zalloc(x86_emulator_cache, GFP_KERNEL_ACCOUNT);</blue>
	if (!ctxt) {
		pr_err(&quot;kvm: failed to allocate vcpu&#x27;s emulator\n&quot;);
		return NULL;
	}

<blue>	ctxt->vcpu = vcpu;</blue>
	ctxt-&gt;ops = &amp;emulate_ops;
	vcpu-&gt;arch.emulate_ctxt = ctxt;

	return ctxt;
}

static void init_emulate_ctxt(struct kvm_vcpu *vcpu)
{
<blue>	struct x86_emulate_ctxt *ctxt = vcpu->arch.emulate_ctxt;</blue>
	int cs_db, cs_l;

	static_call(kvm_x86_get_cs_db_l_bits)(vcpu, &amp;cs_db, &amp;cs_l);

	ctxt-&gt;gpa_available = false;
<blue>	ctxt->eflags = kvm_get_rflags(vcpu);</blue>
<blue>	ctxt->tf = (ctxt->eflags & X86_EFLAGS_TF) != 0;</blue>

<blue>	ctxt->eip = kvm_rip_read(vcpu);</blue>
<blue>	ctxt->mode = (!is_protmode(vcpu))		? X86EMUL_MODE_REAL :</blue>
<blue>		     (ctxt->eflags & X86_EFLAGS_VM)	? X86EMUL_MODE_VM86 :</blue>
<blue>		     (cs_l && is_long_mode(vcpu))	? X86EMUL_MODE_PROT64 :</blue>
<blue>		     cs_db				? X86EMUL_MODE_PROT32 :</blue>
							  X86EMUL_MODE_PROT16;
	BUILD_BUG_ON(HF_GUEST_MASK != X86EMUL_GUEST_MASK);
	BUILD_BUG_ON(HF_SMM_MASK != X86EMUL_SMM_MASK);
	BUILD_BUG_ON(HF_SMM_INSIDE_NMI_MASK != X86EMUL_SMM_INSIDE_NMI_MASK);

	ctxt-&gt;interruptibility = 0;
	ctxt-&gt;have_exception = false;
	ctxt-&gt;exception.vector = -1;
	ctxt-&gt;perm_ok = false;

	init_decode_cache(ctxt);
	vcpu-&gt;arch.emulate_regs_need_sync_from_vcpu = false;
}

void kvm_inject_realmode_interrupt(struct kvm_vcpu *vcpu, int irq, int inc_eip)
{
<yellow>	struct x86_emulate_ctxt *ctxt = vcpu->arch.emulate_ctxt;</yellow>
	int ret;

	init_emulate_ctxt(vcpu);

	ctxt-&gt;op_bytes = 2;
	ctxt-&gt;ad_bytes = 2;
	ctxt-&gt;_eip = ctxt-&gt;eip + inc_eip;
	ret = emulate_int_real(ctxt, irq);

	if (ret != X86EMUL_CONTINUE) {
<yellow>		kvm_make_request(KVM_REQ_TRIPLE_FAULT, vcpu);</yellow>
	} else {
<yellow>		ctxt->eip = ctxt->_eip;</yellow>
		kvm_rip_write(vcpu, ctxt-&gt;eip);
		kvm_set_rflags(vcpu, ctxt-&gt;eflags);
	}
<yellow>}</yellow>
EXPORT_SYMBOL_GPL(kvm_inject_realmode_interrupt);

static void prepare_emulation_failure_exit(struct kvm_vcpu *vcpu, u64 *data,
					   u8 ndata, u8 *insn_bytes, u8 insn_size)
{
<blue>	struct kvm_run *run = vcpu->run;</blue>
	u64 info[5];
	u8 info_start;

	/*
	 * Zero the whole array used to retrieve the exit info, as casting to
	 * u32 for select entries will leave some chunks uninitialized.
	 */
	memset(&amp;info, 0, sizeof(info));

	static_call(kvm_x86_get_exit_info)(vcpu, (u32 *)&amp;info[0], &amp;info[1],
					   &amp;info[2], (u32 *)&amp;info[3],
					   (u32 *)&amp;info[4]);

	run-&gt;exit_reason = KVM_EXIT_INTERNAL_ERROR;
	run-&gt;emulation_failure.suberror = KVM_INTERNAL_ERROR_EMULATION;

	/*
	 * There&#x27;s currently space for 13 entries, but 5 are used for the exit
	 * reason and info.  Restrict to 4 to reduce the maintenance burden
	 * when expanding kvm_run.emulation_failure in the future.
	 */
<blue>	if (WARN_ON_ONCE(ndata > 4))</blue>
		ndata = 4;

	/* Always include the flags as a &#x27;data&#x27; entry. */
	info_start = 1;
<blue>	run->emulation_failure.flags = 0;</blue>

<blue>	if (insn_size) {</blue>
		BUILD_BUG_ON((sizeof(run-&gt;emulation_failure.insn_size) +
			      sizeof(run-&gt;emulation_failure.insn_bytes) != 16));
		info_start += 2;
<yellow>		run->emulation_failure.flags |=</yellow>
			KVM_INTERNAL_ERROR_EMULATION_FLAG_INSTRUCTION_BYTES;
		run-&gt;emulation_failure.insn_size = insn_size;
		memset(run-&gt;emulation_failure.insn_bytes, 0x90,
		       sizeof(run-&gt;emulation_failure.insn_bytes));
<yellow>		memcpy(run->emulation_failure.insn_bytes, insn_bytes, insn_size);</yellow>
	}

<blue>	memcpy(&run->internal.data[info_start], info, sizeof(info));</blue>
	memcpy(&amp;run-&gt;internal.data[info_start + ARRAY_SIZE(info)], data,
	       ndata * sizeof(data[0]));

	run-&gt;emulation_failure.ndata = info_start + ARRAY_SIZE(info) + ndata;
}

static void prepare_emulation_ctxt_failure_exit(struct kvm_vcpu *vcpu)
{
<blue>	struct x86_emulate_ctxt *ctxt = vcpu->arch.emulate_ctxt;</blue>

	prepare_emulation_failure_exit(vcpu, NULL, 0, ctxt-&gt;fetch.data,
				       ctxt-&gt;fetch.end - ctxt-&gt;fetch.data);
}

void __kvm_prepare_emulation_failure_exit(struct kvm_vcpu *vcpu, u64 *data,
					  u8 ndata)
{
<yellow>	prepare_emulation_failure_exit(vcpu, data, ndata, NULL, 0);</yellow>
}
EXPORT_SYMBOL_GPL(__kvm_prepare_emulation_failure_exit);

void kvm_prepare_emulation_failure_exit(struct kvm_vcpu *vcpu)
{
<yellow>	__kvm_prepare_emulation_failure_exit(vcpu, NULL, 0);</yellow>
}
EXPORT_SYMBOL_GPL(kvm_prepare_emulation_failure_exit);

static int handle_emulation_failure(struct kvm_vcpu *vcpu, int emulation_type)
{
<blue>	struct kvm *kvm = vcpu->kvm;</blue>

	++vcpu-&gt;stat.insn_emulation_fail;
<yellow>	trace_kvm_emulate_insn_failed(vcpu);</yellow>

<blue>	if (emulation_type & EMULTYPE_VMWARE_GP) {</blue>
<yellow>		kvm_queue_exception_e(vcpu, GP_VECTOR, 0);</yellow>
		return 1;
	}

<blue>	if (kvm->arch.exit_on_emulation_error ||</blue>
<blue>	    (emulation_type & EMULTYPE_SKIP)) {</blue>
<yellow>		prepare_emulation_ctxt_failure_exit(vcpu);</yellow>
		return 0;
	}

<blue>	kvm_queue_exception(vcpu, UD_VECTOR);</blue>

<blue>	if (!is_guest_mode(vcpu) && static_call(kvm_x86_get_cpl)(vcpu) == 0) {</blue>
<blue>		prepare_emulation_ctxt_failure_exit(vcpu);</blue>
		return 0;
	}

	return 1;
<blue>}</blue>

<blue>static bool reexecute_instruction(struct kvm_vcpu *vcpu, gpa_t cr2_or_gpa,</blue>
				  bool write_fault_to_shadow_pgtable,
				  int emulation_type)
{
	gpa_t gpa = cr2_or_gpa;
	kvm_pfn_t pfn;

<blue>	if (!(emulation_type & EMULTYPE_ALLOW_RETRY_PF))</blue>
		return false;

<blue>	if (WARN_ON_ONCE(is_guest_mode(vcpu)) ||</blue>
<blue>	    WARN_ON_ONCE(!(emulation_type & EMULTYPE_PF)))</blue>
		return false;

<blue>	if (!vcpu->arch.mmu->root_role.direct) {</blue>
		/*
		 * Write permission should be allowed since only
		 * write access need to be emulated.
		 */
<yellow>		gpa = kvm_mmu_gva_to_gpa_write(vcpu, cr2_or_gpa, NULL);</yellow>

		/*
		 * If the mapping is invalid in guest, let cpu retry
		 * it to generate fault.
		 */
		if (gpa == INVALID_GPA)
			return true;
	}

	/*
	 * Do not retry the unhandleable instruction if it faults on the
	 * readonly host memory, otherwise it will goto a infinite loop:
	 * retry instruction -&gt; write #PF -&gt; emulation fail -&gt; retry
	 * instruction -&gt; ...
	 */
<blue>	pfn = gfn_to_pfn(vcpu->kvm, gpa_to_gfn(gpa));</blue>

	/*
	 * If the instruction failed on the error pfn, it can not be fixed,
	 * report the error to userspace.
	 */
	if (is_error_noslot_pfn(pfn))
		return false;

<blue>	kvm_release_pfn_clean(pfn);</blue>

	/* The instructions are well-emulated on direct mmu. */
	if (vcpu-&gt;arch.mmu-&gt;root_role.direct) {
		unsigned int indirect_shadow_pages;

<blue>		write_lock(&vcpu->kvm->mmu_lock);</blue>
		indirect_shadow_pages = vcpu-&gt;kvm-&gt;arch.indirect_shadow_pages;
		write_unlock(&amp;vcpu-&gt;kvm-&gt;mmu_lock);

		if (indirect_shadow_pages)
<blue>			kvm_mmu_unprotect_page(vcpu->kvm, gpa_to_gfn(gpa));</blue>

		return true;
	}

	/*
	 * if emulation was due to access to shadowed page table
	 * and it failed try to unshadow page and re-enter the
	 * guest to let CPU execute the instruction.
	 */
<yellow>	kvm_mmu_unprotect_page(vcpu->kvm, gpa_to_gfn(gpa));</yellow>

	/*
	 * If the access faults on its page table, it can not
	 * be fixed by unprotecting shadow page and it should
	 * be reported to userspace.
	 */
	return !write_fault_to_shadow_pgtable;
<blue>}</blue>

static bool retry_instruction(struct x86_emulate_ctxt *ctxt,
			      gpa_t cr2_or_gpa,  int emulation_type)
{
<blue>	struct kvm_vcpu *vcpu = emul_to_vcpu(ctxt);</blue>
	unsigned long last_retry_eip, last_retry_addr, gpa = cr2_or_gpa;

	last_retry_eip = vcpu-&gt;arch.last_retry_eip;
	last_retry_addr = vcpu-&gt;arch.last_retry_addr;

	/*
	 * If the emulation is caused by #PF and it is non-page_table
	 * writing instruction, it means the VM-EXIT is caused by shadow
	 * page protected, we can zap the shadow page and retry this
	 * instruction directly.
	 *
	 * Note: if the guest uses a non-page-table modifying instruction
	 * on the PDE that points to the instruction, then we will unmap
	 * the instruction and go to an infinite loop. So, we cache the
	 * last retried eip and the last fault address, if we meet the eip
	 * and the address again, we can break out of the potential infinite
	 * loop.
	 */
	vcpu-&gt;arch.last_retry_eip = vcpu-&gt;arch.last_retry_addr = 0;

	if (!(emulation_type &amp; EMULTYPE_ALLOW_RETRY_PF))
		return false;

<blue>	if (WARN_ON_ONCE(is_guest_mode(vcpu)) ||</blue>
<blue>	    WARN_ON_ONCE(!(emulation_type & EMULTYPE_PF)))</blue>
		return false;

<blue>	if (x86_page_table_writing_insn(ctxt))</blue>
		return false;

<blue>	if (ctxt->eip == last_retry_eip && last_retry_addr == cr2_or_gpa)</blue>
		return false;

<blue>	vcpu->arch.last_retry_eip = ctxt->eip;</blue>
	vcpu-&gt;arch.last_retry_addr = cr2_or_gpa;

	if (!vcpu-&gt;arch.mmu-&gt;root_role.direct)
<yellow>		gpa = kvm_mmu_gva_to_gpa_write(vcpu, cr2_or_gpa, NULL);</yellow>

<blue>	kvm_mmu_unprotect_page(vcpu->kvm, gpa_to_gfn(gpa));</blue>

	return true;
}

static int complete_emulated_mmio(struct kvm_vcpu *vcpu);
static int complete_emulated_pio(struct kvm_vcpu *vcpu);

static void kvm_smm_changed(struct kvm_vcpu *vcpu, bool entering_smm)
{
<blue>	trace_kvm_smm_transition(vcpu->vcpu_id, vcpu->arch.smbase, entering_smm);</blue>

	if (entering_smm) {
<blue>		vcpu->arch.hflags |= HF_SMM_MASK;</blue>
	} else {
<yellow>		vcpu->arch.hflags &= ~(HF_SMM_MASK | HF_SMM_INSIDE_NMI_MASK);</yellow>

		/* Process a latched INIT or SMI, if any.  */
		kvm_make_request(KVM_REQ_EVENT, vcpu);

		/*
		 * Even if KVM_SET_SREGS2 loaded PDPTRs out of band,
		 * on SMM exit we still need to reload them from
		 * guest memory
		 */
		vcpu-&gt;arch.pdptrs_from_userspace = false;
	}

<blue>	kvm_mmu_reset_context(vcpu);</blue>
}

static int kvm_vcpu_check_hw_bp(unsigned long addr, u32 type, u32 dr7,
				unsigned long *db)
{
	u32 dr6 = 0;
	int i;
	u32 enable, rwlen;

	enable = dr7;
	rwlen = dr7 &gt;&gt; 16;
<blue>	for (i = 0; i < 4; i++, enable >>= 2, rwlen >>= 4)</blue>
<blue>		if ((enable & 3) && (rwlen & 15) == type && db[i] == addr)</blue>
<yellow>			dr6 |= (1 << i);</yellow>
	return dr6;
}

<yellow>static int kvm_vcpu_do_singlestep(struct kvm_vcpu *vcpu)</yellow>
{
<yellow>	struct kvm_run *kvm_run = vcpu->run;</yellow>

	if (vcpu-&gt;guest_debug &amp; KVM_GUESTDBG_SINGLESTEP) {
<yellow>		kvm_run->debug.arch.dr6 = DR6_BS | DR6_ACTIVE_LOW;</yellow>
		kvm_run-&gt;debug.arch.pc = kvm_get_linear_rip(vcpu);
		kvm_run-&gt;debug.arch.exception = DB_VECTOR;
		kvm_run-&gt;exit_reason = KVM_EXIT_DEBUG;
		return 0;
	}
<yellow>	kvm_queue_exception_p(vcpu, DB_VECTOR, DR6_BS);</yellow>
	return 1;
<yellow>}</yellow>

int kvm_skip_emulated_instruction(struct kvm_vcpu *vcpu)
{
<blue>	unsigned long rflags = static_call(kvm_x86_get_rflags)(vcpu);</blue>
	int r;

	r = static_call(kvm_x86_skip_emulated_instruction)(vcpu);
	if (unlikely(!r))
		return 0;

	kvm_pmu_trigger_event(vcpu, PERF_COUNT_HW_INSTRUCTIONS);

	/*
	 * rflags is the old, &quot;raw&quot; value of the flags.  The new value has
	 * not been saved yet.
	 *
	 * This is correct even for TF set by the guest, because &quot;the
	 * processor will not generate this exception after the instruction
	 * that sets the TF flag&quot;.
	 */
<blue>	if (unlikely(rflags & X86_EFLAGS_TF))</blue>
<yellow>		r = kvm_vcpu_do_singlestep(vcpu);</yellow>
	return r;
<blue>}</blue>
EXPORT_SYMBOL_GPL(kvm_skip_emulated_instruction);

static bool kvm_is_code_breakpoint_inhibited(struct kvm_vcpu *vcpu)
{
	u32 shadow;

<blue>	if (kvm_get_rflags(vcpu) & X86_EFLAGS_RF)</blue>
		return true;

	/*
	 * Intel CPUs inhibit code #DBs when MOV/POP SS blocking is active,
	 * but AMD CPUs do not.  MOV/POP SS blocking is rare, check that first
	 * to avoid the relatively expensive CPUID lookup.
	 */
<blue>	shadow = static_call(kvm_x86_get_interrupt_shadow)(vcpu);</blue>
	return (shadow &amp; KVM_X86_SHADOW_INT_MOV_SS) &amp;&amp;
<yellow>	       guest_cpuid_is_intel(vcpu);</yellow>
}

static bool kvm_vcpu_check_code_breakpoint(struct kvm_vcpu *vcpu,
					   int emulation_type, int *r)
{
<yellow>	WARN_ON_ONCE(emulation_type & EMULTYPE_NO_DECODE);</yellow>

	/*
	 * Do not check for code breakpoints if hardware has already done the
	 * checks, as inferred from the emulation type.  On NO_DECODE and SKIP,
	 * the instruction has passed all exception checks, and all intercepted
	 * exceptions that trigger emulation have lower priority than code
	 * breakpoints, i.e. the fact that the intercepted exception occurred
	 * means any code breakpoints have already been serviced.
	 *
	 * Note, KVM needs to check for code #DBs on EMULTYPE_TRAP_UD_FORCED as
	 * hardware has checked the RIP of the magic prefix, but not the RIP of
	 * the instruction being emulated.  The intent of forced emulation is
	 * to behave as if KVM intercepted the instruction without an exception
	 * and without a prefix.
	 */
<blue>	if (emulation_type & (EMULTYPE_NO_DECODE | EMULTYPE_SKIP |</blue>
			      EMULTYPE_TRAP_UD | EMULTYPE_VMWARE_GP | EMULTYPE_PF))
		return false;

<blue>	if (unlikely(vcpu->guest_debug & KVM_GUESTDBG_USE_HW_BP) &&</blue>
<yellow>	    (vcpu->arch.guest_debug_dr7 & DR7_BP_EN_MASK)) {</yellow>
<yellow>		struct kvm_run *kvm_run = vcpu->run;</yellow>
		unsigned long eip = kvm_get_linear_rip(vcpu);
<yellow>		u32 dr6 = kvm_vcpu_check_hw_bp(eip, 0,</yellow>
					   vcpu-&gt;arch.guest_debug_dr7,
					   vcpu-&gt;arch.eff_db);

<yellow>		if (dr6 != 0) {</yellow>
<yellow>			kvm_run->debug.arch.dr6 = dr6 | DR6_ACTIVE_LOW;</yellow>
			kvm_run-&gt;debug.arch.pc = eip;
			kvm_run-&gt;debug.arch.exception = DB_VECTOR;
			kvm_run-&gt;exit_reason = KVM_EXIT_DEBUG;
			*r = 0;
			return true;
		}
	}

<blue>	if (unlikely(vcpu->arch.dr7 & DR7_BP_EN_MASK) &&</blue>
<blue>	    !kvm_is_code_breakpoint_inhibited(vcpu)) {</blue>
<blue>		unsigned long eip = kvm_get_linear_rip(vcpu);</blue>
<blue>		u32 dr6 = kvm_vcpu_check_hw_bp(eip, 0,</blue>
					   vcpu-&gt;arch.dr7,
					   vcpu-&gt;arch.db);

<blue>		if (dr6 != 0) {</blue>
<yellow>			kvm_queue_exception_p(vcpu, DB_VECTOR, dr6);</yellow>
			*r = 1;
			return true;
		}
	}

	return false;
}

static bool is_vmware_backdoor_opcode(struct x86_emulate_ctxt *ctxt)
{
<yellow>	switch (ctxt->opcode_len) {</yellow>
	case 1:
<yellow>		switch (ctxt->b) {</yellow>
		case 0xe4:	/* IN */
		case 0xe5:
		case 0xec:
		case 0xed:
		case 0xe6:	/* OUT */
		case 0xe7:
		case 0xee:
		case 0xef:
		case 0x6c:	/* INS */
		case 0x6d:
		case 0x6e:	/* OUTS */
		case 0x6f:
			return true;
		}
		break;
	case 2:
<yellow>		switch (ctxt->b) {</yellow>
		case 0x33:	/* RDPMC */
			return true;
		}
		break;
	}

	return false;
}

/*
 * Decode an instruction for emulation.  The caller is responsible for handling
 * code breakpoints.  Note, manually detecting code breakpoints is unnecessary
 * (and wrong) when emulating on an intercepted fault-like exception[*], as
 * code breakpoints have higher priority and thus have already been done by
 * hardware.
 *
 * [*] Except #MC, which is higher priority, but KVM should never emulate in
 *     response to a machine check.
 */
int x86_decode_emulated_instruction(struct kvm_vcpu *vcpu, int emulation_type,
				    void *insn, int insn_len)
{
<blue>	struct x86_emulate_ctxt *ctxt = vcpu->arch.emulate_ctxt;</blue>
	int r;

	init_emulate_ctxt(vcpu);

	r = x86_decode_insn(ctxt, insn, insn_len, emulation_type);

<yellow>	trace_kvm_emulate_insn_start(vcpu);</yellow>
<blue>	++vcpu->stat.insn_emulation;</blue>

	return r;
}
EXPORT_SYMBOL_GPL(x86_decode_emulated_instruction);

int x86_emulate_instruction(struct kvm_vcpu *vcpu, gpa_t cr2_or_gpa,
			    int emulation_type, void *insn, int insn_len)
{
	int r;
<blue>	struct x86_emulate_ctxt *ctxt = vcpu->arch.emulate_ctxt;</blue>
	bool writeback = true;
	bool write_fault_to_spt;

	if (unlikely(!kvm_can_emulate_insn(vcpu, emulation_type, insn, insn_len)))
		return 1;

<blue>	vcpu->arch.l1tf_flush_l1d = true;</blue>

	/*
	 * Clear write_fault_to_shadow_pgtable here to ensure it is
	 * never reused.
	 */
	write_fault_to_spt = vcpu-&gt;arch.write_fault_to_shadow_pgtable;
<blue>	vcpu->arch.write_fault_to_shadow_pgtable = false;</blue>

	if (!(emulation_type &amp; EMULTYPE_NO_DECODE)) {
<blue>		kvm_clear_exception_queue(vcpu);</blue>

		/*
		 * Return immediately if RIP hits a code breakpoint, such #DBs
		 * are fault-like and are higher priority than any faults on
		 * the code fetch itself.
		 */
<blue>		if (kvm_vcpu_check_code_breakpoint(vcpu, emulation_type, &r))</blue>
			return r;

<blue>		r = x86_decode_emulated_instruction(vcpu, emulation_type,</blue>
						    insn, insn_len);
		if (r != EMULATION_OK)  {
<blue>			if ((emulation_type & EMULTYPE_TRAP_UD) ||</blue>
			    (emulation_type &amp; EMULTYPE_TRAP_UD_FORCED)) {
<blue>				kvm_queue_exception(vcpu, UD_VECTOR);</blue>
				return 1;
			}
<blue>			if (reexecute_instruction(vcpu, cr2_or_gpa,</blue>
						  write_fault_to_spt,
						  emulation_type))
				return 1;
<blue>			if (ctxt->have_exception) {</blue>
				/*
				 * #UD should result in just EMULATION_FAILED, and trap-like
				 * exception should not be encountered during decode.
				 */
<blue>				WARN_ON_ONCE(ctxt->exception.vector == UD_VECTOR ||</blue>
					     exception_type(ctxt-&gt;exception.vector) == EXCPT_TRAP);
<blue>				inject_emulated_exception(vcpu);</blue>
				return 1;
			}
			return handle_emulation_failure(vcpu, emulation_type);
		}
	}

<blue>	if ((emulation_type & EMULTYPE_VMWARE_GP) &&</blue>
<yellow>	    !is_vmware_backdoor_opcode(ctxt)) {</yellow>
<yellow>		kvm_queue_exception_e(vcpu, GP_VECTOR, 0);</yellow>
		return 1;
	}

	/*
	 * EMULTYPE_SKIP without EMULTYPE_COMPLETE_USER_EXIT is intended for
	 * use *only* by vendor callbacks for kvm_skip_emulated_instruction().
	 * The caller is responsible for updating interruptibility state and
	 * injecting single-step #DBs.
	 */
<blue>	if (emulation_type & EMULTYPE_SKIP) {</blue>
<yellow>		if (ctxt->mode != X86EMUL_MODE_PROT64)</yellow>
<yellow>			ctxt->eip = (u32)ctxt->_eip;</yellow>
		else
			ctxt-&gt;eip = ctxt-&gt;_eip;

		if (emulation_type &amp; EMULTYPE_COMPLETE_USER_EXIT) {
			r = 1;
			goto writeback;
		}

<yellow>		kvm_rip_write(vcpu, ctxt->eip);</yellow>
		if (ctxt-&gt;eflags &amp; X86_EFLAGS_RF)
<yellow>			kvm_set_rflags(vcpu, ctxt->eflags & ~X86_EFLAGS_RF);</yellow>
		return 1;
	}

<blue>	if (retry_instruction(ctxt, cr2_or_gpa, emulation_type))</blue>
		return 1;

	/* this is needed for vmware backdoor interface to work since it
	   changes registers values  during IO operation */
<blue>	if (vcpu->arch.emulate_regs_need_sync_from_vcpu) {</blue>
<blue>		vcpu->arch.emulate_regs_need_sync_from_vcpu = false;</blue>
		emulator_invalidate_register_cache(ctxt);
	}

restart:
<blue>	if (emulation_type & EMULTYPE_PF) {</blue>
		/* Save the faulting GPA (cr2) in the address field */
<blue>		ctxt->exception.address = cr2_or_gpa;</blue>

		/* With shadow page tables, cr2 contains a GVA or nGPA. */
		if (vcpu-&gt;arch.mmu-&gt;root_role.direct) {
<blue>			ctxt->gpa_available = true;</blue>
			ctxt-&gt;gpa_val = cr2_or_gpa;
		}
	} else {
		/* Sanitize the address out of an abundance of paranoia. */
<blue>		ctxt->exception.address = 0;</blue>
	}

<blue>	r = x86_emulate_insn(ctxt);</blue>

	if (r == EMULATION_INTERCEPTED)
		return 1;

<blue>	if (r == EMULATION_FAILED) {</blue>
<blue>		if (reexecute_instruction(vcpu, cr2_or_gpa, write_fault_to_spt,</blue>
					emulation_type))
			return 1;

<blue>		return handle_emulation_failure(vcpu, emulation_type);</blue>
	}

<blue>	if (ctxt->have_exception) {</blue>
		r = 1;
<blue>		inject_emulated_exception(vcpu);</blue>
<blue>	} else if (vcpu->arch.pio.count) {</blue>
<blue>		if (!vcpu->arch.pio.in) {</blue>
			/* FIXME: return into emulator if single-stepping.  */
			vcpu-&gt;arch.pio.count = 0;
		} else {
			writeback = false;
<blue>			vcpu->arch.complete_userspace_io = complete_emulated_pio;</blue>
		}
<blue>		r = 0;</blue>
<blue>	} else if (vcpu->mmio_needed) {</blue>
<blue>		++vcpu->stat.mmio_exits;</blue>

		if (!vcpu-&gt;mmio_is_write)
			writeback = false;
		r = 0;
<blue>		vcpu->arch.complete_userspace_io = complete_emulated_mmio;</blue>
<blue>	} else if (vcpu->arch.complete_userspace_io) {</blue>
		writeback = false;
		r = 0;
<blue>	} else if (r == EMULATION_RESTART)</blue>
		goto restart;
	else
		r = 1;

writeback:
	if (writeback) {
<blue>		unsigned long rflags = static_call(kvm_x86_get_rflags)(vcpu);</blue>
<blue>		toggle_interruptibility(vcpu, ctxt->interruptibility);</blue>
<blue>		vcpu->arch.emulate_regs_need_sync_to_vcpu = false;</blue>

		/*
		 * Note, EXCPT_DB is assumed to be fault-like as the emulator
		 * only supports code breakpoints and general detect #DB, both
		 * of which are fault-like.
		 */
<blue>		if (!ctxt->have_exception ||</blue>
<blue>		    exception_type(ctxt->exception.vector) == EXCPT_TRAP) {</blue>
<blue>			kvm_pmu_trigger_event(vcpu, PERF_COUNT_HW_INSTRUCTIONS);</blue>
<blue>			if (ctxt->is_branch)</blue>
<blue>				kvm_pmu_trigger_event(vcpu, PERF_COUNT_HW_BRANCH_INSTRUCTIONS);</blue>
<blue>			kvm_rip_write(vcpu, ctxt->eip);</blue>
<blue>			if (r && (ctxt->tf || (vcpu->guest_debug & KVM_GUESTDBG_SINGLESTEP)))</blue>
<yellow>				r = kvm_vcpu_do_singlestep(vcpu);</yellow>
			static_call_cond(kvm_x86_update_emulated_instruction)(vcpu);
<blue>			__kvm_set_rflags(vcpu, ctxt->eflags);</blue>
		}

		/*
		 * For STI, interrupts are shadowed; so KVM_REQ_EVENT will
		 * do nothing, and it will be requested again as soon as
		 * the shadow expires.  But we still need to check here,
		 * because POPF has no interrupt shadow.
		 */
<blue>		if (unlikely((ctxt->eflags & ~rflags) & X86_EFLAGS_IF))</blue>
<yellow>			kvm_make_request(KVM_REQ_EVENT, vcpu);</yellow>
	} else
<blue>		vcpu->arch.emulate_regs_need_sync_to_vcpu = true;</blue>

	return r;
<blue>}</blue>

int kvm_emulate_instruction(struct kvm_vcpu *vcpu, int emulation_type)
{
<blue>	return x86_emulate_instruction(vcpu, 0, emulation_type, NULL, 0);</blue>
}
EXPORT_SYMBOL_GPL(kvm_emulate_instruction);

int kvm_emulate_instruction_from_buffer(struct kvm_vcpu *vcpu,
					void *insn, int insn_len)
{
<yellow>	return x86_emulate_instruction(vcpu, 0, 0, insn, insn_len);</yellow>
}
EXPORT_SYMBOL_GPL(kvm_emulate_instruction_from_buffer);

static int complete_fast_pio_out_port_0x7e(struct kvm_vcpu *vcpu)
{
<blue>	vcpu->arch.pio.count = 0;</blue>
	return 1;
}

static int complete_fast_pio_out(struct kvm_vcpu *vcpu)
{
<blue>	vcpu->arch.pio.count = 0;</blue>

	if (unlikely(!kvm_is_linear_rip(vcpu, vcpu-&gt;arch.pio.linear_rip)))
<blue>		return 1;</blue>

<blue>	return kvm_skip_emulated_instruction(vcpu);</blue>
<blue>}</blue>

static int kvm_fast_pio_out(struct kvm_vcpu *vcpu, int size,
			    unsigned short port)
{
<blue>	unsigned long val = kvm_rax_read(vcpu);</blue>
<blue>	int ret = emulator_pio_out(vcpu, size, port, &val, 1);</blue>

	if (ret)
		return ret;

	/*
	 * Workaround userspace that relies on old KVM behavior of %rip being
	 * incremented prior to exiting to userspace to handle &quot;OUT 0x7e&quot;.
	 */
<blue>	if (port == 0x7e &&</blue>
<blue>	    kvm_check_has_quirk(vcpu->kvm, KVM_X86_QUIRK_OUT_7E_INC_RIP)) {</blue>
<blue>		vcpu->arch.complete_userspace_io =</blue>
			complete_fast_pio_out_port_0x7e;
		kvm_skip_emulated_instruction(vcpu);
	} else {
<blue>		vcpu->arch.pio.linear_rip = kvm_get_linear_rip(vcpu);</blue>
		vcpu-&gt;arch.complete_userspace_io = complete_fast_pio_out;
	}
	return 0;
}

static int complete_fast_pio_in(struct kvm_vcpu *vcpu)
<blue>{</blue>
	unsigned long val;

	/* We should only ever be called with arch.pio.count equal to 1 */
<blue>	BUG_ON(vcpu->arch.pio.count != 1);</blue>

<blue>	if (unlikely(!kvm_is_linear_rip(vcpu, vcpu->arch.pio.linear_rip))) {</blue>
<blue>		vcpu->arch.pio.count = 0;</blue>
		return 1;
	}

	/* For size less than 4 we merge, else we zero extend */
<blue>	val = (vcpu->arch.pio.size < 4) ? kvm_rax_read(vcpu) : 0;</blue>

<blue>	complete_emulator_pio_in(vcpu, &val);</blue>
	kvm_rax_write(vcpu, val);

<blue>	return kvm_skip_emulated_instruction(vcpu);</blue>
}

static int kvm_fast_pio_in(struct kvm_vcpu *vcpu, int size,
			   unsigned short port)
{
	unsigned long val;
	int ret;

	/* For size less than 4 we merge, else we zero extend */
<blue>	val = (size < 4) ? kvm_rax_read(vcpu) : 0;</blue>

<blue>	ret = emulator_pio_in(vcpu, size, port, &val, 1);</blue>
	if (ret) {
<blue>		kvm_rax_write(vcpu, val);</blue>
		return ret;
	}

<blue>	vcpu->arch.pio.linear_rip = kvm_get_linear_rip(vcpu);</blue>
	vcpu-&gt;arch.complete_userspace_io = complete_fast_pio_in;

	return 0;
}

<blue>int kvm_fast_pio(struct kvm_vcpu *vcpu, int size, unsigned short port, int in)</blue>
<blue>{</blue>
	int ret;

	if (in)
<blue>		ret = kvm_fast_pio_in(vcpu, size, port);</blue>
	else
<blue>		ret = kvm_fast_pio_out(vcpu, size, port);</blue>
<blue>	return ret && kvm_skip_emulated_instruction(vcpu);</blue>
}
EXPORT_SYMBOL_GPL(kvm_fast_pio);

static int kvmclock_cpu_down_prep(unsigned int cpu)
{
<yellow>	__this_cpu_write(cpu_tsc_khz, 0);</yellow>
	return 0;
}

static void tsc_khz_changed(void *data)
{
	struct cpufreq_freqs *freq = data;
	unsigned long khz = 0;

<yellow>	if (data)</yellow>
<yellow>		khz = freq->new;</yellow>
<yellow>	else if (!boot_cpu_has(X86_FEATURE_CONSTANT_TSC))</yellow>
<yellow>		khz = cpufreq_quick_get(raw_smp_processor_id());</yellow>
<yellow>	if (!khz)</yellow>
<yellow>		khz = tsc_khz;</yellow>
<yellow>	__this_cpu_write(cpu_tsc_khz, khz);</yellow>
}

#ifdef CONFIG_X86_64
static void kvm_hyperv_tsc_notifier(void)
{
	struct kvm *kvm;
	int cpu;

<yellow>	mutex_lock(&kvm_lock);</yellow>
	list_for_each_entry(kvm, &amp;vm_list, vm_list)
<yellow>		kvm_make_mclock_inprogress_request(kvm);</yellow>

	/* no guest entries from this point */
<yellow>	hyperv_stop_tsc_emulation();</yellow>

	/* TSC frequency always matches when on Hyper-V */
<yellow>	for_each_present_cpu(cpu)</yellow>
<yellow>		per_cpu(cpu_tsc_khz, cpu) = tsc_khz;</yellow>
<yellow>	kvm_caps.max_guest_tsc_khz = tsc_khz;</yellow>

	list_for_each_entry(kvm, &amp;vm_list, vm_list) {
<yellow>		__kvm_start_pvclock_update(kvm);</yellow>
		pvclock_update_vm_gtod_copy(kvm);
		kvm_end_pvclock_update(kvm);
	}

<yellow>	mutex_unlock(&kvm_lock);</yellow>
}
#endif

static void __kvmclock_cpufreq_notifier(struct cpufreq_freqs *freq, int cpu)
{
	struct kvm *kvm;
	struct kvm_vcpu *vcpu;
	int send_ipi = 0;
	unsigned long i;

	/*
	 * We allow guests to temporarily run on slowing clocks,
	 * provided we notify them after, or to run on accelerating
	 * clocks, provided we notify them before.  Thus time never
	 * goes backwards.
	 *
	 * However, we have a problem.  We can&#x27;t atomically update
	 * the frequency of a given CPU from this function; it is
	 * merely a notifier, which can be called from any CPU.
	 * Changing the TSC frequency at arbitrary points in time
	 * requires a recomputation of local variables related to
	 * the TSC for each VCPU.  We must flag these local variables
	 * to be updated and be sure the update takes place with the
	 * new frequency before any guests proceed.
	 *
	 * Unfortunately, the combination of hotplug CPU and frequency
	 * change creates an intractable locking scenario; the order
	 * of when these callouts happen is undefined with respect to
	 * CPU hotplug, and they can race with each other.  As such,
	 * merely setting per_cpu(cpu_tsc_khz) = X during a hotadd is
	 * undefined; you can actually have a CPU frequency change take
	 * place in between the computation of X and the setting of the
	 * variable.  To protect against this problem, all updates of
	 * the per_cpu tsc_khz variable are done in an interrupt
	 * protected IPI, and all callers wishing to update the value
	 * must wait for a synchronous IPI to complete (which is trivial
	 * if the caller is on the CPU already).  This establishes the
	 * necessary total order on variable updates.
	 *
	 * Note that because a guest time update may take place
	 * anytime after the setting of the VCPU&#x27;s request bit, the
	 * correct TSC value must be set before the request.  However,
	 * to ensure the update actually makes it to any guest which
	 * starts running in hardware virtualization between the set
	 * and the acquisition of the spinlock, we must also ping the
	 * CPU after setting the request bit.
	 *
	 */

<yellow>	smp_call_function_single(cpu, tsc_khz_changed, freq, 1);</yellow>

	mutex_lock(&amp;kvm_lock);
<yellow>	list_for_each_entry(kvm, &vm_list, vm_list) {</yellow>
<yellow>		kvm_for_each_vcpu(i, vcpu, kvm) {</yellow>
<yellow>			if (vcpu->cpu != cpu)</yellow>
				continue;
<yellow>			kvm_make_request(KVM_REQ_CLOCK_UPDATE, vcpu);</yellow>
			if (vcpu-&gt;cpu != raw_smp_processor_id())
				send_ipi = 1;
		}
	}
<yellow>	mutex_unlock(&kvm_lock);</yellow>

<yellow>	if (freq->old < freq->new && send_ipi) {</yellow>
		/*
		 * We upscale the frequency.  Must make the guest
		 * doesn&#x27;t see old kvmclock values while running with
		 * the new frequency, otherwise we risk the guest sees
		 * time go backwards.
		 *
		 * In case we update the frequency for another cpu
		 * (which might be in guest context) send an interrupt
		 * to kick the cpu out of guest context.  Next time
		 * guest context is entered kvmclock will be updated,
		 * so the guest will not see stale values.
		 */
<yellow>		smp_call_function_single(cpu, tsc_khz_changed, freq, 1);</yellow>
	}
}

static int kvmclock_cpufreq_notifier(struct notifier_block *nb, unsigned long val,
				     void *data)
<yellow>{</yellow>
	struct cpufreq_freqs *freq = data;
	int cpu;

<yellow>	if (val == CPUFREQ_PRECHANGE && freq->old > freq->new)</yellow>
		return 0;
<yellow>	if (val == CPUFREQ_POSTCHANGE && freq->old < freq->new)</yellow>
		return 0;

<yellow>	for_each_cpu(cpu, freq->policy->cpus)</yellow>
<yellow>		__kvmclock_cpufreq_notifier(freq, cpu);</yellow>

	return 0;
}

static struct notifier_block kvmclock_cpufreq_notifier_block = {
	.notifier_call  = kvmclock_cpufreq_notifier
};

static int kvmclock_cpu_online(unsigned int cpu)
{
<yellow>	tsc_khz_changed(NULL);</yellow>
	return 0;
}

static void kvm_timer_init(void)
{
<yellow>	if (!boot_cpu_has(X86_FEATURE_CONSTANT_TSC)) {</yellow>
<yellow>		max_tsc_khz = tsc_khz;</yellow>

		if (IS_ENABLED(CONFIG_CPU_FREQ)) {
			struct cpufreq_policy *policy;
			int cpu;

			cpu = get_cpu();
			policy = cpufreq_cpu_get(cpu);
			if (policy) {
<yellow>				if (policy->cpuinfo.max_freq)</yellow>
<yellow>					max_tsc_khz = policy->cpuinfo.max_freq;</yellow>
<yellow>				cpufreq_cpu_put(policy);</yellow>
			}
<yellow>			put_cpu();</yellow>
		}
<yellow>		cpufreq_register_notifier(&kvmclock_cpufreq_notifier_block,</yellow>
					  CPUFREQ_TRANSITION_NOTIFIER);
	}

<yellow>	cpuhp_setup_state(CPUHP_AP_X86_KVM_CLK_ONLINE, "x86/kvm/clk:online",</yellow>
			  kvmclock_cpu_online, kvmclock_cpu_down_prep);
}

#ifdef CONFIG_X86_64
static void pvclock_gtod_update_fn(struct work_struct *work)
{
	struct kvm *kvm;
	struct kvm_vcpu *vcpu;
	unsigned long i;

<yellow>	mutex_lock(&kvm_lock);</yellow>
<yellow>	list_for_each_entry(kvm, &vm_list, vm_list)</yellow>
<yellow>		kvm_for_each_vcpu(i, vcpu, kvm)</yellow>
<yellow>			kvm_make_request(KVM_REQ_MASTERCLOCK_UPDATE, vcpu);</yellow>
<yellow>	atomic_set(&kvm_guest_has_master_clock, 0);</yellow>
	mutex_unlock(&amp;kvm_lock);
}

static DECLARE_WORK(pvclock_gtod_work, pvclock_gtod_update_fn);

/*
 * Indirection to move queue_work() out of the tk_core.seq write held
 * region to prevent possible deadlocks against time accessors which
 * are invoked with work related locks held.
 */
static void pvclock_irq_work_fn(struct irq_work *w)
{
<yellow>	queue_work(system_long_wq, &pvclock_gtod_work);</yellow>
}

static DEFINE_IRQ_WORK(pvclock_irq_work, pvclock_irq_work_fn);

/*
 * Notification about pvclock gtod data update.
 */
<yellow>static int pvclock_gtod_notify(struct notifier_block *nb, unsigned long unused,</yellow>
			       void *priv)
{
	struct pvclock_gtod_data *gtod = &amp;pvclock_gtod_data;
	struct timekeeper *tk = priv;

<yellow>	update_pvclock_gtod(tk);</yellow>

	/*
	 * Disable master clock if host does not trust, or does not use,
	 * TSC based clocksource. Delegate queue_work() to irq_work as
	 * this is invoked with tk_core.seq write held.
	 */
	if (!gtod_is_based_on_tsc(gtod-&gt;clock.vclock_mode) &amp;&amp;
<yellow>	    atomic_read(&kvm_guest_has_master_clock) != 0)</yellow>
<yellow>		irq_work_queue(&pvclock_irq_work);</yellow>
	return 0;
<yellow>}</yellow>

static struct notifier_block pvclock_gtod_notifier = {
	.notifier_call = pvclock_gtod_notify,
};
#endif

int kvm_arch_init(void *opaque)
<yellow>{</yellow>
	struct kvm_x86_init_ops *ops = opaque;
	u64 host_pat;
	int r;

<yellow>	if (kvm_x86_ops.hardware_enable) {</yellow>
		pr_err(&quot;kvm: already loaded vendor module &#x27;%s&#x27;\n&quot;, kvm_x86_ops.name);
		return -EEXIST;
	}

<yellow>	if (!ops->cpu_has_kvm_support()) {</yellow>
<yellow>		pr_err_ratelimited("kvm: no hardware support for '%s'\n",</yellow>
				   ops-&gt;runtime_ops-&gt;name);
		return -EOPNOTSUPP;
	}
<yellow>	if (ops->disabled_by_bios()) {</yellow>
<yellow>		pr_err_ratelimited("kvm: support for '%s' disabled by bios\n",</yellow>
				   ops-&gt;runtime_ops-&gt;name);
		return -EOPNOTSUPP;
	}

	/*
	 * KVM explicitly assumes that the guest has an FPU and
	 * FXSAVE/FXRSTOR. For example, the KVM_GET_FPU explicitly casts the
	 * vCPU&#x27;s FPU state as a fxregs_state struct.
	 */
	if (!boot_cpu_has(X86_FEATURE_FPU) || !boot_cpu_has(X86_FEATURE_FXSR)) {
		printk(KERN_ERR &quot;kvm: inadequate fpu\n&quot;);
		return -EOPNOTSUPP;
	}

	if (IS_ENABLED(CONFIG_PREEMPT_RT) &amp;&amp; !boot_cpu_has(X86_FEATURE_CONSTANT_TSC)) {
		pr_err(&quot;RT requires X86_FEATURE_CONSTANT_TSC\n&quot;);
		return -EOPNOTSUPP;
	}

	/*
	 * KVM assumes that PAT entry &#x27;0&#x27; encodes WB memtype and simply zeroes
	 * the PAT bits in SPTEs.  Bail if PAT[0] is programmed to something
	 * other than WB.  Note, EPT doesn&#x27;t utilize the PAT, but don&#x27;t bother
	 * with an exception.  PAT[0] is set to WB on RESET and also by the
	 * kernel, i.e. failure indicates a kernel bug or broken firmware.
	 */
<yellow>	if (rdmsrl_safe(MSR_IA32_CR_PAT, &host_pat) ||</yellow>
<yellow>	    (host_pat & GENMASK(2, 0)) != 6) {</yellow>
		pr_err(&quot;kvm: host PAT[0] is not WB\n&quot;);
		return -EIO;
	}

<yellow>	x86_emulator_cache = kvm_alloc_emulator_cache();</yellow>
	if (!x86_emulator_cache) {
		pr_err(&quot;kvm: failed to allocate cache for x86 emulator\n&quot;);
		return -ENOMEM;
	}

<yellow>	user_return_msrs = alloc_percpu(struct kvm_user_return_msrs);</yellow>
	if (!user_return_msrs) {
		printk(KERN_ERR &quot;kvm: failed to allocate percpu kvm_user_return_msrs\n&quot;);
		r = -ENOMEM;
		goto out_free_x86_emulator_cache;
	}
<yellow>	kvm_nr_uret_msrs = 0;</yellow>

	r = kvm_mmu_vendor_module_init();
	if (r)
		goto out_free_percpu;

<yellow>	kvm_timer_init();</yellow>

	if (boot_cpu_has(X86_FEATURE_XSAVE)) {
<yellow>		host_xcr0 = xgetbv(XCR_XFEATURE_ENABLED_MASK);</yellow>
		kvm_caps.supported_xcr0 = host_xcr0 &amp; KVM_SUPPORTED_XCR0;
	}

<yellow>	if (pi_inject_timer == -1)</yellow>
<yellow>		pi_inject_timer = housekeeping_enabled(HK_TYPE_TIMER);</yellow>
#ifdef CONFIG_X86_64
<yellow>	pvclock_gtod_register_notifier(&pvclock_gtod_notifier);</yellow>

	if (hypervisor_is_type(X86_HYPER_MS_HYPERV))
<yellow>		set_hv_tscchange_cb(kvm_hyperv_tsc_notifier);</yellow>
#endif

	return 0;

out_free_percpu:
<yellow>	free_percpu(user_return_msrs);</yellow>
out_free_x86_emulator_cache:
<yellow>	kmem_cache_destroy(x86_emulator_cache);</yellow>
	return r;
}

void kvm_arch_exit(void)
{
#ifdef CONFIG_X86_64
<yellow>	if (hypervisor_is_type(X86_HYPER_MS_HYPERV))</yellow>
<yellow>		clear_hv_tscchange_cb();</yellow>
#endif
<yellow>	kvm_lapic_exit();</yellow>

	if (!boot_cpu_has(X86_FEATURE_CONSTANT_TSC))
<yellow>		cpufreq_unregister_notifier(&kvmclock_cpufreq_notifier_block,</yellow>
					    CPUFREQ_TRANSITION_NOTIFIER);
<yellow>	cpuhp_remove_state_nocalls(CPUHP_AP_X86_KVM_CLK_ONLINE);</yellow>
#ifdef CONFIG_X86_64
	pvclock_gtod_unregister_notifier(&amp;pvclock_gtod_notifier);
	irq_work_sync(&amp;pvclock_irq_work);
	cancel_work_sync(&amp;pvclock_gtod_work);
#endif
	kvm_x86_ops.hardware_enable = NULL;
	kvm_mmu_vendor_module_exit();
	free_percpu(user_return_msrs);
	kmem_cache_destroy(x86_emulator_cache);
#ifdef CONFIG_KVM_XEN
	static_key_deferred_flush(&amp;kvm_xen_enabled);
<yellow>	WARN_ON(static_branch_unlikely(&kvm_xen_enabled.key));</yellow>
#endif
<yellow>}</yellow>

static int __kvm_emulate_halt(struct kvm_vcpu *vcpu, int state, int reason)
{
	/*
	 * The vCPU has halted, e.g. executed HLT.  Update the run state if the
	 * local APIC is in-kernel, the run loop will detect the non-runnable
	 * state and halt the vCPU.  Exit to userspace if the local APIC is
	 * managed by userspace, in which case userspace is responsible for
	 * handling wake events.
	 */
<blue>	++vcpu->stat.halt_exits;</blue>
<yellow>	if (lapic_in_kernel(vcpu)) {</yellow>
<blue>		vcpu->arch.mp_state = state;</blue>
		return 1;
	} else {
<yellow>		vcpu->run->exit_reason = reason;</yellow>
		return 0;
	}
}

int kvm_emulate_halt_noskip(struct kvm_vcpu *vcpu)
{
<blue>	return __kvm_emulate_halt(vcpu, KVM_MP_STATE_HALTED, KVM_EXIT_HLT);</blue>
<blue>}</blue>
EXPORT_SYMBOL_GPL(kvm_emulate_halt_noskip);

int kvm_emulate_halt(struct kvm_vcpu *vcpu)
{
<blue>	int ret = kvm_skip_emulated_instruction(vcpu);</blue>
	/*
	 * TODO: we might be squashing a GUESTDBG_SINGLESTEP-triggered
	 * KVM_EXIT_DEBUG here.
	 */
<blue>	return kvm_emulate_halt_noskip(vcpu) && ret;</blue>
<blue>}</blue>
EXPORT_SYMBOL_GPL(kvm_emulate_halt);

int kvm_emulate_ap_reset_hold(struct kvm_vcpu *vcpu)
{
<yellow>	int ret = kvm_skip_emulated_instruction(vcpu);</yellow>

<yellow>	return __kvm_emulate_halt(vcpu, KVM_MP_STATE_AP_RESET_HOLD,</yellow>
					KVM_EXIT_AP_RESET_HOLD) &amp;&amp; ret;
<yellow>}</yellow>
EXPORT_SYMBOL_GPL(kvm_emulate_ap_reset_hold);

#ifdef CONFIG_X86_64
static int kvm_pv_clock_pairing(struct kvm_vcpu *vcpu, gpa_t paddr,
			        unsigned long clock_type)
{
	struct kvm_clock_pairing clock_pairing;
	struct timespec64 ts;
	u64 cycle;
	int ret;

<yellow>	if (clock_type != KVM_CLOCK_PAIRING_WALLCLOCK)</yellow>
		return -KVM_EOPNOTSUPP;

	/*
	 * When tsc is in permanent catchup mode guests won&#x27;t be able to use
	 * pvclock_read_retry loop to get consistent view of pvclock
	 */
<yellow>	if (vcpu->arch.tsc_always_catchup)</yellow>
		return -KVM_EOPNOTSUPP;

<yellow>	if (!kvm_get_walltime_and_clockread(&ts, &cycle))</yellow>
		return -KVM_EOPNOTSUPP;

<yellow>	clock_pairing.sec = ts.tv_sec;</yellow>
	clock_pairing.nsec = ts.tv_nsec;
<yellow>	clock_pairing.tsc = kvm_read_l1_tsc(vcpu, cycle);</yellow>
	clock_pairing.flags = 0;
<yellow>	memset(&clock_pairing.pad, 0, sizeof(clock_pairing.pad));</yellow>

	ret = 0;
	if (kvm_write_guest(vcpu-&gt;kvm, paddr, &amp;clock_pairing,
			    sizeof(struct kvm_clock_pairing)))
		ret = -KVM_EFAULT;

	return ret;
}
#endif

/*
 * kvm_pv_kick_cpu_op:  Kick a vcpu.
 *
 * @apicid - apicid of vcpu to be kicked.
 */
static void kvm_pv_kick_cpu_op(struct kvm *kvm, int apicid)
{
	/*
	 * All other fields are unused for APIC_DM_REMRD, but may be consumed by
	 * common code, e.g. for tracing. Defer initialization to the compiler.
	 */
	struct kvm_lapic_irq lapic_irq = {
		.delivery_mode = APIC_DM_REMRD,
		.dest_mode = APIC_DEST_PHYSICAL,
		.shorthand = APIC_DEST_NOSHORT,
		.dest_id = apicid,
	};

	kvm_irq_delivery_to_apic(kvm, NULL, &amp;lapic_irq, NULL);
}

bool kvm_apicv_activated(struct kvm *kvm)
{
<blue>	return (READ_ONCE(kvm->arch.apicv_inhibit_reasons) == 0);</blue>
}
EXPORT_SYMBOL_GPL(kvm_apicv_activated);

bool kvm_vcpu_apicv_activated(struct kvm_vcpu *vcpu)
{
<blue>	ulong vm_reasons = READ_ONCE(vcpu->kvm->arch.apicv_inhibit_reasons);</blue>
	ulong vcpu_reasons = static_call(kvm_x86_vcpu_get_apicv_inhibit_reasons)(vcpu);

	return (vm_reasons | vcpu_reasons) == 0;
}
EXPORT_SYMBOL_GPL(kvm_vcpu_apicv_activated);

static void set_or_clear_apicv_inhibit(unsigned long *inhibits,
				       enum kvm_apicv_inhibit reason, bool set)
{
	if (set)
<blue>		__set_bit(reason, inhibits);</blue>
	else
<blue>		__clear_bit(reason, inhibits);</blue>

<blue>	trace_kvm_apicv_inhibit_changed(reason, set, *inhibits);</blue>
<blue>}</blue>

static void kvm_apicv_init(struct kvm *kvm)
{
	unsigned long *inhibits = &amp;kvm-&gt;arch.apicv_inhibit_reasons;

	init_rwsem(&amp;kvm-&gt;arch.apicv_update_lock);

	set_or_clear_apicv_inhibit(inhibits, APICV_INHIBIT_REASON_ABSENT, true);

<blue>	if (!enable_apicv)</blue>
<yellow>		set_or_clear_apicv_inhibit(inhibits,</yellow>
					   APICV_INHIBIT_REASON_DISABLE, true);
}

<yellow>static void kvm_sched_yield(struct kvm_vcpu *vcpu, unsigned long dest_id)</yellow>
{
	struct kvm_vcpu *target = NULL;
	struct kvm_apic_map *map;

<yellow>	vcpu->stat.directed_yield_attempted++;</yellow>

	if (single_task_running())
		goto no_yield;

<yellow>	rcu_read_lock();</yellow>
	map = rcu_dereference(vcpu-&gt;kvm-&gt;arch.apic_map);

<yellow>	if (likely(map) && dest_id <= map->max_apic_id && map->phys_map[dest_id])</yellow>
<yellow>		target = map->phys_map[dest_id]->vcpu;</yellow>

<yellow>	rcu_read_unlock();</yellow>

<yellow>	if (!target || !READ_ONCE(target->ready))</yellow>
		goto no_yield;

	/* Ignore requests to yield to self */
<yellow>	if (vcpu == target)</yellow>
		goto no_yield;

<yellow>	if (kvm_vcpu_yield_to(target) <= 0)</yellow>
		goto no_yield;

<yellow>	vcpu->stat.directed_yield_successful++;</yellow>

no_yield:
	return;
<yellow>}</yellow>

static int complete_hypercall_exit(struct kvm_vcpu *vcpu)
<yellow>{</yellow>
<yellow>	u64 ret = vcpu->run->hypercall.ret;</yellow>

<yellow>	if (!is_64_bit_mode(vcpu))</yellow>
<yellow>		ret = (u32)ret;</yellow>
<yellow>	kvm_rax_write(vcpu, ret);</yellow>
	++vcpu-&gt;stat.hypercalls;
<yellow>	return kvm_skip_emulated_instruction(vcpu);</yellow>
}

<yellow>int kvm_emulate_hypercall(struct kvm_vcpu *vcpu)</yellow>
{
	unsigned long nr, a0, a1, a2, a3, ret;
	int op_64_bit;

<yellow>	if (kvm_xen_hypercall_enabled(vcpu->kvm))</yellow>
<yellow>		return kvm_xen_hypercall(vcpu);</yellow>

<yellow>	if (kvm_hv_hypercall_enabled(vcpu))</yellow>
<yellow>		return kvm_hv_hypercall(vcpu);</yellow>

<yellow>	nr = kvm_rax_read(vcpu);</yellow>
	a0 = kvm_rbx_read(vcpu);
	a1 = kvm_rcx_read(vcpu);
	a2 = kvm_rdx_read(vcpu);
	a3 = kvm_rsi_read(vcpu);

<yellow>	trace_kvm_hypercall(nr, a0, a1, a2, a3);</yellow>

<yellow>	op_64_bit = is_64_bit_hypercall(vcpu);</yellow>
	if (!op_64_bit) {
		nr &amp;= 0xFFFFFFFF;
<yellow>		a0 &= 0xFFFFFFFF;</yellow>
		a1 &amp;= 0xFFFFFFFF;
		a2 &amp;= 0xFFFFFFFF;
<yellow>		a3 &= 0xFFFFFFFF;</yellow>
	}

<yellow>	if (static_call(kvm_x86_get_cpl)(vcpu) != 0) {</yellow>
		ret = -KVM_EPERM;
		goto out;
	}

	ret = -KVM_ENOSYS;

<yellow>	switch (nr) {</yellow>
	case KVM_HC_VAPIC_POLL_IRQ:
		ret = 0;
		break;
	case KVM_HC_KICK_CPU:
<yellow>		if (!guest_pv_has(vcpu, KVM_FEATURE_PV_UNHALT))</yellow>
			break;

<yellow>		kvm_pv_kick_cpu_op(vcpu->kvm, a1);</yellow>
		kvm_sched_yield(vcpu, a1);
		ret = 0;
		break;
#ifdef CONFIG_X86_64
	case KVM_HC_CLOCK_PAIRING:
<yellow>		ret = kvm_pv_clock_pairing(vcpu, a0, a1);</yellow>
<yellow>		break;</yellow>
#endif
	case KVM_HC_SEND_IPI:
<yellow>		if (!guest_pv_has(vcpu, KVM_FEATURE_PV_SEND_IPI))</yellow>
			break;

<yellow>		ret = kvm_pv_send_ipi(vcpu->kvm, a0, a1, a2, a3, op_64_bit);</yellow>
		break;
	case KVM_HC_SCHED_YIELD:
<yellow>		if (!guest_pv_has(vcpu, KVM_FEATURE_PV_SCHED_YIELD))</yellow>
			break;

<yellow>		kvm_sched_yield(vcpu, a0);</yellow>
		ret = 0;
		break;
	case KVM_HC_MAP_GPA_RANGE: {
		u64 gpa = a0, npages = a1, attrs = a2;

		ret = -KVM_ENOSYS;
<yellow>		if (!(vcpu->kvm->arch.hypercall_exit_enabled & (1 << KVM_HC_MAP_GPA_RANGE)))</yellow>
			break;

<yellow>		if (!PAGE_ALIGNED(gpa) || !npages ||</yellow>
<yellow>		    gpa_to_gfn(gpa) + npages <= gpa_to_gfn(gpa)) {</yellow>
			ret = -KVM_EINVAL;
			break;
		}

<yellow>		vcpu->run->exit_reason        = KVM_EXIT_HYPERCALL;</yellow>
		vcpu-&gt;run-&gt;hypercall.nr       = KVM_HC_MAP_GPA_RANGE;
		vcpu-&gt;run-&gt;hypercall.args[0]  = gpa;
		vcpu-&gt;run-&gt;hypercall.args[1]  = npages;
		vcpu-&gt;run-&gt;hypercall.args[2]  = attrs;
		vcpu-&gt;run-&gt;hypercall.longmode = op_64_bit;
		vcpu-&gt;arch.complete_userspace_io = complete_hypercall_exit;
		return 0;
	}
	default:
		ret = -KVM_ENOSYS;
		break;
	}
out:
<yellow>	if (!op_64_bit)</yellow>
		ret = (u32)ret;
<yellow>	kvm_rax_write(vcpu, ret);</yellow>

	++vcpu-&gt;stat.hypercalls;
<yellow>	return kvm_skip_emulated_instruction(vcpu);</yellow>
<yellow>}</yellow>
EXPORT_SYMBOL_GPL(kvm_emulate_hypercall);

static int emulator_fix_hypercall(struct x86_emulate_ctxt *ctxt)
<yellow>{</yellow>
<yellow>	struct kvm_vcpu *vcpu = emul_to_vcpu(ctxt);</yellow>
	char instruction[3];
<yellow>	unsigned long rip = kvm_rip_read(vcpu);</yellow>

	/*
	 * If the quirk is disabled, synthesize a #UD and let the guest pick up
	 * the pieces.
	 */
	if (!kvm_check_has_quirk(vcpu-&gt;kvm, KVM_X86_QUIRK_FIX_HYPERCALL_INSN)) {
<yellow>		ctxt->exception.error_code_valid = false;</yellow>
		ctxt-&gt;exception.vector = UD_VECTOR;
		ctxt-&gt;have_exception = true;
		return X86EMUL_PROPAGATE_FAULT;
	}

<yellow>	static_call(kvm_x86_patch_hypercall)(vcpu, instruction);</yellow>

	return emulator_write_emulated(ctxt, rip, instruction, 3,
		&amp;ctxt-&gt;exception);
}

<yellow>static int dm_request_for_irq_injection(struct kvm_vcpu *vcpu)</yellow>
{
<blue>	return vcpu->run->request_interrupt_window &&</blue>
<yellow>		likely(!pic_in_kernel(vcpu->kvm));</yellow>
}

/* Called within kvm-&gt;srcu read side.  */
static void post_kvm_run_save(struct kvm_vcpu *vcpu)
{
	struct kvm_run *kvm_run = vcpu-&gt;run;

<blue>	kvm_run->if_flag = static_call(kvm_x86_get_if_flag)(vcpu);</blue>
<blue>	kvm_run->cr8 = kvm_get_cr8(vcpu);</blue>
	kvm_run-&gt;apic_base = kvm_get_apic_base(vcpu);

<blue>	kvm_run->ready_for_interrupt_injection =</blue>
		pic_in_kernel(vcpu-&gt;kvm) ||
<yellow>		kvm_vcpu_ready_for_interrupt_injection(vcpu);</yellow>

	if (is_smm(vcpu))
<blue>		kvm_run->flags |= KVM_RUN_X86_SMM;</blue>
}

<yellow>static void update_cr8_intercept(struct kvm_vcpu *vcpu)</yellow>
{
	int max_irr, tpr;

<blue>	if (!kvm_x86_ops.update_cr8_intercept)</blue>
		return;

<blue>	if (!lapic_in_kernel(vcpu))</blue>
		return;

<blue>	if (vcpu->arch.apic->apicv_active)</blue>
		return;

<yellow>	if (!vcpu->arch.apic->vapic_addr)</yellow>
<yellow>		max_irr = kvm_lapic_find_highest_irr(vcpu);</yellow>
	else
		max_irr = -1;

	if (max_irr != -1)
<yellow>		max_irr >>= 4;</yellow>

<yellow>	tpr = kvm_lapic_get_cr8(vcpu);</yellow>

	static_call(kvm_x86_update_cr8_intercept)(vcpu, tpr, max_irr);
<blue>}</blue>


<yellow>int kvm_check_nested_events(struct kvm_vcpu *vcpu)</yellow>
{
<blue>	if (kvm_test_request(KVM_REQ_TRIPLE_FAULT, vcpu)) {</blue>
<yellow>		kvm_x86_ops.nested_ops->triple_fault(vcpu);</yellow>
		return 1;
	}

<blue>	return kvm_x86_ops.nested_ops->check_events(vcpu);</blue>
<blue>}</blue>

static void kvm_inject_exception(struct kvm_vcpu *vcpu)
{
<blue>	trace_kvm_inj_exception(vcpu->arch.exception.vector,</blue>
				vcpu-&gt;arch.exception.has_error_code,
				vcpu-&gt;arch.exception.error_code,
<blue>				vcpu->arch.exception.injected);</blue>

<blue>	if (vcpu->arch.exception.error_code && !is_protmode(vcpu))</blue>
<yellow>		vcpu->arch.exception.error_code = false;</yellow>
<blue>	static_call(kvm_x86_inject_exception)(vcpu);</blue>
}

/*
 * Check for any event (interrupt or exception) that is ready to be injected,
 * and if there is at least one event, inject the event with the highest
 * priority.  This handles both &quot;pending&quot; events, i.e. events that have never
 * been injected into the guest, and &quot;injected&quot; events, i.e. events that were
 * injected as part of a previous VM-Enter, but weren&#x27;t successfully delivered
 * and need to be re-injected.
 *
 * Note, this is not guaranteed to be invoked on a guest instruction boundary,
 * i.e. doesn&#x27;t guarantee that there&#x27;s an event window in the guest.  KVM must
 * be able to inject exceptions in the &quot;middle&quot; of an instruction, and so must
 * also be able to re-inject NMIs and IRQs in the middle of an instruction.
 * I.e. for exceptions and re-injected events, NOT invoking this on instruction
 * boundaries is necessary and correct.
 *
 * For simplicity, KVM uses a single path to inject all events (except events
 * that are injected directly from L1 to L2) and doesn&#x27;t explicitly track
 * instruction boundaries for asynchronous events.  However, because VM-Exits
 * that can occur during instruction execution typically result in KVM skipping
 * the instruction or injecting an exception, e.g. instruction and exception
 * intercepts, and because pending exceptions have higher priority than pending
 * interrupts, KVM still honors instruction boundaries in most scenarios.
 *
 * But, if a VM-Exit occurs during instruction execution, and KVM does NOT skip
 * the instruction or inject an exception, then KVM can incorrecty inject a new
 * asynchrounous event if the event became pending after the CPU fetched the
 * instruction (in the guest).  E.g. if a page fault (#PF, #NPF, EPT violation)
 * occurs and is resolved by KVM, a coincident NMI, SMI, IRQ, etc... can be
 * injected on the restarted instruction instead of being deferred until the
 * instruction completes.
 *
 * In practice, this virtualization hole is unlikely to be observed by the
 * guest, and even less likely to cause functional problems.  To detect the
 * hole, the guest would have to trigger an event on a side effect of an early
 * phase of instruction execution, e.g. on the instruction fetch from memory.
 * And for it to be a functional problem, the guest would need to depend on the
 * ordering between that side effect, the instruction completing, _and_ the
 * delivery of the asynchronous event.
 */
static int kvm_check_and_inject_events(struct kvm_vcpu *vcpu,
				       bool *req_immediate_exit)
{
	bool can_inject;
	int r;

	/*
	 * Process nested events first, as nested VM-Exit supercedes event
	 * re-injection.  If there&#x27;s an event queued for re-injection, it will
	 * be saved into the appropriate vmc{b,s}12 fields on nested VM-Exit.
	 */
<blue>	if (is_guest_mode(vcpu))</blue>
<blue>		r = kvm_check_nested_events(vcpu);</blue>
	else
		r = 0;

	/*
	 * Re-inject exceptions and events *especially* if immediate entry+exit
	 * to/from L2 is needed, as any event that has already been injected
	 * into L2 needs to complete its lifecycle before injecting a new event.
	 *
	 * Don&#x27;t re-inject an NMI or interrupt if there is a pending exception.
	 * This collision arises if an exception occurred while vectoring the
	 * injected event, KVM intercepted said exception, and KVM ultimately
	 * determined the fault belongs to the guest and queues the exception
	 * for injection back into the guest.
	 *
	 * &quot;Injected&quot; interrupts can also collide with pending exceptions if
	 * userspace ignores the &quot;ready for injection&quot; flag and blindly queues
	 * an interrupt.  In that case, prioritizing the exception is correct,
	 * as the exception &quot;occurred&quot; before the exit to userspace.  Trap-like
	 * exceptions, e.g. most #DBs, have higher priority than interrupts.
	 * And while fault-like exceptions, e.g. #GP and #PF, are the lowest
	 * priority, they&#x27;re only generated (pended) during instruction
	 * execution, and interrupts are recognized at instruction boundaries.
	 * Thus a pending fault-like exception means the fault occurred on the
	 * *previous* instruction and must be serviced prior to recognizing any
	 * new events in order to fully complete the previous instruction.
	 */
<blue>	if (vcpu->arch.exception.injected)</blue>
<blue>		kvm_inject_exception(vcpu);</blue>
<blue>	else if (kvm_is_exception_pending(vcpu))</blue>
		; /* see above */
<blue>	else if (vcpu->arch.nmi_injected)</blue>
<blue>		static_call(kvm_x86_inject_nmi)(vcpu);</blue>
<blue>	else if (vcpu->arch.interrupt.injected)</blue>
<blue>		static_call(kvm_x86_inject_irq)(vcpu, true);</blue>

	/*
	 * Exceptions that morph to VM-Exits are handled above, and pending
	 * exceptions on top of injected exceptions that do not VM-Exit should
	 * either morph to #DF or, sadly, override the injected exception.
	 */
<blue>	WARN_ON_ONCE(vcpu->arch.exception.injected &&</blue>
		     vcpu-&gt;arch.exception.pending);

	/*
	 * Bail if immediate entry+exit to/from the guest is needed to complete
	 * nested VM-Enter or event re-injection so that a different pending
	 * event can be serviced (or if KVM needs to exit to userspace).
	 *
	 * Otherwise, continue processing events even if VM-Exit occurred.  The
	 * VM-Exit will have cleared exceptions that were meant for L2, but
	 * there may now be events that can be injected into L1.
	 */
<blue>	if (r < 0)</blue>
		goto out;

	/*
	 * A pending exception VM-Exit should either result in nested VM-Exit
	 * or force an immediate re-entry and exit to/from L2, and exception
	 * VM-Exits cannot be injected (flag should _never_ be set).
	 */
<blue>	WARN_ON_ONCE(vcpu->arch.exception_vmexit.injected ||</blue>
		     vcpu-&gt;arch.exception_vmexit.pending);

	/*
	 * New events, other than exceptions, cannot be injected if KVM needs
	 * to re-inject a previous event.  See above comments on re-injecting
	 * for why pending exceptions get priority.
	 */
<blue>	can_inject = !kvm_event_needs_reinjection(vcpu);</blue>

<blue>	if (vcpu->arch.exception.pending) {</blue>
		/*
		 * Fault-class exceptions, except #DBs, set RF=1 in the RFLAGS
		 * value pushed on the stack.  Trap-like exception and all #DBs
		 * leave RF as-is (KVM follows Intel&#x27;s behavior in this regard;
		 * AMD states that code breakpoint #DBs excplitly clear RF=0).
		 *
		 * Note, most versions of Intel&#x27;s SDM and AMD&#x27;s APM incorrectly
		 * describe the behavior of General Detect #DBs, which are
		 * fault-like.  They do _not_ set RF, a la code breakpoints.
		 */
<blue>		if (exception_type(vcpu->arch.exception.vector) == EXCPT_FAULT)</blue>
<blue>			__kvm_set_rflags(vcpu, kvm_get_rflags(vcpu) |</blue>
					     X86_EFLAGS_RF);

<blue>		if (vcpu->arch.exception.vector == DB_VECTOR) {</blue>
<blue>			kvm_deliver_exception_payload(vcpu, &vcpu->arch.exception);</blue>
			if (vcpu-&gt;arch.dr7 &amp; DR7_GD) {
				vcpu-&gt;arch.dr7 &amp;= ~DR7_GD;
<blue>				kvm_update_dr7(vcpu);</blue>
			}
		}

<blue>		kvm_inject_exception(vcpu);</blue>

		vcpu-&gt;arch.exception.pending = false;
		vcpu-&gt;arch.exception.injected = true;

		can_inject = false;
	}

	/* Don&#x27;t inject interrupts if the user asked to avoid doing so */
<blue>	if (vcpu->guest_debug & KVM_GUESTDBG_BLOCKIRQ)</blue>
		return 0;

	/*
	 * Finally, inject interrupt events.  If an event cannot be injected
	 * due to architectural conditions (e.g. IF=0) a window-open exit
	 * will re-request KVM_REQ_EVENT.  Sometimes however an event is pending
	 * and can architecturally be injected, but we cannot do it right now:
	 * an interrupt could have arrived just now and we have to inject it
	 * as a vmexit, or there could already an event in the queue, which is
	 * indicated by can_inject.  In that case we request an immediate exit
	 * in order to make progress and get back here for another iteration.
	 * The kvm_x86_ops hooks communicate this by returning -EBUSY.
	 */
<blue>	if (vcpu->arch.smi_pending) {</blue>
<blue>		r = can_inject ? static_call(kvm_x86_smi_allowed)(vcpu, true) : -EBUSY;</blue>
		if (r &lt; 0)
			goto out;
<yellow>		if (r) {</yellow>
<yellow>			vcpu->arch.smi_pending = false;</yellow>
			++vcpu-&gt;arch.smi_count;
			enter_smm(vcpu);
			can_inject = false;
		} else
			static_call(kvm_x86_enable_smi_window)(vcpu);
	}

<blue>	if (vcpu->arch.nmi_pending) {</blue>
<yellow>		r = can_inject ? static_call(kvm_x86_nmi_allowed)(vcpu, true) : -EBUSY;</yellow>
		if (r &lt; 0)
			goto out;
<yellow>		if (r) {</yellow>
<yellow>			--vcpu->arch.nmi_pending;</yellow>
			vcpu-&gt;arch.nmi_injected = true;
			static_call(kvm_x86_inject_nmi)(vcpu);
			can_inject = false;
<yellow>			WARN_ON(static_call(kvm_x86_nmi_allowed)(vcpu, true) < 0);</yellow>
		}
<yellow>		if (vcpu->arch.nmi_pending)</yellow>
<yellow>			static_call(kvm_x86_enable_nmi_window)(vcpu);</yellow>
	}

<blue>	if (kvm_cpu_has_injectable_intr(vcpu)) {</blue>
<blue>		r = can_inject ? static_call(kvm_x86_interrupt_allowed)(vcpu, true) : -EBUSY;</blue>
		if (r &lt; 0)
			goto out;
<blue>		if (r) {</blue>
<blue>			kvm_queue_interrupt(vcpu, kvm_cpu_get_interrupt(vcpu), false);</blue>
			static_call(kvm_x86_inject_irq)(vcpu, false);
<yellow>			WARN_ON(static_call(kvm_x86_interrupt_allowed)(vcpu, true) < 0);</yellow>
		}
<blue>		if (kvm_cpu_has_injectable_intr(vcpu))</blue>
<blue>			static_call(kvm_x86_enable_irq_window)(vcpu);</blue>
	}

<blue>	if (is_guest_mode(vcpu) &&</blue>
<blue>	    kvm_x86_ops.nested_ops->has_events &&</blue>
<blue>	    kvm_x86_ops.nested_ops->has_events(vcpu))</blue>
		*req_immediate_exit = true;

	/*
	 * KVM must never queue a new exception while injecting an event; KVM
	 * is done emulating and should only propagate the to-be-injected event
	 * to the VMCS/VMCB.  Queueing a new exception can put the vCPU into an
	 * infinite loop as KVM will bail from VM-Enter to inject the pending
	 * exception and start the cycle all over.
	 *
	 * Exempt triple faults as they have special handling and won&#x27;t put the
	 * vCPU into an infinite loop.  Triple fault can be queued when running
	 * VMX without unrestricted guest, as that requires KVM to emulate Real
	 * Mode events (see kvm_inject_realmode_interrupt()).
	 */
<blue>	WARN_ON_ONCE(vcpu->arch.exception.pending ||</blue>
		     vcpu-&gt;arch.exception_vmexit.pending);
	return 0;

out:
<blue>	if (r == -EBUSY) {</blue>
		*req_immediate_exit = true;
		r = 0;
	}
	return r;
}

static void process_nmi(struct kvm_vcpu *vcpu)
{
	unsigned limit = 2;

	/*
	 * x86 is limited to one NMI running, and one NMI pending after it.
	 * If an NMI is already in progress, limit further NMIs to just one.
	 * Otherwise, allow two (and we&#x27;ll inject the first one immediately).
	 */
<blue>	if (static_call(kvm_x86_get_nmi_mask)(vcpu) || vcpu->arch.nmi_injected)</blue>
		limit = 1;

<blue>	vcpu->arch.nmi_pending += atomic_xchg(&vcpu->arch.nmi_queued, 0);</blue>
	vcpu-&gt;arch.nmi_pending = min(vcpu-&gt;arch.nmi_pending, limit);
	kvm_make_request(KVM_REQ_EVENT, vcpu);
}

static u32 enter_smm_get_segment_flags(struct kvm_segment *seg)
{
	u32 flags = 0;
	flags |= seg-&gt;g       &lt;&lt; 23;
	flags |= seg-&gt;db      &lt;&lt; 22;
	flags |= seg-&gt;l       &lt;&lt; 21;
	flags |= seg-&gt;avl     &lt;&lt; 20;
	flags |= seg-&gt;present &lt;&lt; 15;
	flags |= seg-&gt;dpl     &lt;&lt; 13;
<yellow>	flags |= seg->s       << 12;</yellow>
	flags |= seg-&gt;type    &lt;&lt; 8;
	return flags;
}

static void enter_smm_save_seg_32(struct kvm_vcpu *vcpu, char *buf, int n)
{
	struct kvm_segment seg;
	int offset;

<yellow>	kvm_get_segment(vcpu, &seg, n);</yellow>
	put_smstate(u32, buf, 0x7fa8 + n * 4, seg.selector);

	if (n &lt; 3)
<yellow>		offset = 0x7f84 + n * 12;</yellow>
	else
<yellow>		offset = 0x7f2c + (n - 3) * 12;</yellow>

<yellow>	put_smstate(u32, buf, offset + 8, seg.base);</yellow>
	put_smstate(u32, buf, offset + 4, seg.limit);
	put_smstate(u32, buf, offset, enter_smm_get_segment_flags(&amp;seg));
}

#ifdef CONFIG_X86_64
static void enter_smm_save_seg_64(struct kvm_vcpu *vcpu, char *buf, int n)
{
	struct kvm_segment seg;
	int offset;
	u16 flags;

<yellow>	kvm_get_segment(vcpu, &seg, n);</yellow>
	offset = 0x7e00 + n * 16;

	flags = enter_smm_get_segment_flags(&amp;seg) &gt;&gt; 8;
	put_smstate(u16, buf, offset, seg.selector);
	put_smstate(u16, buf, offset + 2, flags);
	put_smstate(u32, buf, offset + 4, seg.limit);
	put_smstate(u64, buf, offset + 8, seg.base);
}
#endif

static void enter_smm_save_state_32(struct kvm_vcpu *vcpu, char *buf)
{
	struct desc_ptr dt;
	struct kvm_segment seg;
	unsigned long val;
	int i;

<yellow>	put_smstate(u32, buf, 0x7ffc, kvm_read_cr0(vcpu));</yellow>
<yellow>	put_smstate(u32, buf, 0x7ff8, kvm_read_cr3(vcpu));</yellow>
<yellow>	put_smstate(u32, buf, 0x7ff4, kvm_get_rflags(vcpu));</yellow>
<yellow>	put_smstate(u32, buf, 0x7ff0, kvm_rip_read(vcpu));</yellow>

	for (i = 0; i &lt; 8; i++)
<yellow>		put_smstate(u32, buf, 0x7fd0 + i * 4, kvm_register_read_raw(vcpu, i));</yellow>

<yellow>	kvm_get_dr(vcpu, 6, &val);</yellow>
	put_smstate(u32, buf, 0x7fcc, (u32)val);
	kvm_get_dr(vcpu, 7, &amp;val);
	put_smstate(u32, buf, 0x7fc8, (u32)val);

	kvm_get_segment(vcpu, &amp;seg, VCPU_SREG_TR);
	put_smstate(u32, buf, 0x7fc4, seg.selector);
	put_smstate(u32, buf, 0x7f64, seg.base);
	put_smstate(u32, buf, 0x7f60, seg.limit);
	put_smstate(u32, buf, 0x7f5c, enter_smm_get_segment_flags(&amp;seg));

	kvm_get_segment(vcpu, &amp;seg, VCPU_SREG_LDTR);
	put_smstate(u32, buf, 0x7fc0, seg.selector);
	put_smstate(u32, buf, 0x7f80, seg.base);
	put_smstate(u32, buf, 0x7f7c, seg.limit);
	put_smstate(u32, buf, 0x7f78, enter_smm_get_segment_flags(&amp;seg));

	static_call(kvm_x86_get_gdt)(vcpu, &amp;dt);
	put_smstate(u32, buf, 0x7f74, dt.address);
	put_smstate(u32, buf, 0x7f70, dt.size);

	static_call(kvm_x86_get_idt)(vcpu, &amp;dt);
	put_smstate(u32, buf, 0x7f58, dt.address);
	put_smstate(u32, buf, 0x7f54, dt.size);

	for (i = 0; i &lt; 6; i++)
<yellow>		enter_smm_save_seg_32(vcpu, buf, i);</yellow>

<yellow>	put_smstate(u32, buf, 0x7f14, kvm_read_cr4(vcpu));</yellow>

	/* revision id */
	put_smstate(u32, buf, 0x7efc, 0x00020000);
	put_smstate(u32, buf, 0x7ef8, vcpu-&gt;arch.smbase);
}

#ifdef CONFIG_X86_64
static void enter_smm_save_state_64(struct kvm_vcpu *vcpu, char *buf)
{
	struct desc_ptr dt;
	struct kvm_segment seg;
	unsigned long val;
	int i;

	for (i = 0; i &lt; 16; i++)
<yellow>		put_smstate(u64, buf, 0x7ff8 - i * 8, kvm_register_read_raw(vcpu, i));</yellow>

<yellow>	put_smstate(u64, buf, 0x7f78, kvm_rip_read(vcpu));</yellow>
<yellow>	put_smstate(u32, buf, 0x7f70, kvm_get_rflags(vcpu));</yellow>

<yellow>	kvm_get_dr(vcpu, 6, &val);</yellow>
	put_smstate(u64, buf, 0x7f68, val);
	kvm_get_dr(vcpu, 7, &amp;val);
	put_smstate(u64, buf, 0x7f60, val);

<yellow>	put_smstate(u64, buf, 0x7f58, kvm_read_cr0(vcpu));</yellow>
<yellow>	put_smstate(u64, buf, 0x7f50, kvm_read_cr3(vcpu));</yellow>
<yellow>	put_smstate(u64, buf, 0x7f48, kvm_read_cr4(vcpu));</yellow>

	put_smstate(u32, buf, 0x7f00, vcpu-&gt;arch.smbase);

	/* revision id */
	put_smstate(u32, buf, 0x7efc, 0x00020064);

	put_smstate(u64, buf, 0x7ed0, vcpu-&gt;arch.efer);

	kvm_get_segment(vcpu, &amp;seg, VCPU_SREG_TR);
	put_smstate(u16, buf, 0x7e90, seg.selector);
	put_smstate(u16, buf, 0x7e92, enter_smm_get_segment_flags(&amp;seg) &gt;&gt; 8);
	put_smstate(u32, buf, 0x7e94, seg.limit);
	put_smstate(u64, buf, 0x7e98, seg.base);

	static_call(kvm_x86_get_idt)(vcpu, &amp;dt);
	put_smstate(u32, buf, 0x7e84, dt.size);
	put_smstate(u64, buf, 0x7e88, dt.address);

	kvm_get_segment(vcpu, &amp;seg, VCPU_SREG_LDTR);
	put_smstate(u16, buf, 0x7e70, seg.selector);
	put_smstate(u16, buf, 0x7e72, enter_smm_get_segment_flags(&amp;seg) &gt;&gt; 8);
	put_smstate(u32, buf, 0x7e74, seg.limit);
	put_smstate(u64, buf, 0x7e78, seg.base);

	static_call(kvm_x86_get_gdt)(vcpu, &amp;dt);
	put_smstate(u32, buf, 0x7e64, dt.size);
	put_smstate(u64, buf, 0x7e68, dt.address);

	for (i = 0; i &lt; 6; i++)
<yellow>		enter_smm_save_seg_64(vcpu, buf, i);</yellow>
<yellow>}</yellow>
#endif

static void enter_smm(struct kvm_vcpu *vcpu)
{
	struct kvm_segment cs, ds;
	struct desc_ptr dt;
	unsigned long cr0;
	char buf[512];

<yellow>	memset(buf, 0, 512);</yellow>
#ifdef CONFIG_X86_64
<yellow>	if (guest_cpuid_has(vcpu, X86_FEATURE_LM))</yellow>
<yellow>		enter_smm_save_state_64(vcpu, buf);</yellow>
	else
#endif
<yellow>		enter_smm_save_state_32(vcpu, buf);</yellow>

	/*
	 * Give enter_smm() a chance to make ISA-specific changes to the vCPU
	 * state (e.g. leave guest mode) after we&#x27;ve saved the state into the
	 * SMM state-save area.
	 */
<yellow>	static_call(kvm_x86_enter_smm)(vcpu, buf);</yellow>

	kvm_smm_changed(vcpu, true);
	kvm_vcpu_write_guest(vcpu, vcpu-&gt;arch.smbase + 0xfe00, buf, sizeof(buf));

	if (static_call(kvm_x86_get_nmi_mask)(vcpu))
<yellow>		vcpu->arch.hflags |= HF_SMM_INSIDE_NMI_MASK;</yellow>
	else
<yellow>		static_call(kvm_x86_set_nmi_mask)(vcpu, true);</yellow>

<yellow>	kvm_set_rflags(vcpu, X86_EFLAGS_FIXED);</yellow>
	kvm_rip_write(vcpu, 0x8000);

	cr0 = vcpu-&gt;arch.cr0 &amp; ~(X86_CR0_PE | X86_CR0_EM | X86_CR0_TS | X86_CR0_PG);
	static_call(kvm_x86_set_cr0)(vcpu, cr0);
	vcpu-&gt;arch.cr0 = cr0;

	static_call(kvm_x86_set_cr4)(vcpu, 0);

	/* Undocumented: IDT limit is set to zero on entry to SMM.  */
	dt.address = dt.size = 0;
	static_call(kvm_x86_set_idt)(vcpu, &amp;dt);

<yellow>	kvm_set_dr(vcpu, 7, DR7_FIXED_1);</yellow>

<yellow>	cs.selector = (vcpu->arch.smbase >> 4) & 0xffff;</yellow>
	cs.base = vcpu-&gt;arch.smbase;

	ds.selector = 0;
	ds.base = 0;

	cs.limit    = ds.limit = 0xffffffff;
	cs.type     = ds.type = 0x3;
	cs.dpl      = ds.dpl = 0;
	cs.db       = ds.db = 0;
	cs.s        = ds.s = 1;
	cs.l        = ds.l = 0;
	cs.g        = ds.g = 1;
	cs.avl      = ds.avl = 0;
	cs.present  = ds.present = 1;
	cs.unusable = ds.unusable = 0;
	cs.padding  = ds.padding = 0;

	kvm_set_segment(vcpu, &amp;cs, VCPU_SREG_CS);
	kvm_set_segment(vcpu, &amp;ds, VCPU_SREG_DS);
	kvm_set_segment(vcpu, &amp;ds, VCPU_SREG_ES);
	kvm_set_segment(vcpu, &amp;ds, VCPU_SREG_FS);
	kvm_set_segment(vcpu, &amp;ds, VCPU_SREG_GS);
	kvm_set_segment(vcpu, &amp;ds, VCPU_SREG_SS);

#ifdef CONFIG_X86_64
<yellow>	if (guest_cpuid_has(vcpu, X86_FEATURE_LM))</yellow>
<yellow>		static_call(kvm_x86_set_efer)(vcpu, 0);</yellow>
#endif

<yellow>	kvm_update_cpuid_runtime(vcpu);</yellow>
	kvm_mmu_reset_context(vcpu);
}

static void process_smi(struct kvm_vcpu *vcpu)
{
	vcpu-&gt;arch.smi_pending = true;
	kvm_make_request(KVM_REQ_EVENT, vcpu);
}

void kvm_make_scan_ioapic_request_mask(struct kvm *kvm,
				       unsigned long *vcpu_bitmap)
{
<yellow>	kvm_make_vcpus_request_mask(kvm, KVM_REQ_SCAN_IOAPIC, vcpu_bitmap);</yellow>
}

void kvm_make_scan_ioapic_request(struct kvm *kvm)
{
<blue>	kvm_make_all_cpus_request(kvm, KVM_REQ_SCAN_IOAPIC);</blue>
}

void kvm_vcpu_update_apicv(struct kvm_vcpu *vcpu)
{
<blue>	struct kvm_lapic *apic = vcpu->arch.apic;</blue>
	bool activate;

<yellow>	if (!lapic_in_kernel(vcpu))</yellow>
		return;

<blue>	down_read(&vcpu->kvm->arch.apicv_update_lock);</blue>
	preempt_disable();

	/* Do not activate APICV when APIC is disabled */
	activate = kvm_vcpu_apicv_activated(vcpu) &amp;&amp;
<blue>		   (kvm_get_apic_mode(vcpu) != LAPIC_MODE_DISABLED);</blue>

<blue>	if (apic->apicv_active == activate)</blue>
		goto out;

<yellow>	apic->apicv_active = activate;</yellow>
	kvm_apic_update_apicv(vcpu);
	static_call(kvm_x86_refresh_apicv_exec_ctrl)(vcpu);

	/*
	 * When APICv gets disabled, we may still have injected interrupts
	 * pending. At the same time, KVM_REQ_EVENT may not be set as APICv was
	 * still active when the interrupt got accepted. Make sure
	 * kvm_check_and_inject_events() is called to check for that.
	 */
<yellow>	if (!apic->apicv_active)</yellow>
<yellow>		kvm_make_request(KVM_REQ_EVENT, vcpu);</yellow>

out:
<blue>	preempt_enable();</blue>
<blue>	up_read(&vcpu->kvm->arch.apicv_update_lock);</blue>
<blue>}</blue>
EXPORT_SYMBOL_GPL(kvm_vcpu_update_apicv);

<blue>void __kvm_set_or_clear_apicv_inhibit(struct kvm *kvm,</blue>
				      enum kvm_apicv_inhibit reason, bool set)
{
	unsigned long old, new;

	lockdep_assert_held_write(&amp;kvm-&gt;arch.apicv_update_lock);

<blue>	if (!static_call(kvm_x86_check_apicv_inhibit_reasons)(reason))</blue>
		return;

<blue>	old = new = kvm->arch.apicv_inhibit_reasons;</blue>

	set_or_clear_apicv_inhibit(&amp;new, reason, set);

	if (!!old != !!new) {
		/*
		 * Kick all vCPUs before setting apicv_inhibit_reasons to avoid
		 * false positives in the sanity check WARN in svm_vcpu_run().
		 * This task will wait for all vCPUs to ack the kick IRQ before
		 * updating apicv_inhibit_reasons, and all other vCPUs will
		 * block on acquiring apicv_update_lock so that vCPUs can&#x27;t
		 * redo svm_vcpu_run() without seeing the new inhibit state.
		 *
		 * Note, holding apicv_update_lock and taking it in the read
		 * side (handling the request) also prevents other vCPUs from
		 * servicing the request with a stale apicv_inhibit_reasons.
		 */
<blue>		kvm_make_all_cpus_request(kvm, KVM_REQ_APICV_UPDATE);</blue>
		kvm-&gt;arch.apicv_inhibit_reasons = new;
		if (new) {
			unsigned long gfn = gpa_to_gfn(APIC_DEFAULT_PHYS_BASE);
<yellow>			int idx = srcu_read_lock(&kvm->srcu);</yellow>

			kvm_zap_gfn_range(kvm, gfn, gfn+1);
<yellow>			srcu_read_unlock(&kvm->srcu, idx);</yellow>
		}
	} else {
<yellow>		kvm->arch.apicv_inhibit_reasons = new;</yellow>
	}
<yellow>}</yellow>

<blue>void kvm_set_or_clear_apicv_inhibit(struct kvm *kvm,</blue>
				    enum kvm_apicv_inhibit reason, bool set)
{
<blue>	if (!enable_apicv)</blue>
		return;

<blue>	down_write(&kvm->arch.apicv_update_lock);</blue>
<blue>	__kvm_set_or_clear_apicv_inhibit(kvm, reason, set);</blue>
<blue>	up_write(&kvm->arch.apicv_update_lock);</blue>
<blue>}</blue>
EXPORT_SYMBOL_GPL(kvm_set_or_clear_apicv_inhibit);

static void vcpu_scan_ioapic(struct kvm_vcpu *vcpu)
{
<blue>	if (!kvm_apic_present(vcpu))</blue>
		return;

<blue>	bitmap_zero(vcpu->arch.ioapic_handled_vectors, 256);</blue>

	if (irqchip_split(vcpu-&gt;kvm))
<yellow>		kvm_scan_ioapic_routes(vcpu, vcpu->arch.ioapic_handled_vectors);</yellow>
	else {
<blue>		static_call_cond(kvm_x86_sync_pir_to_irr)(vcpu);</blue>
		if (ioapic_in_kernel(vcpu-&gt;kvm))
<blue>			kvm_ioapic_scan_entry(vcpu, vcpu->arch.ioapic_handled_vectors);</blue>
	}

<blue>	if (is_guest_mode(vcpu))</blue>
<yellow>		vcpu->arch.load_eoi_exitmap_pending = true;</yellow>
	else
<blue>		kvm_make_request(KVM_REQ_LOAD_EOI_EXITMAP, vcpu);</blue>
}

static void vcpu_load_eoi_exitmap(struct kvm_vcpu *vcpu)
{
	u64 eoi_exit_bitmap[4];

<yellow>	if (!kvm_apic_hw_enabled(vcpu->arch.apic))</yellow>
<blue>		return;</blue>

<blue>	if (to_hv_vcpu(vcpu)) {</blue>
		bitmap_or((ulong *)eoi_exit_bitmap,
			  vcpu-&gt;arch.ioapic_handled_vectors,
<blue>			  to_hv_synic(vcpu)->vec_bitmap, 256);</blue>
		static_call_cond(kvm_x86_load_eoi_exitmap)(vcpu, eoi_exit_bitmap);
		return;
	}

<yellow>	static_call_cond(kvm_x86_load_eoi_exitmap)(</yellow>
		vcpu, (u64 *)vcpu-&gt;arch.ioapic_handled_vectors);
}

void kvm_arch_mmu_notifier_invalidate_range(struct kvm *kvm,
					    unsigned long start, unsigned long end)
{
	unsigned long apic_address;

	/*
	 * The physical address of apic access page is stored in the VMCS.
	 * Update it when it becomes invalid.
	 */
<blue>	apic_address = gfn_to_hva(kvm, APIC_DEFAULT_PHYS_BASE >> PAGE_SHIFT);</blue>
<blue>	if (start <= apic_address && apic_address < end)</blue>
<blue>		kvm_make_all_cpus_request(kvm, KVM_REQ_APIC_PAGE_RELOAD);</blue>
<blue>}</blue>

void kvm_arch_guest_memory_reclaimed(struct kvm *kvm)
{
<blue>	static_call_cond(kvm_x86_guest_memory_reclaimed)(kvm);</blue>
}

static void kvm_vcpu_reload_apic_access_page(struct kvm_vcpu *vcpu)
{
<yellow>	if (!lapic_in_kernel(vcpu))</yellow>
		return;

<blue>	static_call_cond(kvm_x86_set_apic_access_page_addr)(vcpu);</blue>
}

void __kvm_request_immediate_exit(struct kvm_vcpu *vcpu)
{
<blue>	smp_send_reschedule(vcpu->cpu);</blue>
}
EXPORT_SYMBOL_GPL(__kvm_request_immediate_exit);

/*
 * Called within kvm-&gt;srcu read side.
 * Returns 1 to let vcpu_run() continue the guest execution loop without
 * exiting to the userspace.  Otherwise, the value will be returned to the
 * userspace.
 */
static int vcpu_enter_guest(struct kvm_vcpu *vcpu)
<blue>{</blue>
	int r;
	bool req_int_win =
<blue>		dm_request_for_irq_injection(vcpu) &&</blue>
<yellow>		kvm_cpu_accept_dm_intr(vcpu);</yellow>
	fastpath_t exit_fastpath;

	bool req_immediate_exit = false;

	/* Forbid vmenter if vcpu dirty ring is soft-full */
<blue>	if (unlikely(vcpu->kvm->dirty_ring_size &&</blue>
		     kvm_dirty_ring_soft_full(&amp;vcpu-&gt;dirty_ring))) {
<yellow>		vcpu->run->exit_reason = KVM_EXIT_DIRTY_RING_FULL;</yellow>
<yellow>		trace_kvm_dirty_ring_exit(vcpu);</yellow>
		r = 0;
		goto out;
	}

<blue>	if (kvm_request_pending(vcpu)) {</blue>
<blue>		if (kvm_check_request(KVM_REQ_VM_DEAD, vcpu)) {</blue>
			r = -EIO;
			goto out;
		}
<blue>		if (kvm_check_request(KVM_REQ_GET_NESTED_STATE_PAGES, vcpu)) {</blue>
			if (unlikely(!kvm_x86_ops.nested_ops-&gt;get_nested_state_pages(vcpu))) {
				r = 0;
				goto out;
			}
		}
<blue>		if (kvm_check_request(KVM_REQ_MMU_FREE_OBSOLETE_ROOTS, vcpu))</blue>
			kvm_mmu_free_obsolete_roots(vcpu);
<blue>		if (kvm_check_request(KVM_REQ_MIGRATE_TIMER, vcpu))</blue>
			__kvm_migrate_timers(vcpu);
<blue>		if (kvm_check_request(KVM_REQ_MASTERCLOCK_UPDATE, vcpu))</blue>
			kvm_update_masterclock(vcpu-&gt;kvm);
<blue>		if (kvm_check_request(KVM_REQ_GLOBAL_CLOCK_UPDATE, vcpu))</blue>
			kvm_gen_kvmclock_update(vcpu);
<blue>		if (kvm_check_request(KVM_REQ_CLOCK_UPDATE, vcpu)) {</blue>
			r = kvm_guest_time_update(vcpu);
			if (unlikely(r))
				goto out;
		}
<blue>		if (kvm_check_request(KVM_REQ_MMU_SYNC, vcpu))</blue>
			kvm_mmu_sync_roots(vcpu);
<blue>		if (kvm_check_request(KVM_REQ_LOAD_MMU_PGD, vcpu))</blue>
<blue>			kvm_mmu_load_pgd(vcpu);</blue>
<blue>		if (kvm_check_request(KVM_REQ_TLB_FLUSH, vcpu)) {</blue>
			kvm_vcpu_flush_tlb_all(vcpu);

			/* Flushing all ASIDs flushes the current ASID... */
			kvm_clear_request(KVM_REQ_TLB_FLUSH_CURRENT, vcpu);
		}
<blue>		kvm_service_local_tlb_flush_requests(vcpu);</blue>

<yellow>		if (kvm_check_request(KVM_REQ_REPORT_TPR_ACCESS, vcpu)) {</yellow>
			vcpu-&gt;run-&gt;exit_reason = KVM_EXIT_TPR_ACCESS;
			r = 0;
			goto out;
		}
<blue>		if (kvm_test_request(KVM_REQ_TRIPLE_FAULT, vcpu)) {</blue>
<blue>			if (is_guest_mode(vcpu))</blue>
<yellow>				kvm_x86_ops.nested_ops->triple_fault(vcpu);</yellow>

<blue>			if (kvm_check_request(KVM_REQ_TRIPLE_FAULT, vcpu)) {</blue>
				vcpu-&gt;run-&gt;exit_reason = KVM_EXIT_SHUTDOWN;
				vcpu-&gt;mmio_needed = 0;
				r = 0;
			}
			goto out;
		}
<blue>		if (kvm_check_request(KVM_REQ_APF_HALT, vcpu)) {</blue>
			/* Page is swapped out. Do synthetic halt */
			vcpu-&gt;arch.apf.halted = true;
			r = 1;
			goto out;
		}
<blue>		if (kvm_check_request(KVM_REQ_STEAL_UPDATE, vcpu))</blue>
			record_steal_time(vcpu);
<blue>		if (kvm_check_request(KVM_REQ_SMI, vcpu))</blue>
			process_smi(vcpu);
<blue>		if (kvm_check_request(KVM_REQ_NMI, vcpu))</blue>
			process_nmi(vcpu);
<blue>		if (kvm_check_request(KVM_REQ_PMU, vcpu))</blue>
			kvm_pmu_handle_event(vcpu);
<blue>		if (kvm_check_request(KVM_REQ_PMI, vcpu))</blue>
			kvm_pmu_deliver_pmi(vcpu);
<blue>		if (kvm_check_request(KVM_REQ_IOAPIC_EOI_EXIT, vcpu)) {</blue>
<yellow>			BUG_ON(vcpu->arch.pending_ioapic_eoi > 255);</yellow>
<yellow>			if (test_bit(vcpu->arch.pending_ioapic_eoi,</yellow>
				     vcpu-&gt;arch.ioapic_handled_vectors)) {
<yellow>				vcpu->run->exit_reason = KVM_EXIT_IOAPIC_EOI;</yellow>
				vcpu-&gt;run-&gt;eoi.vector =
						vcpu-&gt;arch.pending_ioapic_eoi;
				r = 0;
				goto out;
			}
		}
<blue>		if (kvm_check_request(KVM_REQ_SCAN_IOAPIC, vcpu))</blue>
<blue>			vcpu_scan_ioapic(vcpu);</blue>
<blue>		if (kvm_check_request(KVM_REQ_LOAD_EOI_EXITMAP, vcpu))</blue>
<blue>			vcpu_load_eoi_exitmap(vcpu);</blue>
<blue>		if (kvm_check_request(KVM_REQ_APIC_PAGE_RELOAD, vcpu))</blue>
<blue>			kvm_vcpu_reload_apic_access_page(vcpu);</blue>
<blue>		if (kvm_check_request(KVM_REQ_HV_CRASH, vcpu)) {</blue>
			vcpu-&gt;run-&gt;exit_reason = KVM_EXIT_SYSTEM_EVENT;
			vcpu-&gt;run-&gt;system_event.type = KVM_SYSTEM_EVENT_CRASH;
			vcpu-&gt;run-&gt;system_event.ndata = 0;
			r = 0;
			goto out;
		}
<blue>		if (kvm_check_request(KVM_REQ_HV_RESET, vcpu)) {</blue>
			vcpu-&gt;run-&gt;exit_reason = KVM_EXIT_SYSTEM_EVENT;
			vcpu-&gt;run-&gt;system_event.type = KVM_SYSTEM_EVENT_RESET;
			vcpu-&gt;run-&gt;system_event.ndata = 0;
			r = 0;
			goto out;
		}
<blue>		if (kvm_check_request(KVM_REQ_HV_EXIT, vcpu)) {</blue>
			struct kvm_vcpu_hv *hv_vcpu = to_hv_vcpu(vcpu);

			vcpu-&gt;run-&gt;exit_reason = KVM_EXIT_HYPERV;
			vcpu-&gt;run-&gt;hyperv = hv_vcpu-&gt;exit;
			r = 0;
			goto out;
		}

		/*
		 * KVM_REQ_HV_STIMER has to be processed after
		 * KVM_REQ_CLOCK_UPDATE, because Hyper-V SynIC timers
		 * depend on the guest clock being up-to-date
		 */
<blue>		if (kvm_check_request(KVM_REQ_HV_STIMER, vcpu))</blue>
			kvm_hv_process_stimers(vcpu);
<blue>		if (kvm_check_request(KVM_REQ_APICV_UPDATE, vcpu))</blue>
			kvm_vcpu_update_apicv(vcpu);
<blue>		if (kvm_check_request(KVM_REQ_APF_READY, vcpu))</blue>
			kvm_check_async_pf_completion(vcpu);
<blue>		if (kvm_check_request(KVM_REQ_MSR_FILTER_CHANGED, vcpu))</blue>
			static_call(kvm_x86_msr_filter_changed)(vcpu);

<blue>		if (kvm_check_request(KVM_REQ_UPDATE_CPU_DIRTY_LOGGING, vcpu))</blue>
			static_call(kvm_x86_update_cpu_dirty_logging)(vcpu);
	}

<blue>	if (kvm_check_request(KVM_REQ_EVENT, vcpu) || req_int_win ||</blue>
<blue>	    kvm_xen_has_interrupt(vcpu)) {</blue>
<blue>		++vcpu->stat.req_event;</blue>
		r = kvm_apic_accept_events(vcpu);
		if (r &lt; 0) {
			r = 0;
			goto out;
		}
<blue>		if (vcpu->arch.mp_state == KVM_MP_STATE_INIT_RECEIVED) {</blue>
			r = 1;
			goto out;
		}

<blue>		r = kvm_check_and_inject_events(vcpu, &req_immediate_exit);</blue>
		if (r &lt; 0) {
			r = 0;
			goto out;
		}
<blue>		if (req_int_win)</blue>
<yellow>			static_call(kvm_x86_enable_irq_window)(vcpu);</yellow>

<blue>		if (kvm_lapic_enabled(vcpu)) {</blue>
<blue>			update_cr8_intercept(vcpu);</blue>
			kvm_lapic_sync_to_vapic(vcpu);
		}
	}

<blue>	r = kvm_mmu_reload(vcpu);</blue>
	if (unlikely(r)) {
		goto cancel_injection;
	}

<blue>	preempt_disable();</blue>

	static_call(kvm_x86_prepare_switch_to_guest)(vcpu);

	/*
	 * Disable IRQs before setting IN_GUEST_MODE.  Posted interrupt
	 * IPI are then delayed after guest entry, which ensures that they
	 * result in virtual interrupt delivery.
	 */
	local_irq_disable();

	/* Store vcpu-&gt;apicv_active before vcpu-&gt;mode.  */
	smp_store_release(&amp;vcpu-&gt;mode, IN_GUEST_MODE);

<blue>	kvm_vcpu_srcu_read_unlock(vcpu);</blue>

	/*
	 * 1) We should set -&gt;mode before checking -&gt;requests.  Please see
	 * the comment in kvm_vcpu_exiting_guest_mode().
	 *
	 * 2) For APICv, we should set -&gt;mode before checking PID.ON. This
	 * pairs with the memory barrier implicit in pi_test_and_set_on
	 * (see vmx_deliver_posted_interrupt).
	 *
	 * 3) This also orders the write to mode from any reads to the page
	 * tables done while the VCPU is running.  Please see the comment
	 * in kvm_flush_remote_tlbs.
	 */
	smp_mb__after_srcu_read_unlock();

	/*
	 * Process pending posted interrupts to handle the case where the
	 * notification IRQ arrived in the host, or was never sent (because the
	 * target vCPU wasn&#x27;t running).  Do this regardless of the vCPU&#x27;s APICv
	 * status, KVM doesn&#x27;t update assigned devices when APICv is inhibited,
	 * i.e. they can post interrupts even if APICv is temporarily disabled.
	 */
<blue>	if (kvm_lapic_enabled(vcpu))</blue>
<blue>		static_call_cond(kvm_x86_sync_pir_to_irr)(vcpu);</blue>

<blue>	if (kvm_vcpu_exit_request(vcpu)) {</blue>
<blue>		vcpu->mode = OUTSIDE_GUEST_MODE;</blue>
		smp_wmb();
		local_irq_enable();
<blue>		preempt_enable();</blue>
<blue>		kvm_vcpu_srcu_read_lock(vcpu);</blue>
		r = 1;
		goto cancel_injection;
	}

<blue>	if (req_immediate_exit) {</blue>
<blue>		kvm_make_request(KVM_REQ_EVENT, vcpu);</blue>
		static_call(kvm_x86_request_immediate_exit)(vcpu);
	}

<blue>	fpregs_assert_state_consistent();</blue>
	if (test_thread_flag(TIF_NEED_FPU_LOAD))
<blue>		switch_fpu_return();</blue>

<blue>	if (vcpu->arch.guest_fpu.xfd_err)</blue>
<yellow>		wrmsrl(MSR_IA32_XFD_ERR, vcpu->arch.guest_fpu.xfd_err);</yellow>

<blue>	if (unlikely(vcpu->arch.switch_db_regs)) {</blue>
<blue>		set_debugreg(0, 7);</blue>
		set_debugreg(vcpu-&gt;arch.eff_db[0], 0);
		set_debugreg(vcpu-&gt;arch.eff_db[1], 1);
		set_debugreg(vcpu-&gt;arch.eff_db[2], 2);
		set_debugreg(vcpu-&gt;arch.eff_db[3], 3);
<blue>	} else if (unlikely(hw_breakpoint_active())) {</blue>
<yellow>		set_debugreg(0, 7);</yellow>
	}

<blue>	guest_timing_enter_irqoff();</blue>

	for (;;) {
		/*
		 * Assert that vCPU vs. VM APICv state is consistent.  An APICv
		 * update must kick and wait for all vCPUs before toggling the
		 * per-VM state, and responsing vCPUs must wait for the update
		 * to complete before servicing KVM_REQ_APICV_UPDATE.
		 */
<blue>		WARN_ON_ONCE((kvm_vcpu_apicv_activated(vcpu) != kvm_vcpu_apicv_active(vcpu)) &&</blue>
			     (kvm_get_apic_mode(vcpu) != LAPIC_MODE_DISABLED));

<blue>		exit_fastpath = static_call(kvm_x86_vcpu_run)(vcpu);</blue>
		if (likely(exit_fastpath != EXIT_FASTPATH_REENTER_GUEST))
			break;

<yellow>		if (kvm_lapic_enabled(vcpu))</yellow>
<yellow>			static_call_cond(kvm_x86_sync_pir_to_irr)(vcpu);</yellow>

<yellow>		if (unlikely(kvm_vcpu_exit_request(vcpu))) {</yellow>
			exit_fastpath = EXIT_FASTPATH_EXIT_HANDLED;
			break;
		}
	}

	/*
	 * Do this here before restoring debug registers on the host.  And
	 * since we do this before handling the vmexit, a DR access vmexit
	 * can (a) read the correct value of the debug registers, (b) set
	 * KVM_DEBUGREG_WONT_EXIT again.
	 */
<blue>	if (unlikely(vcpu->arch.switch_db_regs & KVM_DEBUGREG_WONT_EXIT)) {</blue>
<blue>		WARN_ON(vcpu->guest_debug & KVM_GUESTDBG_USE_HW_BP);</blue>
<blue>		static_call(kvm_x86_sync_dirty_debug_regs)(vcpu);</blue>
<blue>		kvm_update_dr0123(vcpu);</blue>
<blue>		kvm_update_dr7(vcpu);</blue>
	}

	/*
	 * If the guest has used debug registers, at least dr7
	 * will be disabled while returning to the host.
	 * If we don&#x27;t have active breakpoints in the host, we don&#x27;t
	 * care about the messed up debug address registers. But if
	 * we have some of them active, restore the old state.
	 */
<blue>	if (hw_breakpoint_active())</blue>
<yellow>		hw_breakpoint_restore();</yellow>

<blue>	vcpu->arch.last_vmentry_cpu = vcpu->cpu;</blue>
<blue>	vcpu->arch.last_guest_tsc = kvm_read_l1_tsc(vcpu, rdtsc());</blue>

	vcpu-&gt;mode = OUTSIDE_GUEST_MODE;
	smp_wmb();

	/*
	 * Sync xfd before calling handle_exit_irqoff() which may
	 * rely on the fact that guest_fpu::xfd is up-to-date (e.g.
	 * in #NM irqoff handler).
	 */
<blue>	if (vcpu->arch.xfd_no_write_intercept)</blue>
<yellow>		fpu_sync_guest_vmexit_xfd_state();</yellow>

<blue>	static_call(kvm_x86_handle_exit_irqoff)(vcpu);</blue>

	if (vcpu-&gt;arch.guest_fpu.xfd_err)
<yellow>		wrmsrl(MSR_IA32_XFD_ERR, 0);</yellow>

	/*
	 * Consume any pending interrupts, including the possible source of
	 * VM-Exit on SVM and any ticks that occur between VM-Exit and now.
	 * An instruction is required after local_irq_enable() to fully unblock
	 * interrupts on processors that implement an interrupt shadow, the
	 * stat.exits increment will do nicely.
	 */
<blue>	kvm_before_interrupt(vcpu, KVM_HANDLING_IRQ);</blue>
	local_irq_enable();
	++vcpu-&gt;stat.exits;
	local_irq_disable();
	kvm_after_interrupt(vcpu);

	/*
	 * Wait until after servicing IRQs to account guest time so that any
	 * ticks that occurred while running the guest are properly accounted
	 * to the guest.  Waiting until IRQs are enabled degrades the accuracy
	 * of accounting via context tracking, but the loss of accuracy is
	 * acceptable for all known use cases.
	 */
	guest_timing_exit_irqoff();

	local_irq_enable();
<blue>	preempt_enable();</blue>

<blue>	kvm_vcpu_srcu_read_lock(vcpu);</blue>

	/*
	 * Profile KVM exit RIPs:
	 */
	if (unlikely(prof_on == KVM_PROFILING)) {
<yellow>		unsigned long rip = kvm_rip_read(vcpu);</yellow>
<yellow>		profile_hit(KVM_PROFILING, (void *)rip);</yellow>
	}

<blue>	if (unlikely(vcpu->arch.tsc_always_catchup))</blue>
<yellow>		kvm_make_request(KVM_REQ_CLOCK_UPDATE, vcpu);</yellow>

<blue>	if (vcpu->arch.apic_attention)</blue>
<yellow>		kvm_lapic_sync_from_vapic(vcpu);</yellow>

<blue>	r = static_call(kvm_x86_handle_exit)(vcpu, exit_fastpath);</blue>
	return r;

cancel_injection:
<blue>	if (req_immediate_exit)</blue>
<blue>		kvm_make_request(KVM_REQ_EVENT, vcpu);</blue>
<blue>	static_call(kvm_x86_cancel_injection)(vcpu);</blue>
	if (unlikely(vcpu-&gt;arch.apic_attention))
<yellow>		kvm_lapic_sync_from_vapic(vcpu);</yellow>
out:
	return r;
}

/* Called within kvm-&gt;srcu read side.  */
static inline int vcpu_block(struct kvm_vcpu *vcpu)
{
	bool hv_timer;

<blue>	if (!kvm_arch_vcpu_runnable(vcpu)) {</blue>
		/*
		 * Switch to the software timer before halt-polling/blocking as
		 * the guest&#x27;s timer may be a break event for the vCPU, and the
		 * hypervisor timer runs only when the CPU is in guest mode.
		 * Switch before halt-polling so that KVM recognizes an expired
		 * timer before blocking.
		 */
<blue>		hv_timer = kvm_lapic_hv_timer_in_use(vcpu);</blue>
		if (hv_timer)
<yellow>			kvm_lapic_switch_to_sw_timer(vcpu);</yellow>

<blue>		kvm_vcpu_srcu_read_unlock(vcpu);</blue>
		if (vcpu-&gt;arch.mp_state == KVM_MP_STATE_HALTED)
<blue>			kvm_vcpu_halt(vcpu);</blue>
		else
<blue>			kvm_vcpu_block(vcpu);</blue>
<blue>		kvm_vcpu_srcu_read_lock(vcpu);</blue>

		if (hv_timer)
<yellow>			kvm_lapic_switch_to_hv_timer(vcpu);</yellow>

		/*
		 * If the vCPU is not runnable, a signal or another host event
		 * of some kind is pending; service it without changing the
		 * vCPU&#x27;s activity state.
		 */
<blue>		if (!kvm_arch_vcpu_runnable(vcpu))</blue>
			return 1;
	}

	/*
	 * Evaluate nested events before exiting the halted state.  This allows
	 * the halt state to be recorded properly in the VMCS12&#x27;s activity
	 * state field (AMD does not have a similar field and a VM-Exit always
	 * causes a spurious wakeup from HLT).
	 */
<blue>	if (is_guest_mode(vcpu)) {</blue>
<blue>		if (kvm_check_nested_events(vcpu) < 0)</blue>
			return 0;
	}

<blue>	if (kvm_apic_accept_events(vcpu) < 0)</blue>
		return 0;
<blue>	switch(vcpu->arch.mp_state) {</blue>
	case KVM_MP_STATE_HALTED:
	case KVM_MP_STATE_AP_RESET_HOLD:
<blue>		vcpu->arch.pv.pv_unhalted = false;</blue>
		vcpu-&gt;arch.mp_state =
			KVM_MP_STATE_RUNNABLE;
		fallthrough;
	case KVM_MP_STATE_RUNNABLE:
<blue>		vcpu->arch.apf.halted = false;</blue>
		break;
	case KVM_MP_STATE_INIT_RECEIVED:
		break;
	default:
<yellow>		WARN_ON_ONCE(1);</yellow>
		break;
	}
	return 1;
}

static inline bool kvm_vcpu_running(struct kvm_vcpu *vcpu)
{
<blue>	return (vcpu->arch.mp_state == KVM_MP_STATE_RUNNABLE &&</blue>
<blue>		!vcpu->arch.apf.halted);</blue>
}

/* Called within kvm-&gt;srcu read side.  */
static int vcpu_run(struct kvm_vcpu *vcpu)
{
	int r;

<blue>	vcpu->arch.l1tf_flush_l1d = true;</blue>

	for (;;) {
		/*
		 * If another guest vCPU requests a PV TLB flush in the middle
		 * of instruction emulation, the rest of the emulation could
		 * use a stale page translation. Assume that any code after
		 * this point can start executing an instruction.
		 */
<blue>		vcpu->arch.at_instruction_boundary = false;</blue>
<blue>		if (kvm_vcpu_running(vcpu)) {</blue>
<blue>			r = vcpu_enter_guest(vcpu);</blue>
		} else {
<blue>			r = vcpu_block(vcpu);</blue>
		}

		if (r &lt;= 0)
			break;

<blue>		kvm_clear_request(KVM_REQ_UNBLOCK, vcpu);</blue>
<yellow>		if (kvm_xen_has_pending_events(vcpu))</yellow>
<yellow>			kvm_xen_inject_pending_events(vcpu);</yellow>

<blue>		if (kvm_cpu_has_pending_timer(vcpu))</blue>
<yellow>			kvm_inject_pending_timer_irqs(vcpu);</yellow>

<blue>		if (dm_request_for_irq_injection(vcpu) &&</blue>
<yellow>			kvm_vcpu_ready_for_interrupt_injection(vcpu)) {</yellow>
			r = 0;
<yellow>			vcpu->run->exit_reason = KVM_EXIT_IRQ_WINDOW_OPEN;</yellow>
			++vcpu-&gt;stat.request_irq_exits;
			break;
		}

<blue>		if (__xfer_to_guest_mode_work_pending()) {</blue>
<blue>			kvm_vcpu_srcu_read_unlock(vcpu);</blue>
			r = xfer_to_guest_mode_handle_work(vcpu);
			kvm_vcpu_srcu_read_lock(vcpu);
			if (r)
				return r;
		}
	}

	return r;
}

static inline int complete_emulated_io(struct kvm_vcpu *vcpu)
{
<blue>	return kvm_emulate_instruction(vcpu, EMULTYPE_NO_DECODE);</blue>
}

static int complete_emulated_pio(struct kvm_vcpu *vcpu)
{
<blue>	BUG_ON(!vcpu->arch.pio.count);</blue>

<blue>	return complete_emulated_io(vcpu);</blue>
}

/*
 * Implements the following, as a state machine:
 *
 * read:
 *   for each fragment
 *     for each mmio piece in the fragment
 *       write gpa, len
 *       exit
 *       copy data
 *   execute insn
 *
 * write:
 *   for each fragment
 *     for each mmio piece in the fragment
 *       write gpa, len
 *       copy data
 *       exit
 */
static int complete_emulated_mmio(struct kvm_vcpu *vcpu)
{
<blue>	struct kvm_run *run = vcpu->run;</blue>
	struct kvm_mmio_fragment *frag;
	unsigned len;

<yellow>	BUG_ON(!vcpu->mmio_needed);</yellow>

	/* Complete previous fragment */
<blue>	frag = &vcpu->mmio_fragments[vcpu->mmio_cur_fragment];</blue>
	len = min(8u, frag-&gt;len);
	if (!vcpu-&gt;mmio_is_write)
<blue>		memcpy(frag->data, run->mmio.data, len);</blue>

<blue>	if (frag->len <= 8) {</blue>
		/* Switch to the next fragment. */
		frag++;
<blue>		vcpu->mmio_cur_fragment++;</blue>
	} else {
		/* Go forward to the next mmio piece. */
<yellow>		frag->data += len;</yellow>
		frag-&gt;gpa += len;
		frag-&gt;len -= len;
	}

<blue>	if (vcpu->mmio_cur_fragment >= vcpu->mmio_nr_fragments) {</blue>
<blue>		vcpu->mmio_needed = 0;</blue>

		/* FIXME: return into emulator if single-stepping.  */
		if (vcpu-&gt;mmio_is_write)
			return 1;
<blue>		vcpu->mmio_read_completed = 1;</blue>
		return complete_emulated_io(vcpu);
	}

<blue>	run->exit_reason = KVM_EXIT_MMIO;</blue>
	run-&gt;mmio.phys_addr = frag-&gt;gpa;
	if (vcpu-&gt;mmio_is_write)
<blue>		memcpy(run->mmio.data, frag->data, min(8u, frag->len));</blue>
<blue>	run->mmio.len = min(8u, frag->len);</blue>
	run-&gt;mmio.is_write = vcpu-&gt;mmio_is_write;
	vcpu-&gt;arch.complete_userspace_io = complete_emulated_mmio;
	return 0;
<blue>}</blue>

/* Swap (qemu) user FPU context for the guest FPU context. */
static void kvm_load_guest_fpu(struct kvm_vcpu *vcpu)
{
	/* Exclude PKRU, it&#x27;s restored separately immediately after VM-Exit. */
<yellow>	fpu_swap_kvm_fpstate(&vcpu->arch.guest_fpu, true);</yellow>
<yellow>	trace_kvm_fpu(1);</yellow>
}

/* When vcpu_run ends, restore user space FPU context. */
static void kvm_put_guest_fpu(struct kvm_vcpu *vcpu)
{
<blue>	fpu_swap_kvm_fpstate(&vcpu->arch.guest_fpu, false);</blue>
	++vcpu-&gt;stat.fpu_reload;
<yellow>	trace_kvm_fpu(0);</yellow>
<blue>}</blue>

int kvm_arch_vcpu_ioctl_run(struct kvm_vcpu *vcpu)
{
	struct kvm_queued_exception *ex = &amp;vcpu-&gt;arch.exception;
<blue>	struct kvm_run *kvm_run = vcpu->run;</blue>
	int r;

	vcpu_load(vcpu);
	kvm_sigset_activate(vcpu);
	kvm_run-&gt;flags = 0;
<yellow>	kvm_load_guest_fpu(vcpu);</yellow>

<blue>	kvm_vcpu_srcu_read_lock(vcpu);</blue>
	if (unlikely(vcpu-&gt;arch.mp_state == KVM_MP_STATE_UNINITIALIZED)) {
<yellow>		if (kvm_run->immediate_exit) {</yellow>
			r = -EINTR;
			goto out;
		}
		/*
		 * It should be impossible for the hypervisor timer to be in
		 * use before KVM has ever run the vCPU.
		 */
<yellow>		WARN_ON_ONCE(kvm_lapic_hv_timer_in_use(vcpu));</yellow>

<yellow>		kvm_vcpu_srcu_read_unlock(vcpu);</yellow>
		kvm_vcpu_block(vcpu);
		kvm_vcpu_srcu_read_lock(vcpu);

		if (kvm_apic_accept_events(vcpu) &lt; 0) {
			r = 0;
			goto out;
		}
		r = -EAGAIN;
<yellow>		if (signal_pending(current)) {</yellow>
			r = -EINTR;
<yellow>			kvm_run->exit_reason = KVM_EXIT_INTR;</yellow>
			++vcpu-&gt;stat.signal_exits;
		}
		goto out;
	}

<blue>	if ((kvm_run->kvm_valid_regs & ~KVM_SYNC_X86_VALID_FIELDS) ||</blue>
<blue>	    (kvm_run->kvm_dirty_regs & ~KVM_SYNC_X86_VALID_FIELDS)) {</blue>
		r = -EINVAL;
		goto out;
	}

<blue>	if (kvm_run->kvm_dirty_regs) {</blue>
<yellow>		r = sync_regs(vcpu);</yellow>
		if (r != 0)
			goto out;
	}

	/* re-sync apic&#x27;s tpr */
<blue>	if (!lapic_in_kernel(vcpu)) {</blue>
<yellow>		if (kvm_set_cr8(vcpu, kvm_run->cr8) != 0) {</yellow>
			r = -EINVAL;
			goto out;
		}
	}

	/*
	 * If userspace set a pending exception and L2 is active, convert it to
	 * a pending VM-Exit if L1 wants to intercept the exception.
	 */
<blue>	if (vcpu->arch.exception_from_userspace && is_guest_mode(vcpu) &&</blue>
<yellow>	    kvm_x86_ops.nested_ops->is_exception_vmexit(vcpu, ex->vector,</yellow>
							ex-&gt;error_code)) {
<yellow>		kvm_queue_exception_vmexit(vcpu, ex->vector,</yellow>
					   ex-&gt;has_error_code, ex-&gt;error_code,
					   ex-&gt;has_payload, ex-&gt;payload);
		ex-&gt;injected = false;
		ex-&gt;pending = false;
	}
<blue>	vcpu->arch.exception_from_userspace = false;</blue>

	if (unlikely(vcpu-&gt;arch.complete_userspace_io)) {
		int (*cui)(struct kvm_vcpu *) = vcpu-&gt;arch.complete_userspace_io;
		vcpu-&gt;arch.complete_userspace_io = NULL;
<blue>		r = cui(vcpu);</blue>
		if (r &lt;= 0)
			goto out;
	} else {
<blue>		WARN_ON_ONCE(vcpu->arch.pio.count);</blue>
<blue>		WARN_ON_ONCE(vcpu->mmio_needed);</blue>
	}

<blue>	if (kvm_run->immediate_exit) {</blue>
		r = -EINTR;
		goto out;
	}

<blue>	r = static_call(kvm_x86_vcpu_pre_run)(vcpu);</blue>
	if (r &lt;= 0)
		goto out;

<blue>	r = vcpu_run(vcpu);</blue>

out:
<blue>	kvm_put_guest_fpu(vcpu);</blue>
	if (kvm_run-&gt;kvm_valid_regs)
<blue>		store_regs(vcpu);</blue>
<blue>	post_kvm_run_save(vcpu);</blue>
<blue>	kvm_vcpu_srcu_read_unlock(vcpu);</blue>

	kvm_sigset_deactivate(vcpu);
	vcpu_put(vcpu);
	return r;
}

static void __get_regs(struct kvm_vcpu *vcpu, struct kvm_regs *regs)
{
<blue>	if (vcpu->arch.emulate_regs_need_sync_to_vcpu) {</blue>
		/*
		 * We are here if userspace calls get_regs() in the middle of
		 * instruction emulation. Registers state needs to be copied
		 * back from emulation context to vcpu. Userspace shouldn&#x27;t do
		 * that usually, but some bad designed PV devices (vmware
		 * backdoor interface) need this to work
		 */
<blue>		emulator_writeback_register_cache(vcpu->arch.emulate_ctxt);</blue>
		vcpu-&gt;arch.emulate_regs_need_sync_to_vcpu = false;
	}
<blue>	regs->rax = kvm_rax_read(vcpu);</blue>
	regs-&gt;rbx = kvm_rbx_read(vcpu);
	regs-&gt;rcx = kvm_rcx_read(vcpu);
	regs-&gt;rdx = kvm_rdx_read(vcpu);
	regs-&gt;rsi = kvm_rsi_read(vcpu);
	regs-&gt;rdi = kvm_rdi_read(vcpu);
<blue>	regs->rsp = kvm_rsp_read(vcpu);</blue>
	regs-&gt;rbp = kvm_rbp_read(vcpu);
#ifdef CONFIG_X86_64
	regs-&gt;r8 = kvm_r8_read(vcpu);
	regs-&gt;r9 = kvm_r9_read(vcpu);
	regs-&gt;r10 = kvm_r10_read(vcpu);
	regs-&gt;r11 = kvm_r11_read(vcpu);
	regs-&gt;r12 = kvm_r12_read(vcpu);
	regs-&gt;r13 = kvm_r13_read(vcpu);
	regs-&gt;r14 = kvm_r14_read(vcpu);
	regs-&gt;r15 = kvm_r15_read(vcpu);
#endif

<blue>	regs->rip = kvm_rip_read(vcpu);</blue>
<blue>	regs->rflags = kvm_get_rflags(vcpu);</blue>
}

int kvm_arch_vcpu_ioctl_get_regs(struct kvm_vcpu *vcpu, struct kvm_regs *regs)
{
<blue>	vcpu_load(vcpu);</blue>
	__get_regs(vcpu, regs);
	vcpu_put(vcpu);
	return 0;
}

static void __set_regs(struct kvm_vcpu *vcpu, struct kvm_regs *regs)
{
<blue>	vcpu->arch.emulate_regs_need_sync_from_vcpu = true;</blue>
	vcpu-&gt;arch.emulate_regs_need_sync_to_vcpu = false;

	kvm_rax_write(vcpu, regs-&gt;rax);
	kvm_rbx_write(vcpu, regs-&gt;rbx);
	kvm_rcx_write(vcpu, regs-&gt;rcx);
	kvm_rdx_write(vcpu, regs-&gt;rdx);
	kvm_rsi_write(vcpu, regs-&gt;rsi);
	kvm_rdi_write(vcpu, regs-&gt;rdi);
	kvm_rsp_write(vcpu, regs-&gt;rsp);
	kvm_rbp_write(vcpu, regs-&gt;rbp);
#ifdef CONFIG_X86_64
	kvm_r8_write(vcpu, regs-&gt;r8);
	kvm_r9_write(vcpu, regs-&gt;r9);
	kvm_r10_write(vcpu, regs-&gt;r10);
	kvm_r11_write(vcpu, regs-&gt;r11);
	kvm_r12_write(vcpu, regs-&gt;r12);
	kvm_r13_write(vcpu, regs-&gt;r13);
	kvm_r14_write(vcpu, regs-&gt;r14);
	kvm_r15_write(vcpu, regs-&gt;r15);
#endif

	kvm_rip_write(vcpu, regs-&gt;rip);
	kvm_set_rflags(vcpu, regs-&gt;rflags | X86_EFLAGS_FIXED);

	vcpu-&gt;arch.exception.pending = false;
	vcpu-&gt;arch.exception_vmexit.pending = false;

	kvm_make_request(KVM_REQ_EVENT, vcpu);
}

int kvm_arch_vcpu_ioctl_set_regs(struct kvm_vcpu *vcpu, struct kvm_regs *regs)
{
<blue>	vcpu_load(vcpu);</blue>
	__set_regs(vcpu, regs);
	vcpu_put(vcpu);
	return 0;
}

static void __get_sregs_common(struct kvm_vcpu *vcpu, struct kvm_sregs *sregs)
{
	struct desc_ptr dt;

<blue>	if (vcpu->arch.guest_state_protected)</blue>
		goto skip_protected_regs;

<blue>	kvm_get_segment(vcpu, &sregs->cs, VCPU_SREG_CS);</blue>
	kvm_get_segment(vcpu, &amp;sregs-&gt;ds, VCPU_SREG_DS);
	kvm_get_segment(vcpu, &amp;sregs-&gt;es, VCPU_SREG_ES);
	kvm_get_segment(vcpu, &amp;sregs-&gt;fs, VCPU_SREG_FS);
	kvm_get_segment(vcpu, &amp;sregs-&gt;gs, VCPU_SREG_GS);
	kvm_get_segment(vcpu, &amp;sregs-&gt;ss, VCPU_SREG_SS);

	kvm_get_segment(vcpu, &amp;sregs-&gt;tr, VCPU_SREG_TR);
	kvm_get_segment(vcpu, &amp;sregs-&gt;ldt, VCPU_SREG_LDTR);

	static_call(kvm_x86_get_idt)(vcpu, &amp;dt);
	sregs-&gt;idt.limit = dt.size;
	sregs-&gt;idt.base = dt.address;
	static_call(kvm_x86_get_gdt)(vcpu, &amp;dt);
	sregs-&gt;gdt.limit = dt.size;
	sregs-&gt;gdt.base = dt.address;

	sregs-&gt;cr2 = vcpu-&gt;arch.cr2;
<blue>	sregs->cr3 = kvm_read_cr3(vcpu);</blue>

skip_protected_regs:
<blue>	sregs->cr0 = kvm_read_cr0(vcpu);</blue>
<blue>	sregs->cr4 = kvm_read_cr4(vcpu);</blue>
<blue>	sregs->cr8 = kvm_get_cr8(vcpu);</blue>
	sregs-&gt;efer = vcpu-&gt;arch.efer;
	sregs-&gt;apic_base = kvm_get_apic_base(vcpu);
}

<blue>static void __get_sregs(struct kvm_vcpu *vcpu, struct kvm_sregs *sregs)</blue>
{
<blue>	__get_sregs_common(vcpu, sregs);</blue>

<blue>	if (vcpu->arch.guest_state_protected)</blue>
		return;

<blue>	if (vcpu->arch.interrupt.injected && !vcpu->arch.interrupt.soft)</blue>
<yellow>		set_bit(vcpu->arch.interrupt.nr,</yellow>
			(unsigned long *)sregs-&gt;interrupt_bitmap);
<blue>}</blue>

static void __get_sregs2(struct kvm_vcpu *vcpu, struct kvm_sregs2 *sregs2)
{
	int i;

<blue>	__get_sregs_common(vcpu, (struct kvm_sregs *)sregs2);</blue>

<blue>	if (vcpu->arch.guest_state_protected)</blue>
		return;

<blue>	if (is_pae_paging(vcpu)) {</blue>
		for (i = 0 ; i &lt; 4 ; i++)
<yellow>			sregs2->pdptrs[i] = kvm_pdptr_read(vcpu, i);</yellow>
<yellow>		sregs2->flags |= KVM_SREGS2_FLAGS_PDPTRS_VALID;</yellow>
	}
}

int kvm_arch_vcpu_ioctl_get_sregs(struct kvm_vcpu *vcpu,
				  struct kvm_sregs *sregs)
{
<blue>	vcpu_load(vcpu);</blue>
	__get_sregs(vcpu, sregs);
	vcpu_put(vcpu);
	return 0;
}

int kvm_arch_vcpu_ioctl_get_mpstate(struct kvm_vcpu *vcpu,
				    struct kvm_mp_state *mp_state)
{
	int r;

<blue>	vcpu_load(vcpu);</blue>
	if (kvm_mpx_supported())
<yellow>		kvm_load_guest_fpu(vcpu);</yellow>

<blue>	r = kvm_apic_accept_events(vcpu);</blue>
	if (r &lt; 0)
		goto out;
	r = 0;

<blue>	if ((vcpu->arch.mp_state == KVM_MP_STATE_HALTED ||</blue>
<yellow>	     vcpu->arch.mp_state == KVM_MP_STATE_AP_RESET_HOLD) &&</yellow>
<yellow>	    vcpu->arch.pv.pv_unhalted)</yellow>
<yellow>		mp_state->mp_state = KVM_MP_STATE_RUNNABLE;</yellow>
	else
<blue>		mp_state->mp_state = vcpu->arch.mp_state;</blue>

out:
<blue>	if (kvm_mpx_supported())</blue>
<yellow>		kvm_put_guest_fpu(vcpu);</yellow>
<blue>	vcpu_put(vcpu);</blue>
	return r;
}

int kvm_arch_vcpu_ioctl_set_mpstate(struct kvm_vcpu *vcpu,
				    struct kvm_mp_state *mp_state)
{
	int ret = -EINVAL;

<blue>	vcpu_load(vcpu);</blue>

	switch (mp_state-&gt;mp_state) {
	case KVM_MP_STATE_UNINITIALIZED:
	case KVM_MP_STATE_HALTED:
	case KVM_MP_STATE_AP_RESET_HOLD:
	case KVM_MP_STATE_INIT_RECEIVED:
	case KVM_MP_STATE_SIPI_RECEIVED:
<blue>		if (!lapic_in_kernel(vcpu))</blue>
			goto out;
		break;

	case KVM_MP_STATE_RUNNABLE:
		break;

	default:
		goto out;
	}

	/*
	 * Pending INITs are reported using KVM_SET_VCPU_EVENTS, disallow
	 * forcing the guest into INIT/SIPI if those events are supposed to be
	 * blocked.  KVM prioritizes SMI over INIT, so reject INIT/SIPI state
	 * if an SMI is pending as well.
	 */
<blue>	if ((!kvm_apic_init_sipi_allowed(vcpu) || vcpu->arch.smi_pending) &&</blue>
<blue>	    (mp_state->mp_state == KVM_MP_STATE_SIPI_RECEIVED ||</blue>
	     mp_state-&gt;mp_state == KVM_MP_STATE_INIT_RECEIVED))
		goto out;

<blue>	if (mp_state->mp_state == KVM_MP_STATE_SIPI_RECEIVED) {</blue>
<yellow>		vcpu->arch.mp_state = KVM_MP_STATE_INIT_RECEIVED;</yellow>
		set_bit(KVM_APIC_SIPI, &amp;vcpu-&gt;arch.apic-&gt;pending_events);
	} else
<blue>		vcpu->arch.mp_state = mp_state->mp_state;</blue>
<blue>	kvm_make_request(KVM_REQ_EVENT, vcpu);</blue>

	ret = 0;
out:
<blue>	vcpu_put(vcpu);</blue>
	return ret;
}

int kvm_task_switch(struct kvm_vcpu *vcpu, u16 tss_selector, int idt_index,
		    int reason, bool has_error_code, u32 error_code)
{
<yellow>	struct x86_emulate_ctxt *ctxt = vcpu->arch.emulate_ctxt;</yellow>
	int ret;

	init_emulate_ctxt(vcpu);

	ret = emulator_task_switch(ctxt, tss_selector, idt_index, reason,
				   has_error_code, error_code);
	if (ret) {
<yellow>		vcpu->run->exit_reason = KVM_EXIT_INTERNAL_ERROR;</yellow>
		vcpu-&gt;run-&gt;internal.suberror = KVM_INTERNAL_ERROR_EMULATION;
		vcpu-&gt;run-&gt;internal.ndata = 0;
		return 0;
	}

<yellow>	kvm_rip_write(vcpu, ctxt->eip);</yellow>
	kvm_set_rflags(vcpu, ctxt-&gt;eflags);
	return 1;
<yellow>}</yellow>
EXPORT_SYMBOL_GPL(kvm_task_switch);

static bool kvm_is_valid_sregs(struct kvm_vcpu *vcpu, struct kvm_sregs *sregs)
{
<blue>	if ((sregs->efer & EFER_LME) && (sregs->cr0 & X86_CR0_PG)) {</blue>
		/*
		 * When EFER.LME and CR0.PG are set, the processor is in
		 * 64-bit mode (though maybe in a 32-bit code segment).
		 * CR4.PAE and EFER.LMA must be set.
		 */
<blue>		if (!(sregs->cr4 & X86_CR4_PAE) || !(sregs->efer & EFER_LMA))</blue>
			return false;
<blue>		if (kvm_vcpu_is_illegal_gpa(vcpu, sregs->cr3))</blue>
			return false;
	} else {
		/*
		 * Not in 64-bit mode: EFER.LMA is clear and the code
		 * segment cannot be 64-bit.
		 */
<blue>		if (sregs->efer & EFER_LMA || sregs->cs.l)</blue>
			return false;
	}

<blue>	return kvm_is_valid_cr4(vcpu, sregs->cr4);</blue>
}

<blue>static int __set_sregs_common(struct kvm_vcpu *vcpu, struct kvm_sregs *sregs,</blue>
		int *mmu_reset_needed, bool update_pdptrs)
{
	struct msr_data apic_base_msr;
	int idx;
	struct desc_ptr dt;

<blue>	if (!kvm_is_valid_sregs(vcpu, sregs))</blue>
		return -EINVAL;

<blue>	apic_base_msr.data = sregs->apic_base;</blue>
	apic_base_msr.host_initiated = true;
	if (kvm_set_apic_base(vcpu, &amp;apic_base_msr))
		return -EINVAL;

<blue>	if (vcpu->arch.guest_state_protected)</blue>
		return 0;

<blue>	dt.size = sregs->idt.limit;</blue>
	dt.address = sregs-&gt;idt.base;
	static_call(kvm_x86_set_idt)(vcpu, &amp;dt);
	dt.size = sregs-&gt;gdt.limit;
	dt.address = sregs-&gt;gdt.base;
	static_call(kvm_x86_set_gdt)(vcpu, &amp;dt);

	vcpu-&gt;arch.cr2 = sregs-&gt;cr2;
<blue>	*mmu_reset_needed |= kvm_read_cr3(vcpu) != sregs->cr3;</blue>
	vcpu-&gt;arch.cr3 = sregs-&gt;cr3;
	kvm_register_mark_dirty(vcpu, VCPU_EXREG_CR3);
	static_call_cond(kvm_x86_post_set_cr3)(vcpu, sregs-&gt;cr3);

<blue>	kvm_set_cr8(vcpu, sregs->cr8);</blue>

<blue>	*mmu_reset_needed |= vcpu->arch.efer != sregs->efer;</blue>
	static_call(kvm_x86_set_efer)(vcpu, sregs-&gt;efer);

<blue>	*mmu_reset_needed |= kvm_read_cr0(vcpu) != sregs->cr0;</blue>
	static_call(kvm_x86_set_cr0)(vcpu, sregs-&gt;cr0);
	vcpu-&gt;arch.cr0 = sregs-&gt;cr0;

<blue>	*mmu_reset_needed |= kvm_read_cr4(vcpu) != sregs->cr4;</blue>
	static_call(kvm_x86_set_cr4)(vcpu, sregs-&gt;cr4);

	if (update_pdptrs) {
<blue>		idx = srcu_read_lock(&vcpu->kvm->srcu);</blue>
<blue>		if (is_pae_paging(vcpu)) {</blue>
<yellow>			load_pdptrs(vcpu, kvm_read_cr3(vcpu));</yellow>
			*mmu_reset_needed = 1;
		}
<blue>		srcu_read_unlock(&vcpu->kvm->srcu, idx);</blue>
	}

<blue>	kvm_set_segment(vcpu, &sregs->cs, VCPU_SREG_CS);</blue>
	kvm_set_segment(vcpu, &amp;sregs-&gt;ds, VCPU_SREG_DS);
	kvm_set_segment(vcpu, &amp;sregs-&gt;es, VCPU_SREG_ES);
	kvm_set_segment(vcpu, &amp;sregs-&gt;fs, VCPU_SREG_FS);
	kvm_set_segment(vcpu, &amp;sregs-&gt;gs, VCPU_SREG_GS);
	kvm_set_segment(vcpu, &amp;sregs-&gt;ss, VCPU_SREG_SS);

	kvm_set_segment(vcpu, &amp;sregs-&gt;tr, VCPU_SREG_TR);
	kvm_set_segment(vcpu, &amp;sregs-&gt;ldt, VCPU_SREG_LDTR);

	update_cr8_intercept(vcpu);

	/* Older userspace won&#x27;t unhalt the vcpu on reset. */
<blue>	if (kvm_vcpu_is_bsp(vcpu) && kvm_rip_read(vcpu) == 0xfff0 &&</blue>
<blue>	    sregs->cs.selector == 0xf000 && sregs->cs.base == 0xffff0000 &&</blue>
<blue>	    !is_protmode(vcpu))</blue>
<blue>		vcpu->arch.mp_state = KVM_MP_STATE_RUNNABLE;</blue>

	return 0;
}

<blue>static int __set_sregs(struct kvm_vcpu *vcpu, struct kvm_sregs *sregs)</blue>
<blue>{</blue>
	int pending_vec, max_bits;
	int mmu_reset_needed = 0;
<blue>	int ret = __set_sregs_common(vcpu, sregs, &mmu_reset_needed, true);</blue>

	if (ret)
		return ret;

<blue>	if (mmu_reset_needed)</blue>
<yellow>		kvm_mmu_reset_context(vcpu);</yellow>

	max_bits = KVM_NR_INTERRUPTS;
	pending_vec = find_first_bit(
<blue>		(const unsigned long *)sregs->interrupt_bitmap, max_bits);</blue>

	if (pending_vec &lt; max_bits) {
<yellow>		kvm_queue_interrupt(vcpu, pending_vec, false);</yellow>
<yellow>		pr_debug("Set back pending irq %d\n", pending_vec);</yellow>
<yellow>		kvm_make_request(KVM_REQ_EVENT, vcpu);</yellow>
	}
	return 0;
}

static int __set_sregs2(struct kvm_vcpu *vcpu, struct kvm_sregs2 *sregs2)
{
	int mmu_reset_needed = 0;
<blue>	bool valid_pdptrs = sregs2->flags & KVM_SREGS2_FLAGS_PDPTRS_VALID;</blue>
<blue>	bool pae = (sregs2->cr0 & X86_CR0_PG) && (sregs2->cr4 & X86_CR4_PAE) &&</blue>
<blue>		!(sregs2->efer & EFER_LMA);</blue>
	int i, ret;

<blue>	if (sregs2->flags & ~KVM_SREGS2_FLAGS_PDPTRS_VALID)</blue>
		return -EINVAL;

<yellow>	if (valid_pdptrs && (!pae || vcpu->arch.guest_state_protected))</yellow>
		return -EINVAL;

<blue>	ret = __set_sregs_common(vcpu, (struct kvm_sregs *)sregs2,</blue>
				 &amp;mmu_reset_needed, !valid_pdptrs);
	if (ret)
		return ret;

	if (valid_pdptrs) {
		for (i = 0; i &lt; 4 ; i++)
<yellow>			kvm_pdptr_write(vcpu, i, sregs2->pdptrs[i]);</yellow>

<yellow>		kvm_register_mark_dirty(vcpu, VCPU_EXREG_PDPTR);</yellow>
		mmu_reset_needed = 1;
		vcpu-&gt;arch.pdptrs_from_userspace = true;
	}
<blue>	if (mmu_reset_needed)</blue>
<yellow>		kvm_mmu_reset_context(vcpu);</yellow>
	return 0;
}

int kvm_arch_vcpu_ioctl_set_sregs(struct kvm_vcpu *vcpu,
				  struct kvm_sregs *sregs)
{
	int ret;

<blue>	vcpu_load(vcpu);</blue>
	ret = __set_sregs(vcpu, sregs);
	vcpu_put(vcpu);
	return ret;
}

static void kvm_arch_vcpu_guestdbg_update_apicv_inhibit(struct kvm *kvm)
{
	bool set = false;
	struct kvm_vcpu *vcpu;
	unsigned long i;

<yellow>	if (!enable_apicv)</yellow>
		return;

<yellow>	down_write(&kvm->arch.apicv_update_lock);</yellow>

<yellow>	kvm_for_each_vcpu(i, vcpu, kvm) {</yellow>
<yellow>		if (vcpu->guest_debug & KVM_GUESTDBG_BLOCKIRQ) {</yellow>
			set = true;
			break;
		}
	}
<yellow>	__kvm_set_or_clear_apicv_inhibit(kvm, APICV_INHIBIT_REASON_BLOCKIRQ, set);</yellow>
<yellow>	up_write(&kvm->arch.apicv_update_lock);</yellow>
}

int kvm_arch_vcpu_ioctl_set_guest_debug(struct kvm_vcpu *vcpu,
					struct kvm_guest_debug *dbg)
<yellow>{</yellow>
	unsigned long rflags;
	int i, r;

<yellow>	if (vcpu->arch.guest_state_protected)</yellow>
		return -EINVAL;

<yellow>	vcpu_load(vcpu);</yellow>

	if (dbg-&gt;control &amp; (KVM_GUESTDBG_INJECT_DB | KVM_GUESTDBG_INJECT_BP)) {
		r = -EBUSY;
<yellow>		if (kvm_is_exception_pending(vcpu))</yellow>
			goto out;
<yellow>		if (dbg->control & KVM_GUESTDBG_INJECT_DB)</yellow>
<yellow>			kvm_queue_exception(vcpu, DB_VECTOR);</yellow>
		else
<yellow>			kvm_queue_exception(vcpu, BP_VECTOR);</yellow>
	}

	/*
	 * Read rflags as long as potentially injected trace flags are still
	 * filtered out.
	 */
<yellow>	rflags = kvm_get_rflags(vcpu);</yellow>

<yellow>	vcpu->guest_debug = dbg->control;</yellow>
	if (!(vcpu-&gt;guest_debug &amp; KVM_GUESTDBG_ENABLE))
		vcpu-&gt;guest_debug = 0;

	if (vcpu-&gt;guest_debug &amp; KVM_GUESTDBG_USE_HW_BP) {
		for (i = 0; i &lt; KVM_NR_DB_REGS; ++i)
<yellow>			vcpu->arch.eff_db[i] = dbg->arch.debugreg[i];</yellow>
		vcpu-&gt;arch.guest_debug_dr7 = dbg-&gt;arch.debugreg[7];
	} else {
		for (i = 0; i &lt; KVM_NR_DB_REGS; i++)
<yellow>			vcpu->arch.eff_db[i] = vcpu->arch.db[i];</yellow>
	}
<yellow>	kvm_update_dr7(vcpu);</yellow>

<yellow>	if (vcpu->guest_debug & KVM_GUESTDBG_SINGLESTEP)</yellow>
<yellow>		vcpu->arch.singlestep_rip = kvm_get_linear_rip(vcpu);</yellow>

	/*
	 * Trigger an rflags update that will inject or remove the trace
	 * flags.
	 */
<yellow>	kvm_set_rflags(vcpu, rflags);</yellow>

	static_call(kvm_x86_update_exception_bitmap)(vcpu);

<yellow>	kvm_arch_vcpu_guestdbg_update_apicv_inhibit(vcpu->kvm);</yellow>

<yellow>	r = 0;</yellow>

out:
<yellow>	vcpu_put(vcpu);</yellow>
	return r;
<yellow>}</yellow>

/*
 * Translate a guest virtual address to a guest physical address.
 */
int kvm_arch_vcpu_ioctl_translate(struct kvm_vcpu *vcpu,
				    struct kvm_translation *tr)
{
<yellow>	unsigned long vaddr = tr->linear_address;</yellow>
	gpa_t gpa;
	int idx;

	vcpu_load(vcpu);

	idx = srcu_read_lock(&amp;vcpu-&gt;kvm-&gt;srcu);
	gpa = kvm_mmu_gva_to_gpa_system(vcpu, vaddr, NULL);
<yellow>	srcu_read_unlock(&vcpu->kvm->srcu, idx);</yellow>
	tr-&gt;physical_address = gpa;
	tr-&gt;valid = gpa != INVALID_GPA;
	tr-&gt;writeable = 1;
	tr-&gt;usermode = 0;

	vcpu_put(vcpu);
	return 0;
}

int kvm_arch_vcpu_ioctl_get_fpu(struct kvm_vcpu *vcpu, struct kvm_fpu *fpu)
{
	struct fxregs_state *fxsave;

<yellow>	if (fpstate_is_confidential(&vcpu->arch.guest_fpu))</yellow>
		return 0;

<yellow>	vcpu_load(vcpu);</yellow>

	fxsave = &amp;vcpu-&gt;arch.guest_fpu.fpstate-&gt;regs.fxsave;
	memcpy(fpu-&gt;fpr, fxsave-&gt;st_space, 128);
	fpu-&gt;fcw = fxsave-&gt;cwd;
	fpu-&gt;fsw = fxsave-&gt;swd;
	fpu-&gt;ftwx = fxsave-&gt;twd;
	fpu-&gt;last_opcode = fxsave-&gt;fop;
	fpu-&gt;last_ip = fxsave-&gt;rip;
	fpu-&gt;last_dp = fxsave-&gt;rdp;
	memcpy(fpu-&gt;xmm, fxsave-&gt;xmm_space, sizeof(fxsave-&gt;xmm_space));

	vcpu_put(vcpu);
	return 0;
<yellow>}</yellow>

int kvm_arch_vcpu_ioctl_set_fpu(struct kvm_vcpu *vcpu, struct kvm_fpu *fpu)
{
	struct fxregs_state *fxsave;

<yellow>	if (fpstate_is_confidential(&vcpu->arch.guest_fpu))</yellow>
		return 0;

<yellow>	vcpu_load(vcpu);</yellow>

	fxsave = &amp;vcpu-&gt;arch.guest_fpu.fpstate-&gt;regs.fxsave;

	memcpy(fxsave-&gt;st_space, fpu-&gt;fpr, 128);
	fxsave-&gt;cwd = fpu-&gt;fcw;
	fxsave-&gt;swd = fpu-&gt;fsw;
	fxsave-&gt;twd = fpu-&gt;ftwx;
	fxsave-&gt;fop = fpu-&gt;last_opcode;
	fxsave-&gt;rip = fpu-&gt;last_ip;
	fxsave-&gt;rdp = fpu-&gt;last_dp;
	memcpy(fxsave-&gt;xmm_space, fpu-&gt;xmm, sizeof(fxsave-&gt;xmm_space));

	vcpu_put(vcpu);
	return 0;
<yellow>}</yellow>

static void store_regs(struct kvm_vcpu *vcpu)
{
	BUILD_BUG_ON(sizeof(struct kvm_sync_regs) &gt; SYNC_REGS_SIZE_BYTES);

<blue>	if (vcpu->run->kvm_valid_regs & KVM_SYNC_X86_REGS)</blue>
<yellow>		__get_regs(vcpu, &vcpu->run->s.regs.regs);</yellow>

<yellow>	if (vcpu->run->kvm_valid_regs & KVM_SYNC_X86_SREGS)</yellow>
<yellow>		__get_sregs(vcpu, &vcpu->run->s.regs.sregs);</yellow>

<yellow>	if (vcpu->run->kvm_valid_regs & KVM_SYNC_X86_EVENTS)</yellow>
<yellow>		kvm_vcpu_ioctl_x86_get_vcpu_events(</yellow>
				vcpu, &amp;vcpu-&gt;run-&gt;s.regs.events);
}

static int sync_regs(struct kvm_vcpu *vcpu)
{
<yellow>	if (vcpu->run->kvm_dirty_regs & KVM_SYNC_X86_REGS) {</yellow>
<yellow>		__set_regs(vcpu, &vcpu->run->s.regs.regs);</yellow>
		vcpu-&gt;run-&gt;kvm_dirty_regs &amp;= ~KVM_SYNC_X86_REGS;
	}
<yellow>	if (vcpu->run->kvm_dirty_regs & KVM_SYNC_X86_SREGS) {</yellow>
<yellow>		if (__set_sregs(vcpu, &vcpu->run->s.regs.sregs))</yellow>
			return -EINVAL;
<yellow>		vcpu->run->kvm_dirty_regs &= ~KVM_SYNC_X86_SREGS;</yellow>
	}
<yellow>	if (vcpu->run->kvm_dirty_regs & KVM_SYNC_X86_EVENTS) {</yellow>
<yellow>		if (kvm_vcpu_ioctl_x86_set_vcpu_events(</yellow>
				vcpu, &amp;vcpu-&gt;run-&gt;s.regs.events))
			return -EINVAL;
<yellow>		vcpu->run->kvm_dirty_regs &= ~KVM_SYNC_X86_EVENTS;</yellow>
	}

	return 0;
}

int kvm_arch_vcpu_precreate(struct kvm *kvm, unsigned int id)
{
<blue>	if (kvm_check_tsc_unstable() && kvm->created_vcpus)</blue>
<yellow>		pr_warn_once("kvm: SMP vm created on host with unstable TSC; "</yellow>
			     &quot;guest TSC will not be reliable\n&quot;);

<blue>	if (!kvm->arch.max_vcpu_ids)</blue>
<blue>		kvm->arch.max_vcpu_ids = KVM_MAX_VCPU_IDS;</blue>

<blue>	if (id >= kvm->arch.max_vcpu_ids)</blue>
		return -EINVAL;

<blue>	return static_call(kvm_x86_vcpu_precreate)(kvm);</blue>
<blue>}</blue>

int kvm_arch_vcpu_create(struct kvm_vcpu *vcpu)
{
	struct page *page;
	int r;

<blue>	vcpu->arch.last_vmentry_cpu = -1;</blue>
	vcpu-&gt;arch.regs_avail = ~0;
	vcpu-&gt;arch.regs_dirty = ~0;

	kvm_gpc_init(&amp;vcpu-&gt;arch.pv_time);

<blue>	if (!irqchip_in_kernel(vcpu->kvm) || kvm_vcpu_is_reset_bsp(vcpu))</blue>
<blue>		vcpu->arch.mp_state = KVM_MP_STATE_RUNNABLE;</blue>
	else
		vcpu-&gt;arch.mp_state = KVM_MP_STATE_UNINITIALIZED;

	r = kvm_mmu_create(vcpu);
	if (r &lt; 0)
		return r;

<blue>	if (irqchip_in_kernel(vcpu->kvm)) {</blue>
<blue>		r = kvm_create_lapic(vcpu, lapic_timer_advance_ns);</blue>
		if (r &lt; 0)
			goto fail_mmu_destroy;

		/*
		 * Defer evaluating inhibits until the vCPU is first run, as
		 * this vCPU will not get notified of any changes until this
		 * vCPU is visible to other vCPUs (marked online and added to
		 * the set of vCPUs).  Opportunistically mark APICv active as
		 * VMX in particularly is highly unlikely to have inhibits.
		 * Ignore the current per-VM APICv state so that vCPU creation
		 * is guaranteed to run with a deterministic value, the request
		 * will ensure the vCPU gets the correct state before VM-Entry.
		 */
<blue>		if (enable_apicv) {</blue>
<blue>			vcpu->arch.apic->apicv_active = true;</blue>
			kvm_make_request(KVM_REQ_APICV_UPDATE, vcpu);
		}
	} else
<yellow>		static_branch_inc(&kvm_has_noapic_vcpu);</yellow>

	r = -ENOMEM;

<blue>	page = alloc_page(GFP_KERNEL_ACCOUNT | __GFP_ZERO);</blue>
	if (!page)
		goto fail_free_lapic;
<blue>	vcpu->arch.pio_data = page_address(page);</blue>

	vcpu-&gt;arch.mce_banks = kcalloc(KVM_MAX_MCE_BANKS * 4, sizeof(u64),
				       GFP_KERNEL_ACCOUNT);
	vcpu-&gt;arch.mci_ctl2_banks = kcalloc(KVM_MAX_MCE_BANKS, sizeof(u64),
					    GFP_KERNEL_ACCOUNT);
<blue>	if (!vcpu->arch.mce_banks || !vcpu->arch.mci_ctl2_banks)</blue>
		goto fail_free_mce_banks;
<blue>	vcpu->arch.mcg_cap = KVM_MAX_MCE_BANKS;</blue>

	if (!zalloc_cpumask_var(&amp;vcpu-&gt;arch.wbinvd_dirty_mask,
				GFP_KERNEL_ACCOUNT))
		goto fail_free_mce_banks;

<blue>	if (!alloc_emulate_ctxt(vcpu))</blue>
		goto free_wbinvd_dirty_mask;

	if (!fpu_alloc_guest_fpstate(&amp;vcpu-&gt;arch.guest_fpu)) {
		pr_err(&quot;kvm: failed to allocate vcpu&#x27;s fpu\n&quot;);
		goto free_emulate_ctxt;
	}

<blue>	vcpu->arch.maxphyaddr = cpuid_query_maxphyaddr(vcpu);</blue>
	vcpu-&gt;arch.reserved_gpa_bits = kvm_vcpu_reserved_gpa_bits_raw(vcpu);

	vcpu-&gt;arch.pat = MSR_IA32_CR_PAT_DEFAULT;

<blue>	kvm_async_pf_hash_reset(vcpu);</blue>
<blue>	kvm_pmu_init(vcpu);</blue>

	vcpu-&gt;arch.pending_external_vector = -1;
	vcpu-&gt;arch.preempted_in_kernel = false;

#if IS_ENABLED(CONFIG_HYPERV)
	vcpu-&gt;arch.hv_root_tdp = INVALID_PAGE;
#endif

	r = static_call(kvm_x86_vcpu_create)(vcpu);
	if (r)
		goto free_guest_fpu;

<blue>	vcpu->arch.arch_capabilities = kvm_get_arch_capabilities();</blue>
	vcpu-&gt;arch.msr_platform_info = MSR_PLATFORM_INFO_CPUID_FAULT;
	kvm_xen_init_vcpu(vcpu);
	kvm_vcpu_mtrr_init(vcpu);
	vcpu_load(vcpu);
	kvm_set_tsc_khz(vcpu, vcpu-&gt;kvm-&gt;arch.default_tsc_khz);
	kvm_vcpu_reset(vcpu, false);
	kvm_init_mmu(vcpu);
	vcpu_put(vcpu);
	return 0;

free_guest_fpu:
<yellow>	fpu_free_guest_fpstate(&vcpu->arch.guest_fpu);</yellow>
free_emulate_ctxt:
<yellow>	kmem_cache_free(x86_emulator_cache, vcpu->arch.emulate_ctxt);</yellow>
free_wbinvd_dirty_mask:
<yellow>	free_cpumask_var(vcpu->arch.wbinvd_dirty_mask);</yellow>
fail_free_mce_banks:
<yellow>	kfree(vcpu->arch.mce_banks);</yellow>
	kfree(vcpu-&gt;arch.mci_ctl2_banks);
	free_page((unsigned long)vcpu-&gt;arch.pio_data);
fail_free_lapic:
<yellow>	kvm_free_lapic(vcpu);</yellow>
fail_mmu_destroy:
<yellow>	kvm_mmu_destroy(vcpu);</yellow>
	return r;
<blue>}</blue>

void kvm_arch_vcpu_postcreate(struct kvm_vcpu *vcpu)
{
<blue>	struct kvm *kvm = vcpu->kvm;</blue>

	if (mutex_lock_killable(&amp;vcpu-&gt;mutex))
		return;
<blue>	vcpu_load(vcpu);</blue>
	kvm_synchronize_tsc(vcpu, 0);
	vcpu_put(vcpu);

	/* poll control enabled by default */
	vcpu-&gt;arch.msr_kvm_poll_control = 1;

	mutex_unlock(&amp;vcpu-&gt;mutex);

<blue>	if (kvmclock_periodic_sync && vcpu->vcpu_idx == 0)</blue>
<blue>		schedule_delayed_work(&kvm->arch.kvmclock_sync_work,</blue>
						KVMCLOCK_SYNC_PERIOD);
<blue>}</blue>

void kvm_arch_vcpu_destroy(struct kvm_vcpu *vcpu)
{
	int idx;

<yellow>	kvmclock_reset(vcpu);</yellow>

	static_call(kvm_x86_vcpu_free)(vcpu);

	kmem_cache_free(x86_emulator_cache, vcpu-&gt;arch.emulate_ctxt);
	free_cpumask_var(vcpu-&gt;arch.wbinvd_dirty_mask);
	fpu_free_guest_fpstate(&amp;vcpu-&gt;arch.guest_fpu);

	kvm_xen_destroy_vcpu(vcpu);
	kvm_hv_vcpu_uninit(vcpu);
	kvm_pmu_destroy(vcpu);
	kfree(vcpu-&gt;arch.mce_banks);
	kfree(vcpu-&gt;arch.mci_ctl2_banks);
	kvm_free_lapic(vcpu);
	idx = srcu_read_lock(&amp;vcpu-&gt;kvm-&gt;srcu);
	kvm_mmu_destroy(vcpu);
<yellow>	srcu_read_unlock(&vcpu->kvm->srcu, idx);</yellow>
	free_page((unsigned long)vcpu-&gt;arch.pio_data);
	kvfree(vcpu-&gt;arch.cpuid_entries);
<yellow>	if (!lapic_in_kernel(vcpu))</yellow>
<yellow>		static_branch_dec(&kvm_has_noapic_vcpu);</yellow>
<yellow>}</yellow>

void kvm_vcpu_reset(struct kvm_vcpu *vcpu, bool init_event)
<blue>{</blue>
	struct kvm_cpuid_entry2 *cpuid_0x1;
<blue>	unsigned long old_cr0 = kvm_read_cr0(vcpu);</blue>
	unsigned long new_cr0;

	/*
	 * Several of the &quot;set&quot; flows, e.g. -&gt;set_cr0(), read other registers
	 * to handle side effects.  RESET emulation hits those flows and relies
	 * on emulated/virtualized registers, including those that are loaded
	 * into hardware, to be zeroed at vCPU creation.  Use CRs as a sentinel
	 * to detect improper or missing initialization.
	 */
<blue>	WARN_ON_ONCE(!init_event &&</blue>
		     (old_cr0 || kvm_read_cr3(vcpu) || kvm_read_cr4(vcpu)));

	/*
	 * SVM doesn&#x27;t unconditionally VM-Exit on INIT and SHUTDOWN, thus it&#x27;s
	 * possible to INIT the vCPU while L2 is active.  Force the vCPU back
	 * into L1 as EFER.SVME is cleared on INIT (along with all other EFER
	 * bits), i.e. virtualization is disabled.
	 */
<blue>	if (is_guest_mode(vcpu))</blue>
<yellow>		kvm_leave_nested(vcpu);</yellow>

<blue>	kvm_lapic_reset(vcpu, init_event);</blue>

<yellow>	WARN_ON_ONCE(is_guest_mode(vcpu) || is_smm(vcpu));</yellow>
<blue>	vcpu->arch.hflags = 0;</blue>

	vcpu-&gt;arch.smi_pending = 0;
	vcpu-&gt;arch.smi_count = 0;
	atomic_set(&amp;vcpu-&gt;arch.nmi_queued, 0);
	vcpu-&gt;arch.nmi_pending = 0;
	vcpu-&gt;arch.nmi_injected = false;
	kvm_clear_interrupt_queue(vcpu);
	kvm_clear_exception_queue(vcpu);

	memset(vcpu-&gt;arch.db, 0, sizeof(vcpu-&gt;arch.db));
<blue>	kvm_update_dr0123(vcpu);</blue>
<yellow>	vcpu->arch.dr6 = DR6_ACTIVE_LOW;</yellow>
	vcpu-&gt;arch.dr7 = DR7_FIXED_1;
<yellow>	kvm_update_dr7(vcpu);</yellow>

<blue>	vcpu->arch.cr2 = 0;</blue>

	kvm_make_request(KVM_REQ_EVENT, vcpu);
	vcpu-&gt;arch.apf.msr_en_val = 0;
	vcpu-&gt;arch.apf.msr_int_val = 0;
	vcpu-&gt;arch.st.msr_val = 0;

	kvmclock_reset(vcpu);

	kvm_clear_async_pf_completion_queue(vcpu);
<blue>	kvm_async_pf_hash_reset(vcpu);</blue>
<blue>	vcpu->arch.apf.halted = false;</blue>

<blue>	if (vcpu->arch.guest_fpu.fpstate && kvm_mpx_supported()) {</blue>
		struct fpstate *fpstate = vcpu-&gt;arch.guest_fpu.fpstate;

		/*
		 * All paths that lead to INIT are required to load the guest&#x27;s
		 * FPU state (because most paths are buried in KVM_RUN).
		 */
<yellow>		if (init_event)</yellow>
<yellow>			kvm_put_guest_fpu(vcpu);</yellow>

<yellow>		fpstate_clear_xstate_component(fpstate, XFEATURE_BNDREGS);</yellow>
		fpstate_clear_xstate_component(fpstate, XFEATURE_BNDCSR);

		if (init_event)
<yellow>			kvm_load_guest_fpu(vcpu);</yellow>
	}

<blue>	if (!init_event) {</blue>
<blue>		kvm_pmu_reset(vcpu);</blue>
		vcpu-&gt;arch.smbase = 0x30000;

		vcpu-&gt;arch.msr_misc_features_enables = 0;
		vcpu-&gt;arch.ia32_misc_enable_msr = MSR_IA32_MISC_ENABLE_PEBS_UNAVAIL |
						  MSR_IA32_MISC_ENABLE_BTS_UNAVAIL;

<yellow>		__kvm_set_xcr(vcpu, 0, XFEATURE_MASK_FP);</yellow>
<blue>		__kvm_set_msr(vcpu, MSR_IA32_XSS, 0, true);</blue>
	}

	/* All GPRs except RDX (handled below) are zeroed on RESET/INIT. */
<blue>	memset(vcpu->arch.regs, 0, sizeof(vcpu->arch.regs));</blue>
	kvm_register_mark_dirty(vcpu, VCPU_REGS_RSP);

	/*
	 * Fall back to KVM&#x27;s default Family/Model/Stepping of 0x600 (P6/Athlon)
	 * if no CPUID match is found.  Note, it&#x27;s impossible to get a match at
	 * RESET since KVM emulates RESET before exposing the vCPU to userspace,
	 * i.e. it&#x27;s impossible for kvm_find_cpuid_entry() to find a valid entry
	 * on RESET.  But, go through the motions in case that&#x27;s ever remedied.
	 */
	cpuid_0x1 = kvm_find_cpuid_entry(vcpu, 1);
<blue>	kvm_rdx_write(vcpu, cpuid_0x1 ? cpuid_0x1->eax : 0x600);</blue>

	static_call(kvm_x86_vcpu_reset)(vcpu, init_event);

	kvm_set_rflags(vcpu, X86_EFLAGS_FIXED);
	kvm_rip_write(vcpu, 0xfff0);

	vcpu-&gt;arch.cr3 = 0;
	kvm_register_mark_dirty(vcpu, VCPU_EXREG_CR3);

	/*
	 * CR0.CD/NW are set on RESET, preserved on INIT.  Note, some versions
	 * of Intel&#x27;s SDM list CD/NW as being set on INIT, but they contradict
	 * (or qualify) that with a footnote stating that CD/NW are preserved.
	 */
	new_cr0 = X86_CR0_ET;
	if (init_event)
<yellow>		new_cr0 |= (old_cr0 & (X86_CR0_NW | X86_CR0_CD));</yellow>
	else
		new_cr0 |= X86_CR0_NW | X86_CR0_CD;

<blue>	static_call(kvm_x86_set_cr0)(vcpu, new_cr0);</blue>
	static_call(kvm_x86_set_cr4)(vcpu, 0);
	static_call(kvm_x86_set_efer)(vcpu, 0);
	static_call(kvm_x86_update_exception_bitmap)(vcpu);

	/*
	 * On the standard CR0/CR4/EFER modification paths, there are several
	 * complex conditions determining whether the MMU has to be reset and/or
	 * which PCIDs have to be flushed.  However, CR0.WP and the paging-related
	 * bits in CR4 and EFER are irrelevant if CR0.PG was &#x27;0&#x27;; and a reset+flush
	 * is needed anyway if CR0.PG was &#x27;1&#x27; (which can only happen for INIT, as
	 * CR0 will be &#x27;0&#x27; prior to RESET).  So we only need to check CR0.PG here.
	 */
	if (old_cr0 &amp; X86_CR0_PG) {
<yellow>		kvm_make_request(KVM_REQ_TLB_FLUSH_GUEST, vcpu);</yellow>
		kvm_mmu_reset_context(vcpu);
	}

	/*
	 * Intel&#x27;s SDM states that all TLB entries are flushed on INIT.  AMD&#x27;s
	 * APM states the TLBs are untouched by INIT, but it also states that
	 * the TLBs are flushed on &quot;External initialization of the processor.&quot;
	 * Flush the guest TLB regardless of vendor, there is no meaningful
	 * benefit in relying on the guest to flush the TLB immediately after
	 * INIT.  A spurious TLB flush is benign and likely negligible from a
	 * performance perspective.
	 */
	if (init_event)
<yellow>		kvm_make_request(KVM_REQ_TLB_FLUSH_GUEST, vcpu);</yellow>
}
EXPORT_SYMBOL_GPL(kvm_vcpu_reset);

void kvm_vcpu_deliver_sipi_vector(struct kvm_vcpu *vcpu, u8 vector)
{
	struct kvm_segment cs;

<yellow>	kvm_get_segment(vcpu, &cs, VCPU_SREG_CS);</yellow>
	cs.selector = vector &lt;&lt; 8;
	cs.base = vector &lt;&lt; 12;
	kvm_set_segment(vcpu, &amp;cs, VCPU_SREG_CS);
	kvm_rip_write(vcpu, 0);
}
EXPORT_SYMBOL_GPL(kvm_vcpu_deliver_sipi_vector);

int kvm_arch_hardware_enable(void)
<blue>{</blue>
	struct kvm *kvm;
	struct kvm_vcpu *vcpu;
	unsigned long i;
	int ret;
	u64 local_tsc;
	u64 max_tsc = 0;
	bool stable, backwards_tsc = false;

<blue>	kvm_user_return_msr_cpu_online();</blue>
<blue>	ret = static_call(kvm_x86_hardware_enable)();</blue>
	if (ret != 0)
		return ret;

<blue>	local_tsc = rdtsc();</blue>
<blue>	stable = !kvm_check_tsc_unstable();</blue>
<blue>	list_for_each_entry(kvm, &vm_list, vm_list) {</blue>
<yellow>		kvm_for_each_vcpu(i, vcpu, kvm) {</yellow>
<yellow>			if (!stable && vcpu->cpu == smp_processor_id())</yellow>
<yellow>				kvm_make_request(KVM_REQ_CLOCK_UPDATE, vcpu);</yellow>
<yellow>			if (stable && vcpu->arch.last_host_tsc > local_tsc) {</yellow>
				backwards_tsc = true;
<yellow>				if (vcpu->arch.last_host_tsc > max_tsc)</yellow>
					max_tsc = vcpu-&gt;arch.last_host_tsc;
			}
		}
	}

	/*
	 * Sometimes, even reliable TSCs go backwards.  This happens on
	 * platforms that reset TSC during suspend or hibernate actions, but
	 * maintain synchronization.  We must compensate.  Fortunately, we can
	 * detect that condition here, which happens early in CPU bringup,
	 * before any KVM threads can be running.  Unfortunately, we can&#x27;t
	 * bring the TSCs fully up to date with real time, as we aren&#x27;t yet far
	 * enough into CPU bringup that we know how much real time has actually
	 * elapsed; our helper function, ktime_get_boottime_ns() will be using boot
	 * variables that haven&#x27;t been updated yet.
	 *
	 * So we simply find the maximum observed TSC above, then record the
	 * adjustment to TSC in each VCPU.  When the VCPU later gets loaded,
	 * the adjustment will be applied.  Note that we accumulate
	 * adjustments, in case multiple suspend cycles happen before some VCPU
	 * gets a chance to run again.  In the event that no KVM threads get a
	 * chance to run, we will miss the entire elapsed period, as we&#x27;ll have
	 * reset last_host_tsc, so VCPUs will not have the TSC adjusted and may
	 * loose cycle time.  This isn&#x27;t too big a deal, since the loss will be
	 * uniform across all VCPUs (not to mention the scenario is extremely
	 * unlikely). It is possible that a second hibernate recovery happens
	 * much faster than a first, causing the observed TSC here to be
	 * smaller; this would require additional padding adjustment, which is
	 * why we set last_host_tsc to the local tsc observed here.
	 *
	 * N.B. - this code below runs only on platforms with reliable TSC,
	 * as that is the only way backwards_tsc is set above.  Also note
	 * that this runs for ALL vcpus, which is not a bug; all VCPUs should
	 * have the same delta_cyc adjustment applied if backwards_tsc
	 * is detected.  Note further, this adjustment is only done once,
	 * as we reset last_host_tsc on all VCPUs to stop this from being
	 * called multiple times (one for each physical CPU bringup).
	 *
	 * Platforms with unreliable TSCs don&#x27;t have to deal with this, they
	 * will be compensated by the logic in vcpu_load, which sets the TSC to
	 * catchup mode.  This will catchup all VCPUs to real time, but cannot
	 * guarantee that they stay in perfect synchronization.
	 */
<yellow>	if (backwards_tsc) {</yellow>
<yellow>		u64 delta_cyc = max_tsc - local_tsc;</yellow>
		list_for_each_entry(kvm, &amp;vm_list, vm_list) {
<yellow>			kvm->arch.backwards_tsc_observed = true;</yellow>
			kvm_for_each_vcpu(i, vcpu, kvm) {
<yellow>				vcpu->arch.tsc_offset_adjustment += delta_cyc;</yellow>
				vcpu-&gt;arch.last_host_tsc = local_tsc;
				kvm_make_request(KVM_REQ_MASTERCLOCK_UPDATE, vcpu);
			}

			/*
			 * We have to disable TSC offset matching.. if you were
			 * booting a VM while issuing an S4 host suspend....
			 * you may have some problem.  Solving this issue is
			 * left as an exercise to the reader.
			 */
<yellow>			kvm->arch.last_tsc_nsec = 0;</yellow>
			kvm-&gt;arch.last_tsc_write = 0;
		}

	}
	return 0;
}

void kvm_arch_hardware_disable(void)
{
<yellow>	static_call(kvm_x86_hardware_disable)();</yellow>
<yellow>	drop_user_return_notifiers();</yellow>
<yellow>}</yellow>

static inline void kvm_ops_update(struct kvm_x86_init_ops *ops)
{
<yellow>	memcpy(&kvm_x86_ops, ops->runtime_ops, sizeof(kvm_x86_ops));</yellow>

#define __KVM_X86_OP(func) \
	static_call_update(kvm_x86_##func, kvm_x86_ops.func);
#define KVM_X86_OP(func) \
	WARN_ON(!kvm_x86_ops.func); __KVM_X86_OP(func)
#define KVM_X86_OP_OPTIONAL __KVM_X86_OP
#define KVM_X86_OP_OPTIONAL_RET0(func) \
	static_call_update(kvm_x86_##func, (void *)kvm_x86_ops.func ? : \
					   (void *)__static_call_return0);
#include &lt;asm/kvm-x86-ops.h&gt;
#undef __KVM_X86_OP

	kvm_pmu_ops_update(ops-&gt;pmu_ops);
}

int kvm_arch_hardware_setup(void *opaque)
<yellow>{</yellow>
	struct kvm_x86_init_ops *ops = opaque;
	int r;

<yellow>	rdmsrl_safe(MSR_EFER, &host_efer);</yellow>

	if (boot_cpu_has(X86_FEATURE_XSAVES))
<yellow>		rdmsrl(MSR_IA32_XSS, host_xss);</yellow>

<yellow>	kvm_init_pmu_capability();</yellow>

<yellow>	r = ops->hardware_setup();</yellow>
	if (r != 0)
		return r;

<yellow>	kvm_ops_update(ops);</yellow>

	kvm_register_perf_callbacks(ops-&gt;handle_intel_pt_intr);

	if (!kvm_cpu_cap_has(X86_FEATURE_XSAVES))
<yellow>		kvm_caps.supported_xss = 0;</yellow>

#define __kvm_cpu_cap_has(UNUSED_, f) kvm_cpu_cap_has(f)
<yellow>	cr4_reserved_bits = __cr4_reserved_bits(__kvm_cpu_cap_has, UNUSED_);</yellow>
#undef __kvm_cpu_cap_has

<yellow>	if (kvm_caps.has_tsc_control) {</yellow>
		/*
		 * Make sure the user can only configure tsc_khz values that
		 * fit into a signed integer.
		 * A min value is not calculated because it will always
		 * be 1 on all machines.
		 */
<yellow>		u64 max = min(0x7fffffffULL,</yellow>
			      __scale_tsc(kvm_caps.max_tsc_scaling_ratio, tsc_khz));
		kvm_caps.max_guest_tsc_khz = max;
	}
<yellow>	kvm_caps.default_tsc_scaling_ratio = 1ULL << kvm_caps.tsc_scaling_ratio_frac_bits;</yellow>
<yellow>	kvm_init_msr_list();</yellow>
	return 0;
}

void kvm_arch_hardware_unsetup(void)
{
<yellow>	kvm_unregister_perf_callbacks();</yellow>

	static_call(kvm_x86_hardware_unsetup)();
}

int kvm_arch_check_processor_compat(void *opaque)
{
<yellow>	struct cpuinfo_x86 *c = &cpu_data(smp_processor_id());</yellow>
	struct kvm_x86_init_ops *ops = opaque;

<yellow>	WARN_ON(!irqs_disabled());</yellow>

<yellow>	if (__cr4_reserved_bits(cpu_has, c) !=</yellow>
<yellow>	    __cr4_reserved_bits(cpu_has, &boot_cpu_data))</yellow>
		return -EIO;

<yellow>	return ops->check_processor_compatibility();</yellow>
<yellow>}</yellow>

bool kvm_vcpu_is_reset_bsp(struct kvm_vcpu *vcpu)
{
<blue>	return vcpu->kvm->arch.bsp_vcpu_id == vcpu->vcpu_id;</blue>
}
EXPORT_SYMBOL_GPL(kvm_vcpu_is_reset_bsp);

bool kvm_vcpu_is_bsp(struct kvm_vcpu *vcpu)
{
<yellow>	return (vcpu->arch.apic_base & MSR_IA32_APICBASE_BSP) != 0;</yellow>
}

__read_mostly DEFINE_STATIC_KEY_FALSE(kvm_has_noapic_vcpu);
EXPORT_SYMBOL_GPL(kvm_has_noapic_vcpu);

void kvm_arch_sched_in(struct kvm_vcpu *vcpu, int cpu)
{
	struct kvm_pmu *pmu = vcpu_to_pmu(vcpu);

<blue>	vcpu->arch.l1tf_flush_l1d = true;</blue>
<blue>	if (pmu->version && unlikely(pmu->event_count)) {</blue>
<yellow>		pmu->need_cleanup = true;</yellow>
		kvm_make_request(KVM_REQ_PMU, vcpu);
	}
<blue>	static_call(kvm_x86_sched_in)(vcpu, cpu);</blue>
}

void kvm_arch_free_vm(struct kvm *kvm)
{
<yellow>	kfree(to_kvm_hv(kvm)->hv_pa_pg);</yellow>
	__kvm_arch_free_vm(kvm);
}


int kvm_arch_init_vm(struct kvm *kvm, unsigned long type)
{
	int ret;
	unsigned long flags;

<blue>	if (type)</blue>
		return -EINVAL;

<blue>	ret = kvm_page_track_init(kvm);</blue>
	if (ret)
		goto out;

<blue>	ret = kvm_mmu_init_vm(kvm);</blue>
	if (ret)
		goto out_page_track;

<blue>	ret = static_call(kvm_x86_vm_init)(kvm);</blue>
	if (ret)
		goto out_uninit_mmu;

<blue>	INIT_HLIST_HEAD(&kvm->arch.mask_notifier_list);</blue>
	INIT_LIST_HEAD(&amp;kvm-&gt;arch.assigned_dev_head);
	atomic_set(&amp;kvm-&gt;arch.noncoherent_dma_count, 0);

	/* Reserve bit 0 of irq_sources_bitmap for userspace irq source */
	set_bit(KVM_USERSPACE_IRQ_SOURCE_ID, &amp;kvm-&gt;arch.irq_sources_bitmap);
	/* Reserve bit 1 of irq_sources_bitmap for irqfd-resampler */
	set_bit(KVM_IRQFD_RESAMPLE_IRQ_SOURCE_ID,
		&amp;kvm-&gt;arch.irq_sources_bitmap);

	raw_spin_lock_init(&amp;kvm-&gt;arch.tsc_write_lock);
	mutex_init(&amp;kvm-&gt;arch.apic_map_lock);
	seqcount_raw_spinlock_init(&amp;kvm-&gt;arch.pvclock_sc, &amp;kvm-&gt;arch.tsc_write_lock);
	kvm-&gt;arch.kvmclock_offset = -get_kvmclock_base_ns();

	raw_spin_lock_irqsave(&amp;kvm-&gt;arch.tsc_write_lock, flags);
	pvclock_update_vm_gtod_copy(kvm);
	raw_spin_unlock_irqrestore(&amp;kvm-&gt;arch.tsc_write_lock, flags);

<blue>	kvm->arch.default_tsc_khz = max_tsc_khz ? : tsc_khz;</blue>
	kvm-&gt;arch.guest_can_read_msr_platform_info = true;
<blue>	kvm->arch.enable_pmu = enable_pmu;</blue>

#if IS_ENABLED(CONFIG_HYPERV)
	spin_lock_init(&amp;kvm-&gt;arch.hv_root_tdp_lock);
	kvm-&gt;arch.hv_root_tdp = INVALID_PAGE;
#endif

	INIT_DELAYED_WORK(&amp;kvm-&gt;arch.kvmclock_update_work, kvmclock_update_fn);
	INIT_DELAYED_WORK(&amp;kvm-&gt;arch.kvmclock_sync_work, kvmclock_sync_fn);

<blue>	kvm_apicv_init(kvm);</blue>
<blue>	kvm_hv_init_vm(kvm);</blue>
	kvm_xen_init_vm(kvm);

	return 0;

out_uninit_mmu:
<yellow>	kvm_mmu_uninit_vm(kvm);</yellow>
out_page_track:
<yellow>	kvm_page_track_cleanup(kvm);</yellow>
out:
	return ret;
<blue>}</blue>

int kvm_arch_post_init_vm(struct kvm *kvm)
{
<blue>	return kvm_mmu_post_init_vm(kvm);</blue>
}

static void kvm_unload_vcpu_mmu(struct kvm_vcpu *vcpu)
{
	vcpu_load(vcpu);
	kvm_mmu_unload(vcpu);
	vcpu_put(vcpu);
}

static void kvm_unload_vcpu_mmus(struct kvm *kvm)
{
	unsigned long i;
	struct kvm_vcpu *vcpu;

<yellow>	kvm_for_each_vcpu(i, vcpu, kvm) {</yellow>
<yellow>		kvm_clear_async_pf_completion_queue(vcpu);</yellow>
		kvm_unload_vcpu_mmu(vcpu);
	}
}

void kvm_arch_sync_events(struct kvm *kvm)
{
<yellow>	cancel_delayed_work_sync(&kvm->arch.kvmclock_sync_work);</yellow>
	cancel_delayed_work_sync(&amp;kvm-&gt;arch.kvmclock_update_work);
	kvm_free_pit(kvm);
}

/**
 * __x86_set_memory_region: Setup KVM internal memory slot
 *
 * @kvm: the kvm pointer to the VM.
 * @id: the slot ID to setup.
 * @gpa: the GPA to install the slot (unused when @size == 0).
 * @size: the size of the slot. Set to zero to uninstall a slot.
 *
 * This function helps to setup a KVM internal memory slot.  Specify
 * @size &gt; 0 to install a new slot, while @size == 0 to uninstall a
 * slot.  The return code can be one of the following:
 *
 *   HVA:           on success (uninstall will return a bogus HVA)
 *   -errno:        on error
 *
 * The caller should always use IS_ERR() to check the return value
 * before use.  Note, the KVM internal memory slots are guaranteed to
 * remain valid and unchanged until the VM is destroyed, i.e., the
 * GPA-&gt;HVA translation will not change.  However, the HVA is a user
 * address, i.e. its accessibility is not guaranteed, and must be
 * accessed via __copy_{to,from}_user().
 */
void __user * __x86_set_memory_region(struct kvm *kvm, int id, gpa_t gpa,
				      u32 size)
<blue>{</blue>
	int i, r;
	unsigned long hva, old_npages;
<blue>	struct kvm_memslots *slots = kvm_memslots(kvm);</blue>
	struct kvm_memory_slot *slot;

	/* Called with kvm-&gt;slots_lock held.  */
<yellow>	if (WARN_ON(id >= KVM_MEM_SLOTS_NUM))</yellow>
		return ERR_PTR_USR(-EINVAL);

<blue>	slot = id_to_memslot(slots, id);</blue>
<blue>	if (size) {</blue>
<yellow>		if (slot && slot->npages)</yellow>
			return ERR_PTR_USR(-EEXIST);

		/*
		 * MAP_SHARED to prevent internal slot pages from being moved
		 * by fork()/COW.
		 */
<blue>		hva = vm_mmap(NULL, 0, size, PROT_READ | PROT_WRITE,</blue>
			      MAP_SHARED | MAP_ANONYMOUS, 0);
		if (IS_ERR((void *)hva))
			return (void __user *)hva;
	} else {
<yellow>		if (!slot || !slot->npages)</yellow>
			return NULL;

		old_npages = slot-&gt;npages;
<yellow>		hva = slot->userspace_addr;</yellow>
	}

	for (i = 0; i &lt; KVM_ADDRESS_SPACE_NUM; i++) {
		struct kvm_userspace_memory_region m;

		m.slot = id | (i &lt;&lt; 16);
		m.flags = 0;
<blue>		m.guest_phys_addr = gpa;</blue>
		m.userspace_addr = hva;
		m.memory_size = size;
<blue>		r = __kvm_set_memory_region(kvm, &m);</blue>
		if (r &lt; 0)
<yellow>			return ERR_PTR_USR(r);</yellow>
	}

<blue>	if (!size)</blue>
<yellow>		vm_munmap(hva, old_npages * PAGE_SIZE);</yellow>

<blue>	return (void __user *)hva;</blue>
}
EXPORT_SYMBOL_GPL(__x86_set_memory_region);

void kvm_arch_pre_destroy_vm(struct kvm *kvm)
{
<yellow>	kvm_mmu_pre_destroy_vm(kvm);</yellow>
}

void kvm_arch_destroy_vm(struct kvm *kvm)
{
<yellow>	if (current->mm == kvm->mm) {</yellow>
		/*
		 * Free memory regions allocated on behalf of userspace,
		 * unless the memory map has changed due to process exit
		 * or fd copying.
		 */
<yellow>		mutex_lock(&kvm->slots_lock);</yellow>
		__x86_set_memory_region(kvm, APIC_ACCESS_PAGE_PRIVATE_MEMSLOT,
					0, 0);
		__x86_set_memory_region(kvm, IDENTITY_PAGETABLE_PRIVATE_MEMSLOT,
					0, 0);
		__x86_set_memory_region(kvm, TSS_PRIVATE_MEMSLOT, 0, 0);
		mutex_unlock(&amp;kvm-&gt;slots_lock);
	}
<yellow>	kvm_unload_vcpu_mmus(kvm);</yellow>
<yellow>	static_call_cond(kvm_x86_vm_destroy)(kvm);</yellow>
<yellow>	kvm_free_msr_filter(srcu_dereference_check(kvm->arch.msr_filter, &kvm->srcu, 1));</yellow>
<yellow>	kvm_pic_destroy(kvm);</yellow>
	kvm_ioapic_destroy(kvm);
	kvm_destroy_vcpus(kvm);
	kvfree(rcu_dereference_check(kvm-&gt;arch.apic_map, 1));
	kfree(srcu_dereference_check(kvm-&gt;arch.pmu_event_filter, &amp;kvm-&gt;srcu, 1));
	kvm_mmu_uninit_vm(kvm);
	kvm_page_track_cleanup(kvm);
	kvm_xen_destroy_vm(kvm);
	kvm_hv_destroy_vm(kvm);
}

static void memslot_rmap_free(struct kvm_memory_slot *slot)
{
	int i;

	for (i = 0; i &lt; KVM_NR_PAGE_SIZES; ++i) {
<blue>		kvfree(slot->arch.rmap[i]);</blue>
		slot-&gt;arch.rmap[i] = NULL;
	}
}

void kvm_arch_free_memslot(struct kvm *kvm, struct kvm_memory_slot *slot)
{
	int i;

<blue>	memslot_rmap_free(slot);</blue>

	for (i = 1; i &lt; KVM_NR_PAGE_SIZES; ++i) {
<blue>		kvfree(slot->arch.lpage_info[i - 1]);</blue>
		slot-&gt;arch.lpage_info[i - 1] = NULL;
	}

	kvm_page_track_free_memslot(slot);
}

int memslot_rmap_alloc(struct kvm_memory_slot *slot, unsigned long npages)
<blue>{</blue>
	const int sz = sizeof(*slot-&gt;arch.rmap[0]);
	int i;

<blue>	for (i = 0; i < KVM_NR_PAGE_SIZES; ++i) {</blue>
<blue>		int level = i + 1;</blue>
<blue>		int lpages = __kvm_mmu_slot_lpages(slot, npages, level);</blue>

		if (slot-&gt;arch.rmap[i])
			continue;

		slot-&gt;arch.rmap[i] = __vcalloc(lpages, sz, GFP_KERNEL_ACCOUNT);
		if (!slot-&gt;arch.rmap[i]) {
<yellow>			memslot_rmap_free(slot);</yellow>
			return -ENOMEM;
		}
	}

	return 0;
<blue>}</blue>

static int kvm_alloc_memslot_metadata(struct kvm *kvm,
				      struct kvm_memory_slot *slot)
{
<blue>	unsigned long npages = slot->npages;</blue>
	int i, r;

	/*
	 * Clear out the previous array pointers for the KVM_MR_MOVE case.  The
	 * old arrays will be freed by __kvm_set_memory_region() if installing
	 * the new memslot is successful.
	 */
	memset(&amp;slot-&gt;arch, 0, sizeof(slot-&gt;arch));

<blue>	if (kvm_memslots_have_rmaps(kvm)) {</blue>
<yellow>		r = memslot_rmap_alloc(slot, npages);</yellow>
<blue>		if (r)</blue>
			return r;
	}

<blue>	for (i = 1; i < KVM_NR_PAGE_SIZES; ++i) {</blue>
		struct kvm_lpage_info *linfo;
		unsigned long ugfn;
		int lpages;
<blue>		int level = i + 1;</blue>

		lpages = __kvm_mmu_slot_lpages(slot, npages, level);

		linfo = __vcalloc(lpages, sizeof(*linfo), GFP_KERNEL_ACCOUNT);
		if (!linfo)
			goto out_free;

<blue>		slot->arch.lpage_info[i - 1] = linfo;</blue>

		if (slot-&gt;base_gfn &amp; (KVM_PAGES_PER_HPAGE(level) - 1))
<blue>			linfo[0].disallow_lpage = 1;</blue>
<blue>		if ((slot->base_gfn + npages) & (KVM_PAGES_PER_HPAGE(level) - 1))</blue>
<blue>			linfo[lpages - 1].disallow_lpage = 1;</blue>
<blue>		ugfn = slot->userspace_addr >> PAGE_SHIFT;</blue>
		/*
		 * If the gfn and userspace address are not aligned wrt each
		 * other, disable large page support for this slot.
		 */
		if ((slot-&gt;base_gfn ^ ugfn) &amp; (KVM_PAGES_PER_HPAGE(level) - 1)) {
			unsigned long j;

<blue>			for (j = 0; j < lpages; ++j)</blue>
<blue>				linfo[j].disallow_lpage = 1;</blue>
		}
	}

<blue>	if (kvm_page_track_create_memslot(kvm, slot, npages))</blue>
		goto out_free;

	return 0;

out_free:
<yellow>	memslot_rmap_free(slot);</yellow>

	for (i = 1; i &lt; KVM_NR_PAGE_SIZES; ++i) {
<yellow>		kvfree(slot->arch.lpage_info[i - 1]);</yellow>
		slot-&gt;arch.lpage_info[i - 1] = NULL;
	}
	return -ENOMEM;
}

void kvm_arch_memslots_updated(struct kvm *kvm, u64 gen)
<blue>{</blue>
	struct kvm_vcpu *vcpu;
	unsigned long i;

	/*
	 * memslots-&gt;generation has been incremented.
	 * mmio generation may have reached its maximum value.
	 */
<blue>	kvm_mmu_invalidate_mmio_sptes(kvm, gen);</blue>

	/* Force re-initialization of steal_time cache */
	kvm_for_each_vcpu(i, vcpu, kvm)
<blue>		kvm_vcpu_kick(vcpu);</blue>
}

int kvm_arch_prepare_memory_region(struct kvm *kvm,
				   const struct kvm_memory_slot *old,
				   struct kvm_memory_slot *new,
				   enum kvm_mr_change change)
{
<blue>	if (change == KVM_MR_CREATE || change == KVM_MR_MOVE) {</blue>
<blue>		if ((new->base_gfn + new->npages - 1) > kvm_mmu_max_gfn())</blue>
			return -EINVAL;

<blue>		return kvm_alloc_memslot_metadata(kvm, new);</blue>
	}

<blue>	if (change == KVM_MR_FLAGS_ONLY)</blue>
<yellow>		memcpy(&new->arch, &old->arch, sizeof(old->arch));</yellow>
<blue>	else if (WARN_ON_ONCE(change != KVM_MR_DELETE))</blue>
		return -EIO;

	return 0;
<blue>}</blue>


static void kvm_mmu_update_cpu_dirty_logging(struct kvm *kvm, bool enable)
{
	struct kvm_arch *ka = &amp;kvm-&gt;arch;

<yellow>	if (!kvm_x86_ops.cpu_dirty_log_size)</yellow>
		return;

<yellow>	if ((enable && ++ka->cpu_dirty_logging_count == 1) ||</yellow>
<yellow>	    (!enable && --ka->cpu_dirty_logging_count == 0))</yellow>
<yellow>		kvm_make_all_cpus_request(kvm, KVM_REQ_UPDATE_CPU_DIRTY_LOGGING);</yellow>

<yellow>	WARN_ON_ONCE(ka->cpu_dirty_logging_count < 0);</yellow>
}

static void kvm_mmu_slot_apply_flags(struct kvm *kvm,
				     struct kvm_memory_slot *old,
				     const struct kvm_memory_slot *new,
				     enum kvm_mr_change change)
{
<blue>	u32 old_flags = old ? old->flags : 0;</blue>
<blue>	u32 new_flags = new ? new->flags : 0;</blue>
	bool log_dirty_pages = new_flags &amp; KVM_MEM_LOG_DIRTY_PAGES;

	/*
	 * Update CPU dirty logging if dirty logging is being toggled.  This
	 * applies to all operations.
	 */
<blue>	if ((old_flags ^ new_flags) & KVM_MEM_LOG_DIRTY_PAGES)</blue>
<yellow>		kvm_mmu_update_cpu_dirty_logging(kvm, log_dirty_pages);</yellow>

	/*
	 * Nothing more to do for RO slots (which can&#x27;t be dirtied and can&#x27;t be
	 * made writable) or CREATE/MOVE/DELETE of a slot.
	 *
	 * For a memslot with dirty logging disabled:
	 * CREATE:      No dirty mappings will already exist.
	 * MOVE/DELETE: The old mappings will already have been cleaned up by
	 *		kvm_arch_flush_shadow_memslot()
	 *
	 * For a memslot with dirty logging enabled:
	 * CREATE:      No shadow pages exist, thus nothing to write-protect
	 *		and no dirty bits to clear.
	 * MOVE/DELETE: The old mappings will already have been cleaned up by
	 *		kvm_arch_flush_shadow_memslot().
	 */
<blue>	if ((change != KVM_MR_FLAGS_ONLY) || (new_flags & KVM_MEM_READONLY))</blue>
		return;

	/*
	 * READONLY and non-flags changes were filtered out above, and the only
	 * other flag is LOG_DIRTY_PAGES, i.e. something is wrong if dirty
	 * logging isn&#x27;t being toggled on or off.
	 */
<yellow>	if (WARN_ON_ONCE(!((old_flags ^ new_flags) & KVM_MEM_LOG_DIRTY_PAGES)))</yellow>
		return;

<yellow>	if (!log_dirty_pages) {</yellow>
		/*
		 * Dirty logging tracks sptes in 4k granularity, meaning that
		 * large sptes have to be split.  If live migration succeeds,
		 * the guest in the source machine will be destroyed and large
		 * sptes will be created in the destination.  However, if the
		 * guest continues to run in the source machine (for example if
		 * live migration fails), small sptes will remain around and
		 * cause bad performance.
		 *
		 * Scan sptes if dirty logging has been stopped, dropping those
		 * which can be collapsed into a single large-page spte.  Later
		 * page faults will create the large-page sptes.
		 */
<yellow>		kvm_mmu_zap_collapsible_sptes(kvm, new);</yellow>
	} else {
		/*
		 * Initially-all-set does not require write protecting any page,
		 * because they&#x27;re all assumed to be dirty.
		 */
<yellow>		if (kvm_dirty_log_manual_protect_and_init_set(kvm))</yellow>
			return;

<yellow>		if (READ_ONCE(eager_page_split))</yellow>
<yellow>			kvm_mmu_slot_try_split_huge_pages(kvm, new, PG_LEVEL_4K);</yellow>

<yellow>		if (kvm_x86_ops.cpu_dirty_log_size) {</yellow>
<yellow>			kvm_mmu_slot_leaf_clear_dirty(kvm, new);</yellow>
			kvm_mmu_slot_remove_write_access(kvm, new, PG_LEVEL_2M);
		} else {
<yellow>			kvm_mmu_slot_remove_write_access(kvm, new, PG_LEVEL_4K);</yellow>
		}

		/*
		 * Unconditionally flush the TLBs after enabling dirty logging.
		 * A flush is almost always going to be necessary (see below),
		 * and unconditionally flushing allows the helpers to omit
		 * the subtly complex checks when removing write access.
		 *
		 * Do the flush outside of mmu_lock to reduce the amount of
		 * time mmu_lock is held.  Flushing after dropping mmu_lock is
		 * safe as KVM only needs to guarantee the slot is fully
		 * write-protected before returning to userspace, i.e. before
		 * userspace can consume the dirty status.
		 *
		 * Flushing outside of mmu_lock requires KVM to be careful when
		 * making decisions based on writable status of an SPTE, e.g. a
		 * !writable SPTE doesn&#x27;t guarantee a CPU can&#x27;t perform writes.
		 *
		 * Specifically, KVM also write-protects guest page tables to
		 * monitor changes when using shadow paging, and must guarantee
		 * no CPUs can write to those page before mmu_lock is dropped.
		 * Because CPUs may have stale TLB entries at this point, a
		 * !writable SPTE doesn&#x27;t guarantee CPUs can&#x27;t perform writes.
		 *
		 * KVM also allows making SPTES writable outside of mmu_lock,
		 * e.g. to allow dirty logging without taking mmu_lock.
		 *
		 * To handle these scenarios, KVM uses a separate software-only
		 * bit (MMU-writable) to track if a SPTE is !writable due to
		 * a guest page table being write-protected (KVM clears the
		 * MMU-writable flag when write-protecting for shadow paging).
		 *
		 * The use of MMU-writable is also the primary motivation for
		 * the unconditional flush.  Because KVM must guarantee that a
		 * CPU doesn&#x27;t contain stale, writable TLB entries for a
		 * !MMU-writable SPTE, KVM must flush if it encounters any
		 * MMU-writable SPTE regardless of whether the actual hardware
		 * writable bit was set.  I.e. KVM is almost guaranteed to need
		 * to flush, while unconditionally flushing allows the &quot;remove
		 * write access&quot; helpers to ignore MMU-writable entirely.
		 *
		 * See is_writable_pte() for more details (the case involving
		 * access-tracked SPTEs is particularly relevant).
		 */
<yellow>		kvm_arch_flush_remote_tlbs_memslot(kvm, new);</yellow>
	}
}

void kvm_arch_commit_memory_region(struct kvm *kvm,
				struct kvm_memory_slot *old,
				const struct kvm_memory_slot *new,
				enum kvm_mr_change change)
{
<blue>	if (!kvm->arch.n_requested_mmu_pages &&</blue>
	    (change == KVM_MR_CREATE || change == KVM_MR_DELETE)) {
		unsigned long nr_mmu_pages;

<blue>		nr_mmu_pages = kvm->nr_memslot_pages / KVM_MEMSLOT_PAGES_TO_MMU_PAGES_RATIO;</blue>
		nr_mmu_pages = max(nr_mmu_pages, KVM_MIN_ALLOC_MMU_PAGES);
		kvm_mmu_change_mmu_pages(kvm, nr_mmu_pages);
	}

<blue>	kvm_mmu_slot_apply_flags(kvm, old, new, change);</blue>

	/* Free the arrays associated with the old memslot. */
<blue>	if (change == KVM_MR_MOVE)</blue>
<yellow>		kvm_arch_free_memslot(kvm, old);</yellow>
<blue>}</blue>

void kvm_arch_flush_shadow_all(struct kvm *kvm)
{
<yellow>	kvm_mmu_zap_all(kvm);</yellow>
}

void kvm_arch_flush_shadow_memslot(struct kvm *kvm,
				   struct kvm_memory_slot *slot)
{
<blue>	kvm_page_track_flush_slot(kvm, slot);</blue>
}

static inline bool kvm_guest_apic_has_interrupt(struct kvm_vcpu *vcpu)
{
<blue>	return (is_guest_mode(vcpu) &&</blue>
<blue>		static_call(kvm_x86_guest_apic_has_interrupt)(vcpu));</blue>
}

static inline bool kvm_vcpu_has_events(struct kvm_vcpu *vcpu)
{
<blue>	if (!list_empty_careful(&vcpu->async_pf.done))</blue>
		return true;

<blue>	if (kvm_apic_has_pending_init_or_sipi(vcpu) &&</blue>
<yellow>	    kvm_apic_init_sipi_allowed(vcpu))</yellow>
		return true;

<blue>	if (vcpu->arch.pv.pv_unhalted)</blue>
		return true;

<blue>	if (kvm_is_exception_pending(vcpu))</blue>
		return true;

<blue>	if (kvm_test_request(KVM_REQ_NMI, vcpu) ||</blue>
<blue>	    (vcpu->arch.nmi_pending &&</blue>
<yellow>	     static_call(kvm_x86_nmi_allowed)(vcpu, false)))</yellow>
		return true;

<blue>	if (kvm_test_request(KVM_REQ_SMI, vcpu) ||</blue>
<blue>	    (vcpu->arch.smi_pending &&</blue>
<yellow>	     static_call(kvm_x86_smi_allowed)(vcpu, false)))</yellow>
		return true;

<blue>	if (kvm_arch_interrupt_allowed(vcpu) &&</blue>
<blue>	    (kvm_cpu_has_interrupt(vcpu) ||</blue>
<blue>	    kvm_guest_apic_has_interrupt(vcpu)))</blue>
		return true;

<blue>	if (kvm_hv_has_stimer_pending(vcpu))</blue>
		return true;

<blue>	if (is_guest_mode(vcpu) &&</blue>
<blue>	    kvm_x86_ops.nested_ops->has_events &&</blue>
<blue>	    kvm_x86_ops.nested_ops->has_events(vcpu))</blue>
		return true;

<blue>	if (kvm_xen_has_pending_events(vcpu))</blue>
		return true;

	return false;
<blue>}</blue>

<blue>int kvm_arch_vcpu_runnable(struct kvm_vcpu *vcpu)</blue>
{
<blue>	return kvm_vcpu_running(vcpu) || kvm_vcpu_has_events(vcpu);</blue>
<blue>}</blue>

<yellow>bool kvm_arch_dy_has_pending_interrupt(struct kvm_vcpu *vcpu)</yellow>
{
<yellow>	if (kvm_vcpu_apicv_active(vcpu) &&</yellow>
<yellow>	    static_call(kvm_x86_dy_apicv_has_pending_interrupt)(vcpu))</yellow>
		return true;

<yellow>	return false;</yellow>
<yellow>}</yellow>

bool kvm_arch_dy_runnable(struct kvm_vcpu *vcpu)
{
<yellow>	if (READ_ONCE(vcpu->arch.pv.pv_unhalted))</yellow>
		return true;

<yellow>	if (kvm_test_request(KVM_REQ_NMI, vcpu) ||</yellow>
<yellow>		kvm_test_request(KVM_REQ_SMI, vcpu) ||</yellow>
<yellow>		 kvm_test_request(KVM_REQ_EVENT, vcpu))</yellow>
		return true;

<yellow>	return kvm_arch_dy_has_pending_interrupt(vcpu);</yellow>
<yellow>}</yellow>

bool kvm_arch_vcpu_in_kernel(struct kvm_vcpu *vcpu)
{
<yellow>	if (vcpu->arch.guest_state_protected)</yellow>
		return true;

<yellow>	return vcpu->arch.preempted_in_kernel;</yellow>
<yellow>}</yellow>

unsigned long kvm_arch_vcpu_get_ip(struct kvm_vcpu *vcpu)
{
<yellow>	return kvm_rip_read(vcpu);</yellow>
}

int kvm_arch_vcpu_should_kick(struct kvm_vcpu *vcpu)
{
<blue>	return kvm_vcpu_exiting_guest_mode(vcpu) == IN_GUEST_MODE;</blue>
}

int kvm_arch_interrupt_allowed(struct kvm_vcpu *vcpu)
{
<blue>	return static_call(kvm_x86_interrupt_allowed)(vcpu, false);</blue>
}

<yellow>unsigned long kvm_get_linear_rip(struct kvm_vcpu *vcpu)</yellow>
<blue>{</blue>
	/* Can&#x27;t read the RIP when guest state is protected, just return 0 */
<blue>	if (vcpu->arch.guest_state_protected)</blue>
		return 0;

<blue>	if (is_64_bit_mode(vcpu))</blue>
<blue>		return kvm_rip_read(vcpu);</blue>
<yellow>	return (u32)(get_segment_base(vcpu, VCPU_SREG_CS) +</yellow>
<yellow>		     kvm_rip_read(vcpu));</yellow>
}
EXPORT_SYMBOL_GPL(kvm_get_linear_rip);

bool kvm_is_linear_rip(struct kvm_vcpu *vcpu, unsigned long linear_rip)
{
<yellow>	return kvm_get_linear_rip(vcpu) == linear_rip;</yellow>
}
EXPORT_SYMBOL_GPL(kvm_is_linear_rip);

unsigned long kvm_get_rflags(struct kvm_vcpu *vcpu)
{
	unsigned long rflags;

<blue>	rflags = static_call(kvm_x86_get_rflags)(vcpu);</blue>
<yellow>	if (vcpu->guest_debug & KVM_GUESTDBG_SINGLESTEP)</yellow>
<yellow>		rflags &= ~X86_EFLAGS_TF;</yellow>
	return rflags;
<yellow>}</yellow>
EXPORT_SYMBOL_GPL(kvm_get_rflags);

static void __kvm_set_rflags(struct kvm_vcpu *vcpu, unsigned long rflags)
{
<blue>	if (vcpu->guest_debug & KVM_GUESTDBG_SINGLESTEP &&</blue>
<yellow>	    kvm_is_linear_rip(vcpu, vcpu->arch.singlestep_rip))</yellow>
<yellow>		rflags |= X86_EFLAGS_TF;</yellow>
<blue>	static_call(kvm_x86_set_rflags)(vcpu, rflags);</blue>
}

void kvm_set_rflags(struct kvm_vcpu *vcpu, unsigned long rflags)
{
<blue>	__kvm_set_rflags(vcpu, rflags);</blue>
	kvm_make_request(KVM_REQ_EVENT, vcpu);
}
EXPORT_SYMBOL_GPL(kvm_set_rflags);

static inline u32 kvm_async_pf_hash_fn(gfn_t gfn)
{
	BUILD_BUG_ON(!is_power_of_2(ASYNC_PF_PER_VCPU));

	return hash_32(gfn &amp; 0xffffffff, order_base_2(ASYNC_PF_PER_VCPU));
}

static inline u32 kvm_async_pf_next_probe(u32 key)
{
<yellow>	return (key + 1) & (ASYNC_PF_PER_VCPU - 1);</yellow>
}

static void kvm_add_async_pf_gfn(struct kvm_vcpu *vcpu, gfn_t gfn)
{
	u32 key = kvm_async_pf_hash_fn(gfn);

	while (vcpu-&gt;arch.apf.gfns[key] != ~0)
<yellow>		key = kvm_async_pf_next_probe(key);</yellow>

<yellow>	vcpu->arch.apf.gfns[key] = gfn;</yellow>
}

static u32 kvm_async_pf_gfn_slot(struct kvm_vcpu *vcpu, gfn_t gfn)
{
	int i;
	u32 key = kvm_async_pf_hash_fn(gfn);

<yellow>	for (i = 0; i < ASYNC_PF_PER_VCPU &&</yellow>
<yellow>		     (vcpu->arch.apf.gfns[key] != gfn &&</yellow>
<yellow>		      vcpu->arch.apf.gfns[key] != ~0); i++)</yellow>
		key = kvm_async_pf_next_probe(key);

	return key;
}

bool kvm_find_async_pf_gfn(struct kvm_vcpu *vcpu, gfn_t gfn)
{
<yellow>	return vcpu->arch.apf.gfns[kvm_async_pf_gfn_slot(vcpu, gfn)] == gfn;</yellow>
}

static void kvm_del_async_pf_gfn(struct kvm_vcpu *vcpu, gfn_t gfn)
{
	u32 i, j, k;

<yellow>	i = j = kvm_async_pf_gfn_slot(vcpu, gfn);</yellow>

<yellow>	if (WARN_ON_ONCE(vcpu->arch.apf.gfns[i] != gfn))</yellow>
		return;

	while (true) {
<yellow>		vcpu->arch.apf.gfns[i] = ~0;</yellow>
		do {
<yellow>			j = kvm_async_pf_next_probe(j);</yellow>
			if (vcpu-&gt;arch.apf.gfns[j] == ~0)
				return;
<yellow>			k = kvm_async_pf_hash_fn(vcpu->arch.apf.gfns[j]);</yellow>
			/*
			 * k lies cyclically in ]i,j]
			 * |    i.k.j |
			 * |....j i.k.| or  |.k..j i...|
			 */
<yellow>		} while ((i <= j) ? (i < k && k <= j) : (i < k || k <= j));</yellow>
<yellow>		vcpu->arch.apf.gfns[i] = vcpu->arch.apf.gfns[j];</yellow>
		i = j;
	}
}

static inline int apf_put_user_notpresent(struct kvm_vcpu *vcpu)
{
	u32 reason = KVM_PV_REASON_PAGE_NOT_PRESENT;

<yellow>	return kvm_write_guest_cached(vcpu->kvm, &vcpu->arch.apf.data, &reason,</yellow>
				      sizeof(reason));
}

static inline int apf_put_user_ready(struct kvm_vcpu *vcpu, u32 token)
{
	unsigned int offset = offsetof(struct kvm_vcpu_pv_apf_data, token);

	return kvm_write_guest_offset_cached(vcpu-&gt;kvm, &amp;vcpu-&gt;arch.apf.data,
					     &amp;token, offset, sizeof(token));
}

static inline bool apf_pageready_slot_free(struct kvm_vcpu *vcpu)
{
	unsigned int offset = offsetof(struct kvm_vcpu_pv_apf_data, token);
	u32 val;

<yellow>	if (kvm_read_guest_offset_cached(vcpu->kvm, &vcpu->arch.apf.data,</yellow>
					 &amp;val, offset, sizeof(val)))
		return false;

<yellow>	return !val;</yellow>
}

<yellow>static bool kvm_can_deliver_async_pf(struct kvm_vcpu *vcpu)</yellow>
{

<yellow>	if (!kvm_pv_async_pf_enabled(vcpu))</yellow>
<yellow>		return false;</yellow>

<yellow>	if (vcpu->arch.apf.send_user_only &&</yellow>
<yellow>	    static_call(kvm_x86_get_cpl)(vcpu) == 0)</yellow>
		return false;

<yellow>	if (is_guest_mode(vcpu)) {</yellow>
		/*
		 * L1 needs to opt into the special #PF vmexits that are
		 * used to deliver async page faults.
		 */
<yellow>		return vcpu->arch.apf.delivery_as_pf_vmexit;</yellow>
	} else {
		/*
		 * Play it safe in case the guest temporarily disables paging.
		 * The real mode IDT in particular is unlikely to have a #PF
		 * exception setup.
		 */
<yellow>		return is_paging(vcpu);</yellow>
	}
<yellow>}</yellow>

bool kvm_can_do_async_pf(struct kvm_vcpu *vcpu)
{
<yellow>	if (unlikely(!lapic_in_kernel(vcpu) ||</yellow>
		     kvm_event_needs_reinjection(vcpu) ||
		     kvm_is_exception_pending(vcpu)))
<yellow>		return false;</yellow>

<yellow>	if (kvm_hlt_in_guest(vcpu->kvm) && !kvm_can_deliver_async_pf(vcpu))</yellow>
		return false;

	/*
	 * If interrupts are off we cannot even use an artificial
	 * halt state.
	 */
<yellow>	return kvm_arch_interrupt_allowed(vcpu);</yellow>
<yellow>}</yellow>

bool kvm_arch_async_page_not_present(struct kvm_vcpu *vcpu,
				     struct kvm_async_pf *work)
<yellow>{</yellow>
	struct x86_exception fault;

<yellow>	trace_kvm_async_pf_not_present(work->arch.token, work->cr2_or_gpa);</yellow>
<yellow>	kvm_add_async_pf_gfn(vcpu, work->arch.gfn);</yellow>

	if (kvm_can_deliver_async_pf(vcpu) &amp;&amp;
<yellow>	    !apf_put_user_notpresent(vcpu)) {</yellow>
		fault.vector = PF_VECTOR;
		fault.error_code_valid = true;
		fault.error_code = 0;
		fault.nested_page_fault = false;
<yellow>		fault.address = work->arch.token;</yellow>
		fault.async_page_fault = true;
		kvm_inject_page_fault(vcpu, &amp;fault);
		return true;
	} else {
		/*
		 * It is not possible to deliver a paravirtualized asynchronous
		 * page fault, but putting the guest in an artificial halt state
		 * can be beneficial nevertheless: if an interrupt arrives, we
		 * can deliver it timely and perhaps the guest will schedule
		 * another process.  When the instruction that triggered a page
		 * fault is retried, hopefully the page will be ready in the host.
		 */
<yellow>		kvm_make_request(KVM_REQ_APF_HALT, vcpu);</yellow>
		return false;
	}
}

void kvm_arch_async_page_present(struct kvm_vcpu *vcpu,
				 struct kvm_async_pf *work)
{
	struct kvm_lapic_irq irq = {
		.delivery_mode = APIC_DM_FIXED,
<yellow>		.vector = vcpu->arch.apf.vec</yellow>
	};

<yellow>	if (work->wakeup_all)</yellow>
<yellow>		work->arch.token = ~0; /* broadcast wakeup */</yellow>
	else
<yellow>		kvm_del_async_pf_gfn(vcpu, work->arch.gfn);</yellow>
<yellow>	trace_kvm_async_pf_ready(work->arch.token, work->cr2_or_gpa);</yellow>

<yellow>	if ((work->wakeup_all || work->notpresent_injected) &&</yellow>
<yellow>	    kvm_pv_async_pf_enabled(vcpu) &&</yellow>
<yellow>	    !apf_put_user_ready(vcpu, work->arch.token)) {</yellow>
<yellow>		vcpu->arch.apf.pageready_pending = true;</yellow>
		kvm_apic_set_irq(vcpu, &amp;irq, NULL);
	}

<yellow>	vcpu->arch.apf.halted = false;</yellow>
	vcpu-&gt;arch.mp_state = KVM_MP_STATE_RUNNABLE;
}

void kvm_arch_async_page_present_queued(struct kvm_vcpu *vcpu)
{
<yellow>	kvm_make_request(KVM_REQ_APF_READY, vcpu);</yellow>
<yellow>	if (!vcpu->arch.apf.pageready_pending)</yellow>
<yellow>		kvm_vcpu_kick(vcpu);</yellow>
<yellow>}</yellow>

bool kvm_arch_can_dequeue_async_page_present(struct kvm_vcpu *vcpu)
<yellow>{</yellow>
<yellow>	if (!kvm_pv_async_pf_enabled(vcpu))</yellow>
		return true;
	else
<yellow>		return kvm_lapic_enabled(vcpu) && apf_pageready_slot_free(vcpu);</yellow>
}

void kvm_arch_start_assignment(struct kvm *kvm)
{
<yellow>	if (atomic_inc_return(&kvm->arch.assigned_device_count) == 1)</yellow>
<yellow>		static_call_cond(kvm_x86_pi_start_assignment)(kvm);</yellow>
<yellow>}</yellow>
EXPORT_SYMBOL_GPL(kvm_arch_start_assignment);

void kvm_arch_end_assignment(struct kvm *kvm)
{
<yellow>	atomic_dec(&kvm->arch.assigned_device_count);</yellow>
}
EXPORT_SYMBOL_GPL(kvm_arch_end_assignment);

bool noinstr kvm_arch_has_assigned_device(struct kvm *kvm)
{
	return arch_atomic_read(&amp;kvm-&gt;arch.assigned_device_count);
}
EXPORT_SYMBOL_GPL(kvm_arch_has_assigned_device);

void kvm_arch_register_noncoherent_dma(struct kvm *kvm)
{
<yellow>	atomic_inc(&kvm->arch.noncoherent_dma_count);</yellow>
}
EXPORT_SYMBOL_GPL(kvm_arch_register_noncoherent_dma);

void kvm_arch_unregister_noncoherent_dma(struct kvm *kvm)
{
<yellow>	atomic_dec(&kvm->arch.noncoherent_dma_count);</yellow>
}
EXPORT_SYMBOL_GPL(kvm_arch_unregister_noncoherent_dma);

bool kvm_arch_has_noncoherent_dma(struct kvm *kvm)
{
<blue>	return atomic_read(&kvm->arch.noncoherent_dma_count);</blue>
}
EXPORT_SYMBOL_GPL(kvm_arch_has_noncoherent_dma);

bool kvm_arch_has_irq_bypass(void)
{
	return true;
<yellow>}</yellow>

int kvm_arch_irq_bypass_add_producer(struct irq_bypass_consumer *cons,
				      struct irq_bypass_producer *prod)
{
	struct kvm_kernel_irqfd *irqfd =
		container_of(cons, struct kvm_kernel_irqfd, consumer);
	int ret;

<yellow>	irqfd->producer = prod;</yellow>
<yellow>	kvm_arch_start_assignment(irqfd->kvm);</yellow>
	ret = static_call(kvm_x86_pi_update_irte)(irqfd-&gt;kvm,
<yellow>					 prod->irq, irqfd->gsi, 1);</yellow>

	if (ret)
<yellow>		kvm_arch_end_assignment(irqfd->kvm);</yellow>

	return ret;
<yellow>}</yellow>

void kvm_arch_irq_bypass_del_producer(struct irq_bypass_consumer *cons,
				      struct irq_bypass_producer *prod)
{
	int ret;
	struct kvm_kernel_irqfd *irqfd =
		container_of(cons, struct kvm_kernel_irqfd, consumer);

<yellow>	WARN_ON(irqfd->producer != prod);</yellow>
<yellow>	irqfd->producer = NULL;</yellow>

	/*
	 * When producer of consumer is unregistered, we change back to
	 * remapped mode, so we can re-use the current implementation
	 * when the irq is masked/disabled or the consumer side (KVM
	 * int this case doesn&#x27;t want to receive the interrupts.
	*/
	ret = static_call(kvm_x86_pi_update_irte)(irqfd-&gt;kvm, prod-&gt;irq, irqfd-&gt;gsi, 0);
	if (ret)
		printk(KERN_INFO &quot;irq bypass consumer (token %p) unregistration&quot;
		       &quot; fails: %d\n&quot;, irqfd-&gt;consumer.token, ret);

<yellow>	kvm_arch_end_assignment(irqfd->kvm);</yellow>
}

int kvm_arch_update_irqfd_routing(struct kvm *kvm, unsigned int host_irq,
				   uint32_t guest_irq, bool set)
{
<yellow>	return static_call(kvm_x86_pi_update_irte)(kvm, host_irq, guest_irq, set);</yellow>
}

bool kvm_arch_irqfd_route_changed(struct kvm_kernel_irq_routing_entry *old,
				  struct kvm_kernel_irq_routing_entry *new)
{
<yellow>	if (new->type != KVM_IRQ_ROUTING_MSI)</yellow>
		return true;

<yellow>	return !!memcmp(&old->msi, &new->msi, sizeof(new->msi));</yellow>
<yellow>}</yellow>

bool kvm_vector_hashing_enabled(void)
{
<yellow>	return vector_hashing;</yellow>
}

bool kvm_arch_no_poll(struct kvm_vcpu *vcpu)
{
<blue>	return (vcpu->arch.msr_kvm_poll_control & 1) == 0;</blue>
}
EXPORT_SYMBOL_GPL(kvm_arch_no_poll);


int kvm_spec_ctrl_test_value(u64 value)
<blue>{</blue>
	/*
	 * test that setting IA32_SPEC_CTRL to given value
	 * is allowed by the host processor
	 */

	u64 saved_value;
	unsigned long flags;
	int ret = 0;

<blue>	local_irq_save(flags);</blue>

	if (rdmsrl_safe(MSR_IA32_SPEC_CTRL, &amp;saved_value))
		ret = 1;
<blue>	else if (wrmsrl_safe(MSR_IA32_SPEC_CTRL, value))</blue>
		ret = 1;
	else
<blue>		wrmsrl(MSR_IA32_SPEC_CTRL, saved_value);</blue>

<blue>	local_irq_restore(flags);</blue>

	return ret;
}
EXPORT_SYMBOL_GPL(kvm_spec_ctrl_test_value);

void kvm_fixup_and_inject_pf_error(struct kvm_vcpu *vcpu, gva_t gva, u16 error_code)
{
<yellow>	struct kvm_mmu *mmu = vcpu->arch.walk_mmu;</yellow>
	struct x86_exception fault;
	u64 access = error_code &amp;
		(PFERR_WRITE_MASK | PFERR_FETCH_MASK | PFERR_USER_MASK);

	if (!(error_code &amp; PFERR_PRESENT_MASK) ||
<yellow>	    mmu->gva_to_gpa(vcpu, mmu, gva, access, &fault) != INVALID_GPA) {</yellow>
		/*
		 * If vcpu-&gt;arch.walk_mmu-&gt;gva_to_gpa succeeded, the page
		 * tables probably do not match the TLB.  Just proceed
		 * with the error code that the processor gave.
		 */
<yellow>		fault.vector = PF_VECTOR;</yellow>
		fault.error_code_valid = true;
		fault.error_code = error_code;
		fault.nested_page_fault = false;
		fault.address = gva;
		fault.async_page_fault = false;
	}
<yellow>	vcpu->arch.walk_mmu->inject_page_fault(vcpu, &fault);</yellow>
}
EXPORT_SYMBOL_GPL(kvm_fixup_and_inject_pf_error);

/*
 * Handles kvm_read/write_guest_virt*() result and either injects #PF or returns
 * KVM_EXIT_INTERNAL_ERROR for cases not currently handled by KVM. Return value
 * indicates whether exit to userspace is needed.
 */
int kvm_handle_memory_failure(struct kvm_vcpu *vcpu, int r,
			      struct x86_exception *e)
{
<yellow>	if (r == X86EMUL_PROPAGATE_FAULT) {</yellow>
<yellow>		kvm_inject_emulated_page_fault(vcpu, e);</yellow>
		return 1;
	}

	/*
	 * In case kvm_read/write_guest_virt*() failed with X86EMUL_IO_NEEDED
	 * while handling a VMX instruction KVM could&#x27;ve handled the request
	 * correctly by exiting to userspace and performing I/O but there
	 * doesn&#x27;t seem to be a real use-case behind such requests, just return
	 * KVM_EXIT_INTERNAL_ERROR for now.
	 */
<yellow>	kvm_prepare_emulation_failure_exit(vcpu);</yellow>

	return 0;
<yellow>}</yellow>
EXPORT_SYMBOL_GPL(kvm_handle_memory_failure);

int kvm_handle_invpcid(struct kvm_vcpu *vcpu, unsigned long type, gva_t gva)
<yellow>{</yellow>
	bool pcid_enabled;
	struct x86_exception e;
	struct {
		u64 pcid;
		u64 gla;
	} operand;
	int r;

<yellow>	r = kvm_read_guest_virt(vcpu, gva, &operand, sizeof(operand), &e);</yellow>
	if (r != X86EMUL_CONTINUE)
<yellow>		return kvm_handle_memory_failure(vcpu, r, &e);</yellow>

<yellow>	if (operand.pcid >> 12 != 0) {</yellow>
		kvm_inject_gp(vcpu, 0);
		return 1;
	}

<yellow>	pcid_enabled = kvm_read_cr4_bits(vcpu, X86_CR4_PCIDE);</yellow>

	switch (type) {
	case INVPCID_TYPE_INDIV_ADDR:
<yellow>		if ((!pcid_enabled && (operand.pcid != 0)) ||</yellow>
<yellow>		    is_noncanonical_address(operand.gla, vcpu)) {</yellow>
			kvm_inject_gp(vcpu, 0);
			return 1;
		}
<yellow>		kvm_mmu_invpcid_gva(vcpu, operand.gla, operand.pcid);</yellow>
		return kvm_skip_emulated_instruction(vcpu);

	case INVPCID_TYPE_SINGLE_CTXT:
<yellow>		if (!pcid_enabled && (operand.pcid != 0)) {</yellow>
			kvm_inject_gp(vcpu, 0);
			return 1;
		}

<yellow>		kvm_invalidate_pcid(vcpu, operand.pcid);</yellow>
		return kvm_skip_emulated_instruction(vcpu);

	case INVPCID_TYPE_ALL_NON_GLOBAL:
		/*
		 * Currently, KVM doesn&#x27;t mark global entries in the shadow
		 * page tables, so a non-global flush just degenerates to a
		 * global flush. If needed, we could optimize this later by
		 * keeping track of global entries in shadow page tables.
		 */

		fallthrough;
	case INVPCID_TYPE_ALL_INCL_GLOBAL:
<yellow>		kvm_make_request(KVM_REQ_TLB_FLUSH_GUEST, vcpu);</yellow>
<yellow>		return kvm_skip_emulated_instruction(vcpu);</yellow>

	default:
<yellow>		kvm_inject_gp(vcpu, 0);</yellow>
		return 1;
	}
}
EXPORT_SYMBOL_GPL(kvm_handle_invpcid);

static int complete_sev_es_emulated_mmio(struct kvm_vcpu *vcpu)
{
<yellow>	struct kvm_run *run = vcpu->run;</yellow>
	struct kvm_mmio_fragment *frag;
	unsigned int len;

<yellow>	BUG_ON(!vcpu->mmio_needed);</yellow>

	/* Complete previous fragment */
<yellow>	frag = &vcpu->mmio_fragments[vcpu->mmio_cur_fragment];</yellow>
	len = min(8u, frag-&gt;len);
	if (!vcpu-&gt;mmio_is_write)
<yellow>		memcpy(frag->data, run->mmio.data, len);</yellow>

<yellow>	if (frag->len <= 8) {</yellow>
		/* Switch to the next fragment. */
		frag++;
<yellow>		vcpu->mmio_cur_fragment++;</yellow>
	} else {
		/* Go forward to the next mmio piece. */
<yellow>		frag->data += len;</yellow>
		frag-&gt;gpa += len;
		frag-&gt;len -= len;
	}

<yellow>	if (vcpu->mmio_cur_fragment >= vcpu->mmio_nr_fragments) {</yellow>
<yellow>		vcpu->mmio_needed = 0;</yellow>

		// VMG change, at this point, we&#x27;re always done
		// RIP has already been advanced
		return 1;
	}

	// More MMIO is needed
<yellow>	run->mmio.phys_addr = frag->gpa;</yellow>
	run-&gt;mmio.len = min(8u, frag-&gt;len);
	run-&gt;mmio.is_write = vcpu-&gt;mmio_is_write;
	if (run-&gt;mmio.is_write)
<yellow>		memcpy(run->mmio.data, frag->data, min(8u, frag->len));</yellow>
<yellow>	run->exit_reason = KVM_EXIT_MMIO;</yellow>

	vcpu-&gt;arch.complete_userspace_io = complete_sev_es_emulated_mmio;

	return 0;
<yellow>}</yellow>

int kvm_sev_es_mmio_write(struct kvm_vcpu *vcpu, gpa_t gpa, unsigned int bytes,
			  void *data)
{
	int handled;
	struct kvm_mmio_fragment *frag;

<yellow>	if (!data)</yellow>
		return -EINVAL;

<yellow>	handled = write_emultor.read_write_mmio(vcpu, gpa, bytes, data);</yellow>
	if (handled == bytes)
		return 1;

	bytes -= handled;
	gpa += handled;
	data += handled;

	/*TODO: Check if need to increment number of frags */
	frag = vcpu-&gt;mmio_fragments;
<yellow>	vcpu->mmio_nr_fragments = 1;</yellow>
	frag-&gt;len = bytes;
	frag-&gt;gpa = gpa;
	frag-&gt;data = data;

	vcpu-&gt;mmio_needed = 1;
	vcpu-&gt;mmio_cur_fragment = 0;

	vcpu-&gt;run-&gt;mmio.phys_addr = gpa;
	vcpu-&gt;run-&gt;mmio.len = min(8u, frag-&gt;len);
	vcpu-&gt;run-&gt;mmio.is_write = 1;
	memcpy(vcpu-&gt;run-&gt;mmio.data, frag-&gt;data, min(8u, frag-&gt;len));
	vcpu-&gt;run-&gt;exit_reason = KVM_EXIT_MMIO;

	vcpu-&gt;arch.complete_userspace_io = complete_sev_es_emulated_mmio;

	return 0;
<yellow>}</yellow>
EXPORT_SYMBOL_GPL(kvm_sev_es_mmio_write);

int kvm_sev_es_mmio_read(struct kvm_vcpu *vcpu, gpa_t gpa, unsigned int bytes,
			 void *data)
{
	int handled;
	struct kvm_mmio_fragment *frag;

<yellow>	if (!data)</yellow>
		return -EINVAL;

<yellow>	handled = read_emultor.read_write_mmio(vcpu, gpa, bytes, data);</yellow>
	if (handled == bytes)
		return 1;

	bytes -= handled;
	gpa += handled;
	data += handled;

	/*TODO: Check if need to increment number of frags */
	frag = vcpu-&gt;mmio_fragments;
<yellow>	vcpu->mmio_nr_fragments = 1;</yellow>
	frag-&gt;len = bytes;
	frag-&gt;gpa = gpa;
	frag-&gt;data = data;

	vcpu-&gt;mmio_needed = 1;
	vcpu-&gt;mmio_cur_fragment = 0;

	vcpu-&gt;run-&gt;mmio.phys_addr = gpa;
	vcpu-&gt;run-&gt;mmio.len = min(8u, frag-&gt;len);
	vcpu-&gt;run-&gt;mmio.is_write = 0;
	vcpu-&gt;run-&gt;exit_reason = KVM_EXIT_MMIO;

	vcpu-&gt;arch.complete_userspace_io = complete_sev_es_emulated_mmio;

	return 0;
<yellow>}</yellow>
EXPORT_SYMBOL_GPL(kvm_sev_es_mmio_read);

static void advance_sev_es_emulated_pio(struct kvm_vcpu *vcpu, unsigned count, int size)
{
<yellow>	vcpu->arch.sev_pio_count -= count;</yellow>
	vcpu-&gt;arch.sev_pio_data += count * size;
}

static int kvm_sev_es_outs(struct kvm_vcpu *vcpu, unsigned int size,
			   unsigned int port);

static int complete_sev_es_emulated_outs(struct kvm_vcpu *vcpu)
{
<yellow>	int size = vcpu->arch.pio.size;</yellow>
	int port = vcpu-&gt;arch.pio.port;

	vcpu-&gt;arch.pio.count = 0;
	if (vcpu-&gt;arch.sev_pio_count)
<yellow>		return kvm_sev_es_outs(vcpu, size, port);</yellow>
	return 1;
<yellow>}</yellow>

static int kvm_sev_es_outs(struct kvm_vcpu *vcpu, unsigned int size,
			   unsigned int port)
{
	for (;;) {
		unsigned int count =
<yellow>			min_t(unsigned int, PAGE_SIZE / size, vcpu->arch.sev_pio_count);</yellow>
<yellow>		int ret = emulator_pio_out(vcpu, size, port, vcpu->arch.sev_pio_data, count);</yellow>

		/* memcpy done already by emulator_pio_out.  */
		advance_sev_es_emulated_pio(vcpu, count, size);
		if (!ret)
			break;

		/* Emulation done by the kernel.  */
<yellow>		if (!vcpu->arch.sev_pio_count)</yellow>
			return 1;
	}

<yellow>	vcpu->arch.complete_userspace_io = complete_sev_es_emulated_outs;</yellow>
	return 0;
<yellow>}</yellow>

static int kvm_sev_es_ins(struct kvm_vcpu *vcpu, unsigned int size,
			  unsigned int port);

static int complete_sev_es_emulated_ins(struct kvm_vcpu *vcpu)
{
<yellow>	unsigned count = vcpu->arch.pio.count;</yellow>
	int size = vcpu-&gt;arch.pio.size;
	int port = vcpu-&gt;arch.pio.port;

	complete_emulator_pio_in(vcpu, vcpu-&gt;arch.sev_pio_data);
	advance_sev_es_emulated_pio(vcpu, count, size);
	if (vcpu-&gt;arch.sev_pio_count)
<yellow>		return kvm_sev_es_ins(vcpu, size, port);</yellow>
	return 1;
<yellow>}</yellow>

static int kvm_sev_es_ins(struct kvm_vcpu *vcpu, unsigned int size,
			  unsigned int port)
{
	for (;;) {
		unsigned int count =
<yellow>			min_t(unsigned int, PAGE_SIZE / size, vcpu->arch.sev_pio_count);</yellow>
<yellow>		if (!emulator_pio_in(vcpu, size, port, vcpu->arch.sev_pio_data, count))</yellow>
			break;

		/* Emulation done by the kernel.  */
<yellow>		advance_sev_es_emulated_pio(vcpu, count, size);</yellow>
		if (!vcpu-&gt;arch.sev_pio_count)
			return 1;
	}

<yellow>	vcpu->arch.complete_userspace_io = complete_sev_es_emulated_ins;</yellow>
	return 0;
<yellow>}</yellow>

int kvm_sev_es_string_io(struct kvm_vcpu *vcpu, unsigned int size,
			 unsigned int port, void *data,  unsigned int count,
			 int in)
{
<yellow>	vcpu->arch.sev_pio_data = data;</yellow>
	vcpu-&gt;arch.sev_pio_count = count;
<yellow>	return in ? kvm_sev_es_ins(vcpu, size, port)</yellow>
<yellow>		  : kvm_sev_es_outs(vcpu, size, port);</yellow>
<yellow>}</yellow>
EXPORT_SYMBOL_GPL(kvm_sev_es_string_io);

EXPORT_TRACEPOINT_SYMBOL_GPL(kvm_entry);
EXPORT_TRACEPOINT_SYMBOL_GPL(kvm_exit);
EXPORT_TRACEPOINT_SYMBOL_GPL(kvm_fast_mmio);
EXPORT_TRACEPOINT_SYMBOL_GPL(kvm_inj_virq);
EXPORT_TRACEPOINT_SYMBOL_GPL(kvm_page_fault);
EXPORT_TRACEPOINT_SYMBOL_GPL(kvm_msr);
EXPORT_TRACEPOINT_SYMBOL_GPL(kvm_cr);
EXPORT_TRACEPOINT_SYMBOL_GPL(kvm_nested_vmenter);
EXPORT_TRACEPOINT_SYMBOL_GPL(kvm_nested_vmexit);
EXPORT_TRACEPOINT_SYMBOL_GPL(kvm_nested_vmexit_inject);
EXPORT_TRACEPOINT_SYMBOL_GPL(kvm_nested_intr_vmexit);
EXPORT_TRACEPOINT_SYMBOL_GPL(kvm_nested_vmenter_failed);
EXPORT_TRACEPOINT_SYMBOL_GPL(kvm_invlpga);
EXPORT_TRACEPOINT_SYMBOL_GPL(kvm_skinit);
EXPORT_TRACEPOINT_SYMBOL_GPL(kvm_nested_intercepts);
EXPORT_TRACEPOINT_SYMBOL_GPL(kvm_write_tsc_offset);
EXPORT_TRACEPOINT_SYMBOL_GPL(kvm_ple_window_update);
EXPORT_TRACEPOINT_SYMBOL_GPL(kvm_pml_full);
EXPORT_TRACEPOINT_SYMBOL_GPL(kvm_pi_irte_update);
EXPORT_TRACEPOINT_SYMBOL_GPL(kvm_avic_unaccelerated_access);
EXPORT_TRACEPOINT_SYMBOL_GPL(kvm_avic_incomplete_ipi);
EXPORT_TRACEPOINT_SYMBOL_GPL(kvm_avic_ga_log);
EXPORT_TRACEPOINT_SYMBOL_GPL(kvm_avic_kick_vcpu_slowpath);
EXPORT_TRACEPOINT_SYMBOL_GPL(kvm_avic_doorbell);
EXPORT_TRACEPOINT_SYMBOL_GPL(kvm_apicv_accept_irq);
EXPORT_TRACEPOINT_SYMBOL_GPL(kvm_vmgexit_enter);
EXPORT_TRACEPOINT_SYMBOL_GPL(kvm_vmgexit_exit);
EXPORT_TRACEPOINT_SYMBOL_GPL(kvm_vmgexit_msr_protocol_enter);
EXPORT_TRACEPOINT_SYMBOL_GPL(kvm_vmgexit_msr_protocol_exit);

static int __init kvm_x86_init(void)
{
	kvm_mmu_x86_module_init();
	return 0;
}
module_init(kvm_x86_init);

static void __exit kvm_x86_exit(void)
{
	/*
	 * If module_init() is implemented, module_exit() must also be
	 * implemented to allow module unload.
	 */
}
module_exit(kvm_x86_exit);


</code></pre></td></tr></table>
</body>
</html>
