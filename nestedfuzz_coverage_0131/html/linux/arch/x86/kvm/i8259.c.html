<doctype html>
<html lang="ja">
<head>
<meta charset="utf-8">
<script src="https://cdn.rawgit.com/google/code-prettify/master/loader/run_prettify.js"></script>
<style>
    code{
        font-family:Monaco, Menlo, Consolas, 'Courier New', Courier, monospace, sans-serif;
        font-size: 14px;
        line-height: 18px;
        overflow: auto;
        resize: horizontal;
    }
    code_line{
        font-family: Monaco, Menlo, Consolas, 'Courier New', Courier, monospace, sans-serif;;
        font-size: 14px;
        line-height: 18px;
        overflow: auto;
        resize: horizontal;
        color:#303134;
    }
    blue{
        background-color:#BEEDE8;
    }
    yellow{
        background-color:#FFFF99;
    }
    red{
        background-color:#FF99AC;
    }
</style>

</head>
<body>
<table summary='blob content' class='blob' cellspacing="15">
<tr><td align="right"><pre><code_line>1.
2.
3.
4.
5.
6.
7.
8.
9.
10.
11.
12.
13.
14.
15.
16.
17.
18.
19.
20.
21.
22.
23.
24.
25.
26.
27.
28.
29.
30.
31.
32.
33.
34.
35.
36.
37.
38.
39.
40.
41.
42.
43.
44.
45.
46.
47.
48.
49.
50.
51.
52.
53.
54.
55.
56.
57.
58.
59.
60.
61.
62.
63.
64.
65.
66.
67.
68.
69.
70.
71.
72.
73.
74.
75.
76.
77.
78.
79.
80.
81.
82.
83.
84.
85.
86.
87.
88.
89.
90.
91.
92.
93.
94.
95.
96.
97.
98.
99.
100.
101.
102.
103.
104.
105.
106.
107.
108.
109.
110.
111.
112.
113.
114.
115.
116.
117.
118.
119.
120.
121.
122.
123.
124.
125.
126.
127.
128.
129.
130.
131.
132.
133.
134.
135.
136.
137.
138.
139.
140.
141.
142.
143.
144.
145.
146.
147.
148.
149.
150.
151.
152.
153.
154.
155.
156.
157.
158.
159.
160.
161.
162.
163.
164.
165.
166.
167.
168.
169.
170.
171.
172.
173.
174.
175.
176.
177.
178.
179.
180.
181.
182.
183.
184.
185.
186.
187.
188.
189.
190.
191.
192.
193.
194.
195.
196.
197.
198.
199.
200.
201.
202.
203.
204.
205.
206.
207.
208.
209.
210.
211.
212.
213.
214.
215.
216.
217.
218.
219.
220.
221.
222.
223.
224.
225.
226.
227.
228.
229.
230.
231.
232.
233.
234.
235.
236.
237.
238.
239.
240.
241.
242.
243.
244.
245.
246.
247.
248.
249.
250.
251.
252.
253.
254.
255.
256.
257.
258.
259.
260.
261.
262.
263.
264.
265.
266.
267.
268.
269.
270.
271.
272.
273.
274.
275.
276.
277.
278.
279.
280.
281.
282.
283.
284.
285.
286.
287.
288.
289.
290.
291.
292.
293.
294.
295.
296.
297.
298.
299.
300.
301.
302.
303.
304.
305.
306.
307.
308.
309.
310.
311.
312.
313.
314.
315.
316.
317.
318.
319.
320.
321.
322.
323.
324.
325.
326.
327.
328.
329.
330.
331.
332.
333.
334.
335.
336.
337.
338.
339.
340.
341.
342.
343.
344.
345.
346.
347.
348.
349.
350.
351.
352.
353.
354.
355.
356.
357.
358.
359.
360.
361.
362.
363.
364.
365.
366.
367.
368.
369.
370.
371.
372.
373.
374.
375.
376.
377.
378.
379.
380.
381.
382.
383.
384.
385.
386.
387.
388.
389.
390.
391.
392.
393.
394.
395.
396.
397.
398.
399.
400.
401.
402.
403.
404.
405.
406.
407.
408.
409.
410.
411.
412.
413.
414.
415.
416.
417.
418.
419.
420.
421.
422.
423.
424.
425.
426.
427.
428.
429.
430.
431.
432.
433.
434.
435.
436.
437.
438.
439.
440.
441.
442.
443.
444.
445.
446.
447.
448.
449.
450.
451.
452.
453.
454.
455.
456.
457.
458.
459.
460.
461.
462.
463.
464.
465.
466.
467.
468.
469.
470.
471.
472.
473.
474.
475.
476.
477.
478.
479.
480.
481.
482.
483.
484.
485.
486.
487.
488.
489.
490.
491.
492.
493.
494.
495.
496.
497.
498.
499.
500.
501.
502.
503.
504.
505.
506.
507.
508.
509.
510.
511.
512.
513.
514.
515.
516.
517.
518.
519.
520.
521.
522.
523.
524.
525.
526.
527.
528.
529.
530.
531.
532.
533.
534.
535.
536.
537.
538.
539.
540.
541.
542.
543.
544.
545.
546.
547.
548.
549.
550.
551.
552.
553.
554.
555.
556.
557.
558.
559.
560.
561.
562.
563.
564.
565.
566.
567.
568.
569.
570.
571.
572.
573.
574.
575.
576.
577.
578.
579.
580.
581.
582.
583.
584.
585.
586.
587.
588.
589.
590.
591.
592.
593.
594.
595.
596.
597.
598.
599.
600.
601.
602.
603.
604.
605.
606.
607.
608.
609.
610.
611.
612.
613.
614.
615.
616.
617.
618.
619.
620.
621.
622.
623.
624.
625.
626.
627.
628.
629.
630.
631.
632.
633.
634.
635.
636.
637.
638.
639.
640.
641.
642.
643.
644.
645.
646.
647.
648.
649.
650.
651.
652.
653.
654.
655.
656.
</code_line></pre></td>
<td class='lines'><pre><code class="prettyprint">/*
 * 8259 interrupt controller emulation
 *
 * Copyright (c) 2003-2004 Fabrice Bellard
 * Copyright (c) 2007 Intel Corporation
 * Copyright 2009 Red Hat, Inc. and/or its affiliates.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the &quot;Software&quot;), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 * Authors:
 *   Yaozu (Eddie) Dong &lt;Eddie.dong@intel.com&gt;
 *   Port from Qemu.
 */
#include &lt;linux/mm.h&gt;
#include &lt;linux/slab.h&gt;
#include &lt;linux/bitops.h&gt;
#include &quot;irq.h&quot;

#include &lt;linux/kvm_host.h&gt;
#include &quot;trace.h&quot;

#define pr_pic_unimpl(fmt, ...)	\
	pr_err_ratelimited(&quot;kvm: pic: &quot; fmt, ## __VA_ARGS__)

static void pic_irq_request(struct kvm *kvm, int level);

static void pic_lock(struct kvm_pic *s)
	__acquires(&amp;s-&gt;lock)
{
<blue>	spin_lock(&s->lock);</blue>
}

static void pic_unlock(struct kvm_pic *s)
	__releases(&amp;s-&gt;lock)
<blue>{</blue>
<blue>	bool wakeup = s->wakeup_needed;</blue>
	struct kvm_vcpu *vcpu;
	unsigned long i;

<blue>	s->wakeup_needed = false;</blue>

	spin_unlock(&amp;s-&gt;lock);

	if (wakeup) {
<blue>		kvm_for_each_vcpu(i, vcpu, s->kvm) {</blue>
<blue>			if (kvm_apic_accept_pic_intr(vcpu)) {</blue>
<blue>				kvm_make_request(KVM_REQ_EVENT, vcpu);</blue>
				kvm_vcpu_kick(vcpu);
				return;
			}
		}
	}
}

static void pic_clear_isr(struct kvm_kpic_state *s, int irq)
{
<blue>	s->isr &= ~(1 << irq);</blue>
	if (s != &amp;s-&gt;pics_state-&gt;pics[0])
<yellow>		irq += 8;</yellow>
	/*
	 * We are dropping lock while calling ack notifiers since ack
	 * notifier callbacks for assigned devices call into PIC recursively.
	 * Other interrupt may be delivered to PIC while lock is dropped but
	 * it should be safe since PIC state is already updated at this stage.
	 */
<blue>	pic_unlock(s->pics_state);</blue>
	kvm_notify_acked_irq(s-&gt;pics_state-&gt;kvm, SELECT_PIC(irq), irq);
	pic_lock(s-&gt;pics_state);
}

/*
 * set irq level. If an edge is detected, then the IRR is set to 1
 */
static inline int pic_set_irq1(struct kvm_kpic_state *s, int irq, int level)
{
	int mask, ret = 1;
	mask = 1 &lt;&lt; irq;
<yellow>	if (s->elcr & mask)	/* level triggered */</yellow>
		if (level) {
<yellow>			ret = !(s->irr & mask);</yellow>
			s-&gt;irr |= mask;
<blue>			s->last_irr |= mask;</blue>
		} else {
<yellow>			s->irr &= ~mask;</yellow>
			s-&gt;last_irr &amp;= ~mask;
		}
	else	/* edge triggered */
		if (level) {
<blue>			if ((s->last_irr & mask) == 0) {</blue>
<blue>				ret = !(s->irr & mask);</blue>
				s-&gt;irr |= mask;
			}
<blue>			s->last_irr |= mask;</blue>
		} else
<blue>			s->last_irr &= ~mask;</blue>

	return (s-&gt;imr &amp; mask) ? -1 : ret;
}

/*
 * return the highest priority found in mask (highest = smallest
 * number). Return 8 if no irq
 */
<yellow>static inline int get_priority(struct kvm_kpic_state *s, int mask)</yellow>
{
	int priority;
<blue>	if (mask == 0)</blue>
		return 8;
	priority = 0;
<yellow>	while ((mask & (1 << ((priority + s->priority_add) & 7))) == 0)</yellow>
		priority++;
	return priority;
}

/*
 * return the pic wanted interrupt. return -1 if none
 */
static int pic_get_irq(struct kvm_kpic_state *s)
{
	int mask, cur_priority, priority;

<blue>	mask = s->irr & ~s->imr;</blue>
<blue>	priority = get_priority(s, mask);</blue>
<yellow>	if (priority == 8)</yellow>
		return -1;
	/*
	 * compute current priority. If special fully nested mode on the
	 * master, the IRQ coming from the slave is not taken into account
	 * for the priority computation.
	 */
<blue>	mask = s->isr;</blue>
<yellow>	if (s->special_fully_nested_mode && s == &s->pics_state->pics[0])</yellow>
<yellow>		mask &= ~(1 << 2);</yellow>
<blue>	cur_priority = get_priority(s, mask);</blue>
<blue>	if (priority < cur_priority)</blue>
		/*
		 * higher priority found: an irq should be generated
		 */
		return (priority + s-&gt;priority_add) &amp; 7;
	else
		return -1;
<blue>}</blue>

/*
 * raise irq to CPU if necessary. must be called every time the active
 * irq may change
 */
static void pic_update_irq(struct kvm_pic *s)
{
	int irq2, irq;

<blue>	irq2 = pic_get_irq(&s->pics[1]);</blue>
	if (irq2 &gt;= 0) {
		/*
		 * if irq request by slave pic, signal master PIC
		 */
<yellow>		pic_set_irq1(&s->pics[0], 2, 1);</yellow>
<yellow>		pic_set_irq1(&s->pics[0], 2, 0);</yellow>
	}
<blue>	irq = pic_get_irq(&s->pics[0]);</blue>
<blue>	pic_irq_request(s->kvm, irq >= 0);</blue>
}

void kvm_pic_update_irq(struct kvm_pic *s)
{
<blue>	pic_lock(s);</blue>
	pic_update_irq(s);
	pic_unlock(s);
}

int kvm_pic_set_irq(struct kvm_pic *s, int irq, int irq_source_id, int level)
{
	int ret, irq_level;

<blue>	BUG_ON(irq < 0 || irq >= PIC_NUM_PINS);</blue>

<blue>	pic_lock(s);</blue>
<blue>	irq_level = __kvm_irq_line_state(&s->irq_states[irq],</blue>
					 irq_source_id, level);
<blue>	ret = pic_set_irq1(&s->pics[irq >> 3], irq & 7, irq_level);</blue>
<blue>	pic_update_irq(s);</blue>
<blue>	trace_kvm_pic_set_irq(irq >> 3, irq & 7, s->pics[irq >> 3].elcr,</blue>
			      s-&gt;pics[irq &gt;&gt; 3].imr, ret == 0);
<blue>	pic_unlock(s);</blue>

	return ret;
}

void kvm_pic_clear_all(struct kvm_pic *s, int irq_source_id)
{
	int i;

<yellow>	pic_lock(s);</yellow>
	for (i = 0; i &lt; PIC_NUM_PINS; i++)
<yellow>		__clear_bit(irq_source_id, &s->irq_states[i]);</yellow>
<yellow>	pic_unlock(s);</yellow>
}

/*
 * acknowledge interrupt &#x27;irq&#x27;
 */
<yellow>static inline void pic_intack(struct kvm_kpic_state *s, int irq)</yellow>
{
<blue>	s->isr |= 1 << irq;</blue>
	/*
	 * We don&#x27;t clear a level sensitive interrupt here
	 */
	if (!(s-&gt;elcr &amp; (1 &lt;&lt; irq)))
<blue>		s->irr &= ~(1 << irq);</blue>

<blue>	if (s->auto_eoi) {</blue>
<yellow>		if (s->rotate_on_auto_eoi)</yellow>
<yellow>			s->priority_add = (irq + 1) & 7;</yellow>
<yellow>		pic_clear_isr(s, irq);</yellow>
	}

}

int kvm_pic_read_irq(struct kvm *kvm)
{
	int irq, irq2, intno;
<blue>	struct kvm_pic *s = kvm->arch.vpic;</blue>

	s-&gt;output = 0;

	pic_lock(s);
	irq = pic_get_irq(&amp;s-&gt;pics[0]);
	if (irq &gt;= 0) {
<blue>		pic_intack(&s->pics[0], irq);</blue>
<blue>		if (irq == 2) {</blue>
<yellow>			irq2 = pic_get_irq(&s->pics[1]);</yellow>
			if (irq2 &gt;= 0)
<yellow>				pic_intack(&s->pics[1], irq2);</yellow>
			else
				/*
				 * spurious IRQ on slave controller
				 */
				irq2 = 7;
<yellow>			intno = s->pics[1].irq_base + irq2;</yellow>
		} else
<blue>			intno = s->pics[0].irq_base + irq;</blue>
	} else {
		/*
		 * spurious IRQ on host controller
		 */
		irq = 7;
<yellow>		intno = s->pics[0].irq_base + irq;</yellow>
	}
<blue>	pic_update_irq(s);</blue>
	pic_unlock(s);

	return intno;
}

static void kvm_pic_reset(struct kvm_kpic_state *s)
{
	int irq;
	unsigned long i;
	struct kvm_vcpu *vcpu;
<blue>	u8 edge_irr = s->irr & ~s->elcr;</blue>
	bool found = false;

	s-&gt;last_irr = 0;
	s-&gt;irr &amp;= s-&gt;elcr;
	s-&gt;imr = 0;
	s-&gt;priority_add = 0;
	s-&gt;special_mask = 0;
	s-&gt;read_reg_select = 0;
	if (!s-&gt;init4) {
<yellow>		s->special_fully_nested_mode = 0;</yellow>
		s-&gt;auto_eoi = 0;
	}
<blue>	s->init_state = 1;</blue>

<blue>	kvm_for_each_vcpu(i, vcpu, s->pics_state->kvm)</blue>
<blue>		if (kvm_apic_accept_pic_intr(vcpu)) {</blue>
			found = true;
			break;
		}


	if (!found)
		return;

<yellow>	for (irq = 0; irq < PIC_NUM_PINS/2; irq++)</yellow>
<yellow>		if (edge_irr & (1 << irq))</yellow>
<yellow>			pic_clear_isr(s, irq);</yellow>
}

static void pic_ioport_write(void *opaque, u32 addr, u32 val)
<blue>{</blue>
	struct kvm_kpic_state *s = opaque;
	int priority, cmd, irq;

	addr &amp;= 1;
<blue>	if (addr == 0) {</blue>
<blue>		if (val & 0x10) {</blue>
<blue>			s->init4 = val & 1;</blue>
			if (val &amp; 0x02)
<yellow>				pr_pic_unimpl("single mode not supported");</yellow>
<blue>			if (val & 0x08)</blue>
<yellow>				pr_pic_unimpl(</yellow>
						&quot;level sensitive irq not supported&quot;);
<blue>			kvm_pic_reset(s);</blue>
<blue>		} else if (val & 0x08) {</blue>
<yellow>			if (val & 0x04)</yellow>
<yellow>				s->poll = 1;</yellow>
<yellow>			if (val & 0x02)</yellow>
<yellow>				s->read_reg_select = val & 1;</yellow>
<yellow>			if (val & 0x40)</yellow>
<yellow>				s->special_mask = (val >> 5) & 1;</yellow>
		} else {
<blue>			cmd = val >> 5;</blue>
			switch (cmd) {
			case 0:
			case 4:
<blue>				s->rotate_on_auto_eoi = cmd >> 2;</blue>
				break;
			case 1:	/* end of interrupt */
			case 5:
<blue>				priority = get_priority(s, s->isr);</blue>
<yellow>				if (priority != 8) {</yellow>
					irq = (priority + s-&gt;priority_add) &amp; 7;
<blue>					if (cmd == 5)</blue>
<yellow>						s->priority_add = (irq + 1) & 7;</yellow>
<blue>					pic_clear_isr(s, irq);</blue>
					pic_update_irq(s-&gt;pics_state);
				}
				break;
			case 3:
<yellow>				irq = val & 7;</yellow>
				pic_clear_isr(s, irq);
				pic_update_irq(s-&gt;pics_state);
				break;
			case 6:
<yellow>				s->priority_add = (val + 1) & 7;</yellow>
				pic_update_irq(s-&gt;pics_state);
				break;
			case 7:
				irq = val &amp; 7;
<yellow>				s->priority_add = (irq + 1) & 7;</yellow>
				pic_clear_isr(s, irq);
				pic_update_irq(s-&gt;pics_state);
<blue>				break;</blue>
			default:
				break;	/* no operation */
			}
		}
	} else
<blue>		switch (s->init_state) {</blue>
		case 0: { /* normal mode */
<blue>			u8 imr_diff = s->imr ^ val,</blue>
				off = (s == &amp;s-&gt;pics_state-&gt;pics[0]) ? 0 : 8;
			s-&gt;imr = val;
<blue>			for (irq = 0; irq < PIC_NUM_PINS/2; irq++)</blue>
<blue>				if (imr_diff & (1 << irq))</blue>
					kvm_fire_mask_notifiers(
						s-&gt;pics_state-&gt;kvm,
						SELECT_PIC(irq + off),
						irq + off,
<blue>						!!(s->imr & (1 << irq)));</blue>
<blue>			pic_update_irq(s->pics_state);</blue>
			break;
		}
		case 1:
<blue>			s->irq_base = val & 0xf8;</blue>
			s-&gt;init_state = 2;
			break;
		case 2:
<blue>			if (s->init4)</blue>
<blue>				s->init_state = 3;</blue>
			else
<yellow>				s->init_state = 0;</yellow>
			break;
		case 3:
<blue>			s->special_fully_nested_mode = (val >> 4) & 1;</blue>
			s-&gt;auto_eoi = (val &gt;&gt; 1) &amp; 1;
			s-&gt;init_state = 0;
			break;
		}
}

static u32 pic_poll_read(struct kvm_kpic_state *s, u32 addr1)
{
	int ret;

	ret = pic_get_irq(s);
	if (ret &gt;= 0) {
		if (addr1 &gt;&gt; 7) {
<yellow>			s->pics_state->pics[0].isr &= ~(1 << 2);</yellow>
			s-&gt;pics_state-&gt;pics[0].irr &amp;= ~(1 &lt;&lt; 2);
		}
<yellow>		s->irr &= ~(1 << ret);</yellow>
		pic_clear_isr(s, ret);
		if (addr1 &gt;&gt; 7 || ret != 2)
<yellow>			pic_update_irq(s->pics_state);</yellow>
	} else {
		ret = 0x07;
<yellow>		pic_update_irq(s->pics_state);</yellow>
	}

	return ret;
}

static u32 pic_ioport_read(void *opaque, u32 addr)
{
	struct kvm_kpic_state *s = opaque;
	int ret;

	if (s-&gt;poll) {
<yellow>		ret = pic_poll_read(s, addr);</yellow>
<yellow>		s->poll = 0;</yellow>
	} else
<blue>		if ((addr & 1) == 0)</blue>
<yellow>			if (s->read_reg_select)</yellow>
<yellow>				ret = s->isr;</yellow>
			else
<yellow>				ret = s->irr;</yellow>
		else
<blue>			ret = s->imr;</blue>
	return ret;
}

static void elcr_ioport_write(void *opaque, u32 val)
{
	struct kvm_kpic_state *s = opaque;
	s-&gt;elcr = val &amp; s-&gt;elcr_mask;
}

static u32 elcr_ioport_read(void *opaque)
{
	struct kvm_kpic_state *s = opaque;
	return s-&gt;elcr;
}

static int picdev_write(struct kvm_pic *s,
			 gpa_t addr, int len, const void *val)
{
<blue>	unsigned char data = *(unsigned char *)val;</blue>

	if (len != 1) {
<yellow>		pr_pic_unimpl("non byte write\n");</yellow>
		return 0;
	}
<blue>	switch (addr) {</blue>
	case 0x20:
	case 0x21:
<blue>		pic_lock(s);</blue>
		pic_ioport_write(&amp;s-&gt;pics[0], addr, data);
		pic_unlock(s);
		break;
	case 0xa0:
	case 0xa1:
<blue>		pic_lock(s);</blue>
		pic_ioport_write(&amp;s-&gt;pics[1], addr, data);
		pic_unlock(s);
		break;
	case 0x4d0:
	case 0x4d1:
		pic_lock(s);
<blue>		elcr_ioport_write(&s->pics[addr & 1], data);</blue>
		pic_unlock(s);
		break;
	default:
		return -EOPNOTSUPP;
	}
	return 0;
<blue>}</blue>

static int picdev_read(struct kvm_pic *s,
		       gpa_t addr, int len, void *val)
{
	unsigned char *data = (unsigned char *)val;

<blue>	if (len != 1) {</blue>
<yellow>		memset(val, 0, len);</yellow>
		pr_pic_unimpl(&quot;non byte read\n&quot;);
		return 0;
	}
<blue>	switch (addr) {</blue>
	case 0x20:
	case 0x21:
	case 0xa0:
	case 0xa1:
		pic_lock(s);
<blue>		*data = pic_ioport_read(&s->pics[addr >> 7], addr);</blue>
		pic_unlock(s);
		break;
	case 0x4d0:
	case 0x4d1:
		pic_lock(s);
<yellow>		*data = elcr_ioport_read(&s->pics[addr & 1]);</yellow>
		pic_unlock(s);
		break;
	default:
		return -EOPNOTSUPP;
	}
	return 0;
<blue>}</blue>

static int picdev_master_write(struct kvm_vcpu *vcpu, struct kvm_io_device *dev,
			       gpa_t addr, int len, const void *val)
{
<blue>	return picdev_write(container_of(dev, struct kvm_pic, dev_master),</blue>
			    addr, len, val);
}

static int picdev_master_read(struct kvm_vcpu *vcpu, struct kvm_io_device *dev,
			      gpa_t addr, int len, void *val)
{
<blue>	return picdev_read(container_of(dev, struct kvm_pic, dev_master),</blue>
			    addr, len, val);
}

static int picdev_slave_write(struct kvm_vcpu *vcpu, struct kvm_io_device *dev,
			      gpa_t addr, int len, const void *val)
{
<blue>	return picdev_write(container_of(dev, struct kvm_pic, dev_slave),</blue>
			    addr, len, val);
}

static int picdev_slave_read(struct kvm_vcpu *vcpu, struct kvm_io_device *dev,
			     gpa_t addr, int len, void *val)
{
<blue>	return picdev_read(container_of(dev, struct kvm_pic, dev_slave),</blue>
			    addr, len, val);
}

static int picdev_elcr_write(struct kvm_vcpu *vcpu, struct kvm_io_device *dev,
			     gpa_t addr, int len, const void *val)
{
<blue>	return picdev_write(container_of(dev, struct kvm_pic, dev_elcr),</blue>
			    addr, len, val);
}

static int picdev_elcr_read(struct kvm_vcpu *vcpu, struct kvm_io_device *dev,
			    gpa_t addr, int len, void *val)
{
<yellow>	return picdev_read(container_of(dev, struct kvm_pic, dev_elcr),</yellow>
			    addr, len, val);
}

/*
 * callback when PIC0 irq status changed
 */
static void pic_irq_request(struct kvm *kvm, int level)
{
	struct kvm_pic *s = kvm-&gt;arch.vpic;

	if (!s-&gt;output)
<blue>		s->wakeup_needed = true;</blue>
<blue>	s->output = level;</blue>
}

static const struct kvm_io_device_ops picdev_master_ops = {
	.read     = picdev_master_read,
	.write    = picdev_master_write,
};

static const struct kvm_io_device_ops picdev_slave_ops = {
	.read     = picdev_slave_read,
	.write    = picdev_slave_write,
};

static const struct kvm_io_device_ops picdev_elcr_ops = {
	.read     = picdev_elcr_read,
	.write    = picdev_elcr_write,
};

int kvm_pic_init(struct kvm *kvm)
{
	struct kvm_pic *s;
	int ret;

<blue>	s = kzalloc(sizeof(struct kvm_pic), GFP_KERNEL_ACCOUNT);</blue>
	if (!s)
		return -ENOMEM;
<blue>	spin_lock_init(&s->lock);</blue>
	s-&gt;kvm = kvm;
	s-&gt;pics[0].elcr_mask = 0xf8;
	s-&gt;pics[1].elcr_mask = 0xde;
	s-&gt;pics[0].pics_state = s;
	s-&gt;pics[1].pics_state = s;

	/*
	 * Initialize PIO device
	 */
	kvm_iodevice_init(&amp;s-&gt;dev_master, &amp;picdev_master_ops);
	kvm_iodevice_init(&amp;s-&gt;dev_slave, &amp;picdev_slave_ops);
	kvm_iodevice_init(&amp;s-&gt;dev_elcr, &amp;picdev_elcr_ops);
	mutex_lock(&amp;kvm-&gt;slots_lock);
	ret = kvm_io_bus_register_dev(kvm, KVM_PIO_BUS, 0x20, 2,
				      &amp;s-&gt;dev_master);
	if (ret &lt; 0)
		goto fail_unlock;

<blue>	ret = kvm_io_bus_register_dev(kvm, KVM_PIO_BUS, 0xa0, 2, &s->dev_slave);</blue>
	if (ret &lt; 0)
		goto fail_unreg_2;

<blue>	ret = kvm_io_bus_register_dev(kvm, KVM_PIO_BUS, 0x4d0, 2, &s->dev_elcr);</blue>
	if (ret &lt; 0)
		goto fail_unreg_1;

<blue>	mutex_unlock(&kvm->slots_lock);</blue>

	kvm-&gt;arch.vpic = s;

	return 0;

fail_unreg_1:
<yellow>	kvm_io_bus_unregister_dev(kvm, KVM_PIO_BUS, &s->dev_slave);</yellow>

fail_unreg_2:
<yellow>	kvm_io_bus_unregister_dev(kvm, KVM_PIO_BUS, &s->dev_master);</yellow>

fail_unlock:
<yellow>	mutex_unlock(&kvm->slots_lock);</yellow>

	kfree(s);

	return ret;
<blue>}</blue>

void kvm_pic_destroy(struct kvm *kvm)
{
<yellow>	struct kvm_pic *vpic = kvm->arch.vpic;</yellow>

	if (!vpic)
		return;

<yellow>	mutex_lock(&kvm->slots_lock);</yellow>
	kvm_io_bus_unregister_dev(vpic-&gt;kvm, KVM_PIO_BUS, &amp;vpic-&gt;dev_master);
	kvm_io_bus_unregister_dev(vpic-&gt;kvm, KVM_PIO_BUS, &amp;vpic-&gt;dev_slave);
	kvm_io_bus_unregister_dev(vpic-&gt;kvm, KVM_PIO_BUS, &amp;vpic-&gt;dev_elcr);
	mutex_unlock(&amp;kvm-&gt;slots_lock);

	kvm-&gt;arch.vpic = NULL;
	kfree(vpic);
<yellow>}</yellow>


</code></pre></td></tr></table>
</body>
</html>
