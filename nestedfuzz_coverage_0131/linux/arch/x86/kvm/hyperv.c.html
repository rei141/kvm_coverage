<doctype html>
<html lang="ja">
<head>
<meta charset="utf-8">
<script src="https://cdn.rawgit.com/google/code-prettify/master/loader/run_prettify.js"></script>
<style>
    code{
        font-family:Monaco, Menlo, Consolas, 'Courier New', Courier, monospace, sans-serif;
        font-size: 14px;
        line-height: 18px;
        overflow: auto;
        resize: horizontal;
    }
    code_line{
        font-family: Monaco, Menlo, Consolas, 'Courier New', Courier, monospace, sans-serif;;
        font-size: 14px;
        line-height: 18px;
        overflow: auto;
        resize: horizontal;
        color:#303134;
    }
    blue{
        background-color:#BEEDE8;
    }
    yellow{
        background-color:#FFFF99;
    }
    red{
        background-color:#FF99AC;
    }
</style>

</head>
<body>
<table summary='blob content' class='blob' cellspacing="15">
<tr><td align="right"><pre><code_line>1.<br>2.<br>3.<br>4.<br>5.<br>6.<br>7.<br>8.<br>9.<br>10.<br>11.<br>12.<br>13.<br>14.<br>15.<br>16.<br>17.<br>18.<br>19.<br>20.<br>21.<br>22.<br>23.<br>24.<br>25.<br>26.<br>27.<br>28.<br>29.<br>30.<br>31.<br>32.<br>33.<br>34.<br>35.<br>36.<br>37.<br>38.<br>39.<br>40.<br>41.<br>42.<br>43.<br>44.<br>45.<br>46.<br>47.<br>48.<br>49.<br>50.<br>51.<br>52.<br>53.<br>54.<br>55.<br>56.<br>57.<br>58.<br>59.<br>60.<br>61.<br>62.<br>63.<br>64.<br>65.<br>66.<br>67.<br>68.<br>69.<br>70.<br>71.<br>72.<br>73.<br>74.<br>75.<br>76.<br>77.<br>78.<br>79.<br>80.<br>81.<br>82.<br>83.<br>84.<br>85.<br>86.<br>87.<br>88.<br>89.<br>90.<br>91.<br>92.<br>93.<br>94.<br>95.<br>96.<br>97.<br>98.<br>99.<br>100.<br>101.<br>102.<br>103.<br>104.<br>105.<br>106.<br>107.<br>108.<br>109.<br>110.<br>111.<br>112.<br>113.<br>114.<br>115.<br>116.<br>117.<br>118.<br>119.<br>120.<br>121.<br>122.<br>123.<br>124.<br>125.<br>126.<br>127.<br>128.<br>129.<br>130.<br>131.<br>132.<br>133.<br>134.<br>135.<br>136.<br>137.<br>138.<br>139.<br>140.<br>141.<br>142.<br>143.<br>144.<br>145.<br>146.<br>147.<br>148.<br>149.<br>150.<br>151.<br>152.<br>153.<br>154.<br>155.<br>156.<br>157.<br>158.<br>159.<br>160.<br>161.<br>162.<br>163.<br>164.<br>165.<br>166.<br>167.<br>168.<br>169.<br>170.<br>171.<br>172.<br>173.<br>174.<br>175.<br>176.<br>177.<br>178.<br>179.<br>180.<br>181.<br>182.<br>183.<br>184.<br>185.<br>186.<br>187.<br>188.<br>189.<br>190.<br>191.<br>192.<br>193.<br>194.<br>195.<br>196.<br>197.<br>198.<br>199.<br>200.<br>201.<br>202.<br>203.<br>204.<br>205.<br>206.<br>207.<br>208.<br>209.<br>210.<br>211.<br>212.<br>213.<br>214.<br>215.<br>216.<br>217.<br>218.<br>219.<br>220.<br>221.<br>222.<br>223.<br>224.<br>225.<br>226.<br>227.<br>228.<br>229.<br>230.<br>231.<br>232.<br>233.<br>234.<br>235.<br>236.<br>237.<br>238.<br>239.<br>240.<br>241.<br>242.<br>243.<br>244.<br>245.<br>246.<br>247.<br>248.<br>249.<br>250.<br>251.<br>252.<br>253.<br>254.<br>255.<br>256.<br>257.<br>258.<br>259.<br>260.<br>261.<br>262.<br>263.<br>264.<br>265.<br>266.<br>267.<br>268.<br>269.<br>270.<br>271.<br>272.<br>273.<br>274.<br>275.<br>276.<br>277.<br>278.<br>279.<br>280.<br>281.<br>282.<br>283.<br>284.<br>285.<br>286.<br>287.<br>288.<br>289.<br>290.<br>291.<br>292.<br>293.<br>294.<br>295.<br>296.<br>297.<br>298.<br>299.<br>300.<br>301.<br>302.<br>303.<br>304.<br>305.<br>306.<br>307.<br>308.<br>309.<br>310.<br>311.<br>312.<br>313.<br>314.<br>315.<br>316.<br>317.<br>318.<br>319.<br>320.<br>321.<br>322.<br>323.<br>324.<br>325.<br>326.<br>327.<br>328.<br>329.<br>330.<br>331.<br>332.<br>333.<br>334.<br>335.<br>336.<br>337.<br>338.<br>339.<br>340.<br>341.<br>342.<br>343.<br>344.<br>345.<br>346.<br>347.<br>348.<br>349.<br>350.<br>351.<br>352.<br>353.<br>354.<br>355.<br>356.<br>357.<br>358.<br>359.<br>360.<br>361.<br>362.<br>363.<br>364.<br>365.<br>366.<br>367.<br>368.<br>369.<br>370.<br>371.<br>372.<br>373.<br>374.<br>375.<br>376.<br>377.<br>378.<br>379.<br>380.<br>381.<br>382.<br>383.<br>384.<br>385.<br>386.<br>387.<br>388.<br>389.<br>390.<br>391.<br>392.<br>393.<br>394.<br>395.<br>396.<br>397.<br>398.<br>399.<br>400.<br>401.<br>402.<br>403.<br>404.<br>405.<br>406.<br>407.<br>408.<br>409.<br>410.<br>411.<br>412.<br>413.<br>414.<br>415.<br>416.<br>417.<br>418.<br>419.<br>420.<br>421.<br>422.<br>423.<br>424.<br>425.<br>426.<br>427.<br>428.<br>429.<br>430.<br>431.<br>432.<br>433.<br>434.<br>435.<br>436.<br>437.<br>438.<br>439.<br>440.<br>441.<br>442.<br>443.<br>444.<br>445.<br>446.<br>447.<br>448.<br>449.<br>450.<br>451.<br>452.<br>453.<br>454.<br>455.<br>456.<br>457.<br>458.<br>459.<br>460.<br>461.<br>462.<br>463.<br>464.<br>465.<br>466.<br>467.<br>468.<br>469.<br>470.<br>471.<br>472.<br>473.<br>474.<br>475.<br>476.<br>477.<br>478.<br>479.<br>480.<br>481.<br>482.<br>483.<br>484.<br>485.<br>486.<br>487.<br>488.<br>489.<br>490.<br>491.<br>492.<br>493.<br>494.<br>495.<br>496.<br>497.<br>498.<br>499.<br>500.<br>501.<br>502.<br>503.<br>504.<br>505.<br>506.<br>507.<br>508.<br>509.<br>510.<br>511.<br>512.<br>513.<br>514.<br>515.<br>516.<br>517.<br>518.<br>519.<br>520.<br>521.<br>522.<br>523.<br>524.<br>525.<br>526.<br>527.<br>528.<br>529.<br>530.<br>531.<br>532.<br>533.<br>534.<br>535.<br>536.<br>537.<br>538.<br>539.<br>540.<br>541.<br>542.<br>543.<br>544.<br>545.<br>546.<br>547.<br>548.<br>549.<br>550.<br>551.<br>552.<br>553.<br>554.<br>555.<br>556.<br>557.<br>558.<br>559.<br>560.<br>561.<br>562.<br>563.<br>564.<br>565.<br>566.<br>567.<br>568.<br>569.<br>570.<br>571.<br>572.<br>573.<br>574.<br>575.<br>576.<br>577.<br>578.<br>579.<br>580.<br>581.<br>582.<br>583.<br>584.<br>585.<br>586.<br>587.<br>588.<br>589.<br>590.<br>591.<br>592.<br>593.<br>594.<br>595.<br>596.<br>597.<br>598.<br>599.<br>600.<br>601.<br>602.<br>603.<br>604.<br>605.<br>606.<br>607.<br>608.<br>609.<br>610.<br>611.<br>612.<br>613.<br>614.<br>615.<br>616.<br>617.<br>618.<br>619.<br>620.<br>621.<br>622.<br>623.<br>624.<br>625.<br>626.<br>627.<br>628.<br>629.<br>630.<br>631.<br>632.<br>633.<br>634.<br>635.<br>636.<br>637.<br>638.<br>639.<br>640.<br>641.<br>642.<br>643.<br>644.<br>645.<br>646.<br>647.<br>648.<br>649.<br>650.<br>651.<br>652.<br>653.<br>654.<br>655.<br>656.<br>657.<br>658.<br>659.<br>660.<br>661.<br>662.<br>663.<br>664.<br>665.<br>666.<br>667.<br>668.<br>669.<br>670.<br>671.<br>672.<br>673.<br>674.<br>675.<br>676.<br>677.<br>678.<br>679.<br>680.<br>681.<br>682.<br>683.<br>684.<br>685.<br>686.<br>687.<br>688.<br>689.<br>690.<br>691.<br>692.<br>693.<br>694.<br>695.<br>696.<br>697.<br>698.<br>699.<br>700.<br>701.<br>702.<br>703.<br>704.<br>705.<br>706.<br>707.<br>708.<br>709.<br>710.<br>711.<br>712.<br>713.<br>714.<br>715.<br>716.<br>717.<br>718.<br>719.<br>720.<br>721.<br>722.<br>723.<br>724.<br>725.<br>726.<br>727.<br>728.<br>729.<br>730.<br>731.<br>732.<br>733.<br>734.<br>735.<br>736.<br>737.<br>738.<br>739.<br>740.<br>741.<br>742.<br>743.<br>744.<br>745.<br>746.<br>747.<br>748.<br>749.<br>750.<br>751.<br>752.<br>753.<br>754.<br>755.<br>756.<br>757.<br>758.<br>759.<br>760.<br>761.<br>762.<br>763.<br>764.<br>765.<br>766.<br>767.<br>768.<br>769.<br>770.<br>771.<br>772.<br>773.<br>774.<br>775.<br>776.<br>777.<br>778.<br>779.<br>780.<br>781.<br>782.<br>783.<br>784.<br>785.<br>786.<br>787.<br>788.<br>789.<br>790.<br>791.<br>792.<br>793.<br>794.<br>795.<br>796.<br>797.<br>798.<br>799.<br>800.<br>801.<br>802.<br>803.<br>804.<br>805.<br>806.<br>807.<br>808.<br>809.<br>810.<br>811.<br>812.<br>813.<br>814.<br>815.<br>816.<br>817.<br>818.<br>819.<br>820.<br>821.<br>822.<br>823.<br>824.<br>825.<br>826.<br>827.<br>828.<br>829.<br>830.<br>831.<br>832.<br>833.<br>834.<br>835.<br>836.<br>837.<br>838.<br>839.<br>840.<br>841.<br>842.<br>843.<br>844.<br>845.<br>846.<br>847.<br>848.<br>849.<br>850.<br>851.<br>852.<br>853.<br>854.<br>855.<br>856.<br>857.<br>858.<br>859.<br>860.<br>861.<br>862.<br>863.<br>864.<br>865.<br>866.<br>867.<br>868.<br>869.<br>870.<br>871.<br>872.<br>873.<br>874.<br>875.<br>876.<br>877.<br>878.<br>879.<br>880.<br>881.<br>882.<br>883.<br>884.<br>885.<br>886.<br>887.<br>888.<br>889.<br>890.<br>891.<br>892.<br>893.<br>894.<br>895.<br>896.<br>897.<br>898.<br>899.<br>900.<br>901.<br>902.<br>903.<br>904.<br>905.<br>906.<br>907.<br>908.<br>909.<br>910.<br>911.<br>912.<br>913.<br>914.<br>915.<br>916.<br>917.<br>918.<br>919.<br>920.<br>921.<br>922.<br>923.<br>924.<br>925.<br>926.<br>927.<br>928.<br>929.<br>930.<br>931.<br>932.<br>933.<br>934.<br>935.<br>936.<br>937.<br>938.<br>939.<br>940.<br>941.<br>942.<br>943.<br>944.<br>945.<br>946.<br>947.<br>948.<br>949.<br>950.<br>951.<br>952.<br>953.<br>954.<br>955.<br>956.<br>957.<br>958.<br>959.<br>960.<br>961.<br>962.<br>963.<br>964.<br>965.<br>966.<br>967.<br>968.<br>969.<br>970.<br>971.<br>972.<br>973.<br>974.<br>975.<br>976.<br>977.<br>978.<br>979.<br>980.<br>981.<br>982.<br>983.<br>984.<br>985.<br>986.<br>987.<br>988.<br>989.<br>990.<br>991.<br>992.<br>993.<br>994.<br>995.<br>996.<br>997.<br>998.<br>999.<br>1000.<br>1001.<br>1002.<br>1003.<br>1004.<br>1005.<br>1006.<br>1007.<br>1008.<br>1009.<br>1010.<br>1011.<br>1012.<br>1013.<br>1014.<br>1015.<br>1016.<br>1017.<br>1018.<br>1019.<br>1020.<br>1021.<br>1022.<br>1023.<br>1024.<br>1025.<br>1026.<br>1027.<br>1028.<br>1029.<br>1030.<br>1031.<br>1032.<br>1033.<br>1034.<br>1035.<br>1036.<br>1037.<br>1038.<br>1039.<br>1040.<br>1041.<br>1042.<br>1043.<br>1044.<br>1045.<br>1046.<br>1047.<br>1048.<br>1049.<br>1050.<br>1051.<br>1052.<br>1053.<br>1054.<br>1055.<br>1056.<br>1057.<br>1058.<br>1059.<br>1060.<br>1061.<br>1062.<br>1063.<br>1064.<br>1065.<br>1066.<br>1067.<br>1068.<br>1069.<br>1070.<br>1071.<br>1072.<br>1073.<br>1074.<br>1075.<br>1076.<br>1077.<br>1078.<br>1079.<br>1080.<br>1081.<br>1082.<br>1083.<br>1084.<br>1085.<br>1086.<br>1087.<br>1088.<br>1089.<br>1090.<br>1091.<br>1092.<br>1093.<br>1094.<br>1095.<br>1096.<br>1097.<br>1098.<br>1099.<br>1100.<br>1101.<br>1102.<br>1103.<br>1104.<br>1105.<br>1106.<br>1107.<br>1108.<br>1109.<br>1110.<br>1111.<br>1112.<br>1113.<br>1114.<br>1115.<br>1116.<br>1117.<br>1118.<br>1119.<br>1120.<br>1121.<br>1122.<br>1123.<br>1124.<br>1125.<br>1126.<br>1127.<br>1128.<br>1129.<br>1130.<br>1131.<br>1132.<br>1133.<br>1134.<br>1135.<br>1136.<br>1137.<br>1138.<br>1139.<br>1140.<br>1141.<br>1142.<br>1143.<br>1144.<br>1145.<br>1146.<br>1147.<br>1148.<br>1149.<br>1150.<br>1151.<br>1152.<br>1153.<br>1154.<br>1155.<br>1156.<br>1157.<br>1158.<br>1159.<br>1160.<br>1161.<br>1162.<br>1163.<br>1164.<br>1165.<br>1166.<br>1167.<br>1168.<br>1169.<br>1170.<br>1171.<br>1172.<br>1173.<br>1174.<br>1175.<br>1176.<br>1177.<br>1178.<br>1179.<br>1180.<br>1181.<br>1182.<br>1183.<br>1184.<br>1185.<br>1186.<br>1187.<br>1188.<br>1189.<br>1190.<br>1191.<br>1192.<br>1193.<br>1194.<br>1195.<br>1196.<br>1197.<br>1198.<br>1199.<br>1200.<br>1201.<br>1202.<br>1203.<br>1204.<br>1205.<br>1206.<br>1207.<br>1208.<br>1209.<br>1210.<br>1211.<br>1212.<br>1213.<br>1214.<br>1215.<br>1216.<br>1217.<br>1218.<br>1219.<br>1220.<br>1221.<br>1222.<br>1223.<br>1224.<br>1225.<br>1226.<br>1227.<br>1228.<br>1229.<br>1230.<br>1231.<br>1232.<br>1233.<br>1234.<br>1235.<br>1236.<br>1237.<br>1238.<br>1239.<br>1240.<br>1241.<br>1242.<br>1243.<br>1244.<br>1245.<br>1246.<br>1247.<br>1248.<br>1249.<br>1250.<br>1251.<br>1252.<br>1253.<br>1254.<br>1255.<br>1256.<br>1257.<br>1258.<br>1259.<br>1260.<br>1261.<br>1262.<br>1263.<br>1264.<br>1265.<br>1266.<br>1267.<br>1268.<br>1269.<br>1270.<br>1271.<br>1272.<br>1273.<br>1274.<br>1275.<br>1276.<br>1277.<br>1278.<br>1279.<br>1280.<br>1281.<br>1282.<br>1283.<br>1284.<br>1285.<br>1286.<br>1287.<br>1288.<br>1289.<br>1290.<br>1291.<br>1292.<br>1293.<br>1294.<br>1295.<br>1296.<br>1297.<br>1298.<br>1299.<br>1300.<br>1301.<br>1302.<br>1303.<br>1304.<br>1305.<br>1306.<br>1307.<br>1308.<br>1309.<br>1310.<br>1311.<br>1312.<br>1313.<br>1314.<br>1315.<br>1316.<br>1317.<br>1318.<br>1319.<br>1320.<br>1321.<br>1322.<br>1323.<br>1324.<br>1325.<br>1326.<br>1327.<br>1328.<br>1329.<br>1330.<br>1331.<br>1332.<br>1333.<br>1334.<br>1335.<br>1336.<br>1337.<br>1338.<br>1339.<br>1340.<br>1341.<br>1342.<br>1343.<br>1344.<br>1345.<br>1346.<br>1347.<br>1348.<br>1349.<br>1350.<br>1351.<br>1352.<br>1353.<br>1354.<br>1355.<br>1356.<br>1357.<br>1358.<br>1359.<br>1360.<br>1361.<br>1362.<br>1363.<br>1364.<br>1365.<br>1366.<br>1367.<br>1368.<br>1369.<br>1370.<br>1371.<br>1372.<br>1373.<br>1374.<br>1375.<br>1376.<br>1377.<br>1378.<br>1379.<br>1380.<br>1381.<br>1382.<br>1383.<br>1384.<br>1385.<br>1386.<br>1387.<br>1388.<br>1389.<br>1390.<br>1391.<br>1392.<br>1393.<br>1394.<br>1395.<br>1396.<br>1397.<br>1398.<br>1399.<br>1400.<br>1401.<br>1402.<br>1403.<br>1404.<br>1405.<br>1406.<br>1407.<br>1408.<br>1409.<br>1410.<br>1411.<br>1412.<br>1413.<br>1414.<br>1415.<br>1416.<br>1417.<br>1418.<br>1419.<br>1420.<br>1421.<br>1422.<br>1423.<br>1424.<br>1425.<br>1426.<br>1427.<br>1428.<br>1429.<br>1430.<br>1431.<br>1432.<br>1433.<br>1434.<br>1435.<br>1436.<br>1437.<br>1438.<br>1439.<br>1440.<br>1441.<br>1442.<br>1443.<br>1444.<br>1445.<br>1446.<br>1447.<br>1448.<br>1449.<br>1450.<br>1451.<br>1452.<br>1453.<br>1454.<br>1455.<br>1456.<br>1457.<br>1458.<br>1459.<br>1460.<br>1461.<br>1462.<br>1463.<br>1464.<br>1465.<br>1466.<br>1467.<br>1468.<br>1469.<br>1470.<br>1471.<br>1472.<br>1473.<br>1474.<br>1475.<br>1476.<br>1477.<br>1478.<br>1479.<br>1480.<br>1481.<br>1482.<br>1483.<br>1484.<br>1485.<br>1486.<br>1487.<br>1488.<br>1489.<br>1490.<br>1491.<br>1492.<br>1493.<br>1494.<br>1495.<br>1496.<br>1497.<br>1498.<br>1499.<br>1500.<br>1501.<br>1502.<br>1503.<br>1504.<br>1505.<br>1506.<br>1507.<br>1508.<br>1509.<br>1510.<br>1511.<br>1512.<br>1513.<br>1514.<br>1515.<br>1516.<br>1517.<br>1518.<br>1519.<br>1520.<br>1521.<br>1522.<br>1523.<br>1524.<br>1525.<br>1526.<br>1527.<br>1528.<br>1529.<br>1530.<br>1531.<br>1532.<br>1533.<br>1534.<br>1535.<br>1536.<br>1537.<br>1538.<br>1539.<br>1540.<br>1541.<br>1542.<br>1543.<br>1544.<br>1545.<br>1546.<br>1547.<br>1548.<br>1549.<br>1550.<br>1551.<br>1552.<br>1553.<br>1554.<br>1555.<br>1556.<br>1557.<br>1558.<br>1559.<br>1560.<br>1561.<br>1562.<br>1563.<br>1564.<br>1565.<br>1566.<br>1567.<br>1568.<br>1569.<br>1570.<br>1571.<br>1572.<br>1573.<br>1574.<br>1575.<br>1576.<br>1577.<br>1578.<br>1579.<br>1580.<br>1581.<br>1582.<br>1583.<br>1584.<br>1585.<br>1586.<br>1587.<br>1588.<br>1589.<br>1590.<br>1591.<br>1592.<br>1593.<br>1594.<br>1595.<br>1596.<br>1597.<br>1598.<br>1599.<br>1600.<br>1601.<br>1602.<br>1603.<br>1604.<br>1605.<br>1606.<br>1607.<br>1608.<br>1609.<br>1610.<br>1611.<br>1612.<br>1613.<br>1614.<br>1615.<br>1616.<br>1617.<br>1618.<br>1619.<br>1620.<br>1621.<br>1622.<br>1623.<br>1624.<br>1625.<br>1626.<br>1627.<br>1628.<br>1629.<br>1630.<br>1631.<br>1632.<br>1633.<br>1634.<br>1635.<br>1636.<br>1637.<br>1638.<br>1639.<br>1640.<br>1641.<br>1642.<br>1643.<br>1644.<br>1645.<br>1646.<br>1647.<br>1648.<br>1649.<br>1650.<br>1651.<br>1652.<br>1653.<br>1654.<br>1655.<br>1656.<br>1657.<br>1658.<br>1659.<br>1660.<br>1661.<br>1662.<br>1663.<br>1664.<br>1665.<br>1666.<br>1667.<br>1668.<br>1669.<br>1670.<br>1671.<br>1672.<br>1673.<br>1674.<br>1675.<br>1676.<br>1677.<br>1678.<br>1679.<br>1680.<br>1681.<br>1682.<br>1683.<br>1684.<br>1685.<br>1686.<br>1687.<br>1688.<br>1689.<br>1690.<br>1691.<br>1692.<br>1693.<br>1694.<br>1695.<br>1696.<br>1697.<br>1698.<br>1699.<br>1700.<br>1701.<br>1702.<br>1703.<br>1704.<br>1705.<br>1706.<br>1707.<br>1708.<br>1709.<br>1710.<br>1711.<br>1712.<br>1713.<br>1714.<br>1715.<br>1716.<br>1717.<br>1718.<br>1719.<br>1720.<br>1721.<br>1722.<br>1723.<br>1724.<br>1725.<br>1726.<br>1727.<br>1728.<br>1729.<br>1730.<br>1731.<br>1732.<br>1733.<br>1734.<br>1735.<br>1736.<br>1737.<br>1738.<br>1739.<br>1740.<br>1741.<br>1742.<br>1743.<br>1744.<br>1745.<br>1746.<br>1747.<br>1748.<br>1749.<br>1750.<br>1751.<br>1752.<br>1753.<br>1754.<br>1755.<br>1756.<br>1757.<br>1758.<br>1759.<br>1760.<br>1761.<br>1762.<br>1763.<br>1764.<br>1765.<br>1766.<br>1767.<br>1768.<br>1769.<br>1770.<br>1771.<br>1772.<br>1773.<br>1774.<br>1775.<br>1776.<br>1777.<br>1778.<br>1779.<br>1780.<br>1781.<br>1782.<br>1783.<br>1784.<br>1785.<br>1786.<br>1787.<br>1788.<br>1789.<br>1790.<br>1791.<br>1792.<br>1793.<br>1794.<br>1795.<br>1796.<br>1797.<br>1798.<br>1799.<br>1800.<br>1801.<br>1802.<br>1803.<br>1804.<br>1805.<br>1806.<br>1807.<br>1808.<br>1809.<br>1810.<br>1811.<br>1812.<br>1813.<br>1814.<br>1815.<br>1816.<br>1817.<br>1818.<br>1819.<br>1820.<br>1821.<br>1822.<br>1823.<br>1824.<br>1825.<br>1826.<br>1827.<br>1828.<br>1829.<br>1830.<br>1831.<br>1832.<br>1833.<br>1834.<br>1835.<br>1836.<br>1837.<br>1838.<br>1839.<br>1840.<br>1841.<br>1842.<br>1843.<br>1844.<br>1845.<br>1846.<br>1847.<br>1848.<br>1849.<br>1850.<br>1851.<br>1852.<br>1853.<br>1854.<br>1855.<br>1856.<br>1857.<br>1858.<br>1859.<br>1860.<br>1861.<br>1862.<br>1863.<br>1864.<br>1865.<br>1866.<br>1867.<br>1868.<br>1869.<br>1870.<br>1871.<br>1872.<br>1873.<br>1874.<br>1875.<br>1876.<br>1877.<br>1878.<br>1879.<br>1880.<br>1881.<br>1882.<br>1883.<br>1884.<br>1885.<br>1886.<br>1887.<br>1888.<br>1889.<br>1890.<br>1891.<br>1892.<br>1893.<br>1894.<br>1895.<br>1896.<br>1897.<br>1898.<br>1899.<br>1900.<br>1901.<br>1902.<br>1903.<br>1904.<br>1905.<br>1906.<br>1907.<br>1908.<br>1909.<br>1910.<br>1911.<br>1912.<br>1913.<br>1914.<br>1915.<br>1916.<br>1917.<br>1918.<br>1919.<br>1920.<br>1921.<br>1922.<br>1923.<br>1924.<br>1925.<br>1926.<br>1927.<br>1928.<br>1929.<br>1930.<br>1931.<br>1932.<br>1933.<br>1934.<br>1935.<br>1936.<br>1937.<br>1938.<br>1939.<br>1940.<br>1941.<br>1942.<br>1943.<br>1944.<br>1945.<br>1946.<br>1947.<br>1948.<br>1949.<br>1950.<br>1951.<br>1952.<br>1953.<br>1954.<br>1955.<br>1956.<br>1957.<br>1958.<br>1959.<br>1960.<br>1961.<br>1962.<br>1963.<br>1964.<br>1965.<br>1966.<br>1967.<br>1968.<br>1969.<br>1970.<br>1971.<br>1972.<br>1973.<br>1974.<br>1975.<br>1976.<br>1977.<br>1978.<br>1979.<br>1980.<br>1981.<br>1982.<br>1983.<br>1984.<br>1985.<br>1986.<br>1987.<br>1988.<br>1989.<br>1990.<br>1991.<br>1992.<br>1993.<br>1994.<br>1995.<br>1996.<br>1997.<br>1998.<br>1999.<br>2000.<br>2001.<br>2002.<br>2003.<br>2004.<br>2005.<br>2006.<br>2007.<br>2008.<br>2009.<br>2010.<br>2011.<br>2012.<br>2013.<br>2014.<br>2015.<br>2016.<br>2017.<br>2018.<br>2019.<br>2020.<br>2021.<br>2022.<br>2023.<br>2024.<br>2025.<br>2026.<br>2027.<br>2028.<br>2029.<br>2030.<br>2031.<br>2032.<br>2033.<br>2034.<br>2035.<br>2036.<br>2037.<br>2038.<br>2039.<br>2040.<br>2041.<br>2042.<br>2043.<br>2044.<br>2045.<br>2046.<br>2047.<br>2048.<br>2049.<br>2050.<br>2051.<br>2052.<br>2053.<br>2054.<br>2055.<br>2056.<br>2057.<br>2058.<br>2059.<br>2060.<br>2061.<br>2062.<br>2063.<br>2064.<br>2065.<br>2066.<br>2067.<br>2068.<br>2069.<br>2070.<br>2071.<br>2072.<br>2073.<br>2074.<br>2075.<br>2076.<br>2077.<br>2078.<br>2079.<br>2080.<br>2081.<br>2082.<br>2083.<br>2084.<br>2085.<br>2086.<br>2087.<br>2088.<br>2089.<br>2090.<br>2091.<br>2092.<br>2093.<br>2094.<br>2095.<br>2096.<br>2097.<br>2098.<br>2099.<br>2100.<br>2101.<br>2102.<br>2103.<br>2104.<br>2105.<br>2106.<br>2107.<br>2108.<br>2109.<br>2110.<br>2111.<br>2112.<br>2113.<br>2114.<br>2115.<br>2116.<br>2117.<br>2118.<br>2119.<br>2120.<br>2121.<br>2122.<br>2123.<br>2124.<br>2125.<br>2126.<br>2127.<br>2128.<br>2129.<br>2130.<br>2131.<br>2132.<br>2133.<br>2134.<br>2135.<br>2136.<br>2137.<br>2138.<br>2139.<br>2140.<br>2141.<br>2142.<br>2143.<br>2144.<br>2145.<br>2146.<br>2147.<br>2148.<br>2149.<br>2150.<br>2151.<br>2152.<br>2153.<br>2154.<br>2155.<br>2156.<br>2157.<br>2158.<br>2159.<br>2160.<br>2161.<br>2162.<br>2163.<br>2164.<br>2165.<br>2166.<br>2167.<br>2168.<br>2169.<br>2170.<br>2171.<br>2172.<br>2173.<br>2174.<br>2175.<br>2176.<br>2177.<br>2178.<br>2179.<br>2180.<br>2181.<br>2182.<br>2183.<br>2184.<br>2185.<br>2186.<br>2187.<br>2188.<br>2189.<br>2190.<br>2191.<br>2192.<br>2193.<br>2194.<br>2195.<br>2196.<br>2197.<br>2198.<br>2199.<br>2200.<br>2201.<br>2202.<br>2203.<br>2204.<br>2205.<br>2206.<br>2207.<br>2208.<br>2209.<br>2210.<br>2211.<br>2212.<br>2213.<br>2214.<br>2215.<br>2216.<br>2217.<br>2218.<br>2219.<br>2220.<br>2221.<br>2222.<br>2223.<br>2224.<br>2225.<br>2226.<br>2227.<br>2228.<br>2229.<br>2230.<br>2231.<br>2232.<br>2233.<br>2234.<br>2235.<br>2236.<br>2237.<br>2238.<br>2239.<br>2240.<br>2241.<br>2242.<br>2243.<br>2244.<br>2245.<br>2246.<br>2247.<br>2248.<br>2249.<br>2250.<br>2251.<br>2252.<br>2253.<br>2254.<br>2255.<br>2256.<br>2257.<br>2258.<br>2259.<br>2260.<br>2261.<br>2262.<br>2263.<br>2264.<br>2265.<br>2266.<br>2267.<br>2268.<br>2269.<br>2270.<br>2271.<br>2272.<br>2273.<br>2274.<br>2275.<br>2276.<br>2277.<br>2278.<br>2279.<br>2280.<br>2281.<br>2282.<br>2283.<br>2284.<br>2285.<br>2286.<br>2287.<br>2288.<br>2289.<br>2290.<br>2291.<br>2292.<br>2293.<br>2294.<br>2295.<br>2296.<br>2297.<br>2298.<br>2299.<br>2300.<br>2301.<br>2302.<br>2303.<br>2304.<br>2305.<br>2306.<br>2307.<br>2308.<br>2309.<br>2310.<br>2311.<br>2312.<br>2313.<br>2314.<br>2315.<br>2316.<br>2317.<br>2318.<br>2319.<br>2320.<br>2321.<br>2322.<br>2323.<br>2324.<br>2325.<br>2326.<br>2327.<br>2328.<br>2329.<br>2330.<br>2331.<br>2332.<br>2333.<br>2334.<br>2335.<br>2336.<br>2337.<br>2338.<br>2339.<br>2340.<br>2341.<br>2342.<br>2343.<br>2344.<br>2345.<br>2346.<br>2347.<br>2348.<br>2349.<br>2350.<br>2351.<br>2352.<br>2353.<br>2354.<br>2355.<br>2356.<br>2357.<br>2358.<br>2359.<br>2360.<br>2361.<br>2362.<br>2363.<br>2364.<br>2365.<br>2366.<br>2367.<br>2368.<br>2369.<br>2370.<br>2371.<br>2372.<br>2373.<br>2374.<br>2375.<br>2376.<br>2377.<br>2378.<br>2379.<br>2380.<br>2381.<br>2382.<br>2383.<br>2384.<br>2385.<br>2386.<br>2387.<br>2388.<br>2389.<br>2390.<br>2391.<br>2392.<br>2393.<br>2394.<br>2395.<br>2396.<br>2397.<br>2398.<br>2399.<br>2400.<br>2401.<br>2402.<br>2403.<br>2404.<br>2405.<br>2406.<br>2407.<br>2408.<br>2409.<br>2410.<br>2411.<br>2412.<br>2413.<br>2414.<br>2415.<br>2416.<br>2417.<br>2418.<br>2419.<br>2420.<br>2421.<br>2422.<br>2423.<br>2424.<br>2425.<br>2426.<br>2427.<br>2428.<br>2429.<br>2430.<br>2431.<br>2432.<br>2433.<br>2434.<br>2435.<br>2436.<br>2437.<br>2438.<br>2439.<br>2440.<br>2441.<br>2442.<br>2443.<br>2444.<br>2445.<br>2446.<br>2447.<br>2448.<br>2449.<br>2450.<br>2451.<br>2452.<br>2453.<br>2454.<br>2455.<br>2456.<br>2457.<br>2458.<br>2459.<br>2460.<br>2461.<br>2462.<br>2463.<br>2464.<br>2465.<br>2466.<br>2467.<br>2468.<br>2469.<br>2470.<br>2471.<br>2472.<br>2473.<br>2474.<br>2475.<br>2476.<br>2477.<br>2478.<br>2479.<br>2480.<br>2481.<br>2482.<br>2483.<br>2484.<br>2485.<br>2486.<br>2487.<br>2488.<br>2489.<br>2490.<br>2491.<br>2492.<br>2493.<br>2494.<br>2495.<br>2496.<br>2497.<br>2498.<br>2499.<br>2500.<br>2501.<br>2502.<br>2503.<br>2504.<br>2505.<br>2506.<br>2507.<br>2508.<br>2509.<br>2510.<br>2511.<br>2512.<br>2513.<br>2514.<br>2515.<br>2516.<br>2517.<br>2518.<br>2519.<br>2520.<br>2521.<br>2522.<br>2523.<br>2524.<br>2525.<br>2526.<br>2527.<br>2528.<br>2529.<br>2530.<br>2531.<br>2532.<br>2533.<br>2534.<br>2535.<br>2536.<br>2537.<br>2538.<br>2539.<br>2540.<br>2541.<br>2542.<br>2543.<br>2544.<br>2545.<br>2546.<br>2547.<br>2548.<br>2549.<br>2550.<br>2551.<br>2552.<br>2553.<br>2554.<br>2555.<br>2556.<br>2557.<br>2558.<br>2559.<br>2560.<br>2561.<br>2562.<br>2563.<br>2564.<br>2565.<br>2566.<br>2567.<br>2568.<br>2569.<br>2570.<br>2571.<br>2572.<br>2573.<br>2574.<br>2575.<br>2576.<br>2577.<br>2578.<br>2579.<br>2580.<br>2581.<br></code_line></pre></td>
<td class='lines'><pre><code class="prettyprint">// SPDX-License-Identifier: GPL-2.0-only
/*
 * KVM Microsoft Hyper-V emulation
 *
 * derived from arch/x86/kvm/x86.c
 *
 * Copyright (C) 2006 Qumranet, Inc.
 * Copyright (C) 2008 Qumranet, Inc.
 * Copyright IBM Corporation, 2008
 * Copyright 2010 Red Hat, Inc. and/or its affiliates.
 * Copyright (C) 2015 Andrey Smetanin &lt;asmetanin@virtuozzo.com&gt;
 *
 * Authors:
 *   Avi Kivity   &lt;avi@qumranet.com&gt;
 *   Yaniv Kamay  &lt;yaniv@qumranet.com&gt;
 *   Amit Shah    &lt;amit.shah@qumranet.com&gt;
 *   Ben-Ami Yassour &lt;benami@il.ibm.com&gt;
 *   Andrey Smetanin &lt;asmetanin@virtuozzo.com&gt;
 */

#include &quot;x86.h&quot;
#include &quot;lapic.h&quot;
#include &quot;ioapic.h&quot;
#include &quot;cpuid.h&quot;
#include &quot;hyperv.h&quot;
#include &quot;xen.h&quot;

#include &lt;linux/cpu.h&gt;
#include &lt;linux/kvm_host.h&gt;
#include &lt;linux/highmem.h&gt;
#include &lt;linux/sched/cputime.h&gt;
#include &lt;linux/eventfd.h&gt;

#include &lt;asm/apicdef.h&gt;
#include &lt;trace/events/kvm.h&gt;

#include &quot;trace.h&quot;
#include &quot;irq.h&quot;
#include &quot;fpu.h&quot;

#define KVM_HV_MAX_SPARSE_VCPU_SET_BITS DIV_ROUND_UP(KVM_MAX_VCPUS, 64)

static void stimer_mark_pending(struct kvm_vcpu_hv_stimer *stimer,
				bool vcpu_kick);

static inline u64 synic_read_sint(struct kvm_vcpu_hv_synic *synic, int sint)
{
<blue>	return atomic64_read(&synic->sint[sint]);</blue>
}

static inline int synic_get_sint_vector(u64 sint_value)
{
	if (sint_value &amp; HV_SYNIC_SINT_MASKED)
		return -1;
<yellow>	return sint_value & HV_SYNIC_SINT_VECTOR_MASK;</yellow>
}

static bool synic_has_vector_connected(struct kvm_vcpu_hv_synic *synic,
				      int vector)
{
	int i;

<yellow>	for (i = 0; i < ARRAY_SIZE(synic->sint); i++) {</yellow>
<yellow>		if (synic_get_sint_vector(synic_read_sint(synic, i)) == vector)</yellow>
			return true;
	}
	return false;
}

static bool synic_has_vector_auto_eoi(struct kvm_vcpu_hv_synic *synic,
				     int vector)
{
	int i;
	u64 sint_value;

<yellow>	for (i = 0; i < ARRAY_SIZE(synic->sint); i++) {</yellow>
<yellow>		sint_value = synic_read_sint(synic, i);</yellow>
<yellow>		if (synic_get_sint_vector(sint_value) == vector &&</yellow>
<yellow>		    sint_value & HV_SYNIC_SINT_AUTO_EOI)</yellow>
			return true;
	}
	return false;
}

static void synic_update_vector(struct kvm_vcpu_hv_synic *synic,
				int vector)
{
<blue>	struct kvm_vcpu *vcpu = hv_synic_to_vcpu(synic);</blue>
	struct kvm_hv *hv = to_kvm_hv(vcpu-&gt;kvm);
	bool auto_eoi_old, auto_eoi_new;

	if (vector &lt; HV_SYNIC_FIRST_VALID_VECTOR)
		return;

<yellow>	if (synic_has_vector_connected(synic, vector))</yellow>
<yellow>		__set_bit(vector, synic->vec_bitmap);</yellow>
	else
<yellow>		__clear_bit(vector, synic->vec_bitmap);</yellow>

<yellow>	auto_eoi_old = !bitmap_empty(synic->auto_eoi_bitmap, 256);</yellow>

<yellow>	if (synic_has_vector_auto_eoi(synic, vector))</yellow>
<yellow>		__set_bit(vector, synic->auto_eoi_bitmap);</yellow>
	else
<yellow>		__clear_bit(vector, synic->auto_eoi_bitmap);</yellow>

<yellow>	auto_eoi_new = !bitmap_empty(synic->auto_eoi_bitmap, 256);</yellow>

	if (auto_eoi_old == auto_eoi_new)
		return;

<yellow>	if (!enable_apicv)</yellow>
		return;

<yellow>	down_write(&vcpu->kvm->arch.apicv_update_lock);</yellow>

	if (auto_eoi_new)
<yellow>		hv->synic_auto_eoi_used++;</yellow>
	else
<yellow>		hv->synic_auto_eoi_used--;</yellow>

	/*
	 * Inhibit APICv if any vCPU is using SynIC&#x27;s AutoEOI, which relies on
	 * the hypervisor to manually inject IRQs.
	 */
	__kvm_set_or_clear_apicv_inhibit(vcpu-&gt;kvm,
					 APICV_INHIBIT_REASON_HYPERV,
					 !!hv-&gt;synic_auto_eoi_used);

	up_write(&amp;vcpu-&gt;kvm-&gt;arch.apicv_update_lock);
<blue>}</blue>

static int synic_set_sint(struct kvm_vcpu_hv_synic *synic, int sint,
			  u64 data, bool host)
{
	int vector, old_vector;
	bool masked;

<blue>	vector = data & HV_SYNIC_SINT_VECTOR_MASK;</blue>
<yellow>	masked = data & HV_SYNIC_SINT_MASKED;</yellow>

	/*
	 * Valid vectors are 16-255, however, nested Hyper-V attempts to write
	 * default &#x27;0x10000&#x27; value on boot and this should not #GP. We need to
	 * allow zero-initing the register from host as well.
	 */
<blue>	if (vector < HV_SYNIC_FIRST_VALID_VECTOR && !host && !masked)</blue>
		return 1;
	/*
	 * Guest may configure multiple SINTs to use the same vector, so
	 * we maintain a bitmap of vectors handled by synic, and a
	 * bitmap of vectors with auto-eoi behavior.  The bitmaps are
	 * updated here, and atomically queried on fast paths.
	 */
<blue>	old_vector = synic_read_sint(synic, sint) & HV_SYNIC_SINT_VECTOR_MASK;</blue>

	atomic64_set(&amp;synic-&gt;sint[sint], data);

	synic_update_vector(synic, old_vector);

	synic_update_vector(synic, vector);

	/* Load SynIC vectors into EOI exit bitmap */
	kvm_make_request(KVM_REQ_SCAN_IOAPIC, hv_synic_to_vcpu(synic));
	return 0;
}

static struct kvm_vcpu *get_vcpu_by_vpidx(struct kvm *kvm, u32 vpidx)
{
	struct kvm_vcpu *vcpu = NULL;
	unsigned long i;

<yellow>	if (vpidx >= KVM_MAX_VCPUS)</yellow>
		return NULL;

<yellow>	vcpu = kvm_get_vcpu(kvm, vpidx);</yellow>
<yellow>	if (vcpu && kvm_hv_get_vpindex(vcpu) == vpidx)</yellow>
		return vcpu;
<yellow>	kvm_for_each_vcpu(i, vcpu, kvm)</yellow>
<yellow>		if (kvm_hv_get_vpindex(vcpu) == vpidx)</yellow>
			return vcpu;
	return NULL;
}

static struct kvm_vcpu_hv_synic *synic_get(struct kvm *kvm, u32 vpidx)
<yellow>{</yellow>
	struct kvm_vcpu *vcpu;
	struct kvm_vcpu_hv_synic *synic;

<yellow>	vcpu = get_vcpu_by_vpidx(kvm, vpidx);</yellow>
<yellow>	if (!vcpu || !to_hv_vcpu(vcpu))</yellow>
<yellow>		return NULL;</yellow>
<yellow>	synic = to_hv_synic(vcpu);</yellow>
<yellow>	return (synic->active) ? synic : NULL;</yellow>
}

static void kvm_hv_notify_acked_sint(struct kvm_vcpu *vcpu, u32 sint)
{
<yellow>	struct kvm *kvm = vcpu->kvm;</yellow>
	struct kvm_vcpu_hv_synic *synic = to_hv_synic(vcpu);
	struct kvm_vcpu_hv *hv_vcpu = to_hv_vcpu(vcpu);
	struct kvm_vcpu_hv_stimer *stimer;
	int gsi, idx;

<yellow>	trace_kvm_hv_notify_acked_sint(vcpu->vcpu_id, sint);</yellow>

	/* Try to deliver pending Hyper-V SynIC timers messages */
<yellow>	for (idx = 0; idx < ARRAY_SIZE(hv_vcpu->stimer); idx++) {</yellow>
<yellow>		stimer = &hv_vcpu->stimer[idx];</yellow>
<yellow>		if (stimer->msg_pending && stimer->config.enable &&</yellow>
		    !stimer-&gt;config.direct_mode &amp;&amp;
<yellow>		    stimer->config.sintx == sint)</yellow>
<yellow>			stimer_mark_pending(stimer, false);</yellow>
	}

<yellow>	idx = srcu_read_lock(&kvm->irq_srcu);</yellow>
	gsi = atomic_read(&amp;synic-&gt;sint_to_gsi[sint]);
	if (gsi != -1)
<yellow>		kvm_notify_acked_gsi(kvm, gsi);</yellow>
<yellow>	srcu_read_unlock(&kvm->irq_srcu, idx);</yellow>
}

static void synic_exit(struct kvm_vcpu_hv_synic *synic, u32 msr)
{
<yellow>	struct kvm_vcpu *vcpu = hv_synic_to_vcpu(synic);</yellow>
	struct kvm_vcpu_hv *hv_vcpu = to_hv_vcpu(vcpu);

	hv_vcpu-&gt;exit.type = KVM_EXIT_HYPERV_SYNIC;
	hv_vcpu-&gt;exit.u.synic.msr = msr;
	hv_vcpu-&gt;exit.u.synic.control = synic-&gt;control;
	hv_vcpu-&gt;exit.u.synic.evt_page = synic-&gt;evt_page;
	hv_vcpu-&gt;exit.u.synic.msg_page = synic-&gt;msg_page;

	kvm_make_request(KVM_REQ_HV_EXIT, vcpu);
}

static int synic_set_msr(struct kvm_vcpu_hv_synic *synic,
			 u32 msr, u64 data, bool host)
{
	struct kvm_vcpu *vcpu = hv_synic_to_vcpu(synic);
	int ret;

<blue>	if (!synic->active && (!host || data))</blue>
		return 1;

<blue>	trace_kvm_hv_synic_set_msr(vcpu->vcpu_id, msr, data, host);</blue>

	ret = 0;
	switch (msr) {
	case HV_X64_MSR_SCONTROL:
<blue>		synic->control = data;</blue>
		if (!host)
<yellow>			synic_exit(synic, msr);</yellow>
		break;
	case HV_X64_MSR_SVERSION:
<blue>		if (!host) {</blue>
			ret = 1;
			break;
		}
<blue>		synic->version = data;</blue>
		break;
	case HV_X64_MSR_SIEFP:
<blue>		if ((data & HV_SYNIC_SIEFP_ENABLE) && !host &&</blue>
<yellow>		    !synic->dont_zero_synic_pages)</yellow>
<yellow>			if (kvm_clear_guest(vcpu->kvm,</yellow>
					    data &amp; PAGE_MASK, PAGE_SIZE)) {
				ret = 1;
				break;
			}
<blue>		synic->evt_page = data;</blue>
		if (!host)
<yellow>			synic_exit(synic, msr);</yellow>
		break;
	case HV_X64_MSR_SIMP:
<blue>		if ((data & HV_SYNIC_SIMP_ENABLE) && !host &&</blue>
<yellow>		    !synic->dont_zero_synic_pages)</yellow>
<yellow>			if (kvm_clear_guest(vcpu->kvm,</yellow>
					    data &amp; PAGE_MASK, PAGE_SIZE)) {
				ret = 1;
				break;
			}
<blue>		synic->msg_page = data;</blue>
		if (!host)
<yellow>			synic_exit(synic, msr);</yellow>
		break;
	case HV_X64_MSR_EOM: {
		int i;

<yellow>		if (!synic->active)</yellow>
			break;

		for (i = 0; i &lt; ARRAY_SIZE(synic-&gt;sint); i++)
<yellow>			kvm_hv_notify_acked_sint(vcpu, i);</yellow>
		break;
	}
	case HV_X64_MSR_SINT0 ... HV_X64_MSR_SINT15:
<blue>		ret = synic_set_sint(synic, msr - HV_X64_MSR_SINT0, data, host);</blue>
		break;
	default:
		ret = 1;
		break;
	}
	return ret;
}

static bool kvm_hv_is_syndbg_enabled(struct kvm_vcpu *vcpu)
{
	struct kvm_vcpu_hv *hv_vcpu = to_hv_vcpu(vcpu);

	return hv_vcpu-&gt;cpuid_cache.syndbg_cap_eax &amp;
		HV_X64_SYNDBG_CAP_ALLOW_KERNEL_DEBUGGING;
}

static int kvm_hv_syndbg_complete_userspace(struct kvm_vcpu *vcpu)
{
<yellow>	struct kvm_hv *hv = to_kvm_hv(vcpu->kvm);</yellow>

<yellow>	if (vcpu->run->hyperv.u.syndbg.msr == HV_X64_MSR_SYNDBG_CONTROL)</yellow>
		hv-&gt;hv_syndbg.control.status =
			vcpu-&gt;run-&gt;hyperv.u.syndbg.status;
	return 1;
<yellow>}</yellow>

static void syndbg_exit(struct kvm_vcpu *vcpu, u32 msr)
{
<yellow>	struct kvm_hv_syndbg *syndbg = to_hv_syndbg(vcpu);</yellow>
	struct kvm_vcpu_hv *hv_vcpu = to_hv_vcpu(vcpu);

	hv_vcpu-&gt;exit.type = KVM_EXIT_HYPERV_SYNDBG;
	hv_vcpu-&gt;exit.u.syndbg.msr = msr;
	hv_vcpu-&gt;exit.u.syndbg.control = syndbg-&gt;control.control;
	hv_vcpu-&gt;exit.u.syndbg.send_page = syndbg-&gt;control.send_page;
	hv_vcpu-&gt;exit.u.syndbg.recv_page = syndbg-&gt;control.recv_page;
	hv_vcpu-&gt;exit.u.syndbg.pending_page = syndbg-&gt;control.pending_page;
	vcpu-&gt;arch.complete_userspace_io =
			kvm_hv_syndbg_complete_userspace;

	kvm_make_request(KVM_REQ_HV_EXIT, vcpu);
}

static int syndbg_set_msr(struct kvm_vcpu *vcpu, u32 msr, u64 data, bool host)
{
<blue>	struct kvm_hv_syndbg *syndbg = to_hv_syndbg(vcpu);</blue>

<yellow>	if (!kvm_hv_is_syndbg_enabled(vcpu) && !host)</yellow>
		return 1;

<blue>	trace_kvm_hv_syndbg_set_msr(vcpu->vcpu_id,</blue>
				    to_hv_vcpu(vcpu)-&gt;vp_index, msr, data);
<blue>	switch (msr) {</blue>
	case HV_X64_MSR_SYNDBG_CONTROL:
<yellow>		syndbg->control.control = data;</yellow>
		if (!host)
<yellow>			syndbg_exit(vcpu, msr);</yellow>
		break;
	case HV_X64_MSR_SYNDBG_STATUS:
<yellow>		syndbg->control.status = data;</yellow>
		break;
	case HV_X64_MSR_SYNDBG_SEND_BUFFER:
<yellow>		syndbg->control.send_page = data;</yellow>
		break;
	case HV_X64_MSR_SYNDBG_RECV_BUFFER:
<yellow>		syndbg->control.recv_page = data;</yellow>
		break;
	case HV_X64_MSR_SYNDBG_PENDING_BUFFER:
<yellow>		syndbg->control.pending_page = data;</yellow>
		if (!host)
<yellow>			syndbg_exit(vcpu, msr);</yellow>
		break;
	case HV_X64_MSR_SYNDBG_OPTIONS:
<blue>		syndbg->options = data;</blue>
		break;
	default:
		break;
	}

	return 0;
}

static int syndbg_get_msr(struct kvm_vcpu *vcpu, u32 msr, u64 *pdata, bool host)
{
<blue>	struct kvm_hv_syndbg *syndbg = to_hv_syndbg(vcpu);</blue>

<blue>	if (!kvm_hv_is_syndbg_enabled(vcpu) && !host)</blue>
		return 1;

<blue>	switch (msr) {</blue>
	case HV_X64_MSR_SYNDBG_CONTROL:
<yellow>		*pdata = syndbg->control.control;</yellow>
		break;
	case HV_X64_MSR_SYNDBG_STATUS:
<yellow>		*pdata = syndbg->control.status;</yellow>
		break;
	case HV_X64_MSR_SYNDBG_SEND_BUFFER:
<yellow>		*pdata = syndbg->control.send_page;</yellow>
		break;
	case HV_X64_MSR_SYNDBG_RECV_BUFFER:
<yellow>		*pdata = syndbg->control.recv_page;</yellow>
		break;
	case HV_X64_MSR_SYNDBG_PENDING_BUFFER:
<yellow>		*pdata = syndbg->control.pending_page;</yellow>
		break;
	case HV_X64_MSR_SYNDBG_OPTIONS:
<blue>		*pdata = syndbg->options;</blue>
		break;
	default:
		break;
	}

<blue>	trace_kvm_hv_syndbg_get_msr(vcpu->vcpu_id, kvm_hv_get_vpindex(vcpu), msr, *pdata);</blue>

	return 0;
}

static int synic_get_msr(struct kvm_vcpu_hv_synic *synic, u32 msr, u64 *pdata,
			 bool host)
{
	int ret;

<blue>	if (!synic->active && !host)</blue>
		return 1;

	ret = 0;
<blue>	switch (msr) {</blue>
	case HV_X64_MSR_SCONTROL:
<blue>		*pdata = synic->control;</blue>
		break;
	case HV_X64_MSR_SVERSION:
<yellow>		*pdata = synic->version;</yellow>
		break;
	case HV_X64_MSR_SIEFP:
<blue>		*pdata = synic->evt_page;</blue>
		break;
	case HV_X64_MSR_SIMP:
<blue>		*pdata = synic->msg_page;</blue>
		break;
	case HV_X64_MSR_EOM:
<yellow>		*pdata = 0;</yellow>
		break;
	case HV_X64_MSR_SINT0 ... HV_X64_MSR_SINT15:
<blue>		*pdata = atomic64_read(&synic->sint[msr - HV_X64_MSR_SINT0]);</blue>
		break;
	default:
		ret = 1;
		break;
	}
	return ret;
}

static int synic_set_irq(struct kvm_vcpu_hv_synic *synic, u32 sint)
<yellow>{</yellow>
<yellow>	struct kvm_vcpu *vcpu = hv_synic_to_vcpu(synic);</yellow>
	struct kvm_lapic_irq irq;
	int ret, vector;

<yellow>	if (KVM_BUG_ON(!lapic_in_kernel(vcpu), vcpu->kvm))</yellow>
		return -EINVAL;

<yellow>	if (sint >= ARRAY_SIZE(synic->sint))</yellow>
		return -EINVAL;

<yellow>	vector = synic_get_sint_vector(synic_read_sint(synic, sint));</yellow>
	if (vector &lt; 0)
		return -ENOENT;

<yellow>	memset(&irq, 0, sizeof(irq));</yellow>
	irq.shorthand = APIC_DEST_SELF;
	irq.dest_mode = APIC_DEST_PHYSICAL;
	irq.delivery_mode = APIC_DM_FIXED;
	irq.vector = vector;
	irq.level = 1;

	ret = kvm_irq_delivery_to_apic(vcpu-&gt;kvm, vcpu-&gt;arch.apic, &amp;irq, NULL);
<yellow>	trace_kvm_hv_synic_set_irq(vcpu->vcpu_id, sint, irq.vector, ret);</yellow>
	return ret;
}

int kvm_hv_synic_set_irq(struct kvm *kvm, u32 vpidx, u32 sint)
{
	struct kvm_vcpu_hv_synic *synic;

<yellow>	synic = synic_get(kvm, vpidx);</yellow>
	if (!synic)
		return -EINVAL;

<yellow>	return synic_set_irq(synic, sint);</yellow>
<yellow>}</yellow>

void kvm_hv_synic_send_eoi(struct kvm_vcpu *vcpu, int vector)
{
<yellow>	struct kvm_vcpu_hv_synic *synic = to_hv_synic(vcpu);</yellow>
	int i;

<yellow>	trace_kvm_hv_synic_send_eoi(vcpu->vcpu_id, vector);</yellow>

<yellow>	for (i = 0; i < ARRAY_SIZE(synic->sint); i++)</yellow>
<yellow>		if (synic_get_sint_vector(synic_read_sint(synic, i)) == vector)</yellow>
<yellow>			kvm_hv_notify_acked_sint(vcpu, i);</yellow>
<yellow>}</yellow>

static int kvm_hv_set_sint_gsi(struct kvm *kvm, u32 vpidx, u32 sint, int gsi)
{
	struct kvm_vcpu_hv_synic *synic;

	synic = synic_get(kvm, vpidx);
	if (!synic)
		return -EINVAL;

<yellow>	if (sint >= ARRAY_SIZE(synic->sint_to_gsi))</yellow>
		return -EINVAL;

<yellow>	atomic_set(&synic->sint_to_gsi[sint], gsi);</yellow>
	return 0;
}

void kvm_hv_irq_routing_update(struct kvm *kvm)
{
	struct kvm_irq_routing_table *irq_rt;
	struct kvm_kernel_irq_routing_entry *e;
	u32 gsi;

<blue>	irq_rt = srcu_dereference_check(kvm->irq_routing, &kvm->irq_srcu,</blue>
					lockdep_is_held(&amp;kvm-&gt;irq_lock));

<blue>	for (gsi = 0; gsi < irq_rt->nr_rt_entries; gsi++) {</blue>
<blue>		hlist_for_each_entry(e, &irq_rt->map[gsi], link) {</blue>
<blue>			if (e->type == KVM_IRQ_ROUTING_HV_SINT)</blue>
<yellow>				kvm_hv_set_sint_gsi(kvm, e->hv_sint.vcpu,</yellow>
						    e-&gt;hv_sint.sint, gsi);
		}
	}
<blue>}</blue>

static void synic_init(struct kvm_vcpu_hv_synic *synic)
{
	int i;

	memset(synic, 0, sizeof(*synic));
	synic-&gt;version = HV_SYNIC_VERSION_1;
	for (i = 0; i &lt; ARRAY_SIZE(synic-&gt;sint); i++) {
<blue>		atomic64_set(&synic->sint[i], HV_SYNIC_SINT_MASKED);</blue>
		atomic_set(&amp;synic-&gt;sint_to_gsi[i], -1);
	}
}

<yellow>static u64 get_time_ref_counter(struct kvm *kvm)</yellow>
{
	struct kvm_hv *hv = to_kvm_hv(kvm);
	struct kvm_vcpu *vcpu;
	u64 tsc;

	/*
	 * Fall back to get_kvmclock_ns() when TSC page hasn&#x27;t been set up,
	 * is broken, disabled or being updated.
	 */
<yellow>	if (hv->hv_tsc_page_status != HV_TSC_PAGE_SET)</yellow>
<yellow>		return div_u64(get_kvmclock_ns(kvm), 100);</yellow>

<yellow>	vcpu = kvm_get_vcpu(kvm, 0);</yellow>
	tsc = kvm_read_l1_tsc(vcpu, rdtsc());
	return mul_u64_u64_shr(tsc, hv-&gt;tsc_ref.tsc_scale, 64)
		+ hv-&gt;tsc_ref.tsc_offset;
<yellow>}</yellow>

static void stimer_mark_pending(struct kvm_vcpu_hv_stimer *stimer,
				bool vcpu_kick)
{
<yellow>	struct kvm_vcpu *vcpu = hv_stimer_to_vcpu(stimer);</yellow>

	set_bit(stimer-&gt;index,
		to_hv_vcpu(vcpu)-&gt;stimer_pending_bitmap);
	kvm_make_request(KVM_REQ_HV_STIMER, vcpu);
	if (vcpu_kick)
<yellow>		kvm_vcpu_kick(vcpu);</yellow>
<yellow>}</yellow>

static void stimer_cleanup(struct kvm_vcpu_hv_stimer *stimer)
{
<blue>	struct kvm_vcpu *vcpu = hv_stimer_to_vcpu(stimer);</blue>

<yellow>	trace_kvm_hv_stimer_cleanup(hv_stimer_to_vcpu(stimer)->vcpu_id,</yellow>
				    stimer-&gt;index);

<blue>	hrtimer_cancel(&stimer->timer);</blue>
<blue>	clear_bit(stimer->index,</blue>
		  to_hv_vcpu(vcpu)-&gt;stimer_pending_bitmap);
	stimer-&gt;msg_pending = false;
	stimer-&gt;exp_time = 0;
}

static enum hrtimer_restart stimer_timer_callback(struct hrtimer *timer)
{
	struct kvm_vcpu_hv_stimer *stimer;

	stimer = container_of(timer, struct kvm_vcpu_hv_stimer, timer);
<yellow>	trace_kvm_hv_stimer_callback(hv_stimer_to_vcpu(stimer)->vcpu_id,</yellow>
				     stimer-&gt;index);
<yellow>	stimer_mark_pending(stimer, true);</yellow>

	return HRTIMER_NORESTART;
}

/*
 * stimer_start() assumptions:
 * a) stimer-&gt;count is not equal to 0
 * b) stimer-&gt;config has HV_STIMER_ENABLE flag
 */
static int stimer_start(struct kvm_vcpu_hv_stimer *stimer)
{
	u64 time_now;
	ktime_t ktime_now;

<yellow>	time_now = get_time_ref_counter(hv_stimer_to_vcpu(stimer)->kvm);</yellow>
	ktime_now = ktime_get();

	if (stimer-&gt;config.periodic) {
<yellow>		if (stimer->exp_time) {</yellow>
<yellow>			if (time_now >= stimer->exp_time) {</yellow>
				u64 remainder;

<yellow>				div64_u64_rem(time_now - stimer->exp_time,</yellow>
					      stimer-&gt;count, &amp;remainder);
				stimer-&gt;exp_time =
					time_now + (stimer-&gt;count - remainder);
			}
		} else
<yellow>			stimer->exp_time = time_now + stimer->count;</yellow>

<yellow>		trace_kvm_hv_stimer_start_periodic(</yellow>
					hv_stimer_to_vcpu(stimer)-&gt;vcpu_id,
					stimer-&gt;index,
					time_now, stimer-&gt;exp_time);

		hrtimer_start(&amp;stimer-&gt;timer,
<yellow>			      ktime_add_ns(ktime_now,</yellow>
					   100 * (stimer-&gt;exp_time - time_now)),
			      HRTIMER_MODE_ABS);
		return 0;
	}
<yellow>	stimer->exp_time = stimer->count;</yellow>
	if (time_now &gt;= stimer-&gt;count) {
		/*
		 * Expire timer according to Hypervisor Top-Level Functional
		 * specification v4(15.3.1):
		 * &quot;If a one shot is enabled and the specified count is in
		 * the past, it will expire immediately.&quot;
		 */
<yellow>		stimer_mark_pending(stimer, false);</yellow>
		return 0;
	}

<yellow>	trace_kvm_hv_stimer_start_one_shot(hv_stimer_to_vcpu(stimer)->vcpu_id,</yellow>
					   stimer-&gt;index,
					   time_now, stimer-&gt;count);

	hrtimer_start(&amp;stimer-&gt;timer,
<yellow>		      ktime_add_ns(ktime_now, 100 * (stimer->count - time_now)),</yellow>
		      HRTIMER_MODE_ABS);
	return 0;
}

static int stimer_set_config(struct kvm_vcpu_hv_stimer *stimer, u64 config,
			     bool host)
{
	union hv_stimer_config new_config = {.as_uint64 = config},
		old_config = {.as_uint64 = stimer-&gt;config.as_uint64};
	struct kvm_vcpu *vcpu = hv_stimer_to_vcpu(stimer);
	struct kvm_vcpu_hv *hv_vcpu = to_hv_vcpu(vcpu);
	struct kvm_vcpu_hv_synic *synic = to_hv_synic(vcpu);

<blue>	if (!synic->active && (!host || config))</blue>
		return 1;

<blue>	if (unlikely(!host && hv_vcpu->enforce_cpuid && new_config.direct_mode &&</blue>
		     !(hv_vcpu-&gt;cpuid_cache.features_edx &amp;
		       HV_STIMER_DIRECT_MODE_AVAILABLE)))
		return 1;

<blue>	trace_kvm_hv_stimer_set_config(hv_stimer_to_vcpu(stimer)->vcpu_id,</blue>
				       stimer-&gt;index, config, host);

<blue>	stimer_cleanup(stimer);</blue>
	if (old_config.enable &amp;&amp;
<yellow>	    !new_config.direct_mode && new_config.sintx == 0)</yellow>
<yellow>		new_config.enable = 0;</yellow>
<blue>	stimer->config.as_uint64 = new_config.as_uint64;</blue>

	if (stimer-&gt;config.enable)
<yellow>		stimer_mark_pending(stimer, false);</yellow>

	return 0;
}

static int stimer_set_count(struct kvm_vcpu_hv_stimer *stimer, u64 count,
			    bool host)
{
	struct kvm_vcpu *vcpu = hv_stimer_to_vcpu(stimer);
	struct kvm_vcpu_hv_synic *synic = to_hv_synic(vcpu);

<blue>	if (!synic->active && (!host || count))</blue>
		return 1;

<blue>	trace_kvm_hv_stimer_set_count(hv_stimer_to_vcpu(stimer)->vcpu_id,</blue>
				      stimer-&gt;index, count, host);

<blue>	stimer_cleanup(stimer);</blue>
	stimer-&gt;count = count;
	if (stimer-&gt;count == 0)
<blue>		stimer->config.enable = 0;</blue>
<yellow>	else if (stimer->config.auto_enable)</yellow>
<yellow>		stimer->config.enable = 1;</yellow>

<blue>	if (stimer->config.enable)</blue>
<yellow>		stimer_mark_pending(stimer, false);</yellow>

	return 0;
}

static int stimer_get_config(struct kvm_vcpu_hv_stimer *stimer, u64 *pconfig)
{
	*pconfig = stimer-&gt;config.as_uint64;
	return 0;
}

static int stimer_get_count(struct kvm_vcpu_hv_stimer *stimer, u64 *pcount)
{
	*pcount = stimer-&gt;count;
	return 0;
}

static int synic_deliver_msg(struct kvm_vcpu_hv_synic *synic, u32 sint,
			     struct hv_message *src_msg, bool no_retry)
{
	struct kvm_vcpu *vcpu = hv_synic_to_vcpu(synic);
	int msg_off = offsetof(struct hv_message_page, sint_message[sint]);
	gfn_t msg_page_gfn;
	struct hv_message_header hv_hdr;
	int r;

	if (!(synic-&gt;msg_page &amp; HV_SYNIC_SIMP_ENABLE))
		return -ENOENT;

	msg_page_gfn = synic-&gt;msg_page &gt;&gt; PAGE_SHIFT;

	/*
	 * Strictly following the spec-mandated ordering would assume setting
	 * .msg_pending before checking .message_type.  However, this function
	 * is only called in vcpu context so the entire update is atomic from
	 * guest POV and thus the exact order here doesn&#x27;t matter.
	 */
<yellow>	r = kvm_vcpu_read_guest_page(vcpu, msg_page_gfn, &hv_hdr.message_type,</yellow>
				     msg_off + offsetof(struct hv_message,
							header.message_type),
				     sizeof(hv_hdr.message_type));
	if (r &lt; 0)
		return r;

<yellow>	if (hv_hdr.message_type != HVMSG_NONE) {</yellow>
<yellow>		if (no_retry)</yellow>
			return 0;

		hv_hdr.message_flags.msg_pending = 1;
		r = kvm_vcpu_write_guest_page(vcpu, msg_page_gfn,
					      &amp;hv_hdr.message_flags,
<yellow>					      msg_off +</yellow>
					      offsetof(struct hv_message,
						       header.message_flags),
					      sizeof(hv_hdr.message_flags));
		if (r &lt; 0)
			return r;
		return -EAGAIN;
	}

	r = kvm_vcpu_write_guest_page(vcpu, msg_page_gfn, src_msg, msg_off,
				      sizeof(src_msg-&gt;header) +
<yellow>				      src_msg->header.payload_size);</yellow>
	if (r &lt; 0)
		return r;

	r = synic_set_irq(synic, sint);
	if (r &lt; 0)
		return r;
<yellow>	if (r == 0)</yellow>
		return -EFAULT;
	return 0;
}

static int stimer_send_msg(struct kvm_vcpu_hv_stimer *stimer)
{
<yellow>	struct kvm_vcpu *vcpu = hv_stimer_to_vcpu(stimer);</yellow>
	struct hv_message *msg = &amp;stimer-&gt;msg;
	struct hv_timer_message_payload *payload =
			(struct hv_timer_message_payload *)&amp;msg-&gt;u.payload;

	/*
	 * To avoid piling up periodic ticks, don&#x27;t retry message
	 * delivery for them (within &quot;lazy&quot; lost ticks policy).
	 */
	bool no_retry = stimer-&gt;config.periodic;

	payload-&gt;expiration_time = stimer-&gt;exp_time;
	payload-&gt;delivery_time = get_time_ref_counter(vcpu-&gt;kvm);
<yellow>	return synic_deliver_msg(to_hv_synic(vcpu),</yellow>
				 stimer-&gt;config.sintx, msg,
				 no_retry);
}

static int stimer_notify_direct(struct kvm_vcpu_hv_stimer *stimer)
{
<yellow>	struct kvm_vcpu *vcpu = hv_stimer_to_vcpu(stimer);</yellow>
	struct kvm_lapic_irq irq = {
		.delivery_mode = APIC_DM_FIXED,
		.vector = stimer-&gt;config.apic_vector
	};

<yellow>	if (lapic_in_kernel(vcpu))</yellow>
<yellow>		return !kvm_apic_set_irq(vcpu, &irq, NULL);</yellow>
	return 0;
}

static void stimer_expiration(struct kvm_vcpu_hv_stimer *stimer)
{
<yellow>	int r, direct = stimer->config.direct_mode;</yellow>

	stimer-&gt;msg_pending = true;
	if (!direct)
<yellow>		r = stimer_send_msg(stimer);</yellow>
	else
<yellow>		r = stimer_notify_direct(stimer);</yellow>
<yellow>	trace_kvm_hv_stimer_expiration(hv_stimer_to_vcpu(stimer)->vcpu_id,</yellow>
				       stimer-&gt;index, direct, r);
<yellow>	if (!r) {</yellow>
<yellow>		stimer->msg_pending = false;</yellow>
		if (!(stimer-&gt;config.periodic))
<yellow>			stimer->config.enable = 0;</yellow>
	}
}

void kvm_hv_process_stimers(struct kvm_vcpu *vcpu)
<yellow>{</yellow>
<yellow>	struct kvm_vcpu_hv *hv_vcpu = to_hv_vcpu(vcpu);</yellow>
	struct kvm_vcpu_hv_stimer *stimer;
	u64 time_now, exp_time;
	int i;

	if (!hv_vcpu)
		return;

<yellow>	for (i = 0; i < ARRAY_SIZE(hv_vcpu->stimer); i++)</yellow>
<yellow>		if (test_and_clear_bit(i, hv_vcpu->stimer_pending_bitmap)) {</yellow>
<yellow>			stimer = &hv_vcpu->stimer[i];</yellow>
<yellow>			if (stimer->config.enable) {</yellow>
				exp_time = stimer-&gt;exp_time;

				if (exp_time) {
					time_now =
<yellow>						get_time_ref_counter(vcpu->kvm);</yellow>
					if (time_now &gt;= exp_time)
<yellow>						stimer_expiration(stimer);</yellow>
				}

<yellow>				if ((stimer->config.enable) &&</yellow>
<yellow>				    stimer->count) {</yellow>
<yellow>					if (!stimer->msg_pending)</yellow>
<yellow>						stimer_start(stimer);</yellow>
				} else
<yellow>					stimer_cleanup(stimer);</yellow>
			}
		}
}

void kvm_hv_vcpu_uninit(struct kvm_vcpu *vcpu)
{
<yellow>	struct kvm_vcpu_hv *hv_vcpu = to_hv_vcpu(vcpu);</yellow>
	int i;

	if (!hv_vcpu)
		return;

	for (i = 0; i &lt; ARRAY_SIZE(hv_vcpu-&gt;stimer); i++)
<yellow>		stimer_cleanup(&hv_vcpu->stimer[i]);</yellow>

	kfree(hv_vcpu);
	vcpu-&gt;arch.hyperv = NULL;
<yellow>}</yellow>

bool kvm_hv_assist_page_enabled(struct kvm_vcpu *vcpu)
{
<blue>	struct kvm_vcpu_hv *hv_vcpu = to_hv_vcpu(vcpu);</blue>

	if (!hv_vcpu)
<yellow>		return false;</yellow>

<blue>	if (!(hv_vcpu->hv_vapic & HV_X64_MSR_VP_ASSIST_PAGE_ENABLE))</blue>
		return false;
<blue>	return vcpu->arch.pv_eoi.msr_val & KVM_MSR_ENABLED;</blue>
<yellow>}</yellow>
EXPORT_SYMBOL_GPL(kvm_hv_assist_page_enabled);

<blue>bool kvm_hv_get_assist_page(struct kvm_vcpu *vcpu,</blue>
			    struct hv_vp_assist_page *assist_page)
{
<blue>	if (!kvm_hv_assist_page_enabled(vcpu))</blue>
		return false;
<blue>	return !kvm_read_guest_cached(vcpu->kvm, &vcpu->arch.pv_eoi.data,</blue>
				      assist_page, sizeof(*assist_page));
<blue>}</blue>
EXPORT_SYMBOL_GPL(kvm_hv_get_assist_page);

static void stimer_prepare_msg(struct kvm_vcpu_hv_stimer *stimer)
{
	struct hv_message *msg = &amp;stimer-&gt;msg;
	struct hv_timer_message_payload *payload =
			(struct hv_timer_message_payload *)&amp;msg-&gt;u.payload;

	memset(&amp;msg-&gt;header, 0, sizeof(msg-&gt;header));
	msg-&gt;header.message_type = HVMSG_TIMER_EXPIRED;
	msg-&gt;header.payload_size = sizeof(*payload);

	payload-&gt;timer_index = stimer-&gt;index;
	payload-&gt;expiration_time = 0;
	payload-&gt;delivery_time = 0;
}

static void stimer_init(struct kvm_vcpu_hv_stimer *stimer, int timer_index)
{
	memset(stimer, 0, sizeof(*stimer));
	stimer-&gt;index = timer_index;
	hrtimer_init(&amp;stimer-&gt;timer, CLOCK_MONOTONIC, HRTIMER_MODE_ABS);
	stimer-&gt;timer.function = stimer_timer_callback;
	stimer_prepare_msg(stimer);
}

int kvm_hv_vcpu_init(struct kvm_vcpu *vcpu)
{
<blue>	struct kvm_vcpu_hv *hv_vcpu = to_hv_vcpu(vcpu);</blue>
	int i;

<blue>	if (hv_vcpu)</blue>
		return 0;

<blue>	hv_vcpu = kzalloc(sizeof(struct kvm_vcpu_hv), GFP_KERNEL_ACCOUNT);</blue>
	if (!hv_vcpu)
		return -ENOMEM;

<blue>	vcpu->arch.hyperv = hv_vcpu;</blue>
	hv_vcpu-&gt;vcpu = vcpu;

<blue>	synic_init(&hv_vcpu->synic);</blue>

<blue>	bitmap_zero(hv_vcpu->stimer_pending_bitmap, HV_SYNIC_STIMER_COUNT);</blue>
	for (i = 0; i &lt; ARRAY_SIZE(hv_vcpu-&gt;stimer); i++)
<blue>		stimer_init(&hv_vcpu->stimer[i], i);</blue>

<blue>	hv_vcpu->vp_index = vcpu->vcpu_idx;</blue>

	return 0;
<blue>}</blue>

int kvm_hv_activate_synic(struct kvm_vcpu *vcpu, bool dont_zero_synic_pages)
{
	struct kvm_vcpu_hv_synic *synic;
	int r;

<blue>	r = kvm_hv_vcpu_init(vcpu);</blue>
	if (r)
		return r;

<blue>	synic = to_hv_synic(vcpu);</blue>

<blue>	synic->active = true;</blue>
	synic-&gt;dont_zero_synic_pages = dont_zero_synic_pages;
	synic-&gt;control = HV_SYNIC_CONTROL_ENABLE;
	return 0;
<blue>}</blue>

static bool kvm_hv_msr_partition_wide(u32 msr)
{
	bool r = false;

<blue>	switch (msr) {</blue>
	case HV_X64_MSR_GUEST_OS_ID:
	case HV_X64_MSR_HYPERCALL:
	case HV_X64_MSR_REFERENCE_TSC:
	case HV_X64_MSR_TIME_REF_COUNT:
	case HV_X64_MSR_CRASH_CTL:
	case HV_X64_MSR_CRASH_P0 ... HV_X64_MSR_CRASH_P4:
	case HV_X64_MSR_RESET:
	case HV_X64_MSR_REENLIGHTENMENT_CONTROL:
	case HV_X64_MSR_TSC_EMULATION_CONTROL:
	case HV_X64_MSR_TSC_EMULATION_STATUS:
	case HV_X64_MSR_SYNDBG_OPTIONS:
	case HV_X64_MSR_SYNDBG_CONTROL ... HV_X64_MSR_SYNDBG_PENDING_BUFFER:
		r = true;
		break;
	}

	return r;
}

static int kvm_hv_msr_get_crash_data(struct kvm *kvm, u32 index, u64 *pdata)
{
	struct kvm_hv *hv = to_kvm_hv(kvm);
	size_t size = ARRAY_SIZE(hv-&gt;hv_crash_param);

	if (WARN_ON_ONCE(index &gt;= size))
		return -EINVAL;

	*pdata = hv-&gt;hv_crash_param[array_index_nospec(index, size)];
	return 0;
}

static int kvm_hv_msr_get_crash_ctl(struct kvm *kvm, u64 *pdata)
{
	struct kvm_hv *hv = to_kvm_hv(kvm);

<yellow>	*pdata = hv->hv_crash_ctl;</yellow>
	return 0;
}

static int kvm_hv_msr_set_crash_ctl(struct kvm *kvm, u64 data)
{
	struct kvm_hv *hv = to_kvm_hv(kvm);

<blue>	hv->hv_crash_ctl = data & HV_CRASH_CTL_CRASH_NOTIFY;</blue>

	return 0;
}

static int kvm_hv_msr_set_crash_data(struct kvm *kvm, u32 index, u64 data)
{
	struct kvm_hv *hv = to_kvm_hv(kvm);
	size_t size = ARRAY_SIZE(hv-&gt;hv_crash_param);

	if (WARN_ON_ONCE(index &gt;= size))
		return -EINVAL;

	hv-&gt;hv_crash_param[array_index_nospec(index, size)] = data;
	return 0;
}

/*
 * The kvmclock and Hyper-V TSC page use similar formulas, and converting
 * between them is possible:
 *
 * kvmclock formula:
 *    nsec = (ticks - tsc_timestamp) * tsc_to_system_mul * 2^(tsc_shift-32)
 *           + system_time
 *
 * Hyper-V formula:
 *    nsec/100 = ticks * scale / 2^64 + offset
 *
 * When tsc_timestamp = system_time = 0, offset is zero in the Hyper-V formula.
 * By dividing the kvmclock formula by 100 and equating what&#x27;s left we get:
 *    ticks * scale / 2^64 = ticks * tsc_to_system_mul * 2^(tsc_shift-32) / 100
 *            scale / 2^64 =         tsc_to_system_mul * 2^(tsc_shift-32) / 100
 *            scale        =         tsc_to_system_mul * 2^(32+tsc_shift) / 100
 *
 * Now expand the kvmclock formula and divide by 100:
 *    nsec = ticks * tsc_to_system_mul * 2^(tsc_shift-32)
 *           - tsc_timestamp * tsc_to_system_mul * 2^(tsc_shift-32)
 *           + system_time
 *    nsec/100 = ticks * tsc_to_system_mul * 2^(tsc_shift-32) / 100
 *               - tsc_timestamp * tsc_to_system_mul * 2^(tsc_shift-32) / 100
 *               + system_time / 100
 *
 * Replace tsc_to_system_mul * 2^(tsc_shift-32) / 100 by scale / 2^64:
 *    nsec/100 = ticks * scale / 2^64
 *               - tsc_timestamp * scale / 2^64
 *               + system_time / 100
 *
 * Equate with the Hyper-V formula so that ticks * scale / 2^64 cancels out:
 *    offset = system_time / 100 - tsc_timestamp * scale / 2^64
 *
 * These two equivalencies are implemented in this function.
 */
static bool compute_tsc_page_parameters(struct pvclock_vcpu_time_info *hv_clock,
					struct ms_hyperv_tsc_page *tsc_ref)
{
	u64 max_mul;

<yellow>	if (!(hv_clock->flags & PVCLOCK_TSC_STABLE_BIT))</yellow>
		return false;

	/*
	 * check if scale would overflow, if so we use the time ref counter
	 *    tsc_to_system_mul * 2^(tsc_shift+32) / 100 &gt;= 2^64
	 *    tsc_to_system_mul / 100 &gt;= 2^(32-tsc_shift)
	 *    tsc_to_system_mul &gt;= 100 * 2^(32-tsc_shift)
	 */
<yellow>	max_mul = 100ull << (32 - hv_clock->tsc_shift);</yellow>
<yellow>	if (hv_clock->tsc_to_system_mul >= max_mul)</yellow>
		return false;

	/*
	 * Otherwise compute the scale and offset according to the formulas
	 * derived above.
	 */
	tsc_ref-&gt;tsc_scale =
<yellow>		mul_u64_u32_div(1ULL << (32 + hv_clock->tsc_shift),</yellow>
				hv_clock-&gt;tsc_to_system_mul,
				100);

	tsc_ref-&gt;tsc_offset = hv_clock-&gt;system_time;
	do_div(tsc_ref-&gt;tsc_offset, 100);
	tsc_ref-&gt;tsc_offset -=
		mul_u64_u64_shr(hv_clock-&gt;tsc_timestamp, tsc_ref-&gt;tsc_scale, 64);
	return true;
}

/*
 * Don&#x27;t touch TSC page values if the guest has opted for TSC emulation after
 * migration. KVM doesn&#x27;t fully support reenlightenment notifications and TSC
 * access emulation and Hyper-V is known to expect the values in TSC page to
 * stay constant before TSC access emulation is disabled from guest side
 * (HV_X64_MSR_TSC_EMULATION_STATUS). KVM userspace is expected to preserve TSC
 * frequency and guest visible TSC value across migration (and prevent it when
 * TSC scaling is unsupported).
 */
static inline bool tsc_page_update_unsafe(struct kvm_hv *hv)
{
<yellow>	return (hv->hv_tsc_page_status != HV_TSC_PAGE_GUEST_CHANGED) &&</yellow>
<yellow>		hv->hv_tsc_emulation_control;</yellow>
}

void kvm_hv_setup_tsc_page(struct kvm *kvm,
			   struct pvclock_vcpu_time_info *hv_clock)
{
	struct kvm_hv *hv = to_kvm_hv(kvm);
	u32 tsc_seq;
	u64 gfn;

	BUILD_BUG_ON(sizeof(tsc_seq) != sizeof(hv-&gt;tsc_ref.tsc_sequence));
	BUILD_BUG_ON(offsetof(struct ms_hyperv_tsc_page, tsc_sequence) != 0);

<blue>	mutex_lock(&hv->hv_lock);</blue>

	if (hv-&gt;hv_tsc_page_status == HV_TSC_PAGE_BROKEN ||
<blue>	    hv->hv_tsc_page_status == HV_TSC_PAGE_SET ||</blue>
	    hv-&gt;hv_tsc_page_status == HV_TSC_PAGE_UNSET)
		goto out_unlock;

<yellow>	if (!(hv->hv_tsc_page & HV_X64_MSR_TSC_REFERENCE_ENABLE))</yellow>
		goto out_unlock;

	gfn = hv-&gt;hv_tsc_page &gt;&gt; HV_X64_MSR_TSC_REFERENCE_ADDRESS_SHIFT;
	/*
	 * Because the TSC parameters only vary when there is a
	 * change in the master clock, do not bother with caching.
	 */
<yellow>	if (unlikely(kvm_read_guest(kvm, gfn_to_gpa(gfn),</yellow>
				    &amp;tsc_seq, sizeof(tsc_seq))))
		goto out_err;

<yellow>	if (tsc_seq && tsc_page_update_unsafe(hv)) {</yellow>
<yellow>		if (kvm_read_guest(kvm, gfn_to_gpa(gfn), &hv->tsc_ref, sizeof(hv->tsc_ref)))</yellow>
			goto out_err;

<yellow>		hv->hv_tsc_page_status = HV_TSC_PAGE_SET;</yellow>
		goto out_unlock;
	}

	/*
	 * While we&#x27;re computing and writing the parameters, force the
	 * guest to use the time reference count MSR.
	 */
<yellow>	hv->tsc_ref.tsc_sequence = 0;</yellow>
	if (kvm_write_guest(kvm, gfn_to_gpa(gfn),
			    &amp;hv-&gt;tsc_ref, sizeof(hv-&gt;tsc_ref.tsc_sequence)))
		goto out_err;

<yellow>	if (!compute_tsc_page_parameters(hv_clock, &hv->tsc_ref))</yellow>
		goto out_err;

	/* Ensure sequence is zero before writing the rest of the struct.  */
	smp_wmb();
	if (kvm_write_guest(kvm, gfn_to_gpa(gfn), &amp;hv-&gt;tsc_ref, sizeof(hv-&gt;tsc_ref)))
		goto out_err;

	/*
	 * Now switch to the TSC page mechanism by writing the sequence.
	 */
<yellow>	tsc_seq++;</yellow>
	if (tsc_seq == 0xFFFFFFFF || tsc_seq == 0)
<yellow>		tsc_seq = 1;</yellow>

	/* Write the struct entirely before the non-zero sequence.  */
	smp_wmb();

<yellow>	hv->tsc_ref.tsc_sequence = tsc_seq;</yellow>
	if (kvm_write_guest(kvm, gfn_to_gpa(gfn),
			    &amp;hv-&gt;tsc_ref, sizeof(hv-&gt;tsc_ref.tsc_sequence)))
		goto out_err;

	hv-&gt;hv_tsc_page_status = HV_TSC_PAGE_SET;
	goto out_unlock;

out_err:
<yellow>	hv->hv_tsc_page_status = HV_TSC_PAGE_BROKEN;</yellow>
out_unlock:
<blue>	mutex_unlock(&hv->hv_lock);</blue>
}

void kvm_hv_request_tsc_page_update(struct kvm *kvm)
{
	struct kvm_hv *hv = to_kvm_hv(kvm);

<blue>	mutex_lock(&hv->hv_lock);</blue>

	if (hv-&gt;hv_tsc_page_status == HV_TSC_PAGE_SET &amp;&amp;
<yellow>	    !tsc_page_update_unsafe(hv))</yellow>
<yellow>		hv->hv_tsc_page_status = HV_TSC_PAGE_HOST_CHANGED;</yellow>

<blue>	mutex_unlock(&hv->hv_lock);</blue>
}

<yellow>static bool hv_check_msr_access(struct kvm_vcpu_hv *hv_vcpu, u32 msr)</yellow>
{
<blue>	if (!hv_vcpu->enforce_cpuid)</blue>
		return true;

<yellow>	switch (msr) {</yellow>
	case HV_X64_MSR_GUEST_OS_ID:
	case HV_X64_MSR_HYPERCALL:
<yellow>		return hv_vcpu->cpuid_cache.features_eax &</yellow>
			HV_MSR_HYPERCALL_AVAILABLE;
	case HV_X64_MSR_VP_RUNTIME:
<yellow>		return hv_vcpu->cpuid_cache.features_eax &</yellow>
			HV_MSR_VP_RUNTIME_AVAILABLE;
	case HV_X64_MSR_TIME_REF_COUNT:
<yellow>		return hv_vcpu->cpuid_cache.features_eax &</yellow>
			HV_MSR_TIME_REF_COUNT_AVAILABLE;
	case HV_X64_MSR_VP_INDEX:
<yellow>		return hv_vcpu->cpuid_cache.features_eax &</yellow>
			HV_MSR_VP_INDEX_AVAILABLE;
	case HV_X64_MSR_RESET:
<yellow>		return hv_vcpu->cpuid_cache.features_eax &</yellow>
			HV_MSR_RESET_AVAILABLE;
	case HV_X64_MSR_REFERENCE_TSC:
<yellow>		return hv_vcpu->cpuid_cache.features_eax &</yellow>
			HV_MSR_REFERENCE_TSC_AVAILABLE;
	case HV_X64_MSR_SCONTROL:
	case HV_X64_MSR_SVERSION:
	case HV_X64_MSR_SIEFP:
	case HV_X64_MSR_SIMP:
	case HV_X64_MSR_EOM:
	case HV_X64_MSR_SINT0 ... HV_X64_MSR_SINT15:
<yellow>		return hv_vcpu->cpuid_cache.features_eax &</yellow>
			HV_MSR_SYNIC_AVAILABLE;
	case HV_X64_MSR_STIMER0_CONFIG:
	case HV_X64_MSR_STIMER1_CONFIG:
	case HV_X64_MSR_STIMER2_CONFIG:
	case HV_X64_MSR_STIMER3_CONFIG:
	case HV_X64_MSR_STIMER0_COUNT:
	case HV_X64_MSR_STIMER1_COUNT:
	case HV_X64_MSR_STIMER2_COUNT:
	case HV_X64_MSR_STIMER3_COUNT:
<yellow>		return hv_vcpu->cpuid_cache.features_eax &</yellow>
			HV_MSR_SYNTIMER_AVAILABLE;
	case HV_X64_MSR_EOI:
	case HV_X64_MSR_ICR:
	case HV_X64_MSR_TPR:
	case HV_X64_MSR_VP_ASSIST_PAGE:
<yellow>		return hv_vcpu->cpuid_cache.features_eax &</yellow>
			HV_MSR_APIC_ACCESS_AVAILABLE;
		break;
	case HV_X64_MSR_TSC_FREQUENCY:
	case HV_X64_MSR_APIC_FREQUENCY:
<yellow>		return hv_vcpu->cpuid_cache.features_eax &</yellow>
			HV_ACCESS_FREQUENCY_MSRS;
	case HV_X64_MSR_REENLIGHTENMENT_CONTROL:
	case HV_X64_MSR_TSC_EMULATION_CONTROL:
	case HV_X64_MSR_TSC_EMULATION_STATUS:
<yellow>		return hv_vcpu->cpuid_cache.features_eax &</yellow>
			HV_ACCESS_REENLIGHTENMENT;
	case HV_X64_MSR_CRASH_P0 ... HV_X64_MSR_CRASH_P4:
	case HV_X64_MSR_CRASH_CTL:
<yellow>		return hv_vcpu->cpuid_cache.features_edx &</yellow>
			HV_FEATURE_GUEST_CRASH_MSR_AVAILABLE;
	case HV_X64_MSR_SYNDBG_OPTIONS:
	case HV_X64_MSR_SYNDBG_CONTROL ... HV_X64_MSR_SYNDBG_PENDING_BUFFER:
<yellow>		return hv_vcpu->cpuid_cache.features_edx &</yellow>
			HV_FEATURE_DEBUG_MSRS_AVAILABLE;
	default:
		break;
	}

	return false;
<blue>}</blue>

static int kvm_hv_set_msr_pw(struct kvm_vcpu *vcpu, u32 msr, u64 data,
			     bool host)
{
	struct kvm *kvm = vcpu-&gt;kvm;
	struct kvm_hv *hv = to_kvm_hv(kvm);

<yellow>	if (unlikely(!host && !hv_check_msr_access(to_hv_vcpu(vcpu), msr)))</yellow>
<yellow>		return 1;</yellow>

<blue>	switch (msr) {</blue>
	case HV_X64_MSR_GUEST_OS_ID:
<blue>		hv->hv_guest_os_id = data;</blue>
		/* setting guest os id to zero disables hypercall page */
		if (!hv-&gt;hv_guest_os_id)
<blue>			hv->hv_hypercall &= ~HV_X64_MSR_HYPERCALL_ENABLE;</blue>
		break;
	case HV_X64_MSR_HYPERCALL: {
		u8 instructions[9];
		int i = 0;
		u64 addr;

		/* if guest os id is not set hypercall should remain disabled */
<blue>		if (!hv->hv_guest_os_id)</blue>
			break;
<yellow>		if (!(data & HV_X64_MSR_HYPERCALL_ENABLE)) {</yellow>
<yellow>			hv->hv_hypercall = data;</yellow>
			break;
		}

		/*
		 * If Xen and Hyper-V hypercalls are both enabled, disambiguate
		 * the same way Xen itself does, by setting the bit 31 of EAX
		 * which is RsvdZ in the 32-bit Hyper-V hypercall ABI and just
		 * going to be clobbered on 64-bit.
		 */
<yellow>		if (kvm_xen_hypercall_enabled(kvm)) {</yellow>
			/* orl $0x80000000, %eax */
			instructions[i++] = 0x0d;
			instructions[i++] = 0x00;
			instructions[i++] = 0x00;
			instructions[i++] = 0x00;
<yellow>			instructions[i++] = 0x80;</yellow>
		}

		/* vmcall/vmmcall */
		static_call(kvm_x86_patch_hypercall)(vcpu, instructions + i);
		i += 3;

		/* ret */
<yellow>		((unsigned char *)instructions)[i++] = 0xc3;</yellow>

		addr = data &amp; HV_X64_MSR_HYPERCALL_PAGE_ADDRESS_MASK;
		if (kvm_vcpu_write_guest(vcpu, addr, instructions, i))
<yellow>			return 1;</yellow>
<yellow>		hv->hv_hypercall = data;</yellow>
		break;
	}
	case HV_X64_MSR_REFERENCE_TSC:
<blue>		hv->hv_tsc_page = data;</blue>
		if (hv-&gt;hv_tsc_page &amp; HV_X64_MSR_TSC_REFERENCE_ENABLE) {
			if (!host)
<yellow>				hv->hv_tsc_page_status = HV_TSC_PAGE_GUEST_CHANGED;</yellow>
			else
				hv-&gt;hv_tsc_page_status = HV_TSC_PAGE_HOST_CHANGED;
			kvm_make_request(KVM_REQ_MASTERCLOCK_UPDATE, vcpu);
		} else {
<blue>			hv->hv_tsc_page_status = HV_TSC_PAGE_UNSET;</blue>
		}
		break;
	case HV_X64_MSR_CRASH_P0 ... HV_X64_MSR_CRASH_P4:
<blue>		return kvm_hv_msr_set_crash_data(kvm,</blue>
						 msr - HV_X64_MSR_CRASH_P0,
						 data);
	case HV_X64_MSR_CRASH_CTL:
<blue>		if (host)</blue>
<blue>			return kvm_hv_msr_set_crash_ctl(kvm, data);</blue>

<yellow>		if (data & HV_CRASH_CTL_CRASH_NOTIFY) {</yellow>
<yellow>			vcpu_debug(vcpu, "hv crash (0x%llx 0x%llx 0x%llx 0x%llx 0x%llx)\n",</yellow>
				   hv-&gt;hv_crash_param[0],
				   hv-&gt;hv_crash_param[1],
				   hv-&gt;hv_crash_param[2],
				   hv-&gt;hv_crash_param[3],
				   hv-&gt;hv_crash_param[4]);

			/* Send notification about crash to user space */
<yellow>			kvm_make_request(KVM_REQ_HV_CRASH, vcpu);</yellow>
		}
		break;
	case HV_X64_MSR_RESET:
<yellow>		if (data == 1) {</yellow>
<yellow>			vcpu_debug(vcpu, "hyper-v reset requested\n");</yellow>
<yellow>			kvm_make_request(KVM_REQ_HV_RESET, vcpu);</yellow>
		}
		break;
	case HV_X64_MSR_REENLIGHTENMENT_CONTROL:
<blue>		hv->hv_reenlightenment_control = data;</blue>
		break;
	case HV_X64_MSR_TSC_EMULATION_CONTROL:
<blue>		hv->hv_tsc_emulation_control = data;</blue>
		break;
	case HV_X64_MSR_TSC_EMULATION_STATUS:
<blue>		if (data && !host)</blue>
			return 1;

<blue>		hv->hv_tsc_emulation_status = data;</blue>
		break;
	case HV_X64_MSR_TIME_REF_COUNT:
		/* read-only, but still ignore it if host-initiated */
		if (!host)
			return 1;
		break;
	case HV_X64_MSR_SYNDBG_OPTIONS:
	case HV_X64_MSR_SYNDBG_CONTROL ... HV_X64_MSR_SYNDBG_PENDING_BUFFER:
<blue>		return syndbg_set_msr(vcpu, msr, data, host);</blue>
	default:
<yellow>		vcpu_unimpl(vcpu, "Hyper-V unhandled wrmsr: 0x%x data 0x%llx\n",</yellow>
			    msr, data);
		return 1;
	}
<blue>	return 0;</blue>
}

/* Calculate cpu time spent by current task in 100ns units */
static u64 current_task_runtime_100ns(void)
{
	u64 utime, stime;

<blue>	task_cputime_adjusted(current, &utime, &stime);</blue>

	return div_u64(utime + stime, 100);
}

static int kvm_hv_set_msr(struct kvm_vcpu *vcpu, u32 msr, u64 data, bool host)
{
	struct kvm_vcpu_hv *hv_vcpu = to_hv_vcpu(vcpu);

<blue>	if (unlikely(!host && !hv_check_msr_access(hv_vcpu, msr)))</blue>
		return 1;

<blue>	switch (msr) {</blue>
	case HV_X64_MSR_VP_INDEX: {
<blue>		struct kvm_hv *hv = to_kvm_hv(vcpu->kvm);</blue>
		u32 new_vp_index = (u32)data;

<blue>		if (!host || new_vp_index >= KVM_MAX_VCPUS)</blue>
			return 1;

<blue>		if (new_vp_index == hv_vcpu->vp_index)</blue>
			return 0;

		/*
		 * The VP index is initialized to vcpu_index by
		 * kvm_hv_vcpu_postcreate so they initially match.  Now the
		 * VP index is changing, adjust num_mismatched_vp_indexes if
		 * it now matches or no longer matches vcpu_idx.
		 */
<yellow>		if (hv_vcpu->vp_index == vcpu->vcpu_idx)</yellow>
<yellow>			atomic_inc(&hv->num_mismatched_vp_indexes);</yellow>
<yellow>		else if (new_vp_index == vcpu->vcpu_idx)</yellow>
<yellow>			atomic_dec(&hv->num_mismatched_vp_indexes);</yellow>

<yellow>		hv_vcpu->vp_index = new_vp_index;</yellow>
		break;
	}
	case HV_X64_MSR_VP_ASSIST_PAGE: {
		u64 gfn;
		unsigned long addr;

<blue>		if (!(data & HV_X64_MSR_VP_ASSIST_PAGE_ENABLE)) {</blue>
<blue>			hv_vcpu->hv_vapic = data;</blue>
			if (kvm_lapic_set_pv_eoi(vcpu, 0, 0))
				return 1;
			break;
		}
<blue>		gfn = data >> HV_X64_MSR_VP_ASSIST_PAGE_ADDRESS_SHIFT;</blue>
		addr = kvm_vcpu_gfn_to_hva(vcpu, gfn);
		if (kvm_is_error_hva(addr))
			return 1;

		/*
		 * Clear apic_assist portion of struct hv_vp_assist_page
		 * only, there can be valuable data in the rest which needs
		 * to be preserved e.g. on migration.
		 */
<blue>		if (__put_user(0, (u32 __user *)addr))</blue>
			return 1;
<blue>		hv_vcpu->hv_vapic = data;</blue>
		kvm_vcpu_mark_page_dirty(vcpu, gfn);
		if (kvm_lapic_set_pv_eoi(vcpu,
					    gfn_to_gpa(gfn) | KVM_MSR_ENABLED,
					    sizeof(struct hv_vp_assist_page)))
			return 1;
		break;
	}
	case HV_X64_MSR_EOI:
<yellow>		return kvm_hv_vapic_msr_write(vcpu, APIC_EOI, data);</yellow>
	case HV_X64_MSR_ICR:
<yellow>		return kvm_hv_vapic_msr_write(vcpu, APIC_ICR, data);</yellow>
	case HV_X64_MSR_TPR:
<yellow>		return kvm_hv_vapic_msr_write(vcpu, APIC_TASKPRI, data);</yellow>
	case HV_X64_MSR_VP_RUNTIME:
<yellow>		if (!host)</yellow>
			return 1;
<blue>		hv_vcpu->runtime_offset = data - current_task_runtime_100ns();</blue>
		break;
	case HV_X64_MSR_SCONTROL:
	case HV_X64_MSR_SVERSION:
	case HV_X64_MSR_SIEFP:
	case HV_X64_MSR_SIMP:
	case HV_X64_MSR_EOM:
	case HV_X64_MSR_SINT0 ... HV_X64_MSR_SINT15:
<blue>		return synic_set_msr(to_hv_synic(vcpu), msr, data, host);</blue>
	case HV_X64_MSR_STIMER0_CONFIG:
	case HV_X64_MSR_STIMER1_CONFIG:
	case HV_X64_MSR_STIMER2_CONFIG:
	case HV_X64_MSR_STIMER3_CONFIG: {
<blue>		int timer_index = (msr - HV_X64_MSR_STIMER0_CONFIG)/2;</blue>

<blue>		return stimer_set_config(to_hv_stimer(vcpu, timer_index),</blue>
					 data, host);
	}
	case HV_X64_MSR_STIMER0_COUNT:
	case HV_X64_MSR_STIMER1_COUNT:
	case HV_X64_MSR_STIMER2_COUNT:
	case HV_X64_MSR_STIMER3_COUNT: {
<blue>		int timer_index = (msr - HV_X64_MSR_STIMER0_COUNT)/2;</blue>

<blue>		return stimer_set_count(to_hv_stimer(vcpu, timer_index),</blue>
					data, host);
	}
	case HV_X64_MSR_TSC_FREQUENCY:
	case HV_X64_MSR_APIC_FREQUENCY:
		/* read-only, but still ignore it if host-initiated */
		if (!host)
			return 1;
		break;
	default:
<yellow>		vcpu_unimpl(vcpu, "Hyper-V unhandled wrmsr: 0x%x data 0x%llx\n",</yellow>
			    msr, data);
		return 1;
	}

	return 0;
}

static int kvm_hv_get_msr_pw(struct kvm_vcpu *vcpu, u32 msr, u64 *pdata,
			     bool host)
{
	u64 data = 0;
	struct kvm *kvm = vcpu-&gt;kvm;
	struct kvm_hv *hv = to_kvm_hv(kvm);

<yellow>	if (unlikely(!host && !hv_check_msr_access(to_hv_vcpu(vcpu), msr)))</yellow>
		return 1;

<blue>	switch (msr) {</blue>
	case HV_X64_MSR_GUEST_OS_ID:
<blue>		data = hv->hv_guest_os_id;</blue>
		break;
	case HV_X64_MSR_HYPERCALL:
<blue>		data = hv->hv_hypercall;</blue>
		break;
	case HV_X64_MSR_TIME_REF_COUNT:
<yellow>		data = get_time_ref_counter(kvm);</yellow>
		break;
	case HV_X64_MSR_REFERENCE_TSC:
<blue>		data = hv->hv_tsc_page;</blue>
		break;
	case HV_X64_MSR_CRASH_P0 ... HV_X64_MSR_CRASH_P4:
<blue>		return kvm_hv_msr_get_crash_data(kvm,</blue>
						 msr - HV_X64_MSR_CRASH_P0,
						 pdata);
	case HV_X64_MSR_CRASH_CTL:
<yellow>		return kvm_hv_msr_get_crash_ctl(kvm, pdata);</yellow>
	case HV_X64_MSR_RESET:
		data = 0;
		break;
	case HV_X64_MSR_REENLIGHTENMENT_CONTROL:
<blue>		data = hv->hv_reenlightenment_control;</blue>
		break;
	case HV_X64_MSR_TSC_EMULATION_CONTROL:
<blue>		data = hv->hv_tsc_emulation_control;</blue>
		break;
	case HV_X64_MSR_TSC_EMULATION_STATUS:
<blue>		data = hv->hv_tsc_emulation_status;</blue>
		break;
	case HV_X64_MSR_SYNDBG_OPTIONS:
	case HV_X64_MSR_SYNDBG_CONTROL ... HV_X64_MSR_SYNDBG_PENDING_BUFFER:
<blue>		return syndbg_get_msr(vcpu, msr, pdata, host);</blue>
	default:
<yellow>		vcpu_unimpl(vcpu, "Hyper-V unhandled rdmsr: 0x%x\n", msr);</yellow>
		return 1;
	}

<blue>	*pdata = data;</blue>
	return 0;
}

static int kvm_hv_get_msr(struct kvm_vcpu *vcpu, u32 msr, u64 *pdata,
			  bool host)
{
	u64 data = 0;
<blue>	struct kvm_vcpu_hv *hv_vcpu = to_hv_vcpu(vcpu);</blue>

<blue>	if (unlikely(!host && !hv_check_msr_access(hv_vcpu, msr)))</blue>
		return 1;

<blue>	switch (msr) {</blue>
	case HV_X64_MSR_VP_INDEX:
<yellow>		data = hv_vcpu->vp_index;</yellow>
		break;
	case HV_X64_MSR_EOI:
<yellow>		return kvm_hv_vapic_msr_read(vcpu, APIC_EOI, pdata);</yellow>
	case HV_X64_MSR_ICR:
<yellow>		return kvm_hv_vapic_msr_read(vcpu, APIC_ICR, pdata);</yellow>
	case HV_X64_MSR_TPR:
<yellow>		return kvm_hv_vapic_msr_read(vcpu, APIC_TASKPRI, pdata);</yellow>
	case HV_X64_MSR_VP_ASSIST_PAGE:
<blue>		data = hv_vcpu->hv_vapic;</blue>
		break;
	case HV_X64_MSR_VP_RUNTIME:
<blue>		data = current_task_runtime_100ns() + hv_vcpu->runtime_offset;</blue>
<yellow>		break;</yellow>
	case HV_X64_MSR_SCONTROL:
	case HV_X64_MSR_SVERSION:
	case HV_X64_MSR_SIEFP:
	case HV_X64_MSR_SIMP:
	case HV_X64_MSR_EOM:
	case HV_X64_MSR_SINT0 ... HV_X64_MSR_SINT15:
<blue>		return synic_get_msr(to_hv_synic(vcpu), msr, pdata, host);</blue>
	case HV_X64_MSR_STIMER0_CONFIG:
	case HV_X64_MSR_STIMER1_CONFIG:
	case HV_X64_MSR_STIMER2_CONFIG:
	case HV_X64_MSR_STIMER3_CONFIG: {
<blue>		int timer_index = (msr - HV_X64_MSR_STIMER0_CONFIG)/2;</blue>

		return stimer_get_config(to_hv_stimer(vcpu, timer_index),
					 pdata);
	}
	case HV_X64_MSR_STIMER0_COUNT:
	case HV_X64_MSR_STIMER1_COUNT:
	case HV_X64_MSR_STIMER2_COUNT:
	case HV_X64_MSR_STIMER3_COUNT: {
<blue>		int timer_index = (msr - HV_X64_MSR_STIMER0_COUNT)/2;</blue>

		return stimer_get_count(to_hv_stimer(vcpu, timer_index),
					pdata);
	}
	case HV_X64_MSR_TSC_FREQUENCY:
<yellow>		data = (u64)vcpu->arch.virtual_tsc_khz * 1000;</yellow>
		break;
	case HV_X64_MSR_APIC_FREQUENCY:
		data = APIC_BUS_FREQUENCY;
		break;
	default:
<yellow>		vcpu_unimpl(vcpu, "Hyper-V unhandled rdmsr: 0x%x\n", msr);</yellow>
		return 1;
	}
<blue>	*pdata = data;</blue>
	return 0;
}

int kvm_hv_set_msr_common(struct kvm_vcpu *vcpu, u32 msr, u64 data, bool host)
<blue>{</blue>
<blue>	struct kvm_hv *hv = to_kvm_hv(vcpu->kvm);</blue>

<blue>	if (!host && !vcpu->arch.hyperv_enabled)</blue>
<yellow>		return 1;</yellow>

<blue>	if (kvm_hv_vcpu_init(vcpu))</blue>
		return 1;

<blue>	if (kvm_hv_msr_partition_wide(msr)) {</blue>
		int r;

<blue>		mutex_lock(&hv->hv_lock);</blue>
<blue>		r = kvm_hv_set_msr_pw(vcpu, msr, data, host);</blue>
<blue>		mutex_unlock(&hv->hv_lock);</blue>
		return r;
	} else
<blue>		return kvm_hv_set_msr(vcpu, msr, data, host);</blue>
}

int kvm_hv_get_msr_common(struct kvm_vcpu *vcpu, u32 msr, u64 *pdata, bool host)
<blue>{</blue>
<blue>	struct kvm_hv *hv = to_kvm_hv(vcpu->kvm);</blue>

<blue>	if (!host && !vcpu->arch.hyperv_enabled)</blue>
		return 1;

<blue>	if (kvm_hv_vcpu_init(vcpu))</blue>
		return 1;

<blue>	if (kvm_hv_msr_partition_wide(msr)) {</blue>
		int r;

<blue>		mutex_lock(&hv->hv_lock);</blue>
<blue>		r = kvm_hv_get_msr_pw(vcpu, msr, pdata, host);</blue>
<blue>		mutex_unlock(&hv->hv_lock);</blue>
		return r;
	} else
<blue>		return kvm_hv_get_msr(vcpu, msr, pdata, host);</blue>
}

static void sparse_set_to_vcpu_mask(struct kvm *kvm, u64 *sparse_banks,
				    u64 valid_bank_mask, unsigned long *vcpu_mask)
<yellow>{</yellow>
	struct kvm_hv *hv = to_kvm_hv(kvm);
<yellow>	bool has_mismatch = atomic_read(&hv->num_mismatched_vp_indexes);</yellow>
	u64 vp_bitmap[KVM_HV_MAX_SPARSE_VCPU_SET_BITS];
	struct kvm_vcpu *vcpu;
	int bank, sbank = 0;
	unsigned long i;
	u64 *bitmap;

	BUILD_BUG_ON(sizeof(vp_bitmap) &gt;
		     sizeof(*vcpu_mask) * BITS_TO_LONGS(KVM_MAX_VCPUS));

	/*
	 * If vp_index == vcpu_idx for all vCPUs, fill vcpu_mask directly, else
	 * fill a temporary buffer and manually test each vCPU&#x27;s VP index.
	 */
	if (likely(!has_mismatch))
		bitmap = (u64 *)vcpu_mask;
	else
		bitmap = vp_bitmap;

	/*
	 * Each set of 64 VPs is packed into sparse_banks, with valid_bank_mask
	 * having a &#x27;1&#x27; for each bank that exists in sparse_banks.  Sets must
	 * be in ascending order, i.e. bank0..bankN.
	 */
<yellow>	memset(bitmap, 0, sizeof(vp_bitmap));</yellow>
<yellow>	for_each_set_bit(bank, (unsigned long *)&valid_bank_mask,</yellow>
			 KVM_HV_MAX_SPARSE_VCPU_SET_BITS)
<yellow>		bitmap[bank] = sparse_banks[sbank++];</yellow>

<yellow>	if (likely(!has_mismatch))</yellow>
		return;

<yellow>	bitmap_zero(vcpu_mask, KVM_MAX_VCPUS);</yellow>
<yellow>	kvm_for_each_vcpu(i, vcpu, kvm) {</yellow>
<yellow>		if (test_bit(kvm_hv_get_vpindex(vcpu), (unsigned long *)vp_bitmap))</yellow>
<yellow>			__set_bit(i, vcpu_mask);</yellow>
	}
}

struct kvm_hv_hcall {
	u64 param;
	u64 ingpa;
	u64 outgpa;
	u16 code;
	u16 var_cnt;
	u16 rep_cnt;
	u16 rep_idx;
	bool fast;
	bool rep;
	sse128_t xmm[HV_HYPERCALL_MAX_XMM_REGISTERS];
};

static u64 kvm_get_sparse_vp_set(struct kvm *kvm, struct kvm_hv_hcall *hc,
				 int consumed_xmm_halves,
				 u64 *sparse_banks, gpa_t offset)
{
	u16 var_cnt;
	int i;

<yellow>	if (hc->var_cnt > 64)</yellow>
		return -EINVAL;

	/* Ignore banks that cannot possibly contain a legal VP index. */
<yellow>	var_cnt = min_t(u16, hc->var_cnt, KVM_HV_MAX_SPARSE_VCPU_SET_BITS);</yellow>

<yellow>	if (hc->fast) {</yellow>
		/*
		 * Each XMM holds two sparse banks, but do not count halves that
		 * have already been consumed for hypercall parameters.
		 */
<yellow>		if (hc->var_cnt > 2 * HV_HYPERCALL_MAX_XMM_REGISTERS - consumed_xmm_halves)</yellow>
			return HV_STATUS_INVALID_HYPERCALL_INPUT;
<yellow>		for (i = 0; i < var_cnt; i++) {</yellow>
			int j = i + consumed_xmm_halves;
			if (j % 2)
<yellow>				sparse_banks[i] = sse128_hi(hc->xmm[j / 2]);</yellow>
			else
<yellow>				sparse_banks[i] = sse128_lo(hc->xmm[j / 2]);</yellow>
		}
		return 0;
	}

<yellow>	return kvm_read_guest(kvm, hc->ingpa + offset, sparse_banks,</yellow>
			      var_cnt * sizeof(*sparse_banks));
<yellow>}</yellow>

<yellow>static u64 kvm_hv_flush_tlb(struct kvm_vcpu *vcpu, struct kvm_hv_hcall *hc)</yellow>
{
	struct kvm *kvm = vcpu-&gt;kvm;
	struct hv_tlb_flush_ex flush_ex;
	struct hv_tlb_flush flush;
	DECLARE_BITMAP(vcpu_mask, KVM_MAX_VCPUS);
	u64 valid_bank_mask;
	u64 sparse_banks[KVM_HV_MAX_SPARSE_VCPU_SET_BITS];
	bool all_cpus;

	/*
	 * The Hyper-V TLFS doesn&#x27;t allow more than 64 sparse banks, e.g. the
	 * valid mask is a u64.  Fail the build if KVM&#x27;s max allowed number of
	 * vCPUs (&gt;4096) would exceed this limit, KVM will additional changes
	 * for Hyper-V support to avoid setting the guest up to fail.
	 */
	BUILD_BUG_ON(KVM_HV_MAX_SPARSE_VCPU_SET_BITS &gt; 64);

<yellow>	if (hc->code == HVCALL_FLUSH_VIRTUAL_ADDRESS_LIST ||</yellow>
	    hc-&gt;code == HVCALL_FLUSH_VIRTUAL_ADDRESS_SPACE) {
<yellow>		if (hc->fast) {</yellow>
<yellow>			flush.address_space = hc->ingpa;</yellow>
<yellow>			flush.flags = hc->outgpa;</yellow>
			flush.processor_mask = sse128_lo(hc-&gt;xmm[0]);
		} else {
<yellow>			if (unlikely(kvm_read_guest(kvm, hc->ingpa,</yellow>
						    &amp;flush, sizeof(flush))))
				return HV_STATUS_INVALID_HYPERCALL_INPUT;
		}

<yellow>		trace_kvm_hv_flush_tlb(flush.processor_mask,</yellow>
				       flush.address_space, flush.flags);

		valid_bank_mask = BIT_ULL(0);
<yellow>		sparse_banks[0] = flush.processor_mask;</yellow>

		/*
		 * Work around possible WS2012 bug: it sends hypercalls
		 * with processor_mask = 0x0 and HV_FLUSH_ALL_PROCESSORS clear,
		 * while also expecting us to flush something and crashing if
		 * we don&#x27;t. Let&#x27;s treat processor_mask == 0 same as
		 * HV_FLUSH_ALL_PROCESSORS.
		 */
<yellow>		all_cpus = (flush.flags & HV_FLUSH_ALL_PROCESSORS) ||</yellow>
			flush.processor_mask == 0;
	} else {
<yellow>		if (hc->fast) {</yellow>
			flush_ex.address_space = hc-&gt;ingpa;
<yellow>			flush_ex.flags = hc->outgpa;</yellow>
			memcpy(&amp;flush_ex.hv_vp_set,
			       &amp;hc-&gt;xmm[0], sizeof(hc-&gt;xmm[0]));
		} else {
<yellow>			if (unlikely(kvm_read_guest(kvm, hc->ingpa, &flush_ex,</yellow>
						    sizeof(flush_ex))))
				return HV_STATUS_INVALID_HYPERCALL_INPUT;
		}

<yellow>		trace_kvm_hv_flush_tlb_ex(flush_ex.hv_vp_set.valid_bank_mask,</yellow>
					  flush_ex.hv_vp_set.format,
					  flush_ex.address_space,
					  flush_ex.flags);

		valid_bank_mask = flush_ex.hv_vp_set.valid_bank_mask;
<yellow>		all_cpus = flush_ex.hv_vp_set.format !=</yellow>
			HV_GENERIC_SET_SPARSE_4K;

<yellow>		if (hc->var_cnt != hweight64(valid_bank_mask))</yellow>
			return HV_STATUS_INVALID_HYPERCALL_INPUT;

<yellow>		if (all_cpus)</yellow>
			goto do_flush;

<yellow>		if (!hc->var_cnt)</yellow>
			goto ret_success;

<yellow>		if (kvm_get_sparse_vp_set(kvm, hc, 2, sparse_banks,</yellow>
					  offsetof(struct hv_tlb_flush_ex,
						   hv_vp_set.bank_contents)))
			return HV_STATUS_INVALID_HYPERCALL_INPUT;
	}

do_flush:
	/*
	 * vcpu-&gt;arch.cr3 may not be up-to-date for running vCPUs so we can&#x27;t
	 * analyze it here, flush TLB regardless of the specified address space.
	 */
<yellow>	if (all_cpus) {</yellow>
<yellow>		kvm_make_all_cpus_request(kvm, KVM_REQ_TLB_FLUSH_GUEST);</yellow>
	} else {
<yellow>		sparse_set_to_vcpu_mask(kvm, sparse_banks, valid_bank_mask, vcpu_mask);</yellow>

		kvm_make_vcpus_request_mask(kvm, KVM_REQ_TLB_FLUSH_GUEST, vcpu_mask);
	}

ret_success:
	/* We always do full TLB flush, set &#x27;Reps completed&#x27; = &#x27;Rep Count&#x27; */
	return (u64)HV_STATUS_SUCCESS |
<yellow>		((u64)hc->rep_cnt << HV_HYPERCALL_REP_COMP_OFFSET);</yellow>
}

static void kvm_send_ipi_to_many(struct kvm *kvm, u32 vector,
				 unsigned long *vcpu_bitmap)
<yellow>{</yellow>
	struct kvm_lapic_irq irq = {
		.delivery_mode = APIC_DM_FIXED,
		.vector = vector
	};
	struct kvm_vcpu *vcpu;
	unsigned long i;

<yellow>	kvm_for_each_vcpu(i, vcpu, kvm) {</yellow>
<yellow>		if (vcpu_bitmap && !test_bit(i, vcpu_bitmap))</yellow>
			continue;

		/* We fail only when APIC is disabled */
<yellow>		kvm_apic_set_irq(vcpu, &irq, NULL);</yellow>
	}
}

<yellow>static u64 kvm_hv_send_ipi(struct kvm_vcpu *vcpu, struct kvm_hv_hcall *hc)</yellow>
{
	struct kvm *kvm = vcpu-&gt;kvm;
	struct hv_send_ipi_ex send_ipi_ex;
	struct hv_send_ipi send_ipi;
	DECLARE_BITMAP(vcpu_mask, KVM_MAX_VCPUS);
	u64 valid_bank_mask;
	u64 sparse_banks[KVM_HV_MAX_SPARSE_VCPU_SET_BITS];
	u32 vector;
	bool all_cpus;

<yellow>	if (hc->code == HVCALL_SEND_IPI) {</yellow>
<yellow>		if (!hc->fast) {</yellow>
<yellow>			if (unlikely(kvm_read_guest(kvm, hc->ingpa, &send_ipi,</yellow>
						    sizeof(send_ipi))))
				return HV_STATUS_INVALID_HYPERCALL_INPUT;
<yellow>			sparse_banks[0] = send_ipi.cpu_mask;</yellow>
			vector = send_ipi.vector;
		} else {
			/* &#x27;reserved&#x27; part of hv_send_ipi should be 0 */
<yellow>			if (unlikely(hc->ingpa >> 32 != 0))</yellow>
				return HV_STATUS_INVALID_HYPERCALL_INPUT;
<yellow>			sparse_banks[0] = hc->outgpa;</yellow>
			vector = (u32)hc-&gt;ingpa;
		}
		all_cpus = false;
		valid_bank_mask = BIT_ULL(0);

<yellow>		trace_kvm_hv_send_ipi(vector, sparse_banks[0]);</yellow>
	} else {
<yellow>		if (!hc->fast) {</yellow>
<yellow>			if (unlikely(kvm_read_guest(kvm, hc->ingpa, &send_ipi_ex,</yellow>
						    sizeof(send_ipi_ex))))
				return HV_STATUS_INVALID_HYPERCALL_INPUT;
		} else {
			send_ipi_ex.vector = (u32)hc-&gt;ingpa;
<yellow>			send_ipi_ex.vp_set.format = hc->outgpa;</yellow>
			send_ipi_ex.vp_set.valid_bank_mask = sse128_lo(hc-&gt;xmm[0]);
		}

<yellow>		trace_kvm_hv_send_ipi_ex(send_ipi_ex.vector,</yellow>
					 send_ipi_ex.vp_set.format,
					 send_ipi_ex.vp_set.valid_bank_mask);

		vector = send_ipi_ex.vector;
		valid_bank_mask = send_ipi_ex.vp_set.valid_bank_mask;
<yellow>		all_cpus = send_ipi_ex.vp_set.format == HV_GENERIC_SET_ALL;</yellow>

<yellow>		if (hc->var_cnt != hweight64(valid_bank_mask))</yellow>
			return HV_STATUS_INVALID_HYPERCALL_INPUT;

<yellow>		if (all_cpus)</yellow>
			goto check_and_send_ipi;

<yellow>		if (!hc->var_cnt)</yellow>
			goto ret_success;

<yellow>		if (kvm_get_sparse_vp_set(kvm, hc, 1, sparse_banks,</yellow>
					  offsetof(struct hv_send_ipi_ex,
						   vp_set.bank_contents)))
			return HV_STATUS_INVALID_HYPERCALL_INPUT;
	}

check_and_send_ipi:
<yellow>	if ((vector < HV_IPI_LOW_VECTOR) || (vector > HV_IPI_HIGH_VECTOR))</yellow>
		return HV_STATUS_INVALID_HYPERCALL_INPUT;

<yellow>	if (all_cpus) {</yellow>
<yellow>		kvm_send_ipi_to_many(kvm, vector, NULL);</yellow>
	} else {
<yellow>		sparse_set_to_vcpu_mask(kvm, sparse_banks, valid_bank_mask, vcpu_mask);</yellow>

		kvm_send_ipi_to_many(kvm, vector, vcpu_mask);
	}

ret_success:
	return HV_STATUS_SUCCESS;
}

void kvm_hv_set_cpuid(struct kvm_vcpu *vcpu, bool hyperv_enabled)
{
<blue>	struct kvm_vcpu_hv *hv_vcpu = to_hv_vcpu(vcpu);</blue>
	struct kvm_cpuid_entry2 *entry;

	vcpu-&gt;arch.hyperv_enabled = hyperv_enabled;

	if (!hv_vcpu) {
		/*
		 * KVM should have already allocated kvm_vcpu_hv if Hyper-V is
		 * enabled in CPUID.
		 */
<blue>		WARN_ON_ONCE(vcpu->arch.hyperv_enabled);</blue>
		return;
	}

<blue>	memset(&hv_vcpu->cpuid_cache, 0, sizeof(hv_vcpu->cpuid_cache));</blue>

<blue>	if (!vcpu->arch.hyperv_enabled)</blue>
		return;

<blue>	entry = kvm_find_cpuid_entry(vcpu, HYPERV_CPUID_FEATURES);</blue>
	if (entry) {
<blue>		hv_vcpu->cpuid_cache.features_eax = entry->eax;</blue>
		hv_vcpu-&gt;cpuid_cache.features_ebx = entry-&gt;ebx;
		hv_vcpu-&gt;cpuid_cache.features_edx = entry-&gt;edx;
	}

<blue>	entry = kvm_find_cpuid_entry(vcpu, HYPERV_CPUID_ENLIGHTMENT_INFO);</blue>
	if (entry) {
<blue>		hv_vcpu->cpuid_cache.enlightenments_eax = entry->eax;</blue>
		hv_vcpu-&gt;cpuid_cache.enlightenments_ebx = entry-&gt;ebx;
	}

<blue>	entry = kvm_find_cpuid_entry(vcpu, HYPERV_CPUID_SYNDBG_PLATFORM_CAPABILITIES);</blue>
	if (entry)
<blue>		hv_vcpu->cpuid_cache.syndbg_cap_eax = entry->eax;</blue>

<blue>	entry = kvm_find_cpuid_entry(vcpu, HYPERV_CPUID_NESTED_FEATURES);</blue>
	if (entry) {
<blue>		hv_vcpu->cpuid_cache.nested_eax = entry->eax;</blue>
		hv_vcpu-&gt;cpuid_cache.nested_ebx = entry-&gt;ebx;
	}
<blue>}</blue>

int kvm_hv_set_enforce_cpuid(struct kvm_vcpu *vcpu, bool enforce)
{
	struct kvm_vcpu_hv *hv_vcpu;
	int ret = 0;

<blue>	if (!to_hv_vcpu(vcpu)) {</blue>
<blue>		if (enforce) {</blue>
<blue>			ret = kvm_hv_vcpu_init(vcpu);</blue>
			if (ret)
				return ret;
		} else {
			return 0;
		}
	}

<blue>	hv_vcpu = to_hv_vcpu(vcpu);</blue>
<blue>	hv_vcpu->enforce_cpuid = enforce;</blue>

	return ret;
<blue>}</blue>

static void kvm_hv_hypercall_set_result(struct kvm_vcpu *vcpu, u64 result)
{
	bool longmode;

<yellow>	longmode = is_64_bit_hypercall(vcpu);</yellow>
	if (longmode)
<yellow>		kvm_rax_write(vcpu, result);</yellow>
	else {
<yellow>		kvm_rdx_write(vcpu, result >> 32);</yellow>
		kvm_rax_write(vcpu, result &amp; 0xffffffff);
	}
}

static int kvm_hv_hypercall_complete(struct kvm_vcpu *vcpu, u64 result)
{
<yellow>	trace_kvm_hv_hypercall_done(result);</yellow>
<yellow>	kvm_hv_hypercall_set_result(vcpu, result);</yellow>
	++vcpu-&gt;stat.hypercalls;
	return kvm_skip_emulated_instruction(vcpu);
}

static int kvm_hv_hypercall_complete_userspace(struct kvm_vcpu *vcpu)
{
<yellow>	return kvm_hv_hypercall_complete(vcpu, vcpu->run->hyperv.u.hcall.result);</yellow>
}

static u16 kvm_hvcall_signal_event(struct kvm_vcpu *vcpu, struct kvm_hv_hcall *hc)
{
<yellow>	struct kvm_hv *hv = to_kvm_hv(vcpu->kvm);</yellow>
	struct eventfd_ctx *eventfd;

<yellow>	if (unlikely(!hc->fast)) {</yellow>
		int ret;
		gpa_t gpa = hc-&gt;ingpa;

<yellow>		if ((gpa & (__alignof__(hc->ingpa) - 1)) ||</yellow>
<yellow>		    offset_in_page(gpa) + sizeof(hc->ingpa) > PAGE_SIZE)</yellow>
			return HV_STATUS_INVALID_ALIGNMENT;

<yellow>		ret = kvm_vcpu_read_guest(vcpu, gpa,</yellow>
					  &amp;hc-&gt;ingpa, sizeof(hc-&gt;ingpa));
		if (ret &lt; 0)
			return HV_STATUS_INVALID_ALIGNMENT;
	}

	/*
	 * Per spec, bits 32-47 contain the extra &quot;flag number&quot;.  However, we
	 * have no use for it, and in all known usecases it is zero, so just
	 * report lookup failure if it isn&#x27;t.
	 */
<yellow>	if (hc->ingpa & 0xffff00000000ULL)</yellow>
		return HV_STATUS_INVALID_PORT_ID;
	/* remaining bits are reserved-zero */
<yellow>	if (hc->ingpa & ~KVM_HYPERV_CONN_ID_MASK)</yellow>
		return HV_STATUS_INVALID_HYPERCALL_INPUT;

	/* the eventfd is protected by vcpu-&gt;kvm-&gt;srcu, but conn_to_evt isn&#x27;t */
<yellow>	rcu_read_lock();</yellow>
	eventfd = idr_find(&amp;hv-&gt;conn_to_evt, hc-&gt;ingpa);
	rcu_read_unlock();
	if (!eventfd)
		return HV_STATUS_INVALID_PORT_ID;

<yellow>	eventfd_signal(eventfd, 1);</yellow>
	return HV_STATUS_SUCCESS;
}

static bool is_xmm_fast_hypercall(struct kvm_hv_hcall *hc)
{
<yellow>	switch (hc->code) {</yellow>
	case HVCALL_FLUSH_VIRTUAL_ADDRESS_LIST:
	case HVCALL_FLUSH_VIRTUAL_ADDRESS_SPACE:
	case HVCALL_FLUSH_VIRTUAL_ADDRESS_LIST_EX:
	case HVCALL_FLUSH_VIRTUAL_ADDRESS_SPACE_EX:
	case HVCALL_SEND_IPI_EX:
		return true;
	}

	return false;
}

static void kvm_hv_hypercall_read_xmm(struct kvm_hv_hcall *hc)
{
	int reg;

<yellow>	kvm_fpu_get();</yellow>
<yellow>	for (reg = 0; reg < HV_HYPERCALL_MAX_XMM_REGISTERS; reg++)</yellow>
<yellow>		_kvm_read_sse_reg(reg, &hc->xmm[reg]);</yellow>
<yellow>	kvm_fpu_put();</yellow>
}

static bool hv_check_hypercall_access(struct kvm_vcpu_hv *hv_vcpu, u16 code)
{
<yellow>	if (!hv_vcpu->enforce_cpuid)</yellow>
		return true;

<yellow>	switch (code) {</yellow>
	case HVCALL_NOTIFY_LONG_SPIN_WAIT:
<yellow>		return hv_vcpu->cpuid_cache.enlightenments_ebx &&</yellow>
			hv_vcpu-&gt;cpuid_cache.enlightenments_ebx != U32_MAX;
	case HVCALL_POST_MESSAGE:
<yellow>		return hv_vcpu->cpuid_cache.features_ebx & HV_POST_MESSAGES;</yellow>
	case HVCALL_SIGNAL_EVENT:
<yellow>		return hv_vcpu->cpuid_cache.features_ebx & HV_SIGNAL_EVENTS;</yellow>
	case HVCALL_POST_DEBUG_DATA:
	case HVCALL_RETRIEVE_DEBUG_DATA:
	case HVCALL_RESET_DEBUG_SESSION:
		/*
		 * Return &#x27;true&#x27; when SynDBG is disabled so the resulting code
		 * will be HV_STATUS_INVALID_HYPERCALL_CODE.
		 */
<yellow>		return !kvm_hv_is_syndbg_enabled(hv_vcpu->vcpu) ||</yellow>
<yellow>			hv_vcpu->cpuid_cache.features_ebx & HV_DEBUGGING;</yellow>
	case HVCALL_FLUSH_VIRTUAL_ADDRESS_LIST_EX:
	case HVCALL_FLUSH_VIRTUAL_ADDRESS_SPACE_EX:
<yellow>		if (!(hv_vcpu->cpuid_cache.enlightenments_eax &</yellow>
		      HV_X64_EX_PROCESSOR_MASKS_RECOMMENDED))
			return false;
		fallthrough;
	case HVCALL_FLUSH_VIRTUAL_ADDRESS_LIST:
	case HVCALL_FLUSH_VIRTUAL_ADDRESS_SPACE:
<yellow>		return hv_vcpu->cpuid_cache.enlightenments_eax &</yellow>
			HV_X64_REMOTE_TLB_FLUSH_RECOMMENDED;
	case HVCALL_SEND_IPI_EX:
<yellow>		if (!(hv_vcpu->cpuid_cache.enlightenments_eax &</yellow>
		      HV_X64_EX_PROCESSOR_MASKS_RECOMMENDED))
			return false;
		fallthrough;
	case HVCALL_SEND_IPI:
<yellow>		return hv_vcpu->cpuid_cache.enlightenments_eax &</yellow>
			HV_X64_CLUSTER_IPI_RECOMMENDED;
	default:
		break;
	}

	return true;
}

int kvm_hv_hypercall(struct kvm_vcpu *vcpu)
<yellow>{</yellow>
<yellow>	struct kvm_vcpu_hv *hv_vcpu = to_hv_vcpu(vcpu);</yellow>
	struct kvm_hv_hcall hc;
	u64 ret = HV_STATUS_SUCCESS;

	/*
	 * hypercall generates UD from non zero cpl and real mode
	 * per HYPER-V spec
	 */
<yellow>	if (static_call(kvm_x86_get_cpl)(vcpu) != 0 || !is_protmode(vcpu)) {</yellow>
<yellow>		kvm_queue_exception(vcpu, UD_VECTOR);</yellow>
		return 1;
	}

#ifdef CONFIG_X86_64
<yellow>	if (is_64_bit_hypercall(vcpu)) {</yellow>
<yellow>		hc.param = kvm_rcx_read(vcpu);</yellow>
		hc.ingpa = kvm_rdx_read(vcpu);
<yellow>		hc.outgpa = kvm_r8_read(vcpu);</yellow>
	} else
#endif
	{
<yellow>		hc.param = ((u64)kvm_rdx_read(vcpu) << 32) |</yellow>
			    (kvm_rax_read(vcpu) &amp; 0xffffffff);
		hc.ingpa = ((u64)kvm_rbx_read(vcpu) &lt;&lt; 32) |
			    (kvm_rcx_read(vcpu) &amp; 0xffffffff);
		hc.outgpa = ((u64)kvm_rdi_read(vcpu) &lt;&lt; 32) |
			     (kvm_rsi_read(vcpu) &amp; 0xffffffff);
	}

	hc.code = hc.param &amp; 0xffff;
	hc.var_cnt = (hc.param &amp; HV_HYPERCALL_VARHEAD_MASK) &gt;&gt; HV_HYPERCALL_VARHEAD_OFFSET;
	hc.fast = !!(hc.param &amp; HV_HYPERCALL_FAST_BIT);
	hc.rep_cnt = (hc.param &gt;&gt; HV_HYPERCALL_REP_COMP_OFFSET) &amp; 0xfff;
	hc.rep_idx = (hc.param &gt;&gt; HV_HYPERCALL_REP_START_OFFSET) &amp; 0xfff;
	hc.rep = !!(hc.rep_cnt || hc.rep_idx);

<yellow>	trace_kvm_hv_hypercall(hc.code, hc.fast, hc.var_cnt, hc.rep_cnt,</yellow>
			       hc.rep_idx, hc.ingpa, hc.outgpa);

<yellow>	if (unlikely(!hv_check_hypercall_access(hv_vcpu, hc.code))) {</yellow>
		ret = HV_STATUS_ACCESS_DENIED;
		goto hypercall_complete;
	}

<yellow>	if (unlikely(hc.param & HV_HYPERCALL_RSVD_MASK)) {</yellow>
		ret = HV_STATUS_INVALID_HYPERCALL_INPUT;
		goto hypercall_complete;
	}

<yellow>	if (hc.fast && is_xmm_fast_hypercall(&hc)) {</yellow>
<yellow>		if (unlikely(hv_vcpu->enforce_cpuid &&</yellow>
			     !(hv_vcpu-&gt;cpuid_cache.features_edx &amp;
			       HV_X64_HYPERCALL_XMM_INPUT_AVAILABLE))) {
			kvm_queue_exception(vcpu, UD_VECTOR);
			return 1;
		}

<yellow>		kvm_hv_hypercall_read_xmm(&hc);</yellow>
	}

<yellow>	switch (hc.code) {</yellow>
	case HVCALL_NOTIFY_LONG_SPIN_WAIT:
<yellow>		if (unlikely(hc.rep || hc.var_cnt)) {</yellow>
			ret = HV_STATUS_INVALID_HYPERCALL_INPUT;
			break;
		}
<yellow>		kvm_vcpu_on_spin(vcpu, true);</yellow>
		break;
	case HVCALL_SIGNAL_EVENT:
<yellow>		if (unlikely(hc.rep || hc.var_cnt)) {</yellow>
			ret = HV_STATUS_INVALID_HYPERCALL_INPUT;
			break;
		}
<yellow>		ret = kvm_hvcall_signal_event(vcpu, &hc);</yellow>
		if (ret != HV_STATUS_INVALID_PORT_ID)
			break;
		fallthrough;	/* maybe userspace knows this conn_id */
	case HVCALL_POST_MESSAGE:
		/* don&#x27;t bother userspace if it has no way to handle it */
<yellow>		if (unlikely(hc.rep || hc.var_cnt || !to_hv_synic(vcpu)->active)) {</yellow>
			ret = HV_STATUS_INVALID_HYPERCALL_INPUT;
			break;
		}
<yellow>		vcpu->run->exit_reason = KVM_EXIT_HYPERV;</yellow>
		vcpu-&gt;run-&gt;hyperv.type = KVM_EXIT_HYPERV_HCALL;
		vcpu-&gt;run-&gt;hyperv.u.hcall.input = hc.param;
		vcpu-&gt;run-&gt;hyperv.u.hcall.params[0] = hc.ingpa;
		vcpu-&gt;run-&gt;hyperv.u.hcall.params[1] = hc.outgpa;
		vcpu-&gt;arch.complete_userspace_io =
				kvm_hv_hypercall_complete_userspace;
		return 0;
	case HVCALL_FLUSH_VIRTUAL_ADDRESS_LIST:
<yellow>		if (unlikely(hc.var_cnt)) {</yellow>
			ret = HV_STATUS_INVALID_HYPERCALL_INPUT;
			break;
		}
		fallthrough;
	case HVCALL_FLUSH_VIRTUAL_ADDRESS_LIST_EX:
<yellow>		if (unlikely(!hc.rep_cnt || hc.rep_idx)) {</yellow>
			ret = HV_STATUS_INVALID_HYPERCALL_INPUT;
			break;
		}
<yellow>		ret = kvm_hv_flush_tlb(vcpu, &hc);</yellow>
		break;
	case HVCALL_FLUSH_VIRTUAL_ADDRESS_SPACE:
<yellow>		if (unlikely(hc.var_cnt)) {</yellow>
			ret = HV_STATUS_INVALID_HYPERCALL_INPUT;
			break;
		}
		fallthrough;
	case HVCALL_FLUSH_VIRTUAL_ADDRESS_SPACE_EX:
<yellow>		if (unlikely(hc.rep)) {</yellow>
			ret = HV_STATUS_INVALID_HYPERCALL_INPUT;
			break;
		}
<yellow>		ret = kvm_hv_flush_tlb(vcpu, &hc);</yellow>
		break;
	case HVCALL_SEND_IPI:
<yellow>		if (unlikely(hc.var_cnt)) {</yellow>
			ret = HV_STATUS_INVALID_HYPERCALL_INPUT;
			break;
		}
		fallthrough;
	case HVCALL_SEND_IPI_EX:
<yellow>		if (unlikely(hc.rep)) {</yellow>
			ret = HV_STATUS_INVALID_HYPERCALL_INPUT;
			break;
		}
<yellow>		ret = kvm_hv_send_ipi(vcpu, &hc);</yellow>
		break;
	case HVCALL_POST_DEBUG_DATA:
	case HVCALL_RETRIEVE_DEBUG_DATA:
<yellow>		if (unlikely(hc.fast)) {</yellow>
			ret = HV_STATUS_INVALID_PARAMETER;
			break;
		}
		fallthrough;
	case HVCALL_RESET_DEBUG_SESSION: {
<yellow>		struct kvm_hv_syndbg *syndbg = to_hv_syndbg(vcpu);</yellow>

		if (!kvm_hv_is_syndbg_enabled(vcpu)) {
			ret = HV_STATUS_INVALID_HYPERCALL_CODE;
			break;
		}

<yellow>		if (!(syndbg->options & HV_X64_SYNDBG_OPTION_USE_HCALLS)) {</yellow>
			ret = HV_STATUS_OPERATION_DENIED;
			break;
		}
<yellow>		vcpu->run->exit_reason = KVM_EXIT_HYPERV;</yellow>
		vcpu-&gt;run-&gt;hyperv.type = KVM_EXIT_HYPERV_HCALL;
		vcpu-&gt;run-&gt;hyperv.u.hcall.input = hc.param;
		vcpu-&gt;run-&gt;hyperv.u.hcall.params[0] = hc.ingpa;
		vcpu-&gt;run-&gt;hyperv.u.hcall.params[1] = hc.outgpa;
		vcpu-&gt;arch.complete_userspace_io =
				kvm_hv_hypercall_complete_userspace;
		return 0;
	}
	default:
		ret = HV_STATUS_INVALID_HYPERCALL_CODE;
		break;
	}

hypercall_complete:
<yellow>	return kvm_hv_hypercall_complete(vcpu, ret);</yellow>
}

void kvm_hv_init_vm(struct kvm *kvm)
{
	struct kvm_hv *hv = to_kvm_hv(kvm);

<blue>	mutex_init(&hv->hv_lock);</blue>
	idr_init(&amp;hv-&gt;conn_to_evt);
}

void kvm_hv_destroy_vm(struct kvm *kvm)
{
	struct kvm_hv *hv = to_kvm_hv(kvm);
	struct eventfd_ctx *eventfd;
	int i;

<yellow>	idr_for_each_entry(&hv->conn_to_evt, eventfd, i)</yellow>
<yellow>		eventfd_ctx_put(eventfd);</yellow>
<yellow>	idr_destroy(&hv->conn_to_evt);</yellow>
}

static int kvm_hv_eventfd_assign(struct kvm *kvm, u32 conn_id, int fd)
{
	struct kvm_hv *hv = to_kvm_hv(kvm);
	struct eventfd_ctx *eventfd;
	int ret;

	eventfd = eventfd_ctx_fdget(fd);
	if (IS_ERR(eventfd))
<yellow>		return PTR_ERR(eventfd);</yellow>

<yellow>	mutex_lock(&hv->hv_lock);</yellow>
	ret = idr_alloc(&amp;hv-&gt;conn_to_evt, eventfd, conn_id, conn_id + 1,
			GFP_KERNEL_ACCOUNT);
	mutex_unlock(&amp;hv-&gt;hv_lock);

	if (ret &gt;= 0)
		return 0;

<yellow>	if (ret == -ENOSPC)</yellow>
		ret = -EEXIST;
<yellow>	eventfd_ctx_put(eventfd);</yellow>
	return ret;
}

static int kvm_hv_eventfd_deassign(struct kvm *kvm, u32 conn_id)
{
	struct kvm_hv *hv = to_kvm_hv(kvm);
	struct eventfd_ctx *eventfd;

<yellow>	mutex_lock(&hv->hv_lock);</yellow>
	eventfd = idr_remove(&amp;hv-&gt;conn_to_evt, conn_id);
	mutex_unlock(&amp;hv-&gt;hv_lock);

	if (!eventfd)
		return -ENOENT;

<yellow>	synchronize_srcu(&kvm->srcu);</yellow>
	eventfd_ctx_put(eventfd);
	return 0;
}

int kvm_vm_ioctl_hv_eventfd(struct kvm *kvm, struct kvm_hyperv_eventfd *args)
{
<yellow>	if ((args->flags & ~KVM_HYPERV_EVENTFD_DEASSIGN) ||</yellow>
<yellow>	    (args->conn_id & ~KVM_HYPERV_CONN_ID_MASK))</yellow>
		return -EINVAL;

<yellow>	if (args->flags == KVM_HYPERV_EVENTFD_DEASSIGN)</yellow>
<yellow>		return kvm_hv_eventfd_deassign(kvm, args->conn_id);</yellow>
<yellow>	return kvm_hv_eventfd_assign(kvm, args->conn_id, args->fd);</yellow>
<yellow>}</yellow>

int kvm_get_hv_cpuid(struct kvm_vcpu *vcpu, struct kvm_cpuid2 *cpuid,
		     struct kvm_cpuid_entry2 __user *entries)
<blue>{</blue>
	uint16_t evmcs_ver = 0;
<blue>	struct kvm_cpuid_entry2 cpuid_entries[] = {</blue>
		{ .function = HYPERV_CPUID_VENDOR_AND_MAX_FUNCTIONS },
		{ .function = HYPERV_CPUID_INTERFACE },
		{ .function = HYPERV_CPUID_VERSION },
		{ .function = HYPERV_CPUID_FEATURES },
		{ .function = HYPERV_CPUID_ENLIGHTMENT_INFO },
		{ .function = HYPERV_CPUID_IMPLEMENT_LIMITS },
		{ .function = HYPERV_CPUID_SYNDBG_VENDOR_AND_MAX_FUNCTIONS },
		{ .function = HYPERV_CPUID_SYNDBG_INTERFACE },
		{ .function = HYPERV_CPUID_SYNDBG_PLATFORM_CAPABILITIES	},
		{ .function = HYPERV_CPUID_NESTED_FEATURES },
	};
	int i, nent = ARRAY_SIZE(cpuid_entries);

	if (kvm_x86_ops.nested_ops-&gt;get_evmcs_version)
<blue>		evmcs_ver = kvm_x86_ops.nested_ops->get_evmcs_version(vcpu);</blue>

<blue>	if (cpuid->nent < nent)</blue>
		return -E2BIG;

<blue>	if (cpuid->nent > nent)</blue>
<blue>		cpuid->nent = nent;</blue>

<blue>	for (i = 0; i < nent; i++) {</blue>
<blue>		struct kvm_cpuid_entry2 *ent = &cpuid_entries[i];</blue>
		u32 signature[3];

		switch (ent-&gt;function) {
		case HYPERV_CPUID_VENDOR_AND_MAX_FUNCTIONS:
<blue>			memcpy(signature, "Linux KVM Hv", 12);</blue>

			ent-&gt;eax = HYPERV_CPUID_SYNDBG_PLATFORM_CAPABILITIES;
			ent-&gt;ebx = signature[0];
			ent-&gt;ecx = signature[1];
			ent-&gt;edx = signature[2];
			break;

		case HYPERV_CPUID_INTERFACE:
<blue>			ent->eax = HYPERV_CPUID_SIGNATURE_EAX;</blue>
			break;

		case HYPERV_CPUID_VERSION:
			/*
			 * We implement some Hyper-V 2016 functions so let&#x27;s use
			 * this version.
			 */
<blue>			ent->eax = 0x00003839;</blue>
			ent-&gt;ebx = 0x000A0000;
			break;

		case HYPERV_CPUID_FEATURES:
<blue>			ent->eax |= HV_MSR_VP_RUNTIME_AVAILABLE;</blue>
			ent-&gt;eax |= HV_MSR_TIME_REF_COUNT_AVAILABLE;
			ent-&gt;eax |= HV_MSR_SYNIC_AVAILABLE;
			ent-&gt;eax |= HV_MSR_SYNTIMER_AVAILABLE;
			ent-&gt;eax |= HV_MSR_APIC_ACCESS_AVAILABLE;
			ent-&gt;eax |= HV_MSR_HYPERCALL_AVAILABLE;
			ent-&gt;eax |= HV_MSR_VP_INDEX_AVAILABLE;
			ent-&gt;eax |= HV_MSR_RESET_AVAILABLE;
			ent-&gt;eax |= HV_MSR_REFERENCE_TSC_AVAILABLE;
			ent-&gt;eax |= HV_ACCESS_FREQUENCY_MSRS;
			ent-&gt;eax |= HV_ACCESS_REENLIGHTENMENT;

			ent-&gt;ebx |= HV_POST_MESSAGES;
			ent-&gt;ebx |= HV_SIGNAL_EVENTS;

			ent-&gt;edx |= HV_X64_HYPERCALL_XMM_INPUT_AVAILABLE;
			ent-&gt;edx |= HV_FEATURE_FREQUENCY_MSRS_AVAILABLE;
			ent-&gt;edx |= HV_FEATURE_GUEST_CRASH_MSR_AVAILABLE;

			ent-&gt;ebx |= HV_DEBUGGING;
			ent-&gt;edx |= HV_X64_GUEST_DEBUGGING_AVAILABLE;
			ent-&gt;edx |= HV_FEATURE_DEBUG_MSRS_AVAILABLE;

			/*
			 * Direct Synthetic timers only make sense with in-kernel
			 * LAPIC
			 */
<yellow>			if (!vcpu || lapic_in_kernel(vcpu))</yellow>
<blue>				ent->edx |= HV_STIMER_DIRECT_MODE_AVAILABLE;</blue>

			break;

		case HYPERV_CPUID_ENLIGHTMENT_INFO:
<blue>			ent->eax |= HV_X64_REMOTE_TLB_FLUSH_RECOMMENDED;</blue>
			ent-&gt;eax |= HV_X64_APIC_ACCESS_RECOMMENDED;
			ent-&gt;eax |= HV_X64_RELAXED_TIMING_RECOMMENDED;
			ent-&gt;eax |= HV_X64_CLUSTER_IPI_RECOMMENDED;
<yellow>			ent->eax |= HV_X64_EX_PROCESSOR_MASKS_RECOMMENDED;</yellow>
			if (evmcs_ver)
<blue>				ent->eax |= HV_X64_ENLIGHTENED_VMCS_RECOMMENDED;</blue>
<blue>			if (!cpu_smt_possible())</blue>
<blue>				ent->eax |= HV_X64_NO_NONARCH_CORESHARING;</blue>

<blue>			ent->eax |= HV_DEPRECATING_AEOI_RECOMMENDED;</blue>
			/*
			 * Default number of spinlock retry attempts, matches
			 * HyperV 2016.
			 */
			ent-&gt;ebx = 0x00000FFF;

			break;

		case HYPERV_CPUID_IMPLEMENT_LIMITS:
			/* Maximum number of virtual processors */
<blue>			ent->eax = KVM_MAX_VCPUS;</blue>
			/*
			 * Maximum number of logical processors, matches
			 * HyperV 2016.
			 */
			ent-&gt;ebx = 64;

			break;

		case HYPERV_CPUID_NESTED_FEATURES:
			ent-&gt;eax = evmcs_ver;
<blue>			ent->eax |= HV_X64_NESTED_MSR_BITMAP;</blue>
			ent-&gt;ebx |= HV_X64_NESTED_EVMCS1_PERF_GLOBAL_CTRL;
			break;

		case HYPERV_CPUID_SYNDBG_VENDOR_AND_MAX_FUNCTIONS:
<blue>			memcpy(signature, "Linux KVM Hv", 12);</blue>

			ent-&gt;eax = 0;
			ent-&gt;ebx = signature[0];
			ent-&gt;ecx = signature[1];
			ent-&gt;edx = signature[2];
			break;

		case HYPERV_CPUID_SYNDBG_INTERFACE:
<blue>			memcpy(signature, "VS#1\0\0\0\0\0\0\0\0", 12);</blue>
			ent-&gt;eax = signature[0];
			break;

		case HYPERV_CPUID_SYNDBG_PLATFORM_CAPABILITIES:
<blue>			ent->eax |= HV_X64_SYNDBG_CAP_ALLOW_KERNEL_DEBUGGING;</blue>
			break;

		default:
			break;
		}
	}

<blue>	if (copy_to_user(entries, cpuid_entries,</blue>
			 nent * sizeof(struct kvm_cpuid_entry2)))
		return -EFAULT;

	return 0;
}


</code></pre></td></tr></table>
</body>
</html>
