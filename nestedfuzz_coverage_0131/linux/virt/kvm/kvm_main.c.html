<doctype html>
<html lang="ja">
<head>
<meta charset="utf-8">
<script src="https://cdn.rawgit.com/google/code-prettify/master/loader/run_prettify.js"></script>
<style>
    code{
        font-family:Monaco, Menlo, Consolas, 'Courier New', Courier, monospace, sans-serif;
        font-size: 14px;
        line-height: 18px;
        overflow: auto;
        resize: horizontal;
    }
    code_line{
        font-family: Monaco, Menlo, Consolas, 'Courier New', Courier, monospace, sans-serif;;
        font-size: 14px;
        line-height: 18px;
        overflow: auto;
        resize: horizontal;
        color:#303134;
    }
    blue{
        background-color:#BEEDE8;
    }
    yellow{
        background-color:#FFFF99;
    }
    red{
        background-color:#FF99AC;
    }
</style>

</head>
<body>
<table summary='blob content' class='blob' cellspacing="15">
<tr><td align="right"><pre><code_line>1.
2.
3.
4.
5.
6.
7.
8.
9.
10.
11.
12.
13.
14.
15.
16.
17.
18.
19.
20.
21.
22.
23.
24.
25.
26.
27.
28.
29.
30.
31.
32.
33.
34.
35.
36.
37.
38.
39.
40.
41.
42.
43.
44.
45.
46.
47.
48.
49.
50.
51.
52.
53.
54.
55.
56.
57.
58.
59.
60.
61.
62.
63.
64.
65.
66.
67.
68.
69.
70.
71.
72.
73.
74.
75.
76.
77.
78.
79.
80.
81.
82.
83.
84.
85.
86.
87.
88.
89.
90.
91.
92.
93.
94.
95.
96.
97.
98.
99.
100.
101.
102.
103.
104.
105.
106.
107.
108.
109.
110.
111.
112.
113.
114.
115.
116.
117.
118.
119.
120.
121.
122.
123.
124.
125.
126.
127.
128.
129.
130.
131.
132.
133.
134.
135.
136.
137.
138.
139.
140.
141.
142.
143.
144.
145.
146.
147.
148.
149.
150.
151.
152.
153.
154.
155.
156.
157.
158.
159.
160.
161.
162.
163.
164.
165.
166.
167.
168.
169.
170.
171.
172.
173.
174.
175.
176.
177.
178.
179.
180.
181.
182.
183.
184.
185.
186.
187.
188.
189.
190.
191.
192.
193.
194.
195.
196.
197.
198.
199.
200.
201.
202.
203.
204.
205.
206.
207.
208.
209.
210.
211.
212.
213.
214.
215.
216.
217.
218.
219.
220.
221.
222.
223.
224.
225.
226.
227.
228.
229.
230.
231.
232.
233.
234.
235.
236.
237.
238.
239.
240.
241.
242.
243.
244.
245.
246.
247.
248.
249.
250.
251.
252.
253.
254.
255.
256.
257.
258.
259.
260.
261.
262.
263.
264.
265.
266.
267.
268.
269.
270.
271.
272.
273.
274.
275.
276.
277.
278.
279.
280.
281.
282.
283.
284.
285.
286.
287.
288.
289.
290.
291.
292.
293.
294.
295.
296.
297.
298.
299.
300.
301.
302.
303.
304.
305.
306.
307.
308.
309.
310.
311.
312.
313.
314.
315.
316.
317.
318.
319.
320.
321.
322.
323.
324.
325.
326.
327.
328.
329.
330.
331.
332.
333.
334.
335.
336.
337.
338.
339.
340.
341.
342.
343.
344.
345.
346.
347.
348.
349.
350.
351.
352.
353.
354.
355.
356.
357.
358.
359.
360.
361.
362.
363.
364.
365.
366.
367.
368.
369.
370.
371.
372.
373.
374.
375.
376.
377.
378.
379.
380.
381.
382.
383.
384.
385.
386.
387.
388.
389.
390.
391.
392.
393.
394.
395.
396.
397.
398.
399.
400.
401.
402.
403.
404.
405.
406.
407.
408.
409.
410.
411.
412.
413.
414.
415.
416.
417.
418.
419.
420.
421.
422.
423.
424.
425.
426.
427.
428.
429.
430.
431.
432.
433.
434.
435.
436.
437.
438.
439.
440.
441.
442.
443.
444.
445.
446.
447.
448.
449.
450.
451.
452.
453.
454.
455.
456.
457.
458.
459.
460.
461.
462.
463.
464.
465.
466.
467.
468.
469.
470.
471.
472.
473.
474.
475.
476.
477.
478.
479.
480.
481.
482.
483.
484.
485.
486.
487.
488.
489.
490.
491.
492.
493.
494.
495.
496.
497.
498.
499.
500.
501.
502.
503.
504.
505.
506.
507.
508.
509.
510.
511.
512.
513.
514.
515.
516.
517.
518.
519.
520.
521.
522.
523.
524.
525.
526.
527.
528.
529.
530.
531.
532.
533.
534.
535.
536.
537.
538.
539.
540.
541.
542.
543.
544.
545.
546.
547.
548.
549.
550.
551.
552.
553.
554.
555.
556.
557.
558.
559.
560.
561.
562.
563.
564.
565.
566.
567.
568.
569.
570.
571.
572.
573.
574.
575.
576.
577.
578.
579.
580.
581.
582.
583.
584.
585.
586.
587.
588.
589.
590.
591.
592.
593.
594.
595.
596.
597.
598.
599.
600.
601.
602.
603.
604.
605.
606.
607.
608.
609.
610.
611.
612.
613.
614.
615.
616.
617.
618.
619.
620.
621.
622.
623.
624.
625.
626.
627.
628.
629.
630.
631.
632.
633.
634.
635.
636.
637.
638.
639.
640.
641.
642.
643.
644.
645.
646.
647.
648.
649.
650.
651.
652.
653.
654.
655.
656.
657.
658.
659.
660.
661.
662.
663.
664.
665.
666.
667.
668.
669.
670.
671.
672.
673.
674.
675.
676.
677.
678.
679.
680.
681.
682.
683.
684.
685.
686.
687.
688.
689.
690.
691.
692.
693.
694.
695.
696.
697.
698.
699.
700.
701.
702.
703.
704.
705.
706.
707.
708.
709.
710.
711.
712.
713.
714.
715.
716.
717.
718.
719.
720.
721.
722.
723.
724.
725.
726.
727.
728.
729.
730.
731.
732.
733.
734.
735.
736.
737.
738.
739.
740.
741.
742.
743.
744.
745.
746.
747.
748.
749.
750.
751.
752.
753.
754.
755.
756.
757.
758.
759.
760.
761.
762.
763.
764.
765.
766.
767.
768.
769.
770.
771.
772.
773.
774.
775.
776.
777.
778.
779.
780.
781.
782.
783.
784.
785.
786.
787.
788.
789.
790.
791.
792.
793.
794.
795.
796.
797.
798.
799.
800.
801.
802.
803.
804.
805.
806.
807.
808.
809.
810.
811.
812.
813.
814.
815.
816.
817.
818.
819.
820.
821.
822.
823.
824.
825.
826.
827.
828.
829.
830.
831.
832.
833.
834.
835.
836.
837.
838.
839.
840.
841.
842.
843.
844.
845.
846.
847.
848.
849.
850.
851.
852.
853.
854.
855.
856.
857.
858.
859.
860.
861.
862.
863.
864.
865.
866.
867.
868.
869.
870.
871.
872.
873.
874.
875.
876.
877.
878.
879.
880.
881.
882.
883.
884.
885.
886.
887.
888.
889.
890.
891.
892.
893.
894.
895.
896.
897.
898.
899.
900.
901.
902.
903.
904.
905.
906.
907.
908.
909.
910.
911.
912.
913.
914.
915.
916.
917.
918.
919.
920.
921.
922.
923.
924.
925.
926.
927.
928.
929.
930.
931.
932.
933.
934.
935.
936.
937.
938.
939.
940.
941.
942.
943.
944.
945.
946.
947.
948.
949.
950.
951.
952.
953.
954.
955.
956.
957.
958.
959.
960.
961.
962.
963.
964.
965.
966.
967.
968.
969.
970.
971.
972.
973.
974.
975.
976.
977.
978.
979.
980.
981.
982.
983.
984.
985.
986.
987.
988.
989.
990.
991.
992.
993.
994.
995.
996.
997.
998.
999.
1000.
1001.
1002.
1003.
1004.
1005.
1006.
1007.
1008.
1009.
1010.
1011.
1012.
1013.
1014.
1015.
1016.
1017.
1018.
1019.
1020.
1021.
1022.
1023.
1024.
1025.
1026.
1027.
1028.
1029.
1030.
1031.
1032.
1033.
1034.
1035.
1036.
1037.
1038.
1039.
1040.
1041.
1042.
1043.
1044.
1045.
1046.
1047.
1048.
1049.
1050.
1051.
1052.
1053.
1054.
1055.
1056.
1057.
1058.
1059.
1060.
1061.
1062.
1063.
1064.
1065.
1066.
1067.
1068.
1069.
1070.
1071.
1072.
1073.
1074.
1075.
1076.
1077.
1078.
1079.
1080.
1081.
1082.
1083.
1084.
1085.
1086.
1087.
1088.
1089.
1090.
1091.
1092.
1093.
1094.
1095.
1096.
1097.
1098.
1099.
1100.
1101.
1102.
1103.
1104.
1105.
1106.
1107.
1108.
1109.
1110.
1111.
1112.
1113.
1114.
1115.
1116.
1117.
1118.
1119.
1120.
1121.
1122.
1123.
1124.
1125.
1126.
1127.
1128.
1129.
1130.
1131.
1132.
1133.
1134.
1135.
1136.
1137.
1138.
1139.
1140.
1141.
1142.
1143.
1144.
1145.
1146.
1147.
1148.
1149.
1150.
1151.
1152.
1153.
1154.
1155.
1156.
1157.
1158.
1159.
1160.
1161.
1162.
1163.
1164.
1165.
1166.
1167.
1168.
1169.
1170.
1171.
1172.
1173.
1174.
1175.
1176.
1177.
1178.
1179.
1180.
1181.
1182.
1183.
1184.
1185.
1186.
1187.
1188.
1189.
1190.
1191.
1192.
1193.
1194.
1195.
1196.
1197.
1198.
1199.
1200.
1201.
1202.
1203.
1204.
1205.
1206.
1207.
1208.
1209.
1210.
1211.
1212.
1213.
1214.
1215.
1216.
1217.
1218.
1219.
1220.
1221.
1222.
1223.
1224.
1225.
1226.
1227.
1228.
1229.
1230.
1231.
1232.
1233.
1234.
1235.
1236.
1237.
1238.
1239.
1240.
1241.
1242.
1243.
1244.
1245.
1246.
1247.
1248.
1249.
1250.
1251.
1252.
1253.
1254.
1255.
1256.
1257.
1258.
1259.
1260.
1261.
1262.
1263.
1264.
1265.
1266.
1267.
1268.
1269.
1270.
1271.
1272.
1273.
1274.
1275.
1276.
1277.
1278.
1279.
1280.
1281.
1282.
1283.
1284.
1285.
1286.
1287.
1288.
1289.
1290.
1291.
1292.
1293.
1294.
1295.
1296.
1297.
1298.
1299.
1300.
1301.
1302.
1303.
1304.
1305.
1306.
1307.
1308.
1309.
1310.
1311.
1312.
1313.
1314.
1315.
1316.
1317.
1318.
1319.
1320.
1321.
1322.
1323.
1324.
1325.
1326.
1327.
1328.
1329.
1330.
1331.
1332.
1333.
1334.
1335.
1336.
1337.
1338.
1339.
1340.
1341.
1342.
1343.
1344.
1345.
1346.
1347.
1348.
1349.
1350.
1351.
1352.
1353.
1354.
1355.
1356.
1357.
1358.
1359.
1360.
1361.
1362.
1363.
1364.
1365.
1366.
1367.
1368.
1369.
1370.
1371.
1372.
1373.
1374.
1375.
1376.
1377.
1378.
1379.
1380.
1381.
1382.
1383.
1384.
1385.
1386.
1387.
1388.
1389.
1390.
1391.
1392.
1393.
1394.
1395.
1396.
1397.
1398.
1399.
1400.
1401.
1402.
1403.
1404.
1405.
1406.
1407.
1408.
1409.
1410.
1411.
1412.
1413.
1414.
1415.
1416.
1417.
1418.
1419.
1420.
1421.
1422.
1423.
1424.
1425.
1426.
1427.
1428.
1429.
1430.
1431.
1432.
1433.
1434.
1435.
1436.
1437.
1438.
1439.
1440.
1441.
1442.
1443.
1444.
1445.
1446.
1447.
1448.
1449.
1450.
1451.
1452.
1453.
1454.
1455.
1456.
1457.
1458.
1459.
1460.
1461.
1462.
1463.
1464.
1465.
1466.
1467.
1468.
1469.
1470.
1471.
1472.
1473.
1474.
1475.
1476.
1477.
1478.
1479.
1480.
1481.
1482.
1483.
1484.
1485.
1486.
1487.
1488.
1489.
1490.
1491.
1492.
1493.
1494.
1495.
1496.
1497.
1498.
1499.
1500.
1501.
1502.
1503.
1504.
1505.
1506.
1507.
1508.
1509.
1510.
1511.
1512.
1513.
1514.
1515.
1516.
1517.
1518.
1519.
1520.
1521.
1522.
1523.
1524.
1525.
1526.
1527.
1528.
1529.
1530.
1531.
1532.
1533.
1534.
1535.
1536.
1537.
1538.
1539.
1540.
1541.
1542.
1543.
1544.
1545.
1546.
1547.
1548.
1549.
1550.
1551.
1552.
1553.
1554.
1555.
1556.
1557.
1558.
1559.
1560.
1561.
1562.
1563.
1564.
1565.
1566.
1567.
1568.
1569.
1570.
1571.
1572.
1573.
1574.
1575.
1576.
1577.
1578.
1579.
1580.
1581.
1582.
1583.
1584.
1585.
1586.
1587.
1588.
1589.
1590.
1591.
1592.
1593.
1594.
1595.
1596.
1597.
1598.
1599.
1600.
1601.
1602.
1603.
1604.
1605.
1606.
1607.
1608.
1609.
1610.
1611.
1612.
1613.
1614.
1615.
1616.
1617.
1618.
1619.
1620.
1621.
1622.
1623.
1624.
1625.
1626.
1627.
1628.
1629.
1630.
1631.
1632.
1633.
1634.
1635.
1636.
1637.
1638.
1639.
1640.
1641.
1642.
1643.
1644.
1645.
1646.
1647.
1648.
1649.
1650.
1651.
1652.
1653.
1654.
1655.
1656.
1657.
1658.
1659.
1660.
1661.
1662.
1663.
1664.
1665.
1666.
1667.
1668.
1669.
1670.
1671.
1672.
1673.
1674.
1675.
1676.
1677.
1678.
1679.
1680.
1681.
1682.
1683.
1684.
1685.
1686.
1687.
1688.
1689.
1690.
1691.
1692.
1693.
1694.
1695.
1696.
1697.
1698.
1699.
1700.
1701.
1702.
1703.
1704.
1705.
1706.
1707.
1708.
1709.
1710.
1711.
1712.
1713.
1714.
1715.
1716.
1717.
1718.
1719.
1720.
1721.
1722.
1723.
1724.
1725.
1726.
1727.
1728.
1729.
1730.
1731.
1732.
1733.
1734.
1735.
1736.
1737.
1738.
1739.
1740.
1741.
1742.
1743.
1744.
1745.
1746.
1747.
1748.
1749.
1750.
1751.
1752.
1753.
1754.
1755.
1756.
1757.
1758.
1759.
1760.
1761.
1762.
1763.
1764.
1765.
1766.
1767.
1768.
1769.
1770.
1771.
1772.
1773.
1774.
1775.
1776.
1777.
1778.
1779.
1780.
1781.
1782.
1783.
1784.
1785.
1786.
1787.
1788.
1789.
1790.
1791.
1792.
1793.
1794.
1795.
1796.
1797.
1798.
1799.
1800.
1801.
1802.
1803.
1804.
1805.
1806.
1807.
1808.
1809.
1810.
1811.
1812.
1813.
1814.
1815.
1816.
1817.
1818.
1819.
1820.
1821.
1822.
1823.
1824.
1825.
1826.
1827.
1828.
1829.
1830.
1831.
1832.
1833.
1834.
1835.
1836.
1837.
1838.
1839.
1840.
1841.
1842.
1843.
1844.
1845.
1846.
1847.
1848.
1849.
1850.
1851.
1852.
1853.
1854.
1855.
1856.
1857.
1858.
1859.
1860.
1861.
1862.
1863.
1864.
1865.
1866.
1867.
1868.
1869.
1870.
1871.
1872.
1873.
1874.
1875.
1876.
1877.
1878.
1879.
1880.
1881.
1882.
1883.
1884.
1885.
1886.
1887.
1888.
1889.
1890.
1891.
1892.
1893.
1894.
1895.
1896.
1897.
1898.
1899.
1900.
1901.
1902.
1903.
1904.
1905.
1906.
1907.
1908.
1909.
1910.
1911.
1912.
1913.
1914.
1915.
1916.
1917.
1918.
1919.
1920.
1921.
1922.
1923.
1924.
1925.
1926.
1927.
1928.
1929.
1930.
1931.
1932.
1933.
1934.
1935.
1936.
1937.
1938.
1939.
1940.
1941.
1942.
1943.
1944.
1945.
1946.
1947.
1948.
1949.
1950.
1951.
1952.
1953.
1954.
1955.
1956.
1957.
1958.
1959.
1960.
1961.
1962.
1963.
1964.
1965.
1966.
1967.
1968.
1969.
1970.
1971.
1972.
1973.
1974.
1975.
1976.
1977.
1978.
1979.
1980.
1981.
1982.
1983.
1984.
1985.
1986.
1987.
1988.
1989.
1990.
1991.
1992.
1993.
1994.
1995.
1996.
1997.
1998.
1999.
2000.
2001.
2002.
2003.
2004.
2005.
2006.
2007.
2008.
2009.
2010.
2011.
2012.
2013.
2014.
2015.
2016.
2017.
2018.
2019.
2020.
2021.
2022.
2023.
2024.
2025.
2026.
2027.
2028.
2029.
2030.
2031.
2032.
2033.
2034.
2035.
2036.
2037.
2038.
2039.
2040.
2041.
2042.
2043.
2044.
2045.
2046.
2047.
2048.
2049.
2050.
2051.
2052.
2053.
2054.
2055.
2056.
2057.
2058.
2059.
2060.
2061.
2062.
2063.
2064.
2065.
2066.
2067.
2068.
2069.
2070.
2071.
2072.
2073.
2074.
2075.
2076.
2077.
2078.
2079.
2080.
2081.
2082.
2083.
2084.
2085.
2086.
2087.
2088.
2089.
2090.
2091.
2092.
2093.
2094.
2095.
2096.
2097.
2098.
2099.
2100.
2101.
2102.
2103.
2104.
2105.
2106.
2107.
2108.
2109.
2110.
2111.
2112.
2113.
2114.
2115.
2116.
2117.
2118.
2119.
2120.
2121.
2122.
2123.
2124.
2125.
2126.
2127.
2128.
2129.
2130.
2131.
2132.
2133.
2134.
2135.
2136.
2137.
2138.
2139.
2140.
2141.
2142.
2143.
2144.
2145.
2146.
2147.
2148.
2149.
2150.
2151.
2152.
2153.
2154.
2155.
2156.
2157.
2158.
2159.
2160.
2161.
2162.
2163.
2164.
2165.
2166.
2167.
2168.
2169.
2170.
2171.
2172.
2173.
2174.
2175.
2176.
2177.
2178.
2179.
2180.
2181.
2182.
2183.
2184.
2185.
2186.
2187.
2188.
2189.
2190.
2191.
2192.
2193.
2194.
2195.
2196.
2197.
2198.
2199.
2200.
2201.
2202.
2203.
2204.
2205.
2206.
2207.
2208.
2209.
2210.
2211.
2212.
2213.
2214.
2215.
2216.
2217.
2218.
2219.
2220.
2221.
2222.
2223.
2224.
2225.
2226.
2227.
2228.
2229.
2230.
2231.
2232.
2233.
2234.
2235.
2236.
2237.
2238.
2239.
2240.
2241.
2242.
2243.
2244.
2245.
2246.
2247.
2248.
2249.
2250.
2251.
2252.
2253.
2254.
2255.
2256.
2257.
2258.
2259.
2260.
2261.
2262.
2263.
2264.
2265.
2266.
2267.
2268.
2269.
2270.
2271.
2272.
2273.
2274.
2275.
2276.
2277.
2278.
2279.
2280.
2281.
2282.
2283.
2284.
2285.
2286.
2287.
2288.
2289.
2290.
2291.
2292.
2293.
2294.
2295.
2296.
2297.
2298.
2299.
2300.
2301.
2302.
2303.
2304.
2305.
2306.
2307.
2308.
2309.
2310.
2311.
2312.
2313.
2314.
2315.
2316.
2317.
2318.
2319.
2320.
2321.
2322.
2323.
2324.
2325.
2326.
2327.
2328.
2329.
2330.
2331.
2332.
2333.
2334.
2335.
2336.
2337.
2338.
2339.
2340.
2341.
2342.
2343.
2344.
2345.
2346.
2347.
2348.
2349.
2350.
2351.
2352.
2353.
2354.
2355.
2356.
2357.
2358.
2359.
2360.
2361.
2362.
2363.
2364.
2365.
2366.
2367.
2368.
2369.
2370.
2371.
2372.
2373.
2374.
2375.
2376.
2377.
2378.
2379.
2380.
2381.
2382.
2383.
2384.
2385.
2386.
2387.
2388.
2389.
2390.
2391.
2392.
2393.
2394.
2395.
2396.
2397.
2398.
2399.
2400.
2401.
2402.
2403.
2404.
2405.
2406.
2407.
2408.
2409.
2410.
2411.
2412.
2413.
2414.
2415.
2416.
2417.
2418.
2419.
2420.
2421.
2422.
2423.
2424.
2425.
2426.
2427.
2428.
2429.
2430.
2431.
2432.
2433.
2434.
2435.
2436.
2437.
2438.
2439.
2440.
2441.
2442.
2443.
2444.
2445.
2446.
2447.
2448.
2449.
2450.
2451.
2452.
2453.
2454.
2455.
2456.
2457.
2458.
2459.
2460.
2461.
2462.
2463.
2464.
2465.
2466.
2467.
2468.
2469.
2470.
2471.
2472.
2473.
2474.
2475.
2476.
2477.
2478.
2479.
2480.
2481.
2482.
2483.
2484.
2485.
2486.
2487.
2488.
2489.
2490.
2491.
2492.
2493.
2494.
2495.
2496.
2497.
2498.
2499.
2500.
2501.
2502.
2503.
2504.
2505.
2506.
2507.
2508.
2509.
2510.
2511.
2512.
2513.
2514.
2515.
2516.
2517.
2518.
2519.
2520.
2521.
2522.
2523.
2524.
2525.
2526.
2527.
2528.
2529.
2530.
2531.
2532.
2533.
2534.
2535.
2536.
2537.
2538.
2539.
2540.
2541.
2542.
2543.
2544.
2545.
2546.
2547.
2548.
2549.
2550.
2551.
2552.
2553.
2554.
2555.
2556.
2557.
2558.
2559.
2560.
2561.
2562.
2563.
2564.
2565.
2566.
2567.
2568.
2569.
2570.
2571.
2572.
2573.
2574.
2575.
2576.
2577.
2578.
2579.
2580.
2581.
2582.
2583.
2584.
2585.
2586.
2587.
2588.
2589.
2590.
2591.
2592.
2593.
2594.
2595.
2596.
2597.
2598.
2599.
2600.
2601.
2602.
2603.
2604.
2605.
2606.
2607.
2608.
2609.
2610.
2611.
2612.
2613.
2614.
2615.
2616.
2617.
2618.
2619.
2620.
2621.
2622.
2623.
2624.
2625.
2626.
2627.
2628.
2629.
2630.
2631.
2632.
2633.
2634.
2635.
2636.
2637.
2638.
2639.
2640.
2641.
2642.
2643.
2644.
2645.
2646.
2647.
2648.
2649.
2650.
2651.
2652.
2653.
2654.
2655.
2656.
2657.
2658.
2659.
2660.
2661.
2662.
2663.
2664.
2665.
2666.
2667.
2668.
2669.
2670.
2671.
2672.
2673.
2674.
2675.
2676.
2677.
2678.
2679.
2680.
2681.
2682.
2683.
2684.
2685.
2686.
2687.
2688.
2689.
2690.
2691.
2692.
2693.
2694.
2695.
2696.
2697.
2698.
2699.
2700.
2701.
2702.
2703.
2704.
2705.
2706.
2707.
2708.
2709.
2710.
2711.
2712.
2713.
2714.
2715.
2716.
2717.
2718.
2719.
2720.
2721.
2722.
2723.
2724.
2725.
2726.
2727.
2728.
2729.
2730.
2731.
2732.
2733.
2734.
2735.
2736.
2737.
2738.
2739.
2740.
2741.
2742.
2743.
2744.
2745.
2746.
2747.
2748.
2749.
2750.
2751.
2752.
2753.
2754.
2755.
2756.
2757.
2758.
2759.
2760.
2761.
2762.
2763.
2764.
2765.
2766.
2767.
2768.
2769.
2770.
2771.
2772.
2773.
2774.
2775.
2776.
2777.
2778.
2779.
2780.
2781.
2782.
2783.
2784.
2785.
2786.
2787.
2788.
2789.
2790.
2791.
2792.
2793.
2794.
2795.
2796.
2797.
2798.
2799.
2800.
2801.
2802.
2803.
2804.
2805.
2806.
2807.
2808.
2809.
2810.
2811.
2812.
2813.
2814.
2815.
2816.
2817.
2818.
2819.
2820.
2821.
2822.
2823.
2824.
2825.
2826.
2827.
2828.
2829.
2830.
2831.
2832.
2833.
2834.
2835.
2836.
2837.
2838.
2839.
2840.
2841.
2842.
2843.
2844.
2845.
2846.
2847.
2848.
2849.
2850.
2851.
2852.
2853.
2854.
2855.
2856.
2857.
2858.
2859.
2860.
2861.
2862.
2863.
2864.
2865.
2866.
2867.
2868.
2869.
2870.
2871.
2872.
2873.
2874.
2875.
2876.
2877.
2878.
2879.
2880.
2881.
2882.
2883.
2884.
2885.
2886.
2887.
2888.
2889.
2890.
2891.
2892.
2893.
2894.
2895.
2896.
2897.
2898.
2899.
2900.
2901.
2902.
2903.
2904.
2905.
2906.
2907.
2908.
2909.
2910.
2911.
2912.
2913.
2914.
2915.
2916.
2917.
2918.
2919.
2920.
2921.
2922.
2923.
2924.
2925.
2926.
2927.
2928.
2929.
2930.
2931.
2932.
2933.
2934.
2935.
2936.
2937.
2938.
2939.
2940.
2941.
2942.
2943.
2944.
2945.
2946.
2947.
2948.
2949.
2950.
2951.
2952.
2953.
2954.
2955.
2956.
2957.
2958.
2959.
2960.
2961.
2962.
2963.
2964.
2965.
2966.
2967.
2968.
2969.
2970.
2971.
2972.
2973.
2974.
2975.
2976.
2977.
2978.
2979.
2980.
2981.
2982.
2983.
2984.
2985.
2986.
2987.
2988.
2989.
2990.
2991.
2992.
2993.
2994.
2995.
2996.
2997.
2998.
2999.
3000.
3001.
3002.
3003.
3004.
3005.
3006.
3007.
3008.
3009.
3010.
3011.
3012.
3013.
3014.
3015.
3016.
3017.
3018.
3019.
3020.
3021.
3022.
3023.
3024.
3025.
3026.
3027.
3028.
3029.
3030.
3031.
3032.
3033.
3034.
3035.
3036.
3037.
3038.
3039.
3040.
3041.
3042.
3043.
3044.
3045.
3046.
3047.
3048.
3049.
3050.
3051.
3052.
3053.
3054.
3055.
3056.
3057.
3058.
3059.
3060.
3061.
3062.
3063.
3064.
3065.
3066.
3067.
3068.
3069.
3070.
3071.
3072.
3073.
3074.
3075.
3076.
3077.
3078.
3079.
3080.
3081.
3082.
3083.
3084.
3085.
3086.
3087.
3088.
3089.
3090.
3091.
3092.
3093.
3094.
3095.
3096.
3097.
3098.
3099.
3100.
3101.
3102.
3103.
3104.
3105.
3106.
3107.
3108.
3109.
3110.
3111.
3112.
3113.
3114.
3115.
3116.
3117.
3118.
3119.
3120.
3121.
3122.
3123.
3124.
3125.
3126.
3127.
3128.
3129.
3130.
3131.
3132.
3133.
3134.
3135.
3136.
3137.
3138.
3139.
3140.
3141.
3142.
3143.
3144.
3145.
3146.
3147.
3148.
3149.
3150.
3151.
3152.
3153.
3154.
3155.
3156.
3157.
3158.
3159.
3160.
3161.
3162.
3163.
3164.
3165.
3166.
3167.
3168.
3169.
3170.
3171.
3172.
3173.
3174.
3175.
3176.
3177.
3178.
3179.
3180.
3181.
3182.
3183.
3184.
3185.
3186.
3187.
3188.
3189.
3190.
3191.
3192.
3193.
3194.
3195.
3196.
3197.
3198.
3199.
3200.
3201.
3202.
3203.
3204.
3205.
3206.
3207.
3208.
3209.
3210.
3211.
3212.
3213.
3214.
3215.
3216.
3217.
3218.
3219.
3220.
3221.
3222.
3223.
3224.
3225.
3226.
3227.
3228.
3229.
3230.
3231.
3232.
3233.
3234.
3235.
3236.
3237.
3238.
3239.
3240.
3241.
3242.
3243.
3244.
3245.
3246.
3247.
3248.
3249.
3250.
3251.
3252.
3253.
3254.
3255.
3256.
3257.
3258.
3259.
3260.
3261.
3262.
3263.
3264.
3265.
3266.
3267.
3268.
3269.
3270.
3271.
3272.
3273.
3274.
3275.
3276.
3277.
3278.
3279.
3280.
3281.
3282.
3283.
3284.
3285.
3286.
3287.
3288.
3289.
3290.
3291.
3292.
3293.
3294.
3295.
3296.
3297.
3298.
3299.
3300.
3301.
3302.
3303.
3304.
3305.
3306.
3307.
3308.
3309.
3310.
3311.
3312.
3313.
3314.
3315.
3316.
3317.
3318.
3319.
3320.
3321.
3322.
3323.
3324.
3325.
3326.
3327.
3328.
3329.
3330.
3331.
3332.
3333.
3334.
3335.
3336.
3337.
3338.
3339.
3340.
3341.
3342.
3343.
3344.
3345.
3346.
3347.
3348.
3349.
3350.
3351.
3352.
3353.
3354.
3355.
3356.
3357.
3358.
3359.
3360.
3361.
3362.
3363.
3364.
3365.
3366.
3367.
3368.
3369.
3370.
3371.
3372.
3373.
3374.
3375.
3376.
3377.
3378.
3379.
3380.
3381.
3382.
3383.
3384.
3385.
3386.
3387.
3388.
3389.
3390.
3391.
3392.
3393.
3394.
3395.
3396.
3397.
3398.
3399.
3400.
3401.
3402.
3403.
3404.
3405.
3406.
3407.
3408.
3409.
3410.
3411.
3412.
3413.
3414.
3415.
3416.
3417.
3418.
3419.
3420.
3421.
3422.
3423.
3424.
3425.
3426.
3427.
3428.
3429.
3430.
3431.
3432.
3433.
3434.
3435.
3436.
3437.
3438.
3439.
3440.
3441.
3442.
3443.
3444.
3445.
3446.
3447.
3448.
3449.
3450.
3451.
3452.
3453.
3454.
3455.
3456.
3457.
3458.
3459.
3460.
3461.
3462.
3463.
3464.
3465.
3466.
3467.
3468.
3469.
3470.
3471.
3472.
3473.
3474.
3475.
3476.
3477.
3478.
3479.
3480.
3481.
3482.
3483.
3484.
3485.
3486.
3487.
3488.
3489.
3490.
3491.
3492.
3493.
3494.
3495.
3496.
3497.
3498.
3499.
3500.
3501.
3502.
3503.
3504.
3505.
3506.
3507.
3508.
3509.
3510.
3511.
3512.
3513.
3514.
3515.
3516.
3517.
3518.
3519.
3520.
3521.
3522.
3523.
3524.
3525.
3526.
3527.
3528.
3529.
3530.
3531.
3532.
3533.
3534.
3535.
3536.
3537.
3538.
3539.
3540.
3541.
3542.
3543.
3544.
3545.
3546.
3547.
3548.
3549.
3550.
3551.
3552.
3553.
3554.
3555.
3556.
3557.
3558.
3559.
3560.
3561.
3562.
3563.
3564.
3565.
3566.
3567.
3568.
3569.
3570.
3571.
3572.
3573.
3574.
3575.
3576.
3577.
3578.
3579.
3580.
3581.
3582.
3583.
3584.
3585.
3586.
3587.
3588.
3589.
3590.
3591.
3592.
3593.
3594.
3595.
3596.
3597.
3598.
3599.
3600.
3601.
3602.
3603.
3604.
3605.
3606.
3607.
3608.
3609.
3610.
3611.
3612.
3613.
3614.
3615.
3616.
3617.
3618.
3619.
3620.
3621.
3622.
3623.
3624.
3625.
3626.
3627.
3628.
3629.
3630.
3631.
3632.
3633.
3634.
3635.
3636.
3637.
3638.
3639.
3640.
3641.
3642.
3643.
3644.
3645.
3646.
3647.
3648.
3649.
3650.
3651.
3652.
3653.
3654.
3655.
3656.
3657.
3658.
3659.
3660.
3661.
3662.
3663.
3664.
3665.
3666.
3667.
3668.
3669.
3670.
3671.
3672.
3673.
3674.
3675.
3676.
3677.
3678.
3679.
3680.
3681.
3682.
3683.
3684.
3685.
3686.
3687.
3688.
3689.
3690.
3691.
3692.
3693.
3694.
3695.
3696.
3697.
3698.
3699.
3700.
3701.
3702.
3703.
3704.
3705.
3706.
3707.
3708.
3709.
3710.
3711.
3712.
3713.
3714.
3715.
3716.
3717.
3718.
3719.
3720.
3721.
3722.
3723.
3724.
3725.
3726.
3727.
3728.
3729.
3730.
3731.
3732.
3733.
3734.
3735.
3736.
3737.
3738.
3739.
3740.
3741.
3742.
3743.
3744.
3745.
3746.
3747.
3748.
3749.
3750.
3751.
3752.
3753.
3754.
3755.
3756.
3757.
3758.
3759.
3760.
3761.
3762.
3763.
3764.
3765.
3766.
3767.
3768.
3769.
3770.
3771.
3772.
3773.
3774.
3775.
3776.
3777.
3778.
3779.
3780.
3781.
3782.
3783.
3784.
3785.
3786.
3787.
3788.
3789.
3790.
3791.
3792.
3793.
3794.
3795.
3796.
3797.
3798.
3799.
3800.
3801.
3802.
3803.
3804.
3805.
3806.
3807.
3808.
3809.
3810.
3811.
3812.
3813.
3814.
3815.
3816.
3817.
3818.
3819.
3820.
3821.
3822.
3823.
3824.
3825.
3826.
3827.
3828.
3829.
3830.
3831.
3832.
3833.
3834.
3835.
3836.
3837.
3838.
3839.
3840.
3841.
3842.
3843.
3844.
3845.
3846.
3847.
3848.
3849.
3850.
3851.
3852.
3853.
3854.
3855.
3856.
3857.
3858.
3859.
3860.
3861.
3862.
3863.
3864.
3865.
3866.
3867.
3868.
3869.
3870.
3871.
3872.
3873.
3874.
3875.
3876.
3877.
3878.
3879.
3880.
3881.
3882.
3883.
3884.
3885.
3886.
3887.
3888.
3889.
3890.
3891.
3892.
3893.
3894.
3895.
3896.
3897.
3898.
3899.
3900.
3901.
3902.
3903.
3904.
3905.
3906.
3907.
3908.
3909.
3910.
3911.
3912.
3913.
3914.
3915.
3916.
3917.
3918.
3919.
3920.
3921.
3922.
3923.
3924.
3925.
3926.
3927.
3928.
3929.
3930.
3931.
3932.
3933.
3934.
3935.
3936.
3937.
3938.
3939.
3940.
3941.
3942.
3943.
3944.
3945.
3946.
3947.
3948.
3949.
3950.
3951.
3952.
3953.
3954.
3955.
3956.
3957.
3958.
3959.
3960.
3961.
3962.
3963.
3964.
3965.
3966.
3967.
3968.
3969.
3970.
3971.
3972.
3973.
3974.
3975.
3976.
3977.
3978.
3979.
3980.
3981.
3982.
3983.
3984.
3985.
3986.
3987.
3988.
3989.
3990.
3991.
3992.
3993.
3994.
3995.
3996.
3997.
3998.
3999.
4000.
4001.
4002.
4003.
4004.
4005.
4006.
4007.
4008.
4009.
4010.
4011.
4012.
4013.
4014.
4015.
4016.
4017.
4018.
4019.
4020.
4021.
4022.
4023.
4024.
4025.
4026.
4027.
4028.
4029.
4030.
4031.
4032.
4033.
4034.
4035.
4036.
4037.
4038.
4039.
4040.
4041.
4042.
4043.
4044.
4045.
4046.
4047.
4048.
4049.
4050.
4051.
4052.
4053.
4054.
4055.
4056.
4057.
4058.
4059.
4060.
4061.
4062.
4063.
4064.
4065.
4066.
4067.
4068.
4069.
4070.
4071.
4072.
4073.
4074.
4075.
4076.
4077.
4078.
4079.
4080.
4081.
4082.
4083.
4084.
4085.
4086.
4087.
4088.
4089.
4090.
4091.
4092.
4093.
4094.
4095.
4096.
4097.
4098.
4099.
4100.
4101.
4102.
4103.
4104.
4105.
4106.
4107.
4108.
4109.
4110.
4111.
4112.
4113.
4114.
4115.
4116.
4117.
4118.
4119.
4120.
4121.
4122.
4123.
4124.
4125.
4126.
4127.
4128.
4129.
4130.
4131.
4132.
4133.
4134.
4135.
4136.
4137.
4138.
4139.
4140.
4141.
4142.
4143.
4144.
4145.
4146.
4147.
4148.
4149.
4150.
4151.
4152.
4153.
4154.
4155.
4156.
4157.
4158.
4159.
4160.
4161.
4162.
4163.
4164.
4165.
4166.
4167.
4168.
4169.
4170.
4171.
4172.
4173.
4174.
4175.
4176.
4177.
4178.
4179.
4180.
4181.
4182.
4183.
4184.
4185.
4186.
4187.
4188.
4189.
4190.
4191.
4192.
4193.
4194.
4195.
4196.
4197.
4198.
4199.
4200.
4201.
4202.
4203.
4204.
4205.
4206.
4207.
4208.
4209.
4210.
4211.
4212.
4213.
4214.
4215.
4216.
4217.
4218.
4219.
4220.
4221.
4222.
4223.
4224.
4225.
4226.
4227.
4228.
4229.
4230.
4231.
4232.
4233.
4234.
4235.
4236.
4237.
4238.
4239.
4240.
4241.
4242.
4243.
4244.
4245.
4246.
4247.
4248.
4249.
4250.
4251.
4252.
4253.
4254.
4255.
4256.
4257.
4258.
4259.
4260.
4261.
4262.
4263.
4264.
4265.
4266.
4267.
4268.
4269.
4270.
4271.
4272.
4273.
4274.
4275.
4276.
4277.
4278.
4279.
4280.
4281.
4282.
4283.
4284.
4285.
4286.
4287.
4288.
4289.
4290.
4291.
4292.
4293.
4294.
4295.
4296.
4297.
4298.
4299.
4300.
4301.
4302.
4303.
4304.
4305.
4306.
4307.
4308.
4309.
4310.
4311.
4312.
4313.
4314.
4315.
4316.
4317.
4318.
4319.
4320.
4321.
4322.
4323.
4324.
4325.
4326.
4327.
4328.
4329.
4330.
4331.
4332.
4333.
4334.
4335.
4336.
4337.
4338.
4339.
4340.
4341.
4342.
4343.
4344.
4345.
4346.
4347.
4348.
4349.
4350.
4351.
4352.
4353.
4354.
4355.
4356.
4357.
4358.
4359.
4360.
4361.
4362.
4363.
4364.
4365.
4366.
4367.
4368.
4369.
4370.
4371.
4372.
4373.
4374.
4375.
4376.
4377.
4378.
4379.
4380.
4381.
4382.
4383.
4384.
4385.
4386.
4387.
4388.
4389.
4390.
4391.
4392.
4393.
4394.
4395.
4396.
4397.
4398.
4399.
4400.
4401.
4402.
4403.
4404.
4405.
4406.
4407.
4408.
4409.
4410.
4411.
4412.
4413.
4414.
4415.
4416.
4417.
4418.
4419.
4420.
4421.
4422.
4423.
4424.
4425.
4426.
4427.
4428.
4429.
4430.
4431.
4432.
4433.
4434.
4435.
4436.
4437.
4438.
4439.
4440.
4441.
4442.
4443.
4444.
4445.
4446.
4447.
4448.
4449.
4450.
4451.
4452.
4453.
4454.
4455.
4456.
4457.
4458.
4459.
4460.
4461.
4462.
4463.
4464.
4465.
4466.
4467.
4468.
4469.
4470.
4471.
4472.
4473.
4474.
4475.
4476.
4477.
4478.
4479.
4480.
4481.
4482.
4483.
4484.
4485.
4486.
4487.
4488.
4489.
4490.
4491.
4492.
4493.
4494.
4495.
4496.
4497.
4498.
4499.
4500.
4501.
4502.
4503.
4504.
4505.
4506.
4507.
4508.
4509.
4510.
4511.
4512.
4513.
4514.
4515.
4516.
4517.
4518.
4519.
4520.
4521.
4522.
4523.
4524.
4525.
4526.
4527.
4528.
4529.
4530.
4531.
4532.
4533.
4534.
4535.
4536.
4537.
4538.
4539.
4540.
4541.
4542.
4543.
4544.
4545.
4546.
4547.
4548.
4549.
4550.
4551.
4552.
4553.
4554.
4555.
4556.
4557.
4558.
4559.
4560.
4561.
4562.
4563.
4564.
4565.
4566.
4567.
4568.
4569.
4570.
4571.
4572.
4573.
4574.
4575.
4576.
4577.
4578.
4579.
4580.
4581.
4582.
4583.
4584.
4585.
4586.
4587.
4588.
4589.
4590.
4591.
4592.
4593.
4594.
4595.
4596.
4597.
4598.
4599.
4600.
4601.
4602.
4603.
4604.
4605.
4606.
4607.
4608.
4609.
4610.
4611.
4612.
4613.
4614.
4615.
4616.
4617.
4618.
4619.
4620.
4621.
4622.
4623.
4624.
4625.
4626.
4627.
4628.
4629.
4630.
4631.
4632.
4633.
4634.
4635.
4636.
4637.
4638.
4639.
4640.
4641.
4642.
4643.
4644.
4645.
4646.
4647.
4648.
4649.
4650.
4651.
4652.
4653.
4654.
4655.
4656.
4657.
4658.
4659.
4660.
4661.
4662.
4663.
4664.
4665.
4666.
4667.
4668.
4669.
4670.
4671.
4672.
4673.
4674.
4675.
4676.
4677.
4678.
4679.
4680.
4681.
4682.
4683.
4684.
4685.
4686.
4687.
4688.
4689.
4690.
4691.
4692.
4693.
4694.
4695.
4696.
4697.
4698.
4699.
4700.
4701.
4702.
4703.
4704.
4705.
4706.
4707.
4708.
4709.
4710.
4711.
4712.
4713.
4714.
4715.
4716.
4717.
4718.
4719.
4720.
4721.
4722.
4723.
4724.
4725.
4726.
4727.
4728.
4729.
4730.
4731.
4732.
4733.
4734.
4735.
4736.
4737.
4738.
4739.
4740.
4741.
4742.
4743.
4744.
4745.
4746.
4747.
4748.
4749.
4750.
4751.
4752.
4753.
4754.
4755.
4756.
4757.
4758.
4759.
4760.
4761.
4762.
4763.
4764.
4765.
4766.
4767.
4768.
4769.
4770.
4771.
4772.
4773.
4774.
4775.
4776.
4777.
4778.
4779.
4780.
4781.
4782.
4783.
4784.
4785.
4786.
4787.
4788.
4789.
4790.
4791.
4792.
4793.
4794.
4795.
4796.
4797.
4798.
4799.
4800.
4801.
4802.
4803.
4804.
4805.
4806.
4807.
4808.
4809.
4810.
4811.
4812.
4813.
4814.
4815.
4816.
4817.
4818.
4819.
4820.
4821.
4822.
4823.
4824.
4825.
4826.
4827.
4828.
4829.
4830.
4831.
4832.
4833.
4834.
4835.
4836.
4837.
4838.
4839.
4840.
4841.
4842.
4843.
4844.
4845.
4846.
4847.
4848.
4849.
4850.
4851.
4852.
4853.
4854.
4855.
4856.
4857.
4858.
4859.
4860.
4861.
4862.
4863.
4864.
4865.
4866.
4867.
4868.
4869.
4870.
4871.
4872.
4873.
4874.
4875.
4876.
4877.
4878.
4879.
4880.
4881.
4882.
4883.
4884.
4885.
4886.
4887.
4888.
4889.
4890.
4891.
4892.
4893.
4894.
4895.
4896.
4897.
4898.
4899.
4900.
4901.
4902.
4903.
4904.
4905.
4906.
4907.
4908.
4909.
4910.
4911.
4912.
4913.
4914.
4915.
4916.
4917.
4918.
4919.
4920.
4921.
4922.
4923.
4924.
4925.
4926.
4927.
4928.
4929.
4930.
4931.
4932.
4933.
4934.
4935.
4936.
4937.
4938.
4939.
4940.
4941.
4942.
4943.
4944.
4945.
4946.
4947.
4948.
4949.
4950.
4951.
4952.
4953.
4954.
4955.
4956.
4957.
4958.
4959.
4960.
4961.
4962.
4963.
4964.
4965.
4966.
4967.
4968.
4969.
4970.
4971.
4972.
4973.
4974.
4975.
4976.
4977.
4978.
4979.
4980.
4981.
4982.
4983.
4984.
4985.
4986.
4987.
4988.
4989.
4990.
4991.
4992.
4993.
4994.
4995.
4996.
4997.
4998.
4999.
5000.
5001.
5002.
5003.
5004.
5005.
5006.
5007.
5008.
5009.
5010.
5011.
5012.
5013.
5014.
5015.
5016.
5017.
5018.
5019.
5020.
5021.
5022.
5023.
5024.
5025.
5026.
5027.
5028.
5029.
5030.
5031.
5032.
5033.
5034.
5035.
5036.
5037.
5038.
5039.
5040.
5041.
5042.
5043.
5044.
5045.
5046.
5047.
5048.
5049.
5050.
5051.
5052.
5053.
5054.
5055.
5056.
5057.
5058.
5059.
5060.
5061.
5062.
5063.
5064.
5065.
5066.
5067.
5068.
5069.
5070.
5071.
5072.
5073.
5074.
5075.
5076.
5077.
5078.
5079.
5080.
5081.
5082.
5083.
5084.
5085.
5086.
5087.
5088.
5089.
5090.
5091.
5092.
5093.
5094.
5095.
5096.
5097.
5098.
5099.
5100.
5101.
5102.
5103.
5104.
5105.
5106.
5107.
5108.
5109.
5110.
5111.
5112.
5113.
5114.
5115.
5116.
5117.
5118.
5119.
5120.
5121.
5122.
5123.
5124.
5125.
5126.
5127.
5128.
5129.
5130.
5131.
5132.
5133.
5134.
5135.
5136.
5137.
5138.
5139.
5140.
5141.
5142.
5143.
5144.
5145.
5146.
5147.
5148.
5149.
5150.
5151.
5152.
5153.
5154.
5155.
5156.
5157.
5158.
5159.
5160.
5161.
5162.
5163.
5164.
5165.
5166.
5167.
5168.
5169.
5170.
5171.
5172.
5173.
5174.
5175.
5176.
5177.
5178.
5179.
5180.
5181.
5182.
5183.
5184.
5185.
5186.
5187.
5188.
5189.
5190.
5191.
5192.
5193.
5194.
5195.
5196.
5197.
5198.
5199.
5200.
5201.
5202.
5203.
5204.
5205.
5206.
5207.
5208.
5209.
5210.
5211.
5212.
5213.
5214.
5215.
5216.
5217.
5218.
5219.
5220.
5221.
5222.
5223.
5224.
5225.
5226.
5227.
5228.
5229.
5230.
5231.
5232.
5233.
5234.
5235.
5236.
5237.
5238.
5239.
5240.
5241.
5242.
5243.
5244.
5245.
5246.
5247.
5248.
5249.
5250.
5251.
5252.
5253.
5254.
5255.
5256.
5257.
5258.
5259.
5260.
5261.
5262.
5263.
5264.
5265.
5266.
5267.
5268.
5269.
5270.
5271.
5272.
5273.
5274.
5275.
5276.
5277.
5278.
5279.
5280.
5281.
5282.
5283.
5284.
5285.
5286.
5287.
5288.
5289.
5290.
5291.
5292.
5293.
5294.
5295.
5296.
5297.
5298.
5299.
5300.
5301.
5302.
5303.
5304.
5305.
5306.
5307.
5308.
5309.
5310.
5311.
5312.
5313.
5314.
5315.
5316.
5317.
5318.
5319.
5320.
5321.
5322.
5323.
5324.
5325.
5326.
5327.
5328.
5329.
5330.
5331.
5332.
5333.
5334.
5335.
5336.
5337.
5338.
5339.
5340.
5341.
5342.
5343.
5344.
5345.
5346.
5347.
5348.
5349.
5350.
5351.
5352.
5353.
5354.
5355.
5356.
5357.
5358.
5359.
5360.
5361.
5362.
5363.
5364.
5365.
5366.
5367.
5368.
5369.
5370.
5371.
5372.
5373.
5374.
5375.
5376.
5377.
5378.
5379.
5380.
5381.
5382.
5383.
5384.
5385.
5386.
5387.
5388.
5389.
5390.
5391.
5392.
5393.
5394.
5395.
5396.
5397.
5398.
5399.
5400.
5401.
5402.
5403.
5404.
5405.
5406.
5407.
5408.
5409.
5410.
5411.
5412.
5413.
5414.
5415.
5416.
5417.
5418.
5419.
5420.
5421.
5422.
5423.
5424.
5425.
5426.
5427.
5428.
5429.
5430.
5431.
5432.
5433.
5434.
5435.
5436.
5437.
5438.
5439.
5440.
5441.
5442.
5443.
5444.
5445.
5446.
5447.
5448.
5449.
5450.
5451.
5452.
5453.
5454.
5455.
5456.
5457.
5458.
5459.
5460.
5461.
5462.
5463.
5464.
5465.
5466.
5467.
5468.
5469.
5470.
5471.
5472.
5473.
5474.
5475.
5476.
5477.
5478.
5479.
5480.
5481.
5482.
5483.
5484.
5485.
5486.
5487.
5488.
5489.
5490.
5491.
5492.
5493.
5494.
5495.
5496.
5497.
5498.
5499.
5500.
5501.
5502.
5503.
5504.
5505.
5506.
5507.
5508.
5509.
5510.
5511.
5512.
5513.
5514.
5515.
5516.
5517.
5518.
5519.
5520.
5521.
5522.
5523.
5524.
5525.
5526.
5527.
5528.
5529.
5530.
5531.
5532.
5533.
5534.
5535.
5536.
5537.
5538.
5539.
5540.
5541.
5542.
5543.
5544.
5545.
5546.
5547.
5548.
5549.
5550.
5551.
5552.
5553.
5554.
5555.
5556.
5557.
5558.
5559.
5560.
5561.
5562.
5563.
5564.
5565.
5566.
5567.
5568.
5569.
5570.
5571.
5572.
5573.
5574.
5575.
5576.
5577.
5578.
5579.
5580.
5581.
5582.
5583.
5584.
5585.
5586.
5587.
5588.
5589.
5590.
5591.
5592.
5593.
5594.
5595.
5596.
5597.
5598.
5599.
5600.
5601.
5602.
5603.
5604.
5605.
5606.
5607.
5608.
5609.
5610.
5611.
5612.
5613.
5614.
5615.
5616.
5617.
5618.
5619.
5620.
5621.
5622.
5623.
5624.
5625.
5626.
5627.
5628.
5629.
5630.
5631.
5632.
5633.
5634.
5635.
5636.
5637.
5638.
5639.
5640.
5641.
5642.
5643.
5644.
5645.
5646.
5647.
5648.
5649.
5650.
5651.
5652.
5653.
5654.
5655.
5656.
5657.
5658.
5659.
5660.
5661.
5662.
5663.
5664.
5665.
5666.
5667.
5668.
5669.
5670.
5671.
5672.
5673.
5674.
5675.
5676.
5677.
5678.
5679.
5680.
5681.
5682.
5683.
5684.
5685.
5686.
5687.
5688.
5689.
5690.
5691.
5692.
5693.
5694.
5695.
5696.
5697.
5698.
5699.
5700.
5701.
5702.
5703.
5704.
5705.
5706.
5707.
5708.
5709.
5710.
5711.
5712.
5713.
5714.
5715.
5716.
5717.
5718.
5719.
5720.
5721.
5722.
5723.
5724.
5725.
5726.
5727.
5728.
5729.
5730.
5731.
5732.
5733.
5734.
5735.
5736.
5737.
5738.
5739.
5740.
5741.
5742.
5743.
5744.
5745.
5746.
5747.
5748.
5749.
5750.
5751.
5752.
5753.
5754.
5755.
5756.
5757.
5758.
5759.
5760.
5761.
5762.
5763.
5764.
5765.
5766.
5767.
5768.
5769.
5770.
5771.
5772.
5773.
5774.
5775.
5776.
5777.
5778.
5779.
5780.
5781.
5782.
5783.
5784.
5785.
5786.
5787.
5788.
5789.
5790.
5791.
5792.
5793.
5794.
5795.
5796.
5797.
5798.
5799.
5800.
5801.
5802.
5803.
5804.
5805.
5806.
5807.
5808.
5809.
5810.
5811.
5812.
5813.
5814.
5815.
5816.
5817.
5818.
5819.
5820.
5821.
5822.
5823.
5824.
5825.
5826.
5827.
5828.
5829.
5830.
5831.
5832.
5833.
5834.
5835.
5836.
5837.
5838.
5839.
5840.
5841.
5842.
5843.
5844.
5845.
5846.
5847.
5848.
5849.
5850.
5851.
5852.
5853.
5854.
5855.
5856.
5857.
5858.
5859.
5860.
5861.
5862.
5863.
5864.
5865.
5866.
5867.
5868.
5869.
5870.
5871.
5872.
5873.
5874.
5875.
5876.
5877.
5878.
5879.
5880.
5881.
5882.
5883.
5884.
5885.
5886.
5887.
5888.
5889.
5890.
5891.
5892.
5893.
5894.
5895.
5896.
5897.
5898.
5899.
5900.
5901.
5902.
5903.
5904.
5905.
5906.
5907.
5908.
5909.
5910.
5911.
5912.
5913.
5914.
5915.
5916.
5917.
5918.
5919.
5920.
5921.
5922.
5923.
5924.
5925.
5926.
5927.
5928.
5929.
5930.
5931.
5932.
5933.
5934.
5935.
5936.
5937.
5938.
5939.
5940.
5941.
5942.
5943.
5944.
5945.
5946.
5947.
5948.
5949.
5950.
5951.
5952.
5953.
5954.
5955.
5956.
5957.
5958.
5959.
5960.
5961.
5962.
5963.
5964.
5965.
5966.
5967.
5968.
5969.
5970.
5971.
5972.
5973.
5974.
5975.
5976.
5977.
5978.
5979.
5980.
5981.
5982.
5983.
5984.
5985.
5986.
5987.
5988.
5989.
5990.
5991.
5992.
5993.
5994.
5995.
5996.
5997.
5998.
5999.
6000.
6001.
6002.
6003.
6004.
6005.
6006.
6007.
6008.
6009.
6010.
6011.
6012.
6013.
6014.
6015.
6016.
6017.
6018.
6019.
6020.
6021.
6022.
6023.
6024.
6025.
6026.
6027.
6028.
6029.
6030.
6031.
6032.
6033.
6034.
6035.
6036.
6037.
6038.
6039.
6040.
6041.
6042.
6043.
6044.
6045.
6046.
6047.
6048.
6049.
6050.
6051.
6052.
6053.
6054.
6055.
6056.
6057.
6058.
6059.
6060.
6061.
6062.
6063.
6064.
6065.
6066.
6067.
6068.
6069.
6070.
6071.
6072.
6073.
6074.
6075.
6076.
6077.
6078.
6079.
6080.
6081.
6082.
6083.
6084.
6085.
6086.
6087.
6088.
6089.
6090.
6091.
6092.
6093.
6094.
6095.
6096.
6097.
6098.
6099.
6100.
6101.
6102.
</code_line></pre></td>
<td class='lines'><pre><code class="prettyprint">// SPDX-License-Identifier: GPL-2.0-only
/*
 * Kernel-based Virtual Machine driver for Linux
 *
 * This module enables machines with Intel VT-x extensions to run virtual
 * machines without emulation or binary translation.
 *
 * Copyright (C) 2006 Qumranet, Inc.
 * Copyright 2010 Red Hat, Inc. and/or its affiliates.
 *
 * Authors:
 *   Avi Kivity   &lt;avi@qumranet.com&gt;
 *   Yaniv Kamay  &lt;yaniv@qumranet.com&gt;
 */

#include &lt;kvm/iodev.h&gt;

#include &lt;linux/kvm_host.h&gt;
#include &lt;linux/kvm.h&gt;
#include &lt;linux/module.h&gt;
#include &lt;linux/errno.h&gt;
#include &lt;linux/percpu.h&gt;
#include &lt;linux/mm.h&gt;
#include &lt;linux/miscdevice.h&gt;
#include &lt;linux/vmalloc.h&gt;
#include &lt;linux/reboot.h&gt;
#include &lt;linux/debugfs.h&gt;
#include &lt;linux/highmem.h&gt;
#include &lt;linux/file.h&gt;
#include &lt;linux/syscore_ops.h&gt;
#include &lt;linux/cpu.h&gt;
#include &lt;linux/sched/signal.h&gt;
#include &lt;linux/sched/mm.h&gt;
#include &lt;linux/sched/stat.h&gt;
#include &lt;linux/cpumask.h&gt;
#include &lt;linux/smp.h&gt;
#include &lt;linux/anon_inodes.h&gt;
#include &lt;linux/profile.h&gt;
#include &lt;linux/kvm_para.h&gt;
#include &lt;linux/pagemap.h&gt;
#include &lt;linux/mman.h&gt;
#include &lt;linux/swap.h&gt;
#include &lt;linux/bitops.h&gt;
#include &lt;linux/spinlock.h&gt;
#include &lt;linux/compat.h&gt;
#include &lt;linux/srcu.h&gt;
#include &lt;linux/hugetlb.h&gt;
#include &lt;linux/slab.h&gt;
#include &lt;linux/sort.h&gt;
#include &lt;linux/bsearch.h&gt;
#include &lt;linux/io.h&gt;
#include &lt;linux/lockdep.h&gt;
#include &lt;linux/kthread.h&gt;
#include &lt;linux/suspend.h&gt;

#include &lt;asm/processor.h&gt;
#include &lt;asm/ioctl.h&gt;
#include &lt;linux/uaccess.h&gt;

#include &quot;coalesced_mmio.h&quot;
#include &quot;async_pf.h&quot;
#include &quot;kvm_mm.h&quot;
#include &quot;vfio.h&quot;

#define CREATE_TRACE_POINTS
#include &lt;trace/events/kvm.h&gt;

#include &lt;linux/kvm_dirty_ring.h&gt;

/* Worst case buffer size needed for holding an integer. */
#define ITOA_MAX_LEN 12

MODULE_AUTHOR(&quot;Qumranet&quot;);
MODULE_LICENSE(&quot;GPL&quot;);

/* Architectures should define their poll value according to the halt latency */
unsigned int halt_poll_ns = KVM_HALT_POLL_NS_DEFAULT;
module_param(halt_poll_ns, uint, 0644);
EXPORT_SYMBOL_GPL(halt_poll_ns);

/* Default doubles per-vcpu halt_poll_ns. */
unsigned int halt_poll_ns_grow = 2;
module_param(halt_poll_ns_grow, uint, 0644);
EXPORT_SYMBOL_GPL(halt_poll_ns_grow);

/* The start value to grow halt_poll_ns from */
unsigned int halt_poll_ns_grow_start = 10000; /* 10us */
module_param(halt_poll_ns_grow_start, uint, 0644);
EXPORT_SYMBOL_GPL(halt_poll_ns_grow_start);

/* Default resets per-vcpu halt_poll_ns . */
unsigned int halt_poll_ns_shrink;
module_param(halt_poll_ns_shrink, uint, 0644);
EXPORT_SYMBOL_GPL(halt_poll_ns_shrink);

/*
 * Ordering of locks:
 *
 *	kvm-&gt;lock --&gt; kvm-&gt;slots_lock --&gt; kvm-&gt;irq_lock
 */

DEFINE_MUTEX(kvm_lock);
static DEFINE_RAW_SPINLOCK(kvm_count_lock);
LIST_HEAD(vm_list);

static cpumask_var_t cpus_hardware_enabled;
static int kvm_usage_count;
static atomic_t hardware_enable_failed;

static struct kmem_cache *kvm_vcpu_cache;

static __read_mostly struct preempt_ops kvm_preempt_ops;
static DEFINE_PER_CPU(struct kvm_vcpu *, kvm_running_vcpu);

struct dentry *kvm_debugfs_dir;
EXPORT_SYMBOL_GPL(kvm_debugfs_dir);

static const struct file_operations stat_fops_per_vm;

static struct file_operations kvm_chardev_ops;

static long kvm_vcpu_ioctl(struct file *file, unsigned int ioctl,
			   unsigned long arg);
#ifdef CONFIG_KVM_COMPAT
static long kvm_vcpu_compat_ioctl(struct file *file, unsigned int ioctl,
				  unsigned long arg);
#define KVM_COMPAT(c)	.compat_ioctl	= (c)
#else
/*
 * For architectures that don&#x27;t implement a compat infrastructure,
 * adopt a double line of defense:
 * - Prevent a compat task from opening /dev/kvm
 * - If the open has been done by a 64bit task, and the KVM fd
 *   passed to a compat task, let the ioctls fail.
 */
static long kvm_no_compat_ioctl(struct file *file, unsigned int ioctl,
				unsigned long arg) { return -EINVAL; }

static int kvm_no_compat_open(struct inode *inode, struct file *file)
{
	return is_compat_task() ? -ENODEV : 0;
}
#define KVM_COMPAT(c)	.compat_ioctl	= kvm_no_compat_ioctl,	\
			.open		= kvm_no_compat_open
#endif
static int hardware_enable_all(void);
static void hardware_disable_all(void);

static void kvm_io_bus_destroy(struct kvm_io_bus *bus);

__visible bool kvm_rebooting;
EXPORT_SYMBOL_GPL(kvm_rebooting);

#define KVM_EVENT_CREATE_VM 0
#define KVM_EVENT_DESTROY_VM 1
static void kvm_uevent_notify_change(unsigned int type, struct kvm *kvm);
static unsigned long long kvm_createvm_count;
static unsigned long long kvm_active_vms;

static DEFINE_PER_CPU(cpumask_var_t, cpu_kick_mask);

__weak void kvm_arch_mmu_notifier_invalidate_range(struct kvm *kvm,
						   unsigned long start, unsigned long end)
{
<yellow>}</yellow>

__weak void kvm_arch_guest_memory_reclaimed(struct kvm *kvm)
{
}

bool kvm_is_zone_device_page(struct page *page)
{
	/*
	 * The metadata used by is_zone_device_page() to determine whether or
	 * not a page is ZONE_DEVICE is guaranteed to be valid if and only if
	 * the device has been pinned, e.g. by get_user_pages().  WARN if the
	 * page_count() is zero to help detect bad usage of this helper.
	 */
<yellow>	if (WARN_ON_ONCE(!page_count(page)))</yellow>
		return false;

<yellow>	return is_zone_device_page(page);</yellow>
<yellow>}</yellow>

/*
 * Returns a &#x27;struct page&#x27; if the pfn is &quot;valid&quot; and backed by a refcounted
 * page, NULL otherwise.  Note, the list of refcounted PG_reserved page types
 * is likely incomplete, it has been compiled purely through people wanting to
 * back guest with a certain type of memory and encountering issues.
 */
struct page *kvm_pfn_to_refcounted_page(kvm_pfn_t pfn)
{
	struct page *page;

<blue>	if (!pfn_valid(pfn))</blue>
		return NULL;

<blue>	page = pfn_to_page(pfn);</blue>
	if (!PageReserved(page))
		return page;

	/* The ZERO_PAGE(s) is marked PG_reserved, but is refcounted. */
<blue>	if (is_zero_pfn(pfn))</blue>
		return page;

	/*
	 * ZONE_DEVICE pages currently set PG_reserved, but from a refcounting
	 * perspective they are &quot;normal&quot; pages, albeit with slightly different
	 * usage rules.
	 */
<yellow>	if (kvm_is_zone_device_page(page))</yellow>
		return page;

	return NULL;
<blue>}</blue>

/*
 * Switches to specified vcpu, until a matching vcpu_put()
 */
void vcpu_load(struct kvm_vcpu *vcpu)
{
<blue>	int cpu = get_cpu();</blue>

	__this_cpu_write(kvm_running_vcpu, vcpu);
	preempt_notifier_register(&amp;vcpu-&gt;preempt_notifier);
	kvm_arch_vcpu_load(vcpu, cpu);
<blue>	put_cpu();</blue>
<blue>}</blue>
EXPORT_SYMBOL_GPL(vcpu_load);

void vcpu_put(struct kvm_vcpu *vcpu)
{
<blue>	preempt_disable();</blue>
	kvm_arch_vcpu_put(vcpu);
	preempt_notifier_unregister(&amp;vcpu-&gt;preempt_notifier);
	__this_cpu_write(kvm_running_vcpu, NULL);
<blue>	preempt_enable();</blue>
<blue>}</blue>
EXPORT_SYMBOL_GPL(vcpu_put);

/* TODO: merge with kvm_arch_vcpu_should_kick */
static bool kvm_request_needs_ipi(struct kvm_vcpu *vcpu, unsigned req)
{
<blue>	int mode = kvm_vcpu_exiting_guest_mode(vcpu);</blue>

	/*
	 * We need to wait for the VCPU to reenable interrupts and get out of
	 * READING_SHADOW_PAGE_TABLES mode.
	 */
	if (req &amp; KVM_REQUEST_WAIT)
		return mode != OUTSIDE_GUEST_MODE;

	/*
	 * Need to kick a running VCPU, but otherwise there is nothing to do.
	 */
	return mode == IN_GUEST_MODE;
}

static void ack_kick(void *_completed)
{
<yellow>}</yellow>

<yellow>static inline bool kvm_kick_many_cpus(struct cpumask *cpus, bool wait)</yellow>
{
<blue>	if (cpumask_empty(cpus))</blue>
		return false;

<yellow>	smp_call_function_many(cpus, ack_kick, NULL, wait);</yellow>
	return true;
}

static void kvm_make_vcpu_request(struct kvm_vcpu *vcpu, unsigned int req,
				  struct cpumask *tmp, int current_cpu)
{
	int cpu;

<blue>	if (likely(!(req & KVM_REQUEST_NO_ACTION)))</blue>
<blue>		__kvm_make_request(req, vcpu);</blue>

<blue>	if (!(req & KVM_REQUEST_NO_WAKEUP) && kvm_vcpu_wake_up(vcpu))</blue>
		return;

	/*
	 * Note, the vCPU could get migrated to a different pCPU at any point
	 * after kvm_request_needs_ipi(), which could result in sending an IPI
	 * to the previous pCPU.  But, that&#x27;s OK because the purpose of the IPI
	 * is to ensure the vCPU returns to OUTSIDE_GUEST_MODE, which is
	 * satisfied if the vCPU migrates. Entering READING_SHADOW_PAGE_TABLES
	 * after this point is also OK, as the requirement is only that KVM wait
	 * for vCPUs that were reading SPTEs _before_ any changes were
	 * finalized. See kvm_vcpu_kick() for more details on handling requests.
	 */
<blue>	if (kvm_request_needs_ipi(vcpu, req)) {</blue>
<yellow>		cpu = READ_ONCE(vcpu->cpu);</yellow>
<yellow>		if (cpu != -1 && cpu != current_cpu)</yellow>
<yellow>			__cpumask_set_cpu(cpu, tmp);</yellow>
	}
<blue>}</blue>

bool kvm_make_vcpus_request_mask(struct kvm *kvm, unsigned int req,
				 unsigned long *vcpu_bitmap)
{
	struct kvm_vcpu *vcpu;
	struct cpumask *cpus;
	int i, me;
	bool called;

<yellow>	me = get_cpu();</yellow>

	cpus = this_cpu_cpumask_var_ptr(cpu_kick_mask);
	cpumask_clear(cpus);

<yellow>	for_each_set_bit(i, vcpu_bitmap, KVM_MAX_VCPUS) {</yellow>
<yellow>		vcpu = kvm_get_vcpu(kvm, i);</yellow>
		if (!vcpu)
			continue;
<yellow>		kvm_make_vcpu_request(vcpu, req, cpus, me);</yellow>
	}

<yellow>	called = kvm_kick_many_cpus(cpus, !!(req & KVM_REQUEST_WAIT));</yellow>
<yellow>	put_cpu();</yellow>

	return called;
<yellow>}</yellow>

bool kvm_make_all_cpus_request_except(struct kvm *kvm, unsigned int req,
				      struct kvm_vcpu *except)
<blue>{</blue>
	struct kvm_vcpu *vcpu;
	struct cpumask *cpus;
	unsigned long i;
	bool called;
	int me;

<blue>	me = get_cpu();</blue>

	cpus = this_cpu_cpumask_var_ptr(cpu_kick_mask);
	cpumask_clear(cpus);

<blue>	kvm_for_each_vcpu(i, vcpu, kvm) {</blue>
<blue>		if (vcpu == except)</blue>
			continue;
<blue>		kvm_make_vcpu_request(vcpu, req, cpus, me);</blue>
	}

<blue>	called = kvm_kick_many_cpus(cpus, !!(req & KVM_REQUEST_WAIT));</blue>
<blue>	put_cpu();</blue>

	return called;
}

bool kvm_make_all_cpus_request(struct kvm *kvm, unsigned int req)
{
<blue>	return kvm_make_all_cpus_request_except(kvm, req, NULL);</blue>
}
EXPORT_SYMBOL_GPL(kvm_make_all_cpus_request);

#ifndef CONFIG_HAVE_KVM_ARCH_TLB_FLUSH_ALL
void kvm_flush_remote_tlbs(struct kvm *kvm)
{
<blue>	++kvm->stat.generic.remote_tlb_flush_requests;</blue>

	/*
	 * We want to publish modifications to the page tables before reading
	 * mode. Pairs with a memory barrier in arch-specific code.
	 * - x86: smp_mb__after_srcu_read_unlock in vcpu_enter_guest
	 * and smp_mb in walk_shadow_page_lockless_begin/end.
	 * - powerpc: smp_mb in kvmppc_prepare_to_enter.
	 *
	 * There is already an smp_mb__after_atomic() before
	 * kvm_make_all_cpus_request() reads vcpu-&gt;mode. We reuse that
	 * barrier here.
	 */
<yellow>	if (!kvm_arch_flush_remote_tlb(kvm)</yellow>
<blue>	    || kvm_make_all_cpus_request(kvm, KVM_REQ_TLB_FLUSH))</blue>
<yellow>		++kvm->stat.generic.remote_tlb_flush;</yellow>
<blue>}</blue>
EXPORT_SYMBOL_GPL(kvm_flush_remote_tlbs);
#endif

static void kvm_flush_shadow_all(struct kvm *kvm)
{
	kvm_arch_flush_shadow_all(kvm);
	kvm_arch_guest_memory_reclaimed(kvm);
}

#ifdef KVM_ARCH_NR_OBJS_PER_MEMORY_CACHE
static inline void *mmu_memory_cache_alloc_obj(struct kvm_mmu_memory_cache *mc,
					       gfp_t gfp_flags)
{
	gfp_flags |= mc-&gt;gfp_zero;

	if (mc-&gt;kmem_cache)
<blue>		return kmem_cache_alloc(mc->kmem_cache, gfp_flags);</blue>
	else
<blue>		return (void *)__get_free_page(gfp_flags);</blue>
}

int __kvm_mmu_topup_memory_cache(struct kvm_mmu_memory_cache *mc, int capacity, int min)
{
<blue>	gfp_t gfp = mc->gfp_custom ? mc->gfp_custom : GFP_KERNEL_ACCOUNT;</blue>
	void *obj;

<blue>	if (mc->nobjs >= min)</blue>
		return 0;

<blue>	if (unlikely(!mc->objects)) {</blue>
<blue>		if (WARN_ON_ONCE(!capacity))</blue>
			return -EIO;

<blue>		mc->objects = kvmalloc_array(sizeof(void *), capacity, gfp);</blue>
		if (!mc-&gt;objects)
			return -ENOMEM;

<blue>		mc->capacity = capacity;</blue>
	}

	/* It is illegal to request a different capacity across topups. */
<blue>	if (WARN_ON_ONCE(mc->capacity != capacity))</blue>
		return -EIO;

<blue>	while (mc->nobjs < mc->capacity) {</blue>
<blue>		obj = mmu_memory_cache_alloc_obj(mc, gfp);</blue>
		if (!obj)
<blue>			return mc->nobjs >= min ? 0 : -ENOMEM;</blue>
<blue>		mc->objects[mc->nobjs++] = obj;</blue>
	}
	return 0;
<blue>}</blue>

int kvm_mmu_topup_memory_cache(struct kvm_mmu_memory_cache *mc, int min)
{
<blue>	return __kvm_mmu_topup_memory_cache(mc, KVM_ARCH_NR_OBJS_PER_MEMORY_CACHE, min);</blue>
}

int kvm_mmu_memory_cache_nr_free_objects(struct kvm_mmu_memory_cache *mc)
{
<yellow>	return mc->nobjs;</yellow>
}

void kvm_mmu_free_memory_cache(struct kvm_mmu_memory_cache *mc)
{
<yellow>	while (mc->nobjs) {</yellow>
<yellow>		if (mc->kmem_cache)</yellow>
<yellow>			kmem_cache_free(mc->kmem_cache, mc->objects[--mc->nobjs]);</yellow>
		else
<yellow>			free_page((unsigned long)mc->objects[--mc->nobjs]);</yellow>
	}

<yellow>	kvfree(mc->objects);</yellow>

	mc-&gt;objects = NULL;
	mc-&gt;capacity = 0;
}

void *kvm_mmu_memory_cache_alloc(struct kvm_mmu_memory_cache *mc)
{
	void *p;

<blue>	if (WARN_ON(!mc->nobjs))</blue>
<yellow>		p = mmu_memory_cache_alloc_obj(mc, GFP_ATOMIC | __GFP_ACCOUNT);</yellow>
	else
<blue>		p = mc->objects[--mc->nobjs];</blue>
<blue>	BUG_ON(!p);</blue>
	return p;
<blue>}</blue>
#endif

static void kvm_vcpu_init(struct kvm_vcpu *vcpu, struct kvm *kvm, unsigned id)
{
	mutex_init(&amp;vcpu-&gt;mutex);
	vcpu-&gt;cpu = -1;
	vcpu-&gt;kvm = kvm;
	vcpu-&gt;vcpu_id = id;
	vcpu-&gt;pid = NULL;
#ifndef __KVM_HAVE_ARCH_WQP
	rcuwait_init(&amp;vcpu-&gt;wait);
#endif
	kvm_async_pf_vcpu_init(vcpu);

	kvm_vcpu_set_in_spin_loop(vcpu, false);
	kvm_vcpu_set_dy_eligible(vcpu, false);
	vcpu-&gt;preempted = false;
	vcpu-&gt;ready = false;
	preempt_notifier_init(&amp;vcpu-&gt;preempt_notifier, &amp;kvm_preempt_ops);
	vcpu-&gt;last_used_slot = NULL;

	/* Fill the stats id string for the vcpu */
	snprintf(vcpu-&gt;stats_id, sizeof(vcpu-&gt;stats_id), &quot;kvm-%d/vcpu-%d&quot;,
		 task_pid_nr(current), id);
}

static void kvm_vcpu_destroy(struct kvm_vcpu *vcpu)
{
<yellow>	kvm_arch_vcpu_destroy(vcpu);</yellow>
	kvm_dirty_ring_free(&amp;vcpu-&gt;dirty_ring);

	/*
	 * No need for rcu_read_lock as VCPU_RUN is the only place that changes
	 * the vcpu-&gt;pid pointer, and at destruction time all file descriptors
	 * are already gone.
	 */
	put_pid(rcu_dereference_protected(vcpu-&gt;pid, 1));

	free_page((unsigned long)vcpu-&gt;run);
	kmem_cache_free(kvm_vcpu_cache, vcpu);
}

void kvm_destroy_vcpus(struct kvm *kvm)
{
	unsigned long i;
	struct kvm_vcpu *vcpu;

<yellow>	kvm_for_each_vcpu(i, vcpu, kvm) {</yellow>
<yellow>		kvm_vcpu_destroy(vcpu);</yellow>
		xa_erase(&amp;kvm-&gt;vcpu_array, i);
	}

<yellow>	atomic_set(&kvm->online_vcpus, 0);</yellow>
}
EXPORT_SYMBOL_GPL(kvm_destroy_vcpus);

#if defined(CONFIG_MMU_NOTIFIER) &amp;&amp; defined(KVM_ARCH_WANT_MMU_NOTIFIER)
static inline struct kvm *mmu_notifier_to_kvm(struct mmu_notifier *mn)
{
<blue>	return container_of(mn, struct kvm, mmu_notifier);</blue>
}

static void kvm_mmu_notifier_invalidate_range(struct mmu_notifier *mn,
					      struct mm_struct *mm,
					      unsigned long start, unsigned long end)
{
	struct kvm *kvm = mmu_notifier_to_kvm(mn);
	int idx;

<blue>	idx = srcu_read_lock(&kvm->srcu);</blue>
	kvm_arch_mmu_notifier_invalidate_range(kvm, start, end);
<blue>	srcu_read_unlock(&kvm->srcu, idx);</blue>
}

typedef bool (*hva_handler_t)(struct kvm *kvm, struct kvm_gfn_range *range);

typedef void (*on_lock_fn_t)(struct kvm *kvm, unsigned long start,
			     unsigned long end);

typedef void (*on_unlock_fn_t)(struct kvm *kvm);

struct kvm_hva_range {
	unsigned long start;
	unsigned long end;
	pte_t pte;
	hva_handler_t handler;
	on_lock_fn_t on_lock;
	on_unlock_fn_t on_unlock;
	bool flush_on_ret;
	bool may_block;
};

/*
 * Use a dedicated stub instead of NULL to indicate that there is no callback
 * function/handler.  The compiler technically can&#x27;t guarantee that a real
 * function will have a non-zero address, and so it will generate code to
 * check for !NULL, whereas comparing against a stub will be elided at compile
 * time (unless the compiler is getting long in the tooth, e.g. gcc 4.9).
 */
static void kvm_null_fn(void)
{

}
#define IS_KVM_NULL_FN(fn) ((fn) == (void *)kvm_null_fn)

/* Iterate over each memslot intersecting [start, last] (inclusive) range */
#define kvm_for_each_memslot_in_hva_range(node, slots, start, last)	     \
	for (node = interval_tree_iter_first(&amp;slots-&gt;hva_tree, start, last); \
	     node;							     \
	     node = interval_tree_iter_next(node, start, last))	     \

static __always_inline int __kvm_handle_hva_range(struct kvm *kvm,
						  const struct kvm_hva_range *range)
{
<blue>	bool ret = false, locked = false;</blue>
	struct kvm_gfn_range gfn_range;
	struct kvm_memory_slot *slot;
	struct kvm_memslots *slots;
	int i, idx;

<yellow>	if (WARN_ON_ONCE(range->end <= range->start))</yellow>
		return 0;

	/* A null handler is allowed if and only if on_lock() is provided. */
	if (WARN_ON_ONCE(IS_KVM_NULL_FN(range-&gt;on_lock) &amp;&amp;
			 IS_KVM_NULL_FN(range-&gt;handler)))
		return 0;

<blue>	idx = srcu_read_lock(&kvm->srcu);</blue>

<blue>	for (i = 0; i < KVM_ADDRESS_SPACE_NUM; i++) {</blue>
		struct interval_tree_node *node;

<blue>		slots = __kvm_memslots(kvm, i);</blue>
<blue>		kvm_for_each_memslot_in_hva_range(node, slots,</blue>
						  range-&gt;start, range-&gt;end - 1) {
			unsigned long hva_start, hva_end;

<blue>			slot = container_of(node, struct kvm_memory_slot, hva_node[slots->node_idx]);</blue>
			hva_start = max(range-&gt;start, slot-&gt;userspace_addr);
			hva_end = min(range-&gt;end, slot-&gt;userspace_addr +
						  (slot-&gt;npages &lt;&lt; PAGE_SHIFT));

			/*
			 * To optimize for the likely case where the address
			 * range is covered by zero or one memslots, don&#x27;t
			 * bother making these conditional (to avoid writes on
			 * the second or later invocation of the handler).
			 */
			gfn_range.pte = range-&gt;pte;
<blue>			gfn_range.may_block = range->may_block;</blue>

			/*
			 * {gfn(page) | page intersects with [hva_start, hva_end)} =
			 * {gfn_start, gfn_start+1, ..., gfn_end-1}.
			 */
			gfn_range.start = hva_to_gfn_memslot(hva_start, slot);
			gfn_range.end = hva_to_gfn_memslot(hva_end + PAGE_SIZE - 1, slot);
			gfn_range.slot = slot;

<blue>			if (!locked) {</blue>
				locked = true;
<blue>				KVM_MMU_LOCK(kvm);</blue>
				if (!IS_KVM_NULL_FN(range-&gt;on_lock))
<blue>					range->on_lock(kvm, range->start, range->end);</blue>
				if (IS_KVM_NULL_FN(range-&gt;handler))
					break;
			}
<blue>			ret |= range->handler(kvm, &gfn_range);</blue>
		}
	}

<blue>	if (range->flush_on_ret && ret)</blue>
<blue>		kvm_flush_remote_tlbs(kvm);</blue>

<blue>	if (locked) {</blue>
<blue>		KVM_MMU_UNLOCK(kvm);</blue>
		if (!IS_KVM_NULL_FN(range-&gt;on_unlock))
			range-&gt;on_unlock(kvm);
	}

<blue>	srcu_read_unlock(&kvm->srcu, idx);</blue>

	/* The notifiers are averse to booleans. :-( */
	return (int)ret;
}

static __always_inline int kvm_handle_hva_range(struct mmu_notifier *mn,
						unsigned long start,
						unsigned long end,
						pte_t pte,
						hva_handler_t handler)
{
	struct kvm *kvm = mmu_notifier_to_kvm(mn);
	const struct kvm_hva_range range = {
		.start		= start,
		.end		= end,
		.pte		= pte,
		.handler	= handler,
		.on_lock	= (void *)kvm_null_fn,
		.on_unlock	= (void *)kvm_null_fn,
		.flush_on_ret	= true,
		.may_block	= false,
	};

<blue>	return __kvm_handle_hva_range(kvm, &range);</blue>
}

static __always_inline int kvm_handle_hva_range_no_flush(struct mmu_notifier *mn,
							 unsigned long start,
							 unsigned long end,
							 hva_handler_t handler)
{
<yellow>	struct kvm *kvm = mmu_notifier_to_kvm(mn);</yellow>
	const struct kvm_hva_range range = {
		.start		= start,
		.end		= end,
		.pte		= __pte(0),
		.handler	= handler,
		.on_lock	= (void *)kvm_null_fn,
		.on_unlock	= (void *)kvm_null_fn,
		.flush_on_ret	= false,
		.may_block	= false,
	};

<yellow>	return __kvm_handle_hva_range(kvm, &range);</yellow>
}
static void kvm_mmu_notifier_change_pte(struct mmu_notifier *mn,
					struct mm_struct *mm,
					unsigned long address,
					pte_t pte)
<blue>{</blue>
	struct kvm *kvm = mmu_notifier_to_kvm(mn);

<blue>	trace_kvm_set_spte_hva(address);</blue>

	/*
	 * .change_pte() must be surrounded by .invalidate_range_{start,end}().
	 * If mmu_invalidate_in_progress is zero, then no in-progress
	 * invalidations, including this one, found a relevant memslot at
	 * start(); rechecking memslots here is unnecessary.  Note, a false
	 * positive (count elevated by a different invalidation) is sub-optimal
	 * but functionally ok.
	 */
<blue>	WARN_ON_ONCE(!READ_ONCE(kvm->mn_active_invalidate_count));</blue>
<blue>	if (!READ_ONCE(kvm->mmu_invalidate_in_progress))</blue>
		return;

<blue>	kvm_handle_hva_range(mn, address, address + 1, pte, kvm_set_spte_gfn);</blue>
}

<blue>void kvm_mmu_invalidate_begin(struct kvm *kvm, unsigned long start,</blue>
			      unsigned long end)
{
	/*
	 * The count increase must become visible at unlock time as no
	 * spte can be established without taking the mmu_lock and
	 * count is also read inside the mmu_lock critical section.
	 */
<yellow>	kvm->mmu_invalidate_in_progress++;</yellow>
	if (likely(kvm-&gt;mmu_invalidate_in_progress == 1)) {
<blue>		kvm->mmu_invalidate_range_start = start;</blue>
<yellow>		kvm->mmu_invalidate_range_end = end;</yellow>
	} else {
		/*
		 * Fully tracking multiple concurrent ranges has diminishing
		 * returns. Keep things simple and just find the minimal range
		 * which includes the current and new ranges. As there won&#x27;t be
		 * enough information to subtract a range after its invalidate
		 * completes, any ranges invalidated concurrently will
		 * accumulate and persist until all outstanding invalidates
		 * complete.
		 */
		kvm-&gt;mmu_invalidate_range_start =
<blue>			min(kvm->mmu_invalidate_range_start, start);</blue>
		kvm-&gt;mmu_invalidate_range_end =
			max(kvm-&gt;mmu_invalidate_range_end, end);
	}
}

static int kvm_mmu_notifier_invalidate_range_start(struct mmu_notifier *mn,
					const struct mmu_notifier_range *range)
<blue>{</blue>
<blue>	struct kvm *kvm = mmu_notifier_to_kvm(mn);</blue>
	const struct kvm_hva_range hva_range = {
		.start		= range-&gt;start,
		.end		= range-&gt;end,
		.pte		= __pte(0),
		.handler	= kvm_unmap_gfn_range,
		.on_lock	= kvm_mmu_invalidate_begin,
		.on_unlock	= kvm_arch_guest_memory_reclaimed,
		.flush_on_ret	= true,
		.may_block	= mmu_notifier_range_blockable(range),
	};

<yellow>	trace_kvm_unmap_hva_range(range->start, range->end);</yellow>

	/*
	 * Prevent memslot modification between range_start() and range_end()
	 * so that conditionally locking provides the same result in both
	 * functions.  Without that guarantee, the mmu_invalidate_in_progress
	 * adjustments will be imbalanced.
	 *
	 * Pairs with the decrement in range_end().
	 */
<blue>	spin_lock(&kvm->mn_invalidate_lock);</blue>
	kvm-&gt;mn_active_invalidate_count++;
	spin_unlock(&amp;kvm-&gt;mn_invalidate_lock);

	/*
	 * Invalidate pfn caches _before_ invalidating the secondary MMUs, i.e.
	 * before acquiring mmu_lock, to avoid holding mmu_lock while acquiring
	 * each cache&#x27;s lock.  There are relatively few caches in existence at
	 * any given time, and the caches themselves can check for hva overlap,
	 * i.e. don&#x27;t need to rely on memslot overlap checks for performance.
	 * Because this runs without holding mmu_lock, the pfn caches must use
	 * mn_active_invalidate_count (see above) instead of
	 * mmu_invalidate_in_progress.
	 */
	gfn_to_pfn_cache_invalidate_start(kvm, range-&gt;start, range-&gt;end,
<blue>					  hva_range.may_block);</blue>

<blue>	__kvm_handle_hva_range(kvm, &hva_range);</blue>

	return 0;
}

void kvm_mmu_invalidate_end(struct kvm *kvm, unsigned long start,
			    unsigned long end)
{
	/*
	 * This sequence increase will notify the kvm page fault that
	 * the page that is going to be mapped in the spte could have
	 * been freed.
	 */
<yellow>	kvm->mmu_invalidate_seq++;</yellow>
	smp_wmb();
	/*
	 * The above sequence increase must be visible before the
	 * below count decrease, which is ensured by the smp_wmb above
	 * in conjunction with the smp_rmb in mmu_invalidate_retry().
	 */
	kvm-&gt;mmu_invalidate_in_progress--;
}

static void kvm_mmu_notifier_invalidate_range_end(struct mmu_notifier *mn,
					const struct mmu_notifier_range *range)
{
	struct kvm *kvm = mmu_notifier_to_kvm(mn);
	const struct kvm_hva_range hva_range = {
<blue>		.start		= range->start,</blue>
		.end		= range-&gt;end,
		.pte		= __pte(0),
		.handler	= (void *)kvm_null_fn,
		.on_lock	= kvm_mmu_invalidate_end,
		.on_unlock	= (void *)kvm_null_fn,
		.flush_on_ret	= false,
		.may_block	= mmu_notifier_range_blockable(range),
	};
	bool wake;

<blue>	__kvm_handle_hva_range(kvm, &hva_range);</blue>

	/* Pairs with the increment in range_start(). */
<blue>	spin_lock(&kvm->mn_invalidate_lock);</blue>
	wake = (--kvm-&gt;mn_active_invalidate_count == 0);
	spin_unlock(&amp;kvm-&gt;mn_invalidate_lock);

	/*
	 * There can only be one waiter, since the wait happens under
	 * slots_lock.
	 */
	if (wake)
<blue>		rcuwait_wake_up(&kvm->mn_memslots_update_rcuwait);</blue>

<blue>	BUG_ON(kvm->mmu_invalidate_in_progress < 0);</blue>
<blue>}</blue>

static int kvm_mmu_notifier_clear_flush_young(struct mmu_notifier *mn,
					      struct mm_struct *mm,
					      unsigned long start,
					      unsigned long end)
<blue>{</blue>
<blue>	trace_kvm_age_hva(start, end);</blue>

<blue>	return kvm_handle_hva_range(mn, start, end, __pte(0), kvm_age_gfn);</blue>
}

static int kvm_mmu_notifier_clear_young(struct mmu_notifier *mn,
					struct mm_struct *mm,
					unsigned long start,
					unsigned long end)
<yellow>{</yellow>
<yellow>	trace_kvm_age_hva(start, end);</yellow>

	/*
	 * Even though we do not flush TLB, this will still adversely
	 * affect performance on pre-Haswell Intel EPT, where there is
	 * no EPT Access Bit to clear so that we have to tear down EPT
	 * tables instead. If we find this unacceptable, we can always
	 * add a parameter to kvm_age_hva so that it effectively doesn&#x27;t
	 * do anything on clear_young.
	 *
	 * Also note that currently we never issue secondary TLB flushes
	 * from clear_young, leaving this job up to the regular system
	 * cadence. If we find this inaccurate, we might come up with a
	 * more sophisticated heuristic later.
	 */
<yellow>	return kvm_handle_hva_range_no_flush(mn, start, end, kvm_age_gfn);</yellow>
}

static int kvm_mmu_notifier_test_young(struct mmu_notifier *mn,
				       struct mm_struct *mm,
				       unsigned long address)
<yellow>{</yellow>
<yellow>	trace_kvm_test_age_hva(address);</yellow>

<yellow>	return kvm_handle_hva_range_no_flush(mn, address, address + 1,</yellow>
					     kvm_test_age_gfn);
}

static void kvm_mmu_notifier_release(struct mmu_notifier *mn,
				     struct mm_struct *mm)
{
	struct kvm *kvm = mmu_notifier_to_kvm(mn);
	int idx;

<yellow>	idx = srcu_read_lock(&kvm->srcu);</yellow>
	kvm_flush_shadow_all(kvm);
<yellow>	srcu_read_unlock(&kvm->srcu, idx);</yellow>
}

static const struct mmu_notifier_ops kvm_mmu_notifier_ops = {
	.invalidate_range	= kvm_mmu_notifier_invalidate_range,
	.invalidate_range_start	= kvm_mmu_notifier_invalidate_range_start,
	.invalidate_range_end	= kvm_mmu_notifier_invalidate_range_end,
	.clear_flush_young	= kvm_mmu_notifier_clear_flush_young,
	.clear_young		= kvm_mmu_notifier_clear_young,
	.test_young		= kvm_mmu_notifier_test_young,
	.change_pte		= kvm_mmu_notifier_change_pte,
	.release		= kvm_mmu_notifier_release,
};

static int kvm_init_mmu_notifier(struct kvm *kvm)
{
	kvm-&gt;mmu_notifier.ops = &amp;kvm_mmu_notifier_ops;
	return mmu_notifier_register(&amp;kvm-&gt;mmu_notifier, current-&gt;mm);
}

#else  /* !(CONFIG_MMU_NOTIFIER &amp;&amp; KVM_ARCH_WANT_MMU_NOTIFIER) */

static int kvm_init_mmu_notifier(struct kvm *kvm)
{
	return 0;
}

#endif /* CONFIG_MMU_NOTIFIER &amp;&amp; KVM_ARCH_WANT_MMU_NOTIFIER */

#ifdef CONFIG_HAVE_KVM_PM_NOTIFIER
static int kvm_pm_notifier_call(struct notifier_block *bl,
				unsigned long state,
				void *unused)
{
<yellow>	struct kvm *kvm = container_of(bl, struct kvm, pm_notifier);</yellow>

	return kvm_arch_pm_notifier(kvm, state);
}

static void kvm_init_pm_notifier(struct kvm *kvm)
{
	kvm-&gt;pm_notifier.notifier_call = kvm_pm_notifier_call;
	/* Suspend KVM before we suspend ftrace, RCU, etc. */
	kvm-&gt;pm_notifier.priority = INT_MAX;
	register_pm_notifier(&amp;kvm-&gt;pm_notifier);
}

static void kvm_destroy_pm_notifier(struct kvm *kvm)
{
	unregister_pm_notifier(&amp;kvm-&gt;pm_notifier);
}
#else /* !CONFIG_HAVE_KVM_PM_NOTIFIER */
static void kvm_init_pm_notifier(struct kvm *kvm)
{
}

static void kvm_destroy_pm_notifier(struct kvm *kvm)
{
}
#endif /* CONFIG_HAVE_KVM_PM_NOTIFIER */

static void kvm_destroy_dirty_bitmap(struct kvm_memory_slot *memslot)
{
<blue>	if (!memslot->dirty_bitmap)</blue>
		return;

<yellow>	kvfree(memslot->dirty_bitmap);</yellow>
	memslot-&gt;dirty_bitmap = NULL;
}

/* This does not remove the slot from struct kvm_memslots data structures */
static void kvm_free_memslot(struct kvm *kvm, struct kvm_memory_slot *slot)
{
<blue>	kvm_destroy_dirty_bitmap(slot);</blue>

<blue>	kvm_arch_free_memslot(kvm, slot);</blue>

	kfree(slot);
}

static void kvm_free_memslots(struct kvm *kvm, struct kvm_memslots *slots)
{
	struct hlist_node *idnode;
	struct kvm_memory_slot *memslot;
	int bkt;

	/*
	 * The same memslot objects live in both active and inactive sets,
	 * arbitrarily free using index &#x27;1&#x27; so the second invocation of this
	 * function isn&#x27;t operating over a structure with dangling pointers
	 * (even though this function isn&#x27;t actually touching them).
	 */
<yellow>	if (!slots->node_idx)</yellow>
		return;

<yellow>	hash_for_each_safe(slots->id_hash, bkt, idnode, memslot, id_node[1])</yellow>
<yellow>		kvm_free_memslot(kvm, memslot);</yellow>
<yellow>}</yellow>

static umode_t kvm_stats_debugfs_mode(const struct _kvm_stats_desc *pdesc)
{
<yellow>	switch (pdesc->desc.flags & KVM_STATS_TYPE_MASK) {</yellow>
	case KVM_STATS_TYPE_INSTANT:
		return 0444;
	case KVM_STATS_TYPE_CUMULATIVE:
	case KVM_STATS_TYPE_PEAK:
	default:
		return 0644;
	}
}


static void kvm_destroy_vm_debugfs(struct kvm *kvm)
{
	int i;
<yellow>	int kvm_debugfs_num_entries = kvm_vm_stats_header.num_desc +</yellow>
				      kvm_vcpu_stats_header.num_desc;

	if (IS_ERR(kvm-&gt;debugfs_dentry))
		return;

<yellow>	debugfs_remove_recursive(kvm->debugfs_dentry);</yellow>

	if (kvm-&gt;debugfs_stat_data) {
		for (i = 0; i &lt; kvm_debugfs_num_entries; i++)
<yellow>			kfree(kvm->debugfs_stat_data[i]);</yellow>
<yellow>		kfree(kvm->debugfs_stat_data);</yellow>
	}
<yellow>}</yellow>

static int kvm_create_vm_debugfs(struct kvm *kvm, const char *fdname)
{
	static DEFINE_MUTEX(kvm_debugfs_lock);
	struct dentry *dent;
	char dir_name[ITOA_MAX_LEN * 2];
	struct kvm_stat_data *stat_data;
	const struct _kvm_stats_desc *pdesc;
	int i, ret = -ENOMEM;
<blue>	int kvm_debugfs_num_entries = kvm_vm_stats_header.num_desc +</blue>
				      kvm_vcpu_stats_header.num_desc;

	if (!debugfs_initialized())
		return 0;

<blue>	snprintf(dir_name, sizeof(dir_name), "%d-%s", task_pid_nr(current), fdname);</blue>
	mutex_lock(&amp;kvm_debugfs_lock);
	dent = debugfs_lookup(dir_name, kvm_debugfs_dir);
	if (dent) {
<yellow>		pr_warn_ratelimited("KVM: debugfs: duplicate directory %s\n", dir_name);</yellow>
<yellow>		dput(dent);</yellow>
		mutex_unlock(&amp;kvm_debugfs_lock);
		return 0;
	}
<blue>	dent = debugfs_create_dir(dir_name, kvm_debugfs_dir);</blue>
	mutex_unlock(&amp;kvm_debugfs_lock);
	if (IS_ERR(dent))
		return 0;

<blue>	kvm->debugfs_dentry = dent;</blue>
<blue>	kvm->debugfs_stat_data = kcalloc(kvm_debugfs_num_entries,</blue>
					 sizeof(*kvm-&gt;debugfs_stat_data),
					 GFP_KERNEL_ACCOUNT);
	if (!kvm-&gt;debugfs_stat_data)
		goto out_err;

<blue>	for (i = 0; i < kvm_vm_stats_header.num_desc; ++i) {</blue>
<blue>		pdesc = &kvm_vm_stats_desc[i];</blue>
		stat_data = kzalloc(sizeof(*stat_data), GFP_KERNEL_ACCOUNT);
		if (!stat_data)
			goto out_err;

<blue>		stat_data->kvm = kvm;</blue>
		stat_data-&gt;desc = pdesc;
		stat_data-&gt;kind = KVM_STAT_VM;
		kvm-&gt;debugfs_stat_data[i] = stat_data;
<blue>		debugfs_create_file(pdesc->name, kvm_stats_debugfs_mode(pdesc),</blue>
				    kvm-&gt;debugfs_dentry, stat_data,
				    &amp;stat_fops_per_vm);
	}

<blue>	for (i = 0; i < kvm_vcpu_stats_header.num_desc; ++i) {</blue>
<blue>		pdesc = &kvm_vcpu_stats_desc[i];</blue>
		stat_data = kzalloc(sizeof(*stat_data), GFP_KERNEL_ACCOUNT);
		if (!stat_data)
			goto out_err;

<blue>		stat_data->kvm = kvm;</blue>
		stat_data-&gt;desc = pdesc;
		stat_data-&gt;kind = KVM_STAT_VCPU;
		kvm-&gt;debugfs_stat_data[i + kvm_vm_stats_header.num_desc] = stat_data;
<blue>		debugfs_create_file(pdesc->name, kvm_stats_debugfs_mode(pdesc),</blue>
				    kvm-&gt;debugfs_dentry, stat_data,
				    &amp;stat_fops_per_vm);
	}

<blue>	ret = kvm_arch_create_vm_debugfs(kvm);</blue>
	if (ret)
		goto out_err;

	return 0;
out_err:
<yellow>	kvm_destroy_vm_debugfs(kvm);</yellow>
	return ret;
}

/*
 * Called after the VM is otherwise initialized, but just before adding it to
 * the vm_list.
 */
int __weak kvm_arch_post_init_vm(struct kvm *kvm)
{
	return 0;
<yellow>}</yellow>

/*
 * Called just after removing the VM from the vm_list, but before doing any
 * other destruction.
 */
void __weak kvm_arch_pre_destroy_vm(struct kvm *kvm)
{
<yellow>}</yellow>

/*
 * Called after per-vm debugfs created.  When called kvm-&gt;debugfs_dentry should
 * be setup already, so we can create arch-specific debugfs entries under it.
 * Cleanup should be automatic done in kvm_destroy_vm_debugfs() recursively, so
 * a per-arch destroy interface is not needed.
 */
int __weak kvm_arch_create_vm_debugfs(struct kvm *kvm)
{
	return 0;
}

static struct kvm *kvm_create_vm(unsigned long type, const char *fdname)
{
	struct kvm *kvm = kvm_arch_alloc_vm();
	struct kvm_memslots *slots;
	int r = -ENOMEM;
	int i, j;

	if (!kvm)
		return ERR_PTR(-ENOMEM);

	/* KVM is pinned via open(&quot;/dev/kvm&quot;), the fd passed to this ioctl(). */
<blue>	__module_get(kvm_chardev_ops.owner);</blue>

	KVM_MMU_LOCK_INIT(kvm);
	mmgrab(current-&gt;mm);
	kvm-&gt;mm = current-&gt;mm;
	kvm_eventfd_init(kvm);
	mutex_init(&amp;kvm-&gt;lock);
	mutex_init(&amp;kvm-&gt;irq_lock);
	mutex_init(&amp;kvm-&gt;slots_lock);
	mutex_init(&amp;kvm-&gt;slots_arch_lock);
	spin_lock_init(&amp;kvm-&gt;mn_invalidate_lock);
	rcuwait_init(&amp;kvm-&gt;mn_memslots_update_rcuwait);
	xa_init(&amp;kvm-&gt;vcpu_array);

	INIT_LIST_HEAD(&amp;kvm-&gt;gpc_list);
	spin_lock_init(&amp;kvm-&gt;gpc_lock);

	INIT_LIST_HEAD(&amp;kvm-&gt;devices);
	kvm-&gt;max_vcpus = KVM_MAX_VCPUS;

	BUILD_BUG_ON(KVM_MEM_SLOTS_NUM &gt; SHRT_MAX);

	/*
	 * Force subsequent debugfs file creations to fail if the VM directory
	 * is not created (by kvm_create_vm_debugfs()).
	 */
	kvm-&gt;debugfs_dentry = ERR_PTR(-ENOENT);

	snprintf(kvm-&gt;stats_id, sizeof(kvm-&gt;stats_id), &quot;kvm-%d&quot;,
		 task_pid_nr(current));

	if (init_srcu_struct(&amp;kvm-&gt;srcu))
		goto out_err_no_srcu;
<blue>	if (init_srcu_struct(&kvm->irq_srcu))</blue>
		goto out_err_no_irq_srcu;

<blue>	refcount_set(&kvm->users_count, 1);</blue>
	for (i = 0; i &lt; KVM_ADDRESS_SPACE_NUM; i++) {
<blue>		for (j = 0; j < 2; j++) {</blue>
<blue>			slots = &kvm->__memslots[i][j];</blue>

			atomic_long_set(&amp;slots-&gt;last_used_slot, (unsigned long)NULL);
			slots-&gt;hva_tree = RB_ROOT_CACHED;
			slots-&gt;gfn_tree = RB_ROOT;
<blue>			hash_init(slots->id_hash);</blue>
<blue>			slots->node_idx = j;</blue>

			/* Generations must be different for each address space. */
			slots-&gt;generation = i;
		}

<blue>		rcu_assign_pointer(kvm->memslots[i], &kvm->__memslots[i][0]);</blue>
	}

<blue>	for (i = 0; i < KVM_NR_BUSES; i++) {</blue>
<blue>		rcu_assign_pointer(kvm->buses[i],</blue>
			kzalloc(sizeof(struct kvm_io_bus), GFP_KERNEL_ACCOUNT));
		if (!kvm-&gt;buses[i])
			goto out_err_no_arch_destroy_vm;
	}

<blue>	r = kvm_arch_init_vm(kvm, type);</blue>
	if (r)
		goto out_err_no_arch_destroy_vm;

<blue>	r = hardware_enable_all();</blue>
	if (r)
		goto out_err_no_disable;

#ifdef CONFIG_HAVE_KVM_IRQFD
	INIT_HLIST_HEAD(&amp;kvm-&gt;irq_ack_notifier_list);
#endif

	r = kvm_init_mmu_notifier(kvm);
	if (r)
		goto out_err_no_mmu_notifier;

<blue>	r = kvm_coalesced_mmio_init(kvm);</blue>
	if (r &lt; 0)
		goto out_no_coalesced_mmio;

<blue>	r = kvm_create_vm_debugfs(kvm, fdname);</blue>
	if (r)
		goto out_err_no_debugfs;

<blue>	r = kvm_arch_post_init_vm(kvm);</blue>
	if (r)
		goto out_err;

<blue>	mutex_lock(&kvm_lock);</blue>
	list_add(&amp;kvm-&gt;vm_list, &amp;vm_list);
	mutex_unlock(&amp;kvm_lock);

	preempt_notifier_inc();
	kvm_init_pm_notifier(kvm);

	return kvm;

out_err:
	kvm_destroy_vm_debugfs(kvm);
out_err_no_debugfs:
<yellow>	kvm_coalesced_mmio_free(kvm);</yellow>
out_no_coalesced_mmio:
#if defined(CONFIG_MMU_NOTIFIER) &amp;&amp; defined(KVM_ARCH_WANT_MMU_NOTIFIER)
<yellow>	if (kvm->mmu_notifier.ops)</yellow>
<yellow>		mmu_notifier_unregister(&kvm->mmu_notifier, current->mm);</yellow>
#endif
out_err_no_mmu_notifier:
<yellow>	hardware_disable_all();</yellow>
out_err_no_disable:
<yellow>	kvm_arch_destroy_vm(kvm);</yellow>
out_err_no_arch_destroy_vm:
<yellow>	WARN_ON_ONCE(!refcount_dec_and_test(&kvm->users_count));</yellow>
	for (i = 0; i &lt; KVM_NR_BUSES; i++)
<yellow>		kfree(kvm_get_bus(kvm, i));</yellow>
<yellow>	cleanup_srcu_struct(&kvm->irq_srcu);</yellow>
out_err_no_irq_srcu:
<yellow>	cleanup_srcu_struct(&kvm->srcu);</yellow>
out_err_no_srcu:
<yellow>	kvm_arch_free_vm(kvm);</yellow>
<yellow>	mmdrop(current->mm);</yellow>
<yellow>	module_put(kvm_chardev_ops.owner);</yellow>
<yellow>	return ERR_PTR(r);</yellow>
}

static void kvm_destroy_devices(struct kvm *kvm)
{
	struct kvm_device *dev, *tmp;

	/*
	 * We do not need to take the kvm-&gt;lock here, because nobody else
	 * has a reference to the struct kvm at this point and therefore
	 * cannot access the devices list anyhow.
	 */
	list_for_each_entry_safe(dev, tmp, &amp;kvm-&gt;devices, vm_node) {
<yellow>		list_del(&dev->vm_node);</yellow>
		dev-&gt;ops-&gt;destroy(dev);
	}
}

static void kvm_destroy_vm(struct kvm *kvm)
{
	int i;
<yellow>	struct mm_struct *mm = kvm->mm;</yellow>

	kvm_destroy_pm_notifier(kvm);
<yellow>	kvm_uevent_notify_change(KVM_EVENT_DESTROY_VM, kvm);</yellow>
<yellow>	kvm_destroy_vm_debugfs(kvm);</yellow>
	kvm_arch_sync_events(kvm);
	mutex_lock(&amp;kvm_lock);
	list_del(&amp;kvm-&gt;vm_list);
	mutex_unlock(&amp;kvm_lock);
	kvm_arch_pre_destroy_vm(kvm);

	kvm_free_irq_routing(kvm);
	for (i = 0; i &lt; KVM_NR_BUSES; i++) {
<yellow>		struct kvm_io_bus *bus = kvm_get_bus(kvm, i);</yellow>

		if (bus)
<yellow>			kvm_io_bus_destroy(bus);</yellow>
<yellow>		kvm->buses[i] = NULL;</yellow>
	}
<yellow>	kvm_coalesced_mmio_free(kvm);</yellow>
#if defined(CONFIG_MMU_NOTIFIER) &amp;&amp; defined(KVM_ARCH_WANT_MMU_NOTIFIER)
	mmu_notifier_unregister(&amp;kvm-&gt;mmu_notifier, kvm-&gt;mm);
	/*
	 * At this point, pending calls to invalidate_range_start()
	 * have completed but no more MMU notifiers will run, so
	 * mn_active_invalidate_count may remain unbalanced.
	 * No threads can be waiting in install_new_memslots as the
	 * last reference on KVM has been dropped, but freeing
	 * memslots would deadlock without this manual intervention.
	 */
<yellow>	WARN_ON(rcuwait_active(&kvm->mn_memslots_update_rcuwait));</yellow>
<yellow>	kvm->mn_active_invalidate_count = 0;</yellow>
#else
	kvm_flush_shadow_all(kvm);
#endif
	kvm_arch_destroy_vm(kvm);
<yellow>	kvm_destroy_devices(kvm);</yellow>
<yellow>	for (i = 0; i < KVM_ADDRESS_SPACE_NUM; i++) {</yellow>
<yellow>		kvm_free_memslots(kvm, &kvm->__memslots[i][0]);</yellow>
<yellow>		kvm_free_memslots(kvm, &kvm->__memslots[i][1]);</yellow>
	}
<yellow>	cleanup_srcu_struct(&kvm->irq_srcu);</yellow>
	cleanup_srcu_struct(&amp;kvm-&gt;srcu);
	kvm_arch_free_vm(kvm);
	preempt_notifier_dec();
<yellow>	hardware_disable_all();</yellow>
<yellow>	mmdrop(mm);</yellow>
<yellow>	module_put(kvm_chardev_ops.owner);</yellow>
}

void kvm_get_kvm(struct kvm *kvm)
{
<blue>	refcount_inc(&kvm->users_count);</blue>
<yellow>}</yellow>
EXPORT_SYMBOL_GPL(kvm_get_kvm);

/*
 * Make sure the vm is not during destruction, which is a safe version of
 * kvm_get_kvm().  Return true if kvm referenced successfully, false otherwise.
 */
bool kvm_get_kvm_safe(struct kvm *kvm)
{
<yellow>	return refcount_inc_not_zero(&kvm->users_count);</yellow>
}
EXPORT_SYMBOL_GPL(kvm_get_kvm_safe);

void kvm_put_kvm(struct kvm *kvm)
{
<yellow>	if (refcount_dec_and_test(&kvm->users_count))</yellow>
<yellow>		kvm_destroy_vm(kvm);</yellow>
<yellow>}</yellow>
EXPORT_SYMBOL_GPL(kvm_put_kvm);

/*
 * Used to put a reference that was taken on behalf of an object associated
 * with a user-visible file descriptor, e.g. a vcpu or device, if installation
 * of the new file descriptor fails and the reference cannot be transferred to
 * its final owner.  In such cases, the caller is still actively using @kvm and
 * will fail miserably if the refcount unexpectedly hits zero.
 */
void kvm_put_kvm_no_destroy(struct kvm *kvm)
{
<yellow>	WARN_ON(refcount_dec_and_test(&kvm->users_count));</yellow>
<yellow>}</yellow>
EXPORT_SYMBOL_GPL(kvm_put_kvm_no_destroy);

static int kvm_vm_release(struct inode *inode, struct file *filp)
{
<yellow>	struct kvm *kvm = filp->private_data;</yellow>

	kvm_irqfd_release(kvm);

	kvm_put_kvm(kvm);
	return 0;
}

/*
 * Allocation size is twice as large as the actual dirty bitmap size.
 * See kvm_vm_ioctl_get_dirty_log() why this is needed.
 */
static int kvm_alloc_dirty_bitmap(struct kvm_memory_slot *memslot)
{
<yellow>	unsigned long dirty_bytes = kvm_dirty_bitmap_bytes(memslot);</yellow>

	memslot-&gt;dirty_bitmap = __vcalloc(2, dirty_bytes, GFP_KERNEL_ACCOUNT);
	if (!memslot-&gt;dirty_bitmap)
		return -ENOMEM;

	return 0;
}

static struct kvm_memslots *kvm_get_inactive_memslots(struct kvm *kvm, int as_id)
{
<blue>	struct kvm_memslots *active = __kvm_memslots(kvm, as_id);</blue>
	int node_idx_inactive = active-&gt;node_idx ^ 1;

	return &amp;kvm-&gt;__memslots[as_id][node_idx_inactive];
}

/*
 * Helper to get the address space ID when one of memslot pointers may be NULL.
 * This also serves as a sanity that at least one of the pointers is non-NULL,
 * and that their address space IDs don&#x27;t diverge.
 */
<yellow>static int kvm_memslots_get_as_id(struct kvm_memory_slot *a,</yellow>
				  struct kvm_memory_slot *b)
{
<blue>	if (WARN_ON_ONCE(!a && !b))</blue>
		return 0;

	if (!a)
<blue>		return b->as_id;</blue>
<blue>	if (!b)</blue>
<blue>		return a->as_id;</blue>

<yellow>	WARN_ON_ONCE(a->as_id != b->as_id);</yellow>
	return a-&gt;as_id;
}

static void kvm_insert_gfn_node(struct kvm_memslots *slots,
				struct kvm_memory_slot *slot)
{
	struct rb_root *gfn_tree = &amp;slots-&gt;gfn_tree;
	struct rb_node **node, *parent;
<blue>	int idx = slots->node_idx;</blue>

	parent = NULL;
<blue>	for (node = &gfn_tree->rb_node; *node; ) {</blue>
		struct kvm_memory_slot *tmp;

<blue>		tmp = container_of(*node, struct kvm_memory_slot, gfn_node[idx]);</blue>
		parent = *node;
<blue>		if (slot->base_gfn < tmp->base_gfn)</blue>
<blue>			node = &(*node)->rb_left;</blue>
<blue>		else if (slot->base_gfn > tmp->base_gfn)</blue>
<blue>			node = &(*node)->rb_right;</blue>
		else
<yellow>			BUG();</yellow>
	}

<blue>	rb_link_node(&slot->gfn_node[idx], parent, node);</blue>
	rb_insert_color(&amp;slot-&gt;gfn_node[idx], gfn_tree);
}

static void kvm_erase_gfn_node(struct kvm_memslots *slots,
			       struct kvm_memory_slot *slot)
{
<blue>	rb_erase(&slot->gfn_node[slots->node_idx], &slots->gfn_tree);</blue>
}

static void kvm_replace_gfn_node(struct kvm_memslots *slots,
				 struct kvm_memory_slot *old,
				 struct kvm_memory_slot *new)
{
	int idx = slots-&gt;node_idx;

	WARN_ON_ONCE(old-&gt;base_gfn != new-&gt;base_gfn);

<blue>	rb_replace_node(&old->gfn_node[idx], &new->gfn_node[idx],</blue>
			&amp;slots-&gt;gfn_tree);
}

/*
 * Replace @old with @new in the inactive memslots.
 *
 * With NULL @old this simply adds @new.
 * With NULL @new this simply removes @old.
 *
 * If @new is non-NULL its hva_node[slots_idx] range has to be set
 * appropriately.
 */
static void kvm_replace_memslot(struct kvm *kvm,
				struct kvm_memory_slot *old,
				struct kvm_memory_slot *new)
{
<blue>	int as_id = kvm_memslots_get_as_id(old, new);</blue>
<blue>	struct kvm_memslots *slots = kvm_get_inactive_memslots(kvm, as_id);</blue>
	int idx = slots-&gt;node_idx;

	if (old) {
<blue>		hash_del(&old->id_node[idx]);</blue>
<blue>		interval_tree_remove(&old->hva_node[idx], &slots->hva_tree);</blue>

		if ((long)old == atomic_long_read(&amp;slots-&gt;last_used_slot))
<yellow>			atomic_long_set(&slots->last_used_slot, (long)new);</yellow>

<blue>		if (!new) {</blue>
<blue>			kvm_erase_gfn_node(slots, old);</blue>
			return;
		}
	}

	/*
	 * Initialize @new&#x27;s hva range.  Do this even when replacing an @old
	 * slot, kvm_copy_memslot() deliberately does not touch node data.
	 */
<blue>	new->hva_node[idx].start = new->userspace_addr;</blue>
	new-&gt;hva_node[idx].last = new-&gt;userspace_addr +
				  (new-&gt;npages &lt;&lt; PAGE_SHIFT) - 1;

	/*
	 * (Re)Add the new memslot.  There is no O(1) interval_tree_replace(),
	 * hva_node needs to be swapped with remove+insert even though hva can&#x27;t
	 * change when replacing an existing slot.
	 */
<blue>	hash_add(slots->id_hash, &new->id_node[idx], new->id);</blue>
	interval_tree_insert(&amp;new-&gt;hva_node[idx], &amp;slots-&gt;hva_tree);

	/*
	 * If the memslot gfn is unchanged, rb_replace_node() can be used to
	 * switch the node in the gfn tree instead of removing the old and
	 * inserting the new as two separate operations. Replacement is a
	 * single O(1) operation versus two O(log(n)) operations for
	 * remove+insert.
	 */
<blue>	if (old && old->base_gfn == new->base_gfn) {</blue>
<blue>		kvm_replace_gfn_node(slots, old, new);</blue>
	} else {
		if (old)
<yellow>			kvm_erase_gfn_node(slots, old);</yellow>
<blue>		kvm_insert_gfn_node(slots, new);</blue>
	}
<blue>}</blue>

static int check_memory_region_flags(const struct kvm_userspace_memory_region *mem)
{
	u32 valid_flags = KVM_MEM_LOG_DIRTY_PAGES;

#ifdef __KVM_HAVE_READONLY_MEM
	valid_flags |= KVM_MEM_READONLY;
#endif

<blue>	if (mem->flags & ~valid_flags)</blue>
		return -EINVAL;

	return 0;
}

static void kvm_swap_active_memslots(struct kvm *kvm, int as_id)
{
<blue>	struct kvm_memslots *slots = kvm_get_inactive_memslots(kvm, as_id);</blue>

	/* Grab the generation from the activate memslots. */
	u64 gen = __kvm_memslots(kvm, as_id)-&gt;generation;

<yellow>	WARN_ON(gen & KVM_MEMSLOT_GEN_UPDATE_IN_PROGRESS);</yellow>
<blue>	slots->generation = gen | KVM_MEMSLOT_GEN_UPDATE_IN_PROGRESS;</blue>

	/*
	 * Do not store the new memslots while there are invalidations in
	 * progress, otherwise the locking in invalidate_range_start and
	 * invalidate_range_end will be unbalanced.
	 */
	spin_lock(&amp;kvm-&gt;mn_invalidate_lock);
	prepare_to_rcuwait(&amp;kvm-&gt;mn_memslots_update_rcuwait);
	while (kvm-&gt;mn_active_invalidate_count) {
<blue>		set_current_state(TASK_UNINTERRUPTIBLE);</blue>
		spin_unlock(&amp;kvm-&gt;mn_invalidate_lock);
		schedule();
		spin_lock(&amp;kvm-&gt;mn_invalidate_lock);
	}
<blue>	finish_rcuwait(&kvm->mn_memslots_update_rcuwait);</blue>
	rcu_assign_pointer(kvm-&gt;memslots[as_id], slots);
	spin_unlock(&amp;kvm-&gt;mn_invalidate_lock);

	/*
	 * Acquired in kvm_set_memslot. Must be released before synchronize
	 * SRCU below in order to avoid deadlock with another thread
	 * acquiring the slots_arch_lock in an srcu critical section.
	 */
	mutex_unlock(&amp;kvm-&gt;slots_arch_lock);

	synchronize_srcu_expedited(&amp;kvm-&gt;srcu);

	/*
	 * Increment the new memslot generation a second time, dropping the
	 * update in-progress flag and incrementing the generation based on
	 * the number of address spaces.  This provides a unique and easily
	 * identifiable generation number while the memslots are in flux.
	 */
	gen = slots-&gt;generation &amp; ~KVM_MEMSLOT_GEN_UPDATE_IN_PROGRESS;

	/*
	 * Generations must be unique even across address spaces.  We do not need
	 * a global counter for that, instead the generation space is evenly split
	 * across address spaces.  For example, with two address spaces, address
	 * space 0 will use generations 0, 2, 4, ... while address space 1 will
	 * use generations 1, 3, 5, ...
	 */
	gen += KVM_ADDRESS_SPACE_NUM;

	kvm_arch_memslots_updated(kvm, gen);

	slots-&gt;generation = gen;
}

static int kvm_prepare_memory_region(struct kvm *kvm,
				     const struct kvm_memory_slot *old,
				     struct kvm_memory_slot *new,
				     enum kvm_mr_change change)
{
	int r;

	/*
	 * If dirty logging is disabled, nullify the bitmap; the old bitmap
	 * will be freed on &quot;commit&quot;.  If logging is enabled in both old and
	 * new, reuse the existing bitmap.  If logging is enabled only in the
	 * new and KVM isn&#x27;t using a ring buffer, allocate and initialize a
	 * new bitmap.
	 */
<blue>	if (change != KVM_MR_DELETE) {</blue>
<blue>		if (!(new->flags & KVM_MEM_LOG_DIRTY_PAGES))</blue>
<blue>			new->dirty_bitmap = NULL;</blue>
<yellow>		else if (old && old->dirty_bitmap)</yellow>
<yellow>			new->dirty_bitmap = old->dirty_bitmap;</yellow>
<yellow>		else if (!kvm->dirty_ring_size) {</yellow>
<yellow>			r = kvm_alloc_dirty_bitmap(new);</yellow>
			if (r)
				return r;

<yellow>			if (kvm_dirty_log_manual_protect_and_init_set(kvm))</yellow>
<yellow>				bitmap_set(new->dirty_bitmap, 0, new->npages);</yellow>
		}
	}

<blue>	r = kvm_arch_prepare_memory_region(kvm, old, new, change);</blue>

	/* Free the bitmap on failure if it was allocated above. */
<yellow>	if (r && new && new->dirty_bitmap && (!old || !old->dirty_bitmap))</yellow>
<yellow>		kvm_destroy_dirty_bitmap(new);</yellow>

	return r;
}

static void kvm_commit_memory_region(struct kvm *kvm,
				     struct kvm_memory_slot *old,
				     const struct kvm_memory_slot *new,
				     enum kvm_mr_change change)
{
	/*
	 * Update the total number of memslot pages before calling the arch
	 * hook so that architectures can consume the result directly.
	 */
<blue>	if (change == KVM_MR_DELETE)</blue>
<blue>		kvm->nr_memslot_pages -= old->npages;</blue>
	else if (change == KVM_MR_CREATE)
		kvm-&gt;nr_memslot_pages += new-&gt;npages;

<yellow>	kvm_arch_commit_memory_region(kvm, old, new, change);</yellow>

	switch (change) {
	case KVM_MR_CREATE:
		/* Nothing more to do. */
		break;
	case KVM_MR_DELETE:
		/* Free the old memslot and all its metadata. */
<blue>		kvm_free_memslot(kvm, old);</blue>
		break;
	case KVM_MR_MOVE:
	case KVM_MR_FLAGS_ONLY:
		/*
		 * Free the dirty bitmap as needed; the below check encompasses
		 * both the flags and whether a ring buffer is being used)
		 */
<yellow>		if (old->dirty_bitmap && !new->dirty_bitmap)</yellow>
<yellow>			kvm_destroy_dirty_bitmap(old);</yellow>

		/*
		 * The final quirk.  Free the detached, old slot, but only its
		 * memory, not any metadata.  Metadata, including arch specific
		 * data, may be reused by @new.
		 */
<yellow>		kfree(old);</yellow>
		break;
	default:
		BUG();
	}
}

/*
 * Activate @new, which must be installed in the inactive slots by the caller,
 * by swapping the active slots and then propagating @new to @old once @old is
 * unreachable and can be safely modified.
 *
 * With NULL @old this simply adds @new to @active (while swapping the sets).
 * With NULL @new this simply removes @old from @active and frees it
 * (while also swapping the sets).
 */
static void kvm_activate_memslot(struct kvm *kvm,
				 struct kvm_memory_slot *old,
				 struct kvm_memory_slot *new)
{
<blue>	int as_id = kvm_memslots_get_as_id(old, new);</blue>

<blue>	kvm_swap_active_memslots(kvm, as_id);</blue>

	/* Propagate the new memslot to the now inactive memslots. */
	kvm_replace_memslot(kvm, old, new);
}

static void kvm_copy_memslot(struct kvm_memory_slot *dest,
			     const struct kvm_memory_slot *src)
{
<blue>	dest->base_gfn = src->base_gfn;</blue>
	dest-&gt;npages = src-&gt;npages;
	dest-&gt;dirty_bitmap = src-&gt;dirty_bitmap;
	dest-&gt;arch = src-&gt;arch;
	dest-&gt;userspace_addr = src-&gt;userspace_addr;
	dest-&gt;flags = src-&gt;flags;
	dest-&gt;id = src-&gt;id;
	dest-&gt;as_id = src-&gt;as_id;
}

static void kvm_invalidate_memslot(struct kvm *kvm,
				   struct kvm_memory_slot *old,
				   struct kvm_memory_slot *invalid_slot)
{
	/*
	 * Mark the current slot INVALID.  As with all memslot modifications,
	 * this must be done on an unreachable slot to avoid modifying the
	 * current slot in the active tree.
	 */
<blue>	kvm_copy_memslot(invalid_slot, old);</blue>
	invalid_slot-&gt;flags |= KVM_MEMSLOT_INVALID;
	kvm_replace_memslot(kvm, old, invalid_slot);

	/*
	 * Activate the slot that is now marked INVALID, but don&#x27;t propagate
	 * the slot to the now inactive slots. The slot is either going to be
	 * deleted or recreated as a new slot.
	 */
	kvm_swap_active_memslots(kvm, old-&gt;as_id);

	/*
	 * From this point no new shadow pages pointing to a deleted, or moved,
	 * memslot will be created.  Validation of sp-&gt;gfn happens in:
	 *	- gfn_to_hva (kvm_read_guest, gfn_to_pfn)
	 *	- kvm_is_visible_gfn (mmu_check_root)
	 */
	kvm_arch_flush_shadow_memslot(kvm, old);
	kvm_arch_guest_memory_reclaimed(kvm);

	/* Was released by kvm_swap_active_memslots, reacquire. */
	mutex_lock(&amp;kvm-&gt;slots_arch_lock);

	/*
	 * Copy the arch-specific field of the newly-installed slot back to the
	 * old slot as the arch data could have changed between releasing
	 * slots_arch_lock in install_new_memslots() and re-acquiring the lock
	 * above.  Writers are required to retrieve memslots *after* acquiring
	 * slots_arch_lock, thus the active slot&#x27;s data is guaranteed to be fresh.
	 */
	old-&gt;arch = invalid_slot-&gt;arch;
}

static void kvm_create_memslot(struct kvm *kvm,
			       struct kvm_memory_slot *new)
{
	/* Add the new memslot to the inactive set and activate. */
<blue>	kvm_replace_memslot(kvm, NULL, new);</blue>
<blue>	kvm_activate_memslot(kvm, NULL, new);</blue>
}

static void kvm_delete_memslot(struct kvm *kvm,
			       struct kvm_memory_slot *old,
			       struct kvm_memory_slot *invalid_slot)
{
	/*
	 * Remove the old memslot (in the inactive memslots) by passing NULL as
	 * the &quot;new&quot; slot, and for the invalid version in the active slots.
	 */
<blue>	kvm_replace_memslot(kvm, old, NULL);</blue>
	kvm_activate_memslot(kvm, invalid_slot, NULL);
}

static void kvm_move_memslot(struct kvm *kvm,
			     struct kvm_memory_slot *old,
			     struct kvm_memory_slot *new,
			     struct kvm_memory_slot *invalid_slot)
{
	/*
	 * Replace the old memslot in the inactive slots, and then swap slots
	 * and replace the current INVALID with the new as well.
	 */
<yellow>	kvm_replace_memslot(kvm, old, new);</yellow>
	kvm_activate_memslot(kvm, invalid_slot, new);
}

static void kvm_update_flags_memslot(struct kvm *kvm,
				     struct kvm_memory_slot *old,
				     struct kvm_memory_slot *new)
{
	/*
	 * Similar to the MOVE case, but the slot doesn&#x27;t need to be zapped as
	 * an intermediate step. Instead, the old memslot is simply replaced
	 * with a new, updated copy in both memslot sets.
	 */
<yellow>	kvm_replace_memslot(kvm, old, new);</yellow>
	kvm_activate_memslot(kvm, old, new);
}

static int kvm_set_memslot(struct kvm *kvm,
			   struct kvm_memory_slot *old,
			   struct kvm_memory_slot *new,
			   enum kvm_mr_change change)
{
	struct kvm_memory_slot *invalid_slot;
	int r;

	/*
	 * Released in kvm_swap_active_memslots.
	 *
	 * Must be held from before the current memslots are copied until
	 * after the new memslots are installed with rcu_assign_pointer,
	 * then released before the synchronize srcu in kvm_swap_active_memslots.
	 *
	 * When modifying memslots outside of the slots_lock, must be held
	 * before reading the pointer to the current memslots until after all
	 * changes to those memslots are complete.
	 *
	 * These rules ensure that installing new memslots does not lose
	 * changes made to the previous memslots.
	 */
<blue>	mutex_lock(&kvm->slots_arch_lock);</blue>

	/*
	 * Invalidate the old slot if it&#x27;s being deleted or moved.  This is
	 * done prior to actually deleting/moving the memslot to allow vCPUs to
	 * continue running by ensuring there are no mappings or shadow pages
	 * for the memslot when it is deleted/moved.  Without pre-invalidation
	 * (and without a lock), a window would exist between effecting the
	 * delete/move and committing the changes in arch code where KVM or a
	 * guest could access a non-existent memslot.
	 *
	 * Modifications are done on a temporary, unreachable slot.  The old
	 * slot needs to be preserved in case a later step fails and the
	 * invalidation needs to be reverted.
	 */
	if (change == KVM_MR_DELETE || change == KVM_MR_MOVE) {
<blue>		invalid_slot = kzalloc(sizeof(*invalid_slot), GFP_KERNEL_ACCOUNT);</blue>
		if (!invalid_slot) {
<yellow>			mutex_unlock(&kvm->slots_arch_lock);</yellow>
			return -ENOMEM;
		}
<blue>		kvm_invalidate_memslot(kvm, old, invalid_slot);</blue>
	}

<blue>	r = kvm_prepare_memory_region(kvm, old, new, change);</blue>
	if (r) {
		/*
		 * For DELETE/MOVE, revert the above INVALID change.  No
		 * modifications required since the original slot was preserved
		 * in the inactive slots.  Changing the active memslots also
		 * release slots_arch_lock.
		 */
<yellow>		if (change == KVM_MR_DELETE || change == KVM_MR_MOVE) {</yellow>
<yellow>			kvm_activate_memslot(kvm, invalid_slot, old);</yellow>
			kfree(invalid_slot);
		} else {
<yellow>			mutex_unlock(&kvm->slots_arch_lock);</yellow>
		}
		return r;
	}

	/*
	 * For DELETE and MOVE, the working slot is now active as the INVALID
	 * version of the old slot.  MOVE is particularly special as it reuses
	 * the old slot and returns a copy of the old slot (in working_slot).
	 * For CREATE, there is no old slot.  For DELETE and FLAGS_ONLY, the
	 * old slot is detached but otherwise preserved.
	 */
<blue>	if (change == KVM_MR_CREATE)</blue>
<blue>		kvm_create_memslot(kvm, new);</blue>
	else if (change == KVM_MR_DELETE)
<blue>		kvm_delete_memslot(kvm, old, invalid_slot);</blue>
<yellow>	else if (change == KVM_MR_MOVE)</yellow>
<yellow>		kvm_move_memslot(kvm, old, new, invalid_slot);</yellow>
	else if (change == KVM_MR_FLAGS_ONLY)
<yellow>		kvm_update_flags_memslot(kvm, old, new);</yellow>
	else
		BUG();

	/* Free the temporary INVALID slot used for DELETE and MOVE. */
	if (change == KVM_MR_DELETE || change == KVM_MR_MOVE)
<blue>		kfree(invalid_slot);</blue>

	/*
	 * No need to refresh new-&gt;arch, changes after dropping slots_arch_lock
	 * will directly hit the final, active memslot.  Architectures are
	 * responsible for knowing that new-&gt;arch may be stale.
	 */
<blue>	kvm_commit_memory_region(kvm, old, new, change);</blue>

	return 0;
<blue>}</blue>

static bool kvm_check_memslot_overlap(struct kvm_memslots *slots, int id,
				      gfn_t start, gfn_t end)
{
	struct kvm_memslot_iter iter;

<blue>	kvm_for_each_memslot_in_gfn_range(&iter, slots, start, end) {</blue>
<yellow>		if (iter.slot->id != id)</yellow>
			return true;
	}

	return false;
}

/*
 * Allocate some memory and give it an address in the guest physical address
 * space.
 *
 * Discontiguous memory is allowed, mostly for framebuffers.
 *
 * Must be called holding kvm-&gt;slots_lock for write.
 */
int __kvm_set_memory_region(struct kvm *kvm,
			    const struct kvm_userspace_memory_region *mem)
{
	struct kvm_memory_slot *old, *new;
	struct kvm_memslots *slots;
	enum kvm_mr_change change;
	unsigned long npages;
	gfn_t base_gfn;
	int as_id, id;
	int r;

<blue>	r = check_memory_region_flags(mem);</blue>
	if (r)
		return r;

<blue>	as_id = mem->slot >> 16;</blue>
	id = (u16)mem-&gt;slot;

	/* General sanity checks */
	if ((mem-&gt;memory_size &amp; (PAGE_SIZE - 1)) ||
	    (mem-&gt;memory_size != (unsigned long)mem-&gt;memory_size))
		return -EINVAL;
<blue>	if (mem->guest_phys_addr & (PAGE_SIZE - 1))</blue>
		return -EINVAL;
	/* We can read the guest memory with __xxx_user() later on. */
<blue>	if ((mem->userspace_addr & (PAGE_SIZE - 1)) ||</blue>
	    (mem-&gt;userspace_addr != untagged_addr(mem-&gt;userspace_addr)) ||
<blue>	     !access_ok((void __user *)(unsigned long)mem->userspace_addr,</blue>
			mem-&gt;memory_size))
		return -EINVAL;
<blue>	if (as_id >= KVM_ADDRESS_SPACE_NUM || id >= KVM_MEM_SLOTS_NUM)</blue>
		return -EINVAL;
<blue>	if (mem->guest_phys_addr + mem->memory_size < mem->guest_phys_addr)</blue>
		return -EINVAL;
<blue>	if ((mem->memory_size >> PAGE_SHIFT) > KVM_MEM_MAX_NR_PAGES)</blue>
		return -EINVAL;

<blue>	slots = __kvm_memslots(kvm, as_id);</blue>

	/*
	 * Note, the old memslot (and the pointer itself!) may be invalidated
	 * and/or destroyed by kvm_set_memslot().
	 */
<blue>	old = id_to_memslot(slots, id);</blue>

<blue>	if (!mem->memory_size) {</blue>
<blue>		if (!old || !old->npages)</blue>
			return -EINVAL;

<blue>		if (WARN_ON_ONCE(kvm->nr_memslot_pages < old->npages))</blue>
			return -EIO;

<blue>		return kvm_set_memslot(kvm, old, NULL, KVM_MR_DELETE);</blue>
	}

<blue>	base_gfn = (mem->guest_phys_addr >> PAGE_SHIFT);</blue>
	npages = (mem-&gt;memory_size &gt;&gt; PAGE_SHIFT);

<yellow>	if (!old || !old->npages) {</yellow>
		change = KVM_MR_CREATE;

		/*
		 * To simplify KVM internals, the total number of pages across
		 * all memslots must fit in an unsigned long.
		 */
<blue>		if ((kvm->nr_memslot_pages + npages) < kvm->nr_memslot_pages)</blue>
			return -EINVAL;
	} else { /* Modify an existing slot. */
<yellow>		if ((mem->userspace_addr != old->userspace_addr) ||</yellow>
		    (npages != old-&gt;npages) ||
<yellow>		    ((mem->flags ^ old->flags) & KVM_MEM_READONLY))</yellow>
			return -EINVAL;

<yellow>		if (base_gfn != old->base_gfn)</yellow>
			change = KVM_MR_MOVE;
<yellow>		else if (mem->flags != old->flags)</yellow>
			change = KVM_MR_FLAGS_ONLY;
		else /* Nothing to change. */
			return 0;
	}

	if ((change == KVM_MR_CREATE || change == KVM_MR_MOVE) &amp;&amp;
<blue>	    kvm_check_memslot_overlap(slots, id, base_gfn, base_gfn + npages))</blue>
<yellow>		return -EEXIST;</yellow>

	/* Allocate a slot that will persist in the memslot. */
<blue>	new = kzalloc(sizeof(*new), GFP_KERNEL_ACCOUNT);</blue>
	if (!new)
		return -ENOMEM;

<blue>	new->as_id = as_id;</blue>
	new-&gt;id = id;
	new-&gt;base_gfn = base_gfn;
	new-&gt;npages = npages;
	new-&gt;flags = mem-&gt;flags;
	new-&gt;userspace_addr = mem-&gt;userspace_addr;

	r = kvm_set_memslot(kvm, old, new, change);
	if (r)
<yellow>		kfree(new);</yellow>
	return r;
<blue>}</blue>
EXPORT_SYMBOL_GPL(__kvm_set_memory_region);

int kvm_set_memory_region(struct kvm *kvm,
			  const struct kvm_userspace_memory_region *mem)
{
	int r;

<blue>	mutex_lock(&kvm->slots_lock);</blue>
	r = __kvm_set_memory_region(kvm, mem);
	mutex_unlock(&amp;kvm-&gt;slots_lock);
	return r;
}
EXPORT_SYMBOL_GPL(kvm_set_memory_region);

static int kvm_vm_ioctl_set_memory_region(struct kvm *kvm,
					  struct kvm_userspace_memory_region *mem)
{
<blue>	if ((u16)mem->slot >= KVM_USER_MEM_SLOTS)</blue>
		return -EINVAL;

<blue>	return kvm_set_memory_region(kvm, mem);</blue>
}

#ifndef CONFIG_KVM_GENERIC_DIRTYLOG_READ_PROTECT
/**
 * kvm_get_dirty_log - get a snapshot of dirty pages
 * @kvm:	pointer to kvm instance
 * @log:	slot id and address to which we copy the log
 * @is_dirty:	set to &#x27;1&#x27; if any dirty pages were found
 * @memslot:	set to the associated memslot, always valid on success
 */
int kvm_get_dirty_log(struct kvm *kvm, struct kvm_dirty_log *log,
		      int *is_dirty, struct kvm_memory_slot **memslot)
{
	struct kvm_memslots *slots;
	int i, as_id, id;
	unsigned long n;
	unsigned long any = 0;

	/* Dirty ring tracking is exclusive to dirty log tracking */
	if (kvm-&gt;dirty_ring_size)
		return -ENXIO;

	*memslot = NULL;
	*is_dirty = 0;

	as_id = log-&gt;slot &gt;&gt; 16;
	id = (u16)log-&gt;slot;
	if (as_id &gt;= KVM_ADDRESS_SPACE_NUM || id &gt;= KVM_USER_MEM_SLOTS)
		return -EINVAL;

	slots = __kvm_memslots(kvm, as_id);
	*memslot = id_to_memslot(slots, id);
	if (!(*memslot) || !(*memslot)-&gt;dirty_bitmap)
		return -ENOENT;

	kvm_arch_sync_dirty_log(kvm, *memslot);

	n = kvm_dirty_bitmap_bytes(*memslot);

	for (i = 0; !any &amp;&amp; i &lt; n/sizeof(long); ++i)
		any = (*memslot)-&gt;dirty_bitmap[i];

	if (copy_to_user(log-&gt;dirty_bitmap, (*memslot)-&gt;dirty_bitmap, n))
		return -EFAULT;

	if (any)
		*is_dirty = 1;
	return 0;
}
EXPORT_SYMBOL_GPL(kvm_get_dirty_log);

#else /* CONFIG_KVM_GENERIC_DIRTYLOG_READ_PROTECT */
/**
 * kvm_get_dirty_log_protect - get a snapshot of dirty pages
 *	and reenable dirty page tracking for the corresponding pages.
 * @kvm:	pointer to kvm instance
 * @log:	slot id and address to which we copy the log
 *
 * We need to keep it in mind that VCPU threads can write to the bitmap
 * concurrently. So, to avoid losing track of dirty pages we keep the
 * following order:
 *
 *    1. Take a snapshot of the bit and clear it if needed.
 *    2. Write protect the corresponding page.
 *    3. Copy the snapshot to the userspace.
 *    4. Upon return caller flushes TLB&#x27;s if needed.
 *
 * Between 2 and 4, the guest may write to the page using the remaining TLB
 * entry.  This is not a problem because the page is reported dirty using
 * the snapshot taken before and step 4 ensures that writes done after
 * exiting to userspace will be logged for the next call.
 *
 */
static int kvm_get_dirty_log_protect(struct kvm *kvm, struct kvm_dirty_log *log)
{
	struct kvm_memslots *slots;
	struct kvm_memory_slot *memslot;
	int i, as_id, id;
	unsigned long n;
	unsigned long *dirty_bitmap;
	unsigned long *dirty_bitmap_buffer;
	bool flush;

	/* Dirty ring tracking is exclusive to dirty log tracking */
<yellow>	if (kvm->dirty_ring_size)</yellow>
		return -ENXIO;

<yellow>	as_id = log->slot >> 16;</yellow>
	id = (u16)log-&gt;slot;
<yellow>	if (as_id >= KVM_ADDRESS_SPACE_NUM || id >= KVM_USER_MEM_SLOTS)</yellow>
		return -EINVAL;

<yellow>	slots = __kvm_memslots(kvm, as_id);</yellow>
<yellow>	memslot = id_to_memslot(slots, id);</yellow>
<yellow>	if (!memslot || !memslot->dirty_bitmap)</yellow>
		return -ENOENT;

	dirty_bitmap = memslot-&gt;dirty_bitmap;

<yellow>	kvm_arch_sync_dirty_log(kvm, memslot);</yellow>

	n = kvm_dirty_bitmap_bytes(memslot);
	flush = false;
	if (kvm-&gt;manual_dirty_log_protect) {
		/*
		 * Unlike kvm_get_dirty_log, we always return false in *flush,
		 * because no flush is needed until KVM_CLEAR_DIRTY_LOG.  There
		 * is some code duplication between this function and
		 * kvm_get_dirty_log, but hopefully all architecture
		 * transition to kvm_get_dirty_log_protect and kvm_get_dirty_log
		 * can be eliminated.
		 */
		dirty_bitmap_buffer = dirty_bitmap;
	} else {
<yellow>		dirty_bitmap_buffer = kvm_second_dirty_bitmap(memslot);</yellow>
		memset(dirty_bitmap_buffer, 0, n);

		KVM_MMU_LOCK(kvm);
<yellow>		for (i = 0; i < n / sizeof(long); i++) {</yellow>
			unsigned long mask;
			gfn_t offset;

<yellow>			if (!dirty_bitmap[i])</yellow>
				continue;

			flush = true;
<yellow>			mask = xchg(&dirty_bitmap[i], 0);</yellow>
			dirty_bitmap_buffer[i] = mask;

			offset = i * BITS_PER_LONG;
			kvm_arch_mmu_enable_log_dirty_pt_masked(kvm, memslot,
								offset, mask);
		}
<yellow>		KVM_MMU_UNLOCK(kvm);</yellow>
	}

	if (flush)
<yellow>		kvm_arch_flush_remote_tlbs_memslot(kvm, memslot);</yellow>

<yellow>	if (copy_to_user(log->dirty_bitmap, dirty_bitmap_buffer, n))</yellow>
		return -EFAULT;
	return 0;
<yellow>}</yellow>


/**
 * kvm_vm_ioctl_get_dirty_log - get and clear the log of dirty pages in a slot
 * @kvm: kvm instance
 * @log: slot id and address to which we copy the log
 *
 * Steps 1-4 below provide general overview of dirty page logging. See
 * kvm_get_dirty_log_protect() function description for additional details.
 *
 * We call kvm_get_dirty_log_protect() to handle steps 1-3, upon return we
 * always flush the TLB (step 4) even if previous step failed  and the dirty
 * bitmap may be corrupt. Regardless of previous outcome the KVM logging API
 * does not preclude user space subsequent dirty log read. Flushing TLB ensures
 * writes will be marked dirty for next log read.
 *
 *   1. Take a snapshot of the bit and clear it if needed.
 *   2. Write protect the corresponding page.
 *   3. Copy the snapshot to the userspace.
 *   4. Flush TLB&#x27;s if needed.
 */
static int kvm_vm_ioctl_get_dirty_log(struct kvm *kvm,
				      struct kvm_dirty_log *log)
{
	int r;

<yellow>	mutex_lock(&kvm->slots_lock);</yellow>

	r = kvm_get_dirty_log_protect(kvm, log);

	mutex_unlock(&amp;kvm-&gt;slots_lock);
	return r;
}

/**
 * kvm_clear_dirty_log_protect - clear dirty bits in the bitmap
 *	and reenable dirty page tracking for the corresponding pages.
 * @kvm:	pointer to kvm instance
 * @log:	slot id and address from which to fetch the bitmap of dirty pages
 */
static int kvm_clear_dirty_log_protect(struct kvm *kvm,
				       struct kvm_clear_dirty_log *log)
{
	struct kvm_memslots *slots;
	struct kvm_memory_slot *memslot;
	int as_id, id;
	gfn_t offset;
	unsigned long i, n;
	unsigned long *dirty_bitmap;
	unsigned long *dirty_bitmap_buffer;
	bool flush;

	/* Dirty ring tracking is exclusive to dirty log tracking */
<yellow>	if (kvm->dirty_ring_size)</yellow>
		return -ENXIO;

<yellow>	as_id = log->slot >> 16;</yellow>
	id = (u16)log-&gt;slot;
<yellow>	if (as_id >= KVM_ADDRESS_SPACE_NUM || id >= KVM_USER_MEM_SLOTS)</yellow>
		return -EINVAL;

<yellow>	if (log->first_page & 63)</yellow>
		return -EINVAL;

<yellow>	slots = __kvm_memslots(kvm, as_id);</yellow>
<yellow>	memslot = id_to_memslot(slots, id);</yellow>
<yellow>	if (!memslot || !memslot->dirty_bitmap)</yellow>
		return -ENOENT;

	dirty_bitmap = memslot-&gt;dirty_bitmap;

<yellow>	n = ALIGN(log->num_pages, BITS_PER_LONG) / 8;</yellow>

	if (log-&gt;first_page &gt; memslot-&gt;npages ||
<yellow>	    log->num_pages > memslot->npages - log->first_page ||</yellow>
<yellow>	    (log->num_pages < memslot->npages - log->first_page && (log->num_pages & 63)))</yellow>
	    return -EINVAL;

<yellow>	kvm_arch_sync_dirty_log(kvm, memslot);</yellow>

	flush = false;
	dirty_bitmap_buffer = kvm_second_dirty_bitmap(memslot);
	if (copy_from_user(dirty_bitmap_buffer, log-&gt;dirty_bitmap, n))
		return -EFAULT;

<yellow>	KVM_MMU_LOCK(kvm);</yellow>
	for (offset = log-&gt;first_page, i = offset / BITS_PER_LONG,
<yellow>		 n = DIV_ROUND_UP(log->num_pages, BITS_PER_LONG); n--;</yellow>
	     i++, offset += BITS_PER_LONG) {
<yellow>		unsigned long mask = *dirty_bitmap_buffer++;</yellow>
		atomic_long_t *p = (atomic_long_t *) &amp;dirty_bitmap[i];
		if (!mask)
			continue;

<yellow>		mask &= atomic_long_fetch_andnot(mask, p);</yellow>

		/*
		 * mask contains the bits that really have been cleared.  This
		 * never includes any bits beyond the length of the memslot (if
		 * the length is not aligned to 64 pages), therefore it is not
		 * a problem if userspace sets them in log-&gt;dirty_bitmap.
		*/
		if (mask) {
			flush = true;
<yellow>			kvm_arch_mmu_enable_log_dirty_pt_masked(kvm, memslot,</yellow>
								offset, mask);
		}
	}
<yellow>	KVM_MMU_UNLOCK(kvm);</yellow>

	if (flush)
<yellow>		kvm_arch_flush_remote_tlbs_memslot(kvm, memslot);</yellow>

	return 0;
<yellow>}</yellow>

static int kvm_vm_ioctl_clear_dirty_log(struct kvm *kvm,
					struct kvm_clear_dirty_log *log)
{
	int r;

<yellow>	mutex_lock(&kvm->slots_lock);</yellow>

	r = kvm_clear_dirty_log_protect(kvm, log);

	mutex_unlock(&amp;kvm-&gt;slots_lock);
	return r;
}
#endif /* CONFIG_KVM_GENERIC_DIRTYLOG_READ_PROTECT */

struct kvm_memory_slot *gfn_to_memslot(struct kvm *kvm, gfn_t gfn)
{
<blue>	return __gfn_to_memslot(kvm_memslots(kvm), gfn);</blue>
<blue>}</blue>
EXPORT_SYMBOL_GPL(gfn_to_memslot);

struct kvm_memory_slot *kvm_vcpu_gfn_to_memslot(struct kvm_vcpu *vcpu, gfn_t gfn)
{
<blue>	struct kvm_memslots *slots = kvm_vcpu_memslots(vcpu);</blue>
	u64 gen = slots-&gt;generation;
	struct kvm_memory_slot *slot;

	/*
	 * This also protects against using a memslot from a different address space,
	 * since different address spaces have different generation numbers.
	 */
	if (unlikely(gen != vcpu-&gt;last_used_slot_gen)) {
<blue>		vcpu->last_used_slot = NULL;</blue>
		vcpu-&gt;last_used_slot_gen = gen;
	}

<blue>	slot = try_get_memslot(vcpu->last_used_slot, gfn);</blue>
	if (slot)
		return slot;

	/*
	 * Fall back to searching all memslots. We purposely use
	 * search_memslots() instead of __gfn_to_memslot() to avoid
	 * thrashing the VM-wide last_used_slot in kvm_memslots.
	 */
<blue>	slot = search_memslots(slots, gfn, false);</blue>
<blue>	if (slot) {</blue>
<blue>		vcpu->last_used_slot = slot;</blue>
		return slot;
	}

	return NULL;
<blue>}</blue>

bool kvm_is_visible_gfn(struct kvm *kvm, gfn_t gfn)
{
<yellow>	struct kvm_memory_slot *memslot = gfn_to_memslot(kvm, gfn);</yellow>

<yellow>	return kvm_is_visible_memslot(memslot);</yellow>
<yellow>}</yellow>
EXPORT_SYMBOL_GPL(kvm_is_visible_gfn);

bool kvm_vcpu_is_visible_gfn(struct kvm_vcpu *vcpu, gfn_t gfn)
{
<blue>	struct kvm_memory_slot *memslot = kvm_vcpu_gfn_to_memslot(vcpu, gfn);</blue>

<blue>	return kvm_is_visible_memslot(memslot);</blue>
<blue>}</blue>
EXPORT_SYMBOL_GPL(kvm_vcpu_is_visible_gfn);

unsigned long kvm_host_page_size(struct kvm_vcpu *vcpu, gfn_t gfn)
{
	struct vm_area_struct *vma;
	unsigned long addr, size;

	size = PAGE_SIZE;

<yellow>	addr = kvm_vcpu_gfn_to_hva_prot(vcpu, gfn, NULL);</yellow>
	if (kvm_is_error_hva(addr))
<yellow>		return PAGE_SIZE;</yellow>

<yellow>	mmap_read_lock(current->mm);</yellow>
<yellow>	vma = find_vma(current->mm, addr);</yellow>
	if (!vma)
		goto out;

<yellow>	size = vma_kernel_pagesize(vma);</yellow>

out:
<yellow>	mmap_read_unlock(current->mm);</yellow>

	return size;
<yellow>}</yellow>

static bool memslot_is_readonly(const struct kvm_memory_slot *slot)
{
<blue>	return slot->flags & KVM_MEM_READONLY;</blue>
}

<blue>static unsigned long __gfn_to_hva_many(const struct kvm_memory_slot *slot, gfn_t gfn,</blue>
				       gfn_t *nr_pages, bool write)
{
<blue>	if (!slot || slot->flags & KVM_MEMSLOT_INVALID)</blue>
<blue>		return KVM_HVA_ERR_BAD;</blue>

<blue>	if (memslot_is_readonly(slot) && write)</blue>
<blue>		return KVM_HVA_ERR_RO_BAD;</blue>

<blue>	if (nr_pages)</blue>
<blue>		*nr_pages = slot->npages - (gfn - slot->base_gfn);</blue>

<blue>	return __gfn_to_hva_memslot(slot, gfn);</blue>
<blue>}</blue>

static unsigned long gfn_to_hva_many(struct kvm_memory_slot *slot, gfn_t gfn,
				     gfn_t *nr_pages)
{
<blue>	return __gfn_to_hva_many(slot, gfn, nr_pages, true);</blue>
}

unsigned long gfn_to_hva_memslot(struct kvm_memory_slot *slot,
					gfn_t gfn)
{
<blue>	return gfn_to_hva_many(slot, gfn, NULL);</blue>
<yellow>}</yellow>
EXPORT_SYMBOL_GPL(gfn_to_hva_memslot);

unsigned long gfn_to_hva(struct kvm *kvm, gfn_t gfn)
{
<blue>	return gfn_to_hva_many(gfn_to_memslot(kvm, gfn), gfn, NULL);</blue>
<blue>}</blue>
EXPORT_SYMBOL_GPL(gfn_to_hva);

unsigned long kvm_vcpu_gfn_to_hva(struct kvm_vcpu *vcpu, gfn_t gfn)
{
<blue>	return gfn_to_hva_many(kvm_vcpu_gfn_to_memslot(vcpu, gfn), gfn, NULL);</blue>
<blue>}</blue>
EXPORT_SYMBOL_GPL(kvm_vcpu_gfn_to_hva);

/*
 * Return the hva of a @gfn and the R/W attribute if possible.
 *
 * @slot: the kvm_memory_slot which contains @gfn
 * @gfn: the gfn to be translated
 * @writable: used to return the read/write attribute of the @slot if the hva
 * is valid and @writable is not NULL
 */
<blue>unsigned long gfn_to_hva_memslot_prot(struct kvm_memory_slot *slot,</blue>
				      gfn_t gfn, bool *writable)
{
<blue>	unsigned long hva = __gfn_to_hva_many(slot, gfn, NULL, false);</blue>

<blue>	if (!kvm_is_error_hva(hva) && writable)</blue>
<blue>		*writable = !memslot_is_readonly(slot);</blue>

	return hva;
<yellow>}</yellow>

unsigned long gfn_to_hva_prot(struct kvm *kvm, gfn_t gfn, bool *writable)
{
<yellow>	struct kvm_memory_slot *slot = gfn_to_memslot(kvm, gfn);</yellow>

<yellow>	return gfn_to_hva_memslot_prot(slot, gfn, writable);</yellow>
<yellow>}</yellow>

unsigned long kvm_vcpu_gfn_to_hva_prot(struct kvm_vcpu *vcpu, gfn_t gfn, bool *writable)
{
<blue>	struct kvm_memory_slot *slot = kvm_vcpu_gfn_to_memslot(vcpu, gfn);</blue>

<blue>	return gfn_to_hva_memslot_prot(slot, gfn, writable);</blue>
<blue>}</blue>

static inline int check_user_page_hwpoison(unsigned long addr)
{
	int rc, flags = FOLL_HWPOISON | FOLL_WRITE;

<yellow>	rc = get_user_pages(addr, 1, flags, NULL, NULL);</yellow>
	return rc == -EHWPOISON;
}

/*
 * The fast path to get the writable pfn which will be stored in @pfn,
 * true indicates success, otherwise false is returned.  It&#x27;s also the
 * only part that runs if we can in atomic context.
 */
static bool hva_to_pfn_fast(unsigned long addr, bool write_fault,
			    bool *writable, kvm_pfn_t *pfn)
{
	struct page *page[1];

	/*
	 * Fast pin a writable pfn only if it is a write fault request
	 * or the caller allows to map a writable pfn for a read fault
	 * request.
	 */
<blue>	if (!(write_fault || writable))</blue>
		return false;

<blue>	if (get_user_page_fast_only(addr, FOLL_WRITE, page)) {</blue>
<blue>		*pfn = page_to_pfn(page[0]);</blue>

<blue>		if (writable)</blue>
<blue>			*writable = true;</blue>
		return true;
	}

	return false;
}

/*
 * The slow path to get the pfn of the specified host virtual address,
 * 1 indicates success, -errno is returned if error is detected.
 */
static int hva_to_pfn_slow(unsigned long addr, bool *async, bool write_fault,
			   bool *writable, kvm_pfn_t *pfn)
{
	unsigned int flags = FOLL_HWPOISON;
	struct page *page;
	int npages;

<blue>	might_sleep();</blue>

	if (writable)
<blue>		*writable = write_fault;</blue>

<blue>	if (write_fault)</blue>
		flags |= FOLL_WRITE;
	if (async)
<blue>		flags |= FOLL_NOWAIT;</blue>

<blue>	npages = get_user_pages_unlocked(addr, 1, &page, flags);</blue>
	if (npages != 1)
		return npages;

	/* map read fault as writable if possible */
<blue>	if (unlikely(!write_fault) && writable) {</blue>
		struct page *wpage;

<blue>		if (get_user_page_fast_only(addr, FOLL_WRITE, &wpage)) {</blue>
<blue>			*writable = true;</blue>
<blue>			put_page(page);</blue>
<blue>			page = wpage;</blue>
		}
	}
<blue>	*pfn = page_to_pfn(page);</blue>
	return npages;
}

static bool vma_is_valid(struct vm_area_struct *vma, bool write_fault)
{
<yellow>	if (unlikely(!(vma->vm_flags & VM_READ)))</yellow>
		return false;

<yellow>	if (write_fault && (unlikely(!(vma->vm_flags & VM_WRITE))))</yellow>
		return false;

	return true;
}

static int kvm_try_get_pfn(kvm_pfn_t pfn)
{
<yellow>	struct page *page = kvm_pfn_to_refcounted_page(pfn);</yellow>

	if (!page)
		return 1;

<yellow>	return get_page_unless_zero(page);</yellow>
}

static int hva_to_pfn_remapped(struct vm_area_struct *vma,
			       unsigned long addr, bool write_fault,
			       bool *writable, kvm_pfn_t *p_pfn)
{
	kvm_pfn_t pfn;
	pte_t *ptep;
	spinlock_t *ptl;
	int r;

<yellow>	r = follow_pte(vma->vm_mm, addr, &ptep, &ptl);</yellow>
	if (r) {
		/*
		 * get_user_pages fails for VM_IO and VM_PFNMAP vmas and does
		 * not call the fault handler, so do it here.
		 */
		bool unlocked = false;
<yellow>		r = fixup_user_fault(current->mm, addr,</yellow>
				     (write_fault ? FAULT_FLAG_WRITE : 0),
				     &amp;unlocked);
<yellow>		if (unlocked)</yellow>
			return -EAGAIN;
<yellow>		if (r)</yellow>
			return r;

<yellow>		r = follow_pte(vma->vm_mm, addr, &ptep, &ptl);</yellow>
<yellow>		if (r)</yellow>
			return r;
	}

<yellow>	if (write_fault && !pte_write(*ptep)) {</yellow>
		pfn = KVM_PFN_ERR_RO_FAULT;
		goto out;
	}

<yellow>	if (writable)</yellow>
<yellow>		*writable = pte_write(*ptep);</yellow>
<yellow>	pfn = pte_pfn(*ptep);</yellow>

	/*
	 * Get a reference here because callers of *hva_to_pfn* and
	 * *gfn_to_pfn* ultimately call kvm_release_pfn_clean on the
	 * returned pfn.  This is only needed if the VMA has VM_MIXEDMAP
	 * set, but the kvm_try_get_pfn/kvm_release_pfn_clean pair will
	 * simply do nothing for reserved pfns.
	 *
	 * Whoever called remap_pfn_range is also going to call e.g.
	 * unmap_mapping_range before the underlying pages are freed,
	 * causing a call to our MMU notifier.
	 *
	 * Certain IO or PFNMAP mappings can be backed with valid
	 * struct pages, but be allocated without refcounting e.g.,
	 * tail pages of non-compound higher order allocations, which
	 * would then underflow the refcount when the caller does the
	 * required put_page. Don&#x27;t allow those pages here.
	 */ 
<yellow>	if (!kvm_try_get_pfn(pfn))</yellow>
		r = -EFAULT;

out:
<yellow>	pte_unmap_unlock(ptep, ptl);</yellow>
	*p_pfn = pfn;

	return r;
}

/*
 * Pin guest page in memory and return its pfn.
 * @addr: host virtual address which maps memory to the guest
 * @atomic: whether this function can sleep
 * @async: whether this function need to wait IO complete if the
 *         host page is not in the memory
 * @write_fault: whether we should get a writable host page
 * @writable: whether it allows to map a writable host page for !@write_fault
 *
 * The function will map a writable host page for these two cases:
 * 1): @write_fault = true
 * 2): @write_fault = false &amp;&amp; @writable, @writable will tell the caller
 *     whether the mapping is writable.
 */
kvm_pfn_t hva_to_pfn(unsigned long addr, bool atomic, bool *async,
		     bool write_fault, bool *writable)
<blue>{</blue>
	struct vm_area_struct *vma;
	kvm_pfn_t pfn;
	int npages, r;

	/* we can do it either atomically or asynchronously, not both */
<blue>	BUG_ON(atomic && async);</blue>

<blue>	if (hva_to_pfn_fast(addr, write_fault, writable, &pfn))</blue>
		return pfn;

<blue>	if (atomic)</blue>
		return KVM_PFN_ERR_FAULT;

<blue>	npages = hva_to_pfn_slow(addr, async, write_fault, writable, &pfn);</blue>
	if (npages == 1)
		return pfn;

<yellow>	mmap_read_lock(current->mm);</yellow>
<yellow>	if (npages == -EHWPOISON ||</yellow>
<yellow>	      (!async && check_user_page_hwpoison(addr))) {</yellow>
		pfn = KVM_PFN_ERR_HWPOISON;
		goto exit;
	}

retry:
<yellow>	vma = vma_lookup(current->mm, addr);</yellow>

	if (vma == NULL)
		pfn = KVM_PFN_ERR_FAULT;
<yellow>	else if (vma->vm_flags & (VM_IO | VM_PFNMAP)) {</yellow>
<yellow>		r = hva_to_pfn_remapped(vma, addr, write_fault, writable, &pfn);</yellow>
<yellow>		if (r == -EAGAIN)</yellow>
			goto retry;
<yellow>		if (r < 0)</yellow>
			pfn = KVM_PFN_ERR_FAULT;
	} else {
<yellow>		if (async && vma_is_valid(vma, write_fault))</yellow>
<yellow>			*async = true;</yellow>
		pfn = KVM_PFN_ERR_FAULT;
	}
exit:
<yellow>	mmap_read_unlock(current->mm);</yellow>
	return pfn;
}

kvm_pfn_t __gfn_to_pfn_memslot(const struct kvm_memory_slot *slot, gfn_t gfn,
			       bool atomic, bool *async, bool write_fault,
			       bool *writable, hva_t *hva)
{
<blue>	unsigned long addr = __gfn_to_hva_many(slot, gfn, NULL, write_fault);</blue>

<blue>	if (hva)</blue>
<blue>		*hva = addr;</blue>

<blue>	if (addr == KVM_HVA_ERR_RO_BAD) {</blue>
<blue>		if (writable)</blue>
<blue>			*writable = false;</blue>
<yellow>		return KVM_PFN_ERR_RO_FAULT;</yellow>
	}

<blue>	if (kvm_is_error_hva(addr)) {</blue>
		if (writable)
<blue>			*writable = false;</blue>
<blue>		return KVM_PFN_NOSLOT;</blue>
	}

	/* Do not map writable pfn in the readonly memslot. */
<blue>	if (writable && memslot_is_readonly(slot)) {</blue>
<blue>		*writable = false;</blue>
		writable = NULL;
	}

<blue>	return hva_to_pfn(addr, atomic, async, write_fault,</blue>
			  writable);
<blue>}</blue>
EXPORT_SYMBOL_GPL(__gfn_to_pfn_memslot);

kvm_pfn_t gfn_to_pfn_prot(struct kvm *kvm, gfn_t gfn, bool write_fault,
		      bool *writable)
{
<yellow>	return __gfn_to_pfn_memslot(gfn_to_memslot(kvm, gfn), gfn, false, NULL,</yellow>
				    write_fault, writable, NULL);
<yellow>}</yellow>
EXPORT_SYMBOL_GPL(gfn_to_pfn_prot);

kvm_pfn_t gfn_to_pfn_memslot(const struct kvm_memory_slot *slot, gfn_t gfn)
{
<blue>	return __gfn_to_pfn_memslot(slot, gfn, false, NULL, true, NULL, NULL);</blue>
<yellow>}</yellow>
EXPORT_SYMBOL_GPL(gfn_to_pfn_memslot);

kvm_pfn_t gfn_to_pfn_memslot_atomic(const struct kvm_memory_slot *slot, gfn_t gfn)
{
<yellow>	return __gfn_to_pfn_memslot(slot, gfn, true, NULL, true, NULL, NULL);</yellow>
<yellow>}</yellow>
EXPORT_SYMBOL_GPL(gfn_to_pfn_memslot_atomic);

kvm_pfn_t kvm_vcpu_gfn_to_pfn_atomic(struct kvm_vcpu *vcpu, gfn_t gfn)
{
<yellow>	return gfn_to_pfn_memslot_atomic(kvm_vcpu_gfn_to_memslot(vcpu, gfn), gfn);</yellow>
<yellow>}</yellow>
EXPORT_SYMBOL_GPL(kvm_vcpu_gfn_to_pfn_atomic);

kvm_pfn_t gfn_to_pfn(struct kvm *kvm, gfn_t gfn)
{
<blue>	return gfn_to_pfn_memslot(gfn_to_memslot(kvm, gfn), gfn);</blue>
<blue>}</blue>
EXPORT_SYMBOL_GPL(gfn_to_pfn);

kvm_pfn_t kvm_vcpu_gfn_to_pfn(struct kvm_vcpu *vcpu, gfn_t gfn)
{
<yellow>	return gfn_to_pfn_memslot(kvm_vcpu_gfn_to_memslot(vcpu, gfn), gfn);</yellow>
<yellow>}</yellow>
EXPORT_SYMBOL_GPL(kvm_vcpu_gfn_to_pfn);

int gfn_to_page_many_atomic(struct kvm_memory_slot *slot, gfn_t gfn,
			    struct page **pages, int nr_pages)
{
	unsigned long addr;
	gfn_t entry = 0;

<blue>	addr = gfn_to_hva_many(slot, gfn, &entry);</blue>
<blue>	if (kvm_is_error_hva(addr))</blue>
		return -1;

<blue>	if (entry < nr_pages)</blue>
		return 0;

<blue>	return get_user_pages_fast_only(addr, nr_pages, FOLL_WRITE, pages);</blue>
<blue>}</blue>
EXPORT_SYMBOL_GPL(gfn_to_page_many_atomic);

/*
 * Do not use this helper unless you are absolutely certain the gfn _must_ be
 * backed by &#x27;struct page&#x27;.  A valid example is if the backing memslot is
 * controlled by KVM.  Note, if the returned page is valid, it&#x27;s refcount has
 * been elevated by gfn_to_pfn().
 */
struct page *gfn_to_page(struct kvm *kvm, gfn_t gfn)
{
	struct page *page;
	kvm_pfn_t pfn;

<blue>	pfn = gfn_to_pfn(kvm, gfn);</blue>

	if (is_error_noslot_pfn(pfn))
		return KVM_ERR_PTR_BAD_PAGE;

<blue>	page = kvm_pfn_to_refcounted_page(pfn);</blue>
	if (!page)
		return KVM_ERR_PTR_BAD_PAGE;

	return page;
<blue>}</blue>
EXPORT_SYMBOL_GPL(gfn_to_page);

<blue>void kvm_release_pfn(kvm_pfn_t pfn, bool dirty)</blue>
{
<blue>	if (dirty)</blue>
<blue>		kvm_release_pfn_dirty(pfn);</blue>
	else
<blue>		kvm_release_pfn_clean(pfn);</blue>
<blue>}</blue>

int kvm_vcpu_map(struct kvm_vcpu *vcpu, gfn_t gfn, struct kvm_host_map *map)
{
	kvm_pfn_t pfn;
	void *hva = NULL;
	struct page *page = KVM_UNMAPPED_PAGE;

<blue>	if (!map)</blue>
		return -EINVAL;

<blue>	pfn = gfn_to_pfn(vcpu->kvm, gfn);</blue>
	if (is_error_noslot_pfn(pfn))
		return -EINVAL;

<blue>	if (pfn_valid(pfn)) {</blue>
<blue>		page = pfn_to_page(pfn);</blue>
		hva = kmap(page);
#ifdef CONFIG_HAS_IOMEM
	} else {
<yellow>		hva = memremap(pfn_to_hpa(pfn), PAGE_SIZE, MEMREMAP_WB);</yellow>
#endif
	}

<blue>	if (!hva)</blue>
		return -EFAULT;

<blue>	map->page = page;</blue>
	map-&gt;hva = hva;
	map-&gt;pfn = pfn;
	map-&gt;gfn = gfn;

	return 0;
<blue>}</blue>
EXPORT_SYMBOL_GPL(kvm_vcpu_map);

<blue>void kvm_vcpu_unmap(struct kvm_vcpu *vcpu, struct kvm_host_map *map, bool dirty)</blue>
{
<blue>	if (!map)</blue>
		return;

<blue>	if (!map->hva)</blue>
		return;

<blue>	if (map->page != KVM_UNMAPPED_PAGE)</blue>
		kunmap(map-&gt;page);
#ifdef CONFIG_HAS_IOMEM
	else
<yellow>		memunmap(map->hva);</yellow>
#endif

<blue>	if (dirty)</blue>
<blue>		kvm_vcpu_mark_page_dirty(vcpu, map->gfn);</blue>

<blue>	kvm_release_pfn(map->pfn, dirty);</blue>

	map-&gt;hva = NULL;
	map-&gt;page = NULL;
<blue>}</blue>
EXPORT_SYMBOL_GPL(kvm_vcpu_unmap);

static bool kvm_is_ad_tracked_page(struct page *page)
{
	/*
	 * Per page-flags.h, pages tagged PG_reserved &quot;should in general not be
	 * touched (e.g. set dirty) except by its owner&quot;.
	 */
<blue>	return !PageReserved(page);</blue>
}

<blue>static void kvm_set_page_dirty(struct page *page)</blue>
{
<blue>	if (kvm_is_ad_tracked_page(page))</blue>
<blue>		SetPageDirty(page);</blue>
}

static void kvm_set_page_accessed(struct page *page)
{
<blue>	if (kvm_is_ad_tracked_page(page))</blue>
<blue>		mark_page_accessed(page);</blue>
}

void kvm_release_page_clean(struct page *page)
{
<blue>	WARN_ON(is_error_page(page));</blue>

<blue>	kvm_set_page_accessed(page);</blue>
<blue>	put_page(page);</blue>
<blue>}</blue>
EXPORT_SYMBOL_GPL(kvm_release_page_clean);

<blue>void kvm_release_pfn_clean(kvm_pfn_t pfn)</blue>
{
	struct page *page;

<blue>	if (is_error_noslot_pfn(pfn))</blue>
		return;

<blue>	page = kvm_pfn_to_refcounted_page(pfn);</blue>
	if (!page)
		return;

<blue>	kvm_release_page_clean(page);</blue>
<blue>}</blue>
EXPORT_SYMBOL_GPL(kvm_release_pfn_clean);

void kvm_release_page_dirty(struct page *page)
{
<blue>	WARN_ON(is_error_page(page));</blue>

<blue>	kvm_set_page_dirty(page);</blue>
<blue>	kvm_release_page_clean(page);</blue>
}
EXPORT_SYMBOL_GPL(kvm_release_page_dirty);

<blue>void kvm_release_pfn_dirty(kvm_pfn_t pfn)</blue>
{
	struct page *page;

<blue>	if (is_error_noslot_pfn(pfn))</blue>
		return;

<blue>	page = kvm_pfn_to_refcounted_page(pfn);</blue>
	if (!page)
		return;

<blue>	kvm_release_page_dirty(page);</blue>
<yellow>}</yellow>
EXPORT_SYMBOL_GPL(kvm_release_pfn_dirty);

/*
 * Note, checking for an error/noslot pfn is the caller&#x27;s responsibility when
 * directly marking a page dirty/accessed.  Unlike the &quot;release&quot; helpers, the
 * &quot;set&quot; helpers are not to be used when the pfn might point at garbage.
 */
<blue>void kvm_set_pfn_dirty(kvm_pfn_t pfn)</blue>
{
<blue>	if (WARN_ON(is_error_noslot_pfn(pfn)))</blue>
		return;

<blue>	if (pfn_valid(pfn))</blue>
<blue>		kvm_set_page_dirty(pfn_to_page(pfn));</blue>
<blue>}</blue>
EXPORT_SYMBOL_GPL(kvm_set_pfn_dirty);

<blue>void kvm_set_pfn_accessed(kvm_pfn_t pfn)</blue>
{
<blue>	if (WARN_ON(is_error_noslot_pfn(pfn)))</blue>
		return;

<blue>	if (pfn_valid(pfn))</blue>
<blue>		kvm_set_page_accessed(pfn_to_page(pfn));</blue>
<blue>}</blue>
EXPORT_SYMBOL_GPL(kvm_set_pfn_accessed);

static int next_segment(unsigned long len, int offset)
{
<blue>	if (len > PAGE_SIZE - offset)</blue>
<yellow>		return PAGE_SIZE - offset;</yellow>
	else
		return len;
}

static int __kvm_read_guest_page(struct kvm_memory_slot *slot, gfn_t gfn,
				 void *data, int offset, int len)
{
	int r;
	unsigned long addr;

<blue>	addr = gfn_to_hva_memslot_prot(slot, gfn, NULL);</blue>
	if (kvm_is_error_hva(addr))
		return -EFAULT;
<blue>	r = __copy_from_user(data, (void __user *)addr + offset, len);</blue>
	if (r)
		return -EFAULT;
	return 0;
}

int kvm_read_guest_page(struct kvm *kvm, gfn_t gfn, void *data, int offset,
			int len)
{
<blue>	struct kvm_memory_slot *slot = gfn_to_memslot(kvm, gfn);</blue>

<blue>	return __kvm_read_guest_page(slot, gfn, data, offset, len);</blue>
<yellow>}</yellow>
EXPORT_SYMBOL_GPL(kvm_read_guest_page);

int kvm_vcpu_read_guest_page(struct kvm_vcpu *vcpu, gfn_t gfn, void *data,
			     int offset, int len)
{
<blue>	struct kvm_memory_slot *slot = kvm_vcpu_gfn_to_memslot(vcpu, gfn);</blue>

<blue>	return __kvm_read_guest_page(slot, gfn, data, offset, len);</blue>
<blue>}</blue>
EXPORT_SYMBOL_GPL(kvm_vcpu_read_guest_page);

int kvm_read_guest(struct kvm *kvm, gpa_t gpa, void *data, unsigned long len)
{
<blue>	gfn_t gfn = gpa >> PAGE_SHIFT;</blue>
	int seg;
	int offset = offset_in_page(gpa);
	int ret;

<blue>	while ((seg = next_segment(len, offset)) != 0) {</blue>
<blue>		ret = kvm_read_guest_page(kvm, gfn, data, offset, seg);</blue>
		if (ret &lt; 0)
			return ret;
		offset = 0;
		len -= seg;
		data += seg;
<blue>		++gfn;</blue>
	}
	return 0;
<blue>}</blue>
EXPORT_SYMBOL_GPL(kvm_read_guest);

int kvm_vcpu_read_guest(struct kvm_vcpu *vcpu, gpa_t gpa, void *data, unsigned long len)
{
<blue>	gfn_t gfn = gpa >> PAGE_SHIFT;</blue>
	int seg;
	int offset = offset_in_page(gpa);
	int ret;

<blue>	while ((seg = next_segment(len, offset)) != 0) {</blue>
<blue>		ret = kvm_vcpu_read_guest_page(vcpu, gfn, data, offset, seg);</blue>
		if (ret &lt; 0)
			return ret;
		offset = 0;
		len -= seg;
		data += seg;
<blue>		++gfn;</blue>
	}
	return 0;
<blue>}</blue>
EXPORT_SYMBOL_GPL(kvm_vcpu_read_guest);

static int __kvm_read_guest_atomic(struct kvm_memory_slot *slot, gfn_t gfn,
			           void *data, int offset, unsigned long len)
{
	int r;
	unsigned long addr;

<blue>	addr = gfn_to_hva_memslot_prot(slot, gfn, NULL);</blue>
	if (kvm_is_error_hva(addr))
		return -EFAULT;
<blue>	pagefault_disable();</blue>
	r = __copy_from_user_inatomic(data, (void __user *)addr + offset, len);
	pagefault_enable();
	if (r)
		return -EFAULT;
	return 0;
}

int kvm_vcpu_read_guest_atomic(struct kvm_vcpu *vcpu, gpa_t gpa,
			       void *data, unsigned long len)
{
	gfn_t gfn = gpa &gt;&gt; PAGE_SHIFT;
<blue>	struct kvm_memory_slot *slot = kvm_vcpu_gfn_to_memslot(vcpu, gfn);</blue>
	int offset = offset_in_page(gpa);

<blue>	return __kvm_read_guest_atomic(slot, gfn, data, offset, len);</blue>
<blue>}</blue>
EXPORT_SYMBOL_GPL(kvm_vcpu_read_guest_atomic);

static int __kvm_write_guest_page(struct kvm *kvm,
				  struct kvm_memory_slot *memslot, gfn_t gfn,
			          const void *data, int offset, int len)
{
	int r;
	unsigned long addr;

<blue>	addr = gfn_to_hva_memslot(memslot, gfn);</blue>
<blue>	if (kvm_is_error_hva(addr))</blue>
		return -EFAULT;
<blue>	r = __copy_to_user((void __user *)addr + offset, data, len);</blue>
	if (r)
		return -EFAULT;
<blue>	mark_page_dirty_in_slot(kvm, memslot, gfn);</blue>
	return 0;
<blue>}</blue>

int kvm_write_guest_page(struct kvm *kvm, gfn_t gfn,
			 const void *data, int offset, int len)
{
<blue>	struct kvm_memory_slot *slot = gfn_to_memslot(kvm, gfn);</blue>

	return __kvm_write_guest_page(kvm, slot, gfn, data, offset, len);
}
EXPORT_SYMBOL_GPL(kvm_write_guest_page);

int kvm_vcpu_write_guest_page(struct kvm_vcpu *vcpu, gfn_t gfn,
			      const void *data, int offset, int len)
{
<blue>	struct kvm_memory_slot *slot = kvm_vcpu_gfn_to_memslot(vcpu, gfn);</blue>

<blue>	return __kvm_write_guest_page(vcpu->kvm, slot, gfn, data, offset, len);</blue>
}
EXPORT_SYMBOL_GPL(kvm_vcpu_write_guest_page);

int kvm_write_guest(struct kvm *kvm, gpa_t gpa, const void *data,
		    unsigned long len)
{
	gfn_t gfn = gpa &gt;&gt; PAGE_SHIFT;
	int seg;
	int offset = offset_in_page(gpa);
	int ret;

<blue>	while ((seg = next_segment(len, offset)) != 0) {</blue>
<blue>		ret = kvm_write_guest_page(kvm, gfn, data, offset, seg);</blue>
		if (ret &lt; 0)
			return ret;
		offset = 0;
<blue>		len -= seg;</blue>
		data += seg;
		++gfn;
	}
	return 0;
<blue>}</blue>
EXPORT_SYMBOL_GPL(kvm_write_guest);

int kvm_vcpu_write_guest(struct kvm_vcpu *vcpu, gpa_t gpa, const void *data,
		         unsigned long len)
{
	gfn_t gfn = gpa &gt;&gt; PAGE_SHIFT;
	int seg;
	int offset = offset_in_page(gpa);
	int ret;

<blue>	while ((seg = next_segment(len, offset)) != 0) {</blue>
<blue>		ret = kvm_vcpu_write_guest_page(vcpu, gfn, data, offset, seg);</blue>
		if (ret &lt; 0)
			return ret;
		offset = 0;
<blue>		len -= seg;</blue>
		data += seg;
		++gfn;
	}
	return 0;
<blue>}</blue>
EXPORT_SYMBOL_GPL(kvm_vcpu_write_guest);

static int __kvm_gfn_to_hva_cache_init(struct kvm_memslots *slots,
				       struct gfn_to_hva_cache *ghc,
				       gpa_t gpa, unsigned long len)
<blue>{</blue>
	int offset = offset_in_page(gpa);
<blue>	gfn_t start_gfn = gpa >> PAGE_SHIFT;</blue>
	gfn_t end_gfn = (gpa + len - 1) &gt;&gt; PAGE_SHIFT;
	gfn_t nr_pages_needed = end_gfn - start_gfn + 1;
	gfn_t nr_pages_avail;

	/* Update ghc-&gt;generation before performing any error checks. */
	ghc-&gt;generation = slots-&gt;generation;

	if (start_gfn &gt; end_gfn) {
<yellow>		ghc->hva = KVM_HVA_ERR_BAD;</yellow>
		return -EINVAL;
	}

	/*
	 * If the requested region crosses two memslots, we still
	 * verify that the entire region is valid here.
	 */
<blue>	for ( ; start_gfn <= end_gfn; start_gfn += nr_pages_avail) {</blue>
<blue>		ghc->memslot = __gfn_to_memslot(slots, start_gfn);</blue>
		ghc-&gt;hva = gfn_to_hva_many(ghc-&gt;memslot, start_gfn,
					   &amp;nr_pages_avail);
		if (kvm_is_error_hva(ghc-&gt;hva))
			return -EFAULT;
	}

	/* Use the slow path for cross page reads and writes. */
<blue>	if (nr_pages_needed == 1)</blue>
<blue>		ghc->hva += offset;</blue>
	else
<yellow>		ghc->memslot = NULL;</yellow>

<blue>	ghc->gpa = gpa;</blue>
	ghc-&gt;len = len;
	return 0;
}

int kvm_gfn_to_hva_cache_init(struct kvm *kvm, struct gfn_to_hva_cache *ghc,
			      gpa_t gpa, unsigned long len)
{
<blue>	struct kvm_memslots *slots = kvm_memslots(kvm);</blue>
	return __kvm_gfn_to_hva_cache_init(slots, ghc, gpa, len);
}
EXPORT_SYMBOL_GPL(kvm_gfn_to_hva_cache_init);

int kvm_write_guest_offset_cached(struct kvm *kvm, struct gfn_to_hva_cache *ghc,
				  void *data, unsigned int offset,
				  unsigned long len)
{
<blue>	struct kvm_memslots *slots = kvm_memslots(kvm);</blue>
	int r;
	gpa_t gpa = ghc-&gt;gpa + offset;

<yellow>	if (WARN_ON_ONCE(len + offset > ghc->len))</yellow>
		return -EINVAL;

<blue>	if (slots->generation != ghc->generation) {</blue>
<blue>		if (__kvm_gfn_to_hva_cache_init(slots, ghc, ghc->gpa, ghc->len))</blue>
			return -EFAULT;
	}

<blue>	if (kvm_is_error_hva(ghc->hva))</blue>
		return -EFAULT;

<blue>	if (unlikely(!ghc->memslot))</blue>
<yellow>		return kvm_write_guest(kvm, gpa, data, len);</yellow>

<blue>	r = __copy_to_user((void __user *)ghc->hva + offset, data, len);</blue>
	if (r)
		return -EFAULT;
<blue>	mark_page_dirty_in_slot(kvm, ghc->memslot, gpa >> PAGE_SHIFT);</blue>

	return 0;
<blue>}</blue>
EXPORT_SYMBOL_GPL(kvm_write_guest_offset_cached);

int kvm_write_guest_cached(struct kvm *kvm, struct gfn_to_hva_cache *ghc,
			   void *data, unsigned long len)
{
<blue>	return kvm_write_guest_offset_cached(kvm, ghc, data, 0, len);</blue>
}
EXPORT_SYMBOL_GPL(kvm_write_guest_cached);

int kvm_read_guest_offset_cached(struct kvm *kvm, struct gfn_to_hva_cache *ghc,
				 void *data, unsigned int offset,
				 unsigned long len)
{
<blue>	struct kvm_memslots *slots = kvm_memslots(kvm);</blue>
	int r;
	gpa_t gpa = ghc-&gt;gpa + offset;

<yellow>	if (WARN_ON_ONCE(len + offset > ghc->len))</yellow>
		return -EINVAL;

<blue>	if (slots->generation != ghc->generation) {</blue>
<blue>		if (__kvm_gfn_to_hva_cache_init(slots, ghc, ghc->gpa, ghc->len))</blue>
			return -EFAULT;
	}

<blue>	if (kvm_is_error_hva(ghc->hva))</blue>
		return -EFAULT;

<blue>	if (unlikely(!ghc->memslot))</blue>
<yellow>		return kvm_read_guest(kvm, gpa, data, len);</yellow>

<blue>	r = __copy_from_user(data, (void __user *)ghc->hva + offset, len);</blue>
	if (r)
		return -EFAULT;

	return 0;
<blue>}</blue>
EXPORT_SYMBOL_GPL(kvm_read_guest_offset_cached);

int kvm_read_guest_cached(struct kvm *kvm, struct gfn_to_hva_cache *ghc,
			  void *data, unsigned long len)
{
<blue>	return kvm_read_guest_offset_cached(kvm, ghc, data, 0, len);</blue>
}
EXPORT_SYMBOL_GPL(kvm_read_guest_cached);

int kvm_clear_guest(struct kvm *kvm, gpa_t gpa, unsigned long len)
{
<yellow>	const void *zero_page = (const void *) __va(page_to_phys(ZERO_PAGE(0)));</yellow>
	gfn_t gfn = gpa &gt;&gt; PAGE_SHIFT;
	int seg;
	int offset = offset_in_page(gpa);
	int ret;

<yellow>	while ((seg = next_segment(len, offset)) != 0) {</yellow>
<yellow>		ret = kvm_write_guest_page(kvm, gfn, zero_page, offset, len);</yellow>
		if (ret &lt; 0)
			return ret;
		offset = 0;
<yellow>		len -= seg;</yellow>
		++gfn;
	}
	return 0;
<yellow>}</yellow>
EXPORT_SYMBOL_GPL(kvm_clear_guest);

void mark_page_dirty_in_slot(struct kvm *kvm,
			     const struct kvm_memory_slot *memslot,
		 	     gfn_t gfn)
{
<blue>	struct kvm_vcpu *vcpu = kvm_get_running_vcpu();</blue>

#ifdef CONFIG_HAVE_KVM_DIRTY_RING
<blue>	if (WARN_ON_ONCE(!vcpu) || WARN_ON_ONCE(vcpu->kvm != kvm))</blue>
		return;
#endif

<blue>	if (memslot && kvm_slot_dirty_track_enabled(memslot)) {</blue>
<yellow>		unsigned long rel_gfn = gfn - memslot->base_gfn;</yellow>
<yellow>		u32 slot = (memslot->as_id << 16) | memslot->id;</yellow>

		if (kvm-&gt;dirty_ring_size)
			kvm_dirty_ring_push(&amp;vcpu-&gt;dirty_ring,
					    slot, rel_gfn);
		else
<yellow>			set_bit_le(rel_gfn, memslot->dirty_bitmap);</yellow>
	}
<blue>}</blue>
EXPORT_SYMBOL_GPL(mark_page_dirty_in_slot);

void mark_page_dirty(struct kvm *kvm, gfn_t gfn)
{
	struct kvm_memory_slot *memslot;

<yellow>	memslot = gfn_to_memslot(kvm, gfn);</yellow>
	mark_page_dirty_in_slot(kvm, memslot, gfn);
}
EXPORT_SYMBOL_GPL(mark_page_dirty);

void kvm_vcpu_mark_page_dirty(struct kvm_vcpu *vcpu, gfn_t gfn)
{
	struct kvm_memory_slot *memslot;

<blue>	memslot = kvm_vcpu_gfn_to_memslot(vcpu, gfn);</blue>
	mark_page_dirty_in_slot(vcpu-&gt;kvm, memslot, gfn);
}
EXPORT_SYMBOL_GPL(kvm_vcpu_mark_page_dirty);

void kvm_sigset_activate(struct kvm_vcpu *vcpu)
{
<blue>	if (!vcpu->sigset_active)</blue>
		return;

	/*
	 * This does a lockless modification of -&gt;real_blocked, which is fine
	 * because, only current can change -&gt;real_blocked and all readers of
	 * -&gt;real_blocked don&#x27;t care as long -&gt;real_blocked is always a subset
	 * of -&gt;blocked.
	 */
<yellow>	sigprocmask(SIG_SETMASK, &vcpu->sigset, &current->real_blocked);</yellow>
<blue>}</blue>

void kvm_sigset_deactivate(struct kvm_vcpu *vcpu)
{
<blue>	if (!vcpu->sigset_active)</blue>
		return;

<yellow>	sigprocmask(SIG_SETMASK, &current->real_blocked, NULL);</yellow>
	sigemptyset(&amp;current-&gt;real_blocked);
<blue>}</blue>

static void grow_halt_poll_ns(struct kvm_vcpu *vcpu)
{
	unsigned int old, val, grow, grow_start;

	old = val = vcpu-&gt;halt_poll_ns;
<blue>	grow_start = READ_ONCE(halt_poll_ns_grow_start);</blue>
	grow = READ_ONCE(halt_poll_ns_grow);
	if (!grow)
		goto out;

<blue>	val *= grow;</blue>
	if (val &lt; grow_start)
		val = grow_start;

	vcpu-&gt;halt_poll_ns = val;
out:
<blue>	trace_kvm_halt_poll_ns_grow(vcpu->vcpu_id, val, old);</blue>
}

static void shrink_halt_poll_ns(struct kvm_vcpu *vcpu)
{
	unsigned int old, val, shrink, grow_start;

	old = val = vcpu-&gt;halt_poll_ns;
<blue>	shrink = READ_ONCE(halt_poll_ns_shrink);</blue>
	grow_start = READ_ONCE(halt_poll_ns_grow_start);
	if (shrink == 0)
		val = 0;
	else
<yellow>		val /= shrink;</yellow>

<blue>	if (val < grow_start)</blue>
		val = 0;

	vcpu-&gt;halt_poll_ns = val;
<blue>	trace_kvm_halt_poll_ns_shrink(vcpu->vcpu_id, val, old);</blue>
}

static int kvm_vcpu_check_block(struct kvm_vcpu *vcpu)
{
	int ret = -EINTR;
<blue>	int idx = srcu_read_lock(&vcpu->kvm->srcu);</blue>

	if (kvm_arch_vcpu_runnable(vcpu))
		goto out;
<blue>	if (kvm_cpu_has_pending_timer(vcpu))</blue>
		goto out;
<blue>	if (signal_pending(current))</blue>
		goto out;
<blue>	if (kvm_check_request(KVM_REQ_UNBLOCK, vcpu))</blue>
		goto out;

	ret = 0;
out:
<blue>	srcu_read_unlock(&vcpu->kvm->srcu, idx);</blue>
	return ret;
}

/*
 * Block the vCPU until the vCPU is runnable, an event arrives, or a signal is
 * pending.  This is mostly used when halting a vCPU, but may also be used
 * directly for other vCPU non-runnable states, e.g. x86&#x27;s Wait-For-SIPI.
 */
bool kvm_vcpu_block(struct kvm_vcpu *vcpu)
{
	struct rcuwait *wait = kvm_arch_vcpu_get_wait(vcpu);
	bool waited = false;

<blue>	vcpu->stat.generic.blocking = 1;</blue>

	preempt_disable();
	kvm_arch_vcpu_blocking(vcpu);
	prepare_to_rcuwait(wait);
<blue>	preempt_enable();</blue>

	for (;;) {
<blue>		set_current_state(TASK_INTERRUPTIBLE);</blue>

		if (kvm_vcpu_check_block(vcpu) &lt; 0)
			break;

<blue>		waited = true;</blue>
		schedule();
	}

<blue>	preempt_disable();</blue>
	finish_rcuwait(wait);
	kvm_arch_vcpu_unblocking(vcpu);
<blue>	preempt_enable();</blue>

<blue>	vcpu->stat.generic.blocking = 0;</blue>

	return waited;
}

static inline void update_halt_poll_stats(struct kvm_vcpu *vcpu, ktime_t start,
					  ktime_t end, bool success)
{
	struct kvm_vcpu_stat_generic *stats = &amp;vcpu-&gt;stat.generic;
<blue>	u64 poll_ns = ktime_to_ns(ktime_sub(end, start));</blue>

<blue>	++vcpu->stat.generic.halt_attempted_poll;</blue>

	if (success) {
		++vcpu-&gt;stat.generic.halt_successful_poll;

		if (!vcpu_valid_wakeup(vcpu))
			++vcpu-&gt;stat.generic.halt_poll_invalid;

		stats-&gt;halt_poll_success_ns += poll_ns;
		KVM_STATS_LOG_HIST_UPDATE(stats-&gt;halt_poll_success_hist, poll_ns);
	} else {
		stats-&gt;halt_poll_fail_ns += poll_ns;
		KVM_STATS_LOG_HIST_UPDATE(stats-&gt;halt_poll_fail_hist, poll_ns);
	}
}

static unsigned int kvm_vcpu_max_halt_poll_ns(struct kvm_vcpu *vcpu)
{
	struct kvm *kvm = vcpu-&gt;kvm;

<blue>	if (kvm->override_halt_poll_ns) {</blue>
		/*
		 * Ensure kvm-&gt;max_halt_poll_ns is not read before
		 * kvm-&gt;override_halt_poll_ns.
		 *
		 * Pairs with the smp_wmb() when enabling KVM_CAP_HALT_POLL.
		 */
		smp_rmb();
<yellow>		return READ_ONCE(kvm->max_halt_poll_ns);</yellow>
	}

<blue>	return READ_ONCE(halt_poll_ns);</blue>
}

/*
 * Emulate a vCPU halt condition, e.g. HLT on x86, WFI on arm, etc...  If halt
 * polling is enabled, busy wait for a short time before blocking to avoid the
 * expensive block+unblock sequence if a wake event arrives soon after the vCPU
 * is halted.
 */
void kvm_vcpu_halt(struct kvm_vcpu *vcpu)
{
<blue>	unsigned int max_halt_poll_ns = kvm_vcpu_max_halt_poll_ns(vcpu);</blue>
<blue>	bool halt_poll_allowed = !kvm_arch_no_poll(vcpu);</blue>
	ktime_t start, cur, poll_end;
	bool waited = false;
	bool do_halt_poll;
	u64 halt_ns;

	if (vcpu-&gt;halt_poll_ns &gt; max_halt_poll_ns)
<yellow>		vcpu->halt_poll_ns = max_halt_poll_ns;</yellow>

<blue>	do_halt_poll = halt_poll_allowed && vcpu->halt_poll_ns;</blue>

<blue>	start = cur = poll_end = ktime_get();</blue>
	if (do_halt_poll) {
		ktime_t stop = ktime_add_ns(start, vcpu-&gt;halt_poll_ns);

		do {
			/*
			 * This sets KVM_REQ_UNHALT if an interrupt
			 * arrives.
			 */
<blue>			if (kvm_vcpu_check_block(vcpu) < 0)</blue>
				goto out;
<blue>			cpu_relax();</blue>
			poll_end = cur = ktime_get();
<blue>		} while (kvm_vcpu_can_poll(cur, stop));</blue>
	}

<blue>	waited = kvm_vcpu_block(vcpu);</blue>

	cur = ktime_get();
	if (waited) {
<blue>		vcpu->stat.generic.halt_wait_ns +=</blue>
			ktime_to_ns(cur) - ktime_to_ns(poll_end);
		KVM_STATS_LOG_HIST_UPDATE(vcpu-&gt;stat.generic.halt_wait_hist,
				ktime_to_ns(cur) - ktime_to_ns(poll_end));
	}
out:
	/* The total time the vCPU was &quot;halted&quot;, including polling time. */
<blue>	halt_ns = ktime_to_ns(cur) - ktime_to_ns(start);</blue>

	/*
	 * Note, halt-polling is considered successful so long as the vCPU was
	 * never actually scheduled out, i.e. even if the wake event arrived
	 * after of the halt-polling loop itself, but before the full wait.
	 */
<blue>	if (do_halt_poll)</blue>
<blue>		update_halt_poll_stats(vcpu, start, poll_end, !waited);</blue>

<blue>	if (halt_poll_allowed) {</blue>
		/* Recompute the max halt poll time in case it changed. */
<blue>		max_halt_poll_ns = kvm_vcpu_max_halt_poll_ns(vcpu);</blue>

		if (!vcpu_valid_wakeup(vcpu)) {
			shrink_halt_poll_ns(vcpu);
<blue>		} else if (max_halt_poll_ns) {</blue>
<blue>			if (halt_ns <= vcpu->halt_poll_ns)</blue>
				;
			/* we had a long block, shrink polling */
<blue>			else if (vcpu->halt_poll_ns &&</blue>
<blue>				 halt_ns > max_halt_poll_ns)</blue>
<blue>				shrink_halt_poll_ns(vcpu);</blue>
			/* we had a short halt and our poll time is too small */
<blue>			else if (vcpu->halt_poll_ns < max_halt_poll_ns &&</blue>
				 halt_ns &lt; max_halt_poll_ns)
<blue>				grow_halt_poll_ns(vcpu);</blue>
		} else {
<yellow>			vcpu->halt_poll_ns = 0;</yellow>
		}
	}

<blue>	trace_kvm_vcpu_wakeup(halt_ns, waited, vcpu_valid_wakeup(vcpu));</blue>
<blue>}</blue>
EXPORT_SYMBOL_GPL(kvm_vcpu_halt);

<yellow>bool kvm_vcpu_wake_up(struct kvm_vcpu *vcpu)</yellow>
{
<blue>	if (__kvm_vcpu_wake_up(vcpu)) {</blue>
<yellow>		WRITE_ONCE(vcpu->ready, true);</yellow>
		++vcpu-&gt;stat.generic.halt_wakeup;
		return true;
	}

	return false;
<yellow>}</yellow>
EXPORT_SYMBOL_GPL(kvm_vcpu_wake_up);

#ifndef CONFIG_S390
/*
 * Kick a sleeping VCPU, or a guest VCPU in guest mode, into host kernel mode.
 */
<blue>void kvm_vcpu_kick(struct kvm_vcpu *vcpu)</blue>
{
	int me, cpu;

<blue>	if (kvm_vcpu_wake_up(vcpu))</blue>
		return;

<blue>	me = get_cpu();</blue>
	/*
	 * The only state change done outside the vcpu mutex is IN_GUEST_MODE
	 * to EXITING_GUEST_MODE.  Therefore the moderately expensive &quot;should
	 * kick&quot; check does not need atomic operations if kvm_vcpu_kick is used
	 * within the vCPU thread itself.
	 */
	if (vcpu == __this_cpu_read(kvm_running_vcpu)) {
<blue>		if (vcpu->mode == IN_GUEST_MODE)</blue>
<yellow>			WRITE_ONCE(vcpu->mode, EXITING_GUEST_MODE);</yellow>
		goto out;
	}

	/*
	 * Note, the vCPU could get migrated to a different pCPU at any point
	 * after kvm_arch_vcpu_should_kick(), which could result in sending an
	 * IPI to the previous pCPU.  But, that&#x27;s ok because the purpose of the
	 * IPI is to force the vCPU to leave IN_GUEST_MODE, and migrating the
	 * vCPU also requires it to leave IN_GUEST_MODE.
	 */
<blue>	if (kvm_arch_vcpu_should_kick(vcpu)) {</blue>
<yellow>		cpu = READ_ONCE(vcpu->cpu);</yellow>
<yellow>		if (cpu != me && (unsigned)cpu < nr_cpu_ids && cpu_online(cpu))</yellow>
<yellow>			smp_send_reschedule(cpu);</yellow>
	}
out:
<blue>	put_cpu();</blue>
<blue>}</blue>
EXPORT_SYMBOL_GPL(kvm_vcpu_kick);
#endif /* !CONFIG_S390 */

int kvm_vcpu_yield_to(struct kvm_vcpu *target)
{
	struct pid *pid;
	struct task_struct *task = NULL;
	int ret = 0;

<yellow>	rcu_read_lock();</yellow>
	pid = rcu_dereference(target-&gt;pid);
	if (pid)
<yellow>		task = get_pid_task(pid, PIDTYPE_PID);</yellow>
	rcu_read_unlock();
	if (!task)
<yellow>		return ret;</yellow>
	ret = yield_to(task, 1);
<yellow>	put_task_struct(task);</yellow>

	return ret;
<yellow>}</yellow>
EXPORT_SYMBOL_GPL(kvm_vcpu_yield_to);

/*
 * Helper that checks whether a VCPU is eligible for directed yield.
 * Most eligible candidate to yield is decided by following heuristics:
 *
 *  (a) VCPU which has not done pl-exit or cpu relax intercepted recently
 *  (preempted lock holder), indicated by @in_spin_loop.
 *  Set at the beginning and cleared at the end of interception/PLE handler.
 *
 *  (b) VCPU which has done pl-exit/ cpu relax intercepted but did not get
 *  chance last time (mostly it has become eligible now since we have probably
 *  yielded to lockholder in last iteration. This is done by toggling
 *  @dy_eligible each time a VCPU checked for eligibility.)
 *
 *  Yielding to a recently pl-exited/cpu relax intercepted VCPU before yielding
 *  to preempted lock-holder could result in wrong VCPU selection and CPU
 *  burning. Giving priority for a potential lock-holder increases lock
 *  progress.
 *
 *  Since algorithm is based on heuristics, accessing another VCPU data without
 *  locking does not harm. It may result in trying to yield to  same VCPU, fail
 *  and continue with next VCPU and so on.
 */
static bool kvm_vcpu_eligible_for_directed_yield(struct kvm_vcpu *vcpu)
{
#ifdef CONFIG_HAVE_KVM_CPU_RELAX_INTERCEPT
	bool eligible;

<yellow>	eligible = !vcpu->spin_loop.in_spin_loop ||</yellow>
<yellow>		    vcpu->spin_loop.dy_eligible;</yellow>

<yellow>	if (vcpu->spin_loop.in_spin_loop)</yellow>
<yellow>		kvm_vcpu_set_dy_eligible(vcpu, !vcpu->spin_loop.dy_eligible);</yellow>

	return eligible;
#else
	return true;
#endif
}

/*
 * Unlike kvm_arch_vcpu_runnable, this function is called outside
 * a vcpu_load/vcpu_put pair.  However, for most architectures
 * kvm_arch_vcpu_runnable does not require vcpu_load.
 */
bool __weak kvm_arch_dy_runnable(struct kvm_vcpu *vcpu)
{
<yellow>	return kvm_arch_vcpu_runnable(vcpu);</yellow>
}

static bool vcpu_dy_runnable(struct kvm_vcpu *vcpu)
{
<yellow>	if (kvm_arch_dy_runnable(vcpu))</yellow>
		return true;

#ifdef CONFIG_KVM_ASYNC_PF
<yellow>	if (!list_empty_careful(&vcpu->async_pf.done))</yellow>
		return true;
#endif

	return false;
}

bool __weak kvm_arch_dy_has_pending_interrupt(struct kvm_vcpu *vcpu)
{
	return false;
<yellow>}</yellow>

void kvm_vcpu_on_spin(struct kvm_vcpu *me, bool yield_to_kernel_mode)
{
<blue>	struct kvm *kvm = me->kvm;</blue>
	struct kvm_vcpu *vcpu;
	int last_boosted_vcpu = me-&gt;kvm-&gt;last_boosted_vcpu;
	unsigned long i;
	int yielded = 0;
	int try = 3;
	int pass;

	kvm_vcpu_set_in_spin_loop(me, true);
	/*
	 * We boost the priority of a VCPU that is runnable but not
	 * currently running, because it got preempted by something
	 * else and called schedule in __vcpu_run.  Hopefully that
	 * VCPU is holding the lock that we need and will release it.
	 * We approximate round-robin by starting at the last boosted VCPU.
	 */
<blue>	for (pass = 0; pass < 2 && !yielded && try; pass++) {</blue>
<blue>		kvm_for_each_vcpu(i, vcpu, kvm) {</blue>
<blue>			if (!pass && i <= last_boosted_vcpu) {</blue>
<blue>				i = last_boosted_vcpu;</blue>
				continue;
<blue>			} else if (pass && i > last_boosted_vcpu)</blue>
				break;
<blue>			if (!READ_ONCE(vcpu->ready))</blue>
				continue;
<yellow>			if (vcpu == me)</yellow>
				continue;
<yellow>			if (kvm_vcpu_is_blocking(vcpu) && !vcpu_dy_runnable(vcpu))</yellow>
				continue;
<yellow>			if (READ_ONCE(vcpu->preempted) && yield_to_kernel_mode &&</yellow>
<yellow>			    !kvm_arch_dy_has_pending_interrupt(vcpu) &&</yellow>
<yellow>			    !kvm_arch_vcpu_in_kernel(vcpu))</yellow>
				continue;
<yellow>			if (!kvm_vcpu_eligible_for_directed_yield(vcpu))</yellow>
				continue;

<yellow>			yielded = kvm_vcpu_yield_to(vcpu);</yellow>
			if (yielded &gt; 0) {
<yellow>				kvm->last_boosted_vcpu = i;</yellow>
				break;
<yellow>			} else if (yielded < 0) {</yellow>
<yellow>				try--;</yellow>
				if (!try)
					break;
			}
		}
	}
<blue>	kvm_vcpu_set_in_spin_loop(me, false);</blue>

	/* Ensure vcpu is not eligible during next spinloop */
	kvm_vcpu_set_dy_eligible(me, false);
}
EXPORT_SYMBOL_GPL(kvm_vcpu_on_spin);

static bool kvm_page_in_dirty_ring(struct kvm *kvm, unsigned long pgoff)
{
#ifdef CONFIG_HAVE_KVM_DIRTY_RING
<yellow>	return (pgoff >= KVM_DIRTY_LOG_PAGE_OFFSET) &&</yellow>
	    (pgoff &lt; KVM_DIRTY_LOG_PAGE_OFFSET +
<yellow>	     kvm->dirty_ring_size / PAGE_SIZE);</yellow>
#else
	return false;
#endif
}

static vm_fault_t kvm_vcpu_fault(struct vm_fault *vmf)
{
<yellow>	struct kvm_vcpu *vcpu = vmf->vma->vm_file->private_data;</yellow>
	struct page *page;

	if (vmf-&gt;pgoff == 0)
<yellow>		page = virt_to_page(vcpu->run);</yellow>
#ifdef CONFIG_X86
<yellow>	else if (vmf->pgoff == KVM_PIO_PAGE_OFFSET)</yellow>
<yellow>		page = virt_to_page(vcpu->arch.pio_data);</yellow>
#endif
#ifdef CONFIG_KVM_MMIO
	else if (vmf-&gt;pgoff == KVM_COALESCED_MMIO_PAGE_OFFSET)
<yellow>		page = virt_to_page(vcpu->kvm->coalesced_mmio_ring);</yellow>
#endif
<yellow>	else if (kvm_page_in_dirty_ring(vcpu->kvm, vmf->pgoff))</yellow>
<yellow>		page = kvm_dirty_ring_get_page(</yellow>
		    &amp;vcpu-&gt;dirty_ring,
		    vmf-&gt;pgoff - KVM_DIRTY_LOG_PAGE_OFFSET);
	else
<yellow>		return kvm_arch_vcpu_fault(vcpu, vmf);</yellow>
<yellow>	get_page(page);</yellow>
	vmf-&gt;page = page;
	return 0;
<yellow>}</yellow>

static const struct vm_operations_struct kvm_vcpu_vm_ops = {
	.fault = kvm_vcpu_fault,
};

static int kvm_vcpu_mmap(struct file *file, struct vm_area_struct *vma)
<yellow>{</yellow>
<yellow>	struct kvm_vcpu *vcpu = file->private_data;</yellow>
<yellow>	unsigned long pages = vma_pages(vma);</yellow>

<yellow>	if ((kvm_page_in_dirty_ring(vcpu->kvm, vma->vm_pgoff) ||</yellow>
<yellow>	     kvm_page_in_dirty_ring(vcpu->kvm, vma->vm_pgoff + pages - 1)) &&</yellow>
<yellow>	    ((vma->vm_flags & VM_EXEC) || !(vma->vm_flags & VM_SHARED)))</yellow>
<yellow>		return -EINVAL;</yellow>

<yellow>	vma->vm_ops = &kvm_vcpu_vm_ops;</yellow>
	return 0;
<yellow>}</yellow>

static int kvm_vcpu_release(struct inode *inode, struct file *filp)
{
<yellow>	struct kvm_vcpu *vcpu = filp->private_data;</yellow>

	kvm_put_kvm(vcpu-&gt;kvm);
	return 0;
}

static const struct file_operations kvm_vcpu_fops = {
	.release        = kvm_vcpu_release,
	.unlocked_ioctl = kvm_vcpu_ioctl,
	.mmap           = kvm_vcpu_mmap,
	.llseek		= noop_llseek,
	KVM_COMPAT(kvm_vcpu_compat_ioctl),
};

/*
 * Allocates an inode for the vcpu.
 */
static int create_vcpu_fd(struct kvm_vcpu *vcpu)
{
	char name[8 + 1 + ITOA_MAX_LEN + 1];

<blue>	snprintf(name, sizeof(name), "kvm-vcpu:%d", vcpu->vcpu_id);</blue>
	return anon_inode_getfd(name, &amp;kvm_vcpu_fops, vcpu, O_RDWR | O_CLOEXEC);
}

#ifdef __KVM_HAVE_ARCH_VCPU_DEBUGFS
static int vcpu_get_pid(void *data, u64 *val)
<yellow>{</yellow>
	struct kvm_vcpu *vcpu = (struct kvm_vcpu *) data;
<yellow>	*val = pid_nr(rcu_access_pointer(vcpu->pid));</yellow>
	return 0;
}

<yellow>DEFINE_SIMPLE_ATTRIBUTE(vcpu_get_pid_fops, vcpu_get_pid, NULL, "%llu\n");</yellow>

static void kvm_create_vcpu_debugfs(struct kvm_vcpu *vcpu)
{
	struct dentry *debugfs_dentry;
	char dir_name[ITOA_MAX_LEN * 2];

	if (!debugfs_initialized())
		return;

<blue>	snprintf(dir_name, sizeof(dir_name), "vcpu%d", vcpu->vcpu_id);</blue>
	debugfs_dentry = debugfs_create_dir(dir_name,
					    vcpu-&gt;kvm-&gt;debugfs_dentry);
	debugfs_create_file(&quot;pid&quot;, 0444, debugfs_dentry, vcpu,
			    &amp;vcpu_get_pid_fops);

	kvm_arch_create_vcpu_debugfs(vcpu, debugfs_dentry);
}
#endif

/*
 * Creates some virtual cpus.  Good luck creating more than one.
 */
static int kvm_vm_ioctl_create_vcpu(struct kvm *kvm, u32 id)
{
	int r;
	struct kvm_vcpu *vcpu;
	struct page *page;

	if (id &gt;= KVM_MAX_VCPU_IDS)
		return -EINVAL;

<blue>	mutex_lock(&kvm->lock);</blue>
	if (kvm-&gt;created_vcpus &gt;= kvm-&gt;max_vcpus) {
<yellow>		mutex_unlock(&kvm->lock);</yellow>
		return -EINVAL;
	}

<blue>	r = kvm_arch_vcpu_precreate(kvm, id);</blue>
	if (r) {
<yellow>		mutex_unlock(&kvm->lock);</yellow>
		return r;
	}

<blue>	kvm->created_vcpus++;</blue>
	mutex_unlock(&amp;kvm-&gt;lock);

	vcpu = kmem_cache_zalloc(kvm_vcpu_cache, GFP_KERNEL_ACCOUNT);
	if (!vcpu) {
		r = -ENOMEM;
		goto vcpu_decrement;
	}

	BUILD_BUG_ON(sizeof(struct kvm_run) &gt; PAGE_SIZE);
<blue>	page = alloc_page(GFP_KERNEL_ACCOUNT | __GFP_ZERO);</blue>
	if (!page) {
		r = -ENOMEM;
		goto vcpu_free;
	}
<blue>	vcpu->run = page_address(page);</blue>

	kvm_vcpu_init(vcpu, kvm, id);

	r = kvm_arch_vcpu_create(vcpu);
	if (r)
		goto vcpu_free_run_page;

<blue>	if (kvm->dirty_ring_size) {</blue>
<yellow>		r = kvm_dirty_ring_alloc(&vcpu->dirty_ring,</yellow>
					 id, kvm-&gt;dirty_ring_size);
		if (r)
			goto arch_vcpu_destroy;
	}

<blue>	mutex_lock(&kvm->lock);</blue>
<blue>	if (kvm_get_vcpu_by_id(kvm, id)) {</blue>
		r = -EEXIST;
		goto unlock_vcpu_destroy;
	}

<blue>	vcpu->vcpu_idx = atomic_read(&kvm->online_vcpus);</blue>
	r = xa_insert(&amp;kvm-&gt;vcpu_array, vcpu-&gt;vcpu_idx, vcpu, GFP_KERNEL_ACCOUNT);
<yellow>	BUG_ON(r == -EBUSY);</yellow>
<blue>	if (r)</blue>
		goto unlock_vcpu_destroy;

	/* Now it&#x27;s all set up, let userspace reach it */
<blue>	kvm_get_kvm(kvm);</blue>
<blue>	r = create_vcpu_fd(vcpu);</blue>
	if (r &lt; 0) {
<yellow>		xa_erase(&kvm->vcpu_array, vcpu->vcpu_idx);</yellow>
		kvm_put_kvm_no_destroy(kvm);
		goto unlock_vcpu_destroy;
	}

	/*
	 * Pairs with smp_rmb() in kvm_get_vcpu.  Store the vcpu
	 * pointer before kvm-&gt;online_vcpu&#x27;s incremented value.
	 */
	smp_wmb();
<blue>	atomic_inc(&kvm->online_vcpus);</blue>

	mutex_unlock(&amp;kvm-&gt;lock);
	kvm_arch_vcpu_postcreate(vcpu);
<blue>	kvm_create_vcpu_debugfs(vcpu);</blue>
	return r;

unlock_vcpu_destroy:
<yellow>	mutex_unlock(&kvm->lock);</yellow>
	kvm_dirty_ring_free(&amp;vcpu-&gt;dirty_ring);
arch_vcpu_destroy:
<yellow>	kvm_arch_vcpu_destroy(vcpu);</yellow>
vcpu_free_run_page:
<yellow>	free_page((unsigned long)vcpu->run);</yellow>
vcpu_free:
<yellow>	kmem_cache_free(kvm_vcpu_cache, vcpu);</yellow>
vcpu_decrement:
<yellow>	mutex_lock(&kvm->lock);</yellow>
	kvm-&gt;created_vcpus--;
	mutex_unlock(&amp;kvm-&gt;lock);
	return r;
}

static int kvm_vcpu_ioctl_set_sigmask(struct kvm_vcpu *vcpu, sigset_t *sigset)
{
	if (sigset) {
		sigdelsetmask(sigset, sigmask(SIGKILL)|sigmask(SIGSTOP));
<yellow>		vcpu->sigset_active = 1;</yellow>
		vcpu-&gt;sigset = *sigset;
	} else
<yellow>		vcpu->sigset_active = 0;</yellow>
	return 0;
}

static ssize_t kvm_vcpu_stats_read(struct file *file, char __user *user_buffer,
			      size_t size, loff_t *offset)
{
<yellow>	struct kvm_vcpu *vcpu = file->private_data;</yellow>

	return kvm_stats_read(vcpu-&gt;stats_id, &amp;kvm_vcpu_stats_header,
			&amp;kvm_vcpu_stats_desc[0], &amp;vcpu-&gt;stat,
			sizeof(vcpu-&gt;stat), user_buffer, size, offset);
}

static const struct file_operations kvm_vcpu_stats_fops = {
	.read = kvm_vcpu_stats_read,
	.llseek = noop_llseek,
};

static int kvm_vcpu_ioctl_get_stats_fd(struct kvm_vcpu *vcpu)
{
	int fd;
	struct file *file;
	char name[15 + ITOA_MAX_LEN + 1];

<yellow>	snprintf(name, sizeof(name), "kvm-vcpu-stats:%d", vcpu->vcpu_id);</yellow>

	fd = get_unused_fd_flags(O_CLOEXEC);
	if (fd &lt; 0)
		return fd;

<yellow>	file = anon_inode_getfile(name, &kvm_vcpu_stats_fops, vcpu, O_RDONLY);</yellow>
	if (IS_ERR(file)) {
<yellow>		put_unused_fd(fd);</yellow>
		return PTR_ERR(file);
	}
<yellow>	file->f_mode |= FMODE_PREAD;</yellow>
	fd_install(fd, file);

	return fd;
}

static long kvm_vcpu_ioctl(struct file *filp,
			   unsigned int ioctl, unsigned long arg)
<blue>{</blue>
<blue>	struct kvm_vcpu *vcpu = filp->private_data;</blue>
	void __user *argp = (void __user *)arg;
	int r;
<yellow>	struct kvm_fpu *fpu = NULL;</yellow>
<blue>	struct kvm_sregs *kvm_sregs = NULL;</blue>

<blue>	if (vcpu->kvm->mm != current->mm || vcpu->kvm->vm_dead)</blue>
		return -EIO;

<blue>	if (unlikely(_IOC_TYPE(ioctl) != KVMIO))</blue>
		return -EINVAL;

	/*
	 * Some architectures have vcpu ioctls that are asynchronous to vcpu
	 * execution; mutex_lock() would break them.
	 */
	r = kvm_arch_vcpu_async_ioctl(filp, ioctl, arg);
	if (r != -ENOIOCTLCMD)
		return r;

<blue>	if (mutex_lock_killable(&vcpu->mutex))</blue>
		return -EINTR;
<blue>	switch (ioctl) {</blue>
	case KVM_RUN: {
		struct pid *oldpid;
		r = -EINVAL;
<blue>		if (arg)</blue>
			goto out;
<blue>		oldpid = rcu_access_pointer(vcpu->pid);</blue>
		if (unlikely(oldpid != task_pid(current))) {
			/* The thread running this VCPU changed. */
			struct pid *newpid;

			r = kvm_arch_vcpu_run_pid_change(vcpu);
			if (r)
				break;

<blue>			newpid = get_task_pid(current, PIDTYPE_PID);</blue>
			rcu_assign_pointer(vcpu-&gt;pid, newpid);
			if (oldpid)
<yellow>				synchronize_rcu();</yellow>
<blue>			put_pid(oldpid);</blue>
		}
<blue>		r = kvm_arch_vcpu_ioctl_run(vcpu);</blue>
<yellow>		trace_kvm_userspace_exit(vcpu->run->exit_reason, r);</yellow>
		break;
	}
	case KVM_GET_REGS: {
		struct kvm_regs *kvm_regs;

		r = -ENOMEM;
<blue>		kvm_regs = kzalloc(sizeof(struct kvm_regs), GFP_KERNEL_ACCOUNT);</blue>
		if (!kvm_regs)
			goto out;
<blue>		r = kvm_arch_vcpu_ioctl_get_regs(vcpu, kvm_regs);</blue>
		if (r)
			goto out_free1;
		r = -EFAULT;
<blue>		if (copy_to_user(argp, kvm_regs, sizeof(struct kvm_regs)))</blue>
			goto out_free1;
		r = 0;
out_free1:
<blue>		kfree(kvm_regs);</blue>
		break;
	}
	case KVM_SET_REGS: {
		struct kvm_regs *kvm_regs;

<blue>		kvm_regs = memdup_user(argp, sizeof(*kvm_regs));</blue>
		if (IS_ERR(kvm_regs)) {
			r = PTR_ERR(kvm_regs);
			goto out;
		}
<blue>		r = kvm_arch_vcpu_ioctl_set_regs(vcpu, kvm_regs);</blue>
		kfree(kvm_regs);
		break;
	}
	case KVM_GET_SREGS: {
<blue>		kvm_sregs = kzalloc(sizeof(struct kvm_sregs),</blue>
				    GFP_KERNEL_ACCOUNT);
		r = -ENOMEM;
		if (!kvm_sregs)
			goto out;
<blue>		r = kvm_arch_vcpu_ioctl_get_sregs(vcpu, kvm_sregs);</blue>
		if (r)
			goto out;
		r = -EFAULT;
<blue>		if (copy_to_user(argp, kvm_sregs, sizeof(struct kvm_sregs)))</blue>
			goto out;
		r = 0;
		break;
	}
	case KVM_SET_SREGS: {
<blue>		kvm_sregs = memdup_user(argp, sizeof(*kvm_sregs));</blue>
		if (IS_ERR(kvm_sregs)) {
			r = PTR_ERR(kvm_sregs);
			kvm_sregs = NULL;
			goto out;
		}
<blue>		r = kvm_arch_vcpu_ioctl_set_sregs(vcpu, kvm_sregs);</blue>
		break;
	}
	case KVM_GET_MP_STATE: {
		struct kvm_mp_state mp_state;

<blue>		r = kvm_arch_vcpu_ioctl_get_mpstate(vcpu, &mp_state);</blue>
		if (r)
			goto out;
		r = -EFAULT;
<blue>		if (copy_to_user(argp, &mp_state, sizeof(mp_state)))</blue>
			goto out;
		r = 0;
		break;
	}
	case KVM_SET_MP_STATE: {
		struct kvm_mp_state mp_state;

		r = -EFAULT;
<blue>		if (copy_from_user(&mp_state, argp, sizeof(mp_state)))</blue>
			goto out;
<blue>		r = kvm_arch_vcpu_ioctl_set_mpstate(vcpu, &mp_state);</blue>
		break;
	}
	case KVM_TRANSLATE: {
		struct kvm_translation tr;

		r = -EFAULT;
<yellow>		if (copy_from_user(&tr, argp, sizeof(tr)))</yellow>
			goto out;
<yellow>		r = kvm_arch_vcpu_ioctl_translate(vcpu, &tr);</yellow>
		if (r)
			goto out;
		r = -EFAULT;
<yellow>		if (copy_to_user(argp, &tr, sizeof(tr)))</yellow>
			goto out;
		r = 0;
<blue>		break;</blue>
	}
	case KVM_SET_GUEST_DEBUG: {
		struct kvm_guest_debug dbg;

		r = -EFAULT;
<blue>		if (copy_from_user(&dbg, argp, sizeof(dbg)))</blue>
<blue>			goto out;</blue>
<yellow>		r = kvm_arch_vcpu_ioctl_set_guest_debug(vcpu, &dbg);</yellow>
		break;
	}
	case KVM_SET_SIGNAL_MASK: {
		struct kvm_signal_mask __user *sigmask_arg = argp;
		struct kvm_signal_mask kvm_sigmask;
		sigset_t sigset, *p;

		p = NULL;
<blue>		if (argp) {</blue>
			r = -EFAULT;
<blue>			if (copy_from_user(&kvm_sigmask, argp,</blue>
					   sizeof(kvm_sigmask)))
				goto out;
			r = -EINVAL;
<blue>			if (kvm_sigmask.len != sizeof(sigset))</blue>
				goto out;
			r = -EFAULT;
<yellow>			if (copy_from_user(&sigset, sigmask_arg->sigset,</yellow>
					   sizeof(sigset)))
				goto out;
			p = &amp;sigset;
		}
<yellow>		r = kvm_vcpu_ioctl_set_sigmask(vcpu, p);</yellow>
<yellow>		break;</yellow>
	}
	case KVM_GET_FPU: {
<yellow>		fpu = kzalloc(sizeof(struct kvm_fpu), GFP_KERNEL_ACCOUNT);</yellow>
		r = -ENOMEM;
		if (!fpu)
			goto out;
<yellow>		r = kvm_arch_vcpu_ioctl_get_fpu(vcpu, fpu);</yellow>
		if (r)
			goto out;
		r = -EFAULT;
<yellow>		if (copy_to_user(argp, fpu, sizeof(struct kvm_fpu)))</yellow>
			goto out;
		r = 0;
		break;
	}
	case KVM_SET_FPU: {
<yellow>		fpu = memdup_user(argp, sizeof(*fpu));</yellow>
		if (IS_ERR(fpu)) {
			r = PTR_ERR(fpu);
			fpu = NULL;
			goto out;
		}
<yellow>		r = kvm_arch_vcpu_ioctl_set_fpu(vcpu, fpu);</yellow>
		break;
	}
	case KVM_GET_STATS_FD: {
<yellow>		r = kvm_vcpu_ioctl_get_stats_fd(vcpu);</yellow>
		break;
	}
	default:
<blue>		r = kvm_arch_vcpu_ioctl(filp, ioctl, arg);</blue>
	}
out:
<blue>	mutex_unlock(&vcpu->mutex);</blue>
	kfree(fpu);
	kfree(kvm_sregs);
<blue>	return r;</blue>
}

#ifdef CONFIG_KVM_COMPAT
static long kvm_vcpu_compat_ioctl(struct file *filp,
				  unsigned int ioctl, unsigned long arg)
<yellow>{</yellow>
<yellow>	struct kvm_vcpu *vcpu = filp->private_data;</yellow>
	void __user *argp = compat_ptr(arg);
	int r;

<yellow>	if (vcpu->kvm->mm != current->mm || vcpu->kvm->vm_dead)</yellow>
		return -EIO;

<yellow>	switch (ioctl) {</yellow>
	case KVM_SET_SIGNAL_MASK: {
		struct kvm_signal_mask __user *sigmask_arg = argp;
		struct kvm_signal_mask kvm_sigmask;
		sigset_t sigset;

		if (argp) {
			r = -EFAULT;
<yellow>			if (copy_from_user(&kvm_sigmask, argp,</yellow>
					   sizeof(kvm_sigmask)))
<yellow>				goto out;</yellow>
			r = -EINVAL;
<yellow>			if (kvm_sigmask.len != sizeof(compat_sigset_t))</yellow>
				goto out;
			r = -EFAULT;
			if (get_compat_sigset(&amp;sigset,
<yellow>					      (compat_sigset_t __user *)sigmask_arg->sigset))</yellow>
				goto out;
<yellow>			r = kvm_vcpu_ioctl_set_sigmask(vcpu, &sigset);</yellow>
		} else
<yellow>			r = kvm_vcpu_ioctl_set_sigmask(vcpu, NULL);</yellow>
<yellow>		break;</yellow>
	}
	default:
<yellow>		r = kvm_vcpu_ioctl(filp, ioctl, arg);</yellow>
	}

out:
	return r;
}
#endif

static int kvm_device_mmap(struct file *filp, struct vm_area_struct *vma)
{
<yellow>	struct kvm_device *dev = filp->private_data;</yellow>

<yellow>	if (dev->ops->mmap)</yellow>
<yellow>		return dev->ops->mmap(dev, vma);</yellow>

	return -ENODEV;
<yellow>}</yellow>

static int kvm_device_ioctl_attr(struct kvm_device *dev,
				 int (*accessor)(struct kvm_device *dev,
						 struct kvm_device_attr *attr),
				 unsigned long arg)
{
	struct kvm_device_attr attr;

	if (!accessor)
		return -EPERM;

<yellow>	if (copy_from_user(&attr, (void __user *)arg, sizeof(attr)))</yellow>
		return -EFAULT;

<yellow>	return accessor(dev, &attr);</yellow>
}

static long kvm_device_ioctl(struct file *filp, unsigned int ioctl,
			     unsigned long arg)
<yellow>{</yellow>
<yellow>	struct kvm_device *dev = filp->private_data;</yellow>

<yellow>	if (dev->kvm->mm != current->mm || dev->kvm->vm_dead)</yellow>
		return -EIO;

	switch (ioctl) {
	case KVM_SET_DEVICE_ATTR:
<yellow>		return kvm_device_ioctl_attr(dev, dev->ops->set_attr, arg);</yellow>
	case KVM_GET_DEVICE_ATTR:
<yellow>		return kvm_device_ioctl_attr(dev, dev->ops->get_attr, arg);</yellow>
	case KVM_HAS_DEVICE_ATTR:
<yellow>		return kvm_device_ioctl_attr(dev, dev->ops->has_attr, arg);</yellow>
	default:
<yellow>		if (dev->ops->ioctl)</yellow>
<yellow>			return dev->ops->ioctl(dev, ioctl, arg);</yellow>

		return -ENOTTY;
	}
}

static int kvm_device_release(struct inode *inode, struct file *filp)
{
<yellow>	struct kvm_device *dev = filp->private_data;</yellow>
	struct kvm *kvm = dev-&gt;kvm;

	if (dev-&gt;ops-&gt;release) {
<yellow>		mutex_lock(&kvm->lock);</yellow>
		list_del(&amp;dev-&gt;vm_node);
		dev-&gt;ops-&gt;release(dev);
		mutex_unlock(&amp;kvm-&gt;lock);
	}

<yellow>	kvm_put_kvm(kvm);</yellow>
	return 0;
}

static const struct file_operations kvm_device_fops = {
	.unlocked_ioctl = kvm_device_ioctl,
	.release = kvm_device_release,
	KVM_COMPAT(kvm_device_ioctl),
	.mmap = kvm_device_mmap,
};

struct kvm_device *kvm_device_from_filp(struct file *filp)
{
<yellow>	if (filp->f_op != &kvm_device_fops)</yellow>
		return NULL;

<yellow>	return filp->private_data;</yellow>
<yellow>}</yellow>

static const struct kvm_device_ops *kvm_device_ops_table[KVM_DEV_TYPE_MAX] = {
#ifdef CONFIG_KVM_MPIC
	[KVM_DEV_TYPE_FSL_MPIC_20]	= &amp;kvm_mpic_ops,
	[KVM_DEV_TYPE_FSL_MPIC_42]	= &amp;kvm_mpic_ops,
#endif
};

int kvm_register_device_ops(const struct kvm_device_ops *ops, u32 type)
{
<yellow>	if (type >= ARRAY_SIZE(kvm_device_ops_table))</yellow>
		return -ENOSPC;

<yellow>	if (kvm_device_ops_table[type] != NULL)</yellow>
		return -EEXIST;

<yellow>	kvm_device_ops_table[type] = ops;</yellow>
	return 0;
<yellow>}</yellow>

void kvm_unregister_device_ops(u32 type)
{
<yellow>	if (kvm_device_ops_table[type] != NULL)</yellow>
<yellow>		kvm_device_ops_table[type] = NULL;</yellow>
<yellow>}</yellow>

static int kvm_ioctl_create_device(struct kvm *kvm,
				   struct kvm_create_device *cd)
{
	const struct kvm_device_ops *ops;
	struct kvm_device *dev;
<yellow>	bool test = cd->flags & KVM_CREATE_DEVICE_TEST;</yellow>
	int type;
	int ret;

	if (cd-&gt;type &gt;= ARRAY_SIZE(kvm_device_ops_table))
		return -ENODEV;

<yellow>	type = array_index_nospec(cd->type, ARRAY_SIZE(kvm_device_ops_table));</yellow>
	ops = kvm_device_ops_table[type];
	if (ops == NULL)
		return -ENODEV;

<yellow>	if (test)</yellow>
		return 0;

<yellow>	dev = kzalloc(sizeof(*dev), GFP_KERNEL_ACCOUNT);</yellow>
	if (!dev)
		return -ENOMEM;

<yellow>	dev->ops = ops;</yellow>
	dev-&gt;kvm = kvm;

	mutex_lock(&amp;kvm-&gt;lock);
	ret = ops-&gt;create(dev, type);
	if (ret &lt; 0) {
<yellow>		mutex_unlock(&kvm->lock);</yellow>
		kfree(dev);
		return ret;
	}
<yellow>	list_add(&dev->vm_node, &kvm->devices);</yellow>
	mutex_unlock(&amp;kvm-&gt;lock);

	if (ops-&gt;init)
<yellow>		ops->init(dev);</yellow>

<yellow>	kvm_get_kvm(kvm);</yellow>
<yellow>	ret = anon_inode_getfd(ops->name, &kvm_device_fops, dev, O_RDWR | O_CLOEXEC);</yellow>
	if (ret &lt; 0) {
<yellow>		kvm_put_kvm_no_destroy(kvm);</yellow>
		mutex_lock(&amp;kvm-&gt;lock);
		list_del(&amp;dev-&gt;vm_node);
		if (ops-&gt;release)
<yellow>			ops->release(dev);</yellow>
<yellow>		mutex_unlock(&kvm->lock);</yellow>
		if (ops-&gt;destroy)
<yellow>			ops->destroy(dev);</yellow>
		return ret;
	}

<yellow>	cd->fd = ret;</yellow>
	return 0;
}

static long kvm_vm_ioctl_check_extension_generic(struct kvm *kvm, long arg)
{
<blue>	switch (arg) {</blue>
	case KVM_CAP_USER_MEMORY:
	case KVM_CAP_DESTROY_MEMORY_REGION_WORKS:
	case KVM_CAP_JOIN_MEMORY_REGIONS_WORKS:
	case KVM_CAP_INTERNAL_ERROR_DATA:
#ifdef CONFIG_HAVE_KVM_MSI
	case KVM_CAP_SIGNAL_MSI:
#endif
#ifdef CONFIG_HAVE_KVM_IRQFD
	case KVM_CAP_IRQFD:
	case KVM_CAP_IRQFD_RESAMPLE:
#endif
	case KVM_CAP_IOEVENTFD_ANY_LENGTH:
	case KVM_CAP_CHECK_EXTENSION_VM:
	case KVM_CAP_ENABLE_CAP_VM:
	case KVM_CAP_HALT_POLL:
		return 1;
#ifdef CONFIG_KVM_MMIO
	case KVM_CAP_COALESCED_MMIO:
		return KVM_COALESCED_MMIO_PAGE_OFFSET;
	case KVM_CAP_COALESCED_PIO:
		return 1;
#endif
#ifdef CONFIG_KVM_GENERIC_DIRTYLOG_READ_PROTECT
	case KVM_CAP_MANUAL_DIRTY_LOG_PROTECT2:
		return KVM_DIRTY_LOG_MANUAL_CAPS;
#endif
#ifdef CONFIG_HAVE_KVM_IRQ_ROUTING
	case KVM_CAP_IRQ_ROUTING:
		return KVM_MAX_IRQ_ROUTES;
#endif
#if KVM_ADDRESS_SPACE_NUM &gt; 1
	case KVM_CAP_MULTI_ADDRESS_SPACE:
		return KVM_ADDRESS_SPACE_NUM;
#endif
	case KVM_CAP_NR_MEMSLOTS:
<blue>		return KVM_USER_MEM_SLOTS;</blue>
	case KVM_CAP_DIRTY_LOG_RING:
#ifdef CONFIG_HAVE_KVM_DIRTY_RING_TSO
		return KVM_DIRTY_RING_MAX_ENTRIES * sizeof(struct kvm_dirty_gfn);
#else
		return 0;
#endif
	case KVM_CAP_DIRTY_LOG_RING_ACQ_REL:
#ifdef CONFIG_HAVE_KVM_DIRTY_RING_ACQ_REL
		return KVM_DIRTY_RING_MAX_ENTRIES * sizeof(struct kvm_dirty_gfn);
#else
		return 0;
#endif
	case KVM_CAP_BINARY_STATS_FD:
	case KVM_CAP_SYSTEM_EVENT_DATA:
		return 1;
	default:
		break;
	}
<blue>	return kvm_vm_ioctl_check_extension(kvm, arg);</blue>
<blue>}</blue>

static int kvm_vm_ioctl_enable_dirty_log_ring(struct kvm *kvm, u32 size)
{
	int r;

	if (!KVM_DIRTY_LOG_PAGE_OFFSET)
		return -EINVAL;

	/* the size should be power of 2 */
<yellow>	if (!size || (size & (size - 1)))</yellow>
		return -EINVAL;

	/* Should be bigger to keep the reserved entries, or a page */
<yellow>	if (size < kvm_dirty_ring_get_rsvd_entries() *</yellow>
<yellow>	    sizeof(struct kvm_dirty_gfn) || size < PAGE_SIZE)</yellow>
		return -EINVAL;

<yellow>	if (size > KVM_DIRTY_RING_MAX_ENTRIES *</yellow>
	    sizeof(struct kvm_dirty_gfn))
		return -E2BIG;

	/* We only allow it to set once */
<yellow>	if (kvm->dirty_ring_size)</yellow>
		return -EINVAL;

<yellow>	mutex_lock(&kvm->lock);</yellow>

	if (kvm-&gt;created_vcpus) {
		/* We don&#x27;t allow to change this value after vcpu created */
		r = -EINVAL;
	} else {
<yellow>		kvm->dirty_ring_size = size;</yellow>
		r = 0;
	}

<yellow>	mutex_unlock(&kvm->lock);</yellow>
	return r;
}

static int kvm_vm_ioctl_reset_dirty_pages(struct kvm *kvm)
{
	unsigned long i;
	struct kvm_vcpu *vcpu;
	int cleared = 0;

<yellow>	if (!kvm->dirty_ring_size)</yellow>
		return -EINVAL;

<yellow>	mutex_lock(&kvm->slots_lock);</yellow>

	kvm_for_each_vcpu(i, vcpu, kvm)
<yellow>		cleared += kvm_dirty_ring_reset(vcpu->kvm, &vcpu->dirty_ring);</yellow>

<yellow>	mutex_unlock(&kvm->slots_lock);</yellow>

	if (cleared)
<yellow>		kvm_flush_remote_tlbs(kvm);</yellow>

	return cleared;
}

int __attribute__((weak)) kvm_vm_ioctl_enable_cap(struct kvm *kvm,
						  struct kvm_enable_cap *cap)
{
	return -EINVAL;
<yellow>}</yellow>

static int kvm_vm_ioctl_enable_cap_generic(struct kvm *kvm,
					   struct kvm_enable_cap *cap)
{
<blue>	switch (cap->cap) {</blue>
#ifdef CONFIG_KVM_GENERIC_DIRTYLOG_READ_PROTECT
	case KVM_CAP_MANUAL_DIRTY_LOG_PROTECT2: {
		u64 allowed_options = KVM_DIRTY_LOG_MANUAL_PROTECT_ENABLE;

<blue>		if (cap->args[0] & KVM_DIRTY_LOG_MANUAL_PROTECT_ENABLE)</blue>
			allowed_options = KVM_DIRTY_LOG_MANUAL_CAPS;

<blue>		if (cap->flags || (cap->args[0] & ~allowed_options))</blue>
			return -EINVAL;
<blue>		kvm->manual_dirty_log_protect = cap->args[0];</blue>
		return 0;
	}
#endif
	case KVM_CAP_HALT_POLL: {
<yellow>		if (cap->flags || cap->args[0] != (unsigned int)cap->args[0])</yellow>
			return -EINVAL;

<yellow>		kvm->max_halt_poll_ns = cap->args[0];</yellow>

		/*
		 * Ensure kvm-&gt;override_halt_poll_ns does not become visible
		 * before kvm-&gt;max_halt_poll_ns.
		 *
		 * Pairs with the smp_rmb() in kvm_vcpu_max_halt_poll_ns().
		 */
		smp_wmb();
		kvm-&gt;override_halt_poll_ns = true;

		return 0;
	}
	case KVM_CAP_DIRTY_LOG_RING:
	case KVM_CAP_DIRTY_LOG_RING_ACQ_REL:
<yellow>		if (!kvm_vm_ioctl_check_extension_generic(kvm, cap->cap))</yellow>
			return -EINVAL;

<yellow>		return kvm_vm_ioctl_enable_dirty_log_ring(kvm, cap->args[0]);</yellow>
	default:
<blue>		return kvm_vm_ioctl_enable_cap(kvm, cap);</blue>
	}
}

static ssize_t kvm_vm_stats_read(struct file *file, char __user *user_buffer,
			      size_t size, loff_t *offset)
{
<yellow>	struct kvm *kvm = file->private_data;</yellow>

	return kvm_stats_read(kvm-&gt;stats_id, &amp;kvm_vm_stats_header,
				&amp;kvm_vm_stats_desc[0], &amp;kvm-&gt;stat,
				sizeof(kvm-&gt;stat), user_buffer, size, offset);
}

static const struct file_operations kvm_vm_stats_fops = {
	.read = kvm_vm_stats_read,
	.llseek = noop_llseek,
};

static int kvm_vm_ioctl_get_stats_fd(struct kvm *kvm)
{
	int fd;
	struct file *file;

<yellow>	fd = get_unused_fd_flags(O_CLOEXEC);</yellow>
	if (fd &lt; 0)
		return fd;

<yellow>	file = anon_inode_getfile("kvm-vm-stats",</yellow>
			&amp;kvm_vm_stats_fops, kvm, O_RDONLY);
	if (IS_ERR(file)) {
<yellow>		put_unused_fd(fd);</yellow>
		return PTR_ERR(file);
	}
<yellow>	file->f_mode |= FMODE_PREAD;</yellow>
	fd_install(fd, file);

	return fd;
}

static long kvm_vm_ioctl(struct file *filp,
			   unsigned int ioctl, unsigned long arg)
<blue>{</blue>
<blue>	struct kvm *kvm = filp->private_data;</blue>
	void __user *argp = (void __user *)arg;
	int r;

<blue>	if (kvm->mm != current->mm || kvm->vm_dead)</blue>
		return -EIO;
<blue>	switch (ioctl) {</blue>
	case KVM_CREATE_VCPU:
<blue>		r = kvm_vm_ioctl_create_vcpu(kvm, arg);</blue>
		break;
	case KVM_ENABLE_CAP: {
		struct kvm_enable_cap cap;

		r = -EFAULT;
<blue>		if (copy_from_user(&cap, argp, sizeof(cap)))</blue>
			goto out;
<blue>		r = kvm_vm_ioctl_enable_cap_generic(kvm, &cap);</blue>
		break;
	}
	case KVM_SET_USER_MEMORY_REGION: {
		struct kvm_userspace_memory_region kvm_userspace_mem;

		r = -EFAULT;
<blue>		if (copy_from_user(&kvm_userspace_mem, argp,</blue>
						sizeof(kvm_userspace_mem)))
			goto out;

<blue>		r = kvm_vm_ioctl_set_memory_region(kvm, &kvm_userspace_mem);</blue>
		break;
	}
	case KVM_GET_DIRTY_LOG: {
		struct kvm_dirty_log log;

		r = -EFAULT;
<yellow>		if (copy_from_user(&log, argp, sizeof(log)))</yellow>
			goto out;
<yellow>		r = kvm_vm_ioctl_get_dirty_log(kvm, &log);</yellow>
		break;
	}
#ifdef CONFIG_KVM_GENERIC_DIRTYLOG_READ_PROTECT
	case KVM_CLEAR_DIRTY_LOG: {
		struct kvm_clear_dirty_log log;

		r = -EFAULT;
<yellow>		if (copy_from_user(&log, argp, sizeof(log)))</yellow>
			goto out;
<yellow>		r = kvm_vm_ioctl_clear_dirty_log(kvm, &log);</yellow>
		break;
	}
#endif
#ifdef CONFIG_KVM_MMIO
	case KVM_REGISTER_COALESCED_MMIO: {
		struct kvm_coalesced_mmio_zone zone;

		r = -EFAULT;
<blue>		if (copy_from_user(&zone, argp, sizeof(zone)))</blue>
			goto out;
<blue>		r = kvm_vm_ioctl_register_coalesced_mmio(kvm, &zone);</blue>
		break;
	}
	case KVM_UNREGISTER_COALESCED_MMIO: {
		struct kvm_coalesced_mmio_zone zone;

		r = -EFAULT;
<blue>		if (copy_from_user(&zone, argp, sizeof(zone)))</blue>
			goto out;
<blue>		r = kvm_vm_ioctl_unregister_coalesced_mmio(kvm, &zone);</blue>
		break;
	}
#endif
	case KVM_IRQFD: {
		struct kvm_irqfd data;

		r = -EFAULT;
<yellow>		if (copy_from_user(&data, argp, sizeof(data)))</yellow>
			goto out;
<yellow>		r = kvm_irqfd(kvm, &data);</yellow>
		break;
	}
	case KVM_IOEVENTFD: {
		struct kvm_ioeventfd data;

		r = -EFAULT;
<blue>		if (copy_from_user(&data, argp, sizeof(data)))</blue>
			goto out;
<blue>		r = kvm_ioeventfd(kvm, &data);</blue>
		break;
	}
#ifdef CONFIG_HAVE_KVM_MSI
	case KVM_SIGNAL_MSI: {
		struct kvm_msi msi;

		r = -EFAULT;
<yellow>		if (copy_from_user(&msi, argp, sizeof(msi)))</yellow>
<yellow>			goto out;</yellow>
<yellow>		r = kvm_send_userspace_msi(kvm, &msi);</yellow>
		break;
	}
#endif
#ifdef __KVM_HAVE_IRQ_LINE
	case KVM_IRQ_LINE_STATUS:
	case KVM_IRQ_LINE: {
		struct kvm_irq_level irq_event;

		r = -EFAULT;
<blue>		if (copy_from_user(&irq_event, argp, sizeof(irq_event)))</blue>
			goto out;

<blue>		r = kvm_vm_ioctl_irq_line(kvm, &irq_event,</blue>
					ioctl == KVM_IRQ_LINE_STATUS);
		if (r)
			goto out;

		r = -EFAULT;
<blue>		if (ioctl == KVM_IRQ_LINE_STATUS) {</blue>
<blue>			if (copy_to_user(argp, &irq_event, sizeof(irq_event)))</blue>
				goto out;
		}

		r = 0;
		break;
	}
#endif
#ifdef CONFIG_HAVE_KVM_IRQ_ROUTING
	case KVM_SET_GSI_ROUTING: {
		struct kvm_irq_routing routing;
		struct kvm_irq_routing __user *urouting;
		struct kvm_irq_routing_entry *entries = NULL;

		r = -EFAULT;
<blue>		if (copy_from_user(&routing, argp, sizeof(routing)))</blue>
			goto out;
		r = -EINVAL;
<blue>		if (!kvm_arch_can_set_irq_routing(kvm))</blue>
			goto out;
<blue>		if (routing.nr > KVM_MAX_IRQ_ROUTES)</blue>
			goto out;
<blue>		if (routing.flags)</blue>
			goto out;
<blue>		if (routing.nr) {</blue>
			urouting = argp;
<blue>			entries = vmemdup_user(urouting->entries,</blue>
					       array_size(sizeof(*entries),
							  routing.nr));
			if (IS_ERR(entries)) {
				r = PTR_ERR(entries);
				goto out;
			}
		}
<blue>		r = kvm_set_irq_routing(kvm, entries, routing.nr,</blue>
					routing.flags);
		kvfree(entries);
		break;
	}
#endif /* CONFIG_HAVE_KVM_IRQ_ROUTING */
	case KVM_CREATE_DEVICE: {
		struct kvm_create_device cd;

		r = -EFAULT;
<yellow>		if (copy_from_user(&cd, argp, sizeof(cd)))</yellow>
			goto out;

<yellow>		r = kvm_ioctl_create_device(kvm, &cd);</yellow>
		if (r)
			goto out;

		r = -EFAULT;
<yellow>		if (copy_to_user(argp, &cd, sizeof(cd)))</yellow>
			goto out;

		r = 0;
<blue>		break;</blue>
	}
	case KVM_CHECK_EXTENSION:
<blue>		r = kvm_vm_ioctl_check_extension_generic(kvm, arg);</blue>
		break;
	case KVM_RESET_DIRTY_RINGS:
<yellow>		r = kvm_vm_ioctl_reset_dirty_pages(kvm);</yellow>
		break;
	case KVM_GET_STATS_FD:
<yellow>		r = kvm_vm_ioctl_get_stats_fd(kvm);</yellow>
		break;
	default:
<blue>		r = kvm_arch_vm_ioctl(filp, ioctl, arg);</blue>
	}
out:
<blue>	return r;</blue>
}

#ifdef CONFIG_KVM_COMPAT
struct compat_kvm_dirty_log {
	__u32 slot;
	__u32 padding1;
	union {
		compat_uptr_t dirty_bitmap; /* one bit per page */
		__u64 padding2;
	};
};

struct compat_kvm_clear_dirty_log {
	__u32 slot;
	__u32 num_pages;
	__u64 first_page;
	union {
		compat_uptr_t dirty_bitmap; /* one bit per page */
		__u64 padding2;
	};
};

long __weak kvm_arch_vm_compat_ioctl(struct file *filp, unsigned int ioctl,
				     unsigned long arg)
{
	return -ENOTTY;
<yellow>}</yellow>

static long kvm_vm_compat_ioctl(struct file *filp,
			   unsigned int ioctl, unsigned long arg)
<yellow>{</yellow>
<yellow>	struct kvm *kvm = filp->private_data;</yellow>
	int r;

<yellow>	if (kvm->mm != current->mm || kvm->vm_dead)</yellow>
		return -EIO;

<yellow>	r = kvm_arch_vm_compat_ioctl(filp, ioctl, arg);</yellow>
	if (r != -ENOTTY)
<yellow>		return r;</yellow>

<yellow>	switch (ioctl) {</yellow>
#ifdef CONFIG_KVM_GENERIC_DIRTYLOG_READ_PROTECT
	case KVM_CLEAR_DIRTY_LOG: {
		struct compat_kvm_clear_dirty_log compat_log;
		struct kvm_clear_dirty_log log;

<yellow>		if (copy_from_user(&compat_log, (void __user *)arg,</yellow>
				   sizeof(compat_log)))
			return -EFAULT;
		log.slot	 = compat_log.slot;
		log.num_pages	 = compat_log.num_pages;
<yellow>		log.first_page	 = compat_log.first_page;</yellow>
		log.padding2	 = compat_log.padding2;
		log.dirty_bitmap = compat_ptr(compat_log.dirty_bitmap);

		r = kvm_vm_ioctl_clear_dirty_log(kvm, &amp;log);
		break;
	}
#endif
	case KVM_GET_DIRTY_LOG: {
		struct compat_kvm_dirty_log compat_log;
		struct kvm_dirty_log log;

<yellow>		if (copy_from_user(&compat_log, (void __user *)arg,</yellow>
				   sizeof(compat_log)))
<yellow>			return -EFAULT;</yellow>
<yellow>		log.slot	 = compat_log.slot;</yellow>
		log.padding1	 = compat_log.padding1;
		log.padding2	 = compat_log.padding2;
		log.dirty_bitmap = compat_ptr(compat_log.dirty_bitmap);

		r = kvm_vm_ioctl_get_dirty_log(kvm, &amp;log);
		break;
	}
	default:
<yellow>		r = kvm_vm_ioctl(filp, ioctl, arg);</yellow>
	}
<yellow>	return r;</yellow>
}
#endif

static const struct file_operations kvm_vm_fops = {
	.release        = kvm_vm_release,
	.unlocked_ioctl = kvm_vm_ioctl,
	.llseek		= noop_llseek,
	KVM_COMPAT(kvm_vm_compat_ioctl),
};

bool file_is_kvm(struct file *file)
<yellow>{</yellow>
<yellow>	return file && file->f_op == &kvm_vm_fops;</yellow>
<yellow>}</yellow>
EXPORT_SYMBOL_GPL(file_is_kvm);

static int kvm_dev_ioctl_create_vm(unsigned long type)
{
	char fdname[ITOA_MAX_LEN + 1];
	int r, fd;
	struct kvm *kvm;
	struct file *file;

<blue>	fd = get_unused_fd_flags(O_CLOEXEC);</blue>
	if (fd &lt; 0)
		return fd;

<blue>	snprintf(fdname, sizeof(fdname), "%d", fd);</blue>

<blue>	kvm = kvm_create_vm(type, fdname);</blue>
<blue>	if (IS_ERR(kvm)) {</blue>
<yellow>		r = PTR_ERR(kvm);</yellow>
		goto put_fd;
	}

<blue>	file = anon_inode_getfile("kvm-vm", &kvm_vm_fops, kvm, O_RDWR);</blue>
	if (IS_ERR(file)) {
		r = PTR_ERR(file);
		goto put_kvm;
	}

	/*
	 * Don&#x27;t call kvm_put_kvm anymore at this point; file-&gt;f_op is
	 * already set, with -&gt;release() being kvm_vm_release().  In error
	 * cases it will be called by the final fput(file) and will take
	 * care of doing kvm_put_kvm(kvm).
	 */
<blue>	kvm_uevent_notify_change(KVM_EVENT_CREATE_VM, kvm);</blue>

<blue>	fd_install(fd, file);</blue>
	return fd;

put_kvm:
<yellow>	kvm_put_kvm(kvm);</yellow>
put_fd:
<yellow>	put_unused_fd(fd);</yellow>
	return r;
}

static long kvm_dev_ioctl(struct file *filp,
			  unsigned int ioctl, unsigned long arg)
<blue>{</blue>
	long r = -EINVAL;

<blue>	switch (ioctl) {</blue>
	case KVM_GET_API_VERSION:
<blue>		if (arg)</blue>
			goto out;
		r = KVM_API_VERSION;
		break;
	case KVM_CREATE_VM:
<blue>		r = kvm_dev_ioctl_create_vm(arg);</blue>
		break;
	case KVM_CHECK_EXTENSION:
<blue>		r = kvm_vm_ioctl_check_extension_generic(NULL, arg);</blue>
		break;
	case KVM_GET_VCPU_MMAP_SIZE:
<blue>		if (arg)</blue>
			goto out;
		r = PAGE_SIZE;     /* struct kvm_run */
#ifdef CONFIG_X86
		r += PAGE_SIZE;    /* pio data page */
#endif
#ifdef CONFIG_KVM_MMIO
		r += PAGE_SIZE;    /* coalesced mmio ring page */
#endif
		break;
	case KVM_TRACE_ENABLE:
	case KVM_TRACE_PAUSE:
	case KVM_TRACE_DISABLE:
		r = -EOPNOTSUPP;
		break;
	default:
<blue>		return kvm_arch_dev_ioctl(filp, ioctl, arg);</blue>
	}
out:
	return r;
}

static struct file_operations kvm_chardev_ops = {
	.unlocked_ioctl = kvm_dev_ioctl,
	.llseek		= noop_llseek,
	KVM_COMPAT(kvm_dev_ioctl),
};

static struct miscdevice kvm_dev = {
	KVM_MINOR,
	&quot;kvm&quot;,
	&amp;kvm_chardev_ops,
};

static void hardware_enable_nolock(void *junk)
{
<blue>	int cpu = raw_smp_processor_id();</blue>
	int r;

	if (cpumask_test_cpu(cpu, cpus_hardware_enabled))
		return;

<blue>	cpumask_set_cpu(cpu, cpus_hardware_enabled);</blue>

	r = kvm_arch_hardware_enable();

	if (r) {
<yellow>		cpumask_clear_cpu(cpu, cpus_hardware_enabled);</yellow>
		atomic_inc(&amp;hardware_enable_failed);
		pr_info(&quot;kvm: enabling virtualization on CPU%d failed\n&quot;, cpu);
	}
<blue>}</blue>

static int kvm_starting_cpu(unsigned int cpu)
{
<yellow>	raw_spin_lock(&kvm_count_lock);</yellow>
	if (kvm_usage_count)
<yellow>		hardware_enable_nolock(NULL);</yellow>
<yellow>	raw_spin_unlock(&kvm_count_lock);</yellow>
	return 0;
}

static void hardware_disable_nolock(void *junk)
{
<yellow>	int cpu = raw_smp_processor_id();</yellow>

	if (!cpumask_test_cpu(cpu, cpus_hardware_enabled))
		return;
<yellow>	cpumask_clear_cpu(cpu, cpus_hardware_enabled);</yellow>
	kvm_arch_hardware_disable();
<yellow>}</yellow>

static int kvm_dying_cpu(unsigned int cpu)
{
<yellow>	raw_spin_lock(&kvm_count_lock);</yellow>
	if (kvm_usage_count)
<yellow>		hardware_disable_nolock(NULL);</yellow>
<yellow>	raw_spin_unlock(&kvm_count_lock);</yellow>
	return 0;
}

<yellow>static void hardware_disable_all_nolock(void)</yellow>
{
<yellow>	BUG_ON(!kvm_usage_count);</yellow>

<yellow>	kvm_usage_count--;</yellow>
	if (!kvm_usage_count)
<yellow>		on_each_cpu(hardware_disable_nolock, NULL, 1);</yellow>
}

static void hardware_disable_all(void)
{
<yellow>	raw_spin_lock(&kvm_count_lock);</yellow>
<yellow>	hardware_disable_all_nolock();</yellow>
<yellow>	raw_spin_unlock(&kvm_count_lock);</yellow>
}

static int hardware_enable_all(void)
{
	int r = 0;

<blue>	raw_spin_lock(&kvm_count_lock);</blue>

	kvm_usage_count++;
	if (kvm_usage_count == 1) {
<blue>		atomic_set(&hardware_enable_failed, 0);</blue>
		on_each_cpu(hardware_enable_nolock, NULL, 1);

		if (atomic_read(&amp;hardware_enable_failed)) {
<yellow>			hardware_disable_all_nolock();</yellow>
			r = -EBUSY;
		}
	}

<blue>	raw_spin_unlock(&kvm_count_lock);</blue>

	return r;
}

static int kvm_reboot(struct notifier_block *notifier, unsigned long val,
		      void *v)
{
	/*
	 * Some (well, at least mine) BIOSes hang on reboot if
	 * in vmx root mode.
	 *
	 * And Intel TXT required VMX off for all cpu when system shutdown.
	 */
	pr_info(&quot;kvm: exiting hardware virtualization\n&quot;);
	kvm_rebooting = true;
	on_each_cpu(hardware_disable_nolock, NULL, 1);
	return NOTIFY_OK;
}

static struct notifier_block kvm_reboot_notifier = {
	.notifier_call = kvm_reboot,
	.priority = 0,
};

static void kvm_io_bus_destroy(struct kvm_io_bus *bus)
{
	int i;

<yellow>	for (i = 0; i < bus->dev_count; i++) {</yellow>
<yellow>		struct kvm_io_device *pos = bus->range[i].dev;</yellow>

<yellow>		kvm_iodevice_destructor(pos);</yellow>
	}
<yellow>	kfree(bus);</yellow>
}

static inline int kvm_io_bus_cmp(const struct kvm_io_range *r1,
				 const struct kvm_io_range *r2)
{
<blue>	gpa_t addr1 = r1->addr;</blue>
<blue>	gpa_t addr2 = r2->addr;</blue>

<yellow>	if (addr1 < addr2)</yellow>
		return -1;

	/* If r2-&gt;len == 0, match the exact address.  If r2-&gt;len != 0,
	 * accept any overlapping write.  Any order is acceptable for
	 * overlapping ranges, because kvm_io_bus_get_first_dev ensures
	 * we process all of them.
	 */
<blue>	if (r2->len) {</blue>
<blue>		addr1 += r1->len;</blue>
<blue>		addr2 += r2->len;</blue>
	}

<blue>	if (addr1 > addr2)</blue>
		return 1;

	return 0;
}

static int kvm_io_bus_sort_cmp(const void *p1, const void *p2)
<yellow>{</yellow>
<blue>	return kvm_io_bus_cmp(p1, p2);</blue>
<blue>}</blue>

static int kvm_io_bus_get_first_dev(struct kvm_io_bus *bus,
			     gpa_t addr, int len)
<blue>{</blue>
	struct kvm_io_range *range, key;
	int off;

	key = (struct kvm_io_range) {
		.addr = addr,
		.len = len,
	};

<blue>	range = bsearch(&key, bus->range, bus->dev_count,</blue>
			sizeof(struct kvm_io_range), kvm_io_bus_sort_cmp);
	if (range == NULL)
		return -ENOENT;

<blue>	off = range - bus->range;</blue>

<blue>	while (off > 0 && kvm_io_bus_cmp(&key, &bus->range[off-1]) == 0)</blue>
		off--;

	return off;
}

static int __kvm_io_bus_write(struct kvm_vcpu *vcpu, struct kvm_io_bus *bus,
			      struct kvm_io_range *range, const void *val)
{
	int idx;

<blue>	idx = kvm_io_bus_get_first_dev(bus, range->addr, range->len);</blue>
	if (idx &lt; 0)
		return -EOPNOTSUPP;

<blue>	while (idx < bus->dev_count &&</blue>
<blue>		kvm_io_bus_cmp(range, &bus->range[idx]) == 0) {</blue>
<blue>		if (!kvm_iodevice_write(vcpu, bus->range[idx].dev, range->addr,</blue>
					range-&gt;len, val))
			return idx;
<yellow>		idx++;</yellow>
	}

	return -EOPNOTSUPP;
<blue>}</blue>

/* kvm_io_bus_write - called under kvm-&gt;slots_lock */
int kvm_io_bus_write(struct kvm_vcpu *vcpu, enum kvm_bus bus_idx, gpa_t addr,
		     int len, const void *val)
<blue>{</blue>
	struct kvm_io_bus *bus;
	struct kvm_io_range range;
	int r;

<blue>	range = (struct kvm_io_range) {</blue>
		.addr = addr,
		.len = len,
	};

	bus = srcu_dereference(vcpu-&gt;kvm-&gt;buses[bus_idx], &amp;vcpu-&gt;kvm-&gt;srcu);
	if (!bus)
		return -ENOMEM;
<blue>	r = __kvm_io_bus_write(vcpu, bus, &range, val);</blue>
	return r &lt; 0 ? r : 0;
}
EXPORT_SYMBOL_GPL(kvm_io_bus_write);

/* kvm_io_bus_write_cookie - called under kvm-&gt;slots_lock */
int kvm_io_bus_write_cookie(struct kvm_vcpu *vcpu, enum kvm_bus bus_idx,
			    gpa_t addr, int len, const void *val, long cookie)
<yellow>{</yellow>
	struct kvm_io_bus *bus;
	struct kvm_io_range range;

<yellow>	range = (struct kvm_io_range) {</yellow>
		.addr = addr,
		.len = len,
	};

	bus = srcu_dereference(vcpu-&gt;kvm-&gt;buses[bus_idx], &amp;vcpu-&gt;kvm-&gt;srcu);
	if (!bus)
		return -ENOMEM;

	/* First try the device referenced by cookie. */
<yellow>	if ((cookie >= 0) && (cookie < bus->dev_count) &&</yellow>
<yellow>	    (kvm_io_bus_cmp(&range, &bus->range[cookie]) == 0))</yellow>
<yellow>		if (!kvm_iodevice_write(vcpu, bus->range[cookie].dev, addr, len,</yellow>
					val))
<yellow>			return cookie;</yellow>

	/*
	 * cookie contained garbage; fall back to search and return the
	 * correct cookie value.
	 */
<yellow>	return __kvm_io_bus_write(vcpu, bus, &range, val);</yellow>
}

static int __kvm_io_bus_read(struct kvm_vcpu *vcpu, struct kvm_io_bus *bus,
			     struct kvm_io_range *range, void *val)
{
	int idx;

<blue>	idx = kvm_io_bus_get_first_dev(bus, range->addr, range->len);</blue>
	if (idx &lt; 0)
		return -EOPNOTSUPP;

<blue>	while (idx < bus->dev_count &&</blue>
<blue>		kvm_io_bus_cmp(range, &bus->range[idx]) == 0) {</blue>
<blue>		if (!kvm_iodevice_read(vcpu, bus->range[idx].dev, range->addr,</blue>
				       range-&gt;len, val))
			return idx;
		idx++;
	}

	return -EOPNOTSUPP;
}

/* kvm_io_bus_read - called under kvm-&gt;slots_lock */
int kvm_io_bus_read(struct kvm_vcpu *vcpu, enum kvm_bus bus_idx, gpa_t addr,
		    int len, void *val)
{
	struct kvm_io_bus *bus;
	struct kvm_io_range range;
	int r;

	range = (struct kvm_io_range) {
		.addr = addr,
		.len = len,
	};

<blue>	bus = srcu_dereference(vcpu->kvm->buses[bus_idx], &vcpu->kvm->srcu);</blue>
	if (!bus)
		return -ENOMEM;
<blue>	r = __kvm_io_bus_read(vcpu, bus, &range, val);</blue>
<blue>	return r < 0 ? r : 0;</blue>
<blue>}</blue>

/* Caller must hold slots_lock. */
int kvm_io_bus_register_dev(struct kvm *kvm, enum kvm_bus bus_idx, gpa_t addr,
			    int len, struct kvm_io_device *dev)
{
	int i;
	struct kvm_io_bus *new_bus, *bus;
	struct kvm_io_range range;

<blue>	bus = kvm_get_bus(kvm, bus_idx);</blue>
	if (!bus)
		return -ENOMEM;

	/* exclude ioeventfd which is limited by maximum fd */
<blue>	if (bus->dev_count - bus->ioeventfd_count > NR_IOBUS_DEVS - 1)</blue>
		return -ENOSPC;

<blue>	new_bus = kmalloc(struct_size(bus, range, bus->dev_count + 1),</blue>
			  GFP_KERNEL_ACCOUNT);
	if (!new_bus)
		return -ENOMEM;

	range = (struct kvm_io_range) {
		.addr = addr,
		.len = len,
		.dev = dev,
	};

<blue>	for (i = 0; i < bus->dev_count; i++)</blue>
<blue>		if (kvm_io_bus_cmp(&bus->range[i], &range) > 0)</blue>
			break;

<blue>	memcpy(new_bus, bus, sizeof(*bus) + i * sizeof(struct kvm_io_range));</blue>
	new_bus-&gt;dev_count++;
	new_bus-&gt;range[i] = range;
	memcpy(new_bus-&gt;range + i + 1, bus-&gt;range + i,
		(bus-&gt;dev_count - i) * sizeof(struct kvm_io_range));
	rcu_assign_pointer(kvm-&gt;buses[bus_idx], new_bus);
	synchronize_srcu_expedited(&amp;kvm-&gt;srcu);
	kfree(bus);

	return 0;
<blue>}</blue>

int kvm_io_bus_unregister_dev(struct kvm *kvm, enum kvm_bus bus_idx,
			      struct kvm_io_device *dev)
{
	int i, j;
	struct kvm_io_bus *new_bus, *bus;

	lockdep_assert_held(&amp;kvm-&gt;slots_lock);

<blue>	bus = kvm_get_bus(kvm, bus_idx);</blue>
	if (!bus)
		return 0;

<blue>	for (i = 0; i < bus->dev_count; i++) {</blue>
<blue>		if (bus->range[i].dev == dev) {</blue>
			break;
		}
	}

<yellow>	if (i == bus->dev_count)</yellow>
		return 0;

<blue>	new_bus = kmalloc(struct_size(bus, range, bus->dev_count - 1),</blue>
			  GFP_KERNEL_ACCOUNT);
	if (new_bus) {
<blue>		memcpy(new_bus, bus, struct_size(bus, range, i));</blue>
		new_bus-&gt;dev_count--;
<blue>		memcpy(new_bus->range + i, bus->range + i + 1,</blue>
				flex_array_size(new_bus, range, new_bus-&gt;dev_count - i));
	}

	rcu_assign_pointer(kvm-&gt;buses[bus_idx], new_bus);
	synchronize_srcu_expedited(&amp;kvm-&gt;srcu);

	/* Destroy the old bus _after_ installing the (null) bus. */
	if (!new_bus) {
		pr_err(&quot;kvm: failed to shrink bus, removing it completely\n&quot;);
		for (j = 0; j &lt; bus-&gt;dev_count; j++) {
			if (j == i)
				continue;
			kvm_iodevice_destructor(bus-&gt;range[j].dev);
		}
	}

	kfree(bus);
	return new_bus ? 0 : -ENOMEM;
<blue>}</blue>

struct kvm_io_device *kvm_io_bus_get_dev(struct kvm *kvm, enum kvm_bus bus_idx,
					 gpa_t addr)
{
	struct kvm_io_bus *bus;
	int dev_idx, srcu_idx;
	struct kvm_io_device *iodev = NULL;

<yellow>	srcu_idx = srcu_read_lock(&kvm->srcu);</yellow>

	bus = srcu_dereference(kvm-&gt;buses[bus_idx], &amp;kvm-&gt;srcu);
	if (!bus)
		goto out_unlock;

<yellow>	dev_idx = kvm_io_bus_get_first_dev(bus, addr, 1);</yellow>
	if (dev_idx &lt; 0)
		goto out_unlock;

<yellow>	iodev = bus->range[dev_idx].dev;</yellow>

out_unlock:
<yellow>	srcu_read_unlock(&kvm->srcu, srcu_idx);</yellow>

	return iodev;
}
EXPORT_SYMBOL_GPL(kvm_io_bus_get_dev);

static int kvm_debugfs_open(struct inode *inode, struct file *file,
			   int (*get)(void *, u64 *), int (*set)(void *, u64),
			   const char *fmt)
{
	int ret;
<yellow>	struct kvm_stat_data *stat_data = (struct kvm_stat_data *)</yellow>
					  inode-&gt;i_private;

	/*
	 * The debugfs files are a reference to the kvm struct which
        * is still valid when kvm_destroy_vm is called.  kvm_get_kvm_safe
        * avoids the race between open and the removal of the debugfs directory.
	 */
<yellow>	if (!kvm_get_kvm_safe(stat_data->kvm))</yellow>
		return -ENOENT;

<yellow>	ret = simple_attr_open(inode, file, get,</yellow>
<yellow>			       kvm_stats_debugfs_mode(stat_data->desc) & 0222</yellow>
			       ? set : NULL, fmt);
	if (ret)
<yellow>		kvm_put_kvm(stat_data->kvm);</yellow>

	return ret;
}

static int kvm_debugfs_release(struct inode *inode, struct file *file)
{
<yellow>	struct kvm_stat_data *stat_data = (struct kvm_stat_data *)</yellow>
					  inode-&gt;i_private;

	simple_attr_release(inode, file);
	kvm_put_kvm(stat_data-&gt;kvm);

	return 0;
}

static int kvm_get_stat_per_vm(struct kvm *kvm, size_t offset, u64 *val)
{
<yellow>	*val = *(u64 *)((void *)(&kvm->stat) + offset);</yellow>

	return 0;
}

static int kvm_clear_stat_per_vm(struct kvm *kvm, size_t offset)
{
<yellow>	*(u64 *)((void *)(&kvm->stat) + offset) = 0;</yellow>

	return 0;
}

static int kvm_get_stat_per_vcpu(struct kvm *kvm, size_t offset, u64 *val)
<yellow>{</yellow>
	unsigned long i;
	struct kvm_vcpu *vcpu;

<yellow>	*val = 0;</yellow>

	kvm_for_each_vcpu(i, vcpu, kvm)
<yellow>		*val += *(u64 *)((void *)(&vcpu->stat) + offset);</yellow>

	return 0;
}

static int kvm_clear_stat_per_vcpu(struct kvm *kvm, size_t offset)
<yellow>{</yellow>
	unsigned long i;
	struct kvm_vcpu *vcpu;

<yellow>	kvm_for_each_vcpu(i, vcpu, kvm)</yellow>
<yellow>		*(u64 *)((void *)(&vcpu->stat) + offset) = 0;</yellow>

	return 0;
}

<yellow>static int kvm_stat_data_get(void *data, u64 *val)</yellow>
{
	int r = -EFAULT;
	struct kvm_stat_data *stat_data = (struct kvm_stat_data *)data;

<yellow>	switch (stat_data->kind) {</yellow>
	case KVM_STAT_VM:
		r = kvm_get_stat_per_vm(stat_data-&gt;kvm,
<yellow>					stat_data->desc->desc.offset, val);</yellow>
		break;
	case KVM_STAT_VCPU:
		r = kvm_get_stat_per_vcpu(stat_data-&gt;kvm,
<yellow>					  stat_data->desc->desc.offset, val);</yellow>
		break;
	}

	return r;
<yellow>}</yellow>

<yellow>static int kvm_stat_data_clear(void *data, u64 val)</yellow>
{
	int r = -EFAULT;
	struct kvm_stat_data *stat_data = (struct kvm_stat_data *)data;

<yellow>	if (val)</yellow>
		return -EINVAL;

<yellow>	switch (stat_data->kind) {</yellow>
	case KVM_STAT_VM:
		r = kvm_clear_stat_per_vm(stat_data-&gt;kvm,
<yellow>					  stat_data->desc->desc.offset);</yellow>
		break;
	case KVM_STAT_VCPU:
		r = kvm_clear_stat_per_vcpu(stat_data-&gt;kvm,
<yellow>					    stat_data->desc->desc.offset);</yellow>
		break;
	}

	return r;
<yellow>}</yellow>

static int kvm_stat_data_open(struct inode *inode, struct file *file)
<yellow>{</yellow>
	__simple_attr_check_format(&quot;%llu\n&quot;, 0ull);
<yellow>	return kvm_debugfs_open(inode, file, kvm_stat_data_get,</yellow>
				kvm_stat_data_clear, &quot;%llu\n&quot;);
}

static const struct file_operations stat_fops_per_vm = {
	.owner = THIS_MODULE,
	.open = kvm_stat_data_open,
	.release = kvm_debugfs_release,
	.read = simple_attr_read,
	.write = simple_attr_write,
	.llseek = no_llseek,
};

static int vm_stat_get(void *_offset, u64 *val)
{
	unsigned offset = (long)_offset;
	struct kvm *kvm;
	u64 tmp_val;

<yellow>	*val = 0;</yellow>
	mutex_lock(&amp;kvm_lock);
	list_for_each_entry(kvm, &amp;vm_list, vm_list) {
<yellow>		kvm_get_stat_per_vm(kvm, offset, &tmp_val);</yellow>
		*val += tmp_val;
	}
<yellow>	mutex_unlock(&kvm_lock);</yellow>
	return 0;
}

static int vm_stat_clear(void *_offset, u64 val)
{
	unsigned offset = (long)_offset;
	struct kvm *kvm;

<yellow>	if (val)</yellow>
		return -EINVAL;

<yellow>	mutex_lock(&kvm_lock);</yellow>
	list_for_each_entry(kvm, &amp;vm_list, vm_list) {
<yellow>		kvm_clear_stat_per_vm(kvm, offset);</yellow>
	}
<yellow>	mutex_unlock(&kvm_lock);</yellow>

	return 0;
<yellow>}</yellow>

<yellow>DEFINE_SIMPLE_ATTRIBUTE(vm_stat_fops, vm_stat_get, vm_stat_clear, "%llu\n");</yellow>
<yellow>DEFINE_SIMPLE_ATTRIBUTE(vm_stat_readonly_fops, vm_stat_get, NULL, "%llu\n");</yellow>

static int vcpu_stat_get(void *_offset, u64 *val)
{
	unsigned offset = (long)_offset;
	struct kvm *kvm;
	u64 tmp_val;

<yellow>	*val = 0;</yellow>
	mutex_lock(&amp;kvm_lock);
	list_for_each_entry(kvm, &amp;vm_list, vm_list) {
<yellow>		kvm_get_stat_per_vcpu(kvm, offset, &tmp_val);</yellow>
<yellow>		*val += tmp_val;</yellow>
	}
<yellow>	mutex_unlock(&kvm_lock);</yellow>
	return 0;
}

static int vcpu_stat_clear(void *_offset, u64 val)
{
	unsigned offset = (long)_offset;
	struct kvm *kvm;

<yellow>	if (val)</yellow>
		return -EINVAL;

<yellow>	mutex_lock(&kvm_lock);</yellow>
	list_for_each_entry(kvm, &amp;vm_list, vm_list) {
<yellow>		kvm_clear_stat_per_vcpu(kvm, offset);</yellow>
	}
<yellow>	mutex_unlock(&kvm_lock);</yellow>

	return 0;
<yellow>}</yellow>

<yellow>DEFINE_SIMPLE_ATTRIBUTE(vcpu_stat_fops, vcpu_stat_get, vcpu_stat_clear,</yellow>
			&quot;%llu\n&quot;);
<yellow>DEFINE_SIMPLE_ATTRIBUTE(vcpu_stat_readonly_fops, vcpu_stat_get, NULL, "%llu\n");</yellow>

static void kvm_uevent_notify_change(unsigned int type, struct kvm *kvm)
{
	struct kobj_uevent_env *env;
	unsigned long long created, active;

<blue>	if (!kvm_dev.this_device || !kvm)</blue>
		return;

<blue>	mutex_lock(&kvm_lock);</blue>
	if (type == KVM_EVENT_CREATE_VM) {
<blue>		kvm_createvm_count++;</blue>
		kvm_active_vms++;
	} else if (type == KVM_EVENT_DESTROY_VM) {
<yellow>		kvm_active_vms--;</yellow>
	}
	created = kvm_createvm_count;
	active = kvm_active_vms;
	mutex_unlock(&amp;kvm_lock);

	env = kzalloc(sizeof(*env), GFP_KERNEL_ACCOUNT);
	if (!env)
		return;

<blue>	add_uevent_var(env, "CREATED=%llu", created);</blue>
	add_uevent_var(env, &quot;COUNT=%llu&quot;, active);

	if (type == KVM_EVENT_CREATE_VM) {
		add_uevent_var(env, &quot;EVENT=create&quot;);
		kvm-&gt;userspace_pid = task_pid_nr(current);
	} else if (type == KVM_EVENT_DESTROY_VM) {
		add_uevent_var(env, &quot;EVENT=destroy&quot;);
	}
<blue>	add_uevent_var(env, "PID=%d", kvm->userspace_pid);</blue>

	if (!IS_ERR(kvm-&gt;debugfs_dentry)) {
<blue>		char *tmp, *p = kmalloc(PATH_MAX, GFP_KERNEL_ACCOUNT);</blue>

		if (p) {
<blue>			tmp = dentry_path_raw(kvm->debugfs_dentry, p, PATH_MAX);</blue>
			if (!IS_ERR(tmp))
<blue>				add_uevent_var(env, "STATS_PATH=%s", tmp);</blue>
<blue>			kfree(p);</blue>
		}
	}
	/* no need for checks, since we are adding at most only 5 keys */
<blue>	env->envp[env->envp_idx++] = NULL;</blue>
	kobject_uevent_env(&amp;kvm_dev.this_device-&gt;kobj, KOBJ_CHANGE, env-&gt;envp);
	kfree(env);
<blue>}</blue>

static void kvm_init_debug(void)
{
	const struct file_operations *fops;
	const struct _kvm_stats_desc *pdesc;
	int i;

	kvm_debugfs_dir = debugfs_create_dir(&quot;kvm&quot;, NULL);

	for (i = 0; i &lt; kvm_vm_stats_header.num_desc; ++i) {
		pdesc = &amp;kvm_vm_stats_desc[i];
<yellow>		if (kvm_stats_debugfs_mode(pdesc) & 0222)</yellow>
			fops = &amp;vm_stat_fops;
		else
			fops = &amp;vm_stat_readonly_fops;
<yellow>		debugfs_create_file(pdesc->name, kvm_stats_debugfs_mode(pdesc),</yellow>
				kvm_debugfs_dir,
<yellow>				(void *)(long)pdesc->desc.offset, fops);</yellow>
	}

<yellow>	for (i = 0; i < kvm_vcpu_stats_header.num_desc; ++i) {</yellow>
		pdesc = &amp;kvm_vcpu_stats_desc[i];
<yellow>		if (kvm_stats_debugfs_mode(pdesc) & 0222)</yellow>
			fops = &amp;vcpu_stat_fops;
		else
			fops = &amp;vcpu_stat_readonly_fops;
		debugfs_create_file(pdesc-&gt;name, kvm_stats_debugfs_mode(pdesc),
				kvm_debugfs_dir,
<yellow>				(void *)(long)pdesc->desc.offset, fops);</yellow>
	}
}

static int kvm_suspend(void)
{
<yellow>	if (kvm_usage_count)</yellow>
<yellow>		hardware_disable_nolock(NULL);</yellow>
	return 0;
<yellow>}</yellow>

static void kvm_resume(void)
{
<yellow>	if (kvm_usage_count) {</yellow>
		lockdep_assert_not_held(&amp;kvm_count_lock);
<yellow>		hardware_enable_nolock(NULL);</yellow>
	}
<yellow>}</yellow>

static struct syscore_ops kvm_syscore_ops = {
	.suspend = kvm_suspend,
	.resume = kvm_resume,
};

static inline
struct kvm_vcpu *preempt_notifier_to_vcpu(struct preempt_notifier *pn)
{
	return container_of(pn, struct kvm_vcpu, preempt_notifier);
}

static void kvm_sched_in(struct preempt_notifier *pn, int cpu)
{
	struct kvm_vcpu *vcpu = preempt_notifier_to_vcpu(pn);

<blue>	WRITE_ONCE(vcpu->preempted, false);</blue>
	WRITE_ONCE(vcpu-&gt;ready, false);

	__this_cpu_write(kvm_running_vcpu, vcpu);
	kvm_arch_sched_in(vcpu, cpu);
	kvm_arch_vcpu_load(vcpu, cpu);
}

static void kvm_sched_out(struct preempt_notifier *pn,
			  struct task_struct *next)
{
	struct kvm_vcpu *vcpu = preempt_notifier_to_vcpu(pn);

<yellow>	if (current->on_rq) {</yellow>
<yellow>		WRITE_ONCE(vcpu->preempted, true);</yellow>
		WRITE_ONCE(vcpu-&gt;ready, true);
	}
<yellow>	kvm_arch_vcpu_put(vcpu);</yellow>
	__this_cpu_write(kvm_running_vcpu, NULL);
}

/**
 * kvm_get_running_vcpu - get the vcpu running on the current CPU.
 *
 * We can disable preemption locally around accessing the per-CPU variable,
 * and use the resolved vcpu pointer after enabling preemption again,
 * because even if the current thread is migrated to another CPU, reading
 * the per-CPU value later will give us the same value as we update the
 * per-CPU variable in the preempt notifier handlers.
 */
struct kvm_vcpu *kvm_get_running_vcpu(void)
{
	struct kvm_vcpu *vcpu;

<blue>	preempt_disable();</blue>
	vcpu = __this_cpu_read(kvm_running_vcpu);
<blue>	preempt_enable();</blue>

	return vcpu;
<yellow>}</yellow>
EXPORT_SYMBOL_GPL(kvm_get_running_vcpu);

/**
 * kvm_get_running_vcpus - get the per-CPU array of currently running vcpus.
 */
struct kvm_vcpu * __percpu *kvm_get_running_vcpus(void)
{
        return &amp;kvm_running_vcpu;
<yellow>}</yellow>

#ifdef CONFIG_GUEST_PERF_EVENTS
static unsigned int kvm_guest_state(void)
{
<yellow>	struct kvm_vcpu *vcpu = kvm_get_running_vcpu();</yellow>
	unsigned int state;

<yellow>	if (!kvm_arch_pmi_in_guest(vcpu))</yellow>
<yellow>		return 0;</yellow>

	state = PERF_GUEST_ACTIVE;
<yellow>	if (!kvm_arch_vcpu_in_kernel(vcpu))</yellow>
<yellow>		state |= PERF_GUEST_USER;</yellow>

	return state;
}

static unsigned long kvm_guest_get_ip(void)
{
<yellow>	struct kvm_vcpu *vcpu = kvm_get_running_vcpu();</yellow>

	/* Retrieving the IP must be guarded by a call to kvm_guest_state(). */
<yellow>	if (WARN_ON_ONCE(!kvm_arch_pmi_in_guest(vcpu)))</yellow>
<yellow>		return 0;</yellow>

<yellow>	return kvm_arch_vcpu_get_ip(vcpu);</yellow>
<yellow>}</yellow>

static struct perf_guest_info_callbacks kvm_guest_cbs = {
	.state			= kvm_guest_state,
	.get_ip			= kvm_guest_get_ip,
	.handle_intel_pt_intr	= NULL,
};

void kvm_register_perf_callbacks(unsigned int (*pt_intr_handler)(void))
{
	kvm_guest_cbs.handle_intel_pt_intr = pt_intr_handler;
<yellow>	perf_register_guest_info_callbacks(&kvm_guest_cbs);</yellow>
}
void kvm_unregister_perf_callbacks(void)
{
<yellow>	perf_unregister_guest_info_callbacks(&kvm_guest_cbs);</yellow>
}
#endif

struct kvm_cpu_compat_check {
	void *opaque;
	int *ret;
};

static void check_processor_compat(void *data)
{
	struct kvm_cpu_compat_check *c = data;

<yellow>	*c->ret = kvm_arch_check_processor_compat(c->opaque);</yellow>
}

int kvm_init(void *opaque, unsigned vcpu_size, unsigned vcpu_align,
		  struct module *module)
<yellow>{</yellow>
	struct kvm_cpu_compat_check c;
	int r;
	int cpu;

<yellow>	r = kvm_arch_init(opaque);</yellow>
	if (r)
		goto out_fail;

	/*
	 * kvm_arch_init makes sure there&#x27;s at most one caller
	 * for architectures that support multiple implementations,
	 * like intel and amd on x86.
	 * kvm_arch_init must be called before kvm_irqfd_init to avoid creating
	 * conflicts in case kvm is already setup for another implementation.
	 */
<yellow>	r = kvm_irqfd_init();</yellow>
	if (r)
		goto out_irqfd;

<yellow>	if (!zalloc_cpumask_var(&cpus_hardware_enabled, GFP_KERNEL)) {</yellow>
<yellow>		r = -ENOMEM;</yellow>
		goto out_free_0;
	}

<yellow>	r = kvm_arch_hardware_setup(opaque);</yellow>
	if (r &lt; 0)
		goto out_free_1;

	c.ret = &amp;r;
<yellow>	c.opaque = opaque;</yellow>
<yellow>	for_each_online_cpu(cpu) {</yellow>
<yellow>		smp_call_function_single(cpu, check_processor_compat, &c, 1);</yellow>
		if (r &lt; 0)
			goto out_free_2;
	}

<yellow>	r = cpuhp_setup_state_nocalls(CPUHP_AP_KVM_STARTING, "kvm/cpu:starting",</yellow>
				      kvm_starting_cpu, kvm_dying_cpu);
	if (r)
		goto out_free_2;
<yellow>	register_reboot_notifier(&kvm_reboot_notifier);</yellow>

	/* A kmem cache lets us meet the alignment requirements of fx_save. */
	if (!vcpu_align)
		vcpu_align = __alignof__(struct kvm_vcpu);
	kvm_vcpu_cache =
<yellow>		kmem_cache_create_usercopy("kvm_vcpu", vcpu_size, vcpu_align,</yellow>
					   SLAB_ACCOUNT,
					   offsetof(struct kvm_vcpu, arch),
					   offsetofend(struct kvm_vcpu, stats_id)
					   - offsetof(struct kvm_vcpu, arch),
					   NULL);
	if (!kvm_vcpu_cache) {
<yellow>		r = -ENOMEM;</yellow>
		goto out_free_3;
	}

<yellow>	for_each_possible_cpu(cpu) {</yellow>
<yellow>		if (!alloc_cpumask_var_node(&per_cpu(cpu_kick_mask, cpu),</yellow>
					    GFP_KERNEL, cpu_to_node(cpu))) {
<yellow>			r = -ENOMEM;</yellow>
			goto out_free_4;
		}
	}

<yellow>	r = kvm_async_pf_init();</yellow>
	if (r)
		goto out_free_4;

<yellow>	kvm_chardev_ops.owner = module;</yellow>

	r = misc_register(&amp;kvm_dev);
	if (r) {
		pr_err(&quot;kvm: misc device register failed\n&quot;);
		goto out_unreg;
	}

<yellow>	register_syscore_ops(&kvm_syscore_ops);</yellow>

	kvm_preempt_ops.sched_in = kvm_sched_in;
	kvm_preempt_ops.sched_out = kvm_sched_out;

<yellow>	kvm_init_debug();</yellow>

<yellow>	r = kvm_vfio_ops_init();</yellow>
<yellow>	WARN_ON(r);</yellow>

	return 0;

out_unreg:
	kvm_async_pf_deinit();
out_free_4:
<yellow>	for_each_possible_cpu(cpu)</yellow>
<yellow>		free_cpumask_var(per_cpu(cpu_kick_mask, cpu));</yellow>
<yellow>	kmem_cache_destroy(kvm_vcpu_cache);</yellow>
out_free_3:
<yellow>	unregister_reboot_notifier(&kvm_reboot_notifier);</yellow>
	cpuhp_remove_state_nocalls(CPUHP_AP_KVM_STARTING);
out_free_2:
<yellow>	kvm_arch_hardware_unsetup();</yellow>
out_free_1:
<yellow>	free_cpumask_var(cpus_hardware_enabled);</yellow>
out_free_0:
<yellow>	kvm_irqfd_exit();</yellow>
out_irqfd:
<yellow>	kvm_arch_exit();</yellow>
out_fail:
	return r;
}
EXPORT_SYMBOL_GPL(kvm_init);

void kvm_exit(void)
{
	int cpu;

<yellow>	debugfs_remove_recursive(kvm_debugfs_dir);</yellow>
	misc_deregister(&amp;kvm_dev);
<yellow>	for_each_possible_cpu(cpu)</yellow>
<yellow>		free_cpumask_var(per_cpu(cpu_kick_mask, cpu));</yellow>
<yellow>	kmem_cache_destroy(kvm_vcpu_cache);</yellow>
	kvm_async_pf_deinit();
	unregister_syscore_ops(&amp;kvm_syscore_ops);
	unregister_reboot_notifier(&amp;kvm_reboot_notifier);
	cpuhp_remove_state_nocalls(CPUHP_AP_KVM_STARTING);
	on_each_cpu(hardware_disable_nolock, NULL, 1);
	kvm_arch_hardware_unsetup();
	kvm_arch_exit();
	kvm_irqfd_exit();
	free_cpumask_var(cpus_hardware_enabled);
	kvm_vfio_ops_exit();
}
EXPORT_SYMBOL_GPL(kvm_exit);

struct kvm_vm_worker_thread_context {
	struct kvm *kvm;
	struct task_struct *parent;
	struct completion init_done;
	kvm_vm_thread_fn_t thread_fn;
	uintptr_t data;
	int err;
};

static int kvm_vm_worker_thread(void *context)
{
	/*
	 * The init_context is allocated on the stack of the parent thread, so
	 * we have to locally copy anything that is needed beyond initialization
	 */
	struct kvm_vm_worker_thread_context *init_context = context;
	struct task_struct *parent;
<yellow>	struct kvm *kvm = init_context->kvm;</yellow>
	kvm_vm_thread_fn_t thread_fn = init_context-&gt;thread_fn;
	uintptr_t data = init_context-&gt;data;
	int err;

	err = kthread_park(current);
	/* kthread_park(current) is never supposed to return an error */
<yellow>	WARN_ON(err != 0);</yellow>
	if (err)
		goto init_complete;

<yellow>	err = cgroup_attach_task_all(init_context->parent, current);</yellow>
	if (err) {
		kvm_err(&quot;%s: cgroup_attach_task_all failed with err %d\n&quot;,
			__func__, err);
		goto init_complete;
	}

<yellow>	set_user_nice(current, task_nice(init_context->parent));</yellow>

init_complete:
<yellow>	init_context->err = err;</yellow>
	complete(&amp;init_context-&gt;init_done);
	init_context = NULL;

	if (err)
		goto out;

	/* Wait to be woken up by the spawner before proceeding. */
	kthread_parkme();

	if (!kthread_should_stop())
<yellow>		err = thread_fn(kvm, data);</yellow>

out:
	/*
	 * Move kthread back to its original cgroup to prevent it lingering in
	 * the cgroup of the VM process, after the latter finishes its
	 * execution.
	 *
	 * kthread_stop() waits on the &#x27;exited&#x27; completion condition which is
	 * set in exit_mm(), via mm_release(), in do_exit(). However, the
	 * kthread is removed from the cgroup in the cgroup_exit() which is
	 * called after the exit_mm(). This causes the kthread_stop() to return
	 * before the kthread actually quits the cgroup.
	 */
<yellow>	rcu_read_lock();</yellow>
	parent = rcu_dereference(current-&gt;real_parent);
<yellow>	get_task_struct(parent);</yellow>
	rcu_read_unlock();
	cgroup_attach_task_all(parent, current);
<yellow>	put_task_struct(parent);</yellow>

	return err;
<yellow>}</yellow>

int kvm_vm_create_worker_thread(struct kvm *kvm, kvm_vm_thread_fn_t thread_fn,
				uintptr_t data, const char *name,
				struct task_struct **thread_ptr)
<blue>{</blue>
<blue>	struct kvm_vm_worker_thread_context init_context = {};</blue>
	struct task_struct *thread;

	*thread_ptr = NULL;
	init_context.kvm = kvm;
	init_context.parent = current;
	init_context.thread_fn = thread_fn;
	init_context.data = data;
	init_completion(&amp;init_context.init_done);

<blue>	thread = kthread_run(kvm_vm_worker_thread, &init_context,</blue>
			     &quot;%s-%d&quot;, name, task_pid_nr(current));
	if (IS_ERR(thread))
<yellow>		return PTR_ERR(thread);</yellow>

	/* kthread_run is never supposed to return NULL */
<yellow>	WARN_ON(thread == NULL);</yellow>

<blue>	wait_for_completion(&init_context.init_done);</blue>

	if (!init_context.err)
<blue>		*thread_ptr = thread;</blue>

	return init_context.err;
}


</code></pre></td></tr></table>
</body>
</html>
